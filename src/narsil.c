#include "bulk.h"

/**
 * \file cave.c
 * \brief chunk allocation and utility functions
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
struct feature *f_info;
struct chunk *cave = NULL;
/**
 * Global array for looping through the "keypad directions".
 */
const int16_t ddd[9] =
{ 2, 8, 6, 4, 3, 1, 9, 7, 5 };
/**
 * Hack -- allow quick "cycling" through the legal directions
 */
const uint8_t cycle[] =
{ 1, 2, 3, 6, 9, 8, 7, 4, 1, 2, 3, 6, 9, 8, 7, 4, 1 };
/**
 * Hack -- map each direction into the "middle" of the "cycle[]" array
 */
const uint8_t chome[] =
{ 0, 8, 9, 10, 7, 0, 11, 6, 5, 4 };
/**
 * Global arrays for converting "keypad direction" into "offsets".
 */
const int16_t ddx[10] =
{ 0, -1, 0, 1, -1, 0, 1, -1, 0, 1 };
const int16_t ddy[10] =
{ 0, 1, 1, 1, 0, 0, 0, -1, -1, -1 };
const struct loc ddgrid[10] =
{ {0, 0}, {-1, 1}, {0, 1}, {1, 1}, {-1, 0}, {0, 0}, {1, 0}, {-1, -1}, {0, -1},
  {1, -1} };
/**
 * Global arrays for optimizing "ddx[ddd[i]]", "ddy[ddd[i]]" and
 * "loc(ddx[ddd[i]], ddy[ddd[i]])".
 *
 * This means that each entry in this array corresponds to the direction
 * with the same array index in ddd[].
 */
const int16_t ddx_ddd[9] =
{ 0, 0, 1, -1, 1, -1, 1, -1, 0 };
const int16_t ddy_ddd[9] =
{ 1, -1, 0, 0, 1, 1, -1, -1, 0 };
const struct loc ddgrid_ddd[9] =
{{0, 1}, {0, -1}, {1, 0}, {-1, 0}, {1, 1}, {-1, 1}, {1, -1}, {-1, -1}, {0, 0}};
/* Can mult these by 45 deg or 1.5 o'clock e.g. [6] -> 270 deg or 9 o'clock */
const int16_t clockwise_ddd[9] =
{ 8, 9, 6, 3, 2, 1, 4, 7, 5 };
const struct loc clockwise_grid[9] =
{{0, -1}, {1, -1}, {1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, 0}};
/**
 * Hack -- Precompute a bunch of calls to distance().
 *
 * The pair of arrays dist_offsets_y[n] and dist_offsets_x[n] contain the
 * offsets of all the locations with a distance of n from a central point,
 * with an offset of (0,0) indicating no more offsets at this distance.
 *
 * This is, of course, fairly unreadable, but it eliminates multiple loops
 * from the previous version.
 *
 * It is probably better to replace these arrays with code to compute
 * the relevant arrays, even if the storage is pre-allocated in hard
 * coded sizes.  At the very least, code should be included which is
 * able to generate and dump these arrays (ala "los()").  XXX XXX XXX
 */
static const int d_off_y_0[] =
{ 0 };
static const int d_off_x_0[] =
{ 0 };
static const int d_off_y_1[] =
{ -1, -1, -1, 0, 0, 1, 1, 1, 0 };
static const int d_off_x_1[] =
{ -1, 0, 1, -1, 1, -1, 0, 1, 0 };
static const int d_off_y_2[] =
{ -1, -1, -2, -2, -2, 0, 0, 1, 1, 2, 2, 2, 0 };
static const int d_off_x_2[] =
{ -2, 2, -1, 0, 1, -2, 2, -2, 2, -1, 0, 1, 0 };
static const int d_off_y_3[] =
{ -1, -1, -2, -2, -3, -3, -3, 0, 0, 1, 1, 2, 2,
  3, 3, 3, 0 };
static const int d_off_x_3[] =
{ -3, 3, -2, 2, -1, 0, 1, -3, 3, -3, 3, -2, 2,
  -1, 0, 1, 0 };
static const int d_off_y_4[] =
{ -1, -1, -2, -2, -3, -3, -3, -3, -4, -4, -4, 0,
  0, 1, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 0 };
static const int d_off_x_4[] =
{ -4, 4, -3, 3, -2, -3, 2, 3, -1, 0, 1, -4, 4,
  -4, 4, -3, 3, -2, -3, 2, 3, -1, 0, 1, 0 };
static const int d_off_y_5[] =
{ -1, -1, -2, -2, -3, -3, -4, -4, -4, -4, -5, -5,
  -5, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 4, 4, 5, 5,
  5, 0 };
static const int d_off_x_5[] =
{ -5, 5, -4, 4, -4, 4, -2, -3, 2, 3, -1, 0, 1,
  -5, 5, -5, 5, -4, 4, -4, 4, -2, -3, 2, 3, -1,
  0, 1, 0 };
static const int d_off_y_6[] =
{ -1, -1, -2, -2, -3, -3, -4, -4, -5, -5, -5, -5,
  -6, -6, -6, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5,
  5, 5, 6, 6, 6, 0 };
static const int d_off_x_6[] =
{ -6, 6, -5, 5, -5, 5, -4, 4, -2, -3, 2, 3, -1,
  0, 1, -6, 6, -6, 6, -5, 5, -5, 5, -4, 4, -2,
  -3, 2, 3, -1, 0, 1, 0 };
static const int d_off_y_7[] =
{ -1, -1, -2, -2, -3, -3, -4, -4, -5, -5, -5, -5,
  -6, -6, -6, -6, -7, -7, -7, 0, 0, 1, 1, 2, 2, 3,
  3, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 0 };
static const int d_off_x_7[] =
{ -7, 7, -6, 6, -6, 6, -5, 5, -4, -5, 4, 5, -2,
  -3, 2, 3, -1, 0, 1, -7, 7, -7, 7, -6, 6, -6,
  6, -5, 5, -4, -5, 4, 5, -2, -3, 2, 3, -1, 0,
  1, 0 };
static const int d_off_y_8[] =
{ -1, -1, -2, -2, -3, -3, -4, -4, -5, -5, -6, -6,
  -6, -6, -7, -7, -7, -7, -8, -8, -8, 0, 0, 1, 1,
  2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7,
  8, 8, 8, 0 };
static const int d_off_x_8[] =
{ -8, 8, -7, 7, -7, 7, -6, 6, -6, 6, -4, -5, 4,
  5, -2, -3, 2, 3, -1, 0, 1, -8, 8, -8, 8, -7,
  7, -7, 7, -6, 6, -6, 6, -4, -5, 4, 5, -2, -3,
  2, 3, -1, 0, 1, 0 };
static const int d_off_y_9[] =
{ -1, -1, -2, -2, -3, -3, -4, -4, -5, -5, -6, -6,
  -7, -7, -7, -7, -8, -8, -8, -8, -9, -9, -9, 0,
  0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 7,
  7, 8, 8, 8, 8, 9, 9, 9, 0 };
static const int d_off_x_9[] =
{ -9, 9, -8, 8, -8, 8, -7, 7, -7, 7, -6, 6, -4,
  -5, 4, 5, -2, -3, 2, 3, -1, 0, 1, -9, 9, -9,
  9, -8, 8, -8, 8, -7, 7, -7, 7, -6, 6, -4, -5,
  4, 5, -2, -3, 2, 3, -1, 0, 1, 0 };
const int *dist_offsets_y[10] =
{
 d_off_y_0, d_off_y_1, d_off_y_2, d_off_y_3, d_off_y_4,
 d_off_y_5, d_off_y_6, d_off_y_7, d_off_y_8, d_off_y_9
};
const int *dist_offsets_x[10] =
{
 d_off_x_0, d_off_x_1, d_off_x_2, d_off_x_3, d_off_x_4,
 d_off_x_5, d_off_x_6, d_off_x_7, d_off_x_8, d_off_x_9
};
/**
 * Given a central direction at position [dir #][0], return a series
 * of directions radiating out on both sides from the central direction
 * all the way back to its rear.
 *
 * Side directions come in pairs; for example, directions '1' and '3'
 * flank direction '2'.  The code should know which side to consider
 * first.  If the left, it must add 10 to the central direction to
 * access the second part of the table.
 */
const uint8_t side_dirs[20][8] = {
 {0, 0, 0, 0, 0, 0, 0, 0}, /* bias right */
 {1, 4, 2, 7, 3, 8, 6, 9},
 {2, 1, 3, 4, 6, 7, 9, 8},
 {3, 2, 6, 1, 9, 4, 8, 7},
 {4, 7, 1, 8, 2, 9, 3, 6},
 {5, 5, 5, 5, 5, 5, 5, 5},
 {6, 3, 9, 2, 8, 1, 7, 4},
 {7, 8, 4, 9, 1, 6, 2, 3},
 {8, 9, 7, 6, 4, 3, 1, 2},
 {9, 6, 8, 3, 7, 2, 4, 1},
 {0, 0, 0, 0, 0, 0, 0, 0}, /* bias left */
 {1, 2, 4, 3, 7, 6, 8, 9},
 {2, 3, 1, 6, 4, 9, 7, 8},
 {3, 6, 2, 9, 1, 8, 4, 7},
 {4, 1, 7, 2, 8, 3, 9, 6},
 {5, 5, 5, 5, 5, 5, 5, 5},
 {6, 9, 3, 8, 2, 7, 1, 4},
 {7, 4, 8, 1, 9, 2, 6, 3},
 {8, 7, 9, 4, 6, 1, 3, 2},
 {9, 8, 6, 7, 3, 4, 2, 1}
};
/**
 * Given a "start" and "finish" location, extract a "direction",
 * which will move one step from the "start" towards the "finish".
 *
 * Note that we use "diagonal" motion whenever possible.
 *
 * We return DIR_NONE if no motion is needed.
 */
int motion_dir(struct loc start, struct loc finish)
{
 /* No movement required */
 if (loc_eq(start, finish)) return (DIR_NONE);
 /* South or North */
 if (start.x == finish.x) return ((start.y < finish.y) ? DIR_S : DIR_N);
 /* East or West */
 if (start.y == finish.y) return ((start.x < finish.x) ? DIR_E : DIR_W);
 /* South-east or South-west */
 if (start.y < finish.y) return ((start.x < finish.x) ? DIR_SE : DIR_SW);
 /* North-east or North-west */
 if (start.y > finish.y) return ((start.x < finish.x) ? DIR_NE : DIR_NW);
 /* Paranoia */
 return (DIR_NONE);
}
/**
 * Given a grid and a direction, extract the adjacent grid in that direction
 */
struct loc next_grid(struct loc grid, int dir)
{
 return loc(grid.x + ddgrid[dir].x, grid.y + ddgrid[dir].y);
}
/**
 * Takes a delta coordinates and returns a direction.
 * e.g. (1,0) is south, which is direction 2.
 */
int dir_from_delta(int delta_y, int delta_x)
{
 int16_t dird[3][3] = { { 7, 8, 9 },
         { 4, 5, 6 },
         { 1, 2, 3 } };
 assert((ABS(delta_y) < 2) && (ABS(delta_x) < 2));
 return (dird[delta_y + 1][delta_x + 1]);
}
/**
 * Gives the overall direction from point 1 to point 2.
 * Uses orthogonals when breaking ties.
 */
int rough_direction(struct loc grid1, struct loc grid2)
{
 /* These represent the displacement */
    int delta_y = grid2.y - grid1.y;
    int delta_x = grid2.x - grid1.x;
 /* These represent the direction */
    int dy, dx;
    /* Determine the main direction from the source to the target */
    if (delta_y == 0) {
  dy = 0;
    } else {
  dy = (delta_y > 0) ? 1 : -1;
    }
    if (delta_x == 0) {
  dx = 0;
    } else {
  dx = (delta_x > 0) ? 1 : -1;
    }
 /* See if one direction swamps the other */
    if ((delta_x != 0) && (ABS(delta_y) / ABS(delta_x) >= 2)) dx = 0;
    if ((delta_y != 0) && (ABS(delta_x) / ABS(delta_y) >= 2)) dy = 0;
    return (dir_from_delta(dy, dx));
}
/**
 * Find a terrain feature index by its printable name
 */
int lookup_feat(const char *name)
{
 int i;
 /* Look for it */
 for (i = 0; i < FEAT_MAX; i++) {
  struct feature *feat = &f_info[i];
  if (!feat->name)
   continue;
  /* Test for equality */
  if (streq(name, feat->name))
   return i;
 }
 /* Fail horribly */
 quit_fmt("Failed to find terrain feature %s", name);
 return -1;
}
static const char *feat_code_list[] = {
/**
 * \file list-terrain.h
 * \brief List the terrain (feature) types that can appear
 *
 * These are how the code and data files refer to terrain.  Any changes will
 * break savefiles.  Note that the terrain code is stored as an unsigned 8-bit
 * integer so there can be at most 256 types of terrain.  Flags below start
 * from zero on line 13, so a terrain's sequence number is its line number
 * minus 13.
 */
/* symbol */
"NONE", /* nothing/unknown */
"FLOOR", /* open floor */
"CLOSED", /* closed door */
"OPEN", /* open door */
"BROKEN", /* broken door */
"LESS", /* up staircase */
"MORE", /* down staircase */
"LESS_SHAFT", /* up shaft */
"MORE_SHAFT", /* down shaft */
"CHASM", /* chasm */
"SECRET", /* secret door */
"RUBBLE", /* impassable rubble */
"QUARTZ", /* quartz vein wall */
"GRANITE", /* granite wall */
"PERM", /* permanent wall */
"FORGE",
"FORGE_GOOD",
"FORGE_UNIQUE",
"PIT",
"SPIKED_PIT",

 NULL
};
/**
 * Find a terrain feature by its code name.
 */
int lookup_feat_code(const char *code)
{
 int i = 0;
 while (1) {
  assert(i >= 0 && i < (int) N_ELEMENTS(feat_code_list));
  if (!feat_code_list[i]) {
   return -1;
  }
  if (streq(code, feat_code_list[i])) {
   break;
  }
  ++i;
 }
 return i;
}
/**
 * Return the code name of feature, specified as an index.  Will return NULL
 * if the index is invalid.
 */
const char *get_feat_code_name(int idx)
{
 return (idx < 0 || idx >= FEAT_MAX) ? NULL : feat_code_list[idx];
}
/**
 * Allocate a new flow
 */
void flow_new(struct chunk *c, struct flow *flow) {
 int y;
 flow->grids = mem_zalloc(c->height * sizeof(uint16_t*));
 for (y = 0; y < c->height; y++) {
  flow->grids[y] = mem_zalloc(c->width * sizeof(uint16_t));
 }
}
/**
 * Free a flow
 */
void flow_free(struct chunk *c, struct flow *flow) {
 int y;
 for (y = 0; y < c->height; y++) {
  mem_free(flow->grids[y]);
 }
 mem_free(flow->grids);
}
/**
 * Allocate a new chunk of the world
 */
struct chunk *cave_new(int height, int width) {
 int y, x;
 struct chunk *c = mem_zalloc(sizeof *c);
 c->height = height;
 c->width = width;
 c->feat_count = mem_zalloc((FEAT_MAX + 1) * sizeof(int));
 c->squares = mem_zalloc(c->height * sizeof(struct square*));
 for (y = 0; y < c->height; y++) {
  c->squares[y] = mem_zalloc(c->width * sizeof(struct square));
  for (x = 0; x < c->width; x++) {
   c->squares[y][x].info = mem_zalloc(SQUARE_SIZE * sizeof(bitflag));
  }
 }
 flow_new(c, &c->player_noise);
 flow_new(c, &c->monster_noise);
 flow_new(c, &c->scent);
 c->objects = mem_zalloc(OBJECT_LIST_SIZE * sizeof(struct object*));
 c->obj_max = OBJECT_LIST_SIZE - 1;
 c->monsters = mem_zalloc(z_info->level_monster_max *sizeof(struct monster));
 c->mon_max = 1;
 c->mon_current = -1;
 c->monster_groups = mem_zalloc(z_info->level_monster_max *
           sizeof(struct monster_group*));
 c->turn = turn;
 return c;
}
/**
 * Free a chunk
 */
void cave_free(struct chunk *c) {
 struct chunk *p_c = (c == cave && player) ? player->cave : NULL;
 int y, x, i;
 /* Look for orphaned objects and delete them. */
 for (i = 1; i < c->obj_max; i++) {
  if (c->objects[i] && loc_is_zero(c->objects[i]->grid)) {
   object_delete(c, p_c, &c->objects[i]);
  }
 }
 for (y = 0; y < c->height; y++) {
  for (x = 0; x < c->width; x++) {
   mem_free(c->squares[y][x].info);
   if (c->squares[y][x].trap)
    square_free_trap(c, loc(x, y));
   if (c->squares[y][x].obj)
    object_pile_free(c, p_c, c->squares[y][x].obj);
  }
  mem_free(c->squares[y]);
 }
 mem_free(c->squares);
 flow_free(c, &c->player_noise);
 flow_free(c, &c->monster_noise);
 flow_free(c, &c->scent);
 mem_free(c->feat_count);
 mem_free(c->objects);
 mem_free(c->monsters);
 mem_free(c->monster_groups);
 if (c->name)
  string_free(c->name);
 if (c->vault_name)
  string_free(c->vault_name);
 mem_free(c);
}
/**
 * Enter an object in the list of objects for the current level/chunk.  This
 * function is robust against listing of duplicates or non-objects
 */
void list_object(struct chunk *c, struct object *obj)
{
 int i, newsize;
 /* Check for duplicates and objects already deleted or combined */
 if (!obj) return;
 for (i = 1; i < c->obj_max; i++)
  if (c->objects[i] == obj)
   return;
 /* Put objects in holes in the object list */
 for (i = 1; i < c->obj_max; i++) {
  /* If there is a known object, skip this slot */
  if ((c == cave) && player->cave && player->cave->objects[i]) {
   continue;
  }
  /* Put the object in a hole */
  if (c->objects[i] == NULL) {
   c->objects[i] = obj;
   obj->oidx = i;
   return;
  }
 }
 /* Extend the list */
 newsize = (c->obj_max + OBJECT_LIST_INCR + 1) * sizeof(struct object*);
 c->objects = mem_realloc(c->objects, newsize);
 c->objects[c->obj_max] = obj;
 obj->oidx = c->obj_max;
 for (i = c->obj_max + 1; i <= c->obj_max + OBJECT_LIST_INCR; i++)
  c->objects[i] = NULL;
 c->obj_max += OBJECT_LIST_INCR;
 /* If we're on the current level, extend the known list */
 if ((c == cave) && player->cave) {
  player->cave->objects = mem_realloc(player->cave->objects, newsize);
  for (i = player->cave->obj_max; i <= c->obj_max; i++)
   player->cave->objects[i] = NULL;
  player->cave->obj_max = c->obj_max;
 }
}
/**
 * Remove an object from the list of objects for the current level/chunk.  This
 * function is robust against delisting of unlisted objects.
 */
void delist_object(struct chunk *c, struct object *obj)
{
 if (!obj->oidx) return;
 assert(c->objects[obj->oidx] == obj);
 /* Don't delist an actual object if it still has a listed known object */
 if ((c == cave) && player->cave->objects[obj->oidx]) return;
 c->objects[obj->oidx] = NULL;
 obj->oidx = 0;
}
/**
 * Check consistency of an object list or a pair of object lists
 *
 * If one list, check the listed objects relate to locations of
 * objects correctly
 */
void object_lists_check_integrity(struct chunk *c, struct chunk *c_k)
{
 int i;
 if (c_k) {
  assert(c->obj_max == c_k->obj_max);
  for (i = 0; i < c->obj_max; i++) {
   struct object *obj = c->objects[i];
   struct object *known_obj = c_k->objects[i];
   if (obj) {
    assert(obj->oidx == i);
    if (!loc_is_zero(obj->grid))
     assert(pile_contains(square_object(c, obj->grid), obj));
   }
   if (known_obj) {
    assert (obj);
    if (player->upkeep->playing) {
     assert(known_obj == obj->known);
    }
    if (!loc_is_zero(known_obj->grid))
     assert (pile_contains(square_object(c_k, known_obj->grid),
            known_obj));
    assert (known_obj->oidx == i);
   }
  }
 } else {
  for (i = 0; i < c->obj_max; i++) {
   struct object *obj = c->objects[i];
   if (obj) {
    assert(obj->oidx == i);
    if (!loc_is_zero(obj->grid))
     assert(pile_contains(square_object(c, obj->grid), obj));
   }
  }
 }
}
/**
 * Standard "find me a location" function, now with all legal outputs!
 *
 * Obtains a legal location within the given distance of the initial
 * location, and with "los()" from the source to destination location.
 *
 * This function is often called from inside a loop which searches for
 * locations while increasing the "d" distance.
 *
 * need_los determines whether line of sight is needed
 */
void scatter(struct chunk *c, struct loc *place, struct loc grid, int d,
    bool need_los)
{
 (void) scatter_ext(c, place, 1, grid, d, need_los, NULL);
}
/**
 * Try to find a given number of distinct, randomly selected, locations that
 * are within a given distance of a grid, fully in bounds, and, optionally,
 * are in the line of sight of the given grid and satisfy an additional
 * condition.
 * \param c Is the chunk to search.
 * \param places Points to the storage for the locations found.  That storage
 * must have space for at least n grids.
 * \param n Is the number of locations to find.
 * \param grid Is the location to use as the origin for the search.
 * \param d Is the maximum distance, in grids, that a location can be from
 * grid and still be accepted.
 * \param need_los If true, any locations found will also be in the line of
 * sight from grid.
 * \param pred If not NULL, evaluating that function at a found location, lct,
 * will return true, i.e. (*pred)(c, lct) will be true.
 * \return Return the number of locations found.  That number will be less
 * than or equal to n if n is not negative and will be zero if n is negative.
 */
int scatter_ext(struct chunk *c, struct loc *places, int n, struct loc grid,
  int d, bool need_los, bool (*pred)(struct chunk *, struct loc))
{
 int result = 0;
 /* Stores feasible locations. */
 struct loc *feas = mem_alloc(MIN(c->width, (1 + 2 * MAX(0, d)))
   * (size_t) MIN(c->height, (1 + 2 * MAX(0, d)))
   * sizeof(*feas));
 int nfeas = 0;
 struct loc g;
 /* Get the feasible locations. */
 for (g.y = grid.y - d; g.y <= grid.y + d; ++g.y) {
  for (g.x = grid.x - d; g.x <= grid.x + d; ++g.x) {
   if (!square_in_bounds_fully(c, g)) continue;
   if (d > 1 && distance(grid, g) > d) continue;
   if (need_los && !los(c, grid, g)) continue;
   if (pred && !(*pred)(c, g)) continue;
   feas[nfeas] = g;
   ++nfeas;
  }
 }
 /* Assemble the result. */
 while (result < n && nfeas > 0) {
  /* Choose one at random and append it to the outgoing list. */
  int choice = randint0(nfeas);
  places[result] = feas[choice];
  ++result;
  /* Shift the last feasible one to replace the one selected. */
  --nfeas;
  feas[choice] = feas[nfeas];
 }
 mem_free(feas);
 return result;
}
/**
 * Get a monster on the current level by its index.
 */
struct monster *cave_monster(struct chunk *c, int idx) {
 if (idx <= 0) return NULL;
 return &c->monsters[idx];
}
/**
 * The maximum number of monsters allowed in the level.
 */
int cave_monster_max(struct chunk *c) {
 return c->mon_max;
}
/**
 * The current number of monsters present on the level.
 */
int cave_monster_count(struct chunk *c) {
 return c->mon_cnt;
}
/**
 * Return the number of matching grids around (or under) the character.
 * \param grid If not NULL, *grid is set to the location of the last match.
 * \param test Is the predicate to use when testing for a match.
 * \param under If true, the character's grid is tested as well.
 * Only tests grids that are known and fully in bounds.
 */
int count_feats(struct loc *grid,
    bool (*test)(struct chunk *c, struct loc grid), bool under)
{
 int d;
 struct loc grid1;
 int count = 0; /* Count how many matches */
 /* Check around (and under) the character */
 for (d = 0; d < 9; d++) {
  /* if not searching under player continue */
  if ((d == 8) && !under) continue;
  /* Extract adjacent (legal) location */
  grid1 = loc_sum(player->grid, ddgrid_ddd[d]);
  /* Paranoia */
  if (!square_in_bounds_fully(cave, grid1)) continue;
  /* Must have knowledge */
  if (!square_isknown(cave, grid1)) continue;
  /* Not looking for this feature */
  if (!((*test)(cave, grid1))) continue;
  /* Count it */
  ++count;
  /* Remember the location of the last match */
  if (grid) {
   *grid = grid1;
  }
 }
 /* All done */
 return count;
}
/**
 * Return the number of matching grids around a location.
 * \param match If not NULL, *match is set to the location of the last match.
 * \param c Is the chunk to use.
 * \param grid Is the location whose neighbors will be tested.
 * \param test Is the predicate to use when testing for a match.
 * \param under If true, grid is tested as well.
 */
int count_neighbors(struct loc *match, struct chunk *c, struct loc grid,
 bool (*test)(struct chunk *c, struct loc grid), bool under)
{
 int dlim = (under) ? 9 : 8;
 int count = 0; /* Count how many matches */
 int d;
 struct loc grid1;
 /* Check the grid's neighbors and, if under is true, grid */
 for (d = 0; d < dlim; d++) {
  /* Extract adjacent (legal) location */
  grid1 = loc_sum(grid, ddgrid_ddd[d]);
  if (!square_in_bounds(c, grid1)) continue;
  /* Reject those that don't match */
  if (!((*test)(c, grid1))) continue;
  /* Count it */
  ++count;
  /* Remember the location of the last match */
  if (match) {
   *match = grid1;
  }
 }
 /* All done */
 return count;
}
/**
 * \file cave-fire.c
 * \brief Line-of-fire calculations
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * This whole file is just the code from cave.c in original Sil, lifted and
 * modified as needed (ie the bits that influence field-of-view are ripped out)
 * to provide the correct line-of-fire calculations.
 * 
 * At some point it should be translated into actual readable code.
 */
/**
 * Convert a "location" (Y,X) into a "grid" (G)
 */
/**
 * Convert a "grid" (G) into a "location" (Y)
 */
/**
 * Convert a "grid" (G) into a "location" (X)
 */
/**
 * Maximum number of grids in a single octant
 */
/**
 * Maximum number of slopes in a single octant
 */
/**
 * Mask of bits used in a single octant
 */
/**
 * The 'vinfo_type' structure
 */
struct vinfo_type
{
 int16_t grid[8];
 /* LOS slopes (up to 128) */
 uint32_t bits_3;
 uint32_t bits_2;
 uint32_t bits_1;
 uint32_t bits_0;
 /* Index of the first LOF slope */
 uint8_t slope_fire_index1;
 /* Index of the (possible) second LOF slope */
 uint8_t slope_fire_index2;
 struct vinfo_type *next_0;
 struct vinfo_type *next_1;
 uint8_t y;
 uint8_t x;
 uint8_t d;
 uint8_t r;
};
/**
 * The array of "vinfo" objects, initialized by "vinfo_init()"
 */
static struct vinfo_type vinfo[161];
/**
 * Slope scale factor
 */
/**
 * The actual slopes (for reference)
 */
/* Bit :     Slope   Grids */
/* --- :     -----   ----- */
/*   0 :      2439      21 */
/*   1 :      2564      21 */
/*   2 :      2702      21 */
/*   3 :      2857      21 */
/*   4 :      3030      21 */
/*   5 :      3225      21 */
/*   6 :      3448      21 */
/*   7 :      3703      21 */
/*   8 :      4000      21 */
/*   9 :      4347      21 */
/*  10 :      4761      21 */
/*  11 :      5263      21 */
/*  12 :      5882      21 */
/*  13 :      6666      21 */
/*  14 :      7317      22 */
/*  15 :      7692      20 */
/*  16 :      8108      21 */
/*  17 :      8571      21 */
/*  18 :      9090      20 */
/*  19 :      9677      21 */
/*  20 :     10344      21 */
/*  21 :     11111      20 */
/*  22 :     12000      21 */
/*  23 :     12820      22 */
/*  24 :     13043      22 */
/*  25 :     13513      22 */
/*  26 :     14285      20 */
/*  27 :     15151      22 */
/*  28 :     15789      22 */
/*  29 :     16129      22 */
/*  30 :     17241      22 */
/*  31 :     17647      22 */
/*  32 :     17948      23 */
/*  33 :     18518      22 */
/*  34 :     18918      22 */
/*  35 :     20000      19 */
/*  36 :     21212      22 */
/*  37 :     21739      22 */
/*  38 :     22580      22 */
/*  39 :     23076      22 */
/*  40 :     23809      22 */
/*  41 :     24137      22 */
/*  42 :     24324      23 */
/*  43 :     25714      23 */
/*  44 :     25925      23 */
/*  45 :     26315      23 */
/*  46 :     27272      22 */
/*  47 :     28000      23 */
/*  48 :     29032      23 */
/*  49 :     29411      23 */
/*  50 :     29729      24 */
/*  51 :     30434      23 */
/*  52 :     31034      23 */
/*  53 :     31428      23 */
/*  54 :     33333      18 */
/*  55 :     35483      23 */
/*  56 :     36000      23 */
/*  57 :     36842      23 */
/*  58 :     37142      24 */
/*  59 :     37931      24 */
/*  60 :     38461      24 */
/*  61 :     39130      24 */
/*  62 :     39393      24 */
/*  63 :     40740      24 */
/*  64 :     41176      24 */
/*  65 :     41935      24 */
/*  66 :     42857      23 */
/*  67 :     44000      24 */
/*  68 :     44827      24 */
/*  69 :     45454      23 */
/*  70 :     46666      24 */
/*  71 :     47368      24 */
/*  72 :     47826      24 */
/*  73 :     48148      24 */
/*  74 :     48387      24 */
/*  75 :     51515      25 */
/*  76 :     51724      25 */
/*  77 :     52000      25 */
/*  78 :     52380      25 */
/*  79 :     52941      25 */
/*  80 :     53846      25 */
/*  81 :     54838      25 */
/*  82 :     55555      24 */
/*  83 :     56521      25 */
/*  84 :     57575      26 */
/*  85 :     57894      25 */
/*  86 :     58620      25 */
/*  87 :     60000      23 */
/*  88 :     61290      25 */
/*  89 :     61904      25 */
/*  90 :     62962      25 */
/*  91 :     63636      25 */
/*  92 :     64705      25 */
/*  93 :     65217      25 */
/*  94 :     65517      25 */
/*  95 :     67741      26 */
/*  96 :     68000      26 */
/*  97 :     68421      26 */
/*  98 :     69230      26 */
/*  99 :     70370      26 */
/* 100 :     71428      25 */
/* 101 :     72413      26 */
/* 102 :     73333      26 */
/* 103 :     73913      26 */
/* 104 :     74193      27 */
/* 105 :     76000      26 */
/* 106 :     76470      26 */
/* 107 :     77777      25 */
/* 108 :     78947      26 */
/* 109 :     79310      26 */
/* 110 :     80952      26 */
/* 111 :     81818      26 */
/* 112 :     82608      26 */
/* 113 :     84000      26 */
/* 114 :     84615      26 */
/* 115 :     85185      26 */
/* 116 :     86206      27 */
/* 117 :     86666      27 */
/* 118 :     88235      27 */
/* 119 :     89473      27 */
/* 120 :     90476      27 */
/* 121 :     91304      27 */
/* 122 :     92000      27 */
/* 123 :     92592      27 */
/* 124 :     93103      28 */
/* 125 :    100000      13 */
/**
 * Forward declare
 */
typedef struct vinfo_hack vinfo_hack;
/**
 * Hard-coded version of z_info->max_sight etc for now - NRM
 */
/**
 * Hard-coded max fire grids - NRM
 */
/**
 * Versions of view array - NRM
 */
static uint16_t fire_g[1536];
static int fire_n = 0;
/**
 * Version of SQUARE_FIRE flags in old cave_info array - NRM
 */
static bool fire_info[256 * 55];
/**
 * Temporary data used by "vinfo_init()"
 *
 *	- Number of line of sight slopes
 *
 *	- Slope values
 *
 *	- Slope range for each grid
 */
struct vinfo_hack
{
 int num_slopes;
 long slopes[126];
 long slopes_min[20 + 1][20 + 1];
 long slopes_max[20 + 1][20 + 1];
};
/*
 * Current "comp" function for ang_sort()
 */
bool (*ang_sort_comp)(const void *u, const void *v, int a, int b);
/*
 * Current "swap" function for ang_sort()
 */
void (*ang_sort_swap)(void *u, void *v, int a, int b);
/**
 * Sorting hook -- comp function -- array of long's (see below)
 *
 * We use "u" to point to an array of long integers.
 */
static bool ang_sort_comp_hook_longs(const void *u, const void *v, int a, int b)
{
 long *x = (long*)(u);
 /* Unused parameter */
 (void)v;
 return (x[a] <= x[b]);
}
/**
 * Sorting hook -- comp function -- array of long's (see below)
 *
 * We use "u" to point to an array of long integers.
 */
static void ang_sort_swap_hook_longs(void *u, void *v, int a, int b)
{
 long *x = (long*)(u);
 long temp;
 /* Unused parameter */
 (void)v;
 /* Swap */
 temp = x[a];
 x[a] = x[b];
 x[b] = temp;
}
/*
 * Angband sorting algorithm -- quick sort in place
 *
 * Note that the details of the data we are sorting is hidden,
 * and we rely on the "ang_sort_comp()" and "ang_sort_swap()"
 * function hooks to interact with the data, which is given as
 * two pointers, and which may have any user-defined form.
 */
static void ang_sort_aux(void *u, void *v, int p, int q)
{
 int z, a, b;
 /* Done sort */
 if (p >= q) return;
 /* Pivot */
 z = p;
 /* Begin */
 a = p;
 b = q;
 /* Partition */
 while (true)
 {
  /* Slide i2 */
  while (!(*ang_sort_comp)(u, v, b, z)) b--;
  /* Slide i1 */
  while (!(*ang_sort_comp)(u, v, z, a)) a++;
  /* Done partition */
  if (a >= b) break;
  /* Swap */
  (*ang_sort_swap)(u, v, a, b);
  /* Advance */
  a++, b--;
 }
 /* Recurse left side */
 ang_sort_aux(u, v, p, b);
 /* Recurse right side */
 ang_sort_aux(u, v, b+1, q);
}
/*
 * Angband sorting algorithm -- quick sort in place
 *
 * Note that the details of the data we are sorting is hidden,
 * and we rely on the "ang_sort_comp()" and "ang_sort_swap()"
 * function hooks to interact with the data, which is given as
 * two pointers, and which may have any user-defined form.
 */
static void ang_sort(void *u, void *v, int n)
{
 /* Sort the array */
 ang_sort_aux(u, v, 0, n-1);
}
/**
 * Save a slope
 */
static void vinfo_init_aux(struct vinfo_hack *hack, int y, int x, long m)
{
 int i;
 /* Handle "legal" slopes */
 if ((m > 0) && (m <= 100000L)) {
  /* Look for that slope */
  for (i = 0; i < hack->num_slopes; i++) {
   if (hack->slopes[i] == m) break;
  }
  /* New slope */
  if (i == hack->num_slopes) {
   /* Paranoia */
   if (hack->num_slopes >= 126) {
    quit_fmt("Too many LOS slopes (%d)!", 126);
   }
   /* Save the slope, increment count */
   hack->slopes[hack->num_slopes++] = m;
  }
 }
 /* Track slope range */
 if (hack->slopes_min[y][x] > m) hack->slopes_min[y][x] = m;
 if (hack->slopes_max[y][x] < m) hack->slopes_max[y][x] = m;
}
/**
 * Initialize the "vinfo" array
 *
 * Full Octagon (radius 20), Grids=1149
 *
 * Quadrant (south east), Grids=308, Slopes=251
 *
 * Octant (east then south), Grids=161, Slopes=126
 *
 * This function assumes that VINFO_MAX_GRIDS and VINFO_MAX_SLOPES
 * have the correct values, which can be derived by setting them to
 * a number which is too high, running this function, and using the
 * error messages to obtain the correct values.
 */
errr vinfo_init(void)
{
 int i, g;
 int y, x;
 long m;
 struct vinfo_hack *hack;
 int num_grids = 0;
 int queue_head = 0;
 int queue_tail = 0;
 struct vinfo_type *queue[161 * 2];
 /* Make hack */
 hack = mem_zalloc(sizeof(*hack));
 /* Analyze grids */
 for (y = 0; y <= 20; ++y) {
  for (x = y; x <= 20; ++x) {
   /* Skip grids which are out of sight range */
   if (distance(loc(0, 0), loc(x, y)) > 20) continue;
   /* Default slope range */
   hack->slopes_min[y][x] = 999999999;
   hack->slopes_max[y][x] = 0;
   /* Paranoia */
   if (num_grids >= 161) {
    quit_fmt("Too many grids (%d >= %d)!",
     num_grids, 161);
   }
   /* Count grids */
   num_grids++;
   /* Slope to the top right corner */
   m = 100000L * (1000L * y - 500) / (1000L * x + 500);
   /* Handle "legal" slopes */
   vinfo_init_aux(hack, y, x, m);
   /* Slope to top left corner */
   m = 100000L * (1000L * y - 500) / (1000L * x - 500);
   /* Handle "legal" slopes */
   vinfo_init_aux(hack, y, x, m);
   /* Slope to bottom right corner */
   m = 100000L * (1000L * y + 500) / (1000L * x + 500);
   /* Handle "legal" slopes */
   vinfo_init_aux(hack, y, x, m);
   /* Slope to bottom left corner */
   m = 100000L * (1000L * y + 500) / (1000L * x - 500);
   /* Handle "legal" slopes */
   vinfo_init_aux(hack, y, x, m);
  }
 }
 /* Enforce maximal efficiency (grids) */
 if (num_grids < 161) {
  quit_fmt("Too few grids (%d < %d)!",
   num_grids, 161);
 }
 /* Enforce maximal efficiency (line of sight slopes) */
 if (hack->num_slopes < 126) {
  quit_fmt("Too few LOS slopes (%d < %d)!",
   hack->num_slopes, 126);
 }
 /* Sort slopes numerically */
 ang_sort_comp = ang_sort_comp_hook_longs;
 /* Sort slopes numerically */
 ang_sort_swap = ang_sort_swap_hook_longs;
 /* Sort the (unique) LOS slopes */
 ang_sort(hack->slopes, NULL, hack->num_slopes);
 /* Enqueue player grid */
 queue[queue_tail++] = &vinfo[0];
 /* Process queue */
 while (queue_head < queue_tail) {
  int e;
  /* Index */
  e = queue_head++;
  /* Main Grid */
  g = vinfo[e].grid[0];
  /* Location */
  y = ((int)((g) / 256U));
  x = ((int)((g) % 256U));
  /* Compute grid offsets */
  vinfo[e].grid[0] = (256 * (+y) + (+x));
  vinfo[e].grid[1] = (256 * (+x) + (+y));
  vinfo[e].grid[2] = (256 * (+x) + (-y));
  vinfo[e].grid[3] = (256 * (+y) + (-x));
  vinfo[e].grid[4] = (256 * (-y) + (-x));
  vinfo[e].grid[5] = (256 * (-x) + (-y));
  vinfo[e].grid[6] = (256 * (-x) + (+y));
  vinfo[e].grid[7] = (256 * (-y) + (+x));
  /* Skip player grid */
  if (e > 0) {
   long slope_fire;
   long slope_min = 0;
   long slope_max = 999999L;
   uint8_t tmp0 = 0;
   uint8_t tmp1 = 0;
   uint8_t tmp2 = 0;
   /* Determine LOF slope for this grid */
   if (x == 0) slope_fire = 100000L;
   else slope_fire = 100000L * (1000L * y) / (1000L * x);
   /* Analyze LOS slopes */
   for (i = 0; i < hack->num_slopes; ++i) {
    m = hack->slopes[i];
    /* Memorize intersecting slopes */
    if ((hack->slopes_min[y][x] < m) &&
        (hack->slopes_max[y][x] > m))
    {
     /* Add it to the LOS slope set */
     switch (i / 32)
     {
      case 3: vinfo[e].bits_3 |= (1L << (i % 32)); break;
      case 2: vinfo[e].bits_2 |= (1L << (i % 32)); break;
      case 1: vinfo[e].bits_1 |= (1L << (i % 32)); break;
      case 0: vinfo[e].bits_0 |= (1L << (i % 32)); break;
     }
     /* Check for exact match with the LOF slope */
     if (m == slope_fire) {
      tmp0 = i;
     } else if ((m < slope_fire) && (m > slope_min)) {
      /* Store index of nearest LOS slope < than LOF slope */
      tmp1 = i;
      slope_min = m;
     } else if ((m > slope_fire) && (m < slope_max)) {
      /* Store index of nearest LOS slope > than LOF slope */
      tmp2 = i;
      slope_max = m;
     }
    }
   }
   /* There is a perfect match with one of the LOS slopes */
   if (tmp0) {
    /* Save the (unique) slope */
    vinfo[e].slope_fire_index1 = tmp0;
    /* Mark the other empty */
    vinfo[e].slope_fire_index2 = 0;
   }
   /* The LOF slope lies between two LOS slopes */
   else
   {
    /* Save the first slope */
    vinfo[e].slope_fire_index1 = tmp1;
    /* Save the second slope */
    vinfo[e].slope_fire_index2 = tmp2;
   }
  }
  /* Default */
  vinfo[e].next_0 = &vinfo[0];
  /* Grid next child */
  if (distance(loc(0, 0), loc(x+1, y)) <= 20) {
   g = (256 * (y) + (x+1));
   if (queue[queue_tail-1]->grid[0] != g) {
    vinfo[queue_tail].grid[0] = g;
    queue[queue_tail] = &vinfo[queue_tail];
    queue_tail++;
   }
   vinfo[e].next_0 = &vinfo[queue_tail - 1];
  }
  /* Default */
  vinfo[e].next_1 = &vinfo[0];
  /* Grid diag child */
  if (distance(loc(0, 0), loc(x+1, y+1)) <= 20) {
   g = (256 * (y+1) + (x+1));
   if (queue[queue_tail-1]->grid[0] != g) {
    vinfo[queue_tail].grid[0] = g;
    queue[queue_tail] = &vinfo[queue_tail];
    queue_tail++;
   }
   vinfo[e].next_1 = &vinfo[queue_tail - 1];
  }
  /* Hack -- main diagonal has special children */
  if (y == x) vinfo[e].next_0 = vinfo[e].next_1;
  /* Grid coordinates, approximate distance  */
  vinfo[e].y = y;
  vinfo[e].x = x;
  vinfo[e].d = ((y > x) ? (y + x/2) : (x + y/2));
  vinfo[e].r = ((!y) ? x : (!x) ? y : (y == x) ? y : 0);
 }
 /* Verify maximal bits XXX XXX XXX */
 if (((vinfo[1].bits_3 | vinfo[2].bits_3) != 0x3FFFFFFF) ||
     ((vinfo[1].bits_2 | vinfo[2].bits_2) != 0xFFFFFFFF) ||
     ((vinfo[1].bits_1 | vinfo[2].bits_1) != 0xFFFFFFFF) ||
     ((vinfo[1].bits_0 | vinfo[2].bits_0) != 0xFFFFFFFF))
 {
  quit("Incorrect bit masks!");
 }
 /* Kill hack */
 mem_free(hack);
 /* Success */
 return (0);
}
/**
 * Change a struct loc to an int GRID
 */
static int loc_to_grid(struct loc grid)
{
 return (256 * (grid.y) + (grid.x));
}
/**
 * Change an int GRID to a struct loc
 */
static struct loc grid_to_loc(int grid)
{
 return loc(((int)((grid) % 256U)), ((int)((grid) / 256U)));
}
/**
 * Forget the fire_g grids, redrawing as needed
 */
void forget_fire(struct chunk *c)
{
 int i;
 /* None to forget */
 if (!fire_n) return;
 /* Clear them all */
 for (i = 0; i < fire_n; i++) {
  int g;
  struct loc grid;
  /* Grid */
  g = fire_g[i];
  /* Location */
  grid = grid_to_loc(g);
  /* Clear SQUARE_FIRE flags */
  sqinfo_off(square(c, grid)->info, SQUARE_FIRE);
  fire_info[g] = false;
 }
 /* None left */
 fire_n = 0;
}
/**
 * Calculate the complete field of fire using a cut-down version of the old
 * Sil field of view algorithm (and a modifieed version of this comment).
 *
 * Note the following idiom, which is used in the function below.
 * This idiom processes each "octant" of the field of fire, in a
 * clockwise manner, starting with the east strip, south side,
 * and for each octant, allows a simple calculation to set "g"
 * equal to the proper grids, relative to "pg", in the octant.
 *
 *   for (o2 = 0; o2 < 8; o2++)
 *   ...
 *         g = pg + p->grid[o2];
 *   ...
 *
 *
 * Normally, fire along the major axes is more likely than fire
 * along the diagonal axes, so we check the bits corresponding to
 * the lines of sight near the major axes first.
 *
 * This function is now responsible for maintaining the "SQUARE_FIRE"
 * flags as well as the "SQUARE_FIRE" flags.
 *
 * Basically, this function divides the "octagon of fire" into octants of
 * grids (where grids on the main axes and diagonal axes are "shared" by
 * two octants), and processes each octant one at a time, processing each
 * octant one grid at a time, processing only those grids which "might" be
 * fireable, and setting the "SQUARE_FIRE" flag for each grid for which there
 * is an (unobstructed) line of fire from the center of the player grid to
 * any internal point in the grid (and collecting these "SQUARE_FIRE" grids
 * into the "fire_g" array).
 *
 * This function relies on a theorem (suggested and proven by Mat Hostetter)
 * which states that in each octant of a field of fire, a given grid will
 * be "intersected" by one or more unobstructed "lines of fire" from the
 * center of the player grid if and only if it is "intersected" by at least
 * one such unobstructed "line of fire" which passes directly through some
 * corner of some grid in the octant which is not shared by any other octant.
 * The proof is based on the fact that there are at least three significant
 * lines of fire involving any non-shared grid in any octant, one which
 * intersects the grid and passes though the corner of the grid closest to
 * the player, and two which "brush" the grid, passing through the "outer"
 * corners of the grid, and that any line of fire which intersects a grid
 * without passing through the corner of a grid in the octant can be "slid"
 * slowly towards the corner of the grid closest to the player, until it
 * either reaches it or until it brushes the corner of another grid which
 * is closer to the player, and in either case, the existence of a suitable
 * line of fire is thus demonstrated.
 *
 * It turns out that in each octant of the radius 20 "octagon of fire",
 * there are 161 grids (with 128 not shared by any other octant), and there
 * are exactly 126 distinct "lines of fire" passing from the center of the
 * player grid through any corner of any non-shared grid in the octant.  To
 * determine if a grid is "fireable" by the player, therefore, you need to
 * simply show that one of these 126 lines of fire intersects the grid but
 * does not intersect any wall grid closer to the player.  So we simply use
 * a bit vector with 126 bits to represent the set of interesting lines of
 * fire which have not yet been obstructed by wall grids, and then we scan
 * all the grids in the octant, moving outwards from the player grid.  For
 * each grid, if any of the lines of fire which intersect that grid have not
 * yet been obstructed, then the grid is fireable.  Furthermore, if the grid
 * is a wall grid, then all of the lines of fire which intersect the grid
 * should be marked as obstructed for future reference.  Also, we only need
 * to check those grids for whom at least one of the "parents" was a fireable
 * non-wall grid, where the parents include the two grids touching the grid
 * but closer to the player grid (one adjacent, and one diagonal).  For the
 * bit vector, we simply use 4 32-bit integers.  All of the static values
 * which are needed by this function are stored in the large "vinfo" array
 * (above), which is machine generated by another program.  XXX XXX XXX
 *
 * Hack -- The queue must be able to hold more than VINFO_MAX_GRIDS grids
 * because the grids at the edge of the field of fire use "grid zero" as
 * their children, and the queue must be able to hold several of these
 * special grids.  Because the actual number of required grids is bizarre,
 * we simply allocate twice as many as we would normally need.  XXX XXX XXX
 */
void update_fire(struct chunk *c, struct player *p)
{
 int i, g, o2;
 struct loc grid;
 bool in_pit = square_ispit(c, p->grid) && !p->upkeep->leaping;
 /*** Step 0 -- Begin ***/
 /* Wipe */
 forget_fire(c);
 /*** Step 1 -- player grid ***/
 /* Player grid */
 g = loc_to_grid(p->grid);
 /* Assume fireable */
 fire_info[g] = true;
 sqinfo_on(square(c, p->grid)->info, SQUARE_FIRE);
 /* Save in array */
 fire_g[fire_n++] = g;
 /*** Step 2 -- octants ***/
 /* Scan each octant */
 for (o2 = 0; o2 < 8; o2++) {
  struct vinfo_type *point;
  /* Last added */
  struct vinfo_type *last = &vinfo[0];
  /* Grid queue */
  int queue_head = 0;
  int queue_tail = 0;
  struct vinfo_type *queue[161*2];
  /* Slope bit vector */
  uint32_t bits0 = 0xFFFFFFFF;
  uint32_t bits1 = 0xFFFFFFFF;
  uint32_t bits2 = 0xFFFFFFFF;
  uint32_t bits3 = 0x3FFFFFFF;
  /* Reset queue */
  queue_head = queue_tail = 0;
  /* Initial grids */
  queue[queue_tail++] = &vinfo[1];
  queue[queue_tail++] = &vinfo[2];
  /* Process queue */
  while (queue_head < queue_tail) {
   /* Assume no line of fire */
   bool line_fire = false;
   /* Dequeue next grid */
   point = queue[queue_head++];
   /* Check bits */
   if ((bits0 & (point->bits_0)) ||
       (bits1 & (point->bits_1)) ||
       (bits2 & (point->bits_2)) ||
       (bits3 & (point->bits_3))) {
    bool new = false;
    /* Extract grid value XXX XXX XXX */
    g = loc_to_grid(p->grid) + point->grid[o2];
    grid = grid_to_loc(g);
    new = fire_info[g];
    /* Check bounds */
    if (!square_in_bounds_fully(c, grid)) continue;
    /* If the player is in a pit, skip non-adjacent grids */
    if (in_pit && (distance(grid, p->grid) > 1)) {
     continue;
    }
    /* Check for first possible line of fire */
    i = point->slope_fire_index1;
    /* Check line(s) of fire */
    while (true) {
     switch (i / 32) {
      case 3: {
       if (bits3 & (1L << (i % 32))) line_fire = true;
       break;
      }
      case 2: {
       if (bits2 & (1L << (i % 32))) line_fire = true;
       break;
      }
      case 1: {
       if (bits1 & (1L << (i % 32))) line_fire = true;
       break;
      }
      case 0: {
       if (bits0 & (1L << (i % 32))) line_fire = true;
       break;
      }
     }
     /* Check second LOF slope if necessary */
     if ((!point->slope_fire_index2) || (line_fire) ||
         (i == point->slope_fire_index2)) {
      break;
     }
     /* Check second possible line of fire */
     i = point->slope_fire_index2;
    }
    /* Record line of fire */
    if (line_fire) {
     fire_info[g] = true;
     sqinfo_on(square(c, grid)->info, SQUARE_FIRE);
     /* Newly fireable grid */
     if (new) {
      /* Save in array */
      fire_g[fire_n++] = g;
     }
     /* Handle wall or non-wall */
     if (square_iswall(c, grid)) {
      /* Clear bits */
      bits0 &= ~(point->bits_0);
      bits1 &= ~(point->bits_1);
      bits2 &= ~(point->bits_2);
      bits3 &= ~(point->bits_3);
     } else {
      /* Enqueue child */
      if (last != point->next_0) {
       queue[queue_tail++] = last = point->next_0;
      }
      /* Enqueue child */
      if (last != point->next_1) {
       queue[queue_tail++] = last = point->next_1;
      }
     }
    }
   }
  }
 }
}
/**
 * Determine the path taken by a projection.  -BEN-, -LM-
 *
 * The projection will always start one grid from the grid (y1,x1), and will
 * travel towards the grid (y2,x2), touching one grid per unit of distance
 * along the major axis, and stopping when it satisfies certain conditions
 * or has travelled the maximum legal distance of "range".  Projections
 * cannot extend further than MAX_SIGHT (at least at present).
 *
 * A projection only considers those grids which contain the line(s) of fire
 * from the start to the end point.  Along any step of the projection path,
 * either one or two grids may be valid options for the next step.  When a
 * projection has a choice of grids, it chooses that which offers the least
 * resistance.  Given a choice of clear grids, projections prefer to move
 * orthogonally.
 *
 * Also, projections to or from the character must stay within the pre-
 * calculated field of fire ("cave_info & (CAVE_FIRE)").  This is a hack.
 * XXX XXX
 *
 * The path grids are saved into the grid array pointed to by "gp", and
 * there should be room for at least "range" grids in "gp".  Note that
 * due to the way in which distance is calculated, this function normally
 * uses fewer than "range" grids for the projection path, so the result
 * of this function should never be compared directly to "range".  Note
 * that the initial grid (y1,x1) is never saved into the grid array, not
 * even if the initial grid is also the final grid.  XXX XXX XXX
 *
 * We modify y2 and x2 if they are too far away, or (for PROJECT_PASS only)
 * if the projection threatens to leave the dungeon.
 *
 * The "flg" flags can be used to modify the behavior of this function:
 *    PROJECT_STOP:  projection stops when it cannot bypass a monster.
 *    PROJECT_CHCK:  projection notes when it cannot bypass a monster.
 *    PROJECT_THRU:  projection extends past destination grid
 *    PROJECT_PASS:  projection passes through walls
 *    PROJECT_INVIS: projection passes through invisible walls (ie unknown ones)
 *
 * This function returns the number of grids (if any) in the path.  This
 * may be zero if no grids are legal except for the starting one.
 */
int project_path(struct chunk *c, struct loc *gp, int range, struct loc grid1,
     struct loc *grid2, int flg)
{
 int i, j, k;
 int dy, dx;
 int num, dist, octant;
 int n_grids = 0;
 bool line_fire;
 bool full_stop = false;
 struct loc grid_a, grid_b;
 struct loc grid = loc(0, 0), old_grid = loc(0, 0);
 /* Start with all lines of sight unobstructed */
 uint32_t bits0 = 0xFFFFFFFF;
 uint32_t bits1 = 0xFFFFFFFF;
 uint32_t bits2 = 0xFFFFFFFF;
 uint32_t bits3 = 0x3FFFFFFF;
 int slope_fire1 = -1, slope_fire2 = 0;
 /* Projections are either vertical or horizontal */
 bool vertical = false;
 /* Require projections to be strictly LOF when possible  XXX XXX */
 //bool require_strict_lof = false;
 /* Count of grids in LOF, storage of LOF grids */
 struct loc tmp_grids[80];
 /* Count of grids in projection path */
 int step;
 /* Remember whether and how a grid is blocked */
 int blockage[2];
 /* Assume no monsters in way */
 bool monster_in_way = false;
 /* Initial grid */
 int16_t g0 = loc_to_grid(grid1);
 int16_t g;
 /* Pointer to vinfo data */
 struct vinfo_type *point;
 /* Handle projections of zero length */
 if ((range <= 0) || loc_eq(grid1, *grid2)) return 0;
 /* Note that the character is the source or target of the projection */
 //if (loc_eq(grid1, player->grid) || loc_eq(*grid2, player->grid)) {
  /* Require strict LOF */
 //	require_strict_lof = true;
 //}
 /* Get position change (signed) */
 dy = (*grid2).y - grid1.y;
 dx = (*grid2).x - grid1.x;
 /* Get distance from start to finish */
 dist = distance(grid1, *grid2);
 /* Must stay within the field of sight XXX XXX */
 if ((dist > z_info->max_sight) && !(flg & PROJECT_LEAVE)) {
  /* Always watch your (+/-) when doing rounded integer math. */
  int round_y = (dy < 0 ? -(dist / 2) : (dist / 2));
  int round_x = (dx < 0 ? -(dist / 2) : (dist / 2));
  /* Rescale the endpoint */
  dy = ((dy * (z_info->max_sight - 1)) + round_y) / dist;
  dx = ((dx * (z_info->max_sight - 1)) + round_x) / dist;
  *grid2 = loc_sum(grid1, loc(dx, dy));
 }
 /* Get the correct octant, establish vertical or horizontal major axis */
 if (dy < 0) {
  /* Up and to the left */
  if (dx < 0) {
   /* More upwards than to the left - octant 4 */
   if (ABS(dy) > ABS(dx)) {
    octant = 5;
    vertical = true;
   } else {
    octant = 4;
   }
  } else {
   if (ABS(dy) > ABS(dx)) {
    octant = 6;
    vertical = true;
   } else {
    octant = 7;
   }
  }
 } else {
  if (dx < 0) {
   if (ABS(dy) > ABS(dx)) {
    octant = 2;
    vertical = true;
   } else {
    octant = 3;
   }
  } else {
   if (ABS(dy) > ABS(dx)) {
    octant = 1;
    vertical = true;
   } else {
    octant = 0;
   }
  }
 }
 /* Scan the octant, find the grid corresponding to the end point */
 for (j = 1; j < 161; j++) {
  int16_t vy, vx;
  /* Point to this vinfo record */
  point = &vinfo[j];
  /* Extract grid value */
  g = g0 + point->grid[octant];
  /* Get axis coordinates */
  vy = ((int)((g) / 256U));
  vx = ((int)((g) % 256U));
  /* Allow for negative values XXX XXX XXX */
  if (vy > 256 * 127) {
   vy = vy - (256 * 256);
  }
  if (vx > grid1.x + 127) {
   vy++;
   vx = vx - 256;
  }
  /* Require that grid be correct */
  if ((vy != (*grid2).y) || (vx != (*grid2).x)) continue;
  /* Store lines of fire */
  slope_fire1 = point->slope_fire_index1;
  slope_fire2 = point->slope_fire_index2;
  break;
 }
 /* Note failure XXX XXX */
 if (slope_fire1 == -1) return (0);
 /* Scan the octant, collect all grids having the correct line of fire */
 for (j = 1; j < 161; j++) {
  line_fire = false;
  /* Point to this vinfo record */
  point = &vinfo[j];
  /* See if any lines of sight pass through this grid */
  if (!((bits0 & (point->bits_0)) ||
     (bits1 & (point->bits_1)) ||
     (bits2 & (point->bits_2)) ||
     (bits3 & (point->bits_3)))) {
   continue;
  }
  /*
		 * Extract grid value.  Use pointer shifting to get the
		 * correct grid offset for this octant.
		 */
  g = g0 + point->grid[octant];
  grid = grid_to_loc(g);
  /* Must be legal (this is important) */
  if (!square_in_bounds_fully(c, grid)) continue;
  /* Check for first possible line of fire */
  i = slope_fire1;
  /* Check line(s) of fire */
  while (true) {
   switch (i / 32) {
    case 3: {
     if (bits3 & (1L << (i % 32))) {
      if (point->bits_3 & (1L << (i % 32))) line_fire = true;
     }
     break;
    }
    case 2: {
     if (bits2 & (1L << (i % 32))) {
      if (point->bits_2 & (1L << (i % 32))) line_fire = true;
     }
     break;
    }
    case 1: {
     if (bits1 & (1L << (i % 32))) {
      if (point->bits_1 & (1L << (i % 32))) line_fire = true;
     }
     break;
    }
    case 0: {
     if (bits0 & (1L << (i % 32))) {
      if (point->bits_0 & (1L << (i % 32))) line_fire = true;
     }
     break;
    }
   }
   /* We're done if no second LOF exists, or when we've checked it */
   if ((!slope_fire2) || (i == slope_fire2)) break;
   /* Check second possible line of fire */
   i = slope_fire2;
  }
  /* This grid contains at least one of the lines of fire */
  if (line_fire) {
   /* Do not accept breaks in the series of grids  XXX XXX */
   if (n_grids && distance(grid, old_grid) > 1) {
    break;
   }
   /* Optionally, require strict line of fire */
   //TODO see if this conditional is actually needed; I believe it's
   //purpose is covered by the checks in projectable() - NRM
   //if ((!require_strict_lof) || square_isfire(c, grid) ||
   //   ((flg & (PROJECT_INVIS)) && !square_isknown(c, grid))) {
   /* Store grid value */
   tmp_grids[n_grids++] = grid_to_loc(g);
    //}
   /* Remember previous coordinates */
   old_grid = grid;
  }
  /*
		 * Handle wall (unless ignored).  Walls can be in a projection path,
		 * but the path cannot pass through them.
		 */
  if (!(flg & (PROJECT_PASS)) && square_iswall(c, grid)) {
   if (!(flg & (PROJECT_INVIS)) || square_isknown(c, grid)) {
    /* Clear any lines of sight passing through this grid */
    bits0 &= ~(point->bits_0);
    bits1 &= ~(point->bits_1);
    bits2 &= ~(point->bits_2);
    bits3 &= ~(point->bits_3);
   }
  }
  }
 /* Scan the grids along the line(s) of fire */
 for (step = 0, j = 0; j < n_grids;) {
  /* Get the coordinates of this grid */
  grid_a = tmp_grids[j];
  /* Get the coordinates of the next grid, if legal */
  if (j < n_grids - 1) {
   grid_b = tmp_grids[j + 1];
  } else {
   grid_b = loc(-1, -1);
  }
  /*
		 * We always have at least one legal grid, and may have two.  Allow
		 * the second grid if its position differs only along the minor axis.
		 */
  if (vertical ? grid_a.y == grid_b.y : grid_a.x == grid_b.x) {
   num = 2;
  } else {
   num = 1;
  }
  /* Scan one or both grids */
  for (i = 0; i < num; i++) {
   blockage[i] = 0;
   /* Get the coordinates of this grid */
   grid = i == 0 ? grid_a : grid_b;
   /* Determine perpendicular distance */
   k = (vertical ? ABS(grid.x - grid1.x) : ABS(grid.y - grid1.y));
   /* Hack -- Check maximum range */
   if ((i == num - 1) && (step + (k >> 1)) >= range - 1) {
    /* End of projection */
    full_stop = true;
   }
   /* Sometimes stop at destination grid */
   if (!(flg & (PROJECT_THRU))) {
    if (loc_eq(grid, *grid2)) {
     /* End of projection */
     full_stop = true;
    }
   }
   /* Usually stop at wall grids */
   if (!(flg & (PROJECT_PASS)) &&
    (!(flg & (PROJECT_INVIS)) || square_isknown(c, grid))) {
    if (!square_isprojectable(c, grid)) {
     blockage[i] = 2;
    }
   } else if (!square_in_bounds_fully(c, grid)) {
    /* If we don't stop at wall grids, explicitly check legality */
    full_stop = true;
    blockage[i] = 3;
   }
   /* Try to avoid monsters/players between the endpoints */
   if ((square_monster(c, grid) || square_isplayer(c, grid)) &&
    (blockage[i] < 2)) {
    /* Hack: ignore monsters on the designated square on request */
    if (!loc_eq(c->project_path_ignore, grid)) {
     if (flg & (PROJECT_STOP)) {
      blockage[i] = 2;
     } else if (flg & (PROJECT_CHCK)) {
      blockage[i] = 1;
     }
    }
   }
  }
  /* Pick the first grid if possible, the second if necessary */
  if ((num == 1) || (blockage[0] <= blockage[1])) {
   /* Store the first grid, advance */
   if (blockage[0] < 3) gp[step++] = tmp_grids[j];
   /* Blockage of 2 or greater means the projection ends */
   if (blockage[0] >= 2) break;
   /* Blockage of 1 means a monster bars the path */
   if (blockage[0] == 1) {
    /* Endpoints are always acceptable */
    if (!loc_eq(grid, *grid2)) monster_in_way = true;
   }
   /* Handle end of projection */
   if (full_stop) break;
  } else {
   /* Store the second grid, advance */
   if (blockage[1] < 3) gp[step++] = tmp_grids[j + 1];
   /* Blockage of 2 or greater means the projection ends */
   if (blockage[1] >= 2) break;
   /* Blockage of 1 means a monster bars the path */
   if (blockage[1] == 1) {
    /* Endpoints are always acceptable */
    if (!loc_eq(grid, *grid2)) monster_in_way = true;
   }
   /* Handle end of projection */
   if (full_stop) break;
  }
  /* Advance to the next unexamined LOF grid */
  j += num;
 }
 /* Accept last grid as the new endpoint if allowed */
 if (!(flg & PROJECT_LEAVE))
  *grid2 = gp[step - 1];
 /* Return count of grids in projection path */
 if (monster_in_way) return -step;
 return step;
}
/**
 * \file cave-map.c
 * \brief Lighting and map management functions
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * This function takes a grid location and extracts information the
 * player is allowed to know about it, filling in the grid_data structure
 * passed in 'g'.
 *
 * The information filled in is as follows:
 *  - g->f_idx is filled in with the terrain's feature type, or FEAT_NONE
 *    if the player doesn't know anything about the grid.  The function
 *    makes use of the "mimic" field in terrain in order to allow one
 *    feature to look like another (hiding secret doors, invisible traps,
 *    etc).  This will return the terrain type the player "Knows" about,
 *    not necessarily the real terrain.
 *  - g->m_idx is set to the monster index, or 0 if there is none (or the
 *    player doesn't know it).
 *  - g->first_kind is set to the object_kind of the first object in a grid
 *    that the player knows about, or NULL for no objects.
 *  - g->first_art is set to the artifact pointer of the first object in a grid
 *    that the player knows about, or NULL if there are no objects or the first
 *    known object is not an artifact.
 *  - g->muliple_objects is true if there is more than one object in the
 *    grid that the player knows and cares about (to facilitate any special
 *    floor stack symbol that might be used).
 *  - g->in_view is true if the player can currently see the grid - this can
 *    be used to indicate field-of-view, such as through the 
 *    OPT(player, view_bright_light) option.
 *  - g->lighting is set to indicate the lighting level for the grid:
 *    LIGHTING_LIT by default, LIGHTING_DARK for unlit but seen grids within the
 *    detection radius of a player with the UNLIGHT ability and a light source
 *    with an intensity of one or less, LIGHTING_TORCH for seen and lit grids
 *    within the radius of the player's light source when the view_yellow_light
 *    option is on, and LIGHTING_LOS for seen and lit grids that don't qualify
 *    for LIGHTING_TORCH.
 *  - g->is_player is true if the player is on the given grid.
 *  - g->hallucinate is true if the player is hallucinating something "strange"
 *    for this grid - this should pick a random monster to show if the m_idx
 *    is non-zero, and a random object if first_kind is non-zero.
 * 
 * NOTES:
 * This is called pretty frequently, whenever a grid on the map display
 * needs updating, so don't overcomplicate it.
 *
 * Terrain is remembered separately from objects and monsters, so can be
 * shown even when the player can't "see" it.  This leads to things like
 * doors out of the player's view still change from closed to open and so on.
 *
 * TODO:
 * Hallucination is a display-level hack (mostly in ui-map.c's
 * grid_data_as_text(); some here) and we need it to be a knowledge-level
 * hack.  The idea is that objects may turn into different objects, monsters
 * into different monsters, and terrain may be objects, monsters, or stay the
 * same.
 */
void map_info(struct loc grid, struct grid_data *g)
{
 struct object *obj;
 assert(grid.x < cave->width);
 assert(grid.y < cave->height);
 /* Default "clear" values, others will be set later where appropriate. */
 g->first_kind = NULL;
 g->first_art = NULL;
 g->trap = NULL;
 g->multiple_objects = false;
 g->glow = false;
 g->lighting = LIGHTING_LIT;
 /* Use real feature (remove later) */
 g->f_idx = square(cave, grid)->feat;
 if (f_info[g->f_idx].mimic)
  g->f_idx = (uint32_t) (f_info[g->f_idx].mimic - f_info);
 g->in_view = (square_isseen(cave, grid)) ? true : false;
 g->is_player = (square(cave, grid)->mon < 0) ? true : false;
 g->m_idx = (g->is_player) ? 0 : square(cave, grid)->mon;
 g->hallucinate = player->timed[TMD_IMAGE] ? true : false;
 g->rage = player->timed[TMD_RAGE] ? true : false;
 if (square_isglow(cave, grid)) {
  g->lighting = LIGHTING_LIT;
 }
 if (g->in_view) {
  bool lit = square_islit(cave, grid);
  if (lit) {
   g->lighting = LIGHTING_LOS;
  }
  /* Remember seen feature */
  square_memorize(cave, grid);
 } else if (g->rage) {
  /* Rage shows nothing out of view */
  g->f_idx = FEAT_NONE;
  g->m_idx = 0;
  return;
 } else if (!square_isknown(cave, grid)) {
  g->f_idx = FEAT_NONE;
 }
 /* Use known feature */
 g->f_idx = square(player->cave, grid)->feat;
 if (f_info[g->f_idx].mimic)
  g->f_idx = (uint32_t) (f_info[g->f_idx].mimic - f_info);
 /* There is a known trap in this square */
 if (square_trap(player->cave, grid) && square_isknown(cave, grid)) {
  struct trap *trap = square(player->cave, grid)->trap;
  /* Scan the square trap list */
  while (trap) {
   if (trf_has(trap->flags, TRF_TRAP) ||
    trf_has(trap->flags, TRF_GLYPH)) {
    /* Accept the trap */
    g->trap = trap;
    break;
   }
   trap = trap->next;
  }
    }
 /* Objects */
 for (obj = square_object(player->cave, grid); obj; obj = obj->next) {
  if (ignore_known_item_ok(player, obj)) {
   /* Item stays hidden */
  } else if (!g->first_kind) {
   /*
			 * For glowing, need to test the base object, not just
			 * what the player knows.
			 */
   struct object *base_obj = cave->objects[obj->oidx];
   g->first_kind = obj->kind;
   g->first_art = obj->artifact;
   assert(base_obj);
   g->glow = loc_eq(obj->grid, base_obj->grid)
    && weapon_glows(base_obj, 0);
  } else {
   g->multiple_objects = true;
   break;
  }
 }
 /* Monsters */
 if (g->m_idx > 0) {
  /* If the monster isn't "visible", make sure we don't list it.*/
  struct monster *mon = cave_monster(cave, g->m_idx);
  if (!monster_is_visible(mon) && !monster_is_listened(mon)) g->m_idx = 0;
 }
 /* Rare random hallucination on non-outer walls */
 if (g->hallucinate && g->m_idx == 0 && g->first_kind == 0) {
  if (one_in_(128) && (int) g->f_idx != FEAT_PERM)
   g->m_idx = z_info->r_max + 1;
  else if (one_in_(128) && (int) g->f_idx != FEAT_PERM)
   /* if hallucinating, we just need first_kind to not be NULL */
   g->first_kind = k_info;
  else
   g->hallucinate = false;
 }
 assert((int) g->f_idx < FEAT_MAX);
 if (!g->hallucinate)
  assert((int)g->m_idx < cave->mon_max);
 /* All other g fields are 'flags', mostly booleans. */
}
/**
 * Memorize interesting viewable object/features in the given grid
 *
 * This function should only be called on "legal" grids.
 *
 * This function will memorize the object and/or feature in the given grid,
 * if they are (1) see-able and (2) interesting.  Note that all objects are
 * interesting, all terrain features except floors (and invisible traps) are
 * interesting, and floors (and invisible traps) are interesting sometimes
 * (depending on various options involving the illumination of floor grids).
 *
 * The automatic memorization of all objects and non-floor terrain features
 * as soon as they are displayed allows incredible amounts of optimization
 * in various places, especially "map_info()" and this function itself.
 *
 * Note that the memorization of objects is completely separate from the
 * memorization of terrain features, preventing annoying floor memorization
 * when a detected object is picked up from a dark floor, and object
 * memorization when an object is dropped into a floor grid which is
 * memorized but out-of-sight.
 *
 * This function should be called every time the "memorization" of a grid
 * (or the object in a grid) is called into question, such as when an object
 * is created in a grid, when a terrain feature "changes" from "floor" to
 * "non-floor", and when any grid becomes "see-able" for any reason.
 *
 * This function is called primarily from the "update_view()" function, for
 * each grid which becomes newly "see-able".
 */
void square_note_spot(struct chunk *c, struct loc grid)
{
 /* Require "seen" flag and the current level */
 if (c != cave) return;
 if (!square_isseen(c, grid) && !square_isplayer(c, grid)) return;
 /* Make the player know precisely what is on this grid */
 square_know_pile(c, grid);
 /* Notice traps, memorize those we can see */
 if (square_issecrettrap(c, grid)) {
  square_reveal_trap(c, grid, true);
 }
 square_memorize_traps(c, grid);
 if (!square_ismemorybad(c, grid))
  return;
 /* Memorize this grid */
 square_memorize(c, grid);
}
/**
 * Tell the UI that a given map location has been updated
 *
 * This function should only be called on "legal" grids.
 */
void square_light_spot(struct chunk *c, struct loc grid)
{
 if ((c == cave) && player->cave) {
  player->upkeep->redraw |= PR_ITEMLIST;
  event_signal_point(EVENT_MAP, grid.x, grid.y);
 }
}
/**
 * This routine will "darken" all grids in the set passed in.
 *
 * In addition, some of these grids will be "unmarked".
 *
 * This routine is used (only) by "light_room()"
 */
static void cave_unlight(struct point_set *ps)
{
 int i;
 /* Apply flag changes */
 for (i = 0; i < ps->n; i++) {
  struct loc grid = ps->pts[i];
  /* Darken the grid... */
  sqinfo_off(square(cave, ps->pts[i])->info, SQUARE_GLOW);
  /* Hack -- Forget "boring" grids */
  if (square_isfloor(cave, grid))
   square_unmark(cave, grid);
 }
 /* Process the grids */
 for (i = 0; i < ps->n; i++) {
  /* Redraw the grid */
  square_light_spot(cave, ps->pts[i]);
 }
}
/*
 * Aux function -- see below
 */
static void cave_room_aux(struct point_set *seen, struct loc grid)
{
 if (point_set_contains(seen, grid))
  return;
 if (!square_in_bounds(cave, grid))
  return;
 if (!square_isroom(cave, grid))
  return;
 /* Add it to the "seen" set */
 add_to_point_set(seen, grid);
}
/**
 * Illuminate or darken any room containing the given location.
 */
void light_room(struct loc grid, bool light)
{
 int i, d;
 struct point_set *ps;
 ps = point_set_new(200);
 /* Add the initial grid */
 cave_room_aux(ps, grid);
 /* While grids are in the queue, add their neighbors */
 for (i = 0; i < ps->n; i++) {
  /* Walls get lit, but stop light */
  if (!square_isprojectable(cave, ps->pts[i])) continue;
  /* Spread to the adjacent grids */
  for (d = 0; d < 8; d++) {
   cave_room_aux(ps, loc_sum(ps->pts[i], ddgrid_ddd[d]));
  }
 }
 /* Now, lighten or darken them all at once */
 if (!light) {
  cave_unlight(ps);
 }
 point_set_dispose(ps);
 /* Fully update the visuals */
 player->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
 /* Update stuff */
 update_stuff(player);
}
/**
 * Light up the dungeon using "claravoyance"
 *
 * This function "illuminates" every grid in the dungeon, memorizes all
 * "objects" (or notes the existence of an object "if" full is true),
 * and memorizes all grids as with magic mapping.
 */
void wiz_light(struct chunk *c, struct player *p)
{
 int i, y, x;
 /* Scan all grids */
 for (y = 1; y < c->height - 1; y++) {
  for (x = 1; x < c->width - 1; x++) {
   struct loc grid = loc(x, y);
   /* Process all non-walls */
   if (!square_seemslikewall(c, grid)) {
    if (!square_in_bounds_fully(c, grid)) continue;
    /* Scan all neighbors */
    for (i = 0; i < 9; i++) {
     struct loc a_grid = loc_sum(grid, ddgrid_ddd[i]);
     /* Perma-light the grid */
     sqinfo_on(square(c, a_grid)->info, SQUARE_GLOW);
     /* Memorize normal features */
     if (!square_isfloor(c, a_grid) ||
      square_isvisibletrap(c, a_grid)) {
      square_memorize(c, a_grid);
      square_mark(c, a_grid);
     }
    }
   }
   /* Memorize objects */
   square_know_pile(c, grid);
   /* Forget unprocessed, unknown grids in the mapping area */
   if (!square_ismark(c, grid) && square_ismemorybad(c, grid))
    square_forget(c, grid);
  }
 }
 /* Unmark grids */
 for (y = 1; y < c->height - 1; y++) {
  for (x = 1; x < c->width - 1; x++) {
   struct loc grid = loc(x, y);
   if (!square_in_bounds(c, grid)) continue;
   square_unmark(c, grid);
  }
 }
 /* Fully update the visuals */
 p->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
 /* Redraw whole map, monster list */
 p->upkeep->redraw |= (PR_MAP | PR_MONLIST | PR_ITEMLIST);
}
/**
 * Compeletly darken the level, forgetting everything
 */
void wiz_dark(struct chunk *c, struct player *p)
{
 int y, x;
 /* Scan all grids */
 assert(c == cave);
 for (y = 1; y < c->height - 1; y++) {
  for (x = 1; x < c->width - 1; x++) {
   struct loc grid = loc(x, y);
   struct object *obj = square_object(p->cave, grid);
   /* Forget all grids */
   square_forget(c, grid);
   /*
			 * Mark all grids as unseen so view calculations start
			 * from scratch.
			 */
   sqinfo_off(square(c, grid)->info, SQUARE_SEEN);
   /* Forget all objects */
   while (obj) {
    struct object *base = cave->objects[obj->oidx];
    struct object *next = obj->next;
    assert(base && base->known == obj);
    square_excise_object(p->cave, grid, obj);
    delist_object(p->cave, obj);
    object_delete(p->cave, NULL, &obj);
    base->known = NULL;
    obj = next;
   }
   /* Forget unmoving mindless monsters - TODO */
  }
 }
 /* Fully update the visuals */
 p->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
 /* Redraw whole map, monster list */
 p->upkeep->redraw |= (PR_MAP | PR_MONLIST | PR_ITEMLIST);
}
 /**
 * \file cave-square.c
 * \brief functions for dealing with individual squares
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * FEATURE PREDICATES
 *
 * These functions test a terrain feature index for the obviously described
 * type.  They are used in the square feature predicates below, and
 * occasionally on their own
 */
/**
 * True if the square is rock.
 */
bool feat_is_rock(int feat)
{
 return tf_has(f_info[feat].flags, TF_ROCK);
}
/**
 * True if the square is a quartz wall.
 */
bool feat_is_quartz(int feat)
{
 return tf_has(f_info[feat].flags, TF_QUARTZ);
}
/**
 * True if the square is a granite wall.
 */
bool feat_is_granite(int feat)
{
 return tf_has(f_info[feat].flags, TF_GRANITE);
}
/**
 * True if the feature is a solid wall (not rubble).
 */
bool feat_is_wall(int feat)
{
 return tf_has(f_info[feat].flags, TF_WALL);
}
/**
 * True if the feature is a floor.
 */
bool feat_is_floor(int feat)
{
 return tf_has(f_info[feat].flags, TF_FLOOR);
}
/**
 * True if the feature can hold a trap.
 */
bool feat_is_trap_holding(int feat)
{
 return tf_has(f_info[feat].flags, TF_TRAP);
}
/**
 * True if the feature can hold an object.
 */
bool feat_is_object_holding(int feat)
{
 return tf_has(f_info[feat].flags, TF_OBJECT);
}
/**
 * True if a monster can walk through the feature.
 */
bool feat_is_monster_walkable(int feat)
{
 return tf_has(f_info[feat].flags, TF_PASSABLE);
}
/**
 * True if the feature is a forge.
 */
bool feat_is_forge(int feat)
{
 return tf_has(f_info[feat].flags, TF_FORGE);
}
/**
 * True if the feature allows line-of-sight.
 */
bool feat_is_los(int feat)
{
 return tf_has(f_info[feat].flags, TF_LOS);
}
/**
 * True if the feature is passable by the player.
 */
bool feat_is_passable(int feat)
{
 return tf_has(f_info[feat].flags, TF_PASSABLE);
}
/**
 * True if any projectable can pass through the feature.
 */
bool feat_is_projectable(int feat)
{
 return tf_has(f_info[feat].flags, TF_PROJECT);
}
/**
 * True if the feature can be lit by light sources.
 */
bool feat_is_torch(int feat)
{
 return tf_has(f_info[feat].flags, TF_TORCH);
}
/**
 * True if the feature is a pit.
 */
bool feat_is_pit(int feat)
{
 return tf_has(f_info[feat].flags, TF_PIT);
}
/**
 * True if the feature doesn't carry monster flow information.
 */
bool feat_is_no_flow(int feat)
{
 return tf_has(f_info[feat].flags, TF_NO_FLOW);
}
/**
 * True if the feature doesn't carry player scent.
 */
bool feat_is_no_scent(int feat)
{
 return tf_has(f_info[feat].flags, TF_NO_SCENT);
}
/**
 * True if the feature is a chasm.
 */
bool feat_is_chasm(int feat)
{
 return tf_has(f_info[feat].flags, TF_CHASM);
}
/**
 * SQUARE FEATURE PREDICATES
 *
 * These functions are used to figure out what kind of square something is,
 * via c->squares[y][x].feat (preferably accessed via square(c, grid)).
 * All direct testing of square(c, grid)->feat should be rewritten
 * in terms of these functions.
 *
 * It's often better to use square behavior predicates (written in terms of
 * these functions) instead of these functions directly.
 */
/**
 * True if the square is normal open floor.
 */
bool square_isfloor(struct chunk *c, struct loc grid)
{
 return feat_is_floor(square(c, grid)->feat);
}
/**
 * True if the square can hold a trap.
 */
bool square_istrappable(struct chunk *c, struct loc grid)
{
 return feat_is_trap_holding(square(c, grid)->feat);
}
/**
 * True if the square can hold an object.
 */
bool square_isobjectholding(struct chunk *c, struct loc grid)
{
 return feat_is_object_holding(square(c, grid)->feat);
}
/**
 * True if the square is a normal granite rock wall.
 */
bool square_isgranitewall(struct chunk *c, struct loc grid)
{
 return (tf_has(f_info[square(c, grid)->feat].flags, TF_GRANITE) &&
   !tf_has(f_info[square(c, grid)->feat].flags, TF_DOOR_ANY));
}
/**
 * True if the square is granite.
 */
bool square_isgranite(struct chunk *c, struct loc grid)
{
 return feat_is_granite(square(c, grid)->feat);
}
/**
 * True if the square is a permanent wall.
 */
bool square_isperm(struct chunk *c, struct loc grid)
{
 return (tf_has(f_info[square(c, grid)->feat].flags, TF_PERMANENT) &&
   tf_has(f_info[square(c, grid)->feat].flags, TF_ROCK));
}
/**
 * True if the square is made of rock.
 */
bool square_isrock(struct chunk *c, struct loc grid)
{
 return feat_is_rock(square(c, grid)->feat);
}
/**
 * True if the square is a quartz wall.
 */
bool square_isquartz(struct chunk *c, struct loc grid)
{
 return feat_is_quartz(square(c, grid)->feat);
}
/**
 * True if the square is a mineral wall (quartz/granite).
 */
bool square_ismineral(struct chunk *c, struct loc grid)
{
 return square_isgranitewall(c, grid) || square_isquartz(c, grid);
}
/**
 * True if the square is rubble.
 */
bool square_isrubble(struct chunk *c, struct loc grid)
{
    return (tf_has(f_info[square(c, grid)->feat].flags, TF_ROCK) &&
   !tf_has(f_info[square(c, grid)->feat].flags, TF_DOOR_ANY) &&
   !tf_has(f_info[square(c, grid)->feat].flags, TF_WALL));
}
/**
 * True if the square is a hidden secret door.
 *
 * These squares appear as if they were granite--when detected a secret door
 * is replaced by a closed door.
 */
bool square_issecretdoor(struct chunk *c, struct loc grid)
{
    return (tf_has(f_info[square(c, grid)->feat].flags, TF_DOOR_ANY) &&
   tf_has(f_info[square(c, grid)->feat].flags, TF_ROCK));
}
/**
 * True if the square is an open door.
 */
bool square_isopendoor(struct chunk *c, struct loc grid)
{
    return (tf_has(f_info[square(c, grid)->feat].flags, TF_CLOSABLE));
}
/**
 * True if the square is a closed door (possibly locked or jammed).
 */
bool square_iscloseddoor(struct chunk *c, struct loc grid)
{
 int feat = square(c, grid)->feat;
 return tf_has(f_info[feat].flags, TF_DOOR_CLOSED);
}
bool square_isbrokendoor(struct chunk *c, struct loc grid)
{
 int feat = square(c, grid)->feat;
    return (tf_has(f_info[feat].flags, TF_DOOR_ANY) &&
   tf_has(f_info[feat].flags, TF_PASSABLE) &&
   !tf_has(f_info[feat].flags, TF_CLOSABLE));
}
/**
 * True if the square is a door.
 *
 * This includes open, closed, and hidden doors.
 */
bool square_isdoor(struct chunk *c, struct loc grid)
{
 int feat = square(c, grid)->feat;
 return tf_has(f_info[feat].flags, TF_DOOR_ANY);
}
/**
 * True if the square is a wall.
 *
 * This includes closed doors and any type of blocking rock, including rubble.
 */
bool square_iswall(struct chunk *c, struct loc grid)
{
 int feat = square(c, grid)->feat;
 return tf_has(f_info[feat].flags, TF_DOOR_CLOSED) ||
  tf_has(f_info[feat].flags, TF_ROCK);
}
/**
 * True if square is any stair
 */
bool square_isstairs(struct chunk *c, struct loc grid)
{
 int feat = square(c, grid)->feat;
 return tf_has(f_info[feat].flags, TF_STAIR);
}
/**
 * True if square is an up stair.
 */
bool square_isupstairs(struct chunk*c, struct loc grid)
{
 int feat = square(c, grid)->feat;
 return tf_has(f_info[feat].flags, TF_UPSTAIR);
}
/**
 * True if square is a down stair.
 */
bool square_isdownstairs(struct chunk *c, struct loc grid)
{
 int feat = square(c, grid)->feat;
 return tf_has(f_info[feat].flags, TF_DOWNSTAIR);
}
/**
 * True if square is any shaft
 */
bool square_isshaft(struct chunk *c, struct loc grid)
{
 int feat = square(c, grid)->feat;
 return tf_has(f_info[feat].flags, TF_SHAFT);
}
/**
 * True if the square is a forge.
 */
bool square_isforge(struct chunk *c, struct loc grid)
{
 return feat_is_forge(square(c, grid)->feat);
}
/**
 * True if the square contains the player
 */
bool square_isplayer(struct chunk *c, struct loc grid) {
 return square(c, grid)->mon < 0 ? true : false;
}
/**
 * True if the square contains the player or a monster
 */
bool square_isoccupied(struct chunk *c, struct loc grid) {
 return square(c, grid)->mon != 0 ? true : false;
}
/**
 * True if the square is impassable (wall or chasm)
 */
bool square_isimpassable(struct chunk *c, struct loc grid) {
 return square_ischasm(c, grid) || square_isrock(c, grid);
}
/**
 * True if the player knows the terrain of the square
 */
bool square_isknown(struct chunk *c, struct loc grid) {
 if (c != cave && (!player || c != player->cave)) return false;
 if (!player->cave) return false;
 return square(player->cave, grid)->feat == FEAT_NONE ? false : true;
}
/**
 * True if the player's knowledge of the terrain of the square is wrong
 * or missing
 */
bool square_ismemorybad(struct chunk *c, struct loc grid) {
 return !square_isknown(c, grid)
  || square(player->cave, grid)->feat != square(cave, grid)->feat;
}
/**
 * True if the square is a chasm.
 */
bool square_ischasm(struct chunk *c, struct loc grid)
{
 return feat_is_chasm(square(c, grid)->feat);
}
/**
 * SQUARE INFO PREDICATES
 *
 * These functions tell whether a square is marked with one of the SQUARE_*
 * flags.  These flags are mostly used to mark a square with some information
 * about its location or status.
 */
/**
 * True if the square is marked
 */
bool square_ismark(struct chunk *c, struct loc grid) {
 assert(square_in_bounds(c, grid));
 return sqinfo_has(square(c, grid)->info, SQUARE_MARK);
}
/**
 * True if the square is lit
 */
bool square_isglow(struct chunk *c, struct loc grid) {
 assert(square_in_bounds(c, grid));
 return sqinfo_has(square(c, grid)->info, SQUARE_GLOW);
}
/**
 * True if the square is part of a vault.
 *
 * This doesn't say what kind of square it is, just that it is part of a vault.
 */
bool square_isvault(struct chunk *c, struct loc grid) {
 assert(square_in_bounds(c, grid));
 return sqinfo_has(square(c, grid)->info, SQUARE_VAULT);
}
/**
 * True if the square is part of a greater vault.
 */
bool square_isgreatervault(struct chunk *c, struct loc grid) {
 assert(square_in_bounds(c, grid));
 return sqinfo_has(square(c, grid)->info, SQUARE_G_VAULT);
}
/**
 * True if the square is part of a room.
 */
bool square_isroom(struct chunk *c, struct loc grid) {
 assert(square_in_bounds(c, grid));
 return sqinfo_has(square(c, grid)->info, SQUARE_ROOM);
}
/**
 * True if the square has been seen by the player
 */
bool square_isseen(struct chunk *c, struct loc grid) {
 assert(square_in_bounds(c, grid));
 return sqinfo_has(square(c, grid)->info, SQUARE_SEEN);
}
/**
 * True if the cave square is currently viewable by the player
 */
bool square_isview(struct chunk *c, struct loc grid) {
 assert(square_in_bounds(c, grid));
 return sqinfo_has(square(c, grid)->info, SQUARE_VIEW);
}
/**
 * True if the cave square is currently fireable by the player
 */
bool square_isfire(struct chunk *c, struct loc grid) {
 assert(square_in_bounds(c, grid));
 return sqinfo_has(square(c, grid)->info, SQUARE_FIRE);
}
/**
 * True if the cave square was seen before the current update
 */
bool square_wasseen(struct chunk *c, struct loc grid) {
 assert(square_in_bounds(c, grid));
 return sqinfo_has(square(c, grid)->info, SQUARE_WASSEEN);
}
/**
 * True if the square has a known trap
 */
bool square_istrap(struct chunk *c, struct loc grid) {
 assert(square_in_bounds(c, grid));
 return sqinfo_has(square(c, grid)->info, SQUARE_TRAP);
}
/**
 * True if the square has an unknown trap
 */
bool square_isinvis(struct chunk *c, struct loc grid) {
 assert(square_in_bounds(c, grid));
 return sqinfo_has(square(c, grid)->info, SQUARE_INVIS);
}
/**
 * True if cave square is an inner wall (generation)
 */
bool square_iswall_inner(struct chunk *c, struct loc grid) {
 assert(square_in_bounds(c, grid));
 return sqinfo_has(square(c, grid)->info, SQUARE_WALL_INNER);
}
/**
 * True if cave square is an outer wall (generation)
 */
bool square_iswall_outer(struct chunk *c, struct loc grid) {
 assert(square_in_bounds(c, grid));
 return sqinfo_has(square(c, grid)->info, SQUARE_WALL_OUTER);
}
/**
 * True if cave square is a solid wall (generation)
 */
bool square_iswall_solid(struct chunk *c, struct loc grid) {
 assert(square_in_bounds(c, grid));
 return sqinfo_has(square(c, grid)->info, SQUARE_WALL_SOLID);
}
/**
 * True if cave square will become a chasm (generation)
 */
bool square_tobechasm(struct chunk *c, struct loc grid) {
 assert(square_in_bounds(c, grid));
 return sqinfo_has(square(c, grid)->info, SQUARE_CHASM);
}
/**
 * True if cave square is marked for projection processing
 */
bool square_isproject(struct chunk *c, struct loc grid) {
 assert(square_in_bounds(c, grid));
 return sqinfo_has(square(c, grid)->info, SQUARE_PROJECT);
}
/**
 * SQUARE BEHAVIOR PREDICATES
 *
 * These functions define how a given square behaves, e.g. whether it is
 * passable by the player, whether it is diggable, contains items, etc.
 *
 * These functions use the SQUARE FEATURE PREDICATES (among other info) to
 * make the determination.
 */
/**
 * True if the square is open (a floor square not occupied by a monster).
 */
bool square_isopen(struct chunk *c, struct loc grid) {
 return square_isfloor(c, grid) && !square(c, grid)->mon;
}
/**
 * True if the square is empty (an open square without any items).
 */
bool square_isempty(struct chunk *c, struct loc grid) {
 if (square_isplayertrap(c, grid)) return false;
 if (square_iswebbed(c, grid)) return false;
 return square_isopen(c, grid) && !square_object(c, grid);
}
/**
 * True if cave square is available to create a trap
 */
bool square_isunseen(struct chunk *c, struct loc grid) {
 if (square_isseen(cave, grid)) return false;
 return square_isempty(cave, grid);
}
/**
 * True if the square is usable to place a monster.
 */
bool square_isarrivable(struct chunk *c, struct loc grid) {
 if (square_iswall(c, grid)) return false;
 if (square_ischasm(c, grid)) return false;
 if (square(c, grid)->mon) return false;
 return true;
}
/**
 * True if the square is an untrapped floor square without items.
 */
bool square_canputitem(struct chunk *c, struct loc grid) {
 if (!square_isobjectholding(c, grid)) return false;
 if (square_istrap(c, grid)) return false;
 return !square_object(c, grid);
}
/**
 * True if the square can be dug: this includes rubble and non-permanent walls.
 */
bool square_isdiggable(struct chunk *c, struct loc grid) {
 return (square_ismineral(c, grid) ||
   square_issecretdoor(c, grid) ||
   square_isrubble(c, grid));
}
/**
 * True if the square is a floor with no traps.
 */
bool square_iswebbable(struct chunk *c, struct loc grid) {
 if (square_trap(c, grid)) return false;
 return square_isfloor(c, grid);
}
/**
 * True if the square is a chasm or a known pit or false floor
 */
bool square_isleapable(struct chunk *c, struct loc grid) {
 struct trap_kind *false_floor = lookup_trap("false floor");
 if (square_istrap(c, grid) &&
  square_trap_specific(c, grid, false_floor->tidx)) {
  return true;
 }
 if (square_ispit(c, grid)) return true;
 return square_ischasm(c, grid);
}
/**
 * True if a monster can walk through the tile.
 *
 * This is needed for polymorphing. A monster may be on a feature that isn't
 * an empty space, causing problems when it is replaced with a new monster.
 */
bool square_is_monster_walkable(struct chunk *c, struct loc grid)
{
 assert(square_in_bounds(c, grid));
 return feat_is_monster_walkable(square(c, grid)->feat);
}
/**
 * True if the square is passable by the player.
 */
bool square_ispassable(struct chunk *c, struct loc grid) {
 assert(square_in_bounds(c, grid));
 return feat_is_passable(square(c, grid)->feat);
}
/**
 * True if any projectable can pass through the square.
 */
bool square_isprojectable(struct chunk *c, struct loc grid) {
 if (!square_in_bounds(c, grid)) return false;
 return feat_is_projectable(square(c, grid)->feat);
}
/**
 * True if the square allows line-of-sight.
 */
bool square_allowslos(struct chunk *c, struct loc grid) {
 assert(square_in_bounds(c, grid));
 return feat_is_los(square(c, grid)->feat);
}
/**
 * True if the square is a permanent wall or one of the "stronger" walls.
 *
 * The stronger walls are granite, magma and quartz. This excludes things like
 * secret doors and rubble.
 */
bool square_isstrongwall(struct chunk *c, struct loc grid) {
 assert(square_in_bounds(c, grid));
 return square_ismineral(c, grid) || square_isperm(c, grid);
}
/**
 * True if the cave square a pit.
 */
bool square_ispit(struct chunk *c, struct loc grid) {
 assert(square_in_bounds(c, grid));
 return feat_is_pit(square(c, grid)->feat);
}
/**
 * True if the cave square is lit.
 */
bool square_islit(struct chunk *c, struct loc grid) {
 assert(square_in_bounds(c, grid));
 return square_light(c, grid) > 0 ? true : false;
}
/**
 * True if the cave square doesn't allow monster flow information.
 */
bool square_isnoflow(struct chunk *c, struct loc grid) {
 assert(square_in_bounds(c, grid));
 return feat_is_no_flow(square(c, grid)->feat);
}
/**
 * True if the cave square doesn't carry player scent.
 */
bool square_isnoscent(struct chunk *c, struct loc grid) {
 assert(square_in_bounds(c, grid));
 return feat_is_no_scent(square(c, grid)->feat);
}
bool square_iswarded(struct chunk *c, struct loc grid)
{
 struct trap_kind *rune = lookup_trap("glyph of warding");
 return square_trap_specific(c, grid, rune->tidx);
}
bool square_iswebbed(struct chunk *c, struct loc grid)
{
 struct trap_kind *web = lookup_trap("web");
 return square_trap_specific(c, grid, web->tidx);
}
bool square_seemslikewall(struct chunk *c, struct loc grid)
{
 return tf_has(f_info[square(c, grid)->feat].flags, TF_ROCK);
}
bool square_isinteresting(struct chunk *c, struct loc grid)
{
 int f = square(c, grid)->feat;
 return tf_has(f_info[f].flags, TF_INTERESTING);
}
/**
 * True if the square is a closed, locked door.
 */
bool square_islockeddoor(struct chunk *c, struct loc grid)
{
 return square_door_lock_power(c, grid) > 0;
}
/**
 * True if the square is a closed, jammed door.
 */
bool square_isjammeddoor(struct chunk *c, struct loc grid)
{
 return square_door_jam_power(c, grid) > 0;
}
/**
 * True if there is a player trap (known or unknown) in this square.
 */
bool square_isplayertrap(struct chunk *c, struct loc grid)
{
    return square_trap_flag(c, grid, TRF_TRAP);
}
/**
 * True if there is a visible trap in this square.
 */
bool square_isvisibletrap(struct chunk *c, struct loc grid)
{
    /* Look for a visible trap */
    return square_trap_flag(c, grid, TRF_VISIBLE);
}
/**
 * True if the square is an unknown player trap (it will appear as a floor tile)
 */
bool square_issecrettrap(struct chunk *c, struct loc grid)
{
    return !square_isvisibletrap(c, grid) && square_isplayertrap(c, grid);
}
/**
 * True if the square is a known, disarmable player trap.
 */
bool square_isdisarmabletrap(struct chunk *c, struct loc grid)
{
 return square_isvisibletrap(c, grid) && square_isplayertrap(c, grid);
}
/**
 * Determine if a given location may be "destroyed"
 *
 * Used by destruction spells, and for placing stairs, etc.
 */
bool square_changeable(struct chunk *c, struct loc grid)
{
 struct object *obj;
 /* Forbid perma-grids */
 if (square_isperm(c, grid) || square_isforge(c, grid) ||
  square_isstairs(c, grid)) {
  return false;
 }
 /* Check objects */
 for (obj = square_object(c, grid); obj; obj = obj->next) {
  /* Forbid grids with indestructible objects */
  if (of_has(obj->flags, OF_INDESTRUCTIBLE)) return false;
 }
 /* Accept */
 return true;
}
bool square_in_bounds(struct chunk *c, struct loc grid)
{
 assert(c);
 return grid.x >= 0 && grid.x < c->width &&
  grid.y >= 0 && grid.y < c->height;
}
bool square_in_bounds_fully(struct chunk *c, struct loc grid)
{
 assert(c);
 return grid.x > 0 && grid.x < c->width - 1 &&
  grid.y > 0 && grid.y < c->height - 1;
}
/**
 * Checks if a square is thought by the player to block projections
 */
bool square_isbelievedwall(struct chunk *c, struct loc grid)
{
 // the edge of the world is definitely gonna block things
 if (!square_in_bounds_fully(c, grid)) return true;
 // if we dont know assume its projectable
 if (!square_isknown(c, grid)) return false;
 // report what we think (we may be wrong)
 return !square_isprojectable(player->cave, grid);
}
/**
 * Checks if a square is empty and not in a vault
 */
bool square_suits_start(struct chunk *c, struct loc grid)
{
 return square_isempty(c, grid) && !square_isvault(c, grid);
}
/**
 * Checks if a square is in a room and not next to doors
 */
bool square_suits_stairs(struct chunk *c, struct loc grid)
{
 if (!square_isempty(c, grid) || !square_isroom(c, grid)) return false;
 return !square_num_doors_adjacent(c, grid);
}
/**
 * Checks if a square is appropriate for placing a summoned creature.
 */
bool square_allows_summon(struct chunk *c, struct loc grid)
{
 return square_isempty(c, grid) && !square_iswarded(c, grid);
}
/**
 * Determines whether a square is viewable (only) by the keen senses ability.
 *
 * Note that there is a slight flaw in the implementation.
 * Since light levels are not adjusted by monsters/items if out of view
 * this means that if a square adjacent to the monster is out of view but lit
 * and the monster's square is not lit, then sometimes it won't show when it
 * should show.
 * This is pretty rare though, and I doubt it is very noticeable.
 */
bool square_seen_by_keen_senses(struct chunk *c, struct loc grid)
{
 if (player_active_ability(player, "Keen Senses") &&
  square_isview(c, grid) && (square_light(c, grid) == 0)) {
  int d;
  for (d = 0; d < 8; d++) {
   /* Child location */
   struct loc grid1 = loc_sum(grid, ddgrid_ddd[d]);
   /* Check Bounds */
   if (!square_in_bounds(c, grid1)) continue;
   if ((square_light(c, grid1) > 0) && square_isfloor(c, grid1) &&
    square_isview(c, grid1)) {
    return true;
   }
  }
 }
 return false;
}
/**
 * OTHER SQUARE FUNCTIONS
 *
 * Below are various square-specific functions which are not predicates
 */
const struct square *square(struct chunk *c, struct loc grid)
{
 assert(square_in_bounds(c, grid));
 return &c->squares[grid.y][grid.x];
}
struct feature *square_feat(struct chunk *c, struct loc grid)
{
 assert(square_in_bounds(c, grid));
 return &f_info[square(c, grid)->feat];
}
int square_light(struct chunk *c, struct loc grid)
{
 assert(square_in_bounds(c, grid));
 return square(c, grid)->light;
}
/**
 * Get a monster on the current level by its position.
 */
struct monster *square_monster(struct chunk *c, struct loc grid)
{
 if (!square_in_bounds(c, grid)) return NULL;
 if (square(c, grid)->mon > 0) {
  struct monster *mon = cave_monster(c, square(c, grid)->mon);
  return mon && mon->race ? mon : NULL;
 }
 return NULL;
}
/**
 * Get the top object of a pile on the current level by its position.
 */
struct object *square_object(struct chunk *c, struct loc grid) {
 if (!square_in_bounds(c, grid)) return NULL;
 return square(c, grid)->obj;
}
/**
 * Get the first (and currently only) trap in a position on the current level.
 */
struct trap *square_trap(struct chunk *c, struct loc grid)
{
 if (!square_in_bounds(c, grid)) return NULL;
    return square(c, grid)->trap;
}
/**
 * Return true if the given object is on the floor at this grid
 */
bool square_holds_object(struct chunk *c, struct loc grid, struct object *obj) {
 assert(square_in_bounds(c, grid));
 return pile_contains(square_object(c, grid), obj);
}
/**
 * Excise an object from a floor pile, leaving it orphaned.
 */
void square_excise_object(struct chunk *c, struct loc grid, struct object *obj){
 assert(square_in_bounds(c, grid));
 pile_excise(&c->squares[grid.y][grid.x].obj, obj);
}
/**
 * Excise an entire floor pile.
 */
void square_excise_pile(struct chunk *c, struct loc grid) {
 struct chunk *p_c = (player && c == cave) ? player->cave : NULL;
 assert(square_in_bounds(c, grid));
 object_pile_free(c, p_c, square_object(c, grid));
 square_set_obj(c, grid, NULL);
}
/**
 * Remove all imagined objects from a floor pile.
 *
 * \param p_c is the chunk for a player's point of view which will be tested
 * for the imagined objects.
 * \param c is the chunk (typically cave) which holds the orphaned objects
 * corresponding to the imagined objects in p_c.
 * \param grid is the grid to check for imagined objects.
 *
 * If calling square_excise_pile() on p_c it will necessary to call this
 * function first to avoid leaving dangling references (via the known pointer
 * in orphaned objects within c's object list).
 */
void square_excise_all_imagined(struct chunk *p_c, struct chunk *c,
  struct loc grid)
{
 struct object *obj;
 assert(square_in_bounds(p_c, grid));
 obj = square_object(p_c, grid);
 while (obj) {
  struct object *next = obj->next;
  if (obj->notice & OBJ_NOTICE_IMAGINED) {
   struct object *original;
   assert(c->objects && c->objects[obj->oidx]);
   original = c->objects[obj->oidx];
   square_excise_object(p_c, grid, obj);
   delist_object(p_c, obj);
   object_delete(p_c, NULL, &obj);
   original->known = NULL;
   delist_object(c, original);
   object_delete(c, p_c, &original);
  }
  obj = next;
 }
}
/**
 * Excise an object from a floor pile and delete it while doing the other
 * necessary bookkeeping.  Normally, this is only called for the chunk
 * representing the true nature of the environment and not the one
 * representing the player's view of it.  If do_note is true, call
 * square_note_spot().  If do_light is true, call square_light_spot().
 * Unless calling this on the player's view, those both would be true
 * except as an optimization/simplification when the caller would call
 * square_note_spot()/square_light_spot() anyways or knows that those aren't
 * necessary.
 */
void square_delete_object(struct chunk *c, struct loc grid, struct object *obj,
        bool do_note, bool do_light)
{
 struct chunk *p_c = (c == cave) ? player->cave : NULL;
 square_excise_object(c, grid, obj);
 delist_object(c, obj);
 object_delete(c, p_c, &obj);
 if (do_note) {
  square_note_spot(c, grid);
 }
 if (do_light) {
  square_light_spot(c, grid);
 }
}
/**
 * Helper for square_know_pile():  remove known
 * location for the requested items that are not on this grid.
 */
static void forget_remembered_objects(struct chunk *c, struct chunk *knownc,
  struct loc grid)
{
 struct object *obj = square_object(knownc, grid);
 while (obj) {
  struct object *next = obj->next;
  struct object *original = c->objects[obj->oidx];
  assert(original);
  if (!square_holds_object(c, grid, original)) {
   square_excise_object(knownc, grid, obj);
   obj->grid = loc(0, 0);
   /* Delete objects which no longer exist anywhere */
   if (obj->notice & OBJ_NOTICE_IMAGINED) {
    delist_object(knownc, obj);
    object_delete(knownc, NULL, &obj);
    original->known = NULL;
    delist_object(c, original);
    object_delete(c, knownc, &original);
   }
  }
  obj = next;
 }
}
/**
 * Update the player's knowledge of the objects on a grid in the current level
 */
void square_know_pile(struct chunk *c, struct loc grid)
{
 struct object *obj;
 if (c != cave) return;
 object_lists_check_integrity(c, player->cave);
 /* Know every item on this grid */
 for (obj = square_object(c, grid); obj; obj = obj->next) {
  object_see(player, obj);
  if (loc_eq(grid, player->grid)) {
   object_touch(player, obj);
  }
 }
 forget_remembered_objects(c, player->cave, grid);
}
/**
 * Return how many cardinal directions around (x, y) contain doors.
 * \param c current chunk
 * \param y co-ordinates
 * \param x co-ordinates
 * \return the number of walls
 */
int square_num_doors_adjacent(struct chunk *c, struct loc grid)
{
    int k = 0;
    assert(square_in_bounds(c, grid));
    if (square_isdoor(c, next_grid(grid, DIR_S))) k++;
    if (square_isdoor(c, next_grid(grid, DIR_N))) k++;
    if (square_isdoor(c, next_grid(grid, DIR_E))) k++;
    if (square_isdoor(c, next_grid(grid, DIR_W))) k++;
    return k;
}
/**
 * Return how many diagonal directions around (x, y) contain walls.
 * \param c current chunk
 * \param y co-ordinates
 * \param x co-ordinates
 * \return the number of walls
 */
int square_num_walls_diagonal(struct chunk *c, struct loc grid)
{
    int k = 0;
    assert(square_in_bounds(c, grid));
    if (feat_is_wall(square(c, next_grid(grid, DIR_SE))->feat)) k++;
    if (feat_is_wall(square(c, next_grid(grid, DIR_NW))->feat)) k++;
    if (feat_is_wall(square(c, next_grid(grid, DIR_NE))->feat)) k++;
    if (feat_is_wall(square(c, next_grid(grid, DIR_SW))->feat)) k++;
    return k;
}
/**
 * Set the terrain type for a square.
 *
 * This should be the only function that sets terrain, apart from the savefile
 * loading code.
 */
void square_set_feat(struct chunk *c, struct loc grid, int feat)
{
 int current_feat;
 assert(square_in_bounds(c, grid));
 current_feat = square(c, grid)->feat;
 /* Track changes */
 if (current_feat) c->feat_count[current_feat]--;
 if (feat) c->feat_count[feat]++;
 /* Make the change */
 c->squares[grid.y][grid.x].feat = feat;
 /* Make the new terrain feel at home */
 if (character_dungeon) {
  /* Remove traps if necessary */
  if (!square_istrappable(c, grid))
   square_destroy_trap(c, grid);
  square_note_spot(c, grid);
  square_light_spot(c, grid);
 } else {
  /* Make sure no incorrect wall flags set for dungeon generation */
  sqinfo_off(square(c, grid)->info, SQUARE_WALL_INNER);
  sqinfo_off(square(c, grid)->info, SQUARE_WALL_OUTER);
  sqinfo_off(square(c, grid)->info, SQUARE_WALL_SOLID);
 }
}
/**
 * Set the player-"known" terrain type for a square.
 */
static void square_set_known_feat(struct chunk *c, struct loc grid, int feat)
{
 if (c != cave) return;
 player->cave->squares[grid.y][grid.x].feat = feat;
}
/**
 * Set the occupying monster for a square.
 */
void square_set_mon(struct chunk *c, struct loc grid, int midx)
{
 c->squares[grid.y][grid.x].mon = midx;
}
/**
 * Set the (first) object for a square.
 */
void square_set_obj(struct chunk *c, struct loc grid, struct object *obj)
{
 c->squares[grid.y][grid.x].obj = obj;
}
/**
 * Set the (first) trap for a square.
 */
void square_set_trap(struct chunk *c, struct loc grid, struct trap *trap)
{
 c->squares[grid.y][grid.x].trap = trap;
}
void square_add_trap(struct chunk *c, struct loc grid)
{
 assert(square_in_bounds_fully(c, grid));
 if (!square_isempty(c, grid)) return;
 place_trap(c, grid, -1, c->depth);
}
void square_add_glyph(struct chunk *c, struct loc grid, int type)
{
 struct trap_kind *glyph = NULL;
 switch (type) {
  case GLYPH_WARDING: {
   glyph = lookup_trap("glyph of warding");
   break;
  }
  default: {
   msg("Non-existent glyph requested. Please report this bug.");
   return;
  }
 }
 place_trap(c, grid, glyph->tidx, 0);
}
void square_add_web(struct chunk *c, struct loc grid)
{
 struct trap_kind *web = lookup_trap("web");
 place_trap(c, grid, web->tidx, 0);
}
void square_add_stairs(struct chunk *c, struct loc grid, int depth) {
 int down = randint0(100) < 50;
 if (depth == 0)
  down = 1;
 else if (depth >= z_info->dun_depth)
  down = 0;
 square_set_feat(c, grid, down ? FEAT_MORE : FEAT_LESS);
}
void square_add_door(struct chunk *c, struct loc grid, bool closed) {
 square_set_feat(c, grid, closed ? FEAT_CLOSED : FEAT_OPEN);
}
void square_open_door(struct chunk *c, struct loc grid)
{
 square_remove_all_traps(c, grid);
 square_set_feat(c, grid, FEAT_OPEN);
}
void square_close_door(struct chunk *c, struct loc grid)
{
 square_set_feat(c, grid, FEAT_CLOSED);
}
void square_smash_door(struct chunk *c, struct loc grid)
{
 square_remove_all_traps(c, grid);
 square_set_feat(c, grid, FEAT_BROKEN);
}
void square_unlock_door(struct chunk *c, struct loc grid) {
 assert(square_islockeddoor(c, grid));
 square_set_door_lock(c, grid, 0);
}
void square_destroy_door(struct chunk *c, struct loc grid) {
 assert(square_isdoor(c, grid));
 square_remove_all_traps(c, grid);
 square_set_feat(c, grid, FEAT_FLOOR);
}
void square_destroy_trap(struct chunk *c, struct loc grid)
{
 square_remove_all_traps(c, grid);
}
void square_tunnel_wall(struct chunk *c, struct loc grid)
{
 if (square_isrubble(c, grid)) {
  square_set_feat(c, grid, FEAT_FLOOR);
 } else if (square_issecretdoor(c, grid)) {
  square_set_feat(c, grid, FEAT_CLOSED);
 } else {
  square_set_feat(c, grid, FEAT_RUBBLE);
 }
}
void square_destroy_wall(struct chunk *c, struct loc grid)
{
 square_set_feat(c, grid, FEAT_FLOOR);
}
void square_smash_wall(struct chunk *c, struct loc grid)
{
 int i;
 square_set_feat(c, grid, FEAT_FLOOR);
 for (i = 0; i < 8; i++) {
  /* Extract adjacent location */
  struct loc adj_grid = loc_sum(grid, ddgrid_ddd[i]);
  /* Check legality */
  if (!square_in_bounds_fully(c, adj_grid)) continue;
  /* Ignore permanent grids */
  if (square_isperm(c, adj_grid)) continue;
  /* Ignore floors */
  if (square_isfloor(c, adj_grid)) {
   continue;
  }
  /* Give this grid a chance to survive */
  if ((square_isgranite(c, adj_grid) && one_in_(4)) ||
   (square_isquartz(c, adj_grid) && one_in_(10))) {
   continue;
  }
  /* Remove it */
  square_set_feat(c, adj_grid, FEAT_FLOOR);
 }
}
void square_destroy_rubble(struct chunk *c, struct loc grid) {
 assert(square_isrubble(c, grid));
 square_set_feat(c, grid, FEAT_FLOOR);
}
void square_force_floor(struct chunk *c, struct loc grid) {
 square_set_feat(c, grid, FEAT_FLOOR);
}
int square_forge_bonus(struct chunk *c, struct loc grid) {
 if (square_isforge(c, grid))
  return f_info[square(c, grid)->feat].forge_bonus;
 return 0;
}
int square_digging(struct chunk *c, struct loc grid) {
 if (square_isdiggable(c, grid))
  return f_info[square(c, grid)->feat].dig;
 return 0;
}
int square_pit_difficulty(struct chunk *c, struct loc grid) {
 if (square_ispit(c, grid))
  return f_info[square(c, grid)->feat].pit_difficulty;
 return 0;
}
/**
 * Return the name for the terrain in a grid.  Accounts for the fact that
 * some terrain mimics another terrain.
 *
 * \param c Is the chunk to use.  Usually it is the player's version of the
 * chunk.
 * \param grid Is the grid to use.
 * \param name Is the buffer to hold the returned name.
 * \param size Is the maximum number of characters name can hold.
 */
void square_apparent_name(struct chunk *c, struct loc grid, char *name,
        int size)
{
 int actual = square_isknown(c, grid) ? square(c, grid)->feat : 0;
 const struct feature *fp = f_info[actual].mimic ?
  f_info[actual].mimic : &f_info[actual];
 char forge_string[40];
 /* Handle forges */
 if (square_isforge(c, grid)) {
  /* Use actual forge uses */
  int uses = square_forge_uses(cave, grid);
  if (!uses) {
   my_strcpy(forge_string, " (exhausted)", sizeof(forge_string));
  } else if (uses == 1) {
   my_strcpy(forge_string, " (1 use remaining)", sizeof(forge_string));
  } else {
   strnfmt(forge_string, sizeof(forge_string), " (%d uses remaining)",
     uses);
  }
 } else {
  my_strcpy(forge_string, "", sizeof(forge_string));
 }
 strnfmt(name, size, "%s%s", fp->name, forge_string);
}
/**
 * Return the prefix, appropriate for describing looking at the grid in
 * question, for the name returned by square_name().
 *
 * \param c Is the chunk to use.  Usually it is the player's version of the
 * chunk.
 * \param grid Is the grid to use.
 *
 * The prefix is usually an indefinite article.  It may be an empty string.
 */
const char *square_apparent_look_prefix(struct chunk *c, struct loc grid) {
 int actual = square_isknown(c, grid) ? square(c, grid)->feat : 0;
 const struct feature *fp = f_info[actual].mimic ?
  f_info[actual].mimic : &f_info[actual];
 return (fp->look_prefix) ? fp->look_prefix :
  (is_a_vowel(fp->name[0]) ? "an " : "a ");
}
/**
 * Return a preposition, appropriate for describing the grid the viewer is on,
 * for the name returned by square_name().  May return an empty string when
 * the name doesn't require a preposition.
 *
 * \param c Is the chunk to use.  Usually it is the player's version of the
 * chunk.
 * \param grid Is the grid to use.
 */
const char *square_apparent_look_in_preposition(struct chunk *c, struct loc grid) {
 int actual = square(c, grid)->feat;
 const struct feature *fp = f_info[actual].mimic ?
  f_info[actual].mimic : &f_info[actual];
 return (fp->look_in_preposition) ? fp->look_in_preposition : "on ";
}
/* Memorize the terrain */
void square_memorize(struct chunk *c, struct loc grid) {
 if (c != cave) return;
 square_set_known_feat(c, grid, square(c, grid)->feat);
}
/* Forget the terrain */
void square_forget(struct chunk *c, struct loc grid) {
 if (c != cave) return;
 square_set_known_feat(c, grid, FEAT_NONE);
}
void square_mark(struct chunk *c, struct loc grid) {
 sqinfo_on(square(c, grid)->info, SQUARE_MARK);
}
void square_unmark(struct chunk *c, struct loc grid) {
 sqinfo_off(square(c, grid)->info, SQUARE_MARK);
}
/**
 * \file cave-view.c
 * \brief Line-of-sight and view calculations
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Approximate distance between two points.
 *
 * When either the X or Y component dwarfs the other component,
 * this function is almost perfect, and otherwise, it tends to
 * over-estimate about one grid per fifteen grids of distance.
 *
 * Algorithm: hypot(dy,dx) = max(dy,dx) + min(dy,dx) / 2
 */
int distance(struct loc grid1, struct loc grid2)
{
 /* Find the absolute y/x distance components */
 int ay = abs(grid2.y - grid1.y);
 int ax = abs(grid2.x - grid1.x);
 /* Approximate the distance */
 return ay > ax ? ay + (ax >> 1) : ax + (ay >> 1);
}
/**
 * A simple, fast, integer-based line-of-sight algorithm.  By Joseph Hall,
 * 4116 Brewster Drive, Raleigh NC 27606.  Email to jnh@ecemwl.ncsu.edu.
 *
 * This function returns true if a "line of sight" can be traced from the
 * center of the grid (x1,y1) to the center of the grid (x2,y2), with all
 * of the grids along this path (except for the endpoints) being non-wall
 * grids.  Actually, the "chess knight move" situation is handled by some
 * special case code which allows the grid diagonally next to the player
 * to be obstructed, because this yields better gameplay semantics.  This
 * algorithm is totally reflexive, except for "knight move" situations.
 *
 * Because this function uses (short) ints for all calculations, overflow
 * may occur if dx and dy exceed 90.
 *
 * Once all the degenerate cases are eliminated, we determine the "slope"
 * ("m"), and we use special "fixed point" mathematics in which we use a
 * special "fractional component" for one of the two location components
 * ("qy" or "qx"), which, along with the slope itself, are "scaled" by a
 * scale factor equal to "abs(dy*dx*2)" to keep the math simple.  Then we
 * simply travel from start to finish along the longer axis, starting at
 * the border between the first and second tiles (where the y offset is
 * thus half the slope), using slope and the fractional component to see
 * when motion along the shorter axis is necessary.  Since we assume that
 * vision is not blocked by "brushing" the corner of any grid, we must do
 * some special checks to avoid testing grids which are "brushed" but not
 * actually "entered".
 *
 * Angband three different "line of sight" type concepts, including this
 * function (which is used almost nowhere), the "project()" method (which
 * is used for determining the paths of projectables and spells and such),
 * and the "update_view()" concept (which is used to determine which grids
 * are "viewable" by the player, which is used for many things, such as
 * determining which grids are illuminated by the player's torch, and which
 * grids and monsters can be "seen" by the player, etc).
 */
bool los(struct chunk *c, struct loc grid1, struct loc grid2)
{
 /* Delta */
 int dx, dy;
 /* Absolute */
 int ax, ay;
 /* Signs */
 int sx, sy;
 /* Fractions */
 int qx, qy;
 /* Scanners */
 int tx, ty;
 /* Scale factors */
 int f1, f2;
 /* Slope, or 1/Slope, of LOS */
 int m;
 /* Extract the offset */
 dy = grid2.y - grid1.y;
 dx = grid2.x - grid1.x;
 /* Extract the absolute offset */
 ay = ABS(dy);
 ax = ABS(dx);
 /* Handle adjacent (or identical) grids */
 if ((ax < 2) && (ay < 2)) return (true);
 /* Directly South/North */
 if (!dx) {
  /* South -- check for walls */
  if (dy > 0) {
   for (ty = grid1.y + 1; ty < grid2.y; ty++)
    if (!square_isprojectable(c, loc(grid1.x, ty))) return (false);
  } else { /* North -- check for walls */
   for (ty = grid1.y - 1; ty > grid2.y; ty--)
    if (!square_isprojectable(c, loc(grid1.x, ty))) return (false);
  }
  /* Assume los */
  return (true);
 }
 /* Directly East/West */
 if (!dy) {
  /* East -- check for walls */
  if (dx > 0) {
   for (tx = grid1.x + 1; tx < grid2.x; tx++)
    if (!square_isprojectable(c, loc(tx, grid1.y))) return (false);
  } else { /* West -- check for walls */
   for (tx = grid1.x - 1; tx > grid2.x; tx--)
    if (!square_isprojectable(c, loc(tx, grid1.y))) return (false);
  }
  /* Assume los */
  return (true);
 }
 /* Extract some signs */
 sx = (dx < 0) ? -1 : 1;
 sy = (dy < 0) ? -1 : 1;
 /* Vertical and horizontal "knights" */
 if ((ax == 1) && (ay == 2) &&
  square_isprojectable(c, loc(grid1.x, grid1.y + sy))) {
  return (true);
 } else if ((ay == 1) && (ax == 2) &&
      square_isprojectable(c, loc(grid1.x + sx, grid1.y))) {
  return (true);
 }
 /* Calculate scale factor div 2 */
 f2 = (ax * ay);
 /* Calculate scale factor */
 f1 = f2 << 1;
 /* Travel horizontally */
 if (ax >= ay) {
  /* Let m = dy / dx * 2 * (dy * dx) = 2 * dy * dy */
  qy = ay * ay;
  m = qy << 1;
  tx = grid1.x + sx;
  /* Consider the special case where slope == 1. */
  if (qy == f2) {
   ty = grid1.y + sy;
   qy -= f1;
  } else {
   ty = grid1.y;
  }
  /* Note (below) the case (qy == f2), where */
  /* the LOS exactly meets the corner of a tile. */
  while (grid2.x - tx) {
   if (!square_isprojectable(c, loc(tx, ty)))
    return (false);
   qy += m;
   if (qy < f2) {
    tx += sx;
   } else if (qy > f2) {
    ty += sy;
    if (!square_isprojectable(c, loc(tx, ty)))
     return (false);
    qy -= f1;
    tx += sx;
   } else {
    ty += sy;
    qy -= f1;
    tx += sx;
   }
  }
 } else { /* Travel vertically */
  /* Let m = dx / dy * 2 * (dx * dy) = 2 * dx * dx */
  qx = ax * ax;
  m = qx << 1;
  ty = grid1.y + sy;
  if (qx == f2) {
   tx = grid1.x + sx;
   qx -= f1;
  } else {
   tx = grid1.x;
  }
  /* Note (below) the case (qx == f2), where */
  /* the LOS exactly meets the corner of a tile. */
  while (grid2.y - ty) {
   if (!square_isprojectable(c, loc(tx, ty)))
    return (false);
   qx += m;
   if (qx < f2) {
    ty += sy;
   } else if (qx > f2) {
    tx += sx;
    if (!square_isprojectable(c, loc(tx, ty)))
     return (false);
    qx -= f1;
    ty += sy;
   } else {
    tx += sx;
    qx -= f1;
    ty += sy;
   }
  }
 }
 /* Assume los */
 return (true);
}
/**
 * The comments below are still predominantly true, and have been left
 * (slightly modified for accuracy) for historical and nostalgic reasons.
 *
 * Some comments on the dungeon related data structures and functions...
 *
 * Angband is primarily a dungeon exploration game, and it should come as
 * no surprise that the internal representation of the dungeon has evolved
 * over time in much the same way as the game itself, to provide semantic
 * changes to the game itself, to make the code simpler to understand, and
 * to make the executable itself faster or more efficient in various ways.
 *
 * There are a variety of dungeon related data structures, and associated
 * functions, which store information about the dungeon, and provide methods
 * by which this information can be accessed or modified.
 *
 * Some of this information applies to the dungeon as a whole, such as the
 * list of unique monsters which are still alive.  Some of this information
 * only applies to the current dungeon level, such as the current depth, or
 * the list of monsters currently inhabiting the level.  And some of the
 * information only applies to a single grid of the current dungeon level,
 * such as whether the grid is illuminated, or whether the grid contains a
 * monster, or whether the grid can be seen by the player.  If Angband was
 * to be turned into a multi-player game, some of the information currently
 * associated with the dungeon should really be associated with the player,
 * such as whether a given grid is viewable by a given player.
 *
 * Currently, a lot of the information about the dungeon is stored in ways
 * that make it very efficient to access or modify the information, while
 * still attempting to be relatively conservative about memory usage, even
 * if this means that some information is stored in multiple places, or in
 * ways which require the use of special code idioms.  For example, each
 * monster record in the monster array contains the location of the monster,
 * and each cave grid has an index into the monster array, or a zero if no
 * monster is in the grid.  This allows the monster code to efficiently see
 * where the monster is located, while allowing the dungeon code to quickly
 * determine not only if a monster is present in a given grid, but also to
 * find out which monster.  The extra space used to store the information
 * twice is inconsequential compared to the speed increase.
 *
 * Several pieces of information about each cave grid are stored in the
 * info field of the "cave->squares" array, which is a special array of
 * bitflags.
 *
 * The "SQUARE_ROOM" flag is used to determine which grids are part of "rooms", 
 * and thus which grids are affected by "illumination" spells.
 *
 * The "SQUARE_VAULT" flag is used to determine which grids are part of 
 * "vaults", and thus which grids cannot serve as the destinations of player 
 * teleportation.
 *
 * The "SQUARE_GLOW" flag is used to determine which grids are "permanently 
 * illuminated".  This flag is used by the update_view() function to help 
 * determine which viewable grids may be "seen" by the player.  This flag
 * has special semantics for wall grids (see "update_view()").
 *
 * The "SQUARE_VIEW" flag is used to determine which grids are currently in
 * line of sight of the player.  This flag is set by (and used by) the
 * "update_view()" function.  This flag is used by any code which needs to
 * know if the player can "view" a given grid.  This flag is used by the
 * "map_info()" function for some optional special lighting effects.  The
 * "player_has_los_bold()" macro wraps an abstraction around this flag, but
 * certain code idioms are much more efficient.  This flag is used to check
 * if a modification to a terrain feature might affect the player's field of
 * view.  This flag is used to see if certain monsters are "visible" to the
 * player.  This flag is used to allow any monster in the player's field of
 * view to "sense" the presence of the player.
 *
 * The "SQUARE_SEEN" flag is used to determine which grids are currently in
 * line of sight of the player and also illuminated in some way.  This flag
 * is set by the "update_view()" function, using computations based on the
 * "SQUARE_VIEW" and "SQUARE_GLOW" flags and terrain of various grids.  
 * This flag is used by any code which needs to know if the player can "see" a
 * given grid.  This flag is used by the "map_info()" function both to see
 * if a given "boring" grid can be seen by the player, and for some optional
 * special lighting effects.  The "player_can_see_bold()" macro wraps an
 * abstraction around this flag, but certain code idioms are much more
 * efficient.  This flag is used to see if certain monsters are "visible" to
 * the player.  This flag is never set for a grid unless "SQUARE_VIEW" is also
 * set for the grid.  Whenever the terrain or "SQUARE_GLOW" flag changes
 * for a grid which has the "SQUARE_VIEW" flag set, the "SQUARE_SEEN" flag must
 * be recalculated.  The simplest way to do this is to call "forget_view()"
 * and "update_view()" whenever the terrain or "SQUARE_GLOW" flag changes
 * for a grid which has "SQUARE_VIEW" set.
 *
 * The "SQUARE_WASSEEN" flag is used for a variety of temporary purposes.  This
 * flag is used to determine if the "SQUARE_SEEN" flag for a grid has changed
 * during the "update_view()" function.  This flag is used to "spread" light
 * or darkness through a room.  This flag is used by the "monster flow code".
 * This flag must always be cleared by any code which sets it.
 *
 * The "SQUARE_CLOSE_PLAYER" flag is set for squares that are seen and either
 * in the player's light radius or the UNLIGHT detection radius.  It is used
 * by "map_info()" to select which lighting effects to apply to a square.
 *
 * The "update_view()" function is an extremely important function.  It is
 * called only when the player moves, significant terrain changes, or the
 * player's blindness or torch radius changes.  Note that when the player
 * is resting, or performing any repeated actions (like digging, disarming,
 * farming, etc), there is no need to call the "update_view()" function, so
 * even if it was not very efficient, this would really only matter when the
 * player was "running" through the dungeon.  It sets the "SQUARE_VIEW" flag
 * on every cave grid in the player's field of view.  It also checks the torch
 * radius of the player, and sets the "SQUARE_SEEN" flag for every grid which
 * is in the "field of view" of the player and which is also "illuminated",
 * either by the player's torch (if any), light from monsters, light from
 * bright terrain, or by any permanent light source (as marked by SQUARE_GLOW).
 * It could use and help maintain information about multiple light sources,
 * which would be helpful in a multi-player version of Angband.
 *
 * Note that the "update_view()" function allows, among other things, a room
 * to be "partially" seen as the player approaches it, with a growing cone
 * of floor appearing as the player gets closer to the door.  Also, by not
 * turning on the "memorize perma-lit grids" option, the player will only
 * "see" those floor grids which are actually in line of sight.  And best
 * of all, you can now activate the special lighting effects to indicate
 * which grids are actually in the player's field of view by using dimmer
 * colors for grids which are not in the player's field of view, and/or to
 * indicate which grids are illuminated only by the player's torch by using
 * the color yellow for those grids.
 *
 * It seems as though slight modifications to the "update_view()" functions
 * would allow us to determine "reverse" line-of-sight as well as "normal"
 * line-of-sight", which would allow monsters to have a more "correct" way
 * to determine if they can "see" the player, since right now, they "cheat"
 * somewhat and assume that if the player has "line of sight" to them, then
 * they can "pretend" that they have "line of sight" to the player.  But if
 * such a change was attempted, the monsters would actually start to exhibit
 * some undesirable behavior, such as "freezing" near the entrances to long
 * hallways containing the player, and code would have to be added to make
 * the monsters move around even if the player was not detectable, and to
 * "remember" where the player was last seen, to avoid looking stupid.
 *
 * Note that the "SQUARE_GLOW" flag means that a grid is permanently lit in
 * some way.  However, for the player to "see" the grid, as determined by
 * the "SQUARE_SEEN" flag, the player must not be blind, the grid must have
 * the "SQUARE_VIEW" flag set, and if the grid is a "wall" grid, and it is
 * not lit by some other light source, then it must touch a projectable grid
 * which has both the "SQUARE_GLOW" and "SQUARE_VIEW" flags set.  This last
 * part about wall grids is induced by the semantics of "SQUARE_GLOW" as
 * applied to wall grids, and checking the technical requirements can be very
 * expensive, especially since the grid may be touching some "illegal" grids.
 * Luckily, it is more or less correct to restrict the "touching" grids from
 * the eight "possible" grids to the (at most) three grids which are touching
 * the grid, and which are closer to the player than the grid itself, which
 * eliminates more than half of the work, including all of the potentially
 * "illegal" grids, if at most one of the three grids is a "diagonal" grid.
 * In addition, in almost every situation, it is possible to ignore the
 * "SQUARE_VIEW" flag on these three "touching" grids, for a variety of
 * technical reasons.  Finally, note that in most situations, it is only
 * necessary to check a single "touching" grid, in fact, the grid which is
 * strictly closest to the player of all the touching grids, and in fact,
 * it is normally only necessary to check the "SQUARE_GLOW" flag of that grid,
 * again, for various technical reasons.  However, one of the situations which
 * does not work with this last reduction is the very common one in which the
 * player approaches an illuminated room from a dark hallway, in which the
 * two wall grids which form the "entrance" to the room would not be marked
 * as "SQUARE_SEEN", since of the three "touching" grids nearer to the player
 * than each wall grid, only the farthest of those grids is itself marked
 * "SQUARE_GLOW".
 *
 *
 * Here are some pictures of the legal "light source" radius values, in
 * which the numbers indicate the "order" in which the grids could have
 * been calculated, if desired.  Note that the code will work with larger
 * radiuses, though currently yields such a radius, and the game would
 * become slower in some situations if it did.
 *
 *       Rad=0     Rad=1      Rad=2        Rad=3
 *      No-Light Torch,etc   Lantern     Artifacts
 *
 *                                          333
 *                             333         43334
 *                  212       32123       3321233
 *         @        1@1       31@13       331@133
 *                  212       32123       3321233
 *                             333         43334
 *                                          333
 *
 */
/**
 * Mark the currently seen grids, then wipe in preparation for recalculating
 */
static void mark_wasseen(struct chunk *c)
{
 int x, y;
 /* Save the old "view" grids for later */
 for (y = 0; y < c->height; y++) {
  for (x = 0; x < c->width; x++) {
   struct loc grid = loc(x, y);
   if (square_isseen(c, grid))
    sqinfo_on(square(c, grid)->info, SQUARE_WASSEEN);
   sqinfo_off(square(c, grid)->info, SQUARE_VIEW);
   sqinfo_off(square(c, grid)->info, SQUARE_SEEN);
   sqinfo_off(square(c, grid)->info, SQUARE_CLOSE_PLAYER);
  }
 }
}
/**
 * Help glow_can_light_wall(), add_light() and calc_lighting():  check for
 * whether a wall can appear to be lit, as viewed by the player, by a light
 * source regardless of line-of-sight details.
 * \param c Is the chunk in which to do the evaluation.
 * \param p Is the player to test.
 * \param sgrid Is the location of the light source.
 * \param wgrid Is the location of the wall.
 * \return Return true if the wall will appear to be lit for the player.
 * Otherwise, return false.
 */
static bool source_can_light_wall(struct chunk *c, struct player *p,
  struct loc sgrid, struct loc wgrid)
{
 struct loc sn = next_grid(wgrid, motion_dir(wgrid, sgrid)), pn, cn;
 /*
	 * If the light source is coincident with the wall, all faces will be
	 * lit, and the player can potentially see it if it's within range and
	 * the line of sight isn't broken.
	 */
 if (loc_eq(sn, wgrid)) return true;
 /*
	 * If the player is coincident with the wall, all faces of the wall are
	 * visible to the player and the player can see whichever of those is
	 * lit by the light source.
	 */
 pn = next_grid(wgrid, motion_dir(wgrid, p->grid));
 if (loc_eq(pn, wgrid)) return true;
 /*
	 * For the lit face of the wall to be visible to the player, the
	 * view directions from the wall to the player and the wall to the
	 * light source must share at least one component.
	 */
 if (sn.x == pn.x) {
  /*
		 * If the view directions share both components, the lit face
		 * will be visible to the player if in range and the line of
		 * sight isn't broken.
		 */
  if (sn.y == pn.y) return true;
  cn.x = sn.x;
  cn.y = 0;
 } else if (sn.y == pn.y) {
  cn.x = 0;
  cn.y = sn.y;
 } else {
  /*
		 * If the view directions don't share a component, the lit face
		 * is not visible to the player.
		 */
  return false;
 }
 /*
	 * When only one component of the view directions is shared, take the
	 * common component and test whether there's a wall there that would
	 * block the player's view of the lit face.  That prevents instances
	 * like this:
	 *  p
	 * ###1#
	 *  @
	 * where both the light-emitting monster, 'p', and the player, '@',
	 * have line of sight to the wall, '1', but the face of '1' that would
	 * be lit is blocked by the wall immediately to the left of '1'.
	 */
 return square_allowslos(c, cn);
}
/**
 * Help calc_lighting():  check for whether a wall marked with SQUARE_GLOW
 * can appear to be lit, as viewed by the player regardless of line-of-sight
 * details.
 * \param c Is the chunk in which to do the evaluation.
 * \param p Is the player to test.
 * \param wgrid Is the location of the wall.
 * \return Return true if the wall will appear to be lit for the player.
 * Otherwise, return false.
 */
static bool glow_can_light_wall(struct chunk *c, struct player *p,
  struct loc wgrid)
{
 struct loc pn = next_grid(wgrid, motion_dir(wgrid, p->grid)), chk;
 /*
	 * If the player is in the wall grid, the player will see the lit face.
	 */
 if (loc_eq(pn, wgrid)) return true;
 /*
	 * If the grid in the direction of the player is not a wall and is
	 * glowing, it'll illuminate the wall.
	 */
 if (square_allowslos(c, pn) && square_isglow(c, pn)) return true;
 /*
	 * Try the two neighboring squares adjacent to the one in the direction
	 * of the player to see if one or more will illuminate the wall by
	 * glowing.  Those could be out of bounds if the direction isn't
	 * diagonal.
	 */
 if (pn.x != wgrid.x) {
  if (pn.y != wgrid.y) {
   chk.x = pn.x;
   chk.y = wgrid.y;
   if (square_allowslos(c, chk) &&
     square_isglow(c, chk) &&
     source_can_light_wall(c, p, chk, wgrid))
    return true;
   chk.x = wgrid.x;
   chk.y = pn.y;
   if (square_allowslos(c, chk) &&
     square_isglow(c, chk) &&
     source_can_light_wall(c, p, chk, wgrid))
    return true;
  } else {
   chk.x = pn.x;
   chk.y = wgrid.y - 1;
   if (square_in_bounds(c, chk) &&
     square_allowslos(c, chk) &&
     square_isglow(c, chk) &&
     source_can_light_wall(c, p, chk, wgrid))
    return true;
   chk.y = wgrid.y + 1;
   if (square_in_bounds(c, chk) &&
     square_allowslos(c, chk) &&
     square_isglow(c, chk) &&
     source_can_light_wall(c, p, chk, wgrid))
    return true;
  }
 } else {
  chk.y = pn.y;
  chk.x = wgrid.x - 1;
  if (square_in_bounds(c, chk) && square_allowslos(c, chk) &&
    square_isglow(c, chk) &&
    source_can_light_wall(c, p, chk, wgrid))
   return true;
  chk.x = wgrid.x + 1;
  if (square_in_bounds(c, chk) && square_allowslos(c, chk) &&
    square_isglow(c, chk) &&
    source_can_light_wall(c, p, chk, wgrid))
   return true;
 }
 /*
	 * The adjacent squares towards the player won't light the wall by
	 * by glowing.
	 */
 return false;
}
/**
 * Help calc_lighting():  add in the effect of a light source.
 * \param c Is the chunk to use.
 * \param p Is the player to use.
 * \param sgrid Is the location of the light source.
 * \param radius Is the radius, in grids, of the light source.
 * \param inten Is the intensity of the light source.
 * This is a brute force approach.  Some computation probably could be saved by
 * propagating the light out from the source and terminating paths when they
 * reach a wall.
 */
static void add_light(struct chunk *c, struct player *p, struct loc sgrid,
  int radius, int inten)
{
 int y;
 int bonus_light = 0;
 /* Handle Inner Light */
 if (loc_eq(sgrid, p->grid) && player_active_ability(p, "Inner Light")) {
  bonus_light = 1;
 }
 for (y = -radius; y <= radius; y++) {
  int x;
  for (x = -radius; x <= radius; x++) {
   struct loc grid = loc_sum(sgrid, loc(x, y));
   int dist = distance(sgrid, grid);
   if (!square_in_bounds(c, grid)) continue;
   if (dist > radius) continue;
   /* Don't propagate the light through walls. */
   if (!los(c, sgrid, grid)) continue;
   /*
			 * Only light a wall if the face lit is possibly visible
			 * to the player.
			 */
   if (!square_allowslos(c, grid) && !source_can_light_wall(c,
     p, sgrid, grid)) continue;
   /* Adjust the light level */
   if (inten > 0) {
    /* Light getting less further away */
    c->squares[grid.y][grid.x].light +=
     radius + 1 - dist + bonus_light;
   } else {
    /* Light getting greater further away */
    c->squares[grid.y][grid.x].light -=
     radius + 1 - dist + bonus_light;
   }
  }
 }
}
/**
 * Calculate light level for every grid in view - stolen from Sil
 */
static void calc_lighting(struct chunk *c, struct player *p)
{
 int k, x, y;
 int light = p->upkeep->cur_light, radius = ABS(light);
 int old_light = square_light(c, p->grid);
 /* Starting values based on permanent light */
 for (y = 0; y < c->height; y++) {
  for (x = 0; x < c->width; x++) {
   struct loc grid = loc(x, y);
   if (square_isglow(c, grid) &&
     (square_allowslos(c, grid) ||
     glow_can_light_wall(c, p, grid))) {
    c->squares[y][x].light = 1;
   } else {
    c->squares[y][x].light = 0;
   }
  }
 }
 /* Light around the player */
 add_light(c, p, p->grid, radius, light);
 /* Scan monster list and add monster light or darkness */
 for (k = 1; k < cave_monster_max(c); k++) {
  /* Check the k'th monster */
  struct monster *mon = cave_monster(c, k);
  /* Skip dead monsters */
  if (!mon->race) continue;
  /* Get light info for this monster */
  light = mon->race->light;
  radius = ABS(light);
  /* Skip monsters not affecting light */
  if (!light) continue;
  /* Skip if the player can't see it. */
  if (distance(p->grid, mon->grid) - radius > z_info->max_sight)
   continue;
  add_light(c, p, mon->grid, radius, light);
  /* Glowing monsters lighten their own square */
  if (rf_has(mon->race->flags, RF_GLOW)) {
   c->squares[mon->grid.y][mon->grid.x].light += 1;
  }
 }
 /* Scan object list and add object light or darkness */
 for (k = 1; k < c->obj_max; k++) {
  /* Check the k'th object */
  struct object *obj = c->objects[k];
  if (!obj || !obj->kind) continue;
  if (loc_is_zero(obj->grid)) continue;
  light = 0;
  /* Objects with the Light flag glow on the ground unless they
		 * are torches or lanterns */
  if (of_has(obj->flags, OF_LIGHT) &&
   !(of_has(obj->flags, OF_TAKES_FUEL) ||
     of_has(obj->flags, OF_BURNS_OUT))) {
   light++;
  }
  /* Is it a glowing weapon? */
  if (weapon_glows(obj, 1)) {
   light++;
  }
  /* Does this item create darkness? */
  if (of_has(obj->flags, OF_DARKNESS) && !tval_is_light(obj)) {
   light--;
  }
  /* Some items provide permanent, bright, light */
  if (tval_is_light(obj) && of_has(obj->flags, OF_NO_FUEL)) {
   light += obj->pval;
  }
  /* The Iron Crown also glows */
  if (obj->artifact) {
   const struct artifact *crown = lookup_artifact_name("of Morgoth");
   if (obj->artifact == crown) {
    light += obj->pval;
   }
  }
  /* Do darkness or light for this object */
  radius = ABS(light);
  if (radius > 0) add_light(c, p, obj->grid, radius, light);
 }
 /* Update light level indicator */
 if (square_light(c, p->grid) != old_light) {
  p->upkeep->redraw |= PR_LIGHT;
 }
}
/**
 * Make a square part of the current view
 */
static void become_viewable(struct chunk *c, struct loc grid, struct player *p,
       bool close)
{
 int x = grid.x;
 int y = grid.y;
 /* Already viewable, nothing to do */
 if (square_isview(c, grid)) return;
 /* Add the grid to the view, make seen if it's close enough to the player */
 sqinfo_on(square(c, grid)->info, SQUARE_VIEW);
 if (close) {
  sqinfo_on(square(c, grid)->info, SQUARE_SEEN);
  sqinfo_on(square(c, grid)->info, SQUARE_CLOSE_PLAYER);
 }
 /* Mark lit grids, and walls near to them, as seen */
 if (square_islit(c, grid)) {
  if (!square_allowslos(c, grid)) {
   /* For walls, check for a lit grid closer to the player */
   int xc = (x < p->grid.x) ? (x + 1) : (x > p->grid.x) ? (x - 1) : x;
   int yc = (y < p->grid.y) ? (y + 1) : (y > p->grid.y) ? (y - 1) : y;
   if (square_islit(c, loc(xc, yc))) {
    sqinfo_on(square(c, grid)->info, SQUARE_SEEN);
   }
  } else {
   sqinfo_on(square(c, grid)->info, SQUARE_SEEN);
  }
 }
}
/**
 * Decide whether to include a square in the current view
 */
static void update_view_one(struct chunk *c, struct loc grid, struct player *p)
{
 int x = grid.x;
 int y = grid.y;
 int xc = x, yc = y;
 int d = distance(grid, p->grid);
 bool close = d < p->upkeep->cur_light;
 /* Too far away */
 if (d > z_info->max_sight) return;
 /* Special case for wall lighting. If we are a wall and the square in
	 * the direction of the player is in LOS, we are in LOS. This avoids
	 * situations like:
	 * #1#############
	 * #............@#
	 * ###############
	 * where the wall cell marked '1' would not be lit because the LOS
	 * algorithm runs into the adjacent wall cell.
	 */
 if (!square_allowslos(c, grid)) {
  int dx = x - p->grid.x;
  int dy = y - p->grid.y;
  int ax = ABS(dx);
  int ay = ABS(dy);
  int sx = dx > 0 ? 1 : -1;
  int sy = dy > 0 ? 1 : -1;
  xc = (x < p->grid.x) ? (x + 1) : (x > p->grid.x) ? (x - 1) : x;
  yc = (y < p->grid.y) ? (y + 1) : (y > p->grid.y) ? (y - 1) : y;
  /* Check that the cell we're trying to steal LOS from isn't a
		 * wall. If we don't do this, double-thickness walls will have
		 * both sides visible.
		 */
  if (!square_allowslos(c, loc(xc, yc))) {
   xc = x;
   yc = y;
  }
  /* Check if we got here via the 'knight's move' rule and, if so,
		 * don't steal LOS. */
  if (ax == 2 && ay == 1) {
   if (square_allowslos(c, loc(x - sx, y))
    && !square_allowslos(c, loc(x - sx, y - sy))) {
    xc = x;
    yc = y;
   }
  } else if (ax == 1 && ay == 2) {
   if (square_allowslos(c, loc(x, y - sy))
    && !square_allowslos(c, loc(x - sx, y - sy))) {
    xc = x;
    yc = y;
   }
  }
 }
 if (los(c, p->grid, loc(xc, yc)))
  become_viewable(c, grid, p, close);
}
/**
 * Update view for a single square
 */
static void update_one(struct chunk *c, struct loc grid, struct player *p)
{
 /* Remove view if blind */
 if (p->timed[TMD_BLIND]) {
  sqinfo_off(square(c, grid)->info, SQUARE_SEEN);
  sqinfo_off(square(c, grid)->info, SQUARE_CLOSE_PLAYER);
 }
 /* Square went from unseen -> seen */
 if (square_isseen(c, grid) && !square_wasseen(c, grid)) {
  square_note_spot(c, grid);
  square_light_spot(c, grid);
 }
 /* Square went from seen -> unseen */
 if (!square_isseen(c, grid) && square_wasseen(c, grid))
  square_light_spot(c, grid);
 sqinfo_off(square(c, grid)->info, SQUARE_WASSEEN);
}
/**
 * Update the player's current view
 */
void update_view(struct chunk *c, struct player *p)
{
 int x, y;
 /* Record the current view */
 mark_wasseen(c);
 /* Calculate light levels */
 calc_lighting(c, p);
 /* Assume we can view the player grid */
 sqinfo_on(square(c, p->grid)->info, SQUARE_VIEW);
 if (p->upkeep->cur_light > 0 || square_islit(c, p->grid)) {
  sqinfo_on(square(c, p->grid)->info, SQUARE_SEEN);
  sqinfo_on(square(c, p->grid)->info, SQUARE_CLOSE_PLAYER);
 }
 /*
	 * If the player is blind and in terrain that was remembered to be
	 * impassable, forget the remembered terrain.  This will have to be
	 * modified in variants that have timed effects which allow a player
	 * to move through impassable terrain.
	 */
 if (p->timed[TMD_BLIND] && square_isknown(c, p->grid)
   && !square_ispassable(p->cave, p->grid)) {
  square_forget(c, p->grid);
 }
 /* Squares we have LOS to get marked as in the view, and perhaps seen */
 for (y = 0; y < c->height; y++)
  for (x = 0; x < c->width; x++)
   update_view_one(c, loc(x, y), p);
 /* Update each grid */
 for (y = 0; y < c->height; y++)
  for (x = 0; x < c->width; x++)
   update_one(c, loc(x, y), p);
 /* Update field-of-fire (using the old view algorithm for now - NRM) */
 update_fire(c, p);
}
/**
 * Returns true if the player's grid is dark
 */
bool no_light(const struct player *p)
{
 return (!square_isseen(cave, p->grid));
}
/**
 * \file cmd-cave.c
 * \brief Chest and door opening/closing, disarming, running, resting, &c.
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Determines whether a staircase is 'trapped' like a false floor trap.
 * This means you fall a level below where you expected to end up (if you were
 * going upwards), take some minor damage, and have no stairs back.
 *
 * It gets more likely the more stairs you have recently taken.
 * It is designed to stop you stair-scumming.
 */
static bool trapped_stairs(void)
{
 int chance;
 chance = player->staircasiness / 100;
 chance = chance * chance * chance;
 chance = chance / 10000;
 if (percent_chance(chance)) {
  msg("The stairs crumble beneath you!");
  event_signal(EVENT_MESSAGE_FLUSH);
  msg("You fall through...");
  event_signal(EVENT_MESSAGE_FLUSH);
  msg("...and land somewhere deeper in the Iron Hells.");
  event_signal(EVENT_MESSAGE_FLUSH);
  history_add(player, "Fell through a crumbling stair",
     HIST_TRAPPED_STAIRS);
  /* Take some damage */
  player_falling_damage(player, false);
  /* No stairs back */
  player->upkeep->create_stair = FEAT_NONE;
  return true;
 }
 return false;
}
/**
 * Go up one level
 */
static void do_cmd_go_up_aux(void)
{
 int new_depth, min;
 int change = square_isshaft(cave, player->grid) ? -2 : -1;
 /* Verify stairs */
 if (!square_isupstairs(cave, player->grid)) {
  msg("You see no up staircase here.");
  return;
 }
 /* Special handling for the tutorial */
 if (in_tutorial()) {
  player->upkeep->energy_use = z_info->move_energy;
  tutorial_leave_section(player);
  return;
 }
 /* Force descend */
 if (OPT(player, birth_force_descend) && (silmarils_possessed(player) == 0)){
  msg("You have vowed to not to return until you hold a Silmaril.");
  return;
 }
 /* Calculate the depth to aim for */
 new_depth = dungeon_get_next_level(player, player->depth, change);
 /* Take a turn */
 player->upkeep->energy_use = z_info->move_energy;
 /* Store the action type */
 player->previous_action[0] = ACTION_MISC;
 /* Cannot flee Morgoth's throne room without a Silmaril */
 if ((player->max_depth == z_info->dun_depth) &&
  (silmarils_possessed(player) == 0)) {
  msg("You enter a maze of staircases, but cannot find your way.");
  return;
 }
 /* Monsters may get opportunist or zone of control attacks */
 monster_opportunist_or_zone(player, player->grid);
 /* Player may be dead */
 if (player->chp < 0) return;
 /* Calculate the new depth to arrive at */
 min = player_min_depth(player);
 /* Create a way back */
 player->upkeep->create_stair = (change == -2) ? FEAT_MORE_SHAFT : FEAT_MORE;
 /* Deal with most cases where you can't find your way */
 if ((new_depth < min) && (player->max_depth != z_info->dun_depth)) {
  msgt(MSG_STAIRS_UP, "You enter a maze of up staircases, but cannot find your way.");
  /* Deal with trapped stairs when trying and failing to go upwards */
  if (!trapped_stairs()) {
   if (player->depth == min) {
    msgt(MSG_STAIRS_UP, "You emerge near where you began.");
   } else {
    msgt(MSG_STAIRS_UP, "You emerge even deeper in the dungeon.");
   }
   /* Change the way back */
   if (player->upkeep->create_stair == FEAT_MORE) {
    player->upkeep->create_stair = FEAT_LESS;
   } else {
    player->upkeep->create_stair = FEAT_LESS_SHAFT;
   }
  }
  new_depth = min;
 } else {
  /* Deal with cases where you can find your way */
  msgt(MSG_STAIRS_UP, "You enter a maze of up staircases.");
  /* Escaping */
  if (silmarils_possessed(player) > 0) {
   msgt(MSG_STAIRS_UP, "The divine light reveals the way.");
  }
  /* Flee Morgoth's throne room */
  if (player->depth == z_info->dun_depth) {
   if (!player->morgoth_slain) {
    msg("As you climb the stair, a great cry of rage and anguish comes from below.");
    msg("Make quick your escape: it shall be hard-won.");
   }
   /* Set the 'on the run' flag */
   player->on_the_run = true;
   /* Remove the 'truce' flag if it hasn't been done already */
   player->truce = false;
  } else if (trapped_stairs()) {
   /* Deal with trapped stairs when going upwards */
   new_depth++;
  }
 }
 /* Another staircase has been used... */
 player->stairs_taken++;
 player->staircasiness += 1000;
 if (OPT(player, birth_discon_stairs)) {
  player->upkeep->create_stair = FEAT_NONE;
 }
 /* Change level */
 dungeon_change_level(player, new_depth);
}
/**
 * Go up one level
 */
void do_cmd_go_up(struct command *cmd)
{
 do_cmd_go_up_aux();
}
/**
 * Go down one level
 */
static void do_cmd_go_down_aux(void)
{
 int new_depth, min;
 int change = square_isshaft(cave, player->grid) ? 2 : 1;
 /* Verify stairs */
 if (!square_isdownstairs(cave, player->grid)) {
  msg("I see no down staircase here.");
  return;
 }
 /* Special handling for the tutorial */
 if (in_tutorial()) {
  player->upkeep->energy_use = z_info->move_energy;
  tutorial_leave_section(player);
  return;
 }
 /* Do not descend from the Gates */
 if (player->depth == 0) {
  msg("You have made it to the very gates of Angband and can once more taste the freshness on the air.");
  msg("You will not re-enter that fell pit.");
  return;
 }
 /* Calculate the depth to aim for */
 new_depth = dungeon_get_next_level(player, player->depth, change);
 /* Calculate the new depth to arrive at */
 min = player_min_depth(player);
 /* Create a way back */
 player->upkeep->create_stair = (change == 2) ? FEAT_LESS_SHAFT : FEAT_LESS;
 /* Warn players if this could lead them to Morgoth's Throne Room */
 if (new_depth == z_info->dun_depth) {
  if (!player->on_the_run) {
   msg("From up this stair comes the harsh din of feasting in Morgoth's own hall.");
   if (!get_check("Are you completely sure you wish to descend? ")) {
    player->upkeep->create_stair = FEAT_NONE;
    return;
   }
  }
 }
 /* Take a turn */
 player->upkeep->energy_use = z_info->move_energy;
 /* Store the action type */
 player->previous_action[0] = ACTION_MISC;
 /* Monsters may get opportunist or zone of control attacks */
 monster_opportunist_or_zone(player, player->grid);
 /* Player may be dead */
 if (player->chp < 0) return;
 /* Success */
 msgt(MSG_STAIRS_DOWN, "You enter a maze of down staircases.");
 /* Can never return to the throne room... */
 if ((player->on_the_run) && (new_depth == z_info->dun_depth)) {
  msgt(MSG_STAIRS_DOWN, "Try though you might, you cannot find your way back to Morgoth's throne.");
  msgt(MSG_STAIRS_DOWN, "You emerge near where you began.");
  player->upkeep->create_stair = FEAT_MORE;
  new_depth = z_info->dun_depth - 1;
 } else if (!trapped_stairs() && (new_depth < min)) {
  msgt(MSG_STAIRS_DOWN, "You emerge much deeper in the dungeon.");
  new_depth = min;
 }
 /* Another staircase has been used... */
 player->stairs_taken++;
 player->staircasiness += 1000;
 if (OPT(player, birth_discon_stairs)) {
  player->upkeep->create_stair = FEAT_NONE;
 }
 /* Change level */
 dungeon_change_level(player, new_depth);
}
/**
 * Go down one level
 */
void do_cmd_go_down(struct command *cmd)
{
 do_cmd_go_down_aux();
}
/**
 * Toggle stealth mode
 */
void do_cmd_toggle_stealth(struct command *cmd)
{
 /* Toggle stealth mode */
 if (player->stealth_mode) {
  /* Clear the stealth mode flag */
  player->stealth_mode = STEALTH_MODE_OFF;
  /* Recalculate bonuses */
  player->upkeep->update |= (PU_BONUS);
  /* Redraw the state */
  player->upkeep->redraw |= (PR_STATE);
 } else {
  /* Set the stealth mode flag */
  player->stealth_mode = STEALTH_MODE_ON;
  /* Update stuff */
  player->upkeep->update |= (PU_BONUS);
  /* Redraw stuff */
  player->upkeep->redraw |= (PR_STATE | PR_SPEED);
 }
}
/**
 * Determine if a given grid may be "opened"
 */
static bool do_cmd_open_test(struct player *p, struct loc grid)
{
 /* Must have knowledge */
 if (!square_isknown(cave, grid)) {
  msg("You see nothing there.");
  return false;
 }
 /* Must be a closed door */
 if (!square_iscloseddoor(cave, grid)) {
  msgt(MSG_NOTHING_TO_OPEN, "You see nothing there to open.");
  if (square_iscloseddoor(p->cave, grid)) {
   square_forget(cave, grid);
   square_light_spot(cave, grid);
  }
  return false;
 }
 return (true);
}
/**
 * Perform the basic "open" command on doors
 *
 * Assume there is no monster blocking the destination
 *
 * Returns true if repeated commands may continue
 */
static bool do_cmd_open_aux(struct loc grid)
{
 int score, power, difficulty;
 bool more = false;
 /* Verify legality */
 if (!do_cmd_open_test(player, grid)) return (false);
 /* Check the type of door */
 if (square_isjammeddoor(cave, grid)) {
  /* Stuck */
  msg("The door appears to be stuck.");
 } else if (square_islockeddoor(cave, grid)) {
  /* Get the score in favour (=perception) */
  score = player->state.skill_use[SKILL_PERCEPTION];
  /* Extract the lock power */
  power = square_door_lock_power(cave, grid);
  /* Base difficulty is the door power + 5 */
  difficulty = power + 5;
  /* Penalize some conditions */
  if (player->timed[TMD_BLIND] || no_light(player) ||
   player->timed[TMD_IMAGE]) {
   difficulty += 5;
  }
  if (player->timed[TMD_CONFUSED]) difficulty += 5;
  /* Success */
  if (skill_check(source_player(), score, difficulty, source_none()) > 0){
   /* Message */
   msgt(MSG_LOCKPICK, "You have picked the lock.");
   /* Open the door */
   square_open_door(cave, grid);
   /* Update the visuals */
   player->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
  } else {
   /* Failure */
   event_signal(EVENT_INPUT_FLUSH);
   /* Message */
   msgt(MSG_LOCKPICK_FAIL, "You failed to pick the lock.");
   /* We may keep trying */
   more = true;
  }
 } else {
  /* Closed door */
  square_open_door(cave, grid);
  player->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
  sound(MSG_OPENDOOR);
 }
 /* Result */
 return more;
}
/**
 * Open a closed/locked/jammed door or a closed/locked chest.
 *
 * Unlocking a locked chest is worth one experience point; since doors are
 * player lockable, there is no experience for unlocking doors.
 */
void do_cmd_open(struct command *cmd)
{
 struct loc grid;
 int dir;
 struct object *obj;
 bool more = false;
 int err;
 struct monster *mon;
 /* Get arguments */
 err = cmd_get_arg_direction(cmd, "direction", &dir);
 if (err || dir == DIR_UNKNOWN) {
  struct loc grid1;
  int n_closed_doors, n_locked_chests;
  /* square_iscloseddoor() also includes secret doors. */
  n_closed_doors = count_feats(&grid1, square_iscloseddoor, false)
   - count_feats(&grid1, square_issecretdoor, false);
  assert(n_closed_doors >= 0);
  n_locked_chests = count_chests(&grid1, CHEST_OPENABLE);
  /*
		 * If prompting for a direction, allow the player's square as
		 * an option if there's a chest nearby.
		 */
  if (n_closed_doors + n_locked_chests == 1) {
   dir = motion_dir(player->grid, grid1);
   cmd_set_arg_direction(cmd, "direction", dir);
  } else if (cmd_get_direction(cmd, "direction", &dir, n_locked_chests > 0)) {
   return;
  }
 }
 /* Get location */
 grid = loc_sum(player->grid, ddgrid[dir]);
 /* Check for chest */
 obj = chest_check(player, grid, CHEST_OPENABLE);
 /* Check for door */
 if (!obj && !do_cmd_open_test(player, grid)) {
  msg("There is nothing in your square (or adjacent) to open.");
  /* Cancel repeat */
  disturb(player, false);
  return;
 }
 /* Take a turn */
 player->upkeep->energy_use = z_info->move_energy;
 /* Store the action type */
 player->previous_action[0] = ACTION_MISC;
 /* Apply confusion */
 if (player_confuse_dir(player, &dir, false)) {
  /* Get location */
  grid = loc_sum(player->grid, ddgrid[dir]);
  /* Check for chest */
  obj = chest_check(player, grid, CHEST_OPENABLE);
 }
 /* Monster */
 mon = square_monster(cave, grid);
 if (mon) {
  /* Message */
  msg("There is a monster in the way!");
  /* Attack */
  py_attack(player, grid, ATT_MAIN);
 } else if (obj) {
  /* Chest */
  more = do_cmd_open_chest(grid, obj);
 } else {
  /* Door */
  more = do_cmd_open_aux(grid);
 }
 /* Cancel repeat unless we may continue */
 if (!more) disturb(player, false);
}
/**
 * Determine if a given grid may be "closed"
 */
static bool do_cmd_close_test(struct player *p, struct loc grid)
{
 /* Must have knowledge */
 if (!square_isknown(cave, grid)) {
  /* Message */
  msg("You see nothing there.");
  /* Nope */
  return (false);
 }
  /* Require open/broken door */
 if (!square_isopendoor(cave, grid) && !square_isbrokendoor(cave, grid)) {
  /* Message */
  msg("You see nothing there to close.");
  if (square_isopendoor(p->cave, grid)
    || square_isbrokendoor(p->cave, grid)) {
   square_forget(cave, grid);
   square_light_spot(cave, grid);
  }
  /* Nope */
  return (false);
 }
 /* Dont allow if player is in the way. */
 if (square(cave, grid)->mon < 0) {
  /* Message */
  msg("To close the door you would need to move out from the doorway.");
  /* Nope */
  return (false);
 }
 /* Okay */
 return (true);
}
/**
 * Perform the basic "close" command
 *
 * Assume there is no monster blocking the destination
 *
 * Returns true if repeated commands may continue
 */
static bool do_cmd_close_aux(struct loc grid)
{
 bool more = false;
 /* Verify legality */
 if (!do_cmd_close_test(player, grid)) return (false);
 /* Broken door */
 if (square_isbrokendoor(cave, grid)) {
  msg("The door appears to be broken.");
 } else {
  /* Close door */
  square_close_door(cave, grid);
  player->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
  sound(MSG_SHUTDOOR);
 }
 /* Result */
 return (more);
}
/**
 * Close an open door.
 */
void do_cmd_close(struct command *cmd)
{
 struct loc grid;
 int dir;
 int err;
 bool more = false;
 /* Get arguments */
 err = cmd_get_arg_direction(cmd, "direction", &dir);
 if (err || dir == DIR_UNKNOWN) {
  struct loc grid1;
  /* Count open doors */
  if (count_feats(&grid1, square_isopendoor, false) == 1) {
   dir = motion_dir(player->grid, grid1);
   cmd_set_arg_direction(cmd, "direction", dir);
  } else if (cmd_get_direction(cmd, "direction", &dir, false)) {
   return;
  }
 }
 /* Get location */
 grid = loc_sum(player->grid, ddgrid[dir]);
 /* Verify legality */
 if (!do_cmd_close_test(player, grid)) {
  /* Cancel repeat */
  disturb(player, false);
  return;
 }
 /* Take a turn */
 player->upkeep->energy_use = z_info->move_energy;
 /* Store the action type */
 player->previous_action[0] = ACTION_MISC;
 /* Apply confusion */
 if (player_confuse_dir(player, &dir, false)) {
  /* Get location */
  grid = loc_sum(player->grid, ddgrid[dir]);
 }
 /* Monster - alert, then attack */
 if (square(cave, grid)->mon > 0) {
  msg("There is a monster in the way!");
  py_attack(player, grid, ATT_MAIN);
 } else
  /* Door - close it */
  more = do_cmd_close_aux(grid);
 /* Cancel repeat unless told not to */
 if (!more) disturb(player, false);
}
/**
 * Exchange places with a monster.
 */
void do_cmd_exchange(struct command *cmd)
{
 int dir;
 struct loc grid;
 struct monster *mon;
 char m_name[80];
 if (!player_active_ability(player, "Exchange Places")) {
  msg("You need the ability 'exchange places' to use this command.");
  return;
 }
 /* Get arguments */
 if (cmd_get_direction(cmd, "direction", &dir, false) != CMD_OK)
  return;
 /* Get location */
 grid = loc_sum(player->grid, ddgrid[dir]);
 /* Deal with overburdened characters */
 if (player->upkeep->total_weight > weight_limit(player->state) * 3 / 2) {
  /* Abort */
  msg("You are too burdened to move.");
  return;
 }
 /* Check terrain, traps, monsters */
 mon = square_monster(cave, grid);
 if (square_ispit(cave, player->grid)) {
  /* Can't exchange from within pits */
  msg("You would have to escape the pit before being able to exchange places.");
  return;
 } else if (square_iswebbed(cave, player->grid)) {
  /* Can't exchange from within webs */
  msg("You would have to escape the web before being able to exchange places.");
  return;
 } else if (!mon || !monster_is_visible(mon)) {
  /* No monster, or invisible */
  msg("You cannot see a monster there to exchange places with.");
  return;
 } else if (square_isrubble(cave, grid)) {
  /* Rubble */
  msg("You cannot enter the rubble.");
  return;
 } else if (square_isrock(cave, grid)) {
  /* Wall */
  msg("You cannot enter the wall.");
  return;
 } else if (square_iscloseddoor(cave, grid)) {
  /* Closed door */
  msg("You cannot enter the closed door.");
  return;
 } else {
  if (rf_has(mon->race->flags, RF_NEVER_MOVE) ||
   rf_has(mon->race->flags, RF_HIDDEN_MOVE)) {
   monster_desc(m_name, sizeof(m_name), mon, MDESC_DEFAULT);
   /* Message */
   msg("You cannot get past %s.", m_name);
   return;
  }
 }
 /* Take a turn */
 player->upkeep->energy_use = z_info->move_energy;
 /* Store the action type */
 player->previous_action[0] = ACTION_MISC;
 /* Apply confusion */
 if (player_confuse_dir(player, &dir, false)) {
  /* Get location */
  grid = loc_sum(player->grid, ddgrid[dir]);
 }
 /* Re-check for a visible monster (in case confusion changed the move) */
 mon = square_monster(cave, grid);
 if (!mon || !monster_is_visible(mon)) {
  /* Message */
  msg("You cannot see a monster there to exchange places with.");
  return;
 } else if (square_isrubble(cave, grid)) {
  /* Rubble */
  msg("There is a pile of rubble in the way.");
  return;
 } else if (square_isrock(cave, grid)) {
  /* Wall */
  msg("There is a wall in the way.");
  return;
 } else if (square_iscloseddoor(cave, grid)) {
  /* Closed door */
  msg("There is a door in the way.");
  return;
 } else if (square_ischasm(cave, grid)) {
  /* Chasm */
  msg("You cannot exchange places over the chasm.");
  return;
 }
 /* Recalculate the monster name (in case confusion changed the move) */
 monster_desc(m_name, sizeof(m_name), mon, MDESC_DEFAULT);
 /* Message */
 msg("You exchange places with %s.", m_name);
 /* Attack of opportunity */
 if ((mon->alertness >= ALERTNESS_ALERT) && !mon->m_timed[MON_TMD_CONF] &&
  !rf_has(mon->race->flags, RF_MINDLESS)) {
  char m_pronoun[80];
  /* Calculate pronoun for the first time */
  monster_desc(m_pronoun, sizeof(m_pronoun), mon,
      MDESC_PRO_VIS | MDESC_CAPITAL);
  msg("%s attacks you as you slip past.", m_pronoun);
  make_attack_normal(mon, player);
 }
 /* Alert the monster */
 make_alert(mon, 0);
 /* Swap positions with the monster */
 monster_swap(player->grid, grid);
 player_handle_post_move(player, true, false);
}
/**
 * Determine if a given grid may be "tunneled"
 */
static bool do_cmd_tunnel_test(struct player *p, struct loc grid)
{
 /* Must have knowledge */
 if (!square_isknown(cave, grid)) {
  msg("You see nothing there.");
  return (false);
 }
 /* Titanium */
 if (square_isperm(cave, grid)) {
  msg("You cannot tunnel any further in that direction.");
  if (!square_isperm(p->cave, grid)) {
   square_memorize(cave, grid);
   square_light_spot(cave, grid);
  }
  return (false);
 }
 /* Must be a wall/etc */
 if (!square_isdiggable(cave, grid)) {
  /* Doors get a more informative message. */
  if (square_iscloseddoor(cave, grid)) {
   msg("You cannot tunnel through a door. Try bashing it.");
  } else {
   msg("You see nothing there to tunnel.");
  }
  if (square_isdiggable(p->cave, grid)
    || square_iscloseddoor(p->cave, grid)) {
   square_forget(cave, grid);
   square_light_spot(cave, grid);
  }
  return (false);
 }
 /* Okay */
 return (true);
}
/**
 * Tunnel through wall.  Assumes valid location.
 *
 * Note that it is impossible to "extend" rooms past their
 * outer walls (which are actually part of the room).
 *
 * Attempting to do so will produce floor grids which are not part
 * of the room, and whose "illumination" status do not change with
 * the rest of the room.
 */
static bool twall(struct loc grid)
{
 /* Paranoia -- Require a wall or some such */
 if (!square_isdiggable(cave, grid))
  return (false);
 /* Sound */
 sound(MSG_DIG);
 /* Remove the feature */
 square_tunnel_wall(cave, grid);
 /* Update the visuals */
 player->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
 /* Result */
 return (true);
}
/**
 * Print a message when the player doesn't have the required digger for terrain.
 */
static void fail_message(struct feature *terrain, char *name)
{
 char buf[1024] = "\0";
 /* See if we have a message */
 if (!terrain->fail_msg) return;
 /* Insert */
 insert_name(buf, 1024, terrain->fail_msg, name);
 msg("%s", buf);
}
/**
 * Perform the basic "tunnel" command
 *
 * Assumes that no monster is blocking the destination.
 * Uses twall() (above) to do all "terrain feature changing".
 * Returns true if repeated commands may continue.
 */
static bool do_cmd_tunnel_aux(struct loc grid)
{
 bool more = false;
 int weapon_slot = slot_by_name(player, "weapon");
 struct object *current_weapon = slot_object(player, weapon_slot);
 struct object *digger = NULL;
 int digging_score = 0;
 int difficulty = square_digging(cave, grid);
    char o_name[80];
 /* Verify legality */
 if (!do_cmd_tunnel_test(player, grid)) return (false);
 /* Pick what we're digging with and our chance of success */
 if (obj_digging_score(current_weapon)) {
  /* If weapon is a digger, then use it */
  digging_score = obj_digging_score(current_weapon);
  digger = current_weapon;
 } else {
        /* Find one or more diggers in the pack */
  bool more_than_one = false;
  struct object *test;
  for (test = player->gear; test; test = test->next) {
   if (obj_digging_score(test)) {
    if (digging_score) {
     more_than_one = true;
    }
    digging_score = obj_digging_score(test);
    digger = test;
   }
  }
  /* Make a choice if needed */
  if (more_than_one) {
   /* Get arguments */
   if (!get_item(&digger, "Use which digger?",
        "You are not carrying a shovel or mattock.",
        CMD_TUNNEL, obj_can_dig, USE_INVEN))
    return false;
   digging_score = obj_digging_score(digger);
  }
 }
 /* Abort if you have no digger */
    if (digging_score == 0) {
        /* Confused players trying to dig without a digger waste their turn
		 * (otherwise control-dir is safe in a corridor) */
        if (player->timed[TMD_CONFUSED]) {
            if (square_isrubble(cave, grid)) {
    msg("You bump into the rubble.");
            } else {
    msg("You bump into the wall.");
            }
            return false;
        } else {
            msg("You are not carrying a shovel or mattock.");
            /* Reset the action type */
            player->previous_action[0] = ACTION_NOTHING;
            /* Don't take a turn */
            player->upkeep->energy_use = 0;
            return false;
        }
    }
    /* Get the short name of the item */
 object_desc(o_name, sizeof(o_name), digger, ODESC_BASE, player);
 /* Test for success */
 if (difficulty > digging_score) {
  fail_message(square_feat(cave, grid), o_name);
        /* Confused players trying to dig without a digger waste their turn
		 * (otherwise control-dir is safe in a corridor) */
        if (!player->timed[TMD_CONFUSED]) {
            /* Reset the action type */
            player->previous_action[0] = ACTION_NOTHING;
            /* Don't take a turn */
            player->upkeep->energy_use = 0;
            return false;
        }
 } else if (difficulty > player->state.stat_use[STAT_STR]) {
  msg(square_feat(cave, grid)->str_msg);
        /* Confused players trying to dig without a digger waste their turn
		 * (otherwise control-dir is safe in a corridor) */
        if (!player->timed[TMD_CONFUSED]) {
            /* Reset the action type */
            player->previous_action[0] = ACTION_NOTHING;
            /* Don't take a turn */
            player->upkeep->energy_use = 0;
            return false;
        }
 } else {
  /* Make a lot of noise */
  monsters_hear(true, false, -10);
  /* Success */
  msg(square_feat(cave, grid)->dig_msg);
  twall(grid);
 }
 /* Break the truce if creatures see */
 break_truce(player, false);
    /* Provoke attacks of opportunity from adjacent monsters */
    attacks_of_opportunity(player, loc(0, 0));
 /* Result */
 return more;
}
/**
 * Tunnel through "walls" (including rubble and doors, secret or otherwise)
 *
 * Digging is very difficult without a "digger" weapon, but can be
 * accomplished by strong players using heavy weapons.
 */
void do_cmd_tunnel(struct command *cmd)
{
 struct loc grid;
 int dir;
 bool more = false;
 /* Get arguments */
 if (cmd_get_direction(cmd, "direction", &dir, false))
  return;
 /* Get location */
 grid = loc_sum(player->grid, ddgrid[dir]);
 /* Oops */
 if (!do_cmd_tunnel_test(player, grid)) {
  /* Cancel repeat */
  disturb(player, false);
  return;
 }
 /* Take a turn */
 player->upkeep->energy_use = z_info->move_energy;
 /* Store the action type */
 player->previous_action[0] = ACTION_MISC;
 /* Apply confusion */
 if (player_confuse_dir(player, &dir, false)) {
  /* Get location */
  grid = loc_sum(player->grid, ddgrid[dir]);
 }
 /* Attack any monster we run into */
 if (square(cave, grid)->mon > 0) {
  msg("There is a monster in the way!");
  py_attack(player, grid, ATT_MAIN);
 } else {
  /* Tunnel through walls */
  more = do_cmd_tunnel_aux(grid);
 }
 /* Cancel repetition unless we can continue */
 if (!more) disturb(player, false);
}
/**
 * Determine if a given grid may be "disarmed"
 */
static bool do_cmd_disarm_test(struct player *p, struct loc grid)
{
 /* Must have knowledge */
 if (!square_isknown(cave, grid)) {
  msg("You see nothing there.");
  return false;
 }
 /* Look for a trap or glyph of warding */
 if (!square_isdisarmabletrap(cave, grid) && !square_iswarded(cave, grid)) {
  msg("You see nothing there to disarm.");
  if (square_isdisarmabletrap(p->cave, grid)) {
   square_memorize_traps(cave, grid);
   square_light_spot(cave, grid);
  }
  return false;
 }
 /* Okay */
 return true;
}
/**
 * Perform the basic "disarm" command
 *
 * Assume there is no monster blocking the destination
 *
 * Returns true if repeated commands may continue
 */
static bool do_cmd_disarm_aux(struct loc grid)
{
 int skill, power, difficulty, result;
    struct trap *trap = square(cave, grid)->trap;
 bool more = false;
 /* Verify legality */
 if (!do_cmd_disarm_test(player, grid)) return (false);
    /* Choose first player trap or glyph */
 while (trap) {
  if (trf_has(trap->flags, TRF_TRAP))
   break;
  if (trf_has(trap->flags, TRF_GLYPH))
   break;
  trap = trap->next;
 }
 if (!trap)
  return false;
 /* Get the base disarming skill */
 skill = player->state.skill_use[SKILL_PERCEPTION];
 /* Special case: player is stuck in a web */
 if (square_iswebbed(cave, grid) && loc_eq(grid, player->grid)) {
  more = player_break_web(player);
  return !more;
 }
 /* Determine trap power; (uint8_t)-1 is undisarmable */
 power = trap->power;
 if (power == (uint8_t)-1) {
  msg("You cannot disarm the %s.", trap->kind->name);
  return false;
 }
 /* Base difficulty is the trap power */
 difficulty = power;
 /* Penalize some conditions */
 if (player->timed[TMD_BLIND] || no_light(player) ||
  player->timed[TMD_IMAGE])
  difficulty += 5;
 if (player->timed[TMD_CONFUSED])
  difficulty += 5;
 /* Perform the check */
 result = skill_check(source_player(), skill, difficulty, source_none());
 if (result > 0) {
  /* Success, always succeed with player trap */
  if (trf_has(trap->flags, TRF_GLYPH)) {
   msgt(MSG_DISARM, "You have scuffed the %s.", trap->kind->name);
  } else {
   msgt(MSG_DISARM, "You have disarmed the %s.", trap->kind->name);
  }
  /* Trap is gone */
  square_destroy_trap(cave, grid);
  square_unmark(cave, grid);
 } else if (result > -3) {
  /* Failure by a small amount allows one to keep trying */
  event_signal(EVENT_INPUT_FLUSH);
  msg("You failed to disarm the %s.", trap->kind->name);
  /* Player can try again */
  more = true;
 } else {
  /* Failure by a larger amount sets off the trap */
  monster_swap(player->grid, grid);
  msg("You set off the %s!", trap->kind->name);
  hit_trap(grid);
 }
 /* Result */
 return more;
}
/**
 * Disarms a trap, or a chest
 *
 * Traps must be visible, chests must be known trapped
 */
void do_cmd_disarm(struct command *cmd)
{
 struct loc grid;
 int dir;
 int err;
 struct object *obj;
 bool more = false;
 /* Get arguments */
 err = cmd_get_arg_direction(cmd, "direction", &dir);
 if (err || dir == DIR_UNKNOWN) {
  struct loc grid1;
  int n_traps, n_wards, n_chests;
  n_traps = count_feats(&grid1, square_isdisarmabletrap, true);
  n_wards = count_feats(&grid1, square_iswarded, true);
  n_chests = count_chests(&grid1, CHEST_TRAPPED);
  if (n_traps + n_wards + n_chests == 1) {
   dir = motion_dir(player->grid, grid1);
   cmd_set_arg_direction(cmd, "direction", dir);
  } else if (cmd_get_direction(cmd, "direction", &dir, true)) {
   return;
  }
 }
 /* Get location */
 grid = loc_sum(player->grid, ddgrid[dir]);
 /* Check for chests */
 obj = chest_check(player, grid, CHEST_TRAPPED);
 /* Verify legality */
 if (!obj && !do_cmd_disarm_test(player, grid)) {
  /* Cancel repeat */
  disturb(player, false);
  return;
 }
 /* Take a turn */
 player->upkeep->energy_use = z_info->move_energy;
 /* Store the action type */
 player->previous_action[0] = ACTION_MISC;
 /* Apply confusion */
 if (player_confuse_dir(player, &dir, false)) {
  /* Get location */
  grid = loc_sum(player->grid, ddgrid[dir]);
  /* Check for chests */
  obj = chest_check(player, grid, CHEST_TRAPPED);
 }
 /* Monster */
 if (square(cave, grid)->mon > 0) {
  msg("There is a monster in the way!");
  py_attack(player, grid, ATT_MAIN);
 } else if (obj) {
  /* Chest */
  more = do_cmd_disarm_chest(obj);
 } else {
  /* Disarm trap */
  more = do_cmd_disarm_aux(grid);
 }
 /* Cancel repeat unless told not to */
 if (!more) disturb(player, false);
}
/**
 * Determine if a given grid may be "bashed"
 */
static bool do_cmd_bash_test(struct player *p, struct loc grid)
{
 /* Must have knowledge */
 if (!square_isknown(cave, grid)) {
  /* Message */
  msg("You see nothing there.");
  /* Nope */
  return false;
 }
 /* Require a door */
 if (!square_iscloseddoor(cave, grid) || square_issecretdoor(cave, grid)) {
  /* Message */
  msg("You see no door there to bash.");
  if (square_iscloseddoor(p->cave, grid)) {
   square_forget(cave, grid);
   square_light_spot(cave, grid);
  }
  /* Nope */
  return false;
 }
 /* Okay */
 return true;
}
/**
 * Perform the basic "bash" command
 *
 * Assume there is no monster blocking the destination
 *
 * Returns true if repeated commands may continue
 */
static bool do_cmd_bash_aux(struct loc grid)
{
 int score, difficulty;
 bool more = false;
 bool success = false;
 /* Verify legality */
 if (!do_cmd_bash_test(player, grid)) return false;
 /* Get the score in favour (=str) */
 score = player->state.stat_use[STAT_STR] * 2;
 /* The base difficulty is the door power  */
 difficulty = square_door_jam_power(cave, grid);
 /* Message */
 msg("You slam into the door!");
 if (skill_check(source_player(), score, difficulty, source_none()) > 0) {
  success = true;
  if (player_is_singing(player, lookup_song("Silence"))) {
   /* Message */
   msgt(MSG_OPENDOOR, "The door opens with a muffled crash!");
  } else {
   /* Message */
   msgt(MSG_OPENDOOR, "The door crashes open!");
  }
  if (one_in_(2)) {
   /* Break down the door */
   square_set_feat(cave, grid, FEAT_BROKEN);
  } else {
   /* Open the door */
   square_set_feat(cave, grid, FEAT_OPEN);
  }
  /* Move the player onto the door square */
  monster_swap(player->grid, grid);
  player_handle_post_move(player, false, false);
  /* Make a lot of noise */
  monsters_hear(true, false, -10);
  /* Update the visuals */
  player->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
 }
 if (!success) {
  int old_stun = player->timed[TMD_STUN];
  if (square_iscloseddoor(cave, grid)) {
   /* Message */
   msg("The door holds firm.");
  }
  /* Stuns */
  (void)player_inc_timed(player, TMD_STUN, 10, true, true, true);
  if (player->timed[TMD_STUN] > old_stun) {
   /* Allow repeated bashing */
   more = true;
  }
  /* Make some noise */
  monsters_hear(true, false, -5);
 }
 /* Result */
 return more;
}
/**
 * Bash open a door, success based on character strength
 *
 * For a closed door, pval is positive if locked; negative if stuck.
 *
 * For an open door, pval is positive for a broken door.
 *
 * A closed door can be opened - harder if locked. Any door might be
 * bashed open (and thereby broken). Bashing a door is (potentially)
 * faster! You move into the door way. To open a stuck door, it must
 * be bashed.
 *
 * Creatures can also open or bash doors, see elsewhere.
 */
void do_cmd_bash(struct command *cmd)
{
 int dir;
 struct loc grid;
 struct monster *mon;
 bool more = false;
 /* Get arguments */
 if (cmd_get_direction(cmd, "direction", &dir, false) != CMD_OK)
  return;
 /* Get location */
 grid = loc_sum(player->grid, ddgrid[dir]);
 /* Verify legality */
 if (!do_cmd_bash_test(player, grid)) return;
 /* Take a turn */
 player->upkeep->energy_use = z_info->move_energy;
 /* Store the action type */
 player->previous_action[0] = ACTION_MISC;
 /* Apply confusion */
 if (player_confuse_dir(player, &dir, false)) {
  /* Get location */
  grid = loc_sum(player->grid, ddgrid[dir]);
 }
 /* Monster */
 mon = square_monster(cave, grid);
 if (mon) {
  /* Message */
  msg("There is a monster in the way!");
  /* Attack */
  py_attack(player, grid, ATT_MAIN);
 } else {
  /* Door */
  more = do_cmd_bash_aux(grid);
 }
 /* Cancel repeat unless we may continue */
 if (!more) disturb(player, false);
}
/**
 * Manipulate an adjacent grid in some way
 *
 * Attack monsters, tunnel through walls, disarm traps, bash doors.
 *
 * This command must always take energy, to prevent free detection
 * of invisible monsters.
 *
 * The "semantics" of this command must be chosen before the player
 * is confused, and it must be verified against the new grid.
 */
static void do_cmd_alter_aux(int dir)
{
 struct loc grid;
 bool more = false;
 struct object *o_chest_closed;
 struct object *o_chest_trapped;
 struct object *obj = NULL;
 /* Get location */
 grid = loc_sum(player->grid, ddgrid[dir]);
 /* Take a turn */
 player->upkeep->energy_use = z_info->move_energy;
 /* Store the action type */
 player->previous_action[0] = ACTION_MISC;
 /* Apply confusion */
 if (player_confuse_dir(player, &dir, false)) {
  /* Get location */
  grid = loc_sum(player->grid, ddgrid[dir]);
 }
 /* Check for closed chest */
 o_chest_closed = chest_check(player, grid, CHEST_OPENABLE);
 /* Check for trapped chest */
 o_chest_trapped = chest_check(player, grid, CHEST_TRAPPED);
 /* Check for any object */
 obj = square_object(cave, grid);
 /* Action depends on what's there */
 if (square(cave, grid)->mon > 0) {
  /* Attack monster */
  py_attack(player, grid, ATT_MAIN);
 } else if ((dir != DIR_NONE) && !square_isknown(cave, grid)) {
  /* Deal with players who don't know what is there. */
  if (square_isfloor(cave, grid)) {
   msg("You strike, but there is nothing there.");
  } else {
   msg("You hit something hard.");
   square_memorize(cave, grid);
   square_light_spot(cave, grid);
  }
 } else if (square_isrock(cave, grid)) {
  /* Tunnel through walls and rubble */
  more = do_cmd_tunnel_aux(grid);
 } else if (square_iscloseddoor(cave, grid)) {
  /* Bash closed doors */
  more = do_cmd_bash_aux(grid);
 } else if (square_isdisarmabletrap(cave, grid) || square_iswarded(cave, grid)) {
  /* Disarm traps */
  more = do_cmd_disarm_aux(grid);
 } else if (o_chest_trapped) {
  /* Trapped chest */
  more = do_cmd_disarm_chest(o_chest_trapped);
 } else if (o_chest_closed) {
  /* Open chest */
  more = do_cmd_open_chest(grid, o_chest_closed);
 } else if (square_isopendoor(cave, grid)) {
  /* Close door */
  more = do_cmd_close_aux(grid);
 } else if ((dir == DIR_NONE) && square_isupstairs(cave, grid)) {
  /* Ascend */
  if (get_check("Are you sure you wish to ascend? ")) {
   do_cmd_go_up_aux();
  }
 } else if ((dir == DIR_NONE) && square_isdownstairs(cave, grid)) {
  /* Descend */
  if (get_check("Are you sure you wish to descend? ")) {
   do_cmd_go_down_aux();
  }
 } else if ((dir == DIR_NONE) && square_isforge(cave, grid)) {
  /* Cancel the alter command */
  cmd_cancel_repeat();
  /* Use forge */
  do_cmd_smith_aux(true);
  more = true;
  /* Don't take a turn... */
  player->upkeep->energy_use = 0;
 } else if ((dir == DIR_NONE) && obj) {
  /* Pick up items */
  player_pickup_item(player, obj, true);
 } else if (dir == DIR_NONE) {
  /* Oops */
  msg("There is nothing here to use.");
  /* Don't take a turn... */
  player->upkeep->energy_use = 0;
 } else {
  /* Oops */
  msg("You strike, but there is nothing there.");
 }
 /* Cancel repetition unless we can continue */
 if (!more) disturb(player, false);
}
void do_cmd_alter(struct command *cmd)
{
 int dir;
 /* Get arguments */
 if (cmd_get_direction(cmd, "direction", &dir, true) != CMD_OK)
  return;
 do_cmd_alter_aux(dir);
}
/**
 * Confirm a player wants to leap if necessary
 */
static bool confirm_leap(struct loc grid, int dir)
{
 bool confirm = true;
 char prompt[80];
 struct loc end = loc_sum(loc_sum(player->grid, ddgrid[dir]), ddgrid[dir]);
 struct monster *mon = square_monster(cave, end);
 /* Prompt for confirmation */
 if (!(square_isseen(cave, end) || square_isknown(cave, end))) {
  /* Confirm if the destination is unknown */
  strnfmt(prompt, sizeof(prompt),
    "Are you sure you wish to leap into the unknown? ");
 } else if (square_ischasm(cave, end)) {
  /* Confirm if the destination is in the chasm */
  strnfmt(prompt, sizeof(prompt),
    "Are you sure you wish to leap into the abyss? ");
 } else if (mon && monster_is_visible(mon)) {
  /* Confirm if the destination has a visible monster */
  char m_name[80];
  /* Get the monster name */
  monster_desc(m_name, sizeof(m_name), mon, 0);
  strnfmt(prompt, sizeof(prompt),
    "Are you sure you wish to leap into %s? ", m_name);
 } else {
  /* No confirmation needed */
  confirm = false;
 }
 /* True if no need to confirm or confirmed, otherwise false */
 return (!confirm || get_check(prompt));
}
/**
 * Finish player leap
 */
static void player_land(struct player *p)
{
    /* Make some noise when landing */
    p->stealth_score -= 5;
 /* Handle traps, objects, chasms etc */
 player_handle_post_move(p, true, false);
}
/**
 * Continue player leap
 */
void do_cmd_leap(struct command *cmd)
{
    int dir = player->previous_action[1];
 struct loc end = loc_sum(player->grid, ddgrid[dir]);
 struct monster *mon = square_monster(cave, end);
 /* Knocked back player is handled separately */
 if (player->upkeep->knocked_back) return;
    /* Display a message until player input is received */
    msg("You fly through the air.");
 /* Flush messages */
 event_signal(EVENT_MESSAGE_FLUSH);
 /* Take a turn */
 player->upkeep->energy_use = z_info->move_energy;
 /* Store the action type */
 player->previous_action[0] = dir;
    /* Solid objects end the leap */
 if (!square_ispassable(cave, end)) {
  if (square_isrubble(cave, end)) {
   msgt(MSG_HITWALL, "You slam into a wall of rubble.");
  } else if (square_isrock(cave, end)) {
   msgt(MSG_HITWALL, "You slam into a wall.");
  } else {
   msgt(MSG_HITWALL, "You slam into a door.");
  }
    } else if (mon) {
  /* Monsters end the leap */
        char m_name[80];
        /* Get the monster name */
        monster_desc(m_name, sizeof(m_name), mon, MDESC_STANDARD);
        if (monster_is_visible(mon)) {
   msg("%s blocks your landing.", m_name);
        } else {
            msg("Some unseen foe blocks your landing.");
  }
 } else {
  /* Successful leap */
        /* We generously give you your free flanking attack... */
        player_flanking_or_retreat(player, end);
        /* Move player to the new position */
        monster_swap(player->grid, end);
    }
    /* Land on the ground */
    player_land(player);
}
/**
 * Move player in the given direction.
 *
 * This routine should only be called when energy has been expended.
 *
 * Note that this routine handles monsters in the destination grid,
 * and also handles attempting to move into walls/doors/rubble/etc.
 */
void move_player(int dir, bool disarm)
{
 struct loc grid = loc_sum(player->grid, ddgrid[dir]);
 int m_idx = square(cave, grid)->mon;
 struct monster *mon = cave_monster(cave, m_idx);
 bool trap = square_isdisarmabletrap(cave, grid);
 bool door = square_iscloseddoor(cave, grid) &&
  !square_issecretdoor(cave, grid);
 bool confused = player->timed[TMD_CONFUSED] > 0;
 /* Many things can happen on movement */
 if (mon && monster_is_visible(mon)) {
  /* Attack visible monsters */
  py_attack(player, grid, ATT_MAIN);
 } else if (((trap && disarm) || door) && square_isknown(cave, grid)) {
  /* Auto-repeat if not already repeating */
  if (cmd_get_nrepeats() == 0)
   cmd_set_repeat(99);
  if (door) {
   if (!do_cmd_open_aux(grid)) {
    disturb(player, false);
   }
  } else {
   do_cmd_alter_aux(dir);
  }
 } else if (trap && player->upkeep->running) {
  /* Stop running before known traps */
  disturb(player, false);
  /* Don't take a turn... */
  player->upkeep->energy_use = 0;
 } else if (!square_ispassable(cave, grid)) {
  disturb(player, false);
  /* Notice unknown obstacles, mention known obstacles */
  if (!square_isknown(cave, grid)) {
   if (square_isrubble(cave, grid)) {
    msgt(MSG_HITWALL,
      "You feel a pile of rubble blocking your way.");
   } else if (door) {
    msgt(MSG_HITWALL, "You feel a door blocking your way.");
   } else {
    msgt(MSG_HITWALL, "You feel a wall blocking your way.");
   }
   square_memorize(cave, grid);
   square_light_spot(cave, grid);
  } else {
   if (square_isrubble(cave, grid)) {
    msgt(MSG_HITWALL,
      "There is a pile of rubble blocking your way.");
    if (!square_isrubble(player->cave, grid)) {
     square_memorize(cave, grid);
     square_light_spot(cave, grid);
    }
   } else if (door) {
    msgt(MSG_HITWALL, "There is a door blocking your way.");
    if (!square_iscloseddoor(player->cave, grid)) {
     square_memorize(cave, grid);
     square_light_spot(cave, grid);
    }
   } else {
    msgt(MSG_HITWALL, "There is a wall blocking your way.");
    if (square_ispassable(player->cave, grid)
     || square_isrubble(player->cave, grid)
     || square_iscloseddoor(player->cave, grid)) {
     square_forget(cave, grid);
     square_light_spot(cave, grid);
    }
   }
  }
  /* Store the action type */
  player->previous_action[0] = ACTION_MISC;
 } else if (player->upkeep->total_weight >
      (weight_limit(player->state) * 3) / 2) {
  /* Deal with overburdened characters */
  msg("You are too burdened to move.");
  /* Disturb the player */
  disturb(player, false);
  /* Don't take a turn... */
  player->upkeep->energy_use = 0;
 } else if (player_can_leap(player, grid, dir) && confirm_leap(grid, dir)) {
  /* At this point attack any invisible monster that may be there */
  if (mon) {
   msg("An unseen foe blocks your way.");
   /* Attack */
   py_attack(player, grid, ATT_MAIN);
  } else {
   /* Otherwise do the leap! */
   struct loc mid = loc_sum(player->grid, ddgrid[dir]);
   /* We generously give you your free flanking attack... */
   player_flanking_or_retreat(player, mid);
   /* Store the action type */
   player->previous_action[0] = dir;
   /* Move player to the new position */
   monster_swap(player->grid, mid);
   /* Remember that the player is in the air now */
   player->upkeep->leaping = true;
   cmdq_push(CMD_LEAP);
  }
 } else {
  /* Normal movement */
  bool pit = square_ispit(cave, player->grid);
  bool web = square_iswebbed(cave, player->grid);
  bool step = true;
  /* Check before walking on known traps/chasms on movement */
  if (!confused && square_isknown(cave, grid)) {
   /* If the player hasn't already leapt */
   if (square_ischasm(cave, grid)) {
    /* Disturb the player */
    disturb(player, false);
    /* Flush input */
    event_signal(EVENT_MESSAGE_FLUSH);
    if (!get_check("Step into the chasm? ")) {
     /* Don't take a turn... */
     player->upkeep->energy_use = 0;
     step = false;
    }
   }
   /* Traps */
            if (trap) {
                /* Disturb the player */
    disturb(player, false);
    /* Flush input */
    event_signal(EVENT_MESSAGE_FLUSH);
                if (!get_check("Are you sure you want to step on the trap? ")) {
                    /* Don't take a turn... */
                    player->upkeep->energy_use = 0;
     step = false;
                }
            }
  }
  /* At this point attack any invisible monster that may be there */
        if (mon) {
   msg("An unseen foe blocks your way.");
   /* Attack */
   py_attack(player, grid, ATT_MAIN);
   step = false;
  }
  /* It is hard to get out of a pit */
  if (pit && !player_escape_pit(player)) {
   step = false;
  }
  /* It is hard to get out of a web */
  if (web && !player_break_web(player)) {
   step = false;
  }
  /* We can move */
  if (step) {
   /* Do flanking or controlled retreat attack if any */
   player_flanking_or_retreat(player, grid);
   /* Move player */
   monster_swap(player->grid, grid);
   player_handle_post_move(player, true, false);
   /* Spontaneous Searching */
   perceive(player);
   /* Remember this direction of movement */
   player->previous_action[0] = dir;
  }
 }
 player->upkeep->running_firststep = false;
}
/**
 * Stay still.  Search.  Enter stores.
 * Pick up treasure if "pickup" is true.
 */
static void do_cmd_hold_aux(void)
{
 /* Take a turn */
 player->upkeep->energy_use = z_info->move_energy;
 /* Store the action type */
 player->previous_action[0] = ACTION_STAND;
 /* Store the 'focus' attribute */
 player->focused = true;
 /* Look at the floor */
 event_signal(EVENT_SEEFLOOR);
 square_know_pile(cave, player->grid);
 /* Make less noise if you did nothing at all
	 * (+7 in total whether or not stealth mode is used) */
 if (player->stealth_mode) {
  player->stealth_score += 2;
 } else {
  player->stealth_score += 7;
 }
    /* Passing in stealth mode removes the speed penalty
	 * (as there was no bonus either) */
    player->upkeep->update |= (PU_BONUS);
    player->upkeep->redraw |= (PR_STATE | PR_SPEED);
 /* Searching */
 search(player);
}
/**
 * Stay still.  Search.  Enter stores.
 * Pick up treasure if "pickup" is true.
 */
void do_cmd_hold(struct command *cmd)
{
 do_cmd_hold_aux();
}
/**
 * Determine if a given grid may be "walked"
 */
static bool do_cmd_walk_test(struct player *p, struct loc grid)
{
 int m_idx = square(cave, grid)->mon;
 struct monster *mon = cave_monster(cave, m_idx);
 /* If we don't know the grid, allow attempts to walk into it */
 if (!square_isknown(cave, grid))
  return true;
 /* Allow attack on visible monsters if unafraid */
 if (m_idx > 0 && monster_is_visible(mon)) {
  return true;
 }
 /* Require open space */
 if (!square_ispassable(cave, grid)) {
  if (square_isrubble(cave, grid)) {
   /* Rubble */
   msgt(MSG_HITWALL, "There is a pile of rubble in the way!");
   if (!square_isrubble(p->cave, grid)) {
    square_memorize(cave, grid);
    square_light_spot(cave, grid);
   }
   /* Store the action type */
   player->previous_action[0] = ACTION_MISC;
  } else if (square_isrock(cave, grid)) {
   /* Wall */
   msgt(MSG_HITWALL, "There is a wall in the way!");
   if (square_ispassable(p->cave, grid)
    || square_isrubble(p->cave, grid)
    || square_iscloseddoor(p->cave, grid)) {
    square_forget(cave, grid);
    square_light_spot(cave, grid);
   }
   /* Store the action type */
   player->previous_action[0] = ACTION_MISC;
  } else {
   /* Door */
   return true;
  }
  /* Cancel repeat */
  disturb(player, false);
  /* Nope */
  return false;
 }
 /* Okay */
 return true;
}
/**
 * Walk in the given direction.
 */
void do_cmd_walk(struct command *cmd)
{
 struct loc grid;
 int dir;
 /* Get arguments */
 if (cmd_get_direction(cmd, "direction", &dir, false) != CMD_OK)
  return;
    /* Convert walking in place to 'hold' */
    if (dir == DIR_NONE) {
        do_cmd_hold_aux();
        return;
    }
 /* Apply confusion if necessary */
 if (player_confuse_dir(player, &dir, false))
  /* Confused movements use energy no matter what */
  player->upkeep->energy_use = z_info->move_energy;
 /* Verify walkability, first checking for if the player is escaping */
 grid = loc_sum(player->grid, ddgrid[dir]);
 if (!square_in_bounds_fully(cave, grid)
   && square_ispassable(cave, grid)
   && !square_monster(cave, grid)) {
  /* Deal with leaving the map */
  do_cmd_escape();
  return;
 } else if (!do_cmd_walk_test(player, grid)) {
  return;
 }
 player->upkeep->energy_use = z_info->move_energy;
 /* Attempt to disarm unless it's a trap and we're trapsafe */
 move_player(dir, !square_isdisarmabletrap(cave, grid));
}
/**
 * Walk into a trap.
 */
void do_cmd_jump(struct command *cmd)
{
 struct loc grid;
 int dir;
 /* Get arguments */
 if (cmd_get_direction(cmd, "direction", &dir, false) != CMD_OK)
  return;
 /* Apply confusion if necessary */
 if (player_confuse_dir(player, &dir, false))
  player->upkeep->energy_use = z_info->move_energy;
 /* Verify walkability */
 grid = loc_sum(player->grid, ddgrid[dir]);
 if (!do_cmd_walk_test(player, grid))
  return;
 player->upkeep->energy_use = z_info->move_energy;
 move_player(dir, false);
}
/**
 * Start running.
 *
 * Note that running while confused is not allowed.
 */
void do_cmd_run(struct command *cmd)
{
 struct loc grid;
 int dir;
 /* Get arguments */
 if (cmd_get_direction(cmd, "direction", &dir, false) != CMD_OK)
  return;
 if (player_confuse_dir(player, &dir, true))
  return;
 /* Get location */
 if (dir) {
  grid = loc_sum(player->grid, ddgrid[dir]);
  if (!do_cmd_walk_test(player, grid))
   return;
  /* Hack: convert repeat count to running count */
  if (cmd->nrepeats > 0) {
   player->upkeep->running = cmd->nrepeats;
   cmd->nrepeats = 0;
  }
  else {
   player->upkeep->running = 0;
  }
 }
 /* Start run */
 run_step(dir);
}
/**
 * Start running with pathfinder.
 *
 * Note that running while confused is not allowed.
 */
void do_cmd_pathfind(struct command *cmd)
{
 struct loc grid;
 /* XXX-AS Add better arg checking */
 cmd_get_arg_point(cmd, "point", &grid);
 if (player->timed[TMD_CONFUSED])
  return;
 if (find_path(grid)) {
  player->upkeep->running = 1000;
  /* Calculate torch radius */
  player->upkeep->update |= (PU_TORCH);
  player->upkeep->running_withpathfind = true;
  run_step(0);
 }
}
/**
 * Stop, start or change a song
 */
void do_cmd_change_song(struct command *cmd)
{
 change_song();
}
/**
 * Rest (restores hit points and mana and such)
 */
void do_cmd_rest(struct command *cmd)
{
 int n;
 /* XXX-AS need to insert UI here */
 if (cmd_get_arg_choice(cmd, "choice", &n) != CMD_OK)
  return;
 /* Typically resting ends your current song */
 if (OPT(player, stop_singing_on_rest)) {
  player_change_song(player, NULL, false);
 }
 /* 
	 * A little sanity checking on the input - only the specified negative 
	 * values are valid. 
	 */
 if (n < 0 && !player_resting_is_special(n))
  return;
 /* Do some upkeep on the first turn of rest */
 if (!player_is_resting(player)) {
  player->upkeep->update |= (PU_BONUS);
  /* If a number of turns was entered, remember it */
  if (n > 1)
   player_set_resting_repeat_count(player, n);
  else if (n == 1)
   /* If we're repeating the command, use the same count */
   n = player_get_resting_repeat_count(player);
 }
 /* Set the counter, and stop if told to */
 player_resting_set_count(player, n);
 if (!player_is_resting(player))
  return;
 /* Take a turn */
 player_resting_step_turn(player);
 /* Redraw the state if requested */
 handle_stuff(player);
 /* Prepare to continue, or cancel and clean up */
 if (player_resting_count(player) > 0) {
  cmdq_push(CMD_REST);
  cmd_set_arg_choice(cmdq_peek(), "choice", n - 1);
 } else if (player_resting_is_special(n)) {
  cmdq_push(CMD_REST);
  cmd_set_arg_choice(cmdq_peek(), "choice", n);
  player_set_resting_repeat_count(player, 0);
 } else {
  player_resting_cancel(player, false);
 }
}
/**
 * Spend a turn doing nothing
 */
void do_cmd_sleep(struct command *cmd)
{
 /* Stop singing */
 player_change_song(player, NULL, false);
 /* Take a turn */
 player->upkeep->energy_use = z_info->move_energy;
 /* Store the action type */
 player->previous_action[0] = ACTION_MISC;
}
/**
 * Skip a turn after being knocked back
 */
void do_cmd_skip(struct command *cmd)
{
 /* Let the player know */
 msg("You recover your footing.");
 /* Flush input */
 event_signal(EVENT_MESSAGE_FLUSH);
 /* Reset flag */
 player->upkeep->knocked_back = false;
 /* Take a turn */
 player->upkeep->energy_use = z_info->move_energy;
 /* Store the action type */
 player->previous_action[0] = ACTION_MISC;
}
/**
 * \file cmd-core.c
 * \brief Handles the queueing of game commands.
 *
 * Copyright (c) 2008-9 Antony Sidwell
 * Copyright (c) 2014 Andi Sidwell
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
errr (*cmd_get_hook)(cmd_context c);
/**
 * ------------------------------------------------------------------------
 * A simple list of commands and their handling functions.
 * ------------------------------------------------------------------------ */
struct command_info
{
 cmd_code cmd;
 const char *verb;
 cmd_handler_fn fn;
 bool repeat_allowed;
 int auto_repeat_n;
};
static const struct command_info game_cmds[] =
{
 { CMD_LOADFILE, "load a savefile", NULL, false, 0 },
 { CMD_NEWGAME, "start a new game", NULL, false, 0 },
 { CMD_BIRTH_INIT, "start the character birth process", do_cmd_birth_init, false, 0 },
 { CMD_BIRTH_RESET, "go back to the beginning", do_cmd_birth_reset, false, 0 },
 { CMD_CHOOSE_RACE, "select race", do_cmd_choose_race, false, 0 },
 { CMD_CHOOSE_HOUSE, "select house", do_cmd_choose_house, false, 0 },
 { CMD_CHOOSE_SEX, "select sex", do_cmd_choose_sex, false, 0 },
 { CMD_BUY_STAT, "buy points in a stat", do_cmd_buy_stat, false, 0 },
 { CMD_SELL_STAT, "sell points in a stat", do_cmd_sell_stat, false, 0 },
 { CMD_RESET_STATS, "reset stats", do_cmd_reset_stats, false, 0 },
 { CMD_REFRESH_STATS, "refresh stats", do_cmd_refresh_stats, false, 0 },
 { CMD_BUY_SKILL, "buy points in a skill", do_cmd_buy_skill, false, 0 },
 { CMD_SELL_SKILL, "sell points in a skill", do_cmd_sell_skill, false, 0 },
 { CMD_RESET_SKILLS, "reset skills", do_cmd_reset_skills, false, 0 },
 { CMD_REFRESH_SKILLS, "refresh skills", do_cmd_refresh_skills, false, 0 },
 { CMD_NAME_CHOICE, "choose name", do_cmd_choose_name, false, 0 },
 { CMD_HISTORY_CHOICE, "write history", do_cmd_choose_history, false, 0 },
 { CMD_ACCEPT_CHARACTER, "accept character", do_cmd_accept_character, false, 0 },
 { CMD_GO_UP, "go up stairs", do_cmd_go_up, false, 0 },
 { CMD_GO_DOWN, "go down stairs", do_cmd_go_down, false, 0 },
 { CMD_TOGGLE_STEALTH, "toggle stealth", do_cmd_toggle_stealth, false, 0 },
 { CMD_WALK, "walk", do_cmd_walk, true, 0 },
 { CMD_RUN, "run", do_cmd_run, true, 0 },
 { CMD_JUMP, "jump", do_cmd_jump, false, 0 },
 { CMD_OPEN, "open", do_cmd_open, true, 99 },
 { CMD_CLOSE, "close", do_cmd_close, true, 99 },
 { CMD_BASH, "bash", do_cmd_bash, true, 99 },
 { CMD_EXCHANGE, "exchange places", do_cmd_exchange, false, 0 },
 { CMD_TUNNEL, "tunnel", do_cmd_tunnel, true, 99 },
 { CMD_LEAP, "leap", do_cmd_leap, false, 0 },
 { CMD_HOLD, "stay still", do_cmd_hold, true, 0 },
 { CMD_DISARM, "disarm", do_cmd_disarm, true, 99 },
 { CMD_ALTER, "alter", do_cmd_alter, true, 99 },
 { CMD_REST, "rest", do_cmd_rest, false, 0 },
 { CMD_SLEEP, "sleep", do_cmd_sleep, false, 0 },
 { CMD_SKIP, "skip", do_cmd_skip, false, 0 },
 { CMD_PATHFIND, "walk", do_cmd_pathfind, false, 0 },
 { CMD_PICKUP, "pickup", do_cmd_pickup, false, 0 },
 { CMD_AUTOPICKUP, "autopickup", do_cmd_autopickup, false, 0 },
 { CMD_WIELD, "wear or wield", do_cmd_wield, false, 0 },
 { CMD_TAKEOFF, "take off", do_cmd_takeoff, false, 0 },
 { CMD_DROP, "drop", do_cmd_drop, false, 0 },
 { CMD_DESTROY, "destroy", do_cmd_destroy, false, 0 },
 { CMD_UNINSCRIBE, "un-inscribe", do_cmd_uninscribe, false, 0 },
 { CMD_AUTOINSCRIBE, "autoinscribe", do_cmd_autoinscribe, false, 0 },
 { CMD_EAT, "eat", do_cmd_eat_food, false, 0 },
 { CMD_QUAFF, "quaff", do_cmd_quaff_potion, false, 0 },
 { CMD_BLOW_HORN, "blow", do_cmd_blow_horn, false, 0 },
 { CMD_USE_STAFF, "use", do_cmd_use_staff, false, 0 },
 { CMD_REFUEL, "refuel with", do_cmd_refuel, false, 0 },
 { CMD_FIRE, "fire", do_cmd_fire, false, 0 },
 { CMD_THROW, "throw", do_cmd_throw, false, 0 },
 { CMD_SMITH, "smith", do_cmd_smith, true, 0 },
 { CMD_SING, "change song", do_cmd_change_song, false, 0 },
 { CMD_INSCRIBE, "inscribe", do_cmd_inscribe, false, 0 },
 { CMD_USE, "use", do_cmd_use, false, 0 },
 { CMD_RETIRE, "retire character", do_cmd_retire, false, 0 },
 { CMD_HELP, "help", NULL, false, 0 },
 { CMD_REPEAT, "repeat", NULL, false, 0 },
 { CMD_SPOIL_ARTIFACT, "generate spoiler file for artifacts", do_cmd_spoil_artifact, false, 0 },
 { CMD_SPOIL_MON, "generate spoiler file for monsters", do_cmd_spoil_monster, false, 0 },
 { CMD_SPOIL_MON_BRIEF, "generate brief spoiler file for monsters", do_cmd_spoil_monster_brief, false, 0 },
 { CMD_SPOIL_OBJ, "generate spoiler file for objects", do_cmd_spoil_obj, false, 0 },
 { CMD_WIZ_ACQUIRE, "acquire objects", do_cmd_wiz_acquire, false, 0 },
 { CMD_WIZ_ADVANCE, "make character powerful", do_cmd_wiz_advance, false, 0 },
 { CMD_WIZ_BANISH, "banish nearby monsters", do_cmd_wiz_banish, false, 0 },
 { CMD_WIZ_CHANGE_ITEM_QUANTITY, "change number of an item", do_cmd_wiz_change_item_quantity, false, 0 },
 { CMD_WIZ_COLLECT_DISCONNECT_STATS, "collect statistics about disconnected levels", do_cmd_wiz_collect_disconnect_stats, false, 0 },
 { CMD_WIZ_COLLECT_OBJ_MON_STATS, "collect object/monster statistics", do_cmd_wiz_collect_obj_mon_stats, false, 0 },
 { CMD_WIZ_CREATE_ALL_ARTIFACT, "create all artifacts", do_cmd_wiz_create_all_artifact, false, 0 },
 { CMD_WIZ_CREATE_ALL_ARTIFACT_FROM_TVAL, "create all artifacts of a tval", do_cmd_wiz_create_all_artifact_from_tval, false, 0 },
 { CMD_WIZ_CREATE_ALL_OBJ, "create all objects", do_cmd_wiz_create_all_obj, false, 0 },
 { CMD_WIZ_CREATE_ALL_OBJ_FROM_TVAL, "create all objects of a tval", do_cmd_wiz_create_all_obj_from_tval, false, 0 },
 { CMD_WIZ_CREATE_ARTIFACT, "create artifact", do_cmd_wiz_create_artifact, false, 0 },
 { CMD_WIZ_CREATE_OBJ, "create object", do_cmd_wiz_create_obj, false, 0 },
 { CMD_WIZ_CREATE_TRAP, "create trap", do_cmd_wiz_create_trap, false, 0 },
 { CMD_WIZ_CURE_ALL, "cure everything", do_cmd_wiz_cure_all, false, 0 },
 { CMD_WIZ_DETECT_ALL_LOCAL, "detect everything nearby", do_cmd_wiz_detect_all_local, false, 0 },
 { CMD_WIZ_DETECT_ALL_MONSTERS, "detect all monsters", do_cmd_wiz_detect_all_monsters, false, 0 },
 { CMD_WIZ_DISPLAY_KEYLOG, "display keystroke log", do_cmd_wiz_display_keylog, false, 0 },
 { CMD_WIZ_DUMP_LEVEL_MAP, "write map of level", do_cmd_wiz_dump_level_map, false, 0 },
 { CMD_WIZ_EDIT_PLAYER_EXP, "change the player's experience", do_cmd_wiz_edit_player_exp, false, 0 },
 { CMD_WIZ_EDIT_PLAYER_START, "start editing the player", do_cmd_wiz_edit_player_start, false, 0 },
 { CMD_WIZ_EDIT_PLAYER_STAT, "edit one of the player's stats", do_cmd_wiz_edit_player_stat, false, 0 },
 { CMD_WIZ_HIT_ALL_LOS, "hit all monsters in LOS", do_cmd_wiz_hit_all_los, false, 0 },
 { CMD_WIZ_INCREASE_EXP, "increase experience", do_cmd_wiz_increase_exp, false, 0 },
 { CMD_WIZ_JUMP_LEVEL, "jump to a level", do_cmd_wiz_jump_level, false, 0 },
 { CMD_WIZ_LEARN_OBJECT_KINDS, "learn about kinds of objects", do_cmd_wiz_learn_object_kinds, false, 0 },
 { CMD_WIZ_MAGIC_MAP, "map local area", do_cmd_wiz_magic_map, false, 0 },
 { CMD_WIZ_PEEK_NOISE_SCENT, "peek at noise and scent", do_cmd_wiz_peek_noise_scent, false, 0 },
 { CMD_WIZ_PERFORM_EFFECT, "perform an effect", do_cmd_wiz_perform_effect, false, 0 },
 { CMD_WIZ_PLAY_ITEM, "play with item", do_cmd_wiz_play_item, false, 0 },
 { CMD_WIZ_PUSH_OBJECT, "push objects from square", do_cmd_wiz_push_object, false, 0 },
 { CMD_WIZ_QUERY_FEATURE, "highlight specific feature", do_cmd_wiz_query_feature, false, 0 },
 { CMD_WIZ_QUERY_SQUARE_FLAG, "query square flag", do_cmd_wiz_query_square_flag, false, 0 },
 { CMD_WIZ_QUIT_NO_SAVE, "quit without saving", do_cmd_wiz_quit_no_save, false, 0 },
 { CMD_WIZ_RECALL_MONSTER, "recall monster", do_cmd_wiz_recall_monster, false, 0 },
 { CMD_WIZ_REROLL_ITEM, "reroll an item", do_cmd_wiz_reroll_item, false, 0 },
 { CMD_WIZ_STAT_ITEM, "get statistics for an item", do_cmd_wiz_stat_item, false, 0 },
 { CMD_WIZ_SUMMON_NAMED, "summon specific monster", do_cmd_wiz_summon_named, false, 0 },
 { CMD_WIZ_SUMMON_RANDOM, "summon random monsters", do_cmd_wiz_summon_random, false, 0 },
 { CMD_WIZ_TELEPORT_TO, "teleport to location", do_cmd_wiz_teleport_to, false, 0 },
 { CMD_WIZ_TWEAK_ITEM, "modify item attributes", do_cmd_wiz_tweak_item, false, 0 },
 { CMD_WIZ_WIPE_RECALL, "erase monster recall", do_cmd_wiz_wipe_recall, false, 0 },
 { CMD_WIZ_WIZARD_LIGHT, "wizard light the level", do_cmd_wiz_wizard_light, false, 0 },
};
/**
 * Make a deep copy of a command and its arguments.
 */
void cmd_copy(struct command *dest, const struct command *src)
{
 int i;
 *dest = *src;
 /* String arguments require a deep copy. */
 for (i = 0; i < CMD_MAX_ARGS; ++i) {
  if (dest->arg[i].type == arg_STRING) {
   dest->arg[i].data.string =
    string_make(src->arg[i].data.string);
  }
 }
}
/**
 * Release any resources for the command's arguments.
 */
void cmd_release(struct command *cmd)
{
 int i;
 for (i = 0; i < CMD_MAX_ARGS; ++i) {
  if (cmd->arg[i].type == arg_STRING) {
   string_free((char*)(cmd->arg[i].data.string));
   cmd->arg[i].name[0] = '\0';
   cmd->arg[i].type = arg_NONE;
  }
 }
}
const char *cmd_verb(cmd_code cmd)
{
 size_t i;
 for (i = 0; i < N_ELEMENTS(game_cmds); i++) {
  if (game_cmds[i].cmd == cmd)
   return game_cmds[i].verb;
 }
 return NULL;
}
/**
 * Return the index of the given command in the command array.
 */
static int cmd_idx(cmd_code code)
{
 size_t i;
 for (i = 0; i < N_ELEMENTS(game_cmds); i++)
  if (game_cmds[i].cmd == code)
   return i;
 return CMD_ARG_NOT_PRESENT;
}
/**
 * ------------------------------------------------------------------------
 * The command queue.
 * ------------------------------------------------------------------------ */
static int cmd_head = 0;
static int cmd_tail = 0;
static struct command cmd_queue[20];
/*
 * Remember last non-background command executed for use by CMD_REPEAT; either
 * still in the queue at last_command_idx or copied out of the queue into
 * last_command
 */
int last_command_idx = -1;
static struct command last_command = {
 .context = CTX_INIT,
 .code = CMD_NULL,
 .nrepeats = 0,
 .is_background_command = false,
 .arg = { { 0 } }
};
static bool repeat_prev_allowed = false;
static bool repeating = false;
struct command *cmdq_peek(void)
{
 return &cmd_queue[((cmd_head + 20 - 1) % 20)];
}
/**
 * Insert the given command into the command queue.
 *
 * Makes a shallow copy of the command.  If the command has string arguments,
 * the queue assumes ownership of those arguments.
 */
errr cmdq_push_copy(struct command *cmd)
{
 /* If queue full, return error */
 if (cmd_head + 1 == cmd_tail) return 1;
 if (cmd_head + 1 == 20 && cmd_tail == 0) return 1;
 /* Insert command into queue. */
 if (cmd->code != CMD_REPEAT) {
  if (last_command_idx == cmd_head) {
   /*
			 * The last non-background command will be overwritten.
			 * Copy out of the queue in case it is needed for
			 * CMD_REPEAT.
			 */
   cmd_release(&last_command);
   cmd_copy(&last_command, &cmd_queue[cmd_head]);
   last_command_idx = -1;
  }
  cmd_release(&cmd_queue[cmd_head]);
  cmd_queue[cmd_head] = *cmd;
 } else if (!repeat_prev_allowed) {
  return 1;
 } else {
  /*
		 * If we're repeating a command, we duplicate the previous
		 * command in the next command "slot".
		 */
  if (last_command_idx >= 0) {
   assert(last_command_idx < 20);
   if (last_command_idx != cmd_head) {
    cmd_release(&cmd_queue[cmd_head]);
    cmd_copy(&cmd_queue[cmd_head],
     &cmd_queue[last_command_idx]);
   }
  } else if (last_command.code != CMD_NULL) {
   cmd_release(&cmd_queue[cmd_head]);
   cmd_copy(&cmd_queue[cmd_head], &last_command);
  } else {
   return 1;
  }
 }
 /* Advance point in queue, wrapping around at the end */
 cmd_head++;
 if (cmd_head == 20) cmd_head = 0;
 return 0;
}
/**
 * Process a game command from the UI or the command queue and carry out
 * whatever actions go along with it.
 */
static void process_command(cmd_context ctx, struct command *cmd)
{
 int oldrepeats = cmd->nrepeats;
 int idx = cmd_idx(cmd->code);
 /* Reset so that when selecting items, we look in the default location */
 player->upkeep->command_wrk = 0;
 if (idx == -1) return;
 /* Command repetition */
 if (game_cmds[idx].repeat_allowed) {
  /* Auto-repeat only if there isn't already a repeat length. */
  if (game_cmds[idx].auto_repeat_n > 0 && cmd->nrepeats == 0)
   cmd_set_repeat(game_cmds[idx].auto_repeat_n);
 } else {
  cmd->nrepeats = 0;
  repeating = false;
 }
 /* The command gets to unset this if it isn't appropriate for
	 * the user to repeat it. */
 repeat_prev_allowed = true;
 cmd->context = ctx;
 /* Actually execute the command function */
 if (game_cmds[idx].fn) {
  game_cmds[idx].fn(cmd);
 }
 /* If the command hasn't changed nrepeats, count this execution. */
 if (cmd->nrepeats > 0 && oldrepeats == cmd_get_nrepeats())
  cmd_set_repeat(oldrepeats - 1);
}
/**
 * Get the next game command from the queue and process it.
 */
bool cmdq_pop(cmd_context c)
{
 struct command *cmd;
 /* If we're repeating, just pull the last command again. */
 if (repeating) {
  cmd = &cmd_queue[((cmd_tail + 20 - 1) % 20)];
 } else if (cmd_head != cmd_tail) {
  /* If we have a command ready, set it. */
  cmd = &cmd_queue[cmd_tail++];
  if (cmd_tail == 20)
   cmd_tail = 0;
 } else {
  /* Failure to get a command. */
  return false;
 }
 /* Now process it */
 if (!cmd->is_background_command) {
  last_command_idx = ((cmd_tail + 20 - 1) % 20);
 }
 process_command(c, cmd);
 return true;
}
/**
 * Inserts a command in the queue to be carried out, with the given
 * number of repeats.
 */
errr cmdq_push_repeat(cmd_code c, int nrepeats)
{
 struct command cmd = {
  .context = CTX_INIT,
  .code = CMD_NULL,
  .nrepeats = 0,
  .is_background_command = false,
  .arg = { { 0 } }
 };
 if (cmd_idx(c) == -1)
  return 1;
 cmd.code = c;
 cmd.nrepeats = nrepeats;
 return cmdq_push_copy(&cmd);
}
/**
 * Inserts a command in the queue to be carried out. 
 */
errr cmdq_push(cmd_code c)
{
 return cmdq_push_repeat(c, 0);
}
/**
 * Shorthand to execute all commands in the queue right now, no waiting
 * for input.
 */
void cmdq_execute(cmd_context ctx)
{
 while (cmdq_pop(ctx)) ;
}
/**
 * Remove all commands from the queue.
 */
void cmdq_flush(void)
{
 cmd_tail = cmd_head;
}
/**
 * Remove all commands from the queue and release any allocated resources.
 */
void cmdq_release(void)
{
 int i;
 cmdq_flush();
 for (i = 0; i < 20; ++i) {
  cmd_release(cmd_queue + i);
 }
 cmd_release(&last_command);
 last_command.code = CMD_NULL;
 last_command_idx = -1;
}
/**
 * ------------------------------------------------------------------------
 * Handling of repeated commands
 * ------------------------------------------------------------------------ */
/**
 * Remove any pending repeats from the current command.
 */
void cmd_cancel_repeat(void)
{
 struct command *cmd = &cmd_queue[((cmd_tail + 20 - 1) % 20)];
 if (cmd->nrepeats || repeating) {
  /* Cancel */
  cmd->nrepeats = 0;
  repeating = false;
  /* Redraw the state (later) */
  player->upkeep->redraw |= (PR_STATE);
 }
}
/**
 * Update the number of repeats pending for the current command.
 */
void cmd_set_repeat(int nrepeats)
{
 struct command *cmd = &cmd_queue[((cmd_tail + 20 - 1) % 20)];
 cmd->nrepeats = nrepeats;
 if (nrepeats) repeating = true;
 else repeating = false;
 /* Redraw the state (later) */
 player->upkeep->redraw |= (PR_STATE);
}
/**
 * Return the number of repeats pending for the current command.
 */
int cmd_get_nrepeats(void)
{
 struct command *cmd = &cmd_queue[((cmd_tail + 20 - 1) % 20)];
 return cmd->nrepeats;
}
/**
 * Do not allow the current command to be repeated by the user using the
 * "repeat last command" command.
 */
void cmd_disable_repeat(void)
{
 repeat_prev_allowed = false;
}
/**
 * Do not allow the current command to be repeated by the user using the
 * "repeat last command" command if that command used an item from the floor.
 */
void cmd_disable_repeat_floor_item(void)
{
 int cmd_prev;
 /*
	 * Repeat already disallowed so skip further checks (avoids access
	 * to dangling object references in the command structures).
	 */
 if (!repeat_prev_allowed) return;
 cmd_prev = cmd_head - 1;
 if (cmd_prev < 0) cmd_prev = 20 - 1;
 if (cmd_queue[cmd_prev].code != CMD_NULL) {
  struct command *cmd = &cmd_queue[cmd_prev];
  int i = 0;
  while (1) {
   if (i >= CMD_MAX_ARGS) {
    break;
   }
   if (cmd->arg[i].type == arg_ITEM
    && cmd->arg[i].data.obj
    && (cmd->arg[i].data.obj->grid.x != 0
     || cmd->arg[i].data.obj->grid.y != 0)) {
    repeat_prev_allowed = false;
    break;
   }
   ++i;
  }
 }
}
/**
 * ------------------------------------------------------------------------
 * Argument setting/getting generics
 * ------------------------------------------------------------------------ */
/**
 * Set an argument of name 'arg' to data 'data'
 */
static void cmd_set_arg(struct command *cmd, const char *name,
      enum cmd_arg_type type, union cmd_arg_data data)
{
 size_t i;
 int first_empty = -1;
 int idx = -1;
 assert(name);
 assert(name[0]);
 /* Find an arg that either... */
 for (i = 0; i < CMD_MAX_ARGS; i++) {
  struct cmd_arg *arg = &cmd->arg[i];
  if (!arg->name[0] && first_empty == -1)
   first_empty = i;
  if (streq(arg->name, name)) {
   idx = i;
   break;
  }
 }
 assert(first_empty != -1 || idx != -1);
 if (idx == -1) {
  idx = first_empty;
 } else {
  /* Free allocated string if overwriting a string argument. */
  if (cmd->arg[idx].type == arg_STRING) {
   string_free((char*)(cmd->arg[idx].data.string));
  }
 }
 cmd->arg[idx].type = type;
 cmd->arg[idx].data = data;
 my_strcpy(cmd->arg[idx].name, name, sizeof cmd->arg[0].name);
}
/**
 * Get an argument with name 'arg'
 */
static int cmd_get_arg(struct command *cmd, const char *arg,
        enum cmd_arg_type type, union cmd_arg_data *data)
{
 size_t i;
 for (i = 0; i < CMD_MAX_ARGS; i++) {
  if (streq(cmd->arg[i].name, arg)) {
   if (cmd->arg[i].type != type)
    return CMD_ARG_WRONG_TYPE;
   *data = cmd->arg[i].data;
   return CMD_OK;
  }
 }
 return CMD_ARG_NOT_PRESENT;
}
/**
 * ------------------------------------------------------------------------
 * 'Choice' type
 * ------------------------------------------------------------------------ */
/**
 * XXX This type is a hack. The only places that use this are:
 * - resting
 * - birth choices
 * - store items
 * - spells
 * - selecting an effect for an item that activates for an EF_SELECT effect
 *   (dragon's breath wands or potions, dragon armor that has multiple breath
 *   types)
 * - several debugging commands for integer or boolean arguments that did not
 *   seem to be a good match for 'number' arguments
 *
 * Each of these should have its own type, which will allow for proper
 * validity checking of data.
 */
/**
 * Set arg 'n' to 'choice'
 */
void cmd_set_arg_choice(struct command *cmd, const char *arg, int choice)
{
 union cmd_arg_data data;
 data.choice = choice;
 cmd_set_arg(cmd, arg, arg_CHOICE, data);
}
/**
 * Retrive an argument 'n' if it's a choice
 */
int cmd_get_arg_choice(struct command *cmd, const char *arg, int *choice)
{
 union cmd_arg_data data;
 int err;
 if ((err = cmd_get_arg(cmd, arg, arg_CHOICE, &data)) == CMD_OK)
  *choice = data.choice;
 return err;
}
/**
 * Choose an effect from a list, first try the command but then prompt
 * \param cmd is the command to use.
 * \param arg is the name of the argument to consult in the command
 * \param choice When the return value is CMD_OK, *choice will be set to the
 * index in the list for the selected effect or to -2 if the user selected the
 * random option enabled by allow_random.
 * \param prompt Is the text for the prompt displayed when querying the user.
 * May be NULL to use a default prompt.
 * \param effect points to the first effect in the linked list of effects.
 * \param count is the number of effects from which to choose.  If count is -1,
 * all the effects in the list will be used.
 * \param allow_random when true, present the user an additional option which
 * will choose one of the effects at random; when false, only present the
 * options that correspond to the effects in the list.
 * \return CMD_OK if *choice was updated with a valid selection; otherwise
 * return CMD_ARG_ABORTED.
 */
int cmd_get_effect_from_list(struct command *cmd, const char *arg, int *choice,
 const char *prompt, struct effect *effect, int count,
 bool allow_random)
{
 int selection;
 if (count == -1) {
  struct effect *cursor = effect;
  count = 0;
  while (cursor) {
   ++count;
   cursor = effect_next(cursor);
  }
 }
 if (cmd_get_arg_choice(cmd, arg, &selection) != CMD_OK ||
   ((selection != -2 || !allow_random) &&
   (selection < 0 || selection >= count))) {
  /* It isn't in the command or is invalid; prompt. */
  selection = get_effect_from_list(prompt, effect, count,
   allow_random);
 }
 if ((selection == -2 && allow_random) ||
   (selection >= 0 && selection < count)) {
  /* Record the selection in the command. */
  cmd_set_arg_choice(cmd, arg, selection);
  *choice = selection;
  return CMD_OK;
 }
 return CMD_ARG_ABORTED;
}
/**
 * ------------------------------------------------------------------------
 * Strings
 * ------------------------------------------------------------------------ */
/**
 * Set arg 'n' to given string
 */
void cmd_set_arg_string(struct command *cmd, const char *arg, const char *str)
{
 union cmd_arg_data data;
 data.string = string_make(str);
 cmd_set_arg(cmd, arg, arg_STRING, data);
}
/**
 * Retrieve arg 'n' if a string
 *
 * Note that the command itself retains ownership of the pointer returned in
 * *str:  the caller should not free that pointer.
 */
int cmd_get_arg_string(struct command *cmd, const char *arg, const char **str)
{
 union cmd_arg_data data;
 int err;
 if ((err = cmd_get_arg(cmd, arg, arg_STRING, &data)) == CMD_OK)
  *str = data.string;
 return err;
}
/**
 * Get a string, first from the command or failing that prompt the user
 *
 * Note that the command itself retains ownership of the pointer returned in
 * *str:  the caller should not free that pointer.
 */
int cmd_get_string(struct command *cmd, const char *arg, const char **str,
       const char *initial, const char *title, const char *prompt)
{
 char tmp[80] = "";
 if (cmd_get_arg_string(cmd, arg, str) == CMD_OK)
  return CMD_OK;
 /* Introduce */
 msg("%s", title);
 event_signal(EVENT_MESSAGE_FLUSH);
 /* Prompt properly */
 if (initial)
  my_strcpy(tmp, initial, sizeof tmp);
 if (get_string(prompt, tmp, sizeof tmp)) {
  cmd_set_arg_string(cmd, arg, tmp);
  if (cmd_get_arg_string(cmd, arg, str) == CMD_OK)
   return CMD_OK;
 }
 return CMD_ARG_ABORTED;
}
/**
 * ------------------------------------------------------------------------
 * Directions
 * ------------------------------------------------------------------------ */
/**
 * Set arg 'n' to given direction
 */
void cmd_set_arg_direction(struct command *cmd, const char *arg, int dir)
{
 union cmd_arg_data data;
 data.direction = dir;
 cmd_set_arg(cmd, arg, arg_DIRECTION, data);
}
/**
 * Retrieve arg 'n' if a direction
 */
int cmd_get_arg_direction(struct command *cmd, const char *arg, int *dir)
{
 union cmd_arg_data data;
 int err;
 if ((err = cmd_get_arg(cmd, arg, arg_DIRECTION, &data)) == CMD_OK)
  *dir = data.direction;
 return err;
}
/**
 * Get a direction, first from command or prompt otherwise
 */
int cmd_get_direction(struct command *cmd, const char *arg, int *dir,
       bool allow_5)
{
 if (cmd_get_arg_direction(cmd, arg, dir) == CMD_OK) {
  /* Validity check */
  if (*dir != DIR_NONE)
   return CMD_OK;
 }
 /* We need to do extra work */
 if (get_rep_dir(dir, allow_5)) {
  cmd_set_arg_direction(cmd, arg, *dir);
  return CMD_OK;
 }
 cmd_cancel_repeat();
 return CMD_ARG_ABORTED;
}
/**
 * ------------------------------------------------------------------------
 * Targets
 * ------------------------------------------------------------------------ */
/**
 * XXX Should this be unified with the arg_DIRECTION type?
 *
 * XXX Should we abolish DIR_TARGET and instead pass a struct target which
 * contains all relevant info?
 */
/**
 * Set arg 'n' to target
 */
void cmd_set_arg_target(struct command *cmd, const char *arg, int target)
{
 union cmd_arg_data data;
 data.direction = target;
 cmd_set_arg(cmd, arg, arg_TARGET, data);
}
/**
 * Retrieve arg 'n' if it's a target
 */
int cmd_get_arg_target(struct command *cmd, const char *arg, int *target)
{
 union cmd_arg_data data;
 int err;
 if ((err = cmd_get_arg(cmd, arg, arg_TARGET, &data)) == CMD_OK)
  *target = data.direction;
 return err;
}
/**
 * Get a target, first from command or prompt otherwise
 */
int cmd_get_target(struct command *cmd, const char *arg, int *target, int range,
       bool allow_vertical)
{
 if (cmd_get_arg_target(cmd, arg, target) == CMD_OK) {
  if (*target != DIR_UNKNOWN &&
   (*target != DIR_TARGET || target_okay(range)))
   return CMD_OK;
 }
 if (get_aim_dir(target, range) &&
  (((*target != DIR_UP) && (*target != DIR_DOWN)) || allow_vertical)) {
  cmd_set_arg_target(cmd, arg, *target);
  return CMD_OK;
 }
 return CMD_ARG_ABORTED;
}
/**
 * ------------------------------------------------------------------------
 * Points
 * ------------------------------------------------------------------------ */
/**
 * Set argument 'n' to point grid
 */
void cmd_set_arg_point(struct command *cmd, const char *arg, struct loc grid)
{
 union cmd_arg_data data;
 data.point = grid;
 cmd_set_arg(cmd, arg, arg_POINT, data);
}
/**
 * Retrieve argument 'n' if it's a point
 */
int cmd_get_arg_point(struct command *cmd, const char *arg, struct loc *grid)
{
 union cmd_arg_data data;
 int err;
 if ((err = cmd_get_arg(cmd, arg, arg_POINT, &data)) == CMD_OK) {
  *grid = data.point;
 }
 return err;
}
/**
 * ------------------------------------------------------------------------
 * Item arguments
 * ------------------------------------------------------------------------ */
/**
 * Set argument 'n' to 'item'
 */
void cmd_set_arg_item(struct command *cmd, const char *arg, struct object *obj)
{
 union cmd_arg_data data;
 data.obj = obj;
 cmd_set_arg(cmd, arg, arg_ITEM, data);
}
/**
 * Retrieve argument 'n' as an item
 */
int cmd_get_arg_item(struct command *cmd, const char *arg, struct object **obj)
{
 union cmd_arg_data data;
 int err;
 if ((err = cmd_get_arg(cmd, arg, arg_ITEM, &data)) == CMD_OK)
  *obj = data.obj;
 return err;
}
/**
 * Get an item, first from the command or try the UI otherwise
 */
int cmd_get_item(struct command *cmd, const char *arg, struct object **obj,
     const char *prompt, const char *reject, item_tester filter,
     int mode)
{
 if ((cmd_get_arg_item(cmd, arg, obj) == CMD_OK) && (!filter|| filter(*obj)))
  return CMD_OK;
 if (get_item(obj, prompt, reject, cmd->code, filter, mode)) {
  cmd_set_arg_item(cmd, arg, *obj);
  return CMD_OK;
 }
 return CMD_ARG_ABORTED;
}
/**
 * ------------------------------------------------------------------------
 * Numbers, quantities
 * ------------------------------------------------------------------------ */
/**
 * Set argument 'n' to 'number'
 */
void cmd_set_arg_number(struct command *cmd, const char *arg, int amt)
{
 union cmd_arg_data data;
 data.number = amt;
 cmd_set_arg(cmd, arg, arg_NUMBER, data);
}
/**
 * Get argument 'n' as a number
 */
int cmd_get_arg_number(struct command *cmd, const char *arg, int *amt)
{
 union cmd_arg_data data;
 int err;
 if ((err = cmd_get_arg(cmd, arg, arg_NUMBER, &data)) == CMD_OK)
  *amt = data.number;
 return err;
}
/**
 * Get argument 'n' as a number; failing that, prompt for input
 */
int cmd_get_quantity(struct command *cmd, const char *arg, int *amt, int max)
{
 if (cmd_get_arg_number(cmd, arg, amt) == CMD_OK)
  return CMD_OK;
 *amt = get_quantity(NULL, max);
 if (*amt > 0) {
  cmd_set_arg_number(cmd, arg, *amt);
  return CMD_OK;
 }
 return CMD_ARG_ABORTED;
}
/**
 * \file cmd-misc.c
 * \brief Deal with miscellaneous commands.
 *
 * Copyright (c) 2010 Andi Sidwell
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Toggle wizard mode
 */
void do_cmd_wizard(void)
{
 /* Verify first time */
 if (!(player->noscore & NOSCORE_WIZARD)) {
  /* Mention effects */
  msg("You are about to enter 'wizard' mode for the very first time!");
  msg("This is a form of cheating, and your game will not be scored!");
  event_signal(EVENT_MESSAGE_FLUSH);
  /* Verify request */
  if (!get_check("Are you sure you want to enter wizard mode? "))
   return;
  /* Mark savefile */
  player->noscore |= NOSCORE_WIZARD;
 }
 /* Toggle mode */
 if (player->wizard) {
  player->wizard = false;
  msg("Wizard mode off.");
 } else {
  player->wizard = true;
  msg("Wizard mode on.");
 }
 /* Update monsters */
 player->upkeep->update |= (PU_MONSTERS);
}
/**
 * Escape from Angband
 */
void do_cmd_escape(void)
{
 time_t ct = time((time_t*)0);
 char long_day[40];
 char buf[120];
 /* Set the escaped flag */
 player->escaped = true;
 /* Flush input */
 event_signal(EVENT_INPUT_FLUSH);
 /* Treat escaping character as dead to satisfy end of game logic. */
 event_signal(EVENT_DEATH);
 player->is_dead = true;
 /* Get time */
 (void)strftime(long_day, 40, "%d %B %Y", localtime(&ct));
 /* Add notes to the history */
 strnfmt(buf, sizeof(buf), "You escaped the Iron Hells on %s.", long_day);
 history_add(player, buf, HIST_ESCAPE);
 switch (silmarils_possessed(player)) {
  case 0: {
   history_add(player, "You returned empty handed.", HIST_ESCAPE);
   break;
  }
  case 1: {
   history_add(player, "You brought back a Silmaril from Morgoth's crown!", HIST_ESCAPE);
   break;
  }
  case 2: {
   history_add(player, "You brought back two Silmarils from Morgoth's crown!", HIST_ESCAPE);
   break;
  }
  case 3: {
   history_add(player, "You brought back all three Silmarils from Morgoth's crown!", HIST_ESCAPE);
   break;
  }
  default: {
   history_add(player, "You brought back so many Silmarils that people should be suspicious!", HIST_ESCAPE);
  }
 }
 /* Cause of death */
 my_strcpy(player->died_from, "ripe old age", sizeof(player->died_from));
}
/**
 * Retire
 */
void do_cmd_retire(struct command *cmd)
{
 /* Treat retired character as dead to satisfy end of game logic. */
 player->is_dead = true;
 my_strcpy(player->died_from, "Retiring", sizeof(player->died_from));
}
/**
 * Record the player's thoughts as a note.
 *
 * This both displays the note back to the player and adds it to the game log.
 * Two fancy note types are supported: notes beginning with "/say" will be
 * written as 'Frodo says: "____"', and notes beginning with "/me" will
 * be written as 'Frodo ____'.
 */
void do_cmd_note(void)
{
 /* Allocate/Initialize strings to get and format user input. */
 char tmp[70];
 char note[90];
 my_strcpy(tmp, "", sizeof(tmp));
 my_strcpy(note, "", sizeof(note));
 /* Read a line of input from the user */
 if (!get_string("Note: ", tmp, sizeof(tmp))) return;
 /* Ignore empty notes */
 if (!tmp[0] || (tmp[0] == ' ')) return;
 /* Format the note correctly, supporting some cute /me commands */
 if (strncmp(tmp, "/say ", 5) == 0)
  strnfmt(note, sizeof(note), "-- %s says: \"%s\"", player->full_name,
    &tmp[5]);
 else if (strncmp(tmp, "/me", 3) == 0)
  strnfmt(note, sizeof(note), "-- %s%s", player->full_name, &tmp[3]);
 else
  strnfmt(note, sizeof(note), "-- Note: %s", tmp);
 /* Display the note (omitting the "-- " prefix) */
 msg("%s", &note[3]);
 /* Add a history entry */
 history_add(player, note, HIST_USER_INPUT);
}
/**
 * \file cmd-obj.c
 * \brief Handle objects in various ways
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 * Copyright (c) 2007-9 Andi Sidwell, Chris Carr, Ed Graham, Erik Osheim
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * ------------------------------------------------------------------------
 * Utility bits and bobs
 * ------------------------------------------------------------------------
 */
/**
 * Check to see if the player can use a staff.
 */
static int check_devices(struct object *obj)
{
 /* Base chance of success */
 int score = player->state.skill_use[SKILL_WILL];
 /* Base difficulty */
 int difficulty = obj->kind->level / 2;
 /* Bonus to roll for 'channeling' ability */
 if (player_active_ability(player, "Channeling")) {
  score += 5;
 }
 /* Confusion hurts skill */
 if (player->timed[TMD_CONFUSED]) difficulty += 5;
 /* Roll for usage */
 if (skill_check(source_player(), score, difficulty, source_none()) <= 0) {
  event_signal(EVENT_INPUT_FLUSH);
  msg("You failed to use the staff properly.");
  return false;
 }
 /* Notice empty staffs */
 if (!obj_has_charges(obj)) {
  event_signal(EVENT_INPUT_FLUSH);
  msg("That staff has no charges left.");
  obj->notice |= (OBJ_NOTICE_EMPTY);
  return false;
 }
 return true;
}
/**
 * ------------------------------------------------------------------------
 * Inscriptions
 * ------------------------------------------------------------------------
 */
/**
 * Remove inscription
 */
void do_cmd_uninscribe(struct command *cmd)
{
 struct object *obj;
 /* Get arguments */
 if (cmd_get_item(cmd, "item", &obj,
   /* Prompt */ "Uninscribe which item?",
   /* Error  */ "You have nothing you can uninscribe.",
   /* Filter */ obj_has_inscrip,
   /* Choice */ USE_EQUIP | USE_INVEN | USE_QUIVER | USE_FLOOR) != CMD_OK)
  return;
 obj->note = 0;
 msg("Inscription removed.");
 player->upkeep->notice |= (PN_COMBINE | PN_IGNORE);
 player->upkeep->redraw |= (PR_INVEN | PR_EQUIP);
}
/**
 * Add inscription
 */
void do_cmd_inscribe(struct command *cmd)
{
 struct object *obj;
 const char *str;
 char prompt[1024];
 char o_name[80];
 /* Get arguments */
 if (cmd_get_item(cmd, "item", &obj,
   /* Prompt */ "Inscribe which item?",
   /* Error  */ "You have nothing to inscribe.",
   /* Filter */ NULL,
   /* Choice */ USE_EQUIP | USE_INVEN | USE_QUIVER | USE_FLOOR | IS_HARMLESS) != CMD_OK)
  return;
 /* Form prompt */
 object_desc(o_name, sizeof(o_name), obj, ODESC_PREFIX | ODESC_FULL,
  player);
 strnfmt(prompt, sizeof prompt, "Inscribing %s.", o_name);
 if (cmd_get_string(cmd, "inscription", &str,
   quark_str(obj->note) /* Default */,
   prompt, "Inscribe with what? ") != CMD_OK)
  return;
 obj->note = quark_add(str);
 player->upkeep->notice |= (PN_COMBINE | PN_IGNORE);
 player->upkeep->redraw |= (PR_INVEN | PR_EQUIP);
}
/**
 * Autoinscribe all appropriate objects
 */
void do_cmd_autoinscribe(struct command *cmd)
{
 autoinscribe_ground(player);
 autoinscribe_pack(player);
 player->upkeep->redraw |= (PR_INVEN | PR_EQUIP);
}
/**
 * ------------------------------------------------------------------------
 * Taking off/putting on
 * ------------------------------------------------------------------------
 */
/**
 * Take off an item
 */
void do_cmd_takeoff(struct command *cmd)
{
 struct object *obj;
 /* Get arguments */
 if (cmd_get_item(cmd, "item", &obj,
   /* Prompt */ "Take off or unwield which item?",
   /* Error  */ "You have nothing to take off or unwield.",
   /* Filter */ obj_can_takeoff,
   /* Choice */ USE_EQUIP) != CMD_OK)
  return;
 /* Cannot take off stickied items without special measures. */
 if (handle_stickied_removal(player, obj)) {
  return;
 }
 inven_takeoff(obj);
 combine_pack(player);
 pack_overflow(obj);
 player->upkeep->energy_use = z_info->move_energy;
 /* Store the action type */
 player->previous_action[0] = ACTION_MISC;
}
/**
 * Wield or wear an item
 */
void do_cmd_wield(struct command *cmd)
{
 struct object *equip_obj;
 struct object *weapon = equipped_item_by_slot_name(player, "weapon");
 int shield_slot = slot_by_name(player, "arm");
 char o_name[80];
 unsigned n;
 int slot;
 struct object *obj;
 struct ability *ability;
 bool two_weapon = false;
 bool combine = false;
 /* Get arguments */
 if (cmd_get_item(cmd, "item", &obj,
   /* Prompt */ "Wear or wield which item?",
   /* Error  */ "You have nothing to wear or wield.",
   /* Filter */ obj_can_wear,
   /* Choice */ USE_INVEN | USE_FLOOR | USE_QUIVER) != CMD_OK)
  return;
 /* Check whether it would be too heavy */
 if (!object_is_carried(player, obj) &&
  (player->upkeep->total_weight + obj->weight >
   weight_limit(player->state)* 3 / 2)) {
  /* Describe it */
  object_desc(o_name, sizeof(o_name), obj,
   ODESC_PREFIX | ODESC_FULL, player);
  if (obj->kind) msg("You cannot lift %s.", o_name);
  /* Abort */
  return;
 }
 /*
	 * Get the slot the object wants to go in, and the item currently
	 * there.  Treat arrows specially to ease merging with what is in
	 * the quiver.
	 */
 if (tval_is_ammo(obj)) {
  int quiver1_slot = slot_by_name(player, "first quiver");
  struct object *quiver1_obj =
   equipped_item_by_slot_name(player, "first quiver");
  int quiver2_slot = slot_by_name(player, "second quiver");
  struct object *quiver2_obj =
   equipped_item_by_slot_name(player, "second quiver");
  if (quiver1_obj
    && object_similar(quiver1_obj, obj, OSTACK_PACK)
    && quiver1_obj->number
    < quiver1_obj->kind->base->max_stack) {
   slot = quiver1_slot;
   equip_obj = quiver1_obj;
   combine = true;
  } else if (quiver2_obj
    && object_similar(quiver2_obj, obj, OSTACK_PACK)
    && quiver2_obj->number
    < quiver2_obj->kind->base->max_stack) {
   slot = quiver2_slot;
   equip_obj = quiver2_obj;
   combine = true;
  } else if (quiver1_obj && quiver2_obj) {
   /* Ask for arrow set to replace */
   if (cmd_get_item(cmd, "replace", &equip_obj,
     /* Prompt */ "Replace which set of arrows? ",
     /* Error  */ "Error in do_cmd_wield(), please report.",
     /* Filter */ tval_is_ammo,
     /* Choice */ USE_EQUIP) != CMD_OK) {
    return;
   }
   slot = equipped_item_slot(player->body, equip_obj);
  } else {
   slot = (quiver1_obj) ? quiver2_slot : quiver1_slot;
   equip_obj = NULL;
   assert(!slot_object(player, slot));
  }
 } else {
  slot = wield_slot(obj);
  equip_obj = slot_object(player, slot);
 }
 /* Deal with wielding of two-handed weapons when already using a shield */
 if (of_has(obj->flags, OF_TWO_HANDED) && slot_object(player, shield_slot)) {
  bool shield = tval_is_shield(slot_object(player, shield_slot));
  const char *thing = shield ? "shield" : "off-hand weapon";
  if (obj_is_cursed(slot_object(player, shield_slot))) {
   msg("You would need to remove your %s, but cannot bear to part with it.", thing);
   /* Cancel the command */
   return;
  }
  /* Warn about dropping item in left hand */
  if (!object_is_carried(player, obj) && pack_is_full()) {
   /* Flush input */
   event_signal(EVENT_INPUT_FLUSH);
   msg("This would require removing (and dropping) your %s.", thing);
   if (!get_check("Proceed? ")) {
    /* Cancel the command */
    return;
   }
  }
 }
 /* Deal with wielding of shield or second weapon when already wielding
	 * a two handed weapon */
 if ((slot == shield_slot) && weapon
   && of_has(weapon->flags, OF_TWO_HANDED)) {
  if (obj_is_cursed(weapon)) {
   msg("You would need to remove your weapon, but cannot bear to part with it.");
   /* Cancel the command */
   return;
  }
  /* Warn about dropping item in left hand */
  if (!object_is_carried(player, obj) && pack_is_full()) {
   /* Flush input */
   event_signal(EVENT_INPUT_FLUSH);
   msg("This would require removing (and dropping) your weapon.");
   if (!get_check("Proceed? ")) {
    /* Cancel the command */
    return;
   }
  }
 }
 /* If the slot is open, wield and be done */
 if (!equip_obj) {
  inven_wield(obj, slot);
  return;
 }
 /* Usually if the slot is taken we'll just replace the item in the slot,
	 * but for rings we need to ask the user which slot they actually
	 * want to replace */
 if (tval_is_ring(obj)) {
  if (cmd_get_item(cmd, "replace", &equip_obj,
       /* Prompt */ "Replace which ring? ",
       /* Error  */ "Error in do_cmd_wield(), please report.",
       /* Filter */ tval_is_ring,
       /* Choice */ USE_EQUIP) != CMD_OK)
   return;
  /* Change slot if necessary */
  slot = equipped_item_slot(player->body, equip_obj);
 }
 /* Ask about two weapon fighting if necessary */
 for (ability = obj->known->abilities; ability; ability = ability->next) {
  if (streq(ability->name, "Two Weapon Fighting")) {
   two_weapon = true;
  }
 }
 if ((player_active_ability(player, "Two Weapon Fighting") || two_weapon) &&
     tval_is_melee_weapon(obj)) {
  if (!of_has(obj->flags, OF_TWO_HANDED) &&
   !of_has(obj->flags, OF_HAND_AND_A_HALF)) {
   if (get_check("Do you wish to wield it in your off-hand? ")) {
    slot = shield_slot;
    equip_obj = slot_object(player, slot);
    if (!equip_obj) {
     inven_wield(obj, slot);
     return;
    }
   }
  }
 }
 /* Prevent wielding into a stickied slot */
 if (!obj_can_takeoff(equip_obj)) {
  object_desc(o_name, sizeof(o_name), equip_obj, ODESC_BASE,
   player);
  msg("You cannot remove the %s you are %s.", o_name,
   equip_describe(player, slot));
  return;
 }
 /* "!t" checks for taking off */
 n = check_for_inscrip(equip_obj, "!t");
 while (n--) {
  /* Prompt */
  object_desc(o_name, sizeof(o_name), equip_obj,
   ODESC_PREFIX | ODESC_FULL, player);
  /* Forget it */
  if (!get_check(format("Really take off %s? ", o_name))) return;
 }
 /* Replacing an equipped cursed item requires special measures. */
 if (handle_stickied_removal(player, equip_obj)) {
  return;
 }
 if (combine) {
  /*
		 * At most, only want as many as can be merged into the wielded
		 * stack.
		 */
  int quantity = MIN(obj->number, equip_obj->kind->base->max_stack
   - equip_obj->number);
  struct object *wielded;
  bool dummy = false;
  /*
		 * By the tests that set combine earlier, should have at least
		 * one to merge.
		 */
  assert(quantity);
  if (object_is_carried(player, obj)) {
   wielded = gear_object_for_use(player, obj, quantity,
    false, &dummy);
   object_absorb(equip_obj, wielded);
  } else {
   /*
			 * Limit the quantity by the player's weight limit.
			 * By the prior check on the weight limit, the quantity
			 * will be at least one.
			 */
   quantity = MIN(quantity, inven_carry_num(player, obj));
   assert(quantity);
   wielded = floor_object_for_use(player, obj, quantity,
    false, &dummy);
   inven_carry(player, wielded, true, true);
  }
 } else {
  inven_takeoff(equip_obj);
  /*
		 * Need to handle possible pack overflow if wielding from the
		 * floor.  Do not want to call combine_pack() if wielding from
		 * the pack because that could leave obj dangling if it combined
		 * with the taken off item.
		 */
  if (!object_is_carried(player, obj)) {
   combine_pack(player);
   pack_overflow(equip_obj);
  }
  inven_wield(obj, slot);
 }
}
/**
 * Drop an item
 */
void do_cmd_drop(struct command *cmd)
{
 int amt;
 struct object *obj;
 /* Get arguments */
 if (cmd_get_item(cmd, "item", &obj,
   /* Prompt */ "Drop which item?",
   /* Error  */ "You have nothing to drop.",
   /* Filter */ NULL,
   /* Choice */ USE_EQUIP | USE_INVEN | USE_QUIVER) != CMD_OK)
  return;
 /* Cannot remove equipped stickied items without special measures. */
 if (handle_stickied_removal(player, obj)) {
  return;
 }
 if (cmd_get_quantity(cmd, "quantity", &amt, obj->number) != CMD_OK)
  return;
 inven_drop(obj, amt);
 player->upkeep->energy_use = z_info->move_energy;
 /* Store the action type */
 player->previous_action[0] = ACTION_MISC;
}
/**
 * ------------------------------------------------------------------------
 * Using items the traditional way
 * ------------------------------------------------------------------------
 */
enum use {
 USE_CHARGE,
 USE_VOICE,
 USE_SINGLE
};
/**
 * Use an object the right way.
 */
static void use_aux(struct command *cmd, struct object *obj, enum use use,
     int snd, bool allow_vertical)
{
 struct effect *effect = object_effect(obj);
 bool from_floor = !object_is_carried(player, obj);
 bool can_use = true;
 bool was_aware;
 bool known_aim = false;
 bool none_left = false;
 int dir = 5;
 struct trap_kind *rune = lookup_trap("glyph of warding");
 /* Get arguments */
 if (cmd_get_arg_item(cmd, "item", &obj) != CMD_OK) assert(0);
 was_aware = object_flavor_is_aware(obj);
 /* Determine whether we know an item needs to be be aimed */
 if (tval_is_horn(obj) || was_aware) {
  known_aim = true;
 }
 if (obj_needs_aim(obj)) {
  /* Unknown things with no obvious aim get a random direction */
  if (!known_aim) {
   dir = ddd[randint0(8)];
  } else if (cmd_get_target(cmd, "target", &dir, 0, allow_vertical)
       != CMD_OK) {
   return;
  }
  /* Confusion wrecks aim */
  player_confuse_dir(player, &dir, false);
 }
 /* Track the object used */
 track_object(player->upkeep, obj);
 /* Verify effect */
 assert(effect);
 /* Check voice */
 if (use == USE_VOICE) {
  int voice_cost = player_active_ability(player, "Channeling") ? 10 : 20;
  if (player->csp < voice_cost) {
   event_signal(EVENT_INPUT_FLUSH);
   msg("You are out of breath.");
   return;
  }
  msg("You sound a loud note on the horn.");
  player->csp -= voice_cost;
  player->upkeep->redraw |= PR_MANA;
 }
 /* Check for use if necessary */
 if (use == USE_CHARGE) {
  can_use = check_devices(obj);
 }
 /* Execute the effect */
 if (can_use) {
  uint16_t number;
  bool ident = false, describe = false, deduct_before, used;
  struct object *work_obj;
  struct object *first_remainder = NULL;
  char label = '\0';
  if (from_floor) {
   number = obj->number;
  } else {
   label = gear_to_label(player, obj);
   /*
			 * Show an aggregate total if the description doesn't
			 * have a charge/recharging notice specific to the
			 * stack.
			 */
   if (use != USE_VOICE) {
    number = object_pack_total(player, obj, false,
     &first_remainder);
    if (first_remainder && first_remainder->number == number) {
     first_remainder = NULL;
    }
   } else {
    number = obj->number;
   }
  }
  /* Sound and/or message */
  if (obj->kind->effect_msg) {
   msgt(snd, "%s", obj->kind->effect_msg);
  } else {
   /* Make a noise! */
   sound(snd);
  }
  /*
		 * If the object is on the floor, tentatively deduct the
		 * amount used - the effect could leave the object inaccessible
		 * making it difficult to do after a successful use.  For the
		 * same reason, get a copy of the object to use for propagating
		 * knowledge and messaging (also do so for items in the pack
		 * to keep later logic simpler).  Don't do the deduction for
		 * an object in the pack because the rearrangement of the
		 * pack, if using a stack of one single use item, can distract
		 * the player, see
		 * https://github.com/angband/angband/issues/5543 .
		 * If effects change so that the originating object can be
		 * destroyed even if in the pack, the deduction would have to
		 * be done here if the item is in the pack as well.
		 */
  if (from_floor) {
   if (use == USE_SINGLE) {
    deduct_before = true;
    work_obj = floor_object_for_use(player, obj, 1,
     false, &none_left);
   } else {
    if (use == USE_CHARGE) {
     deduct_before = true;
     /* Use a single charge */
     obj->pval--;
     obj->used++;
    } else {
     deduct_before = false;
    }
    work_obj = object_new();
    object_copy(work_obj, obj);
    work_obj->oidx = 0;
    if (obj->known) {
     work_obj->known = object_new();
     object_copy(work_obj->known,
      obj->known);
     work_obj->known->oidx = 0;
    }
   }
  } else {
   deduct_before = false;
   work_obj = object_new();
   object_copy(work_obj, obj);
   work_obj->oidx = 0;
   if (obj->known) {
    work_obj->known = object_new();
    object_copy(work_obj->known, obj->known);
    work_obj->known->oidx = 0;
   }
  }
  /* Do effect; use original not copy (proj. effect handling) */
  target_fix();
  used = effect_do(effect,
       source_player(),
       obj,
       &ident,
       was_aware,
       dir,
       cmd);
  target_release();
  /* Using a horn stops singing.  Eating or quaffing do not. */
  if (use == USE_VOICE) {
   player_change_song(player, NULL, false);
  }
  if (!used) {
   if (deduct_before) {
    /* Restore the tentative deduction. */
    if (use == USE_SINGLE) {
     /*
					 * Drop/stash copy to simplify
					 * subsequent logic.
					 */
     struct object *wcopy = object_new();
     object_copy(wcopy, work_obj);
     if (from_floor) {
      drop_near(cave, &wcopy, 0,
       player->grid, false,
       true);
     } else {
      inven_carry(player, wcopy,
       true, false);
     }
    } else if (use == USE_CHARGE) {
     obj->pval++;
     obj->used--;
    }
   }
   /*
			 * Quit if the item wasn't used and no knowledge was
			 * gained
			 */
   if (was_aware || !ident) {
    if (work_obj->known) {
     object_delete(player->cave, NULL, &work_obj->known);
    }
    object_delete(cave, player->cave, &work_obj);
    /*
				 * Selection of effect's target may have
				 * triggered an update to windows while the
				 * tentative deduction was in effect; signal
				 * another update to remedy that.
				 */
    if (deduct_before) {
     assert(from_floor);
     player->upkeep->redraw |= (PR_OBJECT);
    }
    return;
   }
  }
  /* Increase knowledge */
  if (!was_aware && ident) {
   object_flavor_aware(player, work_obj);
   describe = true;
  } else {
   object_flavor_tried(work_obj);
  }
  /*
		 * Use up, deduct charge, or apply timeout if it wasn't
		 * done before.  For charges or timeouts, also have to change
		 * work_obj since it is used for messaging (for single use
		 * items, ODESC_ALTNUM means that the work_obj's number doesn't
		 * need to be adjusted).
		 */
  if (used && !deduct_before) {
   assert(!from_floor);
   if (use == USE_CHARGE) {
    obj->pval--;
    obj->used++;
    work_obj->pval--;
    work_obj->used++;
   } else if (use == USE_SINGLE) {
    struct object *used_obj = gear_object_for_use(
     player, obj, 1, false, &none_left);
    if (used_obj->known) {
     object_delete(cave, player->cave,
      &used_obj->known);
    }
    object_delete(cave, player->cave, &used_obj);
   }
  }
  if (describe) {
   /*
			 * Describe what's left of single use items or newly
			 * identified items of all kinds.
			 */
   char name[80];
   object_desc(name, sizeof(name), work_obj,
    ODESC_PREFIX | ODESC_FULL | ODESC_ALTNUM |
    ((number + ((used && use == USE_SINGLE) ?
    -1 : 0)) << 16), player);
   if (from_floor) {
    /* Print a message */
    msg("You see %s.", name);
   } else if (first_remainder) {
    label = gear_to_label(player, first_remainder);
    msg("You have %s (1st %c).", name, label);
   } else {
    msg("You have %s (%c).", name, label);
   }
  } else if (used && use == USE_CHARGE) {
   /* Describe charges */
   if (from_floor) {
    floor_item_charges(work_obj);
   } else {
    inven_item_charges(work_obj);
   }
  }
  /* Clean up created copy. */
  if (work_obj->known)
   object_delete(player->cave, NULL, &work_obj->known);
  object_delete(cave, player->cave, &work_obj);
 }
 /* Use the turn */
 player->upkeep->energy_use = z_info->move_energy;
 /* Store the action type */
 player->previous_action[0] = ACTION_MISC;
 /* Autoinscribe if we are guaranteed to still have any */
 if (!none_left && !from_floor)
  apply_autoinscription(player, obj);
 /* Mark as tried and redisplay */
 player->upkeep->notice |= (PN_COMBINE);
 player->upkeep->redraw |= (PR_INVEN | PR_EQUIP | PR_OBJECT);
 /* Hack to make Glyph of Warding work properly */
 if (square_trap_specific(cave, player->grid, rune->tidx)) {
  /* Push objects off the grid */
  if (square_object(cave, player->grid))
   push_object(player->grid);
 }
}
/**
 * Use a staff 
 */
void do_cmd_use_staff(struct command *cmd)
{
 struct object *obj;
 /* Get an item */
 if (cmd_get_item(cmd, "item", &obj,
   "Use which staff? ",
   "You have no staves to use.",
   tval_is_staff,
   USE_INVEN | USE_FLOOR | SHOW_FAIL) != CMD_OK) return;
 use_aux(cmd, obj, USE_CHARGE, MSG_USE_STAFF, false);
}
/**
 * Blow a horn 
 */
void do_cmd_blow_horn(struct command *cmd)
{
 struct object *obj;
 /* Get an item */
 if (cmd_get_item(cmd, "item", &obj,
   "Blow which horn? ",
   "You have no horns to blow.",
   tval_is_horn,
   USE_INVEN | USE_FLOOR | SHOW_FAIL) != CMD_OK) return;
 use_aux(cmd, obj, USE_VOICE, MSG_ZAP_ROD, obj_allows_vertical_aim(obj));
}
/**
 * Eat some food 
 */
void do_cmd_eat_food(struct command *cmd)
{
 struct object *obj;
 /* Get an item */
 if (cmd_get_item(cmd, "item", &obj,
   "Eat which food? ",
   "You have no food to eat.",
   tval_is_edible,
   USE_INVEN | USE_FLOOR) != CMD_OK) return;
 /* If gorged, you cannot eat food */
 if ((player->timed[TMD_FOOD] >= PY_FOOD_MAX) && obj_nourishes(obj)) {
  msg("You are too full to eat it.");
  return;
 }
 use_aux(cmd, obj, USE_SINGLE, MSG_EAT, false);
}
/**
 * Quaff a potion 
 */
void do_cmd_quaff_potion(struct command *cmd)
{
 struct object *obj;
 /* Get an item */
 if (cmd_get_item(cmd, "item", &obj,
   "Quaff which potion? ",
   "You have no potions from which to quaff.",
   tval_is_potion,
   USE_INVEN | USE_FLOOR) != CMD_OK) return;
 /* If gorged, you cannot quaff nourishing potions */
 if ((player->timed[TMD_FOOD] >= PY_FOOD_MAX) && obj_nourishes(obj)) {
  msg("You are too full to drink it.");
  return;
 }
 use_aux(cmd, obj, USE_SINGLE, MSG_QUAFF, false);
}
/**
 * Use any usable item
 */
void do_cmd_use(struct command *cmd)
{
 struct object *obj;
 /* Get an item */
 if (cmd_get_item(cmd, "item", &obj,
   "Use which item? ",
   "You have no items to use.",
   obj_is_useable,
   USE_EQUIP | USE_INVEN | USE_QUIVER | USE_FLOOR | SHOW_FAIL) != CMD_OK)
  return;
 if (tval_is_ammo(obj)) do_cmd_fire(cmd);
 else if (tval_is_potion(obj)) do_cmd_quaff_potion(cmd);
 else if (tval_is_edible(obj)) do_cmd_eat_food(cmd);
 else if (tval_is_horn(obj)) do_cmd_blow_horn(cmd);
 else if (tval_is_staff(obj)) do_cmd_use_staff(cmd);
 else if (obj_can_refuel(obj)) do_cmd_refuel(cmd);
 else if (tval_is_wearable(obj)) do_cmd_wield(cmd);
 else
  msg("The item cannot be used at the moment");
}
/**
 * ------------------------------------------------------------------------
 * Refuelling
 * ------------------------------------------------------------------------
 */
static void refill_lamp(struct object *lamp, struct object *obj)
{
 int timeout = lamp->timeout + (obj->timeout ? obj->timeout : obj->pval);
 /* Message */
 if (timeout > z_info->fuel_lamp) {
  if (tval_is_light(obj)) {
   if (!get_check("Refueling from this lantern will waste some fuel. Proceed? ")) {
    return;
   }
  } else if (!get_check("Refueling from this flask will waste some fuel. Proceed? ")) {
   return;
  }
 } else {
  msg("You fuel your lamp.");
 }
 /* Refuel */
 lamp->timeout = timeout;
 /* Comment */
 if (lamp->timeout >= z_info->fuel_lamp) {
  lamp->timeout = z_info->fuel_lamp;
  msg("Your lamp is full.");
 }
 /* Refilled from a lantern */
 if (of_has(obj->flags, OF_TAKES_FUEL)) {
  /* Unstack if necessary */
  if (obj->number > 1) {
   /* Obtain a local object, split */
   struct object *used = object_split(obj, 1);
   /* Remove fuel */
   used->timeout = 0;
   /* Carry or drop */
   if (object_is_carried(player, obj) && inven_carry_okay(used))
    inven_carry(player, used, true, true);
   else
    drop_near(cave, &used, 0, player->grid, false, true);
  } else {
   /* Empty a single lantern */
   obj->timeout = 0;
  }
  /* Combine the pack (later) */
  player->upkeep->notice |= (PN_COMBINE);
  /* Redraw stuff */
  player->upkeep->redraw |= (PR_INVEN);
 } else { /* Refilled from a flask */
  struct object *used;
  bool none_left = false;
  /* Decrease the item from the pack or the floor */
  if (object_is_carried(player, obj)) {
   used = gear_object_for_use(player, obj, 1, true, &none_left);
  } else {
   used = floor_object_for_use(player, obj, 1, true, &none_left);
  }
  if (used->known)
   object_delete(player->cave, NULL, &used->known);
  object_delete(cave, player->cave, &used);
 }
 /* Recalculate torch */
 player->upkeep->update |= (PU_TORCH);
 /* Redraw stuff */
 player->upkeep->redraw |= (PR_EQUIP);
}
static void combine_torches(struct object *torch, struct object *obj)
{
 struct object *used;
 bool none_left = false;
 int timeout = torch->timeout + obj->timeout + 5;
 /* Message */
 if ((timeout > z_info->fuel_torch) && !get_check("Refueling from this torch will waste some fuel. Proceed? ")) {
  return;
 }
 /* Refuel */
 torch->timeout = timeout;
 /* Message */
 msg("You combine the torches.");
 /* Comment */
 if (torch->timeout >= z_info->fuel_torch) {
  torch->timeout = z_info->fuel_torch;
  msg("Your torch is fully fueled.");
 } else {
  msg("Your torch glows more brightly.");
 }
 /* Decrease the item from the pack or the floor */
 if (object_is_carried(player, obj)) {
  used = gear_object_for_use(player, obj, 1, true, &none_left);
 } else {
  used = floor_object_for_use(player, obj, 1, true, &none_left);
 }
 if (used->known)
  object_delete(player->cave, NULL, &used->known);
 object_delete(cave, player->cave, &used);
 /* Combine the pack (later) */
 player->upkeep->notice |= (PN_COMBINE);
 /* Recalculate torch */
 player->upkeep->update |= (PU_TORCH);
 /* Redraw stuff */
 player->upkeep->redraw |= (PR_EQUIP | PR_INVEN);
}
void do_cmd_refuel(struct command *cmd)
{
 struct object *light = equipped_item_by_slot_name(player, "light");
 struct object *obj;
 /* Check what we're wielding. */
 if (!light || !tval_is_light(light)) {
  msg("You are not wielding a light.");
  return;
 } else if (of_has(light->flags, OF_NO_FUEL)) {
  msg("Your light cannot be refilled.");
  return;
 }
 /* Get an item */
 if (cmd_get_item(cmd, "item", &obj,
   "Refuel with which fuel source? ",
   "You have nothing you can refuel with.",
   obj_can_refuel,
   USE_INVEN | USE_FLOOR | USE_QUIVER) != CMD_OK) return;
 if (of_has(light->flags, OF_TAKES_FUEL)) {
  refill_lamp(light, obj);
 } else if (of_has(light->flags, OF_BURNS_OUT)) {
  combine_torches(light, obj);
 } else {
  return;
 }
 /* Take a turn */
 player->upkeep->energy_use = z_info->move_energy;
 /* Store the action type */
 player->previous_action[0] = ACTION_MISC;
}
/*
 * Destroy an item
 */
void do_cmd_destroy(struct command *cmd)
{
 int amt;
 struct object *obj;
 struct object *weapon = equipped_item_by_slot_name(player, "weapon");
 /* Special case for prising Silmarils from the Iron Crown of Morgoth */
 obj = square_object(cave, player->grid);
 if (obj && (obj->artifact == lookup_artifact_name("of Morgoth")) &&
  obj->pval) {
  /* No weapon */
  if (!weapon) {
   msg("To prise a Silmaril from the crown, you would need to wield a weapon.");
  } else {
   /* Wielding a weapon */
   if (get_check("Will you try to prise a Silmaril from the Iron Crown? ")) {
    prise_silmaril(player);
    /* Take a turn */
    player->upkeep->energy_use = z_info->move_energy;
    /* Store the action type */
    player->previous_action[0] = ACTION_MISC;
    return;
   }
  }
 }
 /* Get an item */
 if (cmd_get_item(cmd, "item", &obj,
   "Destroy which item? ",
   "You have nothing to destroy.",
   NULL,
   USE_INVEN | USE_FLOOR) != CMD_OK) return;
 /* Special case for Iron Crown of Morgoth, if it has Silmarils left */
 if ((obj->artifact == lookup_artifact_name("of Morgoth")) && obj->pval) {
  if (object_is_carried(player, obj)) {
   msg("You would have to put it down first.");
  } else {
   /* No weapon */
   if (!weapon) {
    msg("To prise a Silmaril from the crown, you would need to wield a weapon.");
   } else {
    msg("You decide to try to prise out a Silmaril after all.");
    prise_silmaril(player);
    /* Take a turn */
    player->upkeep->energy_use = z_info->move_energy;
    /* Store the action type */
    player->previous_action[0] = ACTION_MISC;
   }
  }
  return;
 }
 if (cmd_get_quantity(cmd, "quantity", &amt, obj->number) != CMD_OK)
  return;
 if (object_is_carried(player, obj)) {
  if (!inven_destroy(obj, amt)) return;
 } else {
  if (!floor_destroy(obj, amt)) return;
 }
 /* Take a turn */
 player->upkeep->energy_use = z_info->move_energy;
 /* Store the action type */
 player->previous_action[0] = ACTION_MISC;
}
/**
 * \file cmd-pickup.c
 * \brief Pickup code
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke,
 * Copyright (c) 2007 Leon Marrick
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Find the specified object in the inventory (not equipment)
 */
static const struct object *find_stack_object_in_inventory(const struct object *obj, const struct object *start)
{
 const struct object *gear_obj;
 for (gear_obj = (start) ? start : player->gear; gear_obj; gear_obj = gear_obj->next) {
  if (!object_is_equipped(player->body, gear_obj) &&
    object_similar(gear_obj, obj, OSTACK_PACK)) {
   /* We found the object */
   return gear_obj;
  }
 }
 return NULL;
}
/**
 * Determine if an object can be picked up automatically and return the
 * number to pick up.
 */
static int auto_pickup_okay(const struct object *obj)
{
        /*
	 * Use the following inscriptions to guide pickup with the last one
	 * borrowed from Unangband:
	 *
	 * !g     don't pickup
	 * =g     pickup
	 * =g<n>  (i.e. =g5) pick up if have less than n
	 *
	 * !g takes precedence over any of the others if an object is
	 * inscribed with it and any of the others.  =g with no value takes
	 * precedence over =g<n> if an object is inscribed with both.  In
	 * general, inscriptions on the item on the floor are examined first
	 * and the ones on a matching item in the pack will only come into
	 * consideration if those on the item on the floor do not force or
	 * reject pickup.  When examining inscriptions in the pack, only
	 * use those on the first stack.
	 *
	 * The player option to always pick up overrides all of those
	 * inscriptions.  The player option to pickup if in the inventory
	 * honors those inscriptions.
	 */
 int num = inven_carry_num(player, obj);
 unsigned obj_has_auto, obj_has_maxauto;
 int obj_maxauto;
 if (!num) return 0;
 if (OPT(player, pickup_always)) return num;
 if (obj->notice & OBJ_NOTICE_PICKUP) return num;
 if (check_for_inscrip(obj, "!g")) return 0;
 obj_has_auto = check_for_inscrip(obj, "=g");
 obj_maxauto = INT_MAX;
 obj_has_maxauto = check_for_inscrip_with_int(obj, "=g", &obj_maxauto);
 if (obj_has_auto > obj_has_maxauto) return num;
 if (OPT(player, pickup_inven) || obj_has_maxauto) {
  const struct object *gear_obj = find_stack_object_in_inventory(obj, NULL);
  if (!gear_obj) {
   if (obj_has_maxauto) {
    return (num < obj_maxauto) ? num : obj_maxauto;
   }
   return 0;
  }
  if (!check_for_inscrip(gear_obj, "!g")) {
   unsigned int gear_has_auto = check_for_inscrip(gear_obj, "=g");
   unsigned int gear_has_maxauto;
   int gear_maxauto;
   gear_has_maxauto = check_for_inscrip_with_int(gear_obj, "=g", &gear_maxauto);
   if (gear_has_auto > gear_has_maxauto) {
    return num;
   }
   if (obj_has_maxauto || gear_has_maxauto) {
    /* Use the pack inscription if have both. */
    int max_num = (gear_has_maxauto) ?
     gear_maxauto : obj_maxauto;
    /* Determine the total number in the pack. */
    int pack_num = gear_obj->number;
    while (1) {
     if (!gear_obj->next) {
      break;
     }
     gear_obj = find_stack_object_in_inventory(obj, gear_obj->next);
     if (!gear_obj) {
      break;
     }
     pack_num += gear_obj->number;
    }
    if (pack_num >= max_num) {
     return 0;
    }
    return (num < max_num - pack_num) ?
     num : max_num - pack_num;
   }
   return num;
  }
 }
 return 0;
}
/**
 * Move an object from a floor pile to the player's gear, checking first
 * whether partial pickup is needed
 */
static void player_pickup_aux(struct player *p, struct object *obj,
         int auto_max, bool domsg)
{
 int max = inven_carry_num(p, obj);
 /* Remember if this is auto-pickup. */
 bool autopick = (obj->notice & OBJ_NOTICE_PICKUP);
 /* Confirm at least some of the object can be picked up */
 if (max == 0)
  quit_fmt("Failed pickup of %s", obj->kind->name);
 /* Set ignore status */
 p->upkeep->notice |= PN_IGNORE;
 /* Allow auto-pickup to limit the number if it wants to */
 if (auto_max && max > auto_max) {
  max = auto_max;
 }
 /* Carry the object, prompting for number if necessary */
 if (max == obj->number) {
  if (obj->known) {
   square_excise_object(p->cave, p->grid, obj->known);
   delist_object(p->cave, obj->known);
  }
  square_excise_object(cave, p->grid, obj);
  delist_object(cave, obj);
  inven_carry(p, obj, true, domsg);
 } else {
  int num;
  bool dummy;
  struct object *picked_up;
  if (auto_max)
   num = auto_max;
  else
   num = get_quantity(NULL, max);
  if (!num) return;
  picked_up = floor_object_for_use(p, obj, num, false, &dummy);
  inven_carry(p, picked_up, true, domsg);
 }
 /* If it's auto-pickup of thrown/fired things we're done */
 if (autopick) return;
 /* Store the action type */
 p->previous_action[0] = ACTION_MISC;
 /* Take a turn */
 p->upkeep->energy_use = z_info->move_energy;
}
/**
 * Pick up objects and treasure on the floor.  -LM-
 *
 * Scan the list of objects in that floor grid. Pick up gold automatically.
 * Pick up objects automatically until backpack space is full if
 * auto-pickup option is on, otherwise, store objects on
 * floor in an array, and tally both how many there are and can be picked up.
 *
 * If not picking up anything, indicate objects on the floor.  Do the same
 * thing if we don't have room for anything.
 *
 * Pick up multiple objects using Tim Baker's menu system.   Recursively
 * call this function (forcing menus for any number of objects) until
 * objects are gone, backpack is full, or player is satisfied.
 *
 * We keep track of number of objects picked up to calculate time spent.
 * This tally is incremented even for automatic pickup, so we are careful
 * (in "dungeon.c" and elsewhere) to handle pickup as either a separate
 * automated move or a no-cost part of the stay still or 'g'et command.
 *
 * Note the lack of chance for the character to be disturbed by unmarked
 * objects.  They are truly "unknown".
 *
 * \param obj is the object to pick up.
 * \param menu is whether to present a menu to the player
 */
void player_pickup_item(struct player *p, struct object *obj, bool menu)
{
 struct object *current = NULL;
 int floor_max = z_info->floor_size + 1;
 struct object **floor_list = mem_zalloc(floor_max * sizeof(*floor_list));
 int floor_num = 0;
 int i;
 int can_pickup = 0;
 bool call_function_again = false;
 bool domsg = true;
 /* Always know what's on the floor */
 square_know_pile(cave, p->grid);
 /* Nothing else to pick up -- return */
 if (!square_object(cave, p->grid)) {
  mem_free(floor_list);
  return;
 }
 /* We're given an object - pick it up */
 if (obj) {
  mem_free(floor_list);
  if (inven_carry_num(p, obj) > 0) {
   player_pickup_aux(p, obj, 0, domsg);
  }
  return;
 }
 /* Tally objects that can be at least partially picked up.*/
 floor_num = scan_floor(floor_list, floor_max, p, OFLOOR_VISIBLE, NULL);
 for (i = 0; i < floor_num; i++)
     if (inven_carry_num(p, floor_list[i]) > 0)
   can_pickup++;
 if (!can_pickup) {
     event_signal(EVENT_SEEFLOOR);
  mem_free(floor_list);
     return;
 }
 /* Use a menu interface for multiple objects, or pickup single objects */
 if (!menu && !current) {
  if (floor_num > 1)
   menu = true;
  else
   current = floor_list[0];
 }
 /* Display a list if requested. */
 if (menu && !current) {
  const char *q, *s;
  struct object *obj_local = NULL;
  /* Get an object or exit. */
  q = "Get which item?";
  s = "You see nothing there.";
  if (!get_item(&obj_local, q, s, CMD_PICKUP, inven_carry_okay, USE_FLOOR)) {
   mem_free(floor_list);
   return;
  }
  current = obj_local;
  call_function_again = true;
  /* With a list, we do not need explicit pickup messages */
  domsg = true;
 }
 /* Pick up object, if legal */
 if (current) {
  /* Pick up the object */
  player_pickup_aux(p, current, 0, domsg);
 }
 /*
	 * If requested, call this function recursively.  Count objects picked
	 * up.  Force the display of a menu in all cases.
	 */
 if (call_function_again)
  player_pickup_item(p, NULL, true);
 mem_free(floor_list);
}
/**
 * Pick up everything on the floor that requires no player action
 */
static bool do_autopickup(struct player *p)
{
 struct object *obj, *next;
 bool picked_up = false;
 /* Nothing to pick up -- return */
 if (!square_object(cave, p->grid))
  return false;
 /* Scan the remaining objects */
 obj = square_object(cave, p->grid);
 while (obj) {
  next = obj->next;
  /* Ignore all hidden objects and non-objects */
  if (!ignore_item_ok(p, obj)) {
   int auto_num;
   /* Hack -- disturb */
   disturb(p, false);
   /* Automatically pick up items into the backpack */
   auto_num = auto_pickup_okay(obj);
   if (auto_num) {
    /* Pick up the object (as much as possible) with message */
    player_pickup_aux(p, obj, auto_num, true);
    picked_up = true;
   }
  }
  obj = next;
 }
 return picked_up;
}
/**
 * Pick up objects at the player's request
 */
void do_cmd_pickup(struct command *cmd)
{
 struct object *obj = NULL;
 /* See if we have an item already */
 (void) cmd_get_arg_item(cmd, "item", &obj);
 /* Pick up floor objects with a menu for multiple objects */
 player_pickup_item(player, obj, false);
 /* Redraw the object list using the upkeep flag so that the update can be
	 * somewhat coalesced. Use event_signal(EVENT_ITEMLIST to force update. */
 player->upkeep->redraw |= (PR_ITEMLIST);
}
/**
 * Pick up or look at objects on a square when the player steps onto it
 */
void do_cmd_autopickup(struct command *cmd)
{
 /* Get the obvious things */
 if (do_autopickup(player)) {
  /* Look at or feel what's left */
  event_signal(EVENT_SEEFLOOR);
 }
 /* Redraw the object list using the upkeep flag so that the update can be
	 * somewhat coalesced. Use event_signal(EVENT_ITEMLIST to force update. */
 player->upkeep->redraw |= (PR_ITEMLIST);
}
/**
 * \file cmd-spoil.c
 * \brief Shims between the Angband 4 command system and spoiler generation
 *
 * Copyright (c) 2021 Eric Branlund
 *
 * This work is free software; you can redistribute it and/or modify it under
 * the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Generate artifact spoilers (CMD_SPOIL_ARTIFACT).  Takes no arguments
 * from cmd.
 */
void do_cmd_spoil_artifact(struct command *cmd)
{
 spoil_artifact("artifact.spo");
}
/**
 * Generate monster spoilers (CMD_SPOIL_MON).  Takes no arguments from cmd.
 */
void do_cmd_spoil_monster(struct command *cmd)
{
 spoil_mon_info("mon-info.spo");
}
/**
 * Generate brief monster spoilers (CMD_SPOIL_MON_BRIEF).  Takes no arguments
 * from cmd.
 */
void do_cmd_spoil_monster_brief(struct command *cmd)
{
 spoil_mon_desc("mon-desc.spo");
}
/**
 * Generate object spoilers (CMD_SPOIL_OBJ).  Takes no arguments from cmd.
 */
void do_cmd_spoil_obj(struct command *cmd)
{
 spoil_obj_desc("obj-desc.spo");
}
/**
 * \file cmd-wizard.c
 * \brief Implements debug commands in Angband 4's command system.
 *
 * Copyright (c) 2021 Eric Branlund
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/*
 * Used by do_cmd_wiz_edit_player_*() functions to track the state of the
 * editing process.
 */
enum EditPlayerState {
 EDIT_PLAYER_UNKNOWN, EDIT_PLAYER_STARTED, EDIT_PLAYER_BREAK
} edit_player_state = EDIT_PLAYER_UNKNOWN;
/**
 * Extract a decimal integer from a string while ensuring that only the
 * decimal value and white space are present in the string.
 * \param s is the string to parse.
 * \param val is dereferenced and set to the extracted value.
 * \return true if val was dereferenced and set; false if the extraction
 * failed
 */
static bool get_int_from_string(const char *s, int *val)
{
 char *endptr;
 long lval = strtol(s, &endptr, 10);
 /*
	 * Reject INT_MIN and INT_MAX so, for systems where
	 * sizeof(long) == sizeof(int), it isn't necessary to check errno to
	 * see if the value in the string was out of range.
	 */
 if (s[0] == '\0' ||
   (*endptr != '\0' && !contains_only_spaces(endptr)) ||
   lval <= INT_MIN || lval >= INT_MAX) {
  return false;
 }
 *val = (int)lval;
 return true;
}
/**
 * Extract a long decimal integer from a string while ensuring that only the
 * decimal value and white space are present in the string.
 * \param s is the string to parse.
 * \param val is dereferenced and set to the extracted value.
 * \return true if val was dereferenced and set; false if the extraction
 * failed
 */
static bool get_long_from_string(const char *s, long *val)
{
 char *endptr;
 long lval = strtol(s, &endptr, 10);
 /*
	 * Reject LONG_MIN and LONG_MAX so it isn't necessary to check errno
	 * to see if the value in the string was out of range.
	 */
 if (s[0] == '\0' ||
   (*endptr != '\0' && !contains_only_spaces(endptr)) ||
   lval <= LONG_MIN || lval >= LONG_MAX) {
  return false;
 }
 *val = lval;
 return true;
}
/**
 * Output part of a bitflag set in binary format.
 */
static void prt_binary(const bitflag *flags, int offset, int row, int col,
 wchar_t ch, int num)
{
 int flag;
 /* Scan the flags. */
 for (flag = FLAG_START + offset; flag < FLAG_START + offset + num; flag++) {
  if (of_has(flags, flag)) {
   Term_putch(col++, row, COLOUR_BLUE, ch);
  } else {
   Term_putch(col++, row, COLOUR_WHITE, L'-');
  }
 }
}
/**
 * Create an instance of an artifact.
 *
 * \param art The artifact to instantiate.
 * \return An object that represents the artifact.
 */
static struct object *wiz_create_object_from_artifact(const struct artifact *art)
{
 struct object_kind *kind;
 struct object *obj;
 /* Ignore "empty" artifacts */
 if (!art->name) return NULL;
 /* Acquire the "kind" index */
 kind = lookup_kind(art->tval, art->sval);
 if (!kind) return NULL;
 /* Create the artifact */
 obj = object_new();
 object_prep(obj, kind, art->level, RANDOMISE);
 obj->artifact = art;
 copy_artifact_data(obj, art);
 mark_artifact_created(art, true);
 return obj;
}
/**
 * Create an instance of an object of a given kind.
 *
 * \param kind The base type of object to instantiate.
 * \return An object of the provided object type.
 */
static struct object *wiz_create_object_from_kind(struct object_kind *kind)
{
 struct object *obj;
 obj = object_new();
 object_prep(obj, kind, player->depth, RANDOMISE);
 /* Apply magic (no messages, no artifacts) */
 apply_magic(obj, player->depth, false, false, false);
 return obj;
}
/**
 * Display an item's properties.
 */
static void wiz_display_item(const struct object *obj, bool all,
  const struct player *p)
{
 static const char *flagLabels[] = {
/**
 * \file list-object-flags.h
 * \brief object flags for all objects
 *
 * Changing flag order will break savefiles. Flags
 * below start from 1 on line 17, so a flag's sequence number is its line
 * number minus 16.
 *
 * Each sustain flag (SUST_*) has a matching stat in src/list-stats.h,
 * which should be at the same index in that file as the sustain in this file.
 *
 * The second argument to OF is the label used in the debugging commands
 * object flag display.  At most the first five characters are used.
 *
 * Flag properties are defined in lib/gamedata/object_property.txt
 */
" sStr",
" sDex",
" sCon",
" sGra",
"pFear",
"pBlnd",
"pConf",
"pStun",
"pHall",
"S.Dig",
"Regen",
"S.Inv",
"FrAct",
"Rad",
"Light",
"Speed",
"Sharp",
"SHARP",
"Vamp",
"BuOut",
"TFuel",
"NFuel",
"Cowrd",
"Hungr",
"Darkn",
"Dangr",
"Haunt",
"Aggrv",
"Curse",
" Dig1",
" Dig2",
"Throw",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",

 };
 int j = 0, i, k, nflg;
 bitflag f[OF_SIZE];
 char buf[256];
 bool *labelsDone;
 /* Extract the flags. */
 if (all) {
  object_flags(obj, f);
 }
 /* Clear screen. */
 Term_clear();
 /* Describe fully */
 object_desc(buf, sizeof(buf), obj,
  ODESC_PREFIX | ODESC_FULL | ODESC_SPOIL, p);
 prt(buf, 2, j);
 prt(format("combat = (%+d,%dd%d) [%+d,%dd%d]",
  obj->att, obj->ds, obj->dd, obj->evn, obj->ps, obj->pd),
  4, j);
 prt(format("kind = %-5lu  tval = %-5d  sval = %-5d  wgt = %-3d     timeout = %-d",
  (unsigned long)obj->kind->kidx, obj->tval, obj->sval,
  obj->weight, obj->timeout), 5, j);
 prt(format("number = %-3d  pval = %-5d  name1 = %-4ld  egoidx = %-4ld  cost = %ld",
  obj->number, obj->pval,
  obj->artifact ? (long)obj->artifact->aidx : 0L,
  obj->ego ? (long)obj->ego->eidx : -1L,
  (long)object_value(obj)), 6, j);
 nflg = MIN(OF_MAX - FLAG_START, 80);
 /* Set up header line. */
 if (nflg >= 6) {
  buf[0] = '+';
  k = (nflg - 6) / 2;
  for (i = 1; i < k; ++i) {
   buf[i] = '-';
  }
 } else {
  k = 0;
 }
 buf[k] = 'F';
 buf[k + 1] = 'L';
 buf[k + 2] = 'A';
 buf[k + 3] = 'G';
 buf[k + 4] = 'S';
 for (i = k + 5; i < nflg - 1; ++i) {
  buf[i] = '-';
 }
 if (nflg >= 7) {
  buf[nflg - 1] = '+';
  buf[nflg] = '\0';
 } else {
  buf[k + 5] = '\0';
 }
 prt(buf, 16, j);
 /* Display first five letters of flag labels vertically. */
 labelsDone = mem_zalloc(nflg * sizeof(*labelsDone));
 for (k = 0; k < 5; ++k) {
  for (i = 0; i < nflg; ++i) {
   if (labelsDone[i]) {
    buf[i] = ' ';
   } else if (flagLabels[i][k] == '\0') {
    labelsDone[i] = true;
    buf[i] = ' ';
   } else {
    buf[i] = flagLabels[i][k];
   }
  }
  buf[nflg] = '\0';
  prt(buf, 17 + k, j);
 }
 mem_free(labelsDone);
 prt_binary(f, 0, 22, j, L'*', nflg);
}
/**
 * Drop an object near the player in a manner suitable for debugging.
 *
 * \param obj The object to drop.
 */
static void wiz_drop_object(struct object *obj)
{
 if (obj == NULL) return;
 /* Mark as cheat and where it was created */
 obj->origin = ORIGIN_CHEAT;
 obj->origin_depth = convert_depth_to_origin(player->depth);
 /* Drop the object from heaven. */
 drop_near(cave, &obj, 0, player->grid, true, true);
}
/**
 * Redraw the visible portion of the map to accentuate some chosen
 * characteristic.
 *
 * \param c is the chunk to use as the source for data.
 * \param p is the player to use.
 * \param func is a pointer to a function which will set the value pointed
 * to by its fourth argument to whether or not to display the given grid and,
 * if displaying that grid, set its fifth argument to the color to use for the
 * grid.
 * \param closure is passed as the second argument to func.
 *
 * Assumes the active terminal displays a map.
 */
static void wiz_hack_map(struct chunk *c, struct player *p,
 void (*func)(struct chunk *, void *, struct loc, bool *, uint8_t *),
 void *closure)
{
 int y;
 for (y = Term->offset_y; y < Term->offset_y + SCREEN_HGT; y++) {
  int x;
  for (x = Term->offset_x; x < Term->offset_x + SCREEN_WID; x++) {
   struct loc grid = loc(x, y);
   bool show;
   uint8_t color;
   if (!square_in_bounds_fully(c, grid)) continue;
   (*func)(c, closure, grid, &show, &color);
   if (!show) continue;
   if (loc_eq(grid, p->grid)) {
    print_rel(L'@', color, y, x);
   } else if (square_ispassable(c, grid)) {
    print_rel(L'*', color, y, x);
   } else {
    print_rel(L'#', color, y, x);
   }
  }
 }
}
/**
 * Update the queued command object for do_cmd_wiz_play_item() to reflect
 * that the item has changed.
 *
 * Hack:  this assumes that there's only one command queued.
 */
static void wiz_play_item_notify_changed(void)
{
 struct command *cmd = cmdq_peek();
 if (cmd) {
  assert(cmd->code == CMD_WIZ_PLAY_ITEM);
  cmd_set_arg_choice(cmd, "changed", 1);
 }
}
/**
 * Handle the typical updates needed to upkeep flags after playing with an item.
 */
static void wiz_play_item_standard_upkeep(struct player *p, struct object *obj)
{
 if (object_is_carried(p, obj)) {
  p->upkeep->update |= (PU_BONUS | PU_INVEN);
  p->upkeep->notice |= (PN_COMBINE);
  p->upkeep->redraw |= (PR_INVEN | PR_EQUIP);
 } else {
  p->upkeep->redraw |= (PR_ITEMLIST);
 }
}
/**
 * Acquire some good or great objects and drop them near the player
 * (CMD_WIZ_ACQUIRE).  Can take the number of objects to acquire from the
 * argument, "quantity", of type number in cmd.  Can take whether to get good
 * or great objects from the argument, "choice", of type choice in cmd:  a
 * non-zero value for that will select great objects.
 */
void do_cmd_wiz_acquire(struct command *cmd)
{
 int n, great;
 struct object *nice_obj;
 if (cmd_get_arg_choice(cmd, "choice", &great) != CMD_OK) {
  great = (get_check("Acquire great objects? ")) ? 1 : 0;
  cmd_set_arg_choice(cmd, "choice", great);
 }
 if (cmd_get_arg_number(cmd, "quantity", &n) != CMD_OK) {
  n = get_quantity((great) ?
   "How many great objects? " : "How many good objects? ",
   40);
  if (n < 1) return;
  cmd_set_arg_number(cmd, "quantity", n);
 }
 /* Acquirement */
 while (n--) {
  /* Make a good (or great) object (if possible) */
  nice_obj = make_object(cave, player->depth, true, great, NULL);
  if (!nice_obj) continue;
  nice_obj->origin = ORIGIN_ACQUIRE;
  nice_obj->origin_depth = convert_depth_to_origin(player->depth);
  /* Drop the object */
  drop_near(cave, &nice_obj, 0, player->grid, true, false);
 }
}
/**
 * Advance the player to max exp (CMD_WIZ_ADVANCE).
 *  Takes no arguments from cmd.
 */
void do_cmd_wiz_advance(struct command *cmd)
{
 /* Level 50 */
 player_exp_gain(player, PY_MAX_EXP);
 /* Heal the player */
 player->chp = player->mhp;
 player->chp_frac = 0;
 /* Restore mana */
 player->csp = player->msp;
 player->csp_frac = 0;
 /* Flag update and redraw for things not handled in player_exp_gain() */
 player->upkeep->redraw |= PR_HP | PR_MANA;
}
/**
 * Banish nearby monsters (CMD_WIZ_BANISH).  Can take the range of the effect
 * from the argument, "range", of type number in cmd.
 */
void do_cmd_wiz_banish(struct command *cmd)
{
 int d, i;
 if (cmd_get_arg_number(cmd, "range", &d) != CMD_OK) {
  d = get_quantity("Zap within what distance? ",
   z_info->max_sight);
  cmd_set_arg_number(cmd, "range", d);
 }
 for (i = 1; i < cave_monster_max(cave); i++) {
  struct monster *mon = cave_monster(cave, i);
  /* Skip dead monsters */
  if (!mon->race) continue;
  /* Skip distant monsters */
  if (mon->cdis > d) continue;
  /* Delete the monster */
  delete_monster_idx(cave, i);
 }
 /* Update monster list window */
 player->upkeep->redraw |= PR_MONLIST;
}
/**
 * Change the quantity of an item (CMD_WIZ_CHANGE_ITEM_QUANTITY).  Can take
 * the item to modify from the argument, "item", of type item in cmd.  Can
 * take the new amount from the argument, "quantity", of type number in cmd.
 * Takes whether to update player information from the argument, "update",
 * of type choice in cmd.
 */
void do_cmd_wiz_change_item_quantity(struct command *cmd)
{
 struct object *obj;
 int n, nmax;
 int update = 0;
 if (cmd_get_arg_item(cmd, "item", &obj) != CMD_OK) {
  if (!get_item(&obj, "Change quantity of which item? ",
    "You have nothing to change.", cmd->code,
    NULL, (USE_INVEN | USE_QUIVER | USE_FLOOR))) {
   return;
  }
  cmd_set_arg_item(cmd, "item", obj);
 } else if (object_is_equipped(player->body, obj)) {
  msg("Can not change the quantity of an equipped item.");
  return;
 }
 /* Don't allow multiple artifacts. */
 if (obj->artifact) {
  msg("Can not modify the quantity of an artifact.");
  return;
 }
 /* Find limit on stack size. */
 nmax = obj->kind->base->max_stack;
 if (tval_can_have_charges(obj) && obj->pval > 0 && obj->number > 0) {
  /* Items with charges have a limit imposed by MAX_PVAL. */
  nmax = MIN((MAX_PVAL * obj->number) / obj->pval, nmax);
 }
 /* Get the new quantity. */
 if (cmd_get_arg_number(cmd, "quantity", &n) != CMD_OK) {
  char prompt[80], s[80];
  strnfmt(prompt, sizeof(prompt), "Quantity (1-%d): ", nmax);
  /* Set the default value. */
  strnfmt(s, sizeof(s), "%d", obj->number);
  if (!get_string(prompt, s, sizeof(s)) ||
    !get_int_from_string(s, &n) ||
    n < 1 || n > obj->kind->base->max_stack) {
   return;
  }
  cmd_set_arg_number(cmd, "quantity", n);
 }
 /* Impose limits. */
 n = MAX(1, MIN(nmax, n));
 if (n != obj->number) {
  /* Adjust charges for devices. */
  if (tval_can_have_charges(obj) && obj->number > 0) {
   obj->pval = (obj->pval * n) / obj->number;
  }
  /* Accept change. */
  if (cmd_get_arg_choice(cmd, "update", &update) != CMD_OK ||
    update) {
   if (object_is_carried(player, obj)) {
    /*
				 * Remove the weight of the old number of
				 * objects.
				 */
    player->upkeep->total_weight -=
     obj->number * obj->weight;
    /*
				 * Add the weight of the new number of objects.
				 */
    player->upkeep->total_weight += n * obj->weight;
   }
   wiz_play_item_standard_upkeep(player, obj);
  } else {
   wiz_play_item_notify_changed();
  }
  obj->number = n;
 }
}
/**
 * Generate levels and collect statistics about those with disconnected areas
 * and those where the player is disconnected from stairs
 * (CMD_WIZ_COLLECT_DISCONNECT_STATS).  Can take the number of simulations
 * from the argument, "quantity", of type number in cmd.  Can take whether to
 * stop if a disconnected level is found from the argument, "choice", of type
 * choice in cmd (a nonzero value means stop).
 */
void do_cmd_wiz_collect_disconnect_stats(struct command *cmd)
{
 /* Record last-used value to be the default in next run. */
 static int default_nsim = 50;
 int nsim, stop_on_disconnect;
 if (!stats_are_enabled()) return;
 if (cmd_get_arg_number(cmd, "quantity", &nsim) != CMD_OK) {
  char s[80];
  /* Set default. */
  strnfmt(s, sizeof(s), "%d", default_nsim);
  if (!get_string("Number of simulations: ", s, sizeof(s))) return;
  if (!get_int_from_string(s, &nsim) || nsim < 1) return;
  cmd_set_arg_number(cmd, "quantity", nsim);
 }
 default_nsim = nsim;
 if (cmd_get_arg_choice(cmd, "choice", &stop_on_disconnect) != CMD_OK) {
  stop_on_disconnect =
   get_check("Stop if disconnected level found? ") ? 1 : 0;
  cmd_set_arg_choice(cmd, "choice", stop_on_disconnect);
 }
 disconnect_stats(nsim, stop_on_disconnect != 0);
}
/**
 * Generate levels and collect statistics about the included objects and
 * monsters (CMD_WIZ_COLLECT_OBJ_MON_STATS).  Can take the number of
 * simulations from the argument, "quantity", of type number in cmd.  Can take
 * the type of simulation (diving (1), clearing (2), or clearing with randart
 * regeneration (3)) from the argument, "choice", of type choice in cmd.
 */
void do_cmd_wiz_collect_obj_mon_stats(struct command *cmd)
{
 /* Record last-used values to be the default in next run. */
 static int default_nsim = 50;
 static int default_simtype = 1;
 int nsim, simtype;
 char s[80];
 if (!stats_are_enabled()) return;
 if (cmd_get_arg_number(cmd, "quantity", &nsim) != CMD_OK) {
  /* Set default. */
  strnfmt(s, sizeof(s), "%d", default_nsim);
  if (!get_string("Number of simulations: ", s, sizeof(s))) return;
  if (!get_int_from_string(s, &nsim) || nsim < 1) return;
  cmd_set_arg_number(cmd, "quantity", nsim);
 }
 default_nsim = nsim;
 if (cmd_get_arg_choice(cmd, "choice", &simtype) != CMD_OK) {
  /* Set default. */
  strnfmt(s, sizeof(s), "%d", default_simtype);
  if (!get_string("Type of Sim: Diving (1) or Clearing (2) ",
   s, sizeof(s))) return;
  if (!get_int_from_string(s, &simtype) || simtype < 1 ||
   simtype > 2) return;
  if (simtype == 2) {
   if (get_check("Regen randarts (warning SLOW)? ")) {
    simtype = 3;
   }
  }
  cmd_set_arg_choice(cmd, "choice", simtype);
 }
 default_simtype = (simtype == 1) ? 1 : 2;
 stats_collect(nsim, simtype);
}
/**
 * Create all artifacts and drop them near the player
 * (CMD_WIZ_CREATE_ALL_ARTIFACT).  Takes no arguments from cmd.
 */
void do_cmd_wiz_create_all_artifact(struct command *cmd)
{
 int i;
 for (i = 1; i < z_info->a_max; i++) {
  struct artifact *art = &a_info[i];
  struct object *obj = wiz_create_object_from_artifact(art);
  wiz_drop_object(obj);
 }
}
/**
 * Create all artifacts of a given tval and drop them near the player
 * (CMD_WIZ_CREATE_ALL_ARTIFACT_FROM_TVAL).  Can take the tval to use from
 * the argument, "tval", of type number in cmd.
 */
void do_cmd_wiz_create_all_artifact_from_tval(struct command *cmd)
{
 int tval, i;
 if (cmd_get_arg_number(cmd, "tval", &tval) != CMD_OK) {
  char prompt[80];
  char s[80] = "";
  strnfmt(prompt, sizeof(prompt),
   "Create all artifacts of which tval (1-%d)? ",
   TV_MAX - 1);
  if (!get_string(prompt, s, sizeof(s))) return;
  if (!get_int_from_string(s, &tval) || tval < 1 ||
   tval >= TV_MAX) return;
  cmd_set_arg_number(cmd, "tval", tval);
 }
 for (i = 1; i < z_info->a_max; i++) {
  struct artifact *art = &a_info[i];
  if (art->tval == tval) {
   struct object *obj =
    wiz_create_object_from_artifact(art);
   wiz_drop_object(obj);
  }
 }
}
/**
 * Create one of each kind of ordinary object and drop them near the player
 * (CMD_WIZ_CREATE_ALL_OBJ).  Takes no arguments from cmd.
 */
void do_cmd_wiz_create_all_obj(struct command *cmd)
{
 int i;
 for (i = 0; i < z_info->k_max; i++) {
  struct object_kind *kind = &k_info[i];
  struct object *obj;
  if (kind->base == NULL || kind->base->name == NULL) continue;
  if (kf_has(kind->kind_flags, KF_INSTA_ART)) continue;
  obj = wiz_create_object_from_kind(kind);
  wiz_drop_object(obj);
 }
}
/**
 * Create one of each kind of object from a tval and drop them near the player
 * (CMD_WIZ_CREATE_ALL_OBJ_FROM_TVAL).  Can take the tval to use from the
 * argument, "tval", of type number in cmd.  Can take whether to create instant
 * artifacts from the argument, "choice", of type choice in cmd.
 */
void do_cmd_wiz_create_all_obj_from_tval(struct command *cmd)
{
 int tval, art;
 int i;
 if (cmd_get_arg_number(cmd, "tval", &tval) != CMD_OK) {
  char prompt[80];
  char s[80] = "";
  strnfmt(prompt, sizeof(prompt),
   "Create all items of which tval (1-%d)? ", TV_MAX - 1);
  if (!get_string(prompt, s, sizeof(s))) return;
  if (!get_int_from_string(s, &tval) || tval < 1 ||
   tval >= TV_MAX) return;
  cmd_set_arg_number(cmd, "tval", tval);
 }
 if (cmd_get_arg_choice(cmd, "choice", &art) != CMD_OK) {
  art = get_check("Create instant artifacts? ");
  cmd_set_arg_choice(cmd, "choice", art);
 }
 for (i = 0; i < z_info->k_max; i++) {
  struct object_kind *kind = &k_info[i];
  struct object *obj;
  if (kind->tval != tval ||
   (!art && kf_has(kind->kind_flags, KF_INSTA_ART))) continue;
  obj = wiz_create_object_from_kind(kind);
  wiz_drop_object(obj);
 }
}
/**
 * Create a specified artifact (CMD_WIZ_CREATE_ARTIFACT).  Can take the index
 * of the artifact to create from the argument, "index", of type number in cmd.
 */
void do_cmd_wiz_create_artifact(struct command *cmd)
{
 int ind;
 if (cmd_get_arg_number(cmd, "index", &ind) != CMD_OK) {
  char prompt[80];
  char s[80] = "";
  strnfmt(prompt, sizeof(prompt),
   "Create which artifact (1-%d)? ", z_info->a_max - 1);
  if (!get_string(prompt, s, sizeof(s))) return;
  if (!get_int_from_string(s, &ind)) return;
  cmd_set_arg_number(cmd, "index", ind);
 }
 if (ind >= 1 && ind < z_info->a_max) {
  struct artifact *art = &a_info[ind];
  struct object *obj = wiz_create_object_from_artifact(art);
  wiz_drop_object(obj);
 } else {
  msg("That's not a valid artifact.");
 }
}
/**
 * Create an object of a given kind and drop it near the player
 * (CMD_WIZ_CREATE_OBJ).  Can take the index of the kind of object from the
 * argument, "index", of type number in cmd.
 */
void do_cmd_wiz_create_obj(struct command *cmd)
{
 int ind;
 if (cmd_get_arg_number(cmd, "index", &ind) != CMD_OK) {
  char prompt[80];
  char s[80] = "";
  strnfmt(prompt, sizeof(prompt),
   "Create which object (0-%d)? ", z_info->k_max - 1);
  if (!get_string(prompt, s, sizeof(s))) return;
  if (!get_int_from_string(s, &ind)) return;
  cmd_set_arg_number(cmd, "index", ind);
 }
 if (ind >= 0 && ind < z_info->k_max) {
  struct object_kind *kind = &k_info[ind];
  struct object *obj = wiz_create_object_from_kind(kind);
  wiz_drop_object(obj);
 } else {
  msg("That's not a valid kind of object.");
 }
}
/**
 * Create a trap at the player's position (CMD_WIZ_CREATE_TRAP).  Can take
 * the type of trap to generate from the argument, "index", of type number
 * in cmd.
 */
void do_cmd_wiz_create_trap(struct command *cmd)
{
 int tidx;
 if (cmd_get_arg_number(cmd, "index", &tidx) != CMD_OK) {
  char s[80] = "";
  if (!get_string("Create which trap? ", s, sizeof(s))) return;
  if (!get_int_from_string(s, &tidx)) {
   const struct trap_kind *trap = lookup_trap(s);
   tidx = (trap) ? trap->tidx : z_info->trap_max;
  }
  cmd_set_arg_number(cmd, "index", tidx);
 }
 if (!square_player_trap_allowed(cave, player->grid)) {
  msg("You can't place a trap there!");
 } else if (tidx < 1 || tidx >= z_info->trap_max) {
  msg("Trap not found.");
 } else {
  place_trap(cave, player->grid, tidx, 0);
  /* Can not repeat since there's now a trap here. */
  cmd_disable_repeat();
 }
}
/**
 * Instantly cure the player of everything (CMD_WIZ_CURE_ALL).  Takes no
 * arguments from cmd.
 */
void do_cmd_wiz_cure_all(struct command *cmd)
{
 int i, flag;
 /* Remove bad properties from all objects */
 for (i = 0; i < player->body.count; i++) {
  struct object *obj = player->body.slots[i].obj;
  if (obj) {
   for (flag = FLAG_START; flag != FLAG_END;
    flag = of_next(obj->flags, flag + 1)) {
    struct obj_property *prop =
     lookup_obj_property(OBJ_PROPERTY_FLAG, flag);
    if (prop && prop->type == OFT_BAD) {
     of_off(obj->flags, flag);
    }
   }
  }
 }
 /* Restore stats */
 for (i = 0; i < STAT_MAX; i++) {
  effect_simple(EF_RESTORE_STAT, source_player(), "20", i, 0, 0, NULL);
 }
 /* Heal the player */
 player->chp = player->mhp;
 /* Restore mana */
 player->csp = player->msp;
 /* Cure stuff */
 (void) player_clear_timed(player, TMD_BLIND, true, false);
 (void) player_clear_timed(player, TMD_CONFUSED, true, false);
 (void) player_clear_timed(player, TMD_POISONED, true, false);
 (void) player_clear_timed(player, TMD_AFRAID, true, false);
 (void) player_clear_timed(player, TMD_ENTRANCED, true, false);
 (void) player_clear_timed(player, TMD_IMAGE, true, false);
 (void) player_clear_timed(player, TMD_STUN, true, false);
 (void) player_clear_timed(player, TMD_CUT, true, false);
 (void) player_clear_timed(player, TMD_SLOW, true, false);
 (void) player_clear_timed(player, TMD_DARKENED, true, false);
 /* No longer hungry */
 player_set_timed(player, TMD_FOOD, PY_FOOD_FULL - 1, false, false);
 /* Flag what needs to be updated or redrawn */
 player->upkeep->update |= PU_TORCH | PU_UPDATE_VIEW | PU_MONSTERS;
 player->upkeep->redraw |= PR_BASIC | PR_EXTRA | PR_MAP | PR_EQUIP;
 /* Give the player some feedback */
 msg("You feel *much* better!");
}
/**
 * Detect everything nearby (CMD_WIZ_DETECT_ALL_LOCAL).  Takes no arguments
 * from cmd.
 */
void do_cmd_wiz_detect_all_local(struct command *cmd)
{
 effect_simple(EF_DETECT_TRAPS, source_player(), "0",
  0, 0, 0, NULL);
 effect_simple(EF_DETECT_DOORS, source_player(), "0",
  0, 0, 0, NULL);
 effect_simple(EF_DETECT_OBJECTS, source_player(), "0",
  0, 0, 0, NULL);
 effect_simple(EF_DETECT_MONSTERS, source_player(), "0",
  0, 0, 0, NULL);
}
/**
 * Detect all monsters (CMD_WIZ_DETECT_ALL_MONSTERS).  Takes no arguments
 * from cmd.
 */
void do_cmd_wiz_detect_all_monsters(struct command *cmd)
{
 effect_simple(EF_DETECT_MONSTERS, source_player(), "0",
  0, 0, 0, NULL);
}
/**
 * Display the keycodes the user has been generating (CMD_WIZ_DISPLAY_KEYLOG).
 * Takes no arguments from cmd.
 */
void do_cmd_wiz_display_keylog(struct command *cmd)
{
 int i;
 char buf[50];
 char buf2[12];
 struct keypress keys[2] = {KEYPRESS_NULL, KEYPRESS_NULL};
 screen_save();
 prt("Previous keypresses (top most recent):", 0, 0);
 for (i = 0; i < KEYLOG_SIZE; i++) {
  if (i < log_size) {
   /*
			 * Find the keypress from the log; log_i is one past
			 * the most recent.
			 */
   int j = (log_i > i) ?
    log_i - i - 1 : log_i - i - 1 + KEYLOG_SIZE;
   struct keypress k = keylog[j];
   /*
			 * ugh. it would be nice if there was a version of
			 * keypress_to_text which took only one keypress.
			 */
   keys[0] = k;
   keypress_to_text(buf2, sizeof(buf2), keys, true);
   /* format this line of output */
   strnfmt(buf, sizeof(buf), "    %-12s (code=%lu mods=%u)",
    buf2, (unsigned long)k.code, k.mods);
  } else {
   /* create a blank line of output */
   strnfmt(buf, sizeof(buf), "%40s", "");
  }
  prt(buf, i + 1, 0);
 }
 prt("Press any key to continue.", KEYLOG_SIZE + 1, 0);
 anykey();
 screen_load();
}
/**
 * Dump a map of the current level as an HTML file (CMD_WIZ_DUMP_LEVEL_MAP).
 * Takes no arguments from cmd.
 *
 * Bugs:
 * The path and title could be passed through arguments of type string on the
 * command.  That, however, is problematic because there's nothing to say how
 * the lifetime of the string should be handled (does it need to be freed at
 * all, should it be freed here which would break the option to repeat the
 * command, or should it be freed within cmd-core.c as part of managing the
 * lifecycle for the command).
 */
void do_cmd_wiz_dump_level_map(struct command *cmd)
{
 char path[1024] = "";
 char title[80];
 ang_file *fo;
 strnfmt(title, sizeof(title), "Map of level %d", player->depth);
 if (!get_file("level.html", path, sizeof(path)) ||
   !get_string("Title for map: ", title, sizeof(title))) {
  return;
 }
 fo = file_open(path, MODE_WRITE, FTYPE_TEXT);
 if (fo) {
  dump_level(fo, title, cave, NULL);
  if (file_close(fo)) {
   msg("Level dumped to %s.", path);
  }
 }
}
/**
 * Edit the player's amount of experience (CMD_WIZ_EDIT_PLAYER_EXP).  Takes
 * no arguments from cmd.
 */
void do_cmd_wiz_edit_player_exp(struct command *cmd)
{
 char s[80];
 long newv;
 if (edit_player_state == EDIT_PLAYER_BREAK) return;
 /* Set default value. */
 strnfmt(s, sizeof(s), "%ld", (long)(player->exp));
 if (!get_string("Experience: ", s, sizeof(s)) ||
   !get_long_from_string(s, &newv)) {
  /* Set next editing stage to break. */
  edit_player_state = EDIT_PLAYER_BREAK;
  return;
 }
 /* Keep in the bounds of [0, PY_MAX_EXP]. */
 newv = MIN(PY_MAX_EXP, MAX(0, newv));
 if (newv > player->exp) {
  player_exp_gain(player, newv - player->exp);
 } else {
  player_exp_lose(player, player->exp - newv);
 }
}
/**
 * Start editing the player (CMD_WIZ_EDIT_PLAYER_START).  Takes no arguments
 * from cmd.  Because of the use of static state (edit_player_state), this is
 * not reentrant.
 */
void do_cmd_wiz_edit_player_start(struct command *cmd)
{
 int i;
 if (edit_player_state != EDIT_PLAYER_UNKNOWN) {
  /*
		 * Invoked as the cleanup stage for an edit session to work
		 * nicely with command repetition.
		 */
  edit_player_state = EDIT_PLAYER_UNKNOWN;
  return;
 }
 edit_player_state = EDIT_PLAYER_STARTED;
 for (i = 0; i < STAT_MAX; ++i) {
  if (cmdq_push(CMD_WIZ_EDIT_PLAYER_STAT) != 0) {
   /* Failed.  Skip any queued edit commands. */
   edit_player_state = EDIT_PLAYER_BREAK;
   return;
  }
  cmd_set_arg_choice(cmdq_peek(), "choice", i);
 }
 if (cmdq_push(CMD_WIZ_EDIT_PLAYER_EXP) != 0) {
  /* Failed.  Skip any queued edit commands. */
  edit_player_state = EDIT_PLAYER_BREAK;
  return;
 }
 /* Make the last command look like the first so repetition works. */
 if (cmdq_push(CMD_WIZ_EDIT_PLAYER_START) != 0) {
  /* Failed. Skip any queued edit commands. */
  edit_player_state = EDIT_PLAYER_BREAK;
  return;
 }
}
/**
 * Edit one of the player's statistics (CMD_WIZ_EDIT_PLAYER_STAT).  Takes
 * the index of the statistic to edit from the argument, "choice", of type
 * choice in the command.
 */
void do_cmd_wiz_edit_player_stat(struct command *cmd)
{
 int stat, newv;
 char prompt[80], s[80];
 if (edit_player_state == EDIT_PLAYER_BREAK) return;
 if (cmd_get_arg_choice(cmd, "choice", &stat) != CMD_OK) {
  strnfmt(prompt, sizeof(prompt),
   "Edit which stat (name or 0-%d): ", STAT_MAX - 1);
  /* Set default value. */
  strnfmt(s, sizeof(s), "%s", stat_idx_to_name(0));
  if (!get_string(prompt, s, sizeof(s))) return;
  if (!get_int_from_string(s, &stat)) {
   stat = stat_name_to_idx(s);
   if (stat < 0) {
    return;
   }
  }
  cmd_set_arg_choice(cmd, "choice", stat);
 }
 if (stat < 0 || stat >= STAT_MAX) {
  return;
 }
 strnfmt(prompt, sizeof(prompt), "%s (0-20): ", stat_idx_to_name(stat));
 /* Set default value. */
 strnfmt(s, sizeof(s), "%d", player->stat_base[stat]);
 if (!get_string(prompt, s, sizeof(s)) ||
   !get_int_from_string(s, &newv)) {
  /* Set next editing stage to break. */
  edit_player_state = EDIT_PLAYER_BREAK;
  return;
 }
 /* Limit to the range of [3, 118]. */
 newv = MIN(20, MAX(0, newv));
 player->stat_base[stat] = newv;
 /* Flag what needs to be updated or redrawn. */
 player->upkeep->update |= (PU_BONUS);
 player->upkeep->redraw |= (PR_STATS);
}
/**
 * Hit all monsters in the player's line of sight (CMD_WIZ_HIT_ALL_LOS).  Takes
 * no arguments from cmd.
 */
void do_cmd_wiz_hit_all_los(struct command *cmd)
{
 effect_simple(EF_PROJECT_LOS, source_player(), "10000", PROJ_DISP_ALL,
  0, 0, NULL);
}
/**
 * Increase the player's experience by a given amount (CMD_WIZ_INCREASE_EXP).
 * Can take the amount from the argument, "quantity", of type number in cmd.
 */
void do_cmd_wiz_increase_exp(struct command *cmd)
{
 int n;
 if (cmd_get_arg_number(cmd, "quantity", &n) != CMD_OK) {
  n = get_quantity("Gain how much experience? ", 9999);
  cmd_set_arg_number(cmd, "quantity", n);
 }
 if (n < 1) n = 1;
 player_exp_gain(player, n);
}
/**
 * Go to any level, optionally choosing the level generation algorithm
 * (CMD_WIZ_JUMP_LEVEL).  Can take the level to jump to from the argument,
 * "level", of type number in cmd.  Can take whether to choose the generation
 * algorithm from the argument, "choice", of type choice in cmd.
 *
 * Bugs:
 * Because choose_profile() prompts for the generation algorithm, it is not
 * stored in the command and the prompt will be repeated if the command is
 * repeated.
 */
void do_cmd_wiz_jump_level(struct command *cmd)
{
 int level, choose_gen;
 if (cmd_get_arg_number(cmd, "level", &level) != CMD_OK) {
  char prompt[80], s[80];
  strnfmt(prompt, sizeof(prompt), "Jump to level (0-%d): ",
   z_info->dun_depth);
  /* Set default */
  strnfmt(s, sizeof(s), "%d", player->depth);
  if (!get_string(prompt, s, sizeof(s))) return;
  if (!get_int_from_string(s, &level)) return;
  cmd_set_arg_number(cmd, "level", level);
 }
 /* Paranoia */
 if (level < 0 || level > z_info->dun_depth) return;
 if (cmd_get_arg_choice(cmd, "choice", &choose_gen) != CMD_OK) {
  choose_gen = (get_check("Choose cave profile? ")) ? 1 : 0;
  cmd_set_arg_choice(cmd, "choice", choose_gen);
 }
 if (choose_gen) {
  player->noscore |= NOSCORE_JUMPING;
 }
 msg("You jump to dungeon level %d.", level);
 dungeon_change_level(player, level);
 /*
	 * Because of the structure of the game loop, need to take some energy,
	 * or the change level request will not be processed until after
	 * performing another action that takes energy.
	 */
 player->upkeep->energy_use = z_info->move_energy;
}
/**
 * Make the player aware of all object kinds up to a given level
 * (CMD_WIZ_LEARN_OBJECT_KINDS).  Can take the level from the argument,
 * "level", of type number in cmd.
 */
void do_cmd_wiz_learn_object_kinds(struct command *cmd)
{
 int level, i;
 if (cmd_get_arg_number(cmd, "level", &level) != CMD_OK) {
  char s[80] = "100";
  if (!get_string("Learn object kinds up to level (0-100)? ",
   s, sizeof(s))) return;
  if (!get_int_from_string(s, &level)) return;
  cmd_set_arg_number(cmd, "level", level);
 }
 /* Scan all object kinds */
 for (i = 1; i < z_info->k_max; i++) {
  struct object_kind *kind = &k_info[i];
  /* Induce awareness */
  if (kind && kind->name && kind->level <= level) {
   kind->aware = true;
  }
 }
 msg("You now know about many items!");
}
/**
 * Map the area near the player (CMD_WIZ_MAGIC_MAP).  Takes no arguments from
 * cmd.
 */
void do_cmd_wiz_magic_map(struct command *cmd)
{
 effect_simple(EF_MAP_AREA, source_player(), "0", 0, 0, 0, NULL);
}
/**
 * Is a helper function passed by do_cmd_wiz_peek_noise_scent() to
 * wiz_hack_map() in order to peek at the noise.
 *
 * \param c is the chunk to access for data.
 * \param closure is a pointer to an integer with the desired noise level.
 * \param grid is the location in the chunk.
 * \param show is dereferenced and set to true if grid has the desired noise.
 * Otherwise, it is dereferenced and set to false.
 * \param color is dereferenced and set to the color to use if *show is set
 * to true.  Otherwise, it is not dereferenced.
 */
static void wiz_hack_map_peek_noise(struct chunk *c, void *closure,
 struct loc grid, bool *show, uint8_t *color)
{
 if (c->player_noise.grids[grid.y][grid.x] == *((int*)closure)) {
  *show = true;
  *color = COLOUR_RED;
 } else {
  *show = false;
 }
}
/**
 * Is a helper function passed by do_cmd_wiz_peek_noise_scent() to
 * wiz_hack_map() in order to peek at the scent.
 *
 * \param c is the chunk to access for data.
 * \param closure is a pointer to an integer with the desired scent level.
 * \param grid is the location in the chunk.
 * \param show is dereferenced and set to true if grid has the desired scent.
 * Otherwise, it is dereferenced and set to false.
 * \param color is dereferenced and set to the color to use if *show is set
 * to true.  Otherwise, it is not dereferenced.
 */
static void wiz_hack_map_peek_scent(struct chunk *c, void *closure,
 struct loc grid, bool *show, uint8_t *color)
{
 if (c->scent.grids[grid.y][grid.x] == *((int*)closure)) {
  *show = true;
  *color = COLOUR_YELLOW;
 } else {
  *show = false;
 }
}
/**
 * Display in sequence the squares at n grids from the player, as measured by
 * the noise and scent algorithms; n goes from 1 to the maximum flow depth
 * (CMD_WIZ_PEEK_NOISE_SCENT).  Takes no arguments from cmd.
 */
void do_cmd_wiz_peek_noise_scent(struct command *cmd)
{
 int i;
 char kp;
 /* Noise */
 for (i = 0; i < 100; i++) {
  wiz_hack_map(cave, player, wiz_hack_map_peek_noise, &i);
  /* Get key */
  if (!get_com(format("Depth %d: ", i), &kp)) break;
  /* Redraw map */
  prt_map();
 }
 /* Smell */
 for (i = 0; i < 50; i++) {
  wiz_hack_map(cave, player, wiz_hack_map_peek_scent, &i);
  /* Get key */
  if (!get_com(format("Depth %d: ", i), &kp)) break;
  /* Redraw map */
  prt_map();
 }
 /* Done */
 prt("", 0, 0);
 /* Redraw map */
 prt_map();
}
/**
 * Perform an effect (CMD_WIZ_PERFORM_EFFECT).  Takes no arguments from cmd.
 *
 * Bugs:
 * If the command is repeated, it prompts again for all the effect's parameters.
 * The number of parameters currently exceeds CMD_MAX_ARGS so a one-to-one
 * mapping for storing the parameters as arguments in the command would require
 * increasing CMD_MAX_ARGS.  Otherwise, the parameters would have to be
 * multiplexed into the available arguments to store them in the command.  The
 * handling of the lifetime of string arguments for commands is also awkward
 * which would also hamper storing the effect's parameters in the command.
 */
void do_cmd_wiz_perform_effect(struct command *cmd)
{
 char name[80] = "";
 char dice[80] = "0";
 int index = -1;
 int p1 = 0, p2 = 0, p3 = 0;
 bool ident = false;
 /* Avoid the prompt getting in the way */
 screen_save();
 /* Get the name */
 if (get_string("Do which effect: ", name, sizeof(name))) {
  /* See if an effect index was entered */
  if (!get_int_from_string(name, &index)) {
   /* If not, find the effect with that name */
   index = effect_lookup(name);
  }
  /* Failed */
  if (index <= EF_NONE || index >= EF_MAX) {
   msg("No effect found.");
   return;
  }
 }
 /* Get the dice */
 if (! get_string("Enter damage dice (eg 1+2d6M2): ", dice,
   sizeof(dice))) {
  my_strcpy(dice, "0", sizeof(dice));
 }
 /* Get the effect subtype */
 my_strcpy(name, "0", sizeof(name));
 if (get_string("Enter name or number for effect subtype: ", name,
   sizeof(name))) {
  /* See if an effect parameter was entered */
  p1 = effect_subtype(index, name);
  if (p1 == -1) p1 = 0;
 }
 /* Get the parameters */
 p2 = get_quantity("Enter second parameter (radius): ", 100);
 p3 = get_quantity("Enter third parameter (other): ", 100);
 /* Reload the screen */
 screen_load();
 effect_simple(index, source_player(), dice, p1, p2, p3, &ident);
 if (ident) {
  msg("Identified!");
 }
}
/**
 * Play with an item (CMD_WIZ_PLAY_ITEM).  Can take the item to play with
 * from the argument, "item", of type item in cmd.  Uses the arguments,
 * "original_item" (of type item), "all_prop" (of type choice), and "changed"
 * (of type choice), internally for a session of playing with the same object.
 *
 * Things that can be done are:
 * - output statistics via CMD_WIZ_STAT_ITEM
 * - reroll item via CMD_WIZ_REROLL_ITEM
 * - change properties via CMD_WIZ_TWEAK_ITEM
 * - change a curse via CMD_WIZ_CURSE_ITEM
 * - change the number of items via CMD_WIZ_CHANGE_ITEM_QUANTITY
 */
void do_cmd_wiz_play_item(struct command *cmd)
{
 struct object *obj = NULL;
 struct object *orig_obj = NULL;
 int display_all_prop = 1;
 int object_changed = 0;
 bool done = false;
 bool rejected = true;
 const char *done_msg = NULL;
 char ch;
 /*
	 * When called to initiate a play session, "item" may be set, but
	 * "original_item" should not be set or should be set to NULL.
	 * Subsequent calls in the same session will have both set to
	 * non-NULL vales along with "all_prop" and "changed".
	 */
 if (cmd_get_arg_item(cmd, "original_item", &orig_obj) == CMD_OK &&
   orig_obj) {
  if (cmd_get_arg_item(cmd, "item", &obj) != CMD_OK || !obj) {
   assert(0);
   return;
  }
  if (cmd_get_arg_choice(cmd, "all_prop", &display_all_prop) !=
    CMD_OK) {
   assert(0);
   return;
  }
  if (cmd_get_arg_choice(cmd, "changed", &object_changed) !=
    CMD_OK) {
   assert(0);
   return;
  }
 } else {
  if (cmd_get_arg_item(cmd, "item", &obj) != CMD_OK || !obj) {
   if (!get_item(&obj, "Play with which object? ",
     "You have nothing to play with.",
     cmd->code, NULL, (USE_EQUIP |
     USE_INVEN | USE_QUIVER | USE_FLOOR))) {
    return;
   }
  }
  /* Remember the object. */
  cmd_set_arg_item(cmd, "item", obj);
  /* Make a copy so changes can be rejected. */
  orig_obj = object_new();
  object_copy(orig_obj, obj);
  cmd_set_arg_item(cmd, "original_item", orig_obj);
  /*
		 * Store whether all properties are shown or only the known
		 * ones.
		 */
  if (cmd_get_arg_choice(cmd, "all_prop", &display_all_prop) !=
    CMD_OK) {
   display_all_prop = 1;
   cmd_set_arg_choice(cmd, "all_prop", display_all_prop);
  }
  /*
		 * Store whether the working item may have changed from the
		 * original.
		 */
  if (cmd_get_arg_choice(cmd, "changed", &object_changed) !=
    CMD_OK) {
   object_changed = 0;
   cmd_set_arg_choice(cmd, "changed", object_changed);
  }
  /* Save screen. */
  screen_save();
 }
 /* Display the (possibly modified) item. */
 wiz_display_item(obj, display_all_prop != 0, player);
 /* Get choice. */
 if (get_com("[a]ccept [s]tatistics [r]eroll [t]weak [q]uantity [k]nown? ", &ch)) {
  bool queue_failed = false;
  switch (ch) {
   case 'A':
   case 'a':
    /* Accept whatever changes were made. */
    done = true;
    rejected = false;
    if (object_changed) {
     /* Mark for updates. */
     if (object_is_carried(player, obj) &&
       (obj->number !=
       orig_obj->number ||
       obj->weight !=
       orig_obj->weight)) {
      /*
						 * Remove the weight of the old
						 * version.
						 */
      player->upkeep->total_weight -=
       orig_obj->number *
       orig_obj->weight;
      /*
						 * Add the weight of the new
						 * version.
						 */
      player->upkeep->total_weight +=
       obj->number *
       obj->weight;
     }
     object_touch(player, obj);
     if (object_is_equipped(player->body, obj)) {
      assert(obj->known);
      obj->known->notice &=
       ~OBJ_NOTICE_WORN;
      object_learn_on_wield(player,
       obj);
     }
     wiz_play_item_standard_upkeep(player,
      obj);
    }
    break;
   case 'S':
   case 's':
    /* Get statistics about the item. */
    if (cmdq_push(CMD_WIZ_STAT_ITEM) == 0) {
     cmd_set_arg_item(cmdq_peek(), "item",
      obj);
    } else {
     queue_failed = true;
    }
    break;
   case 'R':
   case 'r':
    /* Reroll the item. */
    if (cmdq_push(CMD_WIZ_REROLL_ITEM) == 0) {
     cmd_set_arg_item(cmdq_peek(), "item",
      obj);
     cmd_set_arg_choice(cmdq_peek(),
      "update", 0);
    } else {
     queue_failed = true;
    }
    break;
   case 'T':
   case 't':
    /* Tweak the object's properties. */
    if (cmdq_push(CMD_WIZ_TWEAK_ITEM) == 0) {
     cmd_set_arg_item(cmdq_peek(), "item",
      obj);
     cmd_set_arg_choice(cmdq_peek(),
      "update", 0);
    } else {
     queue_failed = true;
    }
    break;
   case 'K':
   case 'k':
    /* Toggle whether showing all properties. */
    display_all_prop = !display_all_prop;
    cmd_set_arg_choice(cmd, "all_prop",
     display_all_prop);
    break;
   case 'Q':
   case 'q':
    /* Change the number of items in the stack. */
    if (cmdq_push(CMD_WIZ_CHANGE_ITEM_QUANTITY) == 0) {
     cmd_set_arg_item(cmdq_peek(), "item",
      obj);
     cmd_set_arg_choice(cmdq_peek(),
      "update", 0);
    } else {
     queue_failed = true;
    }
    break;
   default:
    /*
				 * Don't have to do anything, next pass through
				 * will ask again what's wanted.
				 */
    break;
  }
  if (queue_failed &&
    get_check("Couldn't proceed.  Stop playing with item and lose all changes? ")) {
   done = true;
   if (object_changed) {
    done_msg = "Bailed out.  Changes to item lost.";
   }
  }
 } else {
  done = true;
  if (object_changed) {
   done_msg = "Changes ignored.";
  }
 }
 if (!done) {
  /* Push the command back on the queue to be reexecuted. */
  if (cmdq_push_copy(cmd) != 0) {
   /* Failed.  Bail out without saving changes. */
   done = true;
   done_msg = "Couldn't queue command.  Changes lost.";
  }
 }
 if (done) {
  if (rejected && object_changed) {
   /*
			 * Restore to the original values.  The pile links
			 * require special handling because object_copy()
			 * resets them.
			 */
   struct object *prev = obj->prev;
   struct object *next = obj->next;
   /* Free slays, brands, and abilities by hand. */
   mem_free(obj->slays);
   obj->slays = NULL;
   mem_free(obj->brands);
   obj->brands = NULL;
   release_ability_list(obj->abilities);
   obj->abilities = NULL;
   object_copy(obj, orig_obj);
   obj->prev = prev;
   obj->next = next;
  }
  /* Release the preserved copy. */
  object_delete(cave, player->cave, &orig_obj);
  /*
		 * Reset the original_item and changed arguments so repeating
		 * the command will start a new play session without a
		 * dangling reference to the deleted preserved copy.
		 */
  cmd_set_arg_item(cmd, "original_item", NULL);
  cmd_set_arg_choice(cmd, "changed", 0);
  /* Restore the screen. */
  screen_load();
  /* Provide some feedback. */
  if (done_msg) {
   msg("%s", done_msg);
  }
 }
}
/**
 * Push objects from a selected grid (CMD_WIZ_PUSH_OBJECT).  Can take the
 * location from the argument, "point", of type point in cmd.
 */
void do_cmd_wiz_push_object(struct command *cmd)
{
 struct loc grid;
 if (cmd_get_arg_point(cmd, "point", &grid) != CMD_OK) {
  if (!target_set_interactive(TARGET_KILL, loc(-1, -1), 0)) return;
  target_get(&grid);
  cmd_set_arg_point(cmd, "point", grid);
 }
 push_object(grid);
}
struct wiz_query_feature_closure {
 const int *features;
 int n;
};
/**
 * Is a helper function passed by do_cmd_wiz_query_feature() to wiz_hack_map().
 *
 * \param c is the chunk to access for data.
 * \param closure is a pointer to a struct wiz_query_feature_closure cast to a
 * pointer to void.  Selects the terrain shown.
 * \param grid is the location in the chunk.
 * \param show is dereferenced and set to true if grid contains one of the
 * types of terrain selected by closure.  Otherwise, it is dereferenced and
 * set to false.
 * \param color is dereferenced and set to the color to use if *show is set
 * to true.  Otherwise, it is not dereferenced.
 */
static void wiz_hack_map_query_feature(struct chunk *c, void *closure,
 struct loc grid, bool *show, uint8_t *color)
{
 const struct wiz_query_feature_closure *sel_feats = closure;
 int i = 0;
 int sq_feat = square(c, grid)->feat;
 while (1) {
  if (i >= sel_feats->n) {
   *show = false;
   return;
  }
  if (sq_feat == sel_feats->features[i]) {
   *show = true;
   *color = (square_ispassable(c, grid)) ?
    COLOUR_YELLOW : COLOUR_RED;
   return;
  }
  ++i;
 }
}
/**
 * Redraw the visible portion of the map to highlight certain terrain
 * (CMD_WIZ_QUERY_FEATURE).  Can take the terrain to highlight from the
 * argument, "choice", of type choice in cmd.  This function will need
 * to be changed if the terrain types change.
 */
void do_cmd_wiz_query_feature(struct command *cmd)
{
 int feature_class;
 struct wiz_query_feature_closure selected;
 /* OMG hax */
 const int featf[] = { FEAT_FLOOR };
 const int feato[] = { FEAT_OPEN };
 const int featb[] = { FEAT_BROKEN };
 const int featu[] = { FEAT_LESS, FEAT_LESS_SHAFT };
 const int featz[] = { FEAT_MORE, FEAT_MORE_SHAFT };
 const int featt[] = { FEAT_LESS, FEAT_MORE, FEAT_LESS_SHAFT,
        FEAT_MORE_SHAFT };
 const int featc[] = { FEAT_CLOSED };
 const int featd[] = { FEAT_CLOSED, FEAT_OPEN, FEAT_BROKEN,
  FEAT_SECRET };
 const int feath[] = { FEAT_SECRET };
 const int featm[] = { FEAT_FORGE, FEAT_FORGE_GOOD, FEAT_FORGE_UNIQUE };
 const int featq[] = { FEAT_QUARTZ };
 const int featg[] = { FEAT_GRANITE };
 const int featp[] = { FEAT_PERM };
 const int featr[] = { FEAT_RUBBLE };
 const int feata[] = { FEAT_CHASM };
 if (cmd_get_arg_choice(cmd, "choice", &feature_class) != CMD_OK) {
  char choice;
  if (!get_com("Debug Command Feature Query: ", &choice)) return;
  feature_class = choice;
  cmd_set_arg_choice(cmd, "choice", feature_class);
 }
 switch (feature_class) {
  /* Floors */
  case 'f':
   selected.features = featf;
   selected.n = (int) N_ELEMENTS(featf);
   break;
  /* Open doors */
  case 'o':
   selected.features = feato;
   selected.n = (int) N_ELEMENTS(feato);
   break;
  /* Broken doors */
  case 'b':
   selected.features = featb;
   selected.n = (int) N_ELEMENTS(featb);
   break;
  /* Upstairs */
  case 'u':
   selected.features = featu;
   selected.n = (int) N_ELEMENTS(featu);
   break;
  /* Downstairs */
  case 'z':
   selected.features = featz;
   selected.n = (int) N_ELEMENTS(featz);
   break;
  /* Stairs */
  case 't':
   selected.features = featt;
   selected.n = (int) N_ELEMENTS(featt);
   break;
  /* Closed doors */
  case 'c':
   selected.features = featc;
   selected.n = (int) N_ELEMENTS(featc);
   break;
  /* Doors */
  case 'd':
   selected.features = featd;
   selected.n = (int) N_ELEMENTS(featd);
   break;
  /* Secret doors */
  case 'h':
   selected.features = feath;
   selected.n = (int) N_ELEMENTS(feath);
   break;
  /* Forges */
  case 'm':
   selected.features = featm;
   selected.n = (int) N_ELEMENTS(featm);
   break;
  /* Quartz */
  case 'q':
   selected.features = featq;
   selected.n = (int) N_ELEMENTS(featq);
   break;
  /* Granite */
  case 'g':
   selected.features = featg;
   selected.n = (int) N_ELEMENTS(featg);
   break;
  /* Permanent wall */
  case 'p':
   selected.features = featp;
   selected.n = (int) N_ELEMENTS(featp);
   break;
  /* Rubble */
  case 'r':
   selected.features = featr;
   selected.n = (int) N_ELEMENTS(featr);
   break;
  /* Chasms */
  case 'a':
   selected.features = feata;
   selected.n = (int) N_ELEMENTS(feata);
   break;
  /* Invalid entry */
  default:
   msg("That was an invalid selection.  Use one of fobuztcdhmqgpra .");
   return;
 }
 wiz_hack_map(cave, player, wiz_hack_map_query_feature, &selected);
 Term_redraw();
 msg("Press any key.");
 inkey_ex();
 prt("", 0, 0);
 /* Redraw map */
 prt_map();
}
/**
 * Is a helper function passed by do_cmd_wiz_query_square_flag() to
 * wiz_hack_map().
 *
 * \param c is the chunk to access for data.
 * \param closure is a pointer to the int with the flag to highlight.
 * \param grid is the location in the chunk.
 * \param show is dereferenced and set to true if the grid has the flag.
 * Otherwise, it is dereferenced and set to false.
 * \param color is dereferenced and set to the color to use if *show is set
 * to true.  Otherwise, it is not dereferenced.
 */
static void wiz_hack_map_query_square_flag(struct chunk *c, void *closure,
 struct loc grid, bool *show, uint8_t *color)
{
 int flag = *((int*)closure);
 /* With a flag, test for that.  Otherwise, test if grid is known. */
 if ((flag && sqinfo_has(square(c, grid)->info, flag)) ||
   (!flag && square_isknown(c, grid))) {
  *show = true;
  *color = (square_ispassable(c, grid)) ?
   COLOUR_YELLOW : COLOUR_RED;
 } else {
  *show = false;
 }
}
/**
 * Redraw the visible portion of the map to highlight squares with a given
 * flag (CMD_WIZ_QUERY_SQUARE_FLAG).  Can take the flag to highlight from the
 * argument, "choice", of type choice in cmd.  This function will need to
 * be changed if list-square-flags.h changes.
 */
void do_cmd_wiz_query_square_flag(struct command *cmd)
{
 int flag = 0;
 if (cmd_get_arg_choice(cmd, "choice", &flag) != CMD_OK) {
  char c;
  if (!get_com("Debug Command Query [grasvwftniolx]: ", &c))
   return;
  switch (c) {
   case 'g': flag = SQUARE_GLOW; break;
   case 'r': flag = SQUARE_ROOM; break;
   case 'a': flag = SQUARE_VAULT; break;
   case 's': flag = SQUARE_SEEN; break;
   case 'v': flag = SQUARE_VIEW; break;
   case 'w': flag = SQUARE_WASSEEN; break;
   case 'f': flag = SQUARE_FIRE; break;
   case 't': flag = SQUARE_TRAP; break;
   case 'n': flag = SQUARE_INVIS; break;
   case 'i': flag = SQUARE_WALL_INNER; break;
   case 'o': flag = SQUARE_WALL_OUTER; break;
   case 'l': flag = SQUARE_WALL_SOLID; break;
  }
  cmd_set_arg_choice(cmd, "choice", flag);
 }
 wiz_hack_map(cave, player, wiz_hack_map_query_square_flag, &flag);
 Term_redraw();
 msg("Press any key.");
 inkey_ex();
 prt("", 0, 0);
 /* Redraw map */
 prt_map();
}
/**
 * Quit without saving (CMD_WIZ_QUIT_NO_SAVE).  Takes no arguments from cmd.
 */
void do_cmd_wiz_quit_no_save(struct command *cmd)
{
 quit("user choice");
}
/**
 * Make the player fully aware of a monster race's attributes
 * (CMD_WIZ_RECALL_MONSTER).  Can take the race from the argument, "index", of
 * type number in cmd.  If that index is -1, make the player aware of all
 * races.
 */
void do_cmd_wiz_recall_monster(struct command *cmd)
{
 int r_idx = z_info->r_max;
 if (cmd_get_arg_number(cmd, "index", &r_idx) != CMD_OK) {
  char s[80] = "";
  char c;
  if (!get_com("Full recall for [a]ll monsters or [s]pecific monster? ", &c)) return;
  if (c == 'a' || c == 'A') {
   r_idx = -1;
  } else if (c == 's' || c == 'S') {
   if (!get_string("Which monster? ", s, sizeof(s)))
    return;
   if (!get_int_from_string(s, &r_idx)) {
    const struct monster_race *race =
     lookup_monster(s);
    if (race) {
     r_idx = race->ridx;
    }
   }
  } else {
   return;
  }
  cmd_set_arg_number(cmd, "index", r_idx);
 }
 if (r_idx >= 0 && r_idx < z_info->r_max) {
  const struct monster_race *race = &r_info[r_idx];
  cheat_monster_lore(race, get_lore(race));
 } else if (r_idx == -1) {
  int i;
  for (i = 0; i < z_info->r_max; i++) {
   cheat_monster_lore(&r_info[i], &l_list[i]);
  }
 } else {
  msg("No monster found.");
 }
}
/**
 * Reroll an item (CMD_WIZ_REROLL_ITEM).  Can take the item to use from
 * the argument, "item", of type item in cmd.  Can take the type of roll
 * to use from the argument, "choice", of type choice in cmd:  0 means set
 * good and great to false for the roll, 1 means set good to true and great
 * to false for the roll, and 2 means set good and great to true for the roll.
 */
void do_cmd_wiz_reroll_item(struct command *cmd)
{
 bool good = false;
 bool great = false;
 int roll_choice = 0;
 int update = 0;
 struct object *obj;
 struct object *new;
 /* Get the item to reroll. */
 if (cmd_get_arg_item(cmd, "item", &obj) != CMD_OK) {
  if (!get_item(&obj, "Reroll which item? ",
    "You have nothing to reroll.", cmd->code,
    NULL, (USE_EQUIP | USE_INVEN | USE_QUIVER |
    USE_FLOOR))) {
   return;
  }
  cmd_set_arg_item(cmd, "item", obj);
 }
 /* Get the type of roll to use. */
 if (cmd_get_arg_choice(cmd, "choice", &roll_choice) != CMD_OK) {
  char ch;
  if (!get_com("Roll as [n]ormal, [g]ood, or [e]xcellent? ", &ch)) {
   return;
  }
  if (ch == 'n' || ch == 'N') {
   roll_choice = 0;
  } else if (ch == 'g' || ch == 'G') {
   roll_choice = 1;
  } else if (ch == 'e' || ch == 'E') {
   roll_choice = 2;
  } else {
   return;
  }
  cmd_set_arg_choice(cmd, "choice", roll_choice);
 }
 if (roll_choice == 0) {
  good = false;
  great = false;
 } else if (roll_choice == 1) {
  good = true;
  great = false;
 } else if (roll_choice == 2) {
  good = true;
  great = true;
 } else {
  return;
 }
 /* Hack -- leave artifacts alone */
 if (obj->artifact) {
  return;
 }
 /* Get a new object with a clean slate. */
 new = object_new();
 /* Reroll based on old kind and player's depth.  Then apply magic. */
 object_prep(new, obj->kind, player->depth, RANDOMISE);
 apply_magic(new, player->depth, false, good, great);
 /* Copy over changes to the original. */
 {
  /* Record old pile information. */
  struct object *prev = obj->prev;
  struct object *next = obj->next;
  struct object *known_obj = obj->known;
  uint16_t oidx = obj->oidx;
  struct loc grid = obj->grid;
  bitflag notice = obj->notice;
  /*
		 * Free slays, brands, and abilities on the old object by hand.
		 */
  mem_free(obj->slays);
  obj->slays = NULL;
  mem_free(obj->brands);
  obj->brands = NULL;
  release_ability_list(obj->abilities);
  obj->abilities = NULL;
  /* Copy over; pile information needs to be restored. */
  object_copy(obj, new);
  obj->prev = prev;
  obj->next = next;
  obj->known = known_obj;
  obj->known->ego = obj->ego;
  obj->oidx = oidx;
  obj->grid = grid;
  obj->notice = notice;
 }
 /* Mark as cheat */
 obj->origin = ORIGIN_CHEAT;
 /* Flag what needs to be updated. */
 if (cmd_get_arg_choice(cmd, "update", &update) != CMD_OK || update) {
  wiz_play_item_standard_upkeep(player, obj);
 } else {
  wiz_play_item_notify_changed();
 }
 /* Free the copy. */
 object_delete(cave, player->cave, &new);
}
/**
 * Get some statistics about the rarity of an item (CMD_WIZ_STAT_ITEM).  Can
 * take the item to use from the argument, "item", of type item in cmd.  Can
 * take how items used for comparison are rolled from the argument, "choice",
 * of type choice in cmd:  a value of zero means calling make_object() with
 * good and great set to false, a value of one means calling make_object()
 * with good set to true and great set to false, and a value of two means
 * calling make_object() with good and great set to true.  Can take the
 * depth used when generating items from the argument, "depth", of type
 * number in cmd.
 *
 * Generate a lot of fake items and see if they are of the same type (tval and
 * sval).  Then compare modifiers, AC, to-hit, and to-dam to get whether the
 * fake item matches (all modifiers are the same as are the AC, to-hit, and
 * to-dam), is better (all modifiers, AC, to-hit, and to-dam are not less
 * than on the target item and at least one of those is more than the matching
 * attribute on the target item), is worse (all modifiers, AC, to-hit, and
 * to-dam are not more than on the target item and at least one of those is
 * less than the matching attribute on the target item), or is different.
 * Curses, brands, slays, and other properties not treated as modifiers have
 * no effect on that classification.  A comment left about this procedure in
 * wiz-debug.c was "HINT: This is *very* useful for balancing the game!".
 */
/* This is the maximum number of rolls to use. */
void do_cmd_wiz_stat_item(struct command *cmd)
{
 const char *repfmt =
  "Rolls: %ld, Matches: %ld, Better: %ld, Worse: %ld, Other: %ld";
 int level = player->depth;
 int treasure_choice = 0;
 bool good = false, great = false;
 long matches = 0, better = 0, worse = 0, other = 0;
 long n = 100000;
 struct object *obj;
 long i;
 const char *quality;
 /* Get the target item for comparison. */
 if (cmd_get_arg_item(cmd, "item", &obj) != CMD_OK) {
  if (!get_item(&obj, "Compare with which item? ",
    "You have nothing to compare.", cmd->code,
    NULL, (USE_EQUIP | USE_INVEN | USE_QUIVER |
    USE_FLOOR))) {
   return;
  }
  cmd_set_arg_item(cmd, "item", obj);
 }
 /* Display item. */
 wiz_display_item(obj, true, player);
 /* Get what kind of treasure to generate. */
 if (cmd_get_arg_choice(cmd, "choice", &treasure_choice) != CMD_OK) {
  char ch;
  if (!get_com("Roll for [n]ormal, [g]ood, or [e]xcellent treasure? ", &ch)) {
   return;
  }
  if (ch == 'n' || ch == 'N') {
   treasure_choice = 0;
  } else if (ch == 'g' || ch == 'G') {
   treasure_choice = 1;
  } else if (ch == 'e' || ch == 'E') {
   treasure_choice = 2;
  } else {
   return;
  }
  cmd_set_arg_choice(cmd, "choice", treasure_choice);
 }
 if (treasure_choice == 0) {
  good = false;
  great = false;
  quality = "normal";
 } else if (treasure_choice == 1) {
  good = true;
  great = false;
  quality = "good";
 } else if (treasure_choice == 2) {
  good = true;
  great = true;
  quality = "excellent";
 } else {
  return;
 }
 /* Get the depth to use when generating treasure. */
 if (cmd_get_arg_number(cmd, "depth", &level) != CMD_OK) {
  char prompt[80], s[80];
  strnfmt(prompt, sizeof(prompt), "Depth for treasure (0-%d): ",
   z_info->max_depth - 1);
  /* Set default. */
  strnfmt(s, sizeof(s), "%d", player->depth);
  if (!get_string(prompt, s, sizeof(s)) ||
    !get_int_from_string(s, &level) || level < 0 ||
    level >= z_info->max_depth) {
   return;
  }
  cmd_set_arg_number(cmd, "depth", level);
 }
 if (level < 0 || level >= z_info->max_depth) {
  return;
 }
 /* Give feedback about what's going to be done. */
 msg("Creating a lot of %s items.  Base level = %d.", quality, level);
 event_signal(EVENT_MESSAGE_FLUSH);
 for (i = 0; i < n; i++) {
  bool ismatch = true, isbetter = true, isworse = true;
  struct object *test_obj;
  int j;
  /* Output every few rolls. */
  if (i < 100 || i % 100 == 0) {
   ui_event e;
   /* Do not wait. */
   inkey_scan = SCAN_INSTANT;
   /* Allow interrupt */
   e = inkey_ex();
   if (e.type != EVT_NONE) {
    event_signal(EVENT_INPUT_FLUSH);
    break;
   }
   /* Dump the stats. */
   prt(format(repfmt, i, matches, better, worse, other),
    0, 0);
   Term_fresh();
  }
  /* Create an object. */
  test_obj = make_object(cave, level, good, great, NULL);
  /*
		 * Allow multiple artifacts, because breaking the game is OK
		 * here.
		 */
  if (obj->artifact) {
   mark_artifact_created(obj->artifact, false);
  }
  /* Check for failures to generate an object. */
  if (!test_obj) continue;
  /* Test for same tval and sval. */
  if (obj->tval != test_obj->tval ||
    obj->sval != test_obj->sval) {
   object_delete(cave, player->cave, &test_obj);
   continue;
  }
  /* Check the modifiers. */
  for (j = 0; j < OBJ_MOD_MAX; j++) {
   if (test_obj->modifiers[j] != obj->modifiers[j]) {
    ismatch = false;
    if (test_obj->modifiers[j] < obj->modifiers[j]) {
     isbetter = false;
    } else {
     isworse = false;
    }
   }
  }
  /* Check for match over all the tested properties. */
  if (ismatch && test_obj->att == obj->att &&
    test_obj->ds == obj->ds &&
    test_obj->dd == obj->dd &&
    test_obj->evn == obj->evn &&
    test_obj->ps == obj->ps &&
    test_obj->pd == obj->pd) {
   ++matches;
  /* Check for same or better over all the tested properties. */
  } else if (isbetter && test_obj->att > obj->att &&
    test_obj->ds > obj->ds &&
    test_obj->dd > obj->dd &&
    test_obj->evn > obj->evn &&
    test_obj->ps > obj->ps &&
    test_obj->pd > obj->pd) {
   ++better;
  /* Check for same or worse over all the tested properties. */
  } else if (isworse && test_obj->att <= obj->att &&
    test_obj->ds <= obj->ds &&
    test_obj->dd <= obj->dd &&
    test_obj->evn <= obj->evn &&
    test_obj->ps <= obj->ps &&
    test_obj->pd <= obj->pd) {
   ++worse;
  /* Everything else is merely different. */
  } else {
   ++other;
  }
  /* Nuke the test object. */
  object_delete(cave, player->cave, &test_obj);
 }
 /* Final dump */
 msg(repfmt, i, matches, better, worse, other);
 event_signal(EVENT_MESSAGE_FLUSH);
 /* Hack -- normally only make a single artifact */
 if (obj->artifact) {
  mark_artifact_created(obj->artifact, true);
 }
}
/**
 * Summon a specific monster (CMD_WIZ_SUMMON_NAMED).  Can take the index
 * of the monster to summon from the argument, "index", of type number in cmd.
 */
void do_cmd_wiz_summon_named(struct command *cmd)
{
 int r_idx, i = 0;
 struct monster_race *r = NULL;
 struct monster_group_info info = { 0, 0 };
 if (cmd_get_arg_number(cmd, "index", &r_idx) == CMD_OK) {
  if (r_idx > 0 && r_idx < z_info->r_max) {
   r = &r_info[r_idx];
  }
 } else {
  char s[80] = "";
  if (!get_string("Summon which monster? ", s, sizeof(s))) return;
  /* See if an index was entered */
  if (get_int_from_string(s, &r_idx)) {
   if (r_idx > 0 && r_idx < z_info->r_max) {
    r = &r_info[r_idx];
   }
  } else {
   /* If not, find by name */
   r = lookup_monster(s);
  }
  if (r != NULL) {
   cmd_set_arg_number(cmd, "index", r->ridx);
  }
 }
 if (r == NULL) {
  msg("No monster found.");
  return;
 }
 /* Try 10 times */
 while (1) {
  struct loc grid;
  /* Pick an empty location. */
  if (i >= 10 || scatter_ext(cave, &grid, 1, player->grid, 1,
    true, square_isempty) == 0) {
   msg("Could not place monster.");
   break;
  }
  /* Try to place. */
  if (place_new_monster(cave, grid, r, true, true,
    info, ORIGIN_DROP_WIZARD)) {
   player->upkeep->redraw |= PR_MAP | PR_MONLIST;
   break;
  }
  ++i;
 }
}
/**
 * Summon random monsters near the player (CMD_WIZ_SUMMON_RANDOM).  Can take
 * the number to summon from the argument, "quantity", of type number in cmd.
 */
void do_cmd_wiz_summon_random(struct command *cmd)
{
 int n, i;
 if (cmd_get_arg_number(cmd, "quantity", &n) != CMD_OK) {
  n = get_quantity("How many monsters? ", 40);
  if (n < 1) n = 1;
  cmd_set_arg_number(cmd, "quantity", n);
 }
 for (i = 0; i < n; i++) {
  effect_simple(EF_SUMMON, source_player(), "1",
   0, 0, 0, NULL);
 }
}
/**
 * Teleport to the requested position (CMD_WIZ_TELEPORT_TO).  Can take the
 * position from the argument, "point", of type point in cmd.
 */
void do_cmd_wiz_teleport_to(struct command *cmd)
{
 struct loc grid;
 if (cmd_get_arg_point(cmd, "point", &grid) != CMD_OK) {
  /* Use the targeting function. */
  if (!target_set_interactive(TARGET_LOOK, loc(-1, -1), 0)) return;
  /* Grab the target coordinates. */
  target_get(&grid);
  /* Record in the command to facilitate repetition. */
  cmd_set_arg_point(cmd, "point", grid);
 }
 /* Test for passable terrain. */
 if (square_ispassable(cave, grid)) {
  /* Teleport to the target */
  effect_simple(EF_TELEPORT_TO, source_player(), "0", 0, 0, 0, NULL);
 } else {
  msg("The square you are aiming for is impassable.");
 }
}
/**
 * Tweak an item:  make it ego or artifact, give values for modifiers, att,
 * evn, or dice.  Can take the item to modify from the argument, "item", of
 * type item in cmd.  Takes whether to update player information from the
 * argument, "update", of type choice in cmd.
 */
void do_cmd_wiz_tweak_item(struct command *cmd)
{
 static const char *obj_mods[] = {
/**
 * \file src/list-stats.h
 * \brief player stats
 *
 * Changing stat order or making new ones will break savefiles. Stats
 * below start from 0 on line 14, so a stat's sequence number is its line
 * number minus 14.
 *
 * Each stat has a matching sustain in src/list-object-flags.h, which should
 * be at the same index in that file as the stat in this file.
 *
 * Stat properties are defined in lib/gamedata/object_property.txt
 */
"STR",
"DEX",
"CON",
"GRA",
/**
 * \file src/list-skills.h
 * \brief player skills
 *
 * Changing skill order or making new ones will break savefiles. Skills
 * below start from 0 on line 11, so a skill's sequence number is its line
 * number minus 11.
 *
 * Skill properties are not defined in lib/gamedata/object_property.txt
 */
"MELEE",
"ARCHERY",
"EVASION",
"STEALTH",
"PERCEPTION",
"WILL",
"SMITHING",
"SONG",
/**
 * \file list-object-modifiers.h
 * \brief object modifiers (plusses and minuses) for all objects
 *
 * Changing modifier order will break savefiles. Modifiers below start from
 * 13 on line 12 (stats and skills count as modifiers, and are included from
 * list-stats.h and list-skills.h), so a modifier's sequence number is its line
 * number plus 1.
 *
 * Modifier properties are defined in lib/gamedata/object_property.txt
 */
"DAMAGE_SIDES",
"TUNNEL",

  NULL
 };
 struct object *obj;
 char tmp_val[80];
 int i, val;
 int update = 0;
 /* Get the item to tweak. */
 if (cmd_get_arg_item(cmd, "item", &obj) != CMD_OK) {
  if (!get_item(&obj, "Tweak which item? ",
    "You have nothing to tweak.", cmd->code,
    NULL, (USE_EQUIP | USE_INVEN | USE_QUIVER |
    USE_FLOOR))) {
   return;
  }
  cmd_set_arg_item(cmd, "item", obj);
 }
 /* Hack -- leave artifacts alone */
 if (obj->artifact) return;
 /*
	 * Check for whether updating the player information or let
	 * do_cmd_wiz_play_item() handle it.
	 */
 if (cmd_get_arg_choice(cmd, "update", &update) != CMD_OK) {
  update = 1;
 }
 /* Get ego name. */
 if (obj->ego) {
  strnfmt(tmp_val, sizeof(tmp_val), "%s", obj->ego->name);
 } else {
  strnfmt(tmp_val, sizeof(tmp_val), "-1");
 }
 if (!get_string("Enter ego item: ", tmp_val, sizeof(tmp_val))) return;
 /* Accept index or name */
 if (get_int_from_string(tmp_val, &val)) {
  if (val >= 0 && val < z_info->e_max) {
   obj->ego = &e_info[val];
  } else {
   obj->ego = NULL;
  }
 } else {
  obj->ego = lookup_ego_item(tmp_val, obj->tval, obj->sval);
 }
 if (obj->ego) {
  struct ego_item *e = obj->ego;
  struct object *prev = obj->prev;
  struct object *next = obj->next;
  struct object *known = obj->known;
  uint16_t oidx = obj->oidx;
  struct loc grid = obj->grid;
  bitflag notice = obj->notice;
  object_prep(obj, obj->kind, player->depth, RANDOMISE);
  obj->ego = e;
  obj->prev = prev;
  obj->next = next;
  obj->known = known;
  obj->oidx = oidx;
  obj->grid = grid;
  obj->notice = notice;
  ego_apply_magic(obj, player->depth);
 }
 wiz_display_item(obj, true, player);
 /* Get artifact name */
 if (obj->artifact) {
  strnfmt(tmp_val, sizeof(tmp_val), "%s", obj->artifact->name);
 } else {
  strnfmt(tmp_val, sizeof(tmp_val), "0");
 }
 if (!get_string("Enter new artifact: ", tmp_val, sizeof(tmp_val))) {
  if (update) {
   wiz_play_item_standard_upkeep(player, obj);
  } else {
   wiz_play_item_notify_changed();
  }
  return;
 }
 /* Accept index or name */
 if (get_int_from_string(tmp_val, &val)) {
  if (val > 0 && val < z_info->a_max) {
   obj->artifact = &a_info[val];
  } else {
   obj->artifact = NULL;
  }
 } else {
  obj->artifact = lookup_artifact_name(tmp_val);
 }
 if (obj->artifact) {
  const struct artifact *a = obj->artifact;
  struct object *prev = obj->prev;
  struct object *next = obj->next;
  struct object *known = obj->known;
  uint16_t oidx = obj->oidx;
  struct loc grid = obj->grid;
  bitflag notice = obj->notice;
  obj->ego = NULL;
  object_prep(obj, obj->kind, obj->artifact->level, RANDOMISE);
  obj->artifact = a;
  obj->prev = prev;
  obj->next = next;
  obj->known = known;
  obj->oidx = oidx;
  obj->grid = grid;
  obj->notice = notice;
  copy_artifact_data(obj, obj->artifact);
 }
 wiz_display_item(obj, true, player);
 for (i = 0; i < OBJ_MOD_MAX; i++) {
  do { char prompt[80]; strnfmt(prompt, sizeof(prompt), "Enter new %s setting: ", obj_mods[i]); strnfmt(tmp_val, sizeof(tmp_val), "%d", obj->modifiers[i]); if (!get_string(prompt, tmp_val, sizeof(tmp_val))) { if (update) { wiz_play_item_standard_upkeep(player, obj); } else { wiz_play_item_notify_changed(); } return; } if (get_int_from_string(tmp_val, &val)) { obj->modifiers[i] = val; wiz_display_item(obj, true, player); }} while (0);
 }
 do { char prompt[80]; strnfmt(prompt, sizeof(prompt), "Enter new %s setting: ", "Attack"); strnfmt(tmp_val, sizeof(tmp_val), "%d", obj->att); if (!get_string(prompt, tmp_val, sizeof(tmp_val))) { if (update) { wiz_play_item_standard_upkeep(player, obj); } else { wiz_play_item_notify_changed(); } return; } if (get_int_from_string(tmp_val, &val)) { obj->att = val; wiz_display_item(obj, true, player); }} while (0);
 do { char prompt[80]; strnfmt(prompt, sizeof(prompt), "Enter new %s setting: ", "Damage dice"); strnfmt(tmp_val, sizeof(tmp_val), "%d", obj->dd); if (!get_string(prompt, tmp_val, sizeof(tmp_val))) { if (update) { wiz_play_item_standard_upkeep(player, obj); } else { wiz_play_item_notify_changed(); } return; } if (get_int_from_string(tmp_val, &val)) { obj->dd = val; wiz_display_item(obj, true, player); }} while (0);
 do { char prompt[80]; strnfmt(prompt, sizeof(prompt), "Enter new %s setting: ", "Damage sides"); strnfmt(tmp_val, sizeof(tmp_val), "%d", obj->ds); if (!get_string(prompt, tmp_val, sizeof(tmp_val))) { if (update) { wiz_play_item_standard_upkeep(player, obj); } else { wiz_play_item_notify_changed(); } return; } if (get_int_from_string(tmp_val, &val)) { obj->ds = val; wiz_display_item(obj, true, player); }} while (0);
 do { char prompt[80]; strnfmt(prompt, sizeof(prompt), "Enter new %s setting: ", "Evasion"); strnfmt(tmp_val, sizeof(tmp_val), "%d", obj->evn); if (!get_string(prompt, tmp_val, sizeof(tmp_val))) { if (update) { wiz_play_item_standard_upkeep(player, obj); } else { wiz_play_item_notify_changed(); } return; } if (get_int_from_string(tmp_val, &val)) { obj->evn = val; wiz_display_item(obj, true, player); }} while (0);
 do { char prompt[80]; strnfmt(prompt, sizeof(prompt), "Enter new %s setting: ", "Protection dice"); strnfmt(tmp_val, sizeof(tmp_val), "%d", obj->pd); if (!get_string(prompt, tmp_val, sizeof(tmp_val))) { if (update) { wiz_play_item_standard_upkeep(player, obj); } else { wiz_play_item_notify_changed(); } return; } if (get_int_from_string(tmp_val, &val)) { obj->pd = val; wiz_display_item(obj, true, player); }} while (0);
 do { char prompt[80]; strnfmt(prompt, sizeof(prompt), "Enter new %s setting: ", "Protection sides"); strnfmt(tmp_val, sizeof(tmp_val), "%d", obj->ps); if (!get_string(prompt, tmp_val, sizeof(tmp_val))) { if (update) { wiz_play_item_standard_upkeep(player, obj); } else { wiz_play_item_notify_changed(); } return; } if (get_int_from_string(tmp_val, &val)) { obj->ps = val; wiz_display_item(obj, true, player); }} while (0);
 if (update) {
  wiz_play_item_standard_upkeep(player, obj);
 } else {
  wiz_play_item_notify_changed();
 }
}
/**
 * Make the player ignorant of a monster race's attributes
 * (CMD_WIZ_WIPE_RECALL).  Can take the race from the argument, "index", of
 * type number in cmd.  If that index is -1, make the player ignorant of all
 * races.
 */
void do_cmd_wiz_wipe_recall(struct command *cmd)
{
 int r_idx = z_info->r_max;
 if (cmd_get_arg_number(cmd, "index", &r_idx) != CMD_OK) {
  char s[80] = "";
  char c;
  if (!get_com("Wipe recall for [a]ll monsters or [s]pecific monster? ", &c)) return;
  if (c == 'a' || c == 'A') {
   r_idx = -1;
  } else if (c == 's' || c == 'S') {
   if (!get_string("Which monster? ", s, sizeof(s)))
    return;
   if (!get_int_from_string(s, &r_idx)) {
    const struct monster_race *race =
     lookup_monster(s);
    if (race) {
     r_idx = race->ridx;
    }
   }
  } else {
   return;
  }
  cmd_set_arg_number(cmd, "index", r_idx);
 }
 if (r_idx >= 0 && r_idx < z_info->r_max) {
  const struct monster_race *race = &r_info[r_idx];
  wipe_monster_lore(race, get_lore(race));
 } else if (r_idx == -1) {
  int i;
  for (i = 0; i < z_info->r_max; i++) {
   wipe_monster_lore(&r_info[i], &l_list[i]);
  }
 } else {
  msg("No monster found.");
 }
}
/**
 * Wizard light the level (CMD_WIZ_WIZARD_LIGHT).  Takes no arguments from cmd.
 */
void do_cmd_wiz_wizard_light(struct command *cmd)
{
 wiz_light(cave, player);
}
/**
 * \file combat.c
 * \brief All forms of combat
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Knock monster or player backwards
 */
bool knock_back(struct loc grid1, struct loc grid2)
{
    bool knocked = false;
    int mod, d, i;
    /* Default knocking back a monster */
    struct monster *mon = square_monster(cave, grid2);
 /* The location to get knocked to */
    struct loc grid3;
    /* Determine the main direction from the source to the target */
    int dir = rough_direction(grid1, grid2);
    /* Extract the next grid in the direction */
    struct loc next = loc_sum(grid2, ddgrid[dir]);
    /* First try to knock it straight back */
    if (!square_iswall(cave, next) && (square_monster(cave, next) == NULL)) {
        grid3 = next;
        knocked = true;
    } else {
  /* Then try the adjacent directions */
        /* Randomize clockwise or anticlockwise */
        mod = one_in_(2) ? -1 : +1;
        /* Try both directions */
        for (i = 0; i < 2; i++) {
            d = cycle[chome[dir_from_delta(ddy[dir], ddx[dir])] + mod];
            grid3 = loc_sum(grid2, ddgrid[d]);
            if (!square_iswall(cave, grid3) &&
    (square_monster(cave, next) == NULL)) {
                knocked = true;
                break;
            }
            /* switch direction */
            mod *= -1;
        }
    }
    /* Make the target skip a turn */
    if (knocked) {
        if (mon) {
            mon->skip_next_turn = true;
            /* Actually move the monster */
            monster_swap(grid2, grid3);
        } else {
            msg("You are knocked back.");
            player->upkeep->knocked_back = true;
            /* Actually move the player */
            monster_swap(grid2, grid3);
            /* Cannot stay in the air */
            player->upkeep->leaping = false;
            /* Make some noise when landing */
   player->stealth_score -= 5;
            /* Set off traps, etc */
   player_handle_post_move(player, true, true);
        }
    }
    return knocked;
}
/**
 * Determine the result of a skill check.
 * (1d10 + skill) - (1d10 + difficulty)
 * Results <= 0 count as fails.
 * Results > 0 are successes.
 *
 * There is a fake skill check in monsters_hear (where player roll is
 * used once for all monsters) so if something changes here, remember to change
 * it there.
 */
int skill_check(struct source attacker, int skill, int difficulty,
    struct source defender)
{
 int skill_total;
 int difficulty_total;
 /* Bonuses against your enemy of choice */
 if ((attacker.what == SRC_PLAYER) && (defender.what == SRC_MONSTER)) {
  struct monster *mon = cave_monster(cave, defender.which.monster);
  skill += player_bane_bonus(player, mon);
 }
 if ((defender.what == SRC_PLAYER) && (attacker.what == SRC_MONSTER)) {
  struct monster *mon = cave_monster(cave, attacker.which.monster);
  difficulty += player_bane_bonus(player, mon);
    }
    /* Elf-bane bonus against you */
 if ((attacker.what == SRC_PLAYER) && (defender.what == SRC_MONSTER)) {
  struct monster *mon = cave_monster(cave, defender.which.monster);
  difficulty += monster_elf_bane_bonus(mon, player);
 }
 if ((defender.what == SRC_PLAYER) && (attacker.what == SRC_MONSTER)) {
  struct monster *mon = cave_monster(cave, attacker.which.monster);
  skill += monster_elf_bane_bonus(mon, player);
    }
 /* The basic rolls */
 skill_total = randint1(10) + skill;
 difficulty_total = randint1(10) + difficulty;
 /* Alternate rolls for dealing with the player curse */
 if (player->cursed) {
  int alt_total;
  if (attacker.what == SRC_PLAYER) {
   alt_total = randint1(10) + skill;
   skill_total = MIN(skill_total, alt_total);
  }
  if (defender.what == SRC_PLAYER) {
   alt_total = randint1(10) + difficulty;
   difficulty_total = MIN(difficulty_total, alt_total);
  }
 }
 /* Debugging message */
 if (OPT(player, cheat_skill_rolls)) {
  msg("{%d+%d v %d+%d = %d}.", skill_total - skill, skill,
   difficulty_total - difficulty, difficulty,
   skill_total - difficulty_total);
 }
 return skill_total - difficulty_total;
}
/**
 * Determine the result of an attempt to hit an opponent.
 * Results <= 0 count as misses.
 * Results > 0 are hits and, if high enough, are criticals.
 *
 * The monster is the creature doing the attacking. 
 * This is used in displaying the attack roll details.
 * attacker_vis is whether the attacker is visible.
 * this is used in displaying the attack roll details.
 */
int hit_roll(int att, int evn, struct source attacker, struct source defender,
    bool display_roll)
{
 int attack_score, attack_score_alt;
 int evasion_score, evasion_score_alt;
 bool non_player_visible;
 /* Determine the visibility for the combat roll window */
 if (attacker.what == SRC_PLAYER) {
  if ((defender.what == SRC_NONE) || (defender.what == SRC_TRAP)) {
   non_player_visible = true;
  } else {
   struct monster *mon = cave_monster(cave, defender.which.monster);
   assert(mon);
   non_player_visible = monster_is_visible(mon);
  }
 } else {
  if ((attacker.what == SRC_NONE) || (attacker.what == SRC_TRAP)) {
   non_player_visible = true;
  } else {
   struct monster *mon = cave_monster(cave, attacker.which.monster);
   assert(mon);
   non_player_visible = monster_is_visible(mon);
  }
 }
 /* Roll the dice... */
 attack_score = randint1(20) + att;
 attack_score_alt = randint1(20) + att;
 evasion_score = randint1(20) + evn;
 evasion_score_alt = randint1(20) + evn;
 /* Take the worst of two rolls for cursed players */
 if (player && player->cursed) {
  if (attacker.what == SRC_PLAYER) {
   attack_score = MIN(attack_score, attack_score_alt);
  } else {
   evasion_score = MIN(evasion_score, evasion_score_alt);
  }
 }
 /* Set the information for the combat roll window */
 if (display_roll) {
  event_signal_combat_attack(EVENT_COMBAT_ATTACK, attacker, defender,
           non_player_visible, att, attack_score - att,
           evn, evasion_score - evn, true);
 }
 return (attack_score - evasion_score);
}
/**
 * Determines the bonus for the ability 'concentration' and updates some
 * related variables.
 */
static int concentration_bonus(struct player *p, struct loc grid)
{
 int bonus = 0;
 int midx = square_monster(cave, grid) ? square_monster(cave, grid)->midx :0;
 /* Deal with 'concentration' ability */
 if (player_active_ability(p, "Concentration") &&
  (p->last_attack_m_idx == midx)) {
  bonus = MIN(p->consecutive_attacks,
     p->state.skill_use[SKILL_PERCEPTION] / 2);
 }
 /* If the player is not engaged with this monster, reset the attack count
	 * and monster */
 if (p->last_attack_m_idx != midx) {
  p->consecutive_attacks = 0;
  p->last_attack_m_idx = midx;
 }
 return bonus;
}
/**
 * Determines the bonus for the ability 'focused attack'.
 */
static int focused_attack_bonus(struct player *p)
{
 /* Focused attack */
 if (p->focused) {
  p->focused = false;
  if (player_active_ability(p, "Focused Attack")) {
   return (p->state.skill_use[SKILL_PERCEPTION] / 2);
  }
 }
 return 0;
}
/**
 * Determines the bonus for the ability 'master hunter'.
 */
static int master_hunter_bonus(struct player *p, struct monster *mon)
{
 struct monster_lore *lore = get_lore(mon->race);
 /* Master hunter bonus */
 if (player_active_ability(p, "Master Hunter")) {
  return MIN(lore->pkills, p->state.skill_use[SKILL_PERCEPTION] / 4);
 }
 return 0;
}
/**
 * Determines the player's attack based on all the relevant attributes and
 * modifiers.
 */
int total_player_attack(struct player *p, struct monster *mon, int base)
{
 int att = base;
 /* Reward concentration ability (if applicable) */
 att += concentration_bonus(p, mon->grid);
 /* Reward focused attack ability (if applicable) */
 att += focused_attack_bonus(p);
 /* reward bane ability (if applicable) */
 att += player_bane_bonus(p, mon);
 /* Reward master hunter ability (if applicable) */
 att += master_hunter_bonus(p, mon);
 /* Penalise distance -- note that this penalty will equal 0 in melee */
 att -= distance(p->grid, mon->grid) / 5;
 /* Halve attack score for certain situations (and only halve positive
	 * scores!) */
 if (att > 0) {
  /* Penalise the player if (s)he can't see the monster */
  if (!monster_is_visible(mon)) att /= 2;
  /* Penalise the player if (s)he is in a pit or web */
  if (square_ispit(cave, p->grid) || square_iswebbed(cave, p->grid)) {
   att /= 2;
  }
 }
 return att;
}
/**
 * Determines the player's evasion based on all the relevant attributes and
 * modifiers.
 */
int total_player_evasion(struct player *p, struct monster *mon, bool archery)
{
 int evn = p->state.skill_use[SKILL_EVASION];
 /* Reward successful use of the dodging ability  */
 evn += player_dodging_bonus(p);
 /* Reward successful use of the bane ability */
 evn += player_bane_bonus(p, mon);
 /* Halve evasion for certain situations (and only positive evasion!) */
 if (evn > 0) {
  /* Penalise the player if (s)he can't see the monster */
  if (!monster_is_visible(mon)) {
   evn /= 2;
  }
  /* Penalise targets of archery attacks */
  if (archery) {
   evn /= 2;
  }
  /* Penalise the player if (s)he is in a pit or web */
  if (square_ispit(cave, p->grid) || square_iswebbed(cave, p->grid)) {
   evn /= 2;
  }
 }
 return evn;
}
/**
 * Light hating monsters get a penalty to hit/evn if the player's
 * square is too bright.
 */
static int light_penalty(const struct monster *mon)
{
 int penalty = 0;
 if (rf_has(mon->race->flags, RF_HURT_LIGHT)) {
  penalty = square_light(cave, mon->grid) - 2;
  if (penalty < 0) penalty = 0;
 }
 return penalty;
}
/**
 * Determines a monster's attack score based on all the relevant attributes
 * and modifiers.
 */
int total_monster_attack(struct player *p, struct monster *mon, int base)
{
 int att = base;
 /* Penalise stunning  */
 if (mon->m_timed[MON_TMD_STUN]) {
  att -= 2;
 }
 /* Penalise being in bright light for light-averse monsters */
 att -= light_penalty(mon);
 /* Reward surrounding the player */
 att += overwhelming_att_mod(p, mon);
 /* Penalise distance */
 att -= distance(p->grid, mon->grid) / 5;
    /* Elf-bane bonus */
    att += monster_elf_bane_bonus(mon, p);
 /* Halve attack score for certain situations (and only positive scores!) */
 if (att > 0) {
  /* Penalise monsters who can't see the player */
  if ((mon->race->light > 0) && strchr("@G", mon->race->d_char) &&
   (square_light(cave, p->grid) <= 0)) {
   att /= 2;
  }
 }
 return att;
}
/**
 * Determines a monster's evasion based on all the relevant attributes and
 * modifiers.
 */
int total_monster_evasion(struct player *p, struct monster *mon, bool archery)
{
 struct monster_race *race = mon->race;
 int evn = race->evn;
 bool unseen = false;
 /* All sleeping monsters have -5 total evasion */
 if (mon->alertness < ALERTNESS_UNWARY) return -5;
 /* Penalise stunning */
 if (mon->m_timed[MON_TMD_STUN]) {
  evn -= 2;
 }
 /* Penalise being in bright light for light-averse monsters */
 evn -= light_penalty(mon);
    /* Elf-bane bonus */
    evn += monster_elf_bane_bonus(mon, p);
    /* Halve evasion for certain situations (and only halve positive evasion!)*/
 if (evn > 0) {
  /* Check if player is unseen */
  if ((race->light > 0) && strchr("@G", race->d_char) &&
   (square_light(cave, p->grid) <= 0)) {
   unseen = true;
  }
  /* Penalise unwary monsters, or those who can't see the player */
  if (unseen || (mon->alertness < ALERTNESS_ALERT)) {
   evn /= 2;
  }
  /* Penalise targets of archery attacks */
  if (archery) {
   evn /= 2;
  }
 }
 return evn;
}
/**
 * Monsters are already given a large set penalty for being asleep
 * (total evasion mod of -5) and unwary (evasion score / 2),
 * but we also give a bonus for high stealth characters who have ASSASSINATION.
 */
int stealth_melee_bonus(const struct monster *mon)
{
 int stealth_bonus = 0;
 if (player_active_ability(player, "Assassination")) {
  if ((mon->alertness < ALERTNESS_ALERT) && monster_is_visible(mon) &&
   !player->timed[TMD_CONFUSED]) {
   stealth_bonus = player->state.skill_use[SKILL_STEALTH];
  }
 }
 return stealth_bonus;
}
/**
 * Give a bonus to attack the player depending on the number of adjacent
 * monsters.
 * This is +1 for monsters near the attacker or to the sides,
 * and +2 for monsters in the three positions behind the player:
 * 
 * 1M1  M11
 * 1@1  1@2
 * 222  122
 *
 * We should lessen this with the crowd fighting ability
 */
int overwhelming_att_mod(struct player *p, struct monster *mon)
{
 int mod = 0;
    int dir;
 int dy, dx;
 int py = p->grid.y;
 int px = p->grid.x;
    /* Determine the main direction from the player to the monster */
    dir = rough_direction(p->grid, mon->grid);
    /* Extract the deltas from the direction */
    dy = ddy[dir];
    dx = ddx[dir];
 /* If monster in an orthogonal direction   753 */
 /*                                         8@M */
 /*                                         642 */
 if (dy * dx == 0) {
  /* Increase modifier for monsters engaged with the player... */
  if (square_monster(cave, loc(px - dy + dx, py + dx + dy))) mod++;/* 2 */
  if (square_monster(cave, loc(px + dy + dx, py - dx + dy))) mod++;/* 3 */
  if (square_monster(cave, loc(px - dy , py + dx ))) mod++;/* 4 */
  if (square_monster(cave, loc(px + dy , py - dx ))) mod++;/* 5 */
  /* ...especially if they are behind the player */
  if (square_monster(cave, loc(px - dy - dx, py + dx - dy))) mod++;/* 6 */
  if (square_monster(cave, loc(px + dy - dx, py - dx - dy))) mod++;/* 7 */
  if (square_monster(cave, loc(px - dx, py - dy))) mod++;/* 8 */
 } else {
  /* If monster in a diagonal direction   875 */
  /*                                      6@3 */
  /*                                      42M */
  /* Increase modifier for monsters engaged with the player... */
  if (square_monster(cave, loc(px , py + dy))) mod++; /* 2 */
  if (square_monster(cave, loc(px + dx, py ))) mod++; /* 3 */
  if (square_monster(cave, loc(px - dy, py + dx))) mod++; /* 4 */
  if (square_monster(cave, loc(px + dy, py - dx))) mod++; /* 5 */
  /* ...especially if they are behind the player */
  if (square_monster(cave, loc(px , py - dy))) mod++; /* 6 */
  if (square_monster(cave, loc(px - dx, py ))) mod++; /* 7 */
  if (square_monster(cave, loc(px - dx, py - dy))) mod++; /* 8 */
 }
 /* Adjust for crowd fighting ability */
 if (player_active_ability(p, "Crowd Fighting")) {
  mod /= 2;
 }
 return (mod);
}
/**
 * Determines the number of bonus dice from a (potentially) critical hit
 *
 * bonus of 1 die for every (6 + weight_in_pounds) over what is needed.
 * (using rounding at 0.5 instead of always rounding up)
 *
 * Thus for a Dagger (0.8lb):         7, 14, 20, 27...  (6+weight)
 *            Short Sword (1.5lb):    8, 15, 23, 30...
 *            Long Sword (3lb):       9, 18, 27, 35...
 *            Bastard Sword (4lb):   10, 20, 30, 40...
 *            Great Sword (7lb):     13, 26, 39, 52...
 *            Shortbow (2lb):         8, 16, 24, 32...
 *            Longbow (3lb):          9, 18, 27, 36...
 *            m 1dX (2lb):            8, 16, 24, 32...
 *            m 2dX (4lb):           10, 20, 30, 40...
 *            m 3dX (6lb):           12, 24, 36, 48...
 *
 * (old versions)
 * Thus for a Dagger (0.8lb):         9, 13, 17, 21...  5 then (3+weight)
 *            Short Sword (1.5lb):   10, 14, 19, 23...
 *            Long Sword (3lb):      11, 17, 23, 29...
 *            Bastard Sword (4lb):   12, 19, 26, 33...
 *            Great Sword (7lb):     15, 25, 35, 45...
 *            Shortbow (2lb):        10, 15, 20, 25...
 *            Longbow (3lb):         11, 17, 23, 29...
 *            m 1dX (2lb):           10, 15, 20, 25...
 *            m 2dX (4lb):           12, 19, 26, 33...
 *            m 3dX (6lb):           14, 23, 32, 41...
 * Thus for a Dagger (0.8lb):        11, 12, 13, 14...  (10 then weightx)
 *            Short Sword (1.5lb):   12, 13, 15, 16...
 *            Long Sword (3lb):      13, 16, 19, 22...
 *            Bastard Sword (4lb):   14, 18, 22, 26...
 *            Great Sword (7lb):     17, 24, 31, 38...
 *            Shortbow (2lb):        12, 14, 16, 18...
 *            Longbow (3lb):         13, 16, 19, 22...
 * Thus for a Dagger (0.8lb):         6, 12, 18, 24...  (5+weight)
 *            Short Sword (1.5lb):    7, 13, 20, 26...
 *            Long Sword (3lb):       8, 16, 24, 32...
 *            Bastard Sword (4lb):    9, 18, 27, 36...
 *            Great Sword (7lb):     12, 24, 36, 48...
 *            Shortbow (2lb):         7, 14, 21, 28...
 *            Longbow (3lb):          8, 16, 24, 32...
 * Thus for a Dagger (0.8lb):         4,  8, 12, 16...  (3+weight)
 *            Short Sword (1.5lb):    5,  9, 14, 18...
 *            Long Sword (3lb):       6, 12, 18, 25...
 *            Bastard Sword (4lb):    7, 14, 21, 28...
 *            Great Sword (7lb):     10, 20, 30, 40...
 *            Shortbow (2lb):         5, 10, 15, 20...
 *            Longbow (3lb):          6, 12, 18, 24...
 * Thus for a Dagger (0.8lb):         8, 12, 15, 18...  (old1)
 *            Short Sword (1.5lb):    9, 14, 18, 23...
 *            Long Sword (3lb):      11, 17, 23, 29...
 *            Bastard Sword (3.5lb): 11, 18, 24, 31...
 *            Great Sword (7lb):     15, 25, 35, 45...
 * Thus for a Dagger (0.8lb):         7, 10, 12, 14...  (old2)
 *            Short Sword (1.5lb):    8, 12, 15, 19...
 *            Long Sword (3lb):      10, 15, 20, 25...
 *            Bastard Sword (3.5lb): 10, 16, 21, 27...
 *            Great Sword (7lb):     14, 23, 32, 41...
 */
int crit_bonus(struct player *p, int hit_result, int weight,
      const struct monster_race *race, int skill_type, bool thrown)
{
 int crit_bonus_dice;
 int crit_separation = 70;
 /* When attacking a monster... */
 if (race) {
  /* Changes to melee criticals */
  if (skill_type == SKILL_MELEE) {
   /* Can have improved criticals for melee */
   if (player_active_ability(p, "Finesse")) {
    crit_separation -= 10;
   }
   /* Can have improved criticals for melee with one handed weapons */
   if (player_active_ability(p, "Subtlety") && !thrown &&
    !two_handed_melee(p) &&
    !equipped_item_by_slot_name(p, "arm")) {
    crit_separation -= 20;
   }
   /* Can have inferior criticals for melee */
   if (player_active_ability(p, "Power")) {
    crit_separation += 10;
   }
  }
  /* Can have improved criticals for archery */
  if ((skill_type == SKILL_ARCHERY) &&
   player_active_ability(p, "Precision")) {
   crit_separation -= 10;
  }
 } else {
  /* When attacking the player... */
  /* Resistance to criticals increases what they need for each bonus die*/
  if (player_active_ability(p, "Critical Resistance")) {
   crit_separation += (p->state.skill_use[SKILL_WILL] / 5) * 10;
  }
 }
 /* Note: the +4 in this calculation is for rounding purposes */
 crit_bonus_dice = (hit_result * 10 + 4) / (crit_separation + weight);
 /* When attacking a monster... */
 if (race) {
  /* Resistance to criticals doubles what you need for each bonus die */
  if (rf_has(race->flags, RF_RES_CRIT)) {
   crit_bonus_dice /= 2;
  }
  /* Certain creatures cannot suffer crits as they have no vulnerable
		 * areas */
  if (rf_has(race->flags, RF_NO_CRIT)) {
   crit_bonus_dice = 0;
  }
 }
 /* Can't have fewer than zero dice */
 return MAX(crit_bonus_dice, 0);
}
/**
 * Roll the protection dice for all parts of the player's armour
 */
int protection_roll(struct player *p, int typ, bool melee, aspect prot_aspect)
{
 int i;
 int prt = 0;
 int mult = 1;
 int armour_weight = 0;
 struct song *staying = lookup_song("Staying");
 /* Things that always count: */
 if (player_is_singing(p, staying)) {
  int bonus = song_bonus(p, p->state.skill_use[SKILL_SONG], staying);
  prt += damcalc(1, MAX(1, bonus), prot_aspect);
 }
 if (player_active_ability(p, "Hardiness")) {
  prt += damcalc(1, p->state.skill_use[SKILL_WILL] / 6, prot_aspect);
 }
 /* Armour: */
 for (i = 0; i < p->body.count; i++) {
  struct object *obj = p->body.slots[i].obj;
  if (!obj) continue;
  /* Skip off-hand weapons */
  if (slot_type_is(p, i, EQUIP_SHIELD) && tval_is_weapon(obj)) continue;
  /* Count weight of armour */
  if (tval_is_armor(obj)) {
   armour_weight += obj->weight;
  }
  /* Fire and cold and generic 'hurt' all check the shield */
  if (slot_type_is(p, i, EQUIP_SHIELD)) {
   if ((typ == PROJ_HURT) || (typ == PROJ_FIRE) || (typ == PROJ_COLD)){
    if (player_active_ability(p, "Blocking") &&
     (!melee || ((p->previous_action[0] == ACTION_STAND) ||
        ((p->previous_action[0] == ACTION_NOTHING) &&
         (p->previous_action[1] == ACTION_STAND))))) {
     mult = 2;
    }
    if (obj->pd > 0) {
     prt += damcalc(obj->pd * mult, obj->ps, prot_aspect);
    }
   }
  } else if ((typ == PROJ_HURT) || (tval_is_jewelry(obj))) {
   /* Also add protection if damage is generic 'hurt' or it is
			 * a ring or amulet slot */
   if (obj->ps > 0) {
    prt += damcalc(obj->pd, obj->ps, prot_aspect);
   }
  }
 }
 /* Heavy armour bonus */
 if (player_active_ability(p, "Heavy Armour") && (typ == PROJ_HURT)) {
  prt += damcalc(1, MIN(1, armour_weight / 150), prot_aspect);
 }
 return prt;
}
/**
 * \file datafile.c
 * \brief Angband data file reading and writing routines.
 *
 * Copyright (c) 2017 Nick McConnell
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 *
 * This file deals with Angband specific functions for reading and writing
 * of data files; basic parser functions are in parser.c.
 */
/**
 * Hold a prefix to distinguish files from different users when the archive
 * directory is shared.
 */
static char *archive_user_pfx = NULL;
const char *parser_error_str[PARSE_ERROR_MAX] = {
/**
 * \file list-parser-errors.h
 * \brief Parse errors and descriptions
 */
"(none)",
"bad expression string",
"name is already in use",
"symbol is already in use",
"element name mismatch",
"field too long",
"generic error",
"internal error",
"invalid ability",
"invalid allocation",
"invalid colour",
"invalid dice",
"invalid effect",
"invalid expression",
"invalid flag",
"invalid object property id type",
"invalid item number",
"invalid power calculation iterate",
"invalid lighting",
"invalid message",
"invalid monster base",
"invalid monster race",
"invalid monster group role",
"invalid object property code",
"invalid option",
"invalid power calculation operation",
"invalid player property code",
"invalid player race",
"invalid object property type",
"invalid skill",
"invalid slay",
"invalid smithing category",
"invalid smithing cost type",
"invalid spell frequency",
"invalid spell name",
"invalid spell stat",
"invalid object property subtype",
"invalid terrain",
"invalid UTF-8 code point",
"invalid value",
"malformed coordinate",
"missing blow effect type",
"missing field",
"missing object property type",
"missing player property type",
"missing record header",
"artifact name not found",
"no builder found",
"no file found",
"no kind for ability",
"no kind for drop type",
"no kind for ego type",
"no kind found",
"no room found",
"non-sequential records",
"not a number",
"not random",
"not a special artifact",
"obsolete file",
"out of bounds",
"out of memory",
"directive used more than once",
"too few entries",
"too many entries",
"too many ability prerequisites",
"unbound expression",
"undefined directive",
"unrecognized blow",
"unrecognized brand",
"unrecognized slay",
"unrecognized curse",
"unrecognized trap",
"unrecognized tval",
"unrecognized sval",
"unrecognized skill",
"unrecognized parameter",
"vault too big",
"bad vault description line length",

};
/**
 * ------------------------------------------------------------------------
 * Angband datafile parsing routines
 * ------------------------------------------------------------------------ */
static void parse_error(struct file_parser *fp, struct parser *p) {
 struct parser_state s;
 parser_getstate(p, &s);
 msg("Parse error in %s line %d column %d: %s: %s", fp->name,
            s.line, s.col, s.msg, parser_error_str[s.error]);
 event_signal(EVENT_MESSAGE_FLUSH);
 quit_fmt("Parse error in %s line %d column %d.", fp->name, s.line, s.col);
}
errr run_parser(struct file_parser *fp) {
 struct parser *p = fp->init();
 errr r;
 if (!p) {
  return PARSE_ERROR_GENERIC;
 }
 r = fp->run(p);
 if (r) {
  parse_error(fp, p);
  return r;
 }
 r = fp->finish(p);
 if (r) {
  msg("Parser finish error in %s: %s", fp->name,
   (r > 0 && r < PARSE_ERROR_MAX) ?
   parser_error_str[r] : "unspecified error");
  event_signal(EVENT_MESSAGE_FLUSH);
  quit_fmt("Parser finish error in %s.", fp->name);
 }
 return r;
}
/**
 * The basic file parsing function.  Attempt to load filename through
 * parser and perform a quit if the file is not found.
 */
errr parse_file_quit_not_found(struct parser *p, const char *filename) {
 errr parse_err = parse_file(p, filename);
 if (parse_err == PARSE_ERROR_NO_FILE_FOUND)
  quit(format("Cannot open '%s.txt'", filename));
 return parse_err;
}
/**
 * The basic file parsing function.
 */
errr parse_file(struct parser *p, const char *filename) {
 char path[1024];
 char buf[1024];
 ang_file *fh;
 errr r = 0;
 /* The player can put a customised file in the user directory */
 path_build(path, sizeof(path), ANGBAND_DIR_USER, format("%s.txt",
               filename));
 fh = file_open(path, MODE_READ, FTYPE_TEXT);
 /* If no custom file, just load the standard one */
 if (!fh) {
  path_build(path, sizeof(path), ANGBAND_DIR_GAMEDATA,
       format("%s.txt", filename));
  fh = file_open(path, MODE_READ, FTYPE_TEXT);
 }
 /* File wasn't found, return the error */
 if (!fh)
  return PARSE_ERROR_NO_FILE_FOUND;
 /* Parse it */
 while (file_getl(fh, buf, sizeof(buf))) {
  r = parser_parse(p, buf);
  if (r)
   break;
 }
 file_close(fh);
 return r;
}
void cleanup_parser(struct file_parser *fp)
{
 fp->cleanup();
}
int lookup_flag(const char **flag_table, const char *flag_name) {
 int i = FLAG_START;
 while (flag_table[i] && !streq(flag_table[i], flag_name))
  i++;
 /* End of table reached without match */
 if (!flag_table[i]) i = FLAG_END;
 return i;
}
int code_index_in_array(const char *code_name[], const char *code)
{
 int i = 0;
 while (code_name[i]) {
  if (streq(code_name[i], code)) {
   return i;
  }
  i++;
 }
 return -1;
}
/**
 * Gets a name and argument for a value expression of the form NAME[arg]
 * \param name_and_value is the expression
 * \param string is the random value string to return (NULL if not required)
 * \param nstring is the maximum number of bytes to write to string; not used
 * if string is NULL
 * \param num is the integer to return (NULL if not required)
 */
static bool find_value_arg(char *value_name, char *string, size_t nstring,
  int *num)
{
 /* Find the first bracket */
 char *to = strchr(value_name, '[');
 if (!to) {
  return false;
 }
 /* Choose random_value value or int or fail */
 if (string) {
  /* Find the closing bracket. */
  char *tc = strchr(to + 1, ']');
  if (!tc || (size_t)(tc - to) > nstring) {
   return false;
  }
  /* Get the dice */
  memcpy(string, to + 1, tc - (to + 1));
  string[tc - (to + 1)] = '\0';
 } else if (num) {
  /* Get the value */
  char *tc;
  long lv = strtol(to + 1, &tc, 10);
  /*
		 * Also reject INT_MIN and INT_MAX so don't have to check errno
		 * to detect overflow when sizeof(long) == sizeof(int).
		 */
  if (*tc != ']' || lv <= INT_MIN || lv >= INT_MAX) {
   return false;
  }
  *num = (int)lv;
 } else {
  return false;
 }
 /*
	 * Put a null where the opening bracket is; make it easier for the
	 * caller to handle the name.
	 */
 *to = '\0';
 /* Success */
 return true;
}
/**
 * Get the random value argument from a value expression and put it into the
 * appropriate place in an array
 * \param value the target array of values
 * \param value_type the possible value strings
 * \param name_and_value the value expression being matched
 * \return 0 if successful, otherwise an error value
 */
errr grab_rand_value(random_value *value, const char **value_type,
      const char *name_and_value)
{
 int i = 0;
 /* Get a rewritable string */
 char *value_name = string_make(name_and_value);
 char dice_string[40];
 dice_t *dice;
 /* Parse the value expression */
 if (!find_value_arg(value_name, dice_string, sizeof(dice_string), NULL)) {
  string_free(value_name);
  return PARSE_ERROR_INVALID_VALUE;
 }
 dice = dice_new();
 while (value_type[i] && !streq(value_type[i], value_name))
  i++;
 string_free(value_name);
 if (value_type[i]) {
  if (!dice_parse_string(dice, dice_string)) {
   dice_free(dice);
   return PARSE_ERROR_NOT_RANDOM;
  }
  dice_random_value(dice, &value[i]);
 }
 dice_free(dice);
 return value_type[i] ? PARSE_ERROR_NONE : PARSE_ERROR_INTERNAL;
}
/**
 * Get the integer argument from a value expression and put it into the
 * appropriate place in an array
 * \param value the target array of integers
 * \param value_type the possible value strings
 * \param name_and_value the value expression being matched
 * \return 0 if successful, otherwise an error value
 */
errr grab_int_value(int *value, const char **value_type,
     const char *name_and_value)
{
 int val, i = 0;
 /* Get a rewritable string */
 char *value_name = string_make(name_and_value);
 /* Parse the value expression */
 if (!find_value_arg(value_name, NULL, 0, &val)) {
  string_free(value_name);
  return PARSE_ERROR_INVALID_VALUE;
 }
 while (value_type[i] && !streq(value_type[i], value_name))
  i++;
 string_free(value_name);
 if (value_type[i])
  value[i] = val;
 return value_type[i] ? PARSE_ERROR_NONE : PARSE_ERROR_INTERNAL;
}
/**
 * Parse a string expected to be of the form "<int><whitespace>
 * <optional fixed string><whitespace><int>".
 *
 * \param lo will be dereferenced and set to the first integer in the string
 * if the return value is PARSE_ERROR_NONE.
 * \param hi will be dereferenced and set to the second integer in the string
 * if the return value is PARSE_ERROR_NONE.
 * \param range is the string to parse.
 * \param sep is the optional string separating the two integers.  It may be
 * NULL.  If not NULL, it must neither start nor end with whitespace.
 * \return PARSE_ERROR_NONE if successful, otherwise an error value.
 */
errr grab_int_range(int *lo, int *hi, const char *range, const char *sep)
{
 char *pe;
 long lv1 = strtol(range, &pe, 10), lv2;
 /*
	 * Reject INT_MIN and INT_MAX as well so don't have to check errno in
	 * order to recognize overflow when sizeof(int) == sizeof(long).
	 */
 if (pe == range || !isspace(*pe) || lv1 <= INT_MIN || lv1 >= INT_MAX) {
  return PARSE_ERROR_INVALID_VALUE;
 }
 range = pe;
 if (sep) {
  size_t nonwhite_offset;
  pe = strstr(range, sep);
  if (!pe) {
   return PARSE_ERROR_INVALID_VALUE;
  }
  nonwhite_offset = strspn(range, " \t");
  if (range + nonwhite_offset != pe) {
   return PARSE_ERROR_INVALID_VALUE;
  }
  range = pe + strlen(sep);
  if (!isspace(*range)) {
   return PARSE_ERROR_INVALID_VALUE;
  }
 }
 lv2 = strtol(range, &pe, 10);
 if (pe == range || !contains_only_spaces(pe) || lv2 <= INT_MIN
   || lv2 >= INT_MAX) {
  return PARSE_ERROR_INVALID_VALUE;
 }
 *lo = (int)lv1;
 *hi = (int)lv2;
 return PARSE_ERROR_NONE;
}
/**
 * Get the integer argument from a value expression and the index in the
 * value_type array of the suffix used to build the value string
 * \param value the integer value
 * \param index the information on where to put it (eg array index)
 * \param value_type the variable suffix of the possible value strings
 * \param prefix the constant prefix of the possible value strings
 * \param name_and_value the value expression being matched
 * \return 0 if successful, otherwise an error value
 */
errr grab_index_and_int(int *value, int *index, const char **value_type,
      const char *prefix, const char *name_and_value)
{
 int i;
 /* Get a rewritable string */
 char *value_name = string_make(name_and_value);
 char *value_string = string_make(prefix);
 /* Parse the value expression */
 if (!find_value_arg(value_name, NULL, 0, value)) {
  string_free(value_string);
  string_free(value_name);
  return PARSE_ERROR_INVALID_VALUE;
 }
 /* Compose the value string and look for it */
 for (i = 0; value_type[i]; i++) {
  value_string = string_append(value_string, value_type[i]);
  if (streq(value_string, value_name)) break;
  my_strcpy(value_string, prefix, strlen(prefix) + 1);
 }
 free(value_string);
 free(value_name);
 if (value_type[i])
  *index = i;
 return value_type[i] ? PARSE_ERROR_NONE : PARSE_ERROR_INTERNAL;
}
/**
 * Get the integer argument from a slay value expression and the monster base
 * name it is slaying
 * \param value the integer value
 * \param base the monster base name
 * \param name_and_value the value expression being matched
 * \return 0 if successful, otherwise an error value
 */
errr grab_base_and_int(int *value, char **base, const char *name_and_value)
{
 /* Get a rewritable string */
 char *value_name = string_make(name_and_value);
 /* Parse the value expression */
 if (!find_value_arg(value_name, NULL, 0, value)) {
  string_free(value_name);
  return PARSE_ERROR_INVALID_VALUE;
 }
 /* Must be a slay */
 if (strncmp(value_name, "SLAY_", 5)) {
  string_free(value_name);
  return PARSE_ERROR_INVALID_VALUE;
 }
 *base = string_make(value_name + 5);
 string_free(value_name);
 /* If we've got this far, assume it's a valid monster base name */
 return PARSE_ERROR_NONE;
}
errr grab_name(const char *from, const char *what, const char *list[], int max,
      int *num)
{
 int i;
 /* Scan list */
 for (i = 0; i < max; i++) {
  if (streq(what, list[i])) {
   *num = i;
   return PARSE_ERROR_NONE;
  }
 }
 /* Oops */
 msg("Unknown %s '%s'.", from, what);
 /* Error */
 return PARSE_ERROR_GENERIC;
}
errr grab_flag(bitflag *flags, const size_t size, const char **flag_table, const char *flag_name) {
 int flag = lookup_flag(flag_table, flag_name);
 if (flag == FLAG_END) return PARSE_ERROR_INVALID_FLAG;
 flag_on(flags, size, flag);
 return 0;
}
errr remove_flag(bitflag *flags, const size_t size, const char **flag_table,
     const char *flag_name) {
 int flag = lookup_flag(flag_table, flag_name);
 if (flag == FLAG_END) return PARSE_ERROR_INVALID_FLAG;
 flag_off(flags, size, flag);
 return 0;
}
/**
 * ------------------------------------------------------------------------
 * Angband datafile writing routines
 * ------------------------------------------------------------------------ */
/**
 * Write the flag lines for a set of flags.
 */
void write_flags(ang_file *fff, const char *intro_text, const bitflag *flags,
        int flag_size, const char *names[])
{
 int flag;
 char buf[1024] = "";
 int pointer = 0;
 /* Write flag name list */
 for (flag = flag_next(flags, flag_size, FLAG_START); flag != FLAG_END;
   flag = flag_next(flags, flag_size, flag + 1)) {
  /* Write the flags, keeping track of where we are */
  if (strlen(buf)) {
   my_strcat(buf, " | ", sizeof(buf));
   pointer += 3;
  }
  /* If no name, we're past the real flags */
  if (!names[flag]) break;
  my_strcat(buf, names[flag], sizeof(buf));
  pointer += strlen(names[flag]);
  /* Move to a new line if this one is long enough */
  if (pointer >= 60) {
   file_putf(fff, "%s%s\n", intro_text, buf);
   my_strcpy(buf, "", sizeof(buf));
   pointer = 0;
  }
 }
 /* Print remaining flags if any */
 if (pointer)
  file_putf(fff, "%s%s\n", intro_text, buf);
}
/**
 * Write value lines for a set of modifiers.
 */
void write_mods(ang_file *fff, const int values[])
{
 size_t i;
 char buf[1024] = "";
 int pointer = 0;
 static const char *obj_mods[] = {
/**
 * \file src/list-stats.h
 * \brief player stats
 *
 * Changing stat order or making new ones will break savefiles. Stats
 * below start from 0 on line 14, so a stat's sequence number is its line
 * number minus 14.
 *
 * Each stat has a matching sustain in src/list-object-flags.h, which should
 * be at the same index in that file as the stat in this file.
 *
 * Stat properties are defined in lib/gamedata/object_property.txt
 */
"STR",
"DEX",
"CON",
"GRA",
/**
 * \file src/list-skills.h
 * \brief player skills
 *
 * Changing skill order or making new ones will break savefiles. Skills
 * below start from 0 on line 11, so a skill's sequence number is its line
 * number minus 11.
 *
 * Skill properties are not defined in lib/gamedata/object_property.txt
 */
"MELEE",
"ARCHERY",
"EVASION",
"STEALTH",
"PERCEPTION",
"WILL",
"SMITHING",
"SONG",
/**
 * \file list-object-modifiers.h
 * \brief object modifiers (plusses and minuses) for all objects
 *
 * Changing modifier order will break savefiles. Modifiers below start from
 * 13 on line 12 (stats and skills count as modifiers, and are included from
 * list-stats.h and list-skills.h), so a modifier's sequence number is its line
 * number plus 1.
 *
 * Modifier properties are defined in lib/gamedata/object_property.txt
 */
"DAMAGE_SIDES",
"TUNNEL",

  NULL
 };
 /* Write value list */
 for (i = 0; i < OBJ_MOD_MAX; i++) {
  /* If no value, don't write */
  if (values[i] == 0) continue;
  /* If this line contains something, write a divider */
  if (strlen(buf)) {
   my_strcat(buf, " | ", sizeof(buf));
   pointer += 3;
  }
  /* Write the name and value */
  my_strcat(buf, obj_mods[i], sizeof(buf));
  pointer += strlen(obj_mods[i]);
  my_strcat(buf, format("[%d]", values[i]), sizeof(buf));
  pointer += 5;
  /* Move to a new line if this one is long enough */
  if (pointer >= 60) {
   file_putf(fff, "%s%s\n", "values:", buf);
   my_strcpy(buf, "", sizeof(buf));
   pointer = 0;
  }
 }
 /* Print remaining values if any */
 if (pointer)
  file_putf(fff, "%s%s\n", "values:", buf);
}
/**
 * Write value lines for a set of modifiers.
 */
void write_elements(ang_file *fff, const struct element_info *el_info)
{
 size_t i;
 char buf[1024] = "";
 int pointer = 0;
 static const char *element_names[] = {
/**
 * \file list-elements.h
 * \brief Elements used in spells and other attacks.
 */
"ACID",
"FIRE",
"COLD",
"POIS",
"DARK",

  NULL
 };
 /* Write value list */
 for (i = 0; i < ELEM_MAX; i++) {
  /* If no value, don't write */
  if (el_info[i].res_level == 0) continue;
  /* If this line contains something, write a divider */
  if (strlen(buf)) {
   my_strcat(buf, " | ", sizeof(buf));
   pointer += 3;
  }
  /* Write the name and value */
  my_strcat(buf, format("RES_%s", element_names[i]), sizeof(buf));
  pointer += strlen(element_names[i]) + 4;
  my_strcat(buf, format("[%d]", el_info[i].res_level), sizeof(buf));
  pointer += 5;
  /* Move to a new line if this one is long enough */
  if (pointer >= 60) {
   file_putf(fff, "%s%s\n", "values:", buf);
   my_strcpy(buf, "", sizeof(buf));
   pointer = 0;
  }
 }
 /* Print remaining values if any */
 if (pointer)
  file_putf(fff, "%s%s\n", "values:", buf);
}
/**
 * Set the prefix to use for the current user when archiving files.
 * \param pfx Is the new prefix to use.  May be NULL which is treated
 * like an empty string.
 */
void set_archive_user_prefix(const char *pfx)
{
 string_free(archive_user_pfx);
 archive_user_pfx = string_make(pfx);
}
/**
 * Archive a data file from ANGBAND_DIR_USER into ANGBAND_DIR_ARCHIVE
 */
void file_archive(const char *fname, const char *append)
{
 char arch[1024];
 char old[1024];
 int i, max_arch = 10000;
 /* Add a suffix to the filename, custom if requested */
 if (append) {
  path_build(arch, sizeof(arch), ANGBAND_DIR_ARCHIVE,
   format("%s%s_%s.txt",
   (archive_user_pfx) ? archive_user_pfx : "", fname,
   append));
 } else {
  /* Check the indices of existing archived files, get the next one */
  for (i = 1; i < max_arch; i++) {
   path_build(arch, sizeof(arch), ANGBAND_DIR_ARCHIVE,
    format("%s%s_%d.txt",
    (archive_user_pfx) ? archive_user_pfx : "",
    fname, i));
   if (!file_exists(arch)) break;
   my_strcpy(arch, "", sizeof(arch));
  }
 }
 /* Move the file */
 path_build(old, sizeof(old), ANGBAND_DIR_USER, format("%s.txt", fname));
 safe_setuid_grab();
 file_move(old, arch);
 safe_setuid_drop();
}
/**
 * Check if an archived randart file for the current seed exists
 */
bool randart_file_exists(void)
{
 char path[1024];
 /* Get the randart filename and path */
 path_build(path, sizeof(path), ANGBAND_DIR_ARCHIVE,
      format("%srandart_%08lx.txt", (archive_user_pfx) ?
     archive_user_pfx : "",
     (unsigned long)seed_randart));
 return file_exists(path);
}
/**
 * Prepare the randart file for the current seed to be loaded
 */
void activate_randart_file(void)
{
 char new[1024];
 char old[1024];
 /* Get the randart filename and path */
 path_build(old, sizeof(old), ANGBAND_DIR_ARCHIVE,
  format("%srandart_%08lx.txt",
  (archive_user_pfx) ? archive_user_pfx : "",
  (unsigned long)seed_randart));
 /* Move it into place */
 path_build(new, sizeof(new), ANGBAND_DIR_USER, "randart.txt");
 safe_setuid_grab();
 file_move(old, new);
 safe_setuid_drop();
}
/**
 * Move the randart file to the archive directory
 */
void deactivate_randart_file(void)
{
 char buf[10];
 strnfmt(buf, 9, "%08lx", (unsigned long)seed_randart);
 file_archive("randart", buf);
}
void write_self_made_artefacts(void)
{
 ang_file *log_file;
 char fname[1024];
 /* Open the file, write a header */
 path_build(fname, sizeof(fname), ANGBAND_DIR_USER, "randart.txt");
 log_file = file_open(fname, MODE_WRITE, FTYPE_TEXT);
 file_putf(log_file,
     "# Artifact file for self-made artifacts with label %08x\n\n\n",
     seed_randart);
 /* Write the data */
 write_self_made_artefact_entries(log_file);
 /* Close the file */
 if (!file_close(log_file)) {
  quit_fmt("Error - can't close %s.", fname);
 }
}
/**
 * \file debug.c
 * \brief Simple debugging functions
 *
 * Copyright (c) 2007 Andi Sidwell
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
typedef void debug_hook(const char *);
static void to_stderr(const char *out);
static debug_hook *d_out = to_stderr;
/**
 * Simple printing to stderr
 */
static void to_stderr(const char *out)
{
 fputs(out, stderr);
 fputs("\n", stderr);
}
/**
 * Output some text.
 *
 * Amongst other things, this should use the message package so that ports can
 * display e.g. a debugging window, or send the output to file.
 */
void debug(const char *fmt, ...)
{
 va_list vp;
 char buffer[1024] = "";
 va_start(vp, fmt);
 vstrnfmt(buffer, sizeof(buffer), fmt, vp);
 va_end(vp);
 d_out(buffer);
 /* We are done */
 return;
}
/**
 * \file effect-handler-attack.c
 * \brief Handler functions for attack effects
 *
 * Copyright (c) 2007 Andi Sidwell
 * Copyright (c) 2016 Ben Semmler, Nick McConnell
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
static void get_target(struct source origin, int dir, struct loc *grid,
        int *flags)
{
 switch (origin.what) {
  case SRC_MONSTER: {
   struct monster *monster = cave_monster(cave, origin.which.monster);
   if (!monster) break;
   *flags |= (PROJECT_PLAY);
   if (monster->target.midx > 0) {
    struct monster *mon = cave_monster(cave, monster->target.midx);
    *grid = mon->grid;
   } else {
    *grid = player->grid;
   }
   break;
  }
  case SRC_PLAYER:
   if (dir == DIR_TARGET && target_okay(z_info->max_range)) {
    target_get(grid);
   } else {
    /* Use the adjacent grid in the given direction as target */
    *grid = loc_sum(player->grid, ddgrid[dir]);
   }
   break;
  default:
   *flags |= PROJECT_PLAY;
   *grid = player->grid;
   break;
 }
}
/**
 * Apply the project() function in a direction, or at a target
 */
static bool project_aimed(struct source origin, int typ, int dir, int dd,
        int ds, int dif, int flg, const struct object *obj)
{
 struct loc grid = loc(-1, -1);
 /* Pass through the target if needed */
 flg |= (PROJECT_THRU);
 get_target(origin, dir, &grid, &flg);
 /* Aim at the target, do NOT explode */
 return (project(origin, 0, grid, dd, ds, dif, typ, flg, 0, false, obj));
}
/**
 * Heal the player by a given percentage of their wounds, or a minimum
 * amount, whichever is larger.
 *
 * context->value.base should be the minimum, and
 * context->value.m_bonus the percentage
 */
bool effect_handler_HEAL_HP(effect_handler_context_t *context)
{
 int num, minh;
 /* Always ID */
 context->ident = true;
 /* No healing needed */
 if (player->chp >= player->mhp) return (true);
 /* Figure percentage healing level */
 num = ((player->mhp - player->chp) * context->value.m_bonus) / 100;
 /* Enforce minimum */
 minh = context->value.base
  + damroll(context->value.dice, context->value.sides);
 if (num < minh) num = minh;
 if (num <= 0) {
  /*
		 * There's no healing: either because not damaged enough for
		 * the bonus amount to matter or the effect was misconfigured.
		 */
  return true;
 }
 /* Gain hitpoints */
 player->chp += num;
 /* Enforce maximum */
 if (player->chp >= player->mhp) {
  player->chp = player->mhp;
  player->chp_frac = 0;
 }
 /* Redraw */
 player->upkeep->redraw |= (PR_HP);
 /* Print a nice message */
 if (num < 5)
  msg("You feel a little better.");
 else if (num < 15)
  msg("You feel better.");
 else if (num < 35)
  msg("You feel much better.");
 else
  msg("You feel very good.");
 return (true);
}
/**
 * Deal damage from the current monster or trap to the player
 */
bool effect_handler_DAMAGE(effect_handler_context_t *context)
{
 int dam = effect_calculate_value(context);
 char killer[80];
 /* Always ID */
 context->ident = true;
 switch (context->origin.what) {
  case SRC_MONSTER: {
   struct monster *mon = cave_monster(cave,
              context->origin.which.monster);
   monster_desc(killer, sizeof(killer), mon, MDESC_DIED_FROM);
   break;
  }
  case SRC_TRAP: {
   struct trap *trap = context->origin.which.trap;
   const char *article = is_a_vowel(trap->kind->desc[0]) ? "an " : "a ";
   strnfmt(killer, sizeof(killer), "%s%s", article, trap->kind->desc);
   break;
  }
  case SRC_CHEST_TRAP: {
   struct chest_trap *trap = context->origin.which.chest_trap;
   strnfmt(killer, sizeof(killer), "%s", trap->msg_death);
   break;
  }
  case SRC_PLAYER: {
   if (context->msg) {
    my_strcpy(killer, context->msg, sizeof(killer));
   } else {
    my_strcpy(killer, "yourself", sizeof(killer));
   }
   break;
  }
  case SRC_NONE: {
   my_strcpy(killer, "a bug", sizeof(killer));
   break;
  }
  default: break;
 }
 /* Hit the player */
 take_hit(player, dam, killer);
 return true;
}
/**
 * Dart trap (yes, it needs its own effect)
 */
bool effect_handler_DART(effect_handler_context_t *context)
{
 int dam = effect_calculate_value(context);
 int prt = protection_roll(player, PROJ_HURT, false, RANDOMISE);
 char *name;
 assert(context->origin.what == SRC_TRAP);
 name = context->origin.which.trap->kind->name;
 if (check_hit(context->radius, true, context->origin)) {
  if (dam > prt) {
   msg("A small dart hits you!");
   /* Do a tiny amount of damage */
   take_hit(player, context->other, name);
   event_signal_combat_damage(EVENT_COMBAT_DAMAGE, context->value.dice,
            context->value.sides, prt + 1, -1, -1,
            prt, 100, PROJ_HURT, false);
   /* Reduce the stat */
   player_stat_dec(player, context->subtype);
  } else {
   msg("A small dart hits you, but is deflected by your armour.");
   event_signal_combat_damage(EVENT_COMBAT_DAMAGE, context->value.dice,
            context->value.sides, dam, -1, -1, prt,
            100, PROJ_HURT, false);
  }
 } else {
  msg("A small dart barely misses you.");
 }
 /* Make a small amount of noise */
 monsters_hear(true, false, 5);
 return true;
}
/**
 * Fall in a pit - player only
 */
bool effect_handler_PIT(effect_handler_context_t *context)
{
 bool spiked = (context->subtype == 1);
 square_set_feat(cave, player->grid, spiked ? FEAT_SPIKED_PIT : FEAT_PIT);
 player_fall_in_pit(player, spiked);
 return true;
}
/**
 * Apply a "project()" directly to all viewable monsters.  If context->other is
 * set, the effect damage boost is applied.  This is a hack - NRM
 *
 * Note that affected monsters are NOT auto-tracked by this usage.
 */
bool effect_handler_PROJECT_LOS(effect_handler_context_t *context)
{
 int i;
 int typ = context->subtype;
 struct loc origin = origin_get_loc(context->origin);
 int flg = PROJECT_JUMP | PROJECT_KILL | PROJECT_HIDE;
 /* Affect all (nearby) monsters */
 for (i = 1; i < cave_monster_max(cave); i++) {
  struct monster *mon = cave_monster(cave, i);
  /* Paranoia -- Skip dead monsters */
  if (!mon->race) continue;
  /* Don't affect the caster */
  if (mon->midx == cave->mon_current) continue;
  /* Require line of sight */
  if (!los(cave, origin, mon->grid)) continue;
  /* Require line of fire - assumes player is the origin - NRM */
  if (!square_isfire(cave, mon->grid)) continue;
  /* Jump directly to the monster */
  if (project(source_player(), 0, mon->grid, 0, 0, context->value.base,
     typ, flg, 0, 0, context->obj)) {
   context->ident = true;
  }
 }
 /* Result */
 return true;
}
/**
 * Apply a "project()" directly to all grids.
 */
bool effect_handler_PROJECT_LOS_GRIDS(effect_handler_context_t *context)
{
 struct loc grid;
 int typ = context->subtype;
 int flg = PROJECT_GRID | PROJECT_ITEM | PROJECT_JUMP | PROJECT_HIDE;
 /* Affect all viewable grids */
 for (grid.y = player->grid.y - z_info->max_sight;
   grid.y <= player->grid.y + z_info->max_sight; grid.y++) {
  for (grid.x = player->grid.x - z_info->max_sight;
    grid.x <= player->grid.x + z_info->max_sight; grid.x++) {
   /* Grid must be in bounds and in the player's LoS */
   if (!square_in_bounds_fully(cave, grid)) continue;
   if (!square_isview(cave, grid)) continue;
   if (project(source_player(), 0, grid, 0, 0, context->value.base,
      typ, flg, 0, 0, context->obj))
    context->ident = true;
  }
 }
 /* Result */
 return true;
}
/**
 * Drop the ceiling on the player.
 *
 * The player will take damage and jump into a safe grid if possible,
 * otherwise, they will take crush damage.  Players who dodge may still
 * be hit by rubble.
 */
bool effect_handler_DEADFALL(effect_handler_context_t *context)
{
 int i;
 struct loc pgrid = player->grid, safe_grid = loc(0, 0);
 int safe_grids = 0;
 int dam, prt, net_dam = 0;
 /* Check around the player */
 for (i = 0; i < 8; i++) {
  /* Get the location */
  struct loc grid = loc_sum(pgrid, ddgrid_ddd[i]);
  /* Skip non-empty grids - allow pushing into traps and webs */
  if (!square_isopen(cave, grid)) continue;
  /* Count "safe" grids, apply the randomizer */
  if ((++safe_grids > 1) && (randint0(safe_grids) != 0)) continue;
  /* Save the safe location */
  safe_grid = grid;
 }
 /* Check for safety */
 if (!safe_grids) {
  /* Hurt the player a lot */
  msg("You are severely crushed!");
  dam = damroll(6, 8);
  /* Protection */
  prt = protection_roll(player, PROJ_HURT, false, false);
  net_dam = (dam - prt > 0) ? (dam - prt) : 0;
  event_signal_combat_attack(EVENT_COMBAT_ATTACK, source_none(),
           source_player(), true, -1, -1, -1, -1,
           false);
  event_signal_combat_damage(EVENT_COMBAT_DAMAGE, 6, 8, dam, -1, -1, prt,
           100, PROJ_HURT, false);
  (void)player_inc_timed(player, TMD_STUN, dam * 4, true, true,
   true);
 } else {
  /* Destroy the grid, and push the player to safety */
  if (check_hit(20, true, context->origin)) {
   msg("You are struck by rubble!");
   dam = damroll(4, 8);
   /* Protection */
   prt = protection_roll(player, PROJ_HURT, false, false);
   event_signal_combat_damage(EVENT_COMBAT_DAMAGE, 4, 8, dam, -1, -1,
            prt, 100, PROJ_HURT, false);
   net_dam = (dam - prt > 0) ? (dam - prt) : 0;
   (void)player_inc_timed(player, TMD_STUN, dam * 4, true,
    true, true);
  } else {
   msg("You nimbly dodge the falling rock!");
  }
  /* Move player */
  monster_swap(pgrid, safe_grid);
  player_handle_post_move(player, true, true);
 }
 /* Take the damage */
 take_hit(player, net_dam, "a deadfall");
 /* Drop rubble */
 square_set_feat(cave, pgrid, FEAT_RUBBLE);
 return true;
}
/**
 * Induce an earthquake of the radius context->radius centred on the
 * instigator.
 *
 * Does rd8 damage at the centre, and one less die each square out 
 * from there. If a square doesn't have a monster in it after the damage
 * it might be transformed to a different terrain (eg floor to rubble,
 * rubble to wall, wall to rubble), with a damage% chance. Note that
 * no damage is done to the square at the epicentre.
 * 
 * The player will take damage and jump into a safe grid if possible,
 * otherwise, he will tunnel through the rubble instantaneously.
 *
 * Monsters will take damage, and jump into a safe grid if possible,
 * otherwise they will be buried in the rubble, disappearing from
 * the level in the same way that they do when banished.
 *
 * Note that players and monsters (except eaters of walls and passers
 * through walls) will never occupy the same grid as a wall (or door).
 */
bool effect_handler_EARTHQUAKE(effect_handler_context_t *context)
{
 int r = effect_calculate_value(context);;
 bool melee = context->other;
 struct loc pgrid = player->grid;
 bool vis = (context->origin.what == SRC_PLAYER);
 int i;
 struct loc offset, pit = loc(0, 0);
 bool fall_in = false;
 struct loc centre = origin_get_loc(context->origin);
 int player_damage = 0, player_dd = 0, player_ds = 0;
 context->ident = true;
 /* No effect on the surface */
 if (!player->depth) {
  msg("The ground shakes for a moment.");
  return true;
 }
 /* Paranoia -- Enforce maximum range */
 if (r > 10) r = 10;
 /* If it's a monster creating the earthquake, get it */
 if (context->origin.what == SRC_MONSTER) {
  struct monster *mon = cave_monster(cave, context->origin.which.monster);
  /* Set visibility */
  vis = monster_is_visible(mon);
  /* Pit creation by Morgoth */
  if (mon->race == lookup_monster("Morgoth, Lord of Darkness")) {
   struct loc safe;
   bool in_pit = square_ispit(cave, player->grid);
   int num = 0;
   /* Locate the pit */
   if (melee) {
    int dir = rough_direction(mon->grid, pgrid);
    pit = loc_sum(mon->grid, ddgrid[dir]);
   } else {
    pit = pgrid;
   }
   /* See if the player is in the pit, and if they can dodge */
   if (loc_eq(pit, pgrid)) {
    if (!in_pit) {
     /* Check around the player for safe locations to dodge to */
     for (i = 0; i < 8; i++) {
      /* Get the location */
      struct loc test = loc_sum(pgrid, ddgrid_ddd[i]);
      /* Skip non-empty grids */
      if (!square_isempty(cave, test)) continue;
      /* Count "safe" grids, apply the randomizer */
      if ((++num > 1) && (randint0(num) != 0)) continue;
      /* Save the safe location */
      safe = test;
     }
    }
    if (num > 0) {
     monster_swap(pgrid, safe);
     player_handle_post_move(player, true, true);
    } else {
     /* Remember to make the player fall into the pit later */
     fall_in = true;
    }
   }
   if (square_changeable(cave, pit)) {
    /* Delete objects */
    square_excise_pile(cave, pit);
    /* Change the feature */
    square_set_feat(cave, pit, FEAT_PIT);
   }
  }
 }
 /* Earthquake damage */
 for (offset.y = -r; offset.y <= r; offset.y++) {
  for (offset.x = -r; offset.x <= r; offset.x++) {
   int ds, dd, damage, net_dam, prt;
   /* Extract the location and distance */
   struct loc grid = loc_sum(centre, offset);
   int dist = distance(centre, grid);
   /* Get the monster, if any */
   struct monster *mon = square_monster(cave, grid);
   /* Skip illegal grids */
   if (!square_in_bounds_fully(cave, grid)) continue;
   /* Skip distant grids */
   if (dist > r) continue;
   /* Skip the epicenter */
   if (loc_is_zero(offset)) continue;
   /* Roll the damage for this square */
   dd = r + 1 - dist;
   ds = 8;
   damage = damroll(dd, ds);
   /* If the player is on the square... */
   if (square_isplayer(cave, grid)) {
    player_damage = damage;
    player_dd = dd;
    player_ds = ds;
   } else if (mon) {
    /* If a monster is on the square... */
    char m_name[80];
    /* Describe the monster */
    monster_desc(m_name, sizeof(m_name), mon, MDESC_STANDARD);
    /* Apply monster protection */
    prt = damroll(mon->race->pd, mon->race->ps);
    net_dam = damage - prt;
    /* Apply damage after protection */
    if (net_dam > 0) {
     bool killed = false;
     if (monster_is_visible(mon)) {
      /* Message for each visible monster */
      msg("%s is hit by falling debris.", m_name);
      /* Update combat rolls */
      event_signal_combat_attack(EVENT_COMBAT_ATTACK,
               context->origin,
               source_monster(mon->midx),
               vis, -1, -1, -1, -1, false);
      event_signal_combat_damage(EVENT_COMBAT_DAMAGE, dd, ds,
               damage, mon->race->pd,
               mon->race->ps, prt, 100,
               PROJ_HURT, false);
     }
     /* Do the damage and check for death */
     killed = mon_take_hit(mon, player, net_dam, NULL);
     /* Special effects for survivors */
     if (!killed) {
      /* Some creatures are resistant to stunning */
      if (rf_has(mon->race->flags, RF_NO_STUN)) {
       struct monster_lore *lore = get_lore(mon->race);
       /* Mark the lore */
       if (monster_is_visible(mon)) {
        rf_on(lore->flags, RF_NO_STUN);
       }
      } else {
       mon_inc_timed(mon, MON_TMD_STUN, net_dam * 4, 0);
      }
      /* Alert it */
      set_alertness(mon, MAX(mon->alertness + 10,
              ALERTNESS_VERY_ALERT));
      /* Message for non-visible monsters */
      if (!monster_is_visible(mon)) {
       message_pain(mon, damage);
      }
     }
    }
   }
   /* Squares without monsters/player will sometimes get transformed;
			 * note that a monster may have been there but got killed by now */
   if (!square_isoccupied(cave, grid) && percent_chance(damage) &&
    !loc_eq(grid, pit)) {
    /* Destroy location (if valid) */
    if (square_changeable(cave, grid)) {
                    int t, feat = FEAT_FLOOR, adj_chasms = 0;
     /* Delete objects */
     square_excise_pile(cave, grid);
                    /* Count adjacent chasm squares */
                    for (i = 0; i < 8; i++) {
                        /* Get the location */
                        struct loc adj_grid = loc_sum(grid, ddgrid_ddd[i]);
                        /* count the chasms */
                        if (square_ischasm(cave, adj_grid)) {
       adj_chasms++;
      }
                    }
     /* Wall (or floor) type */
     t = randint0(100);
                    /* Change based on existing type */
                    if (square_ischasm(cave, grid)) {
                        /* If we started with a chasm - mostly unchanged */
                        if (one_in_(10)) {
                            if (t < 10) {
        feat = FEAT_RUBBLE;
                            } else if (t < 70) {
        feat = FEAT_GRANITE;
                            } else {
        feat = FEAT_QUARTZ;
       }
      }
                    } else if (!square_iswall(cave, grid)) {
      /* If we started with open floor */
                        if (randint1(8) <= adj_chasms + 1) {
       feat = FEAT_CHASM;
      } else if (t < 40) {
       feat = FEAT_RUBBLE;
      } else if (t < 80) {
       feat = FEAT_GRANITE;
      } else {
       feat = FEAT_QUARTZ;
      }
     } else if (square_isrubble(cave, grid)) {
      /* If we started with rubble */
                        if (randint1(32) <= adj_chasms) {
       feat = FEAT_CHASM;
                        } else if (t < 40) {
       feat = FEAT_FLOOR;
      } else if (t < 70) {
       feat = FEAT_GRANITE;
      } else {
                            feat = FEAT_QUARTZ;
      }
     } else {
      /* If we started with a wall of some sort */
                        if (randint1(32) <= adj_chasms) {
       feat = FEAT_CHASM;
      } else if (t < 80) {
       feat = FEAT_RUBBLE;
      } else {
                            feat = FEAT_FLOOR;
      }
     }
                    /* Change the feature (unless it would be making a chasm
					 * at 950 or 1000 ft) */
                    if ((feat != FEAT_CHASM) &&
      (player->depth < z_info->dun_depth - 1)) {
                        square_unmark(cave, grid);
      square_set_feat(cave, grid, feat);
                    }
    }
   }
  }
 }
 if (player_damage) {
  int prt, net_dam;
  /* Appropriate message */
  msg("You are pummeled with debris!");
  /* Apply protection */
  prt = protection_roll(player, PROJ_HURT, false, RANDOMISE);
  net_dam = player_damage - prt;
  /* Take the damage */
  if (net_dam > 0) {
   take_hit(player, net_dam, "an earthquake");
  }
  if (!player->is_dead) {
   player_inc_timed(player, TMD_STUN, net_dam * 4,
    true, true, true);
  }
  /* Update combat rolls */
  event_signal_combat_attack(EVENT_COMBAT_ATTACK, context->origin,
   source_player(), vis, -1, -1, -1, -1, false);
  event_signal_combat_damage(EVENT_COMBAT_DAMAGE, player_dd,
   player_ds, player_damage, -1, -1, prt, 100, PROJ_HURT,
   false);
 }
 /* Fall into the pit if there were no safe squares to jump to */
 if (fall_in && !player->is_dead && square_ispit(cave, pgrid)) {
  int damage;
  msg("You fall back into the newly made pit!");
  /* Falling damage */
  damage = damroll(2, 4);
  /* Update combat rolls */
  event_signal_combat_attack(EVENT_COMBAT_ATTACK, source_grid(pgrid),
           source_player(), true, -1, -1, -1, -1,false);
  event_signal_combat_damage(EVENT_COMBAT_DAMAGE, 2, 4, damage, -1, -1,
           0, 0, PROJ_HURT, false);
  /* Take the damage */
  take_hit(player, damage, "falling into a pit");
 }
 /* Make a lot of noise */
 monsters_hear(true, false, -30);
 /* Fully update the visuals */
 player->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
 /* Redraw map and health bar */
 player->upkeep->redraw |= (PR_MAP | PR_HEALTH);
 /* Window stuff */
 player->upkeep->redraw |= (PR_MONLIST | PR_ITEMLIST);
 return true;
}
/**
 * Project from the source grid at the player, with full intensity out to
 * its radius
 * Affect the player
 */
bool effect_handler_SPOT(effect_handler_context_t *context)
{
 struct loc pgrid = player->grid;
 int rad = context->radius ? context->radius : 0;
 int flg = PROJECT_JUMP | PROJECT_PLAY;
 /* Aim at the target */
 if (project(context->origin, rad, pgrid, context->value.dice,
    context->value.sides, context->value.m_bonus, context->subtype,
    flg, 0, true, NULL))
  context->ident = true;
 return true;
}
/**
 * Project from the player's grid, act as a ball, with full intensity out as
 * far as the given diameter
 * Affect grids, objects, and monsters
 */
bool effect_handler_SPHERE(effect_handler_context_t *context)
{
 struct loc pgrid = player->grid;
 int rad = context->radius ? context->radius : 0;
 int diameter_of_source = context->other ? context->other : 0;
 int flg = PROJECT_STOP | PROJECT_GRID | PROJECT_ITEM | PROJECT_KILL;
 if (context->origin.what == SRC_MONSTER) {
  flg |= PROJECT_PLAY;
 }
 /* Explode */
 if (project(context->origin, rad, pgrid, context->value.dice,
    context->value.sides, context->value.m_bonus, context->subtype,
    flg, 0, diameter_of_source, NULL))
  context->ident = true;
 return true;
}
/**
 * Cast a ball spell that explodes immediately on the origin and
 * hurts everything.
 * Affect grids, objects, and monsters
 */
bool effect_handler_EXPLOSION(effect_handler_context_t *context)
{
 int dd = context->value.dice;
 int ds = context->value.sides;
 int dif = context->value.base;
 int rad = context->radius ? context->radius : 0;
 struct loc target = origin_get_loc(context->origin);
 int flg = PROJECT_BOOM | PROJECT_GRID | PROJECT_JUMP |
  PROJECT_ITEM | PROJECT_KILL | PROJECT_PLAY;
 /* Explode at the target */
 if (project(context->origin, rad, target, dd, ds, dif, context->subtype,
    flg, 0, true, context->obj))
  context->ident = true;
 return true;
}
/**
 * Breathe an element, in a cone from the breather
 * Affect grids, objects, and monsters
 * context->subtype is element, context->other degrees of arc
 * If context->radius is set it is radius of breath, but it usually isn't
 */
bool effect_handler_BREATH(effect_handler_context_t *context)
{
 int type = context->subtype;
 struct loc target = player->grid;
 /* Breath width */
 int degrees_of_arc = context->other;
 /*
	 * Distance breathed generally has no fixed limit; if the radius set
	 * is zero, the displayed effect will only go out to the range where
	 * damage can still be inflicted (i.e. the PROJECT_RANGE_DAM flag).
	 */
 int rad = context->radius;
 int flg = PROJECT_ARC | PROJECT_GRID | PROJECT_ITEM | PROJECT_KILL
  | PROJECT_PLAY | PROJECT_RANGE_DAM;
 /* Breathe at the target */
 if (project(context->origin, rad, target, context->value.dice,
    context->value.sides, context->value.m_bonus, type, flg,
    degrees_of_arc, 0, context->obj))
  context->ident = true;
 return true;
}
/**
 * Cast a bolt spell
 * Stop if we hit a monster, as a bolt
 * Affect monsters (not grids or objects)
 */
bool effect_handler_BOLT(effect_handler_context_t *context)
{
 int flg = PROJECT_STOP | PROJECT_KILL;
 (void) project_aimed(context->origin, context->subtype, context->dir,
       context->value.dice, context->value.sides,
       context->value.m_bonus, flg, context->obj);
 if (!player->timed[TMD_BLIND])
  context->ident = true;
 return true;
}
/**
 * Cast a beam spell
 * Pass through monsters, as a beam
 * Affect monsters (not grids or objects)
 */
bool effect_handler_BEAM(effect_handler_context_t *context)
{
 int flg = PROJECT_BEAM | PROJECT_KILL;
 (void) project_aimed(context->origin, context->subtype, context->dir,
  context->value.dice, context->value.sides,
  context->value.m_bonus, flg, context->obj);
 if (!player->timed[TMD_BLIND]) {
  context->ident = true;
 }
 return true;
}
/**
 * Cast a beam spell which affects grids or objects, but not monsters.
 * Allows for targeting up or down (an effect that uses that should set the
 * other parameter for the effect to a non-zero value), but the handling of
 * the effect subtype there is not general:  currently assumes it is KILL_WALL.
 */
bool effect_handler_TERRAIN_BEAM(effect_handler_context_t *context)
{
 if (context->dir == DIR_UP || context->dir == DIR_DOWN) {
  /* Verify that the effect allows targeting up or down. */
  assert(context->other);
  assert(context->subtype == PROJ_KILL_WALL);
  if (context->dir == DIR_UP) {
   player_blast_ceiling(player);
  } else {
   player_blast_floor(player);
  }
  context->ident = true;
 } else {
  int flg = PROJECT_BEAM | PROJECT_GRID | PROJECT_ITEM
   | PROJECT_WALL;
  (void) project_aimed(context->origin, context->subtype,
   context->dir, context->value.dice, context->value.sides,
   context->value.m_bonus, flg, context->obj);
  if (!player->timed[TMD_BLIND]) {
   context->ident = true;
  }
 }
 return true;
}
/**
 * \file effect-handler-general.c
 * \brief Handler functions for general effects
 *
 * Copyright (c) 2007 Andi Sidwell
 * Copyright (c) 2016 Ben Semmler, Nick McConnell
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Set value for a chain of effects
 */
static int set_value = 0;
int effect_calculate_value(effect_handler_context_t *context)
{
 int final = 0;
 if (set_value) {
  return set_value;
 }
 if (context->value.base > 0 ||
  (context->value.dice > 0 && context->value.sides > 0)) {
  final = context->value.base +
   damroll(context->value.dice, context->value.sides);
 }
 return final;
}
/**
 * Stat adjectives
 */
static const char *desc_stat(int stat, bool positive)
{
 struct obj_property *prop = lookup_obj_property(OBJ_PROPERTY_STAT, stat);
 if (positive) {
  return prop->adjective;
 }
 return prop->neg_adj;
}
/**
 * Attempt to close a single square of chasm.
 *
 * Marks grids to be closed with the SQUARE_TEMP flag..
 */
static bool close_chasm(struct loc grid, int power)
{
    int adj_chasms = 0;
    int y, x;
    bool effect = false;
    for (y = grid.y - 1; y <= grid.y + 1; y++) {
        for (x = grid.x - 1; x <= grid.x + 1; x++) {
   struct loc adj = loc(x, y);
            if (!loc_eq(adj, grid) && square_in_bounds(cave, adj) &&
    square_ischasm(cave, adj)) {
    adj_chasms++;
   }
  }
    }
    /* Cannot close chasms that are completely surrounded */
    if (adj_chasms < 8) {
        if (skill_check(source_player(), power, 20 + adj_chasms,
      source_none()) > 0) {
            square_mark(cave, grid);
            effect = true;
        }
    }
    return effect;
}
/**
 * Close all marked chasms
 */
static void close_marked_chasms(void)
{
 struct loc grid;
 /* Search the whole map */
 for (grid.y = 0; grid.y < cave->height; grid.y++) {
  for (grid.x = 0; grid.x < cave->width; grid.x++) {
   /* Find all the marked chasms */
   if (square_ischasm(cave, grid) && square_ismark(cave, grid)) {
    /* Unmark and add floor */
    square_unmark(cave, grid);
    square_set_feat(cave, grid, FEAT_FLOOR);
    /* Memorize */
    square_memorize(cave, grid);
    square_light_spot(cave, grid);
   }
  }
 }
}
/**
 * Selects items that have at least one unknown rune.
 */
static bool item_tester_unknown(const struct object *obj)
{
    return object_runes_known(obj) ? false : true;
}
/**
 * ------------------------------------------------------------------------
 * Effect handlers
 * ------------------------------------------------------------------------ */
/**
 * Feed the player, or set their satiety level.
 */
bool effect_handler_NOURISH(effect_handler_context_t *context)
{
 const char *old_grade = player_get_timed_grade(player, TMD_FOOD);
 int amount = effect_calculate_value(context);
 if (context->subtype == 0) {
  /* Increase food level by amount */
  player_inc_timed(player, TMD_FOOD, MAX(amount, 0), false,
   context->origin.what != SRC_PLAYER || !context->aware,
   false);
 } else if (context->subtype == 1) {
  /* Decrease food level by amount */
  player_dec_timed(player, TMD_FOOD, MAX(amount, 0), false,
   context->origin.what != SRC_PLAYER || !context->aware);
 } else {
  return false;
 }
 /*
	 * If the effect's other parameter is nonzero, only identify if the
	 * timed grade changed.  Otherwise, always identify.
	 */
 if (context->other) {
  if (old_grade != player_get_timed_grade(player, TMD_FOOD)) {
   context->ident = true;
  }
 } else {
  context->ident = true;
 }
 return true;
}
/**
 * Cure a player status condition.
 */
bool effect_handler_CURE(effect_handler_context_t *context)
{
 int type = context->subtype;
 (void) player_clear_timed(player, type, true,
  context->origin.what != SRC_PLAYER || !context->aware);
 context->ident = true;
 return true;
}
/**
 * Set a (positive or negative) player status condition.
 */
bool effect_handler_TIMED_SET(effect_handler_context_t *context)
{
 int amount = effect_calculate_value(context);
 if (player_set_timed(player, context->subtype, MAX(amount, 0), true,
   context->origin.what != SRC_PLAYER ||
   !context->aware)) {
  context->ident = true;
 }
 return true;
}
/**
 * Extend a (positive or negative) player status condition.
 */
bool effect_handler_TIMED_INC(effect_handler_context_t *context)
{
 int amount = effect_calculate_value(context);
 player_inc_timed(player, context->subtype, MAX(amount, 0), true,
  context->origin.what != SRC_PLAYER || !context->aware, true);
 context->ident = true;
 return true;
}
/**
 * Check if we can impose a player status condition.
 * This effect uses context->ident to report whether or not the check is
 * successful, so should never be used for objects.
 */
bool effect_handler_TIMED_INC_CHECK(effect_handler_context_t *context)
{
 context->ident = player_inc_check(player, context->subtype, false);
 return true;
}
/**
 * Extend a (positive or negative) player status condition unresistably.
 */
bool effect_handler_TIMED_INC_NO_RES(effect_handler_context_t *context)
{
 int amount = effect_calculate_value(context);
 player_inc_timed(player, context->subtype, MAX(amount, 0), true,
  context->origin.what != SRC_PLAYER || !context->aware, false);
 context->ident = true;
 return true;
}
/**
 * Special timed effect for herbs of terror.
 */
bool effect_handler_TERROR(effect_handler_context_t *context)
{
 bool afraid = player_inc_check(player, TMD_AFRAID, false);
 if (afraid) {
  int fear_amount, haste_amount;
  fear_amount = damroll(context->value.dice, context->value.sides);
  haste_amount = damroll(context->value.dice / 2, context->value.sides);
  context->ident = !player->timed[TMD_AFRAID] || !player->timed[TMD_FAST];
  player_inc_timed(player, TMD_AFRAID, MAX(fear_amount, 0), true,
   context->origin.what != SRC_PLAYER || !context->aware,
   false);
  player_inc_timed(player, TMD_FAST, MAX(haste_amount, 0), true,
   context->origin.what != SRC_PLAYER || !context->aware,
   false);
 } else {
  msg("You feel nervous for a moment.");
  context->ident = true;
 }
 return true;
}
/**
 * Create a glyph.
 */
bool effect_handler_GLYPH(effect_handler_context_t *context)
{
 /* Always notice */
 context->ident = true;
 /* See if the effect works */
 if (!square_istrappable(cave, player->grid)) {
  msg("You cannot draw a glyph without a clean expanse of floor.");
  return false;
 }
 /* Push objects off the grid */
 if (square_object(cave, player->grid))
  push_object(player->grid);
 /* Create a glyph */
 msg("You trace out a glyph of warding upon the floor.");
 square_add_glyph(cave, player->grid, context->subtype);
 return true;
}
/**
 * Restore a stat; the stat index is context->subtype
 */
bool effect_handler_RESTORE_STAT(effect_handler_context_t *context)
{
 int stat = context->subtype;
 int gain = effect_calculate_value(context);
 /* Check bounds */
 if (stat < 0 || stat >= STAT_MAX) return false;
 /* Attempt to increase */
 if (player_stat_res(player, stat, gain)) {
  /* Message */
  msg("You feel less %s.", desc_stat(stat, false));
  /* ID */
  context->ident = true;
 }
 return true;
}
/**
 * Drain a stat temporarily.  The stat index is context->subtype.
 */
bool effect_handler_DRAIN_STAT(effect_handler_context_t *context)
{
 int stat = context->subtype;
 int flag = sustain_flag(stat);
 struct monster *mon = cave_monster(cave, cave->mon_current);
 /* Bounds check */
 if (flag < 0) return false;
 /* Sustain */
 if (player_saving_throw(player, mon, player->state.flags[flag])) {
  /* Message */
  msg("You feel %s for a moment, but it passes.", desc_stat(stat, false));
  /* Notice effect */
  equip_learn_flag(player, flag);
  context->ident = true;
  return true;
 }
 /* Reduce the stat */
 player_stat_dec(player, stat);
 msgt(MSG_DRAIN_STAT, "You feel %s.", desc_stat(stat, false));
 /* ID */
 context->ident = true;
 return true;
}
bool effect_handler_RESTORE_MANA(effect_handler_context_t *context)
{
 int amount = effect_calculate_value(context);
 if (!amount) amount = player->msp;
 if (player->csp < player->msp) {
  player->csp += amount;
  if (player->csp > player->msp) {
   player->csp = player->msp;
   player->csp_frac = 0;
   msg("You feel your power renew.");
  } else
   msg("You feel your power renew somewhat.");
  player->upkeep->redraw |= (PR_MANA);
 }
 context->ident = true;
 return true;
}
/**
 * Uncurse all equipped objects
 */
bool effect_handler_REMOVE_CURSE(effect_handler_context_t *context)
{
 int i;
 bool removed = false;
 for (i = 0; i < player->body.count; i++) {
  struct object *obj = slot_object(player, i);
  /* Skip non-objects, non-cursed objects */
  if (!obj || !obj->kind) continue;
  if (!obj_is_cursed(obj)) continue;
  /* Uncurse the object */
  uncurse_object(obj);
  removed = true;
 }
 if (removed) {
  context->ident = true;
  msg("You feel sanctified.");
 }
 return true;
}
/**
 * Map the dungeon level.
 */
bool effect_handler_MAP_AREA(effect_handler_context_t *context)
{
 int i, x, y;
 /* Scan the dungeon */
 for (y = 1; y < cave->height - 1; y++) {
  for (x = 1; x < cave->width - 1; x++) {
   struct loc grid = loc(x, y);
   /* All non-walls are "checked" */
   if (!square_seemslikewall(cave, grid)) {
    if (!square_in_bounds_fully(cave, grid)) continue;
    /* Memorize normal features */
    if (!square_isfloor(cave, grid))
     square_memorize(cave, grid);
    /* Memorize known walls */
    for (i = 0; i < 8; i++) {
     int yy = y + ddy_ddd[i];
     int xx = x + ddx_ddd[i];
     /* Memorize walls (etc) */
     if (square_seemslikewall(cave, loc(xx, yy)))
      square_memorize(cave, loc(xx, yy));
    }
   }
   /* Forget unprocessed, misremembered grids in the mapping area */
   if (square_ismemorybad(cave, grid)) {
    square_unmark(cave, grid);
   }
  }
 }
 /* Fully update the visuals */
 player->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
 /* Redraw whole map, monster list */
 player->upkeep->redraw |= (PR_MAP | PR_MONLIST | PR_ITEMLIST);
 /* Notice */
 context->ident = true;
 return true;
}
/**
 * Detect traps in the player's line of sight.
 */
bool effect_handler_DETECT_TRAPS(effect_handler_context_t *context)
{
 struct loc grid;
 bool detect = false;
 /* Affect all viewable grids */
 for (grid.y = player->grid.y - z_info->max_sight;
   grid.y <= player->grid.y + z_info->max_sight; grid.y++) {
  for (grid.x = player->grid.x - z_info->max_sight;
    grid.x <= player->grid.x + z_info->max_sight; grid.x++) {
   /* Grid must be in bounds and in the player's LoS */
   if (!square_in_bounds_fully(cave, grid)) continue;
   if (!square_isview(cave, grid)) continue;
   /* Detect traps */
   if (square_isplayertrap(cave, grid)) {
    /* Reveal trap */
    if (square_reveal_trap(cave, grid, false)) {
     detect = true;
    }
   }
  }
 }
 /* Describe */
 if (detect) {
  msg("You sense the presence of traps!");
 }
 /* Notice */
 context->ident = true;
 return true;
}
/**
 * Detect doors in the player's line of sight.
 */
bool effect_handler_DETECT_DOORS(effect_handler_context_t *context)
{
 struct loc grid;
 bool doors = false;
 /* Affect all viewable grids */
 for (grid.y = player->grid.y - z_info->max_sight;
   grid.y <= player->grid.y + z_info->max_sight; grid.y++) {
  for (grid.x = player->grid.x - z_info->max_sight;
    grid.x <= player->grid.x + z_info->max_sight; grid.x++) {
   /* Grid must be in bounds and in the player's LoS */
   if (!square_in_bounds_fully(cave, grid)) continue;
   if (!square_isview(cave, grid)) continue;
   /* Detect secret doors */
   if (square_issecretdoor(cave, grid)) {
    /* Put an actual door */
    place_closed_door(cave, grid);
    /* Memorize */
    square_memorize(cave, grid);
    square_light_spot(cave, grid);
    /* Obvious */
    doors = true;
   } else if (square_isdoor(cave, grid)) {
    /* Detect other types of doors. */
    if (square_ismemorybad(cave, grid)) {
     square_memorize(cave, grid);
     square_light_spot(cave, grid);
     doors = true;
    }
   } else if (square_isdoor(player->cave, grid)
     && square_ismemorybad(cave, grid)) {
    /*
				 * Forget misremembered doors in the mapping
				 * area.
				 */
    square_forget(cave, grid);
   }
  }
 }
 /* Describe */
 if (doors)
  msg("You sense the presence of doors!");
 else if (context->aware)
  msg("You sense no doors.");
 context->ident = true;
 return true;
}
/**
 * Detect monsters which satisfy the given predicate around the player.
 */
static bool detect_monsters(monster_predicate pred)
{
 int i;
 bool monsters = false;
 /* Scan monsters */
 for (i = 1; i < cave_monster_max(cave); i++) {
  struct monster *mon = cave_monster(cave, i);
  /* Skip dead monsters */
  if (!mon->race) continue;
  /* Detect all appropriate, obvious monsters */
  if (!pred || pred(mon)) {
   /* Detect the monster */
   mflag_on(mon->mflag, MFLAG_MARK);
   mflag_on(mon->mflag, MFLAG_SHOW);
   /* Note invisible monsters */
   if (monster_is_invisible(mon)) {
    struct monster_lore *lore = get_lore(mon->race);
    rf_on(lore->flags, RF_INVISIBLE);
   }
   /* Update monster recall window */
   if (player->upkeep->monster_race == mon->race)
    /* Redraw stuff */
    player->upkeep->redraw |= (PR_MONSTER);
   /* Update the monster */
   update_mon(mon, cave, false);
   /* Detect */
   monsters = true;
  }
 }
 return monsters;
}
/**
 * Detect objects on the level.
 */
bool effect_handler_DETECT_OBJECTS(effect_handler_context_t *context)
{
 int x, y;
 bool objects = false;
 /* Scan the area for objects */
 for (y = 1; y <= cave->height - 1; y++) {
  for (x = 1; x <= cave->width - 1; x++) {
   struct loc grid = loc(x, y);
   struct object *obj = square_object(cave, grid);
   if (!obj) continue;
   /* Notice an object is detected */
   if (!ignore_item_ok(player, obj)) {
    objects = true;
    context->ident = true;
   }
   /* Mark the pile as seen */
   square_know_pile(cave, grid);
  }
 }
 if (objects)
  msg("You detect the presence of objects!");
 else if (context->aware)
  msg("You detect no objects.");
 /* Redraw whole map, monster list */
 player->upkeep->redraw |= PR_ITEMLIST;
 return true;
}
/**
 * Detect monsters on the level.
 */
bool effect_handler_DETECT_MONSTERS(effect_handler_context_t *context)
{
 bool monsters = detect_monsters(NULL);
 if (monsters) {
  msg("You sense the presence of your enemies!");
  context->ident = true;
 }
 return monsters;
}
/**
 * Reveal an invisible monster.
 */
bool effect_handler_REVEAL_MONSTER(effect_handler_context_t *context)
{
 assert(context->origin.what == SRC_MONSTER);
 struct monster *mon = cave_monster(cave, context->origin.which.monster);
 char m_name[80];
 struct monster_lore *lore = get_lore(mon->race);
 /* Reject if no effect */
 if (monster_is_visible(mon) || !rf_has(mon->race->flags, RF_INVISIBLE)) {
  return false;
 }
 /* Mark as visible */
 mflag_on(mon->mflag, MFLAG_VISIBLE);
 /* Re-draw the spot*/
 square_light_spot(cave, mon->grid);
 /* Get the monster name */
 monster_desc(m_name, sizeof(m_name), mon, MDESC_DEFAULT);
 /* Monster forgets player history (?) */
 msg("%s appears for an instant!", m_name);
 /* Update the lore*/
 rf_on(lore->flags, RF_INVISIBLE);
 context->ident = true;
 return true;
}
/**
 * Close chasms in the player's line of sight.
 */
bool effect_handler_CLOSE_CHASMS(effect_handler_context_t *context)
{
 struct loc grid;
 bool closed = false;
 int power = effect_calculate_value(context);
 /* Affect all viewable grids */
 for (grid.y = player->grid.y - z_info->max_sight;
   grid.y <= player->grid.y + z_info->max_sight; grid.y++) {
  for (grid.x = player->grid.x - z_info->max_sight;
    grid.x <= player->grid.x + z_info->max_sight; grid.x++) {
   /* Grid must be in bounds and in the player's LoS */
   if (!square_in_bounds_fully(cave, grid)) continue;
   if (!square_isview(cave, grid)) continue;
   /* Attempt to mark chasms for closing */
   if (square_ischasm(cave, grid)) {
    closed |= close_chasm(grid, power);
   }
  }
 }
 if (closed) {
  close_marked_chasms();
 }
 context->ident = true;
 return true;
}
/**
 * Identify an unknown item.
 */
bool effect_handler_IDENTIFY(effect_handler_context_t *context)
{
 struct object *obj;
 const char *q, *s;
 int itemmode = (USE_EQUIP | USE_INVEN | USE_QUIVER | USE_FLOOR);
 bool used = false;
 context->ident = true;
 /* Get an item */
 q = "Identify which item? ";
 s = "You have nothing to identify.";
 if (context->cmd) {
  if (cmd_get_item(context->cmd, "tgtitem", &obj, q, s,
    item_tester_unknown, itemmode)) {
   return used;
  }
 } else if (!get_item(&obj, q, s, 0, item_tester_unknown, itemmode))
  return used;
 /* Identify the object */
 object_learn_unknown_rune(player, obj);
 return true;
}
/**
 * Recharge a staff from the pack or on the floor.  Number of charges
 * is context->value.base.
 */
bool effect_handler_RECHARGE(effect_handler_context_t *context)
{
 int num = context->value.base;
 int itemmode = (USE_INVEN | USE_FLOOR);
 struct object *obj;
 bool used = false;
 const char *q, *s;
 /* Immediately obvious */
 context->ident = true;
 /* Get an item */
 q = "Recharge which item? ";
 s = "You have nothing to recharge.";
 if (context->cmd) {
  if (cmd_get_item(context->cmd, "tgtitem", &obj, q, s,
    tval_can_have_charges, itemmode)) {
   return used;
  }
 } else if (!get_item(&obj, q, s, 0, tval_can_have_charges, itemmode)) {
  return (used);
 }
 obj->pval += num;
 obj->notice &= ~(OBJ_NOTICE_EMPTY);
 /* Combine the pack (later) */
 player->upkeep->notice |= (PN_COMBINE);
 /* Redraw stuff */
 player->upkeep->redraw |= (PR_INVEN);
 /* Something was done */
 return true;
}
/**
 * Summon context->value monsters of context->subtype type.
 * If context->other is set, summon random monsters on stairs
 */
bool effect_handler_SUMMON(effect_handler_context_t *context)
{
 int summon_max = effect_calculate_value(context);
 int summon_type = context->subtype;
 bool stairs = context->other ? true : false;
 int level_boost = damroll(2, 2) - damroll(2, 2);
 int message_type = summon_message_type(summon_type);
 int count = 0;
 sound(message_type);
 if (stairs) {
  int i;
  for (i = 0; i < summon_max; i++) {
   if (pick_and_place_monster_on_stairs(cave, player, false,
             player->depth, false))
    context->ident = true;
  }
 } else {
  /* Summon some monsters */
  int itry = 0;
  while (count < summon_max && itry < 1000) {
   count += summon_specific(player->grid, player->depth + level_boost,
          summon_type);
   ++itry;
  }
  /* Identify */
  context->ident = count ? true : false;
 }
 return true;
}
/**
 * Teleport player or target monster to a grid near the given location
 * This function is slightly obsessive about correctness.
 * This function allows teleporting into vaults (!)
 */
bool effect_handler_TELEPORT_TO(effect_handler_context_t *context)
{
 struct loc start = player->grid, aim, land;
 int dis = 0, ctr = 0, dir = DIR_TARGET;
 context->ident = true;
 /* Where are we going? */
 do {
  if (!get_aim_dir(&dir, cave->width)) return false;
 } while (dir == DIR_TARGET && !target_okay(cave->width));
 if (dir == DIR_TARGET)
  target_get(&aim);
 else
  aim = loc_offset(start, ddx[dir], ddy[dir]);
 /* Find a usable location */
 while (1) {
  /* Pick a nearby legal location */
  while (1) {
   land = rand_loc(aim, dis, dis);
   if (square_in_bounds_fully(cave, land)) break;
  }
  /* Accept "naked" floor grids */
  if (square_isempty(cave, land)) break;
  /* Occasionally advance the distance */
  if (++ctr > (4 * dis * dis + 4 * dis + 1)) {
   ctr = 0;
   dis++;
  }
 }
 /* Sound */
 sound(MSG_TELEPORT);
 /* Move player or monster */
 monster_swap(start, land);
 /* Cancel target if necessary */
 target_set_location(loc(0, 0));
 /* Lots of updates after monster_swap */
 handle_stuff(player);
 return true;
}
bool effect_handler_DARKEN_LEVEL(effect_handler_context_t *context)
{
 wiz_dark(cave, player);
 context->ident = true;
 return true;
}
/**
 * Call light around the player
 */
bool effect_handler_LIGHT_AREA(effect_handler_context_t *context)
{
 struct loc pgrid = player->grid;
 int rad = context->radius ? context->radius : 0;
 int flg = PROJECT_BOOM | PROJECT_GRID | PROJECT_KILL;
 /* Message */
 if (!player->timed[TMD_BLIND])
  msg("You are surrounded by a white light.");
 /* Lots of light */
 (void) project(source_player(), rad, pgrid, context->value.dice,
       context->value.sides, -1, context->subtype, flg, 0, false,
       NULL);
 /* Assume seen */
 context->ident = true;
 return (true);
}
/**
 * Call darkness around the player or target monster
 */
bool effect_handler_DARKEN_AREA(effect_handler_context_t *context)
{
 bool message = player->timed[TMD_BLIND] ? false : true;
 if (message) {
  msg("Darkness surrounds you.");
 }
 /* Darken the room */
 light_room(player->grid, false);
 /* Assume seen */
 context->ident = true;
 return (true);
}
/**
 * Attempt to decrease morale of all intelligent monsters.
 */
bool effect_handler_SONG_OF_ELBERETH(effect_handler_context_t *context)
{
 int i;
 int score = song_bonus(player, player->state.skill_use[SKILL_SONG],
         lookup_song("Elbereth"));
 for (i = cave_monster_max(cave) - 1; i >= 1; i--) {
  struct monster *mon = cave_monster(cave, i);
  int resistance;
  int result;
  /* Ignore dead monsters */
  if (!mon->race) continue;
  /* Only intelligent monsters are affected */
  if (!rf_has(mon->race->flags, RF_SMART)) continue;
  /* Morgoth is not affected */
  if (!rf_has(mon->race->flags, RF_QUESTOR)) continue;
  /* Resistance is monster will, modified by distance from the player */
  resistance = monster_skill(mon, SKILL_WILL);
  resistance += flow_dist(cave->player_noise, mon->grid);
  result = skill_check(source_player(), score, resistance,
        source_monster(mon->midx));
  /* If successful, cause fear in the monster */
  if (result > 0) {
   /* Decrease temporary morale */
   mon->tmp_morale -= result * 10;
  }
 }
 return true;
}
/**
 * Attempt to decrease alertness of all monsters.
 */
bool effect_handler_SONG_OF_LORIEN(effect_handler_context_t *context)
{
 int i;
 int score = song_bonus(player, player->state.skill_use[SKILL_SONG],
         lookup_song("Lorien"));
 for (i = cave_monster_max(cave) - 1; i >= 1; i--) {
  struct monster *mon = cave_monster(cave, i);
  int resistance;
  int result;
  /* Ignore dead monsters */
  if (!mon->race) continue;
  /* Deal with sleep resistance */
  if (rf_has(mon->race->flags, RF_NO_SLEEP)) {
   struct monster_lore *lore = get_lore(mon->race);;
   if (monster_is_visible(mon)) {
    rf_on(lore->flags, RF_NO_SLEEP);
   }
   continue;
  }
  /* Resistance is monster will, modified by distance from the player */
  resistance = monster_skill(mon, SKILL_WILL);
  resistance += 5 + flow_dist(cave->player_noise, mon->grid);
  result = skill_check(source_player(), score, resistance,
        source_monster(mon->midx));
  /* If successful, (partially) put the monster to sleep */
  if (result > 0) {
   set_alertness(mon, mon->alertness - result);
  }
 }
 return true;
}
/**
 * Affect a variety of terrain to help the player escape
 */
bool effect_handler_SONG_OF_FREEDOM(effect_handler_context_t *context)
{
 int base_diff = player->depth ? player->depth / 2 : 10;
 int score = song_bonus(player, player->state.skill_use[SKILL_SONG],
         lookup_song("Freedom"));
 struct loc grid;
 bool closed_chasm = false;
    /* Scan the map */
    for (grid.y = 0; grid.y < cave->height; grid.y++) {
        for (grid.x = 0; grid.x < cave->width; grid.x++) {
   struct object *obj;
   if (!square_in_bounds_fully(cave, grid)) continue;
   obj = square_object(cave, grid);
   if (obj && tval_is_chest(obj) && (obj->pval > 0)) {
    /* Chest */
    int diff = base_diff + 5 + flow_dist(cave->player_noise, grid);
    if (skill_check(source_player(), score, diff, source_none())) {
                        /* Disarm or Unlock */
                        obj->pval = (0 - obj->pval);
                        /* Identify */
                        obj->known->pval = obj->pval;
    }
   } else if (square_ischasm(cave, grid)) {
    /* Chasm */
    int power = score - flow_dist(cave->player_noise, grid) - 5;
                closed_chasm |= close_chasm(grid, power);
   } else if (square_issecrettrap(cave, grid)) {
    /* Invisible trap */
    int diff = base_diff + 5 + flow_dist(cave->player_noise, grid);
    if (skill_check(source_player(), score, diff, source_none())
     > 0) {
     square_destroy_trap(cave, grid);
    }
   } else if (square_isvisibletrap(cave, grid)) {
    /* Visible trap */
    int diff = base_diff + 5 + flow_dist(cave->player_noise, grid);
    if (skill_check(source_player(), score, diff, source_none())
     > 0) {
     square_destroy_trap(cave, grid);
     square_light_spot(cave, grid);
    }
   } else if (square_issecretdoor(cave, grid)) {
    /* Secret door */
    int diff = base_diff + flow_dist(cave->player_noise, grid);
    if (skill_check(source_player(), score, diff, source_none())
     > 0) {
     place_closed_door(cave, grid);
     if (square_isseen(cave, grid)) {
      msg("You have found a secret door.");
      disturb(player, false);
     }
    }
   } else if (square_isjammeddoor(cave, grid)) {
    /* Stuck door */
    int diff = base_diff + flow_dist(cave->player_noise, grid);
    int result = skill_check(source_player(), score, diff,
           source_none());
    if (result > 0) {
     int jam = square_door_jam_power(cave, grid) - result;
     square_set_door_jam(cave, grid, MAX(jam, 0));
    }
   } else if (square_islockeddoor(cave, grid)) {
    /* Locked door */
    int diff = base_diff + flow_dist(cave->player_noise, grid);
    int result = skill_check(source_player(), score, diff,
           source_none());
    if (result > 0) {
     int lock = square_door_lock_power(cave, grid) - result;
     square_set_door_lock(cave, grid, MAX(lock, 0));
    }
   } else if (square_isrubble(cave, grid)) {
    /* Rubble */
                int d, noise_dist = 100;
    int diff, result;
                /* Check adjacent squares for valid noise distances, since
				 * rubble is impervious to sound */
                for (d = 0; d < 8; d++) {
                    int dir = cycle[d];
     int noise_dist_new = flow_dist(cave->player_noise,
               loc_sum(grid, ddgrid[dir]));
     noise_dist = MIN(noise_dist, noise_dist_new);
                }
                noise_dist++;
                diff = base_diff + 5 + noise_dist;
                result = skill_check(source_player(), score, diff,
          source_none());
                if (result > 0) {
     square_set_feat(cave, grid, FEAT_FLOOR);
                    player->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
    }
   }
  }
 }
    /* Then, if any chasms were marked to be closed, do the closing */
    if (closed_chasm) {
  close_marked_chasms();
   }
 return true;
}
/**
 * Affect a variety of terrain to hinder the player's escape
 */
bool effect_handler_SONG_OF_BINDING(effect_handler_context_t *context)
{
 struct monster *mon = cave_monster(cave, context->origin.which.monster);
 int song_skill = monster_sing(mon, lookup_song("Binding"));
 struct loc grid;
 int dist, result, resistance;
 /* Use the monster noise flow to represent the song levels at each square */
 cave->monster_noise.centre = mon->grid;
    update_flow(cave, &cave->monster_noise, NULL);
    /* Scan the map, closing doors */
    for (grid.y = 0; grid.y < cave->height; grid.y++) {
        for (grid.x = 0; grid.x < cave->width; grid.x++) {
            if (!square_in_bounds_fully(cave, grid)) continue;
            /* If there is no player/monster in the square, and it's a door,
			* and the door isn't between the monster and the player */
            if (!square_monster(cave, grid) && square_isdoor(cave, grid) &&
    !((mon->grid.y <= grid.y) && (grid.y <= player->grid.y) &&
      (mon->grid.y <= grid.y) && (grid.y <= player->grid.y))) {
    dist = 15 + flow_dist(cave->monster_noise, grid);
    result = skill_check(source_monster(mon->midx), song_skill,
          dist, source_none());
    square_set_door_lock(cave, grid, result);
   }
  }
    }
    /* Determine the player's resistance */
 dist = flow_dist(cave->monster_noise, player->grid);
    resistance = player->state.skill_use[SKILL_WILL] +
  (player->state.flags[OF_FREE_ACT] * 10) + dist;
 /* Perform the skill check */
    result = skill_check(source_monster(mon->midx), song_skill, resistance,
       source_player());
    /* If the check succeeds, the player is slowed for at least 2 rounds.
	 * Note that only the first of these affects you as you aren't slow on the
	 * round it wears off */
    if (result > 0) {
  int slow = MAX(player->timed[TMD_SLOW], 2);
        player_set_timed(player, TMD_SLOW, slow, false, true);
    }
 return true;
}
/**
 * Increase the singing monster's alertness
 */
bool effect_handler_SONG_OF_PIERCING(effect_handler_context_t *context)
{
 struct monster *mon = cave_monster(cave, context->origin.which.monster);
 int song_skill = monster_sing(mon, lookup_song("Piercing"));
 int dist = flow_dist(cave->player_noise, mon->grid);
 int result, resistance;
    char name[80];
    /* Get the monster name */
    monster_desc(name, sizeof(name), mon, MDESC_POSS);
    /* Determine the player's resistance */
    resistance = player->state.skill_use[SKILL_WILL] + 5 + dist;
 /* Perform the skill check */
    result = skill_check(source_monster(mon->midx), song_skill, resistance,
       source_player());
    /* If the check succeeds, Morgoth knows the player's location */
    if (result > 0) {
        msg("You feel your mind laid bare before %s will.", name);
        set_alertness(mon, MIN(result, ALERTNESS_VERY_ALERT));
    } else if (result > -5) {
        msg("You feel the force of %s will searching for the intruder.", name);
    }
 return true;
}
/**
 * Increase the singing monster's alertness
 */
bool effect_handler_SONG_OF_OATHS(effect_handler_context_t *context)
{
 struct monster *mon = cave_monster(cave, context->origin.which.monster);
 int song_skill = monster_sing(mon, lookup_song("Oaths"));
 int result, resistance = 15;
 /* Use the monster noise flow to represent the song levels at each square */
 cave->monster_noise.centre = mon->grid;
    update_flow(cave, &cave->monster_noise, NULL);
 /* Perform the skill check */
    result = skill_check(source_monster(mon->midx), song_skill, resistance,
       source_player());
    /* If the check was successful, summon an oathwraith to a nearby square */
    if (result > 0) {
        /* The greatest distance away the wraith can be summoned --
		 * smaller is typically better */
        int range = MAX(15 - result, 3);
  struct loc grid;
  /* Summon an oathwraith within 'range' of the player */
  while (true) {
   struct monster *new;
   struct monster_group_info info = { 0, 0 };
   cave_find(cave, &grid, square_isarrivable);
   if (flow_dist(cave->monster_noise, grid) > range) continue;
   /* Place it */
   place_new_monster_one(cave, grid, lookup_monster("Oathwraith"),
          true, false, info, ORIGIN_DROP_SUMMON);
   new = square_monster(cave, grid);
   /* Message if visible */
   if (monster_is_visible(new)) {
    msg("An Oathwraith appears.");
   }
   /* Mark the wraith as having been summoned */
   mflag_on(new->mflag, MFLAG_SUMMONED);
   /* Let it know where the player is */
   set_alertness(new, ALERTNESS_QUITE_ALERT);
   break;
  }
 }
 return true;
}
/**
 * Make nearby monsters aggressive.
 */
bool effect_handler_AGGRAVATE(effect_handler_context_t *context)
{
 int i;
 for (i = 1; i < cave_monster_max(cave); i++) {
  /* Check the i'th monster */
  struct monster *mon = cave_monster(cave, i);
  struct monster_race *race = mon ? mon->race : NULL;
  if (!race) continue;
  if ((mon->alertness >= ALERTNESS_ALERT) &&
   (flow_dist(cave->player_noise, mon->grid) <= 10)) {
   mflag_on(mon->mflag, MFLAG_AGGRESSIVE);
            /* Notice if the monster is visible */
            if (monster_is_visible(mon)) context->ident = true;
   if (rf_has(race->flags, RF_SMART) &&
       (rf_has(race->flags, RF_FRIENDS) ||
     rf_has(race->flags, RF_FRIEND) ||
     rf_has(race->flags, RF_UNIQUE_FRIEND) ||
     rf_has(race->flags, RF_ESCORT) ||
     rf_has(race->flags, RF_ESCORTS) ||
     rsf_has(race->spell_flags, RSF_SHRIEK))) {
    tell_allies(mon, MFLAG_AGGRESSIVE);
                /* Notice if you hear them shout */
                context->ident = true;
   }
  }
 }
 return true;
}
/**
 * Make noise that monsters may hear and react to.
 */
bool effect_handler_NOISE(effect_handler_context_t *context)
{
 int amount = effect_calculate_value(context);
 bool player_centred = context->subtype ? true : false;
 if (context->origin.what == SRC_MONSTER) {
  struct monster *mon = cave_monster(cave, context->origin.which.monster);
  cave->monster_noise.centre = mon->grid;
  update_flow(cave, &cave->monster_noise, NULL);
  /* Radius is used for monster making its own noise */
  if (context->radius) mon->noise += context->radius;
 }
 monsters_hear(player_centred, false, amount);
 return true;
}
/**
 * Create traps.
 */
bool effect_handler_CREATE_TRAPS(effect_handler_context_t *context)
{
 int amount = effect_calculate_value(context);
 while (amount--) {
  struct loc grid;
  cave_find(cave, &grid, square_isunseen);
  square_add_trap(cave, grid);
 }
 return true;
}
/**
 * \file effects.c
 * \brief Public effect and auxiliary functions for every effect in the game
 *
 * Copyright (c) 2007 Andi Sidwell
 * Copyright (c) 2016 Ben Semmler, Nick McConnell
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * ------------------------------------------------------------------------
 * Properties of effects
 * ------------------------------------------------------------------------ */
/**
 * Useful things about effects.
 */
static const struct effect_kind effects[] =
{
 { EF_NONE, false, NULL, NULL, NULL, NULL },
/**
 * \file list-effects.h
 * \brief List of effects
 *
 * name: effect code
 * aim: does the effect require aiming?
 * info: info label for spells
 * args: how many arguments the description takes
 * info flags: flags for object description
 * description: text of description
 * menu_name: format string for menu name; use an empty string if there's no
 * plan to use it from a menu
 */
/* name 							aim		info		args	info flags		description	menu_name */
{ EF_HEAL_HP, false, "heal", effect_handler_HEAL_HP, "heals %s hitpoints%s", "heal self" },
{ EF_DAMAGE, false, "hurt", effect_handler_DAMAGE, "does %s damage to the player", "%s damage" },
{ EF_DART, false, "hurt", effect_handler_DART, "does %s damage to the player", "dart" },
{ EF_PIT, false, "hurt", effect_handler_PIT, "player falls in a pit", "pitfall" },
{ EF_PROJECT_LOS, false, "power", effect_handler_PROJECT_LOS, "%s which are in line of sight", "%s in line of sight" },
{ EF_PROJECT_LOS_GRIDS, false, "power", effect_handler_PROJECT_LOS_GRIDS, "%s which are in line of sight", "%s in line of sight" },
{ EF_DEADFALL, false, "hurt", effect_handler_DEADFALL, "makes rocks fall on the player", "deadfall" },
{ EF_EARTHQUAKE, false, NULL, effect_handler_EARTHQUAKE, "causes an earthquake around you of radius %d", "cause earthquake" },
{ EF_SPOT, false, "dam", effect_handler_SPOT, "creates a ball of %s with radius %d, centred on and hitting the player, with full intensity to radius %d, dealing %s damage at the centre", "engulf with %s" },
{ EF_SPHERE, false, "dam", effect_handler_SPHERE, "creates a ball of %s with radius %d, centred on the player, with full intensity to radius %d, dealing %s damage at the centre", "project %s" },
{ EF_EXPLOSION, false, "dam", effect_handler_EXPLOSION, "produces a blast of %s", "blast %s" },
{ EF_BREATH, true, NULL, effect_handler_BREATH, "breathes a cone of %s with width %d degrees, dealing %s damage at the source", "breathe a cone of %s" },
{ EF_BOLT, true, "dam", effect_handler_BOLT, "casts a bolt of %s dealing %s damage", "cast a bolt of %s" },
{ EF_BEAM, true, "dam", effect_handler_BEAM, "casts a beam of %s dealing %s damage", "cast a beam of %s" },
{ EF_TERRAIN_BEAM, true, NULL, effect_handler_TERRAIN_BEAM, "casts a beam of %s", "cast a beam of %s" },
{ EF_NOURISH, false, NULL, effect_handler_NOURISH, "%s for %s turns (%s percent)", "%s %s" },
{ EF_CURE, false, NULL, effect_handler_CURE, "cures %s", "cure %s" },
{ EF_TIMED_SET, false, NULL, effect_handler_TIMED_SET, "administers %s for %s turns", "administer %s" },
{ EF_TIMED_INC, false, "dur", effect_handler_TIMED_INC, "extends %s for %s turns", "extend %s" },
{ EF_TIMED_INC_CHECK, false, "dur", effect_handler_TIMED_INC_CHECK, "checks if %s can be extended", "checks %s extension" },
{ EF_TIMED_INC_NO_RES, false, "dur", effect_handler_TIMED_INC_NO_RES, "extends %s for %s turns (unresistable)", "extend %s" },
{ EF_TERROR, false, NULL, effect_handler_TERROR, "administers fear for %s turns, and haste for about half as long", "administer fear/haste" },
{ EF_GLYPH, false, NULL, effect_handler_GLYPH, "inscribes a glyph beneath you", "inscribe a glyph" },
{ EF_RESTORE_STAT, false, NULL, effect_handler_RESTORE_STAT, "restores your %s", "restore %s" },
{ EF_DRAIN_STAT, false, NULL, effect_handler_DRAIN_STAT, "reduces your %s", "drains %s" },
{ EF_RESTORE_MANA, false, NULL, effect_handler_RESTORE_MANA, "restores some mana", "restore some mana" },
{ EF_REMOVE_CURSE, false, NULL, effect_handler_REMOVE_CURSE, "attempts power %s removal of a single curse on an object", "remove curse" },
{ EF_MAP_AREA, false, NULL, effect_handler_MAP_AREA, "maps the current dungeon level", "map level" },
{ EF_DETECT_TRAPS, false, NULL, effect_handler_DETECT_TRAPS, "detects traps nearby", "detect traps" },
{ EF_DETECT_DOORS, false, NULL, effect_handler_DETECT_DOORS, "detects doors nearby", "detect doors" },
{ EF_DETECT_OBJECTS, false, NULL, effect_handler_DETECT_OBJECTS, "detects objects nearby", "detect objects" },
{ EF_DETECT_MONSTERS, false, NULL, effect_handler_DETECT_MONSTERS, "detects monsters on the level", "detect monsters" },
{ EF_REVEAL_MONSTER, false, NULL, effect_handler_REVEAL_MONSTER, "reveals a monster", "reveal monster" },
{ EF_CLOSE_CHASMS, false, NULL, effect_handler_CLOSE_CHASMS, "close nearby chasms", "close_chasms" },
{ EF_IDENTIFY, false, NULL, effect_handler_IDENTIFY, "identifie a selected item", "identify" },
{ EF_RECHARGE, false, "power", effect_handler_RECHARGE, "tries to recharge a wand or staff, destroying the wand or staff on failure", "recharge" },
{ EF_SUMMON, false, NULL, effect_handler_SUMMON, "summons %s at the current dungeon level", "summon %s" },
{ EF_TELEPORT_TO, false, NULL, effect_handler_TELEPORT_TO, "teleports toward a target", "teleport to target" },
{ EF_DARKEN_LEVEL, false, NULL, effect_handler_DARKEN_LEVEL, "completely darkens and forgets the level", "darken level" },
{ EF_LIGHT_AREA, false, NULL, effect_handler_LIGHT_AREA, "lights up the surrounding area", "light area" },
{ EF_DARKEN_AREA, false, NULL, effect_handler_DARKEN_AREA, "darkens the surrounding area", "darken area" },
{ EF_SONG_OF_ELBERETH, false, NULL, effect_handler_SONG_OF_ELBERETH, "sings a song of Elbereth", "song of Elbereth" },
{ EF_SONG_OF_LORIEN, false, NULL, effect_handler_SONG_OF_LORIEN, "sings a song of Lorien", "song of Lorien" },
{ EF_SONG_OF_FREEDOM, false, NULL, effect_handler_SONG_OF_FREEDOM, "sings a song of Freedom", "song of Freedom" },
{ EF_SONG_OF_BINDING, false, NULL, effect_handler_SONG_OF_BINDING, "sings a song of Binding", "song of Binding" },
{ EF_SONG_OF_PIERCING, false, NULL, effect_handler_SONG_OF_PIERCING, "sings a song of Piercing", "song of Piercing" },
{ EF_SONG_OF_OATHS, false, NULL, effect_handler_SONG_OF_OATHS, "sings a song of Oaths", "song of Oaths" },
{ EF_AGGRAVATE, false, NULL, effect_handler_AGGRAVATE, "makes nearby monsters aggressive", "make angry" },
{ EF_NOISE, false, NULL, effect_handler_NOISE, "makes a noise that monsters may hear", "make a noise" },
{ EF_CREATE_TRAPS, false, NULL, effect_handler_CREATE_TRAPS, "create traps on the level", "create traps" },
 { EF_MAX, false, NULL, NULL, NULL, NULL }
};
static const char *effect_names[] = {
 NULL,
/**
 * \file list-effects.h
 * \brief List of effects
 *
 * name: effect code
 * aim: does the effect require aiming?
 * info: info label for spells
 * args: how many arguments the description takes
 * info flags: flags for object description
 * description: text of description
 * menu_name: format string for menu name; use an empty string if there's no
 * plan to use it from a menu
 */
/* name 							aim		info		args	info flags		description	menu_name */
"HEAL_HP",
"DAMAGE",
"DART",
"PIT",
"PROJECT_LOS",
"PROJECT_LOS_GRIDS",
"DEADFALL",
"EARTHQUAKE",
"SPOT",
"SPHERE",
"EXPLOSION",
"BREATH",
"BOLT",
"BEAM",
"TERRAIN_BEAM",
"NOURISH",
"CURE",
"TIMED_SET",
"TIMED_INC",
"TIMED_INC_CHECK",
"TIMED_INC_NO_RES",
"TERROR",
"GLYPH",
"RESTORE_STAT",
"DRAIN_STAT",
"RESTORE_MANA",
"REMOVE_CURSE",
"MAP_AREA",
"DETECT_TRAPS",
"DETECT_DOORS",
"DETECT_OBJECTS",
"DETECT_MONSTERS",
"REVEAL_MONSTER",
"CLOSE_CHASMS",
"IDENTIFY",
"RECHARGE",
"SUMMON",
"TELEPORT_TO",
"DARKEN_LEVEL",
"LIGHT_AREA",
"DARKEN_AREA",
"SONG_OF_ELBERETH",
"SONG_OF_LORIEN",
"SONG_OF_FREEDOM",
"SONG_OF_BINDING",
"SONG_OF_PIERCING",
"SONG_OF_OATHS",
"AGGRAVATE",
"NOISE",
"CREATE_TRAPS",

};
/*
 * Utility functions
 */
/**
 * Free all the effects in a structure
 *
 * \param source the effects being freed
 */
void free_effect(struct effect *source)
{
 struct effect *e = source, *e_next;
 while (e) {
  e_next = e->next;
  dice_free(e->dice);
  if (e->msg) {
   string_free(e->msg);
  }
  mem_free(e);
  e = e_next;
 }
}
bool effect_valid(const struct effect *effect)
{
 if (!effect) return false;
 return effect->index > EF_NONE && effect->index < EF_MAX;
}
bool effect_aim(const struct effect *effect)
{
 const struct effect *e = effect;
 if (!effect_valid(effect))
  return false;
 while (e) {
  if (effects[e->index].aim) return true;
  e = e->next;
 }
 return false;
}
const char *effect_info(const struct effect *effect)
{
 if (!effect_valid(effect))
  return NULL;
 return effects[effect->index].info;
}
const char *effect_desc(const struct effect *effect)
{
 if (!effect_valid(effect))
  return NULL;
 return effects[effect->index].desc;
}
effect_index effect_lookup(const char *name)
{
 size_t i;
 for (i = 0; i < N_ELEMENTS(effect_names); i++) {
  const char *effect_name = effect_names[i];
  /* Test for equality */
  if (effect_name != NULL && streq(name, effect_name))
   return i;
 }
 return EF_MAX;
}
/**
 * Translate a string to an effect parameter subtype index
 */
int effect_subtype(int index, const char *type)
{
 char *pe;
 long lv;
 lv = strtol(type, &pe, 10);
 if (pe != type) {
  /*
		 * Got a plain numeric value.  Verify that there isn't garbage
		 * after it and that it doesn't overflow.  Also reject INT_MIN
		 * and INT_MAX so don't have to check errno to detect overflow
		 * when sizeof(long) == sizeof(int).
		 */
  return (contains_only_spaces(pe) && lv < INT_MAX
   && lv > INT_MIN) ? (int)lv : -1;
 }
 /* If not a numerical value, assign according to effect index */
 switch (index) {
  /* Projection name */
  case EF_PROJECT_LOS:
  case EF_PROJECT_LOS_GRIDS:
  case EF_LIGHT_AREA:
  case EF_EXPLOSION:
  case EF_SPOT:
  case EF_SPHERE:
  case EF_BREATH:
  case EF_BOLT:
  case EF_BEAM:
  case EF_TERRAIN_BEAM:
   return proj_name_to_idx(type);
  /* Timed effect name */
  case EF_CURE:
  case EF_TIMED_SET:
  case EF_TIMED_INC:
  case EF_TIMED_INC_CHECK:
  case EF_TIMED_INC_NO_RES:
   return timed_name_to_idx(type);
  /* Nourishment types */
  case EF_NOURISH:
   if (streq(type, "INC_BY")) {
    return 0;
   } else if (streq(type, "DEC_BY")) {
    return 1;
   }
   break;
  /* Summon name */
  case EF_SUMMON:
   return summon_name_to_idx(type);
  /* Stat name */
  case EF_RESTORE_STAT:
  case EF_DRAIN_STAT:
  case EF_DART:
   return stat_name_to_idx(type);
  /* Inscribe a glyph */
  case EF_GLYPH:
   if (streq(type, "WARDING")) {
    return GLYPH_WARDING;
   }
   break;
  /* Allow monster teleport toward */
  case EF_TELEPORT_TO:
   if (streq(type, "SELF")) {
    return 1;
   }
   break;
  /* Pit types */
  case EF_PIT:
   if (streq(type, "SPIKED")) {
    return 1;
   } else if (streq(type, "NORMAL")) {
    return 0;
   }
   break;
  /* Monster listen types */
  case EF_NOISE:
   if (streq(type, "PLAYER")) {
    return 1;
   } else if (streq(type, "MONSTER")) {
    return 0;
   }
   break;
  /* Some effects only want a radius, so this is a dummy */
  default:
   if (streq(type, "NONE")) {
    return 0;
   }
   break;
 }
 return -1;
}
static int32_t effect_value_base_zero(void)
{
 return 0;
}
static int32_t effect_value_base_spell_power(void)
{
 int power = 0;
 /* Check the reference race first */
 if (ref_race)
    power = ref_race->spell_power;
 /* Otherwise the current monster if there is one */
 else if (cave->mon_current > 0)
  power = cave_monster(cave, cave->mon_current)->race->spell_power;
 return power;
}
static int32_t effect_value_base_dungeon_level(void)
{
 return cave->depth;
}
static int32_t effect_value_base_max_sight(void)
{
 return z_info->max_sight;
}
static int32_t effect_value_base_player_hp(void)
{
 return player->chp;
}
static int32_t effect_value_base_player_max_hp(void)
{
 return player->mhp;
}
static int32_t effect_value_base_player_will(void)
{
 int will = player->state.skill_use[SKILL_WILL];
 if (player_active_ability(player, "Channeling")) {
  will += 5;
 }
 return will;
}
static int32_t effect_value_base_player_cut(void)
{
 return player->timed[TMD_CUT];
}
static int32_t effect_value_base_player_pois(void)
{
 return player->timed[TMD_POISONED];
}
expression_base_value_f effect_value_base_by_name(const char *name)
{
 static const struct value_base_s {
  const char *name;
  expression_base_value_f function;
 } value_bases[] = {
  { "ZERO", effect_value_base_zero },
  { "SPELL_POWER", effect_value_base_spell_power },
  { "DUNGEON_LEVEL", effect_value_base_dungeon_level },
  { "MAX_SIGHT", effect_value_base_max_sight },
  { "PLAYER_HP", effect_value_base_player_hp },
  { "PLAYER_MAX_HP", effect_value_base_player_max_hp },
  { "PLAYER_WILL", effect_value_base_player_will },
  { "PLAYER_CUT", effect_value_base_player_cut },
  { "PLAYER_POIS", effect_value_base_player_pois },
  { NULL, NULL },
 };
 const struct value_base_s *current = value_bases;
 while (current->name != NULL && current->function != NULL) {
  if (my_stricmp(name, current->name) == 0)
   return current->function;
  current++;
 }
 return NULL;
}
/**
 * ------------------------------------------------------------------------
 * Execution of effects
 * ------------------------------------------------------------------------ */
/**
 * Execute an effect chain.
 *
 * \param effect is the effect chain
 * \param origin is the origin of the effect (player, monster etc.)
 * \param obj    is the object making the effect happen (or NULL)
 * \param ident  will be updated if the effect is identifiable
 *               (NB: no effect ever sets *ident to false)
 * \param aware  indicates whether the player is aware of the effect already
 * \param dir    is the direction the effect will go in
 * \param cmd    If the effect is invoked as part of a command, this is the
 *               command structure - used primarily so repeating the command
 *               can use the same information without prompting the player
 *               again.  Use NULL for this if not invoked as part of a command.
 */
bool effect_do(struct effect *effect,
  struct source origin,
  struct object *obj,
  bool *ident,
  bool aware,
  int dir,
  struct command *cmd)
{
 bool completed = false;
 bool first = true;
 effect_handler_f handler;
 random_value value = { 0, 0, 0, 0 };
 do {
  int leftover = 1;
  if (!effect_valid(effect)) {
   msg("Bad effect passed to effect_do(). Please report this bug.");
   return false;
  }
  if (effect->dice != NULL)
   (void) dice_roll(effect->dice, &value);
  /* Handle the effect */
  handler = effects[effect->index].handler;
  if (handler != NULL) {
   effect_handler_context_t context = {
    effect->index,
    origin,
    obj,
    aware,
    dir,
    value,
    effect->subtype,
    effect->radius,
    effect->other,
    effect->msg,
    *ident,
    cmd
   };
   completed = handler(&context) || completed;
   /* Don't identify by NOURISH unless it's the only effect */
   if ((effect->index != EF_NOURISH) || (!effect->next && first)) {
    *ident = context.ident;
   }
   first = false;
  }
  /* Get the next effect, if there is one */
  while (leftover-- && effect)
   effect = effect->next;
 } while (effect);
 return completed;
}
/**
 * Perform a single effect with a simple dice string and parameters
 * Calling with ident a valid pointer will (depending on effect) give success
 * information; ident = NULL will ignore this
 */
void effect_simple(int index,
       struct source origin,
       const char *dice_string,
       int subtype,
       int radius,
       int other,
       bool *ident)
{
 struct effect effect;
 int dir = DIR_TARGET;
 bool dummy_ident = false;
 /* Set all the values */
 memset(&effect, 0, sizeof(effect));
 effect.index = index;
 effect.dice = dice_new();
 dice_parse_string(effect.dice, dice_string);
 effect.subtype = subtype;
 effect.radius = radius;
 effect.other = other;
 /* Direction if needed */
 if (effect_aim(&effect))
  get_aim_dir(&dir, z_info->max_range);
 /* Do the effect */
 if (!ident) {
  ident = &dummy_ident;
 }
 effect_do(&effect, origin, NULL, ident, true, dir, NULL);
 dice_free(effect.dice);
}
/**
 * \file effects-info.c
 * \brief Implement interfaces for displaying information about effects
 *
 * Copyright (c) 2020 Eric Branlund
 * Copyright (c) 2010 Andi Sidwell
 * Copyright (c) 2004 Robert Ruehlmann
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
static struct {
        int index;
        int args;
        int efinfo_flag;
        const char *desc;
 const char *menu_name;
} base_descs[] = {
        { EF_NONE, 0, EFINFO_NONE, "", "" },
/**
 * \file list-effects.h
 * \brief List of effects
 *
 * name: effect code
 * aim: does the effect require aiming?
 * info: info label for spells
 * args: how many arguments the description takes
 * info flags: flags for object description
 * description: text of description
 * menu_name: format string for menu name; use an empty string if there's no
 * plan to use it from a menu
 */
/* name 							aim		info		args	info flags		description	menu_name */
{ EF_HEAL_HP, 2, EFINFO_HEAL, "heals %s hitpoints%s", "heal self" },
{ EF_DAMAGE, 1, EFINFO_DICE, "does %s damage to the player", "%s damage" },
{ EF_DART, 1, EFINFO_DICE, "does %s damage to the player", "dart" },
{ EF_PIT, 0, EFINFO_DICE, "player falls in a pit", "pitfall" },
{ EF_PROJECT_LOS, 1, EFINFO_PROJ, "%s which are in line of sight", "%s in line of sight" },
{ EF_PROJECT_LOS_GRIDS, 1, EFINFO_PROJ, "%s which are in line of sight", "%s in line of sight" },
{ EF_DEADFALL, 0, EFINFO_DICE, "makes rocks fall on the player", "deadfall" },
{ EF_EARTHQUAKE, 1, EFINFO_QUAKE, "causes an earthquake around you of radius %d", "cause earthquake" },
{ EF_SPOT, 4, EFINFO_SPOT, "creates a ball of %s with radius %d, centred on and hitting the player, with full intensity to radius %d, dealing %s damage at the centre", "engulf with %s" },
{ EF_SPHERE, 4, EFINFO_SPOT, "creates a ball of %s with radius %d, centred on the player, with full intensity to radius %d, dealing %s damage at the centre", "project %s" },
{ EF_EXPLOSION, 1, EFINFO_PROJ, "produces a blast of %s", "blast %s" },
{ EF_BREATH, 3, EFINFO_BREATH, "breathes a cone of %s with width %d degrees, dealing %s damage at the source", "breathe a cone of %s" },
{ EF_BOLT, 2, EFINFO_BOLT, "casts a bolt of %s dealing %s damage", "cast a bolt of %s" },
{ EF_BEAM, 2, EFINFO_BOLT, "casts a beam of %s dealing %s damage", "cast a beam of %s" },
{ EF_TERRAIN_BEAM, 1, EFINFO_PROJ, "casts a beam of %s", "cast a beam of %s" },
{ EF_NOURISH, 3, EFINFO_FOOD, "%s for %s turns (%s percent)", "%s %s" },
{ EF_CURE, 1, EFINFO_CURE, "cures %s", "cure %s" },
{ EF_TIMED_SET, 2, EFINFO_TIMED, "administers %s for %s turns", "administer %s" },
{ EF_TIMED_INC, 2, EFINFO_TIMED, "extends %s for %s turns", "extend %s" },
{ EF_TIMED_INC_CHECK, 1, EFINFO_TIMED, "checks if %s can be extended", "checks %s extension" },
{ EF_TIMED_INC_NO_RES, 2, EFINFO_TIMED, "extends %s for %s turns (unresistable)", "extend %s" },
{ EF_TERROR, 1, EFINFO_TERROR, "administers fear for %s turns, and haste for about half as long", "administer fear/haste" },
{ EF_GLYPH, 1, EFINFO_NONE, "inscribes a glyph beneath you", "inscribe a glyph" },
{ EF_RESTORE_STAT, 1, EFINFO_STAT, "restores your %s", "restore %s" },
{ EF_DRAIN_STAT, 1, EFINFO_STAT, "reduces your %s", "drains %s" },
{ EF_RESTORE_MANA, 0, EFINFO_NONE, "restores some mana", "restore some mana" },
{ EF_REMOVE_CURSE, 1, EFINFO_DICE, "attempts power %s removal of a single curse on an object", "remove curse" },
{ EF_MAP_AREA, 0, EFINFO_NONE, "maps the current dungeon level", "map level" },
{ EF_DETECT_TRAPS, 0, EFINFO_NONE, "detects traps nearby", "detect traps" },
{ EF_DETECT_DOORS, 0, EFINFO_NONE, "detects doors nearby", "detect doors" },
{ EF_DETECT_OBJECTS, 0, EFINFO_NONE, "detects objects nearby", "detect objects" },
{ EF_DETECT_MONSTERS, 0, EFINFO_NONE, "detects monsters on the level", "detect monsters" },
{ EF_REVEAL_MONSTER, 0, EFINFO_NONE, "reveals a monster", "reveal monster" },
{ EF_CLOSE_CHASMS, 0, EFINFO_NONE, "close nearby chasms", "close_chasms" },
{ EF_IDENTIFY, 0, EFINFO_NONE, "identifie a selected item", "identify" },
{ EF_RECHARGE, 0, EFINFO_NONE, "tries to recharge a wand or staff, destroying the wand or staff on failure", "recharge" },
{ EF_SUMMON, 1, EFINFO_SUMM, "summons %s at the current dungeon level", "summon %s" },
{ EF_TELEPORT_TO, 0, EFINFO_NONE, "teleports toward a target", "teleport to target" },
{ EF_DARKEN_LEVEL, 0, EFINFO_NONE, "completely darkens and forgets the level", "darken level" },
{ EF_LIGHT_AREA, 0, EFINFO_NONE, "lights up the surrounding area", "light area" },
{ EF_DARKEN_AREA, 0, EFINFO_NONE, "darkens the surrounding area", "darken area" },
{ EF_SONG_OF_ELBERETH, 0, EFINFO_NONE, "sings a song of Elbereth", "song of Elbereth" },
{ EF_SONG_OF_LORIEN, 0, EFINFO_NONE, "sings a song of Lorien", "song of Lorien" },
{ EF_SONG_OF_FREEDOM, 0, EFINFO_NONE, "sings a song of Freedom", "song of Freedom" },
{ EF_SONG_OF_BINDING, 0, EFINFO_NONE, "sings a song of Binding", "song of Binding" },
{ EF_SONG_OF_PIERCING, 0, EFINFO_NONE, "sings a song of Piercing", "song of Piercing" },
{ EF_SONG_OF_OATHS, 0, EFINFO_NONE, "sings a song of Oaths", "song of Oaths" },
{ EF_AGGRAVATE, 0, EFINFO_NONE, "makes nearby monsters aggressive", "make angry" },
{ EF_NOISE, 0, EFINFO_NONE, "makes a noise that monsters may hear", "make a noise" },
{ EF_CREATE_TRAPS, 0, EFINFO_NONE, "create traps on the level", "create traps" },

};
/**
 * Get the possible dice strings.
 */
static void format_dice_string(const random_value *v, int multiplier,
 size_t len, char* dice_string)
{
 if (v->dice && v->base) {
  if (multiplier == 1) {
   strnfmt(dice_string, len, "%d+%dd%d", v->base, v->dice,
    v->sides);
  } else {
   strnfmt(dice_string, len, "%d+%d*(%dd%d)",
    multiplier * v->base, multiplier, v->dice,
    v->sides);
  }
 } else if (v->dice) {
  if (multiplier == 1) {
   strnfmt(dice_string, len, "%dd%d", v->dice, v->sides);
  } else {
   strnfmt(dice_string, len, "%d*(%dd%d)", multiplier,
    v->dice, v->sides);
  }
 } else {
  strnfmt(dice_string, len, "%d", multiplier * v->base);
 }
}
/**
 * Appends a message describing the magical device skill bonus and the average
 * damage. Average damage is only displayed if there is variance or a magical
 * device bonus.
 */
static void append_damage(char *buffer, size_t buffer_size, random_value value)
{
 if (randcalc_varies(value)) {
  // Ten times the average damage, for 1 digit of precision
  int dam = (100 * randcalc(value, 0, AVERAGE)) / 10;
  my_strcat(buffer, format(" for an average of %d.%d damage", dam / 10,
   dam % 10), buffer_size);
 }
}
static void copy_to_textblock_with_coloring(textblock *tb, const char *s)
{
 while (*s) {
  if (isdigit((unsigned char) *s)) {
   textblock_append_c(tb, COLOUR_L_GREEN, "%c", *s);
  } else {
   textblock_append(tb, "%c", *s);
  }
  ++s;
 }
}
/**
 * Creates a new textblock which has a description of the effect in *e and all
 * the subsequent effects.  If none of the effects has a description, will
 * return NULL.  If there is at least one effect with a description and prefix
 * is not NULL, the string pointed to by prefix will be added to the textblock
 * before the descriptions.
 */
textblock *effect_describe(const struct effect *e, const char *prefix)
{
 textblock *tb = NULL;
 char desc[250];
 random_value value = { 0, 0, 0, 0 };
 bool value_set = false;
 while (e) {
  const char* edesc = effect_desc(e);
  char dice_string[20];
  if ((e->dice != NULL) && !value_set) {
   (void) dice_roll(e->dice, &value);
  }
  if (!edesc) {
   e = e->next;
   continue;
  }
  format_dice_string(&value, 1, sizeof(dice_string), dice_string);
  /* Check all the possible types of description format. */
  switch (base_descs[e->index].efinfo_flag) {
  case EFINFO_DICE:
   strnfmt(desc, sizeof(desc), edesc, dice_string);
   break;
  case EFINFO_HEAL:
   /* Healing sometimes has a minimum percentage. */
   {
    char min_string[50];
    if (value.m_bonus) {
     strnfmt(min_string, sizeof(min_string),
      " (or %d%%, whichever is greater)",
      value.m_bonus);
    } else {
     strnfmt(min_string, sizeof(min_string),
      "%s", "");
    }
    strnfmt(desc, sizeof(desc), edesc, dice_string,
     min_string);
   }
   break;
  case EFINFO_FOOD:
   {
    const char *fed = e->subtype ?
     (e->subtype == 1 ? "uses enough food value" :
      "leaves you nourished") : "feeds you";
    char turn_dice_string[20];
    format_dice_string(&value, 10,
     sizeof(turn_dice_string),
     turn_dice_string);
    strnfmt(desc, sizeof(desc), edesc, fed,
     turn_dice_string, dice_string);
   }
   break;
  case EFINFO_CURE:
   strnfmt(desc, sizeof(desc), edesc, timed_effects[e->subtype].desc);
   break;
  case EFINFO_TIMED:
   strnfmt(desc, sizeof(desc), edesc, timed_effects[e->subtype].desc,
     dice_string);
   break;
  case EFINFO_TERROR:
   strnfmt(desc, sizeof(desc), edesc, dice_string);
   break;
  case EFINFO_STAT:
   {
    int stat = e->subtype;
    strnfmt(desc, sizeof(desc), edesc,
     lookup_obj_property(OBJ_PROPERTY_STAT, stat)->name);
   }
   break;
  case EFINFO_PROJ:
   strnfmt(desc, sizeof(desc), edesc, projections[e->subtype].desc);
   break;
  case EFINFO_SUMM:
   strnfmt(desc, sizeof(desc), edesc, summon_desc(e->subtype));
   break;
  case EFINFO_QUAKE:
   strnfmt(desc, sizeof(desc), edesc, e->radius);
   break;
  case EFINFO_SPOT:
   {
    int i_radius = e->other ? e->other : e->radius;
    strnfmt(desc, sizeof(desc), edesc,
     projections[e->subtype].player_desc,
     e->radius, i_radius, dice_string);
    append_damage(desc, sizeof(desc), value);
   }
   break;
  case EFINFO_BREATH:
   strnfmt(desc, sizeof(desc), edesc,
    projections[e->subtype].player_desc, e->other,
    dice_string);
   append_damage(desc, sizeof(desc), value);
   break;
  case EFINFO_BOLT:
   /* Bolts and beams that damage */
   strnfmt(desc, sizeof(desc), edesc,
    projections[e->subtype].desc, dice_string);
   append_damage(desc, sizeof(desc), value);
   break;
  case EFINFO_NONE:
   strnfmt(desc, sizeof(desc), "%s", edesc);
   break;
  default:
   strnfmt(desc, sizeof(desc), "%s", "");
   msg("Bad effect description passed to effect_info().  Please report this bug.");
   break;
  }
  e = e->next;
  if (desc[0] != '\0') {
   if (tb) {
    if (e) {
     textblock_append(tb, ", ");
    } else {
     textblock_append(tb, " and ");
    }
   } else {
    tb = textblock_new();
    if (prefix) {
     textblock_append(tb, "%s", prefix);
    }
   }
   copy_to_textblock_with_coloring(tb, desc);
  }
 }
 return tb;
}
/**
 * Fills a buffer with a short description, suitable for use a menu entry, of
 * an effect.
 * \param buf is the buffer to fill.
 * \param max is the maximum number of characters the buffer can hold.
 * \param e is the effect to describe.
 * \return the number of characters written to the buffer; will be zero if
 * the effect is invalid
 */
size_t effect_get_menu_name(char *buf, size_t max, const struct effect *e)
{
 const char *fmt;
 size_t len;
 if (!e || e->index <= EF_NONE || e->index >= EF_MAX) {
  return 0;
 }
 fmt = base_descs[e->index].menu_name;
 switch (base_descs[e->index].efinfo_flag) {
 case EFINFO_DICE:
 case EFINFO_HEAL:
 case EFINFO_QUAKE:
 case EFINFO_TERROR:
 case EFINFO_NONE:
  len = strnfmt(buf, max, "%s", fmt);
  break;
 case EFINFO_FOOD:
  {
   const char *actstr;
   const char *actarg;
   int avg;
   switch (e->subtype) {
   case 0: /* INC_BY */
    actstr = "feed";
    actarg = "yourself";
    break;
   case 1: /* DEC_BY */
    actstr = "increase";
    actarg = "hunger";
    break;
   case 2: /* SET_TO */
    avg = (e->dice) ?
     dice_evaluate(e->dice, 1, AVERAGE, NULL) : 0;
    actstr = "become";
    if (avg > PY_FOOD_FULL) {
     actarg = "bloated";
    } else {
     actarg = "hungry";
    }
    break;
   case 3: /* INC_TO */
    avg = (e->dice) ?
     dice_evaluate(e->dice, 1, AVERAGE, NULL): 0;
    actstr = "leave";
    if (avg > PY_FOOD_FULL) {
     actarg = "bloated";
    } else {
     actarg = "hungry";
    }
    break;
   default:
    actstr = NULL;
    actarg = NULL;
    break;
   }
   if (actstr && actarg) {
    len = strnfmt(buf, max, fmt, actstr, actarg);
   } else {
    len = strnfmt(buf, max, "%s", "");
   }
  }
  break;
 case EFINFO_CURE:
 case EFINFO_TIMED:
  len = strnfmt(buf, max, fmt, timed_effects[e->subtype].desc);
  break;
 case EFINFO_STAT:
  len = strnfmt(buf, max, fmt,
   lookup_obj_property(OBJ_PROPERTY_STAT, e->subtype)->name);
  break;
 case EFINFO_PROJ:
 case EFINFO_BOLT:
  len = strnfmt(buf, max, fmt, projections[e->subtype].desc);
  break;
 case EFINFO_SUMM:
  len = strnfmt(buf, max, fmt, summon_desc(e->subtype));
  break;
 case EFINFO_SPOT:
 case EFINFO_BREATH:
  len = strnfmt(buf, max, fmt, projections[e->subtype].player_desc);
  break;
 default:
  len = strnfmt(buf, max, "%s", "");
  msg("Bad effect description passed to effect_get_menu_name().  Please report this bug.");
  break;
 }
 return len;
}
/**
 * Returns a pointer to the next effect in the effect stack
 */
struct effect *effect_next(struct effect *effect)
{
 return effect->next;
}
/**
 * Checks if the effect deals damage, by checking the effect's info string.
 * Random or select effects are considered to deal damage if any sub-effect
 * deals damage.
 */
bool effect_damages(const struct effect *effect)
{
 return effect_info(effect) != NULL && streq(effect_info(effect), "dam");
}
/**
 * Calculates the average damage of the effect. Random effects and select
 * effects return an average of all sub-effect averages.
 *
 * \param effect is the effect to evaluate.
 */
int effect_avg_damage(const struct effect *effect)
{
 return dice_evaluate(effect->dice, 0, AVERAGE, NULL);
}
/**
 * Returns the projection of the effect, or an empty string if it has none.
 * Random or select effects only return a projection if all sub-effects have
 * the same projection.
 */
const char *effect_projection(const struct effect *effect)
{
 if (projections[effect->subtype].player_desc != NULL) {
  switch (base_descs[effect->index].efinfo_flag) {
   case EFINFO_PROJ:
   case EFINFO_BOLT:
   case EFINFO_BREATH:
   case EFINFO_SPOT:
    return projections[effect->subtype].player_desc;
  }
 }
 return "";
}
/**
 * \file game-event.c
 * \brief Allows the registering of handlers to be told about game events.
 *
 * Copyright (c) 2007 Antony Sidwell
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
struct event_handler_entry
{
 struct event_handler_entry *next;
 game_event_handler *fn;
 void *user;
};
static struct event_handler_entry *event_handlers[N_GAME_EVENTS];
static void game_event_dispatch(game_event_type type, game_event_data *data)
{
 struct event_handler_entry *this = event_handlers[type];
 /* 
	 * Send the word out to all interested event handlers.
	 */
 while (this)
 {
  /* Call the handler with the relevant data */
  this->fn(type, data, this->user);
  this = this->next;
 }
}
void event_add_handler(game_event_type type, game_event_handler *fn, void *user)
{
 struct event_handler_entry *new;
 assert(fn != NULL);
 /* Make a new entry */
 new = mem_alloc(sizeof *new);
 new->fn = fn;
 new->user = user;
 /* Add it to the head of the appropriate list */
 new->next = event_handlers[type];
 event_handlers[type] = new;
}
void event_remove_handler(game_event_type type, game_event_handler *fn, void *user)
{
 struct event_handler_entry *prev = NULL;
 struct event_handler_entry *this = event_handlers[type];
 /* Look for the entry in the list */
 while (this)
 {
  /* Check if this is the entry we want to remove */
  if (this->fn == fn && this->user == user)
  {
   if (!prev)
   {
    event_handlers[type] = this->next;
   }
   else
   {
    prev->next = this->next;
   }
   mem_free(this);
   return;
  }
  prev = this;
  this = this->next;
 }
}
void event_remove_handler_type(game_event_type type)
{
 struct event_handler_entry *handler = event_handlers[type];
 while (handler) {
  struct event_handler_entry *next = handler->next;
  mem_free(handler);
  handler = next;
 }
 event_handlers[type] = NULL;
}
void event_remove_all_handlers(void)
{
 int type;
 struct event_handler_entry *handler, *next;
 for (type = 0; type < N_GAME_EVENTS; type++) {
  handler = event_handlers[type];
  while (handler) {
   next = handler->next;
   mem_free(handler);
   handler = next;
  }
  event_handlers[type] = NULL;
 }
}
void event_add_handler_set(game_event_type *type, size_t n_types, game_event_handler *fn, void *user)
{
 size_t i;
 for (i = 0; i < n_types; i++)
  event_add_handler(type[i], fn, user);
}
void event_remove_handler_set(game_event_type *type, size_t n_types, game_event_handler *fn, void *user)
{
 size_t i;
 for (i = 0; i < n_types; i++)
  event_remove_handler(type[i], fn, user);
}
void event_signal(game_event_type type)
{
 game_event_dispatch(type, NULL);
}
void event_signal_flag(game_event_type type, bool flag)
{
 game_event_data data;
 data.flag = flag;
 game_event_dispatch(type, &data);
}
void event_signal_point(game_event_type type, int x, int y)
{
 game_event_data data;
 data.point.x = x;
 data.point.y = y;
 game_event_dispatch(type, &data);
}
void event_signal_string(game_event_type type, const char *s)
{
 game_event_data data;
 data.string = s;
 game_event_dispatch(type, &data);
}
void event_signal_message(game_event_type type, int t, const char *s)
{
 game_event_data data;
 memset(&data, 0, sizeof data);
 data.message.type = t;
 data.message.msg = s;
 game_event_dispatch(type, &data);
}
/**
 * Signal a change or refresh in the point buy for birth stats.
 *
 * \param points points[i] is the number of points already spent to increase
 * the ith stat, i >= 0 and i < STAT_MAX.
 * \param inc_points inc_points[i] is the number of additional points it would
 * take to incrase the ith stat by one, i >= 0 and i < STAT_MAX.
 * \param remaining is the number of points that remain to be spent.
 */
void event_signal_birthpoints(const int *points, const int *inc_points,
  int remaining)
{
 game_event_data data;
 data.points.points = points;
 data.points.inc_points = inc_points;
 data.points.remaining = remaining;
 game_event_dispatch(EVENT_STATPOINTS, &data);
}
/**
 * Signal a change or refresh in the point buy for skills.
 *
 * \param exp exp[i] is the amount of experience already spent to increase
 * the ith stat, i >= 0 and i < SKILL_MAX.
 * \param inc_exp inc_exp[i] is the amount of additional experience it would
 * take to incrase the ith skill by one, i >= 0 and i < SKILL_MAX.
 * \param remaining is the amount of experience that remain to be spent.
 */
void event_signal_skillpoints(const int *exp, const int *inc_exp,
  int remaining)
{
 game_event_data data;
 data.exp.exp = exp;
 data.exp.inc_exp = inc_exp;
 data.exp.remaining = remaining;
 game_event_dispatch(EVENT_SKILLPOINTS, &data);
}
void event_signal_blast(game_event_type type,
      int proj_type,
      int num_grids,
      int *distance_to_grid,
      bool drawing,
      bool *player_sees_grid,
      struct loc *blast_grid,
      struct loc centre)
{
 game_event_data data;
 data.explosion.proj_type = proj_type;
 data.explosion.num_grids = num_grids;
 data.explosion.distance_to_grid = distance_to_grid;
 data.explosion.drawing = drawing;
 data.explosion.player_sees_grid = player_sees_grid;
 data.explosion.blast_grid = blast_grid;
 data.explosion.centre = centre;
 game_event_dispatch(type, &data);
}
void event_signal_bolt(game_event_type type,
        int proj_type,
        bool drawing,
        bool seen,
        bool beam,
        int oy,
        int ox,
        int y,
        int x)
{
 game_event_data data;
 data.bolt.proj_type = proj_type;
 data.bolt.drawing = drawing;
 data.bolt.seen = seen;
 data.bolt.beam = beam;
 data.bolt.oy = oy;
 data.bolt.ox = ox;
 data.bolt.y = y;
 data.bolt.x = x;
 game_event_dispatch(type, &data);
}
void event_signal_missile(game_event_type type,
        struct object *obj,
        bool seen,
        int y,
        int x)
{
 game_event_data data;
 data.missile.obj = obj;
 data.missile.seen = seen;
 data.missile.y = y;
 data.missile.x = x;
 game_event_dispatch(type, &data);
}
void event_signal_hit(game_event_type type,
       int dam,
       int dam_type,
       bool fatal,
       struct loc grid)
{
 game_event_data data;
 data.hit.dam = dam;
 data.hit.dam_type = dam_type;
 data.hit.fatal = fatal;
 data.hit.grid = grid;
 game_event_dispatch(type, &data);
}
void event_signal_size(game_event_type type, int h, int w)
{
 game_event_data data;
 data.size.h = h;
 data.size.w = w;
 game_event_dispatch(type, &data);
}
void event_signal_tunnel(game_event_type type, tunnel_type t,
  tunnel_direction_type dir, int vlength, int hlength)
{
 game_event_data data;
 data.tunnel.t = t;
 data.tunnel.dir = dir;
 data.tunnel.vlength = vlength;
 data.tunnel.hlength = hlength;
 game_event_dispatch(type, &data);
}
void event_signal_combat_attack(game_event_type type, struct source attacker,
        struct source defender, bool vis, int att,
        int att_roll, int evn, int evn_roll, bool melee)
{
 game_event_data data;
 data.combat_attack.attacker = attacker;
 data.combat_attack.defender = defender;
 data.combat_attack.vis = vis;
 data.combat_attack.att = att;
 data.combat_attack.att_roll = att_roll;
 data.combat_attack.evn = evn;
 data.combat_attack.evn_roll = evn_roll;
 data.combat_attack.melee = melee;
 game_event_dispatch(type, &data);
}
void event_signal_combat_damage(game_event_type type, int dd, int ds, int dam,
        int pd, int ps, int prot, int prt_percent,
        int dam_type, bool melee)
{
 game_event_data data;
 data.combat_damage.dd = dd;
 data.combat_damage.ds = ds;
 data.combat_damage.dam = dam;
 data.combat_damage.pd = pd;
 data.combat_damage.ps = ps;
 data.combat_damage.prot = prot;
 data.combat_damage.prt_percent = prt_percent;
 data.combat_damage.dam_type = dam_type;
 data.combat_damage.melee = melee;
 game_event_dispatch(type, &data);
}
void event_signal_poem(game_event_type type, const char *name, int row, int col)
{
 game_event_data data;
 data.verse.filename = name;
 data.verse.text = NULL;
 data.verse.row = row;
 data.verse.col = col;
 game_event_dispatch(type, &data);
}
void event_signal_poem_textblock(game_event_type type, struct textblock *tb,
  int row, int col)
{
 game_event_data data;
 data.verse.filename = NULL;
 data.verse.text = tb;
 data.verse.row = row;
 data.verse.col = col;
 game_event_dispatch(type, &data);
}
/**
 * \file game-input.c
 * \brief Ask for non-command input from the UI.
 *
 * Copyright (c) 2014 Nick McConnell
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
bool (*get_string_hook)(const char *prompt, char *buf, size_t len);
int (*get_quantity_hook)(const char *prompt, int max);
bool (*get_check_hook)(const char *prompt);
bool (*get_com_hook)(const char *prompt, char *command);
bool (*get_rep_dir_hook)(int *dir, bool allow_none);
bool (*get_aim_dir_hook)(int *dir, int range);
bool (*get_item_hook)(struct object **choice, const char *pmt, const char *str,
       cmd_code cmd, item_tester tester, int mode);
int (*get_effect_from_list_hook)(const char* prompt,
 struct effect *effect, int count, bool allow_random);
bool (*confirm_debug_hook)(void);
void (*get_panel_hook)(int *min_y, int *min_x, int *max_y, int *max_x);
bool (*panel_contains_hook)(unsigned int y, unsigned int x);
bool (*map_is_visible_hook)(void);
struct object *(*smith_object_hook)(struct smithing_cost *cost);
void (*view_abilities_hook)(struct player_ability *ability_list,
       int num_abilities);
void (*change_song_hook)(void);
/**
 * Prompt for a string from the user.
 *
 * \param prompt is the prompt to the user, and should take the form "Prompt: "
 * \param buf is the user string, and the value passed in is the default
 * \param len is the length of buf
 * \return whether the user accepted the entered value or escaped
 */
bool get_string(const char *prompt, char *buf, size_t len)
{
 /* Ask the UI for it */
 if (get_string_hook)
  return get_string_hook(prompt, buf, len);
 else
  return false;
}
/**
 * Request a quantity from the user
 *
 * \param prompt is the prompt to the user, and should take the form "Prompt: "
 * \param max is the maximum value to accept
 * \return the quantity
 */
int get_quantity(const char *prompt, int max)
{
 /* Ask the UI for it */
 if (get_quantity_hook)
  return get_quantity_hook(prompt, max);
 else
  return 0;
}
/**
 * Verify something with the user
 *
 * \param prompt is the prompt to the user, and should take the form "Query? "
 * \return whether the user answered "y"
 *
 * get_check_hook() should be set to a function which asks the user for a
 * "y/n" answer
 */
bool get_check(const char *prompt)
{
 /* Ask the UI for it */
 if (get_check_hook)
  return get_check_hook(prompt);
 else
  return false;
}
/**
 * Prompts for a keypress
 *
 * \param prompt is the prompt to the user, and should take the form "Command: "
 * \param command stores the keypress
 * \return whether the user accepted the entered value or escaped
 */
bool get_com(const char *prompt, char *command)
{
 /* Ask the UI for it */
 if (get_com_hook)
  return get_com_hook(prompt, command);
 else
  return false;
}
/**
 * Request a "movement" direction from the user.
 *
 * \param dir is a pointer to an integer representing the chosen direction
 * \param allow_none can be set to true to allow the null direction
 * \return true if a direction was chosen, otherwise return false.
 */
bool get_rep_dir(int *dir, bool allow_none)
{
 /* Ask the UI for it */
 if (get_rep_dir_hook)
  return get_rep_dir_hook(dir, allow_none);
 else
  return false;
}
/**
 * Get an "aiming" direction from the user.
 *
 * \param dir is a pointer to an integer representing the chosen direction
 * \return true if a direction was chosen, otherwise return false.
 */
bool get_aim_dir(int *dir, int range)
{
 /* Ask the UI for it */
 if (get_aim_dir_hook)
  return get_aim_dir_hook(dir, range);
 else
  return false;
}
/**
 * Let the user select an object, save its address
 *
 * \param choice is the chosen object
 * \param pmt is the prompt to the player
 * \param str is the message if no valid item is available
 * \param cmd is the command (if any) the request is called from
 * \param tester is the function (if any) used to test for valid objects
 * \param mode gives more information on where the object can be chosen from
 *
 * If a legal item is selected , we save it in "obj" and return true.
 * If no item is available, we do nothing to "obj", and we display a
 *   warning message, using "str" if available, and return false.
 * If no item is selected, we do nothing to "obj", and return false.
 */
bool get_item(struct object **choice, const char *pmt, const char *str,
     cmd_code cmd, item_tester tester, int mode)
{
 /* Ask the UI for it */
 if (get_item_hook)
  return get_item_hook(choice, pmt, str, cmd, tester, mode);
 else
  return false;
}
/**
 * Select an effect from a list.
 * \param prompt is the prompt to present to the user.  May be NULL to use
 * a default prompt.
 * \param effect is the pointer to the first effect in the linked list.
 * \param count is the number of effects in the list.  If count is -1, use
 * all of the effects in the list.
 * \param allow_random if true, present an additional option which will
 * select a random effect from the list.  If false, only present the options
 * corresponding to the effects in the list.
 * \return the index of the selected item in the list, -2 if the user selected
 * the random option enabled by allow_random, or -1 to indicate a canceled or
 * invalid selection
 */
int get_effect_from_list(const char *prompt, struct effect *effect, int count,
 bool allow_random)
{
 /* Ask the UI for it */
 if (get_effect_from_list_hook) {
  return get_effect_from_list_hook(prompt, effect, count,
   allow_random);
 }
 /*
	 * If there's no UI implementation but a random selection is allowed,
	 * use that.
	 */
 return (allow_random) ? -2 : -1;
}
/**
 * Confirm whether to enable the debugging commands.
 */
bool confirm_debug(void)
{
 /* Use a UI-specific method. */
 if (confirm_debug_hook) {
  return confirm_debug_hook();
 }
 /* Otherwise, use a generic procedure.  First, mention effects. */
 msg("You are about to use the dangerous, unsupported, debug commands!");
 msg("Your machine may crash, and your savefile may become corrupted!");
 event_signal(EVENT_MESSAGE_FLUSH);
 /* Then verify. */
 return get_check("Are you sure you want to use the debug commands? ");
}
/**
 * Get the borders of the area the player can see (the "panel")
 */
void get_panel(int *min_y, int *min_x, int *max_y, int *max_x)
{
 /* Ask the UI for it */
 if (get_panel_hook)
  get_panel_hook(min_y, min_x, max_y, max_x);
}
/**
 * Check to see if a map grid is in the panel
 */
bool panel_contains(unsigned int y, unsigned int x)
{
 /* Ask the UI for it */
 if (panel_contains_hook)
  return panel_contains_hook(y, x);
 else
  return true;
}
/**
 * Check to see if the map is currently shown
 */
bool map_is_visible(void)
{
 /* Ask the UI for it */
 if (map_is_visible_hook)
  return map_is_visible_hook();
 else
  return true;
}
/**
 * Smith an object
 */
struct object *smith_object(struct smithing_cost *cost)
{
 /* Ask the UI for it */
 if (smith_object_hook)
  return smith_object_hook(cost);
 return NULL;
}
/**
 * Browse player abilities
 */
void view_ability_menu(struct player_ability *ability_list,
        int num_abilities)
{
 /* Ask the UI for it */
 if (view_abilities_hook)
  view_abilities_hook(ability_list, num_abilities);
}
/**
 * Change songs
 */
void change_song(void)
{
 /* Ask the UI for it */
 if (change_song_hook)
  change_song_hook();
}
/**
 * \file game-world.c
 * \brief Game core management of the game world
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
uint16_t daycount = 0;
uint32_t seed_randart; /* Hack -- consistent random artifacts */
uint32_t seed_flavor; /* Hack -- consistent object colors */
int32_t turn; /* Current game turn */
bool character_generated; /* The character exists */
bool character_dungeon; /* The character has a dungeon */
struct level *world;
/**
 * This table allows quick conversion from "speed" to "energy"
 * It used to be complex, but in Sil it is basically linear.
 * It is set up so that there are 10 game turns per player turn at normal speed
 *
 * Note that creatures should never have speed 0 in the first place
 */
const uint8_t extract_energy[8] =
{
 /* Impossible */ 5,
 /* Slow */ 5,
 /* Normal */ 10,
 /* Fast */ 15,
 /* V Fast */ 20,
 /* X Fast */ 25,
 /* I Fast */ 30,
 /* A Fast */ 35,
};
/**
 * Find a level by its name
 */
struct level *level_by_name(const char *name)
{
 struct level *lev = world;
 while (lev) {
  if (streq(lev->name, name)) {
   break;
  }
  lev = lev->next;
 }
 return lev;
}
/**
 * Find a level by its depth
 */
struct level *level_by_depth(int depth)
{
 struct level *lev = world;
 while (lev) {
  if (lev->depth == depth) {
   break;
  }
  lev = lev->next;
 }
 return lev;
}
/**
 * Say whether it's daytime or not
 */
bool is_daytime(void)
{
 if ((turn % (10L * z_info->day_length)) < ((10L * z_info->day_length) / 2))
  return true;
 return false;
}
/**
 * The amount of energy gained in a turn by a player or monster
 */
int turn_energy(int speed)
{
 return extract_energy[speed] * z_info->move_energy / 100;
}
/**
 * Determines how many points of health/song is regenerated next round
 * assuming it increases by 'max' points every 'period'.
 * Note that players use 'player->turn' and monsters use 'turn'.
 * This lets hasted players regenerate at the right speed.
 */
int regen_amount(int turn_number, int max, int period)
{
 int regen_so_far, regen_next;
 if (turn_number == 0) {
  /* Do nothing on the first turn of the game */
  return 0;
 }
 if ((turn_number % period) > 0) {
  regen_so_far = (max * ((turn_number - 1) % period)) / period;
  regen_next = (max * (turn_number % period)) / period;
 } else {
  regen_so_far = (max * ((turn_number - 1) % period)) / period;
  regen_next = (max * period) / period;
 }
 return regen_next - regen_so_far;
}
/**
 * Represents the different levels of health.
 * Note that it is a bit odd with fewer health levels in the SOMEWHAT_WOUNDED
 * category. This is due to a rounding off tension between the natural way to
 * do the colours (perfect having its own) and the natural way to do the stars
 * for the health bar (zero having its own).
 * It should be unnoticeable to the player.
 */
int health_level(int current, int max)
{
 int level;
 if (current == max) {
  level = HEALTH_UNHURT;
 } else {
  switch ((4 * current + max - 1 ) / max) {
   case 4: level = HEALTH_SOMEWHAT_WOUNDED; break; /* 76% - 99% */
   case 3: level = HEALTH_WOUNDED ; break; /* 51% - 75% */
   case 2: level = HEALTH_BADLY_WOUNDED ; break; /* 26% - 50% */
   case 1: level = HEALTH_ALMOST_DEAD ; break; /* 1% - 25% */
   default:level = HEALTH_DEAD ; break; /* 0% */
  }
 }
 return (level);
}
/**
 * Play an ambient sound dependent on dungeon level, and day or night in town
 */
void play_ambient_sound(void)
{
 if (player->depth == 0) {
  if (is_daytime())
   sound(MSG_AMBIENT_DAY);
  else
   sound(MSG_AMBIENT_NITE);
 } else if (player->depth <= 20) {
  sound(MSG_AMBIENT_DNG1);
 } else if (player->depth <= 40) {
  sound(MSG_AMBIENT_DNG2);
 } else if (player->depth <= 60) {
  sound(MSG_AMBIENT_DNG3);
 } else if (player->depth <= 80) {
  sound(MSG_AMBIENT_DNG4);
 } else {
  sound(MSG_AMBIENT_DNG5);
 }
}
/**
 * Helper for process_world -- decrement player->timed[] and curse effect fields
 */
static void decrease_timeouts(void)
{
 int i;
 /* Most timed effects decrement by 1 */
 for (i = 0; i < TMD_MAX; i++) {
  int decr = player_timed_decrement_amount(player, i);
  /* Food is handled separately */
  if (!player->timed[i] || (i == TMD_FOOD))
   continue;
  /* Decrement the effect */
  player_dec_timed(player, i, decr, false, true);
 }
}
/**
 * Get the additional cost to monster or noise flow due to terrain
 */
static int square_flow_cost(struct chunk *c, struct loc grid,
       struct monster *mon)
{
 int cost = 0;
 /* Deal with monster pathfinding */
 if (mon) {
  bool bash = false;
  /* Get the percentage chance of the monster being able
		 * to move onto that square */
  int chance = monster_entry_chance(c, mon, grid, &bash);
  /* If there is any chance, then convert it to a number of turns */
  if (chance > 0) {
   cost += (100 / chance) - 1;
   /* Add an extra turn for unlocking/opening doors as
			 * this action doesn't move the monster */
   if (square_iscloseddoor(c, grid)) {
    if (!(bash ||
      rf_has(mon->race->flags, RF_PASS_DOOR) ||
      rf_has(mon->race->flags, RF_PASS_WALL))) {
     cost += 1;
    }
   } else if (square_isdiggable(c, grid) &&
     rf_has(mon->race->flags, RF_TUNNEL_WALL)) {
    /* Add extra turn(s) for tunneling through rubble/walls as
				 * this action doesn't move the monster */
    if (square_isrubble(c, grid)) {
     /* An extra turn to dig through */
     cost += 1;
    } else {
     /* Two extra turns to dig through granite/quartz */
     cost += 2;
    }
   } else if (square_iswall(c, grid) &&
        rf_has(mon->race->flags, RF_KILL_WALL)) {
    /* Pretend it would take an extra turn (to prefer routes
				 * with less wall destruction */
    cost += 1;
   }
  } else {
   /* If there is no chance, just skip this square */
   return -1;
  }
 } else {
  /* Deal with noise flows */
  /* Ignore walls */
  if (square_iswall(c, grid) && !square_isdoor(c, grid)) {
   return -1;
  }
  /* Penalize doors by 5 when calculating the real noise*/
  if (square_iscloseddoor(c, grid) || square_issecretdoor(c, grid)){
   cost += 5;
  }
 }
 return cost;
}
/**
 * Used to convert grid into an array index (i) in a chunk of width w.
 * \param grid location
 * \param w area width
 * \return index
 */
static int grid_to_i(struct loc grid, int w)
{
 return grid.y * w + grid.x;
}
/**
 * Used to convert an array index (i) into grid in a chunk of width w.
 * \param i grid index
 * \param w area width
 * \param grid location
 */
static void i_to_grid(int i, int w, struct loc *grid)
{
 grid->y = i / w;
 grid->x = i % w;
}
/**
 * Sil needs various 'flows', which are arrays of the same size as the map,
 * with a number for each map square.
 *
 * One of these flows is used to represent the from the player noise at each
 * location.
 * Another is used to represent the noise from a particular monster.
 *
 * Each monster has a flow which it uses for alert pathfinding, representing the
 * shortest route each monster could take to get to the player.
 *
 * Flows are also used for the pathfinding of unwary monsters who move in their
 * initial groups to various locations around the map.
 *
 * Note that the noise is generated around the centre.
 * This is often the player, but can be a monster (for FLOW_MONSTER_NOISE)
 */
void update_flow(struct chunk *c, struct flow *flow, struct monster *mon)
{
 struct loc next = flow->centre;
 int y, x, d;
 int value = 0;
 struct queue *queue = q_new(c->height * c->width);
 /* Set all the grids to maximum */
 for (y = 1; y < c->height - 1; y++) {
  for (x = 1; x < c->width - 1; x++) {
   flow->grids[y][x] = z_info->flow_max;
  }
 }
 if (loc_eq(next, loc(0, 0))) {
  quit("Flow has no centre!");
 }
 /* Set the centre value to zero, push it onto the queue */
 flow->grids[next.y][next.x] = 0;
 q_push_int(queue, grid_to_i(next, c->width));
 value++;
 /* Propagate outwards */
 while ((q_len(queue) > 0) && (value < z_info->flow_max)) {
  /* Process only the grids currently on the queue */
  int count = q_len(queue);
  while (count) {
   /* Get the next grid, count it */
   i_to_grid(q_pop_int(queue), c->width, &next);
   count--;
   /* If it costs more the current value, put it back on the queue */
   if (flow->grids[next.y][next.x] > value) {
    q_push_int(queue, grid_to_i(next, c->width));
    continue;
   }
   /* Iterate over the current grid's children */
   for (d = 0; d < 8; d++) {
    /* Child location */
    struct loc grid = loc_sum(next, ddgrid_ddd[d]);
    struct monster *grid_mon;
    int cost;
    /* Legal grids only */
    if (!square_in_bounds(c, grid)) continue;
    /* Skip grids that have already been processed */
    if (flow->grids[grid.y][grid.x] < z_info->flow_max) continue;
    /* Extra cost of the grid */
    cost = square_flow_cost(c, grid, mon);
    /* Ignore features that block flow */
    if (cost < 0) continue;
    /* Save the flow value */
    flow->grids[grid.y][grid.x] = value + cost;
    /* Enqueue that child */
    q_push_int(queue, grid_to_i(grid, c->width));
    /* Monster on this grid */
    grid_mon = square_monster(c, grid);
    /* Monsters at this site need to re-consider their targets */
    if (grid_mon) {
     grid_mon->target.grid = loc(0, 0);
    }
   }
  }
  value++;
 }
 q_free(queue);
}
/**
 * Determines how far a grid is from the source using the given flow.
 */
int flow_dist(struct flow flow, struct loc grid)
{
 return flow.grids[grid.y][grid.x];
}
/**
 * Characters leave scent trails for perceptive monsters to track.
 *
 * Scent is rather more limited than sound.  Many creatures cannot use
 * it at all, it doesn't extend very far outwards from the character's
 * current position, and monsters can use it to home in the character,
 * but not to run away.
 *
 * Scent is valued according to age.  When a character takes his turn,
 * scent is aged by one, and new scent of the current age is laid down.
 * Speedy characters leave more scent, true, but it also ages faster,
 * which makes it harder to hunt them down.
 *
 * Whenever the age count loops, most of the scent trail is erased and
 * the age of the remainder is recalculated.
 */
static void update_scent(void)
{
 int y, x;
 int scent_strength[5][5] = {
  {250, 2, 2, 2, 250},
  { 2, 1, 1, 1, 2},
  { 2, 1, 0, 1, 2},
  { 2, 1, 1, 1, 2},
  {250, 2, 2, 2, 250},
 };
 /* Scent becomes "younger" */
 cave->scent_age--;
 /* Loop the age and adjust scent values when necessary */
 if (cave->scent_age <= 0) {
  /* Update scent for all grids */
  for (y = 1; y < cave->height - 1; y++) {
   for (x = 1; x < cave->width - 1; x++) {
    /* Ignore non-existent scent */
    if (cave->scent.grids[y][x] == 0) continue;
    /* Erase the earlier part of the previous cycle */
    if (cave->scent.grids[y][x] > SMELL_STRENGTH) {
     cave->scent.grids[y][x] = 0;
    } else {
     /* Reset the ages of the most recent scent */
     cave->scent.grids[y][x] += 250 - SMELL_STRENGTH;
    }
   }
  }
  /* Reset the age value */
  cave->scent_age = 250 - SMELL_STRENGTH;
 }
 /* Lay down new scent around the player */
 for (y = 0; y < 5; y++) {
  for (x = 0; x < 5; x++) {
   struct loc scent;
   int new_scent = scent_strength[y][x];
   /* Initialize */
   scent.y = y + player->grid.y - 2;
   scent.x = x + player->grid.x - 2;
   /* Ignore invalid or non-scent-carrying grids */
   if (!square_in_bounds(cave, scent)) continue;
   if (square_isnoscent(cave, scent)) continue;
   /* Grid must not be blocked by walls from the character */
   if (!los(cave, player->grid, loc(x, y))) continue;
   /* Note grids that are too far away */
   if (scent_strength[y][x] == 250) continue;
   /* Mark the scent */
   cave->scent.grids[scent.y][scent.x] = cave->scent_age + new_scent;
  }
 }
}
/**
 * Get and return the strength (age) of scent in a given grid.
 *
 * Return "-1" if no scent exists in the grid.
 */
int get_scent(struct chunk *c, struct loc grid)
{
 int age;
 int scent;
 /* Check Bounds */
 if (!square_in_bounds(c, grid)) return -1;
 /* Sent trace? */
 scent = c->scent.grids[grid.y][grid.x];
 /* No scent at all */
 if (!c->scent.grids[grid.y][grid.x]) return -1;
 /* Get age of scent */
 age = scent - c->scent_age;
 if (age > SMELL_STRENGTH) return -1;
 /* Return the age of the scent */
 return age;
}
/**
 * Handle things that need updating once every 10 game turns
 */
void process_world(struct chunk *c)
{
 /* Compact the monster list if we're approaching the limit */
 if (cave_monster_count(c) + 32 > z_info->level_monster_max)
  compact_monsters(c, 64);
 /* Too many holes in the monster list - compress */
 if (cave_monster_count(c) + 32 < cave_monster_max(c))
  compact_monsters(c, 0);
 /*** Check the Time ***/
 /* Play an ambient sound at regular intervals. */
 if (!(turn % ((10L * z_info->day_length) / 4)))
  play_ambient_sound();
 /* Handle  the "surface" */
 if (!player->depth) {
  if (percent_chance(10)) {
   /* Make a new monster */
   (void)pick_and_place_monster_on_stairs(c, player, true, 0, false);
  }
 }
 /* Check for creature generation */
 if (silmarils_possessed(player) >= 2) {
  /* Vastly more wandering monsters during the endgame when you have
		 * 2 or 3 Silmarils */
  int percent = (c->height * c->width)
   / (z_info->block_hgt * z_info->block_wid);
  if (percent_chance(percent)) {
   (void)pick_and_place_monster_on_stairs(c, player, true, c->depth,
               false);
  }
 } else if (one_in_(z_info->alloc_monster_chance)) {
  /* Normal wandering monster generation */
  (void)pick_and_place_monster_on_stairs(c, player, true, c->depth,
              false);
 }
 /* Players with the haunted curse attract wraiths */
 if (percent_chance(player->state.flags[OF_HAUNTED])) {
  /* Make a new wraith */
  (void)pick_and_place_monster_on_stairs(c, player, true, c->depth, true);
 }
 /* Process light */
 player_update_light(player);
}
/**
 * Housekeeping after the processing monsters but before processing the player
 */
static void pre_process_player(void)
{
 int i;
 /* Reset the riposte flag */
 player->upkeep->riposte = false;
 /* Reset the was_entranced flag */
 player->upkeep->was_entranced = false;
 /* Update the player's light radius */
 calc_light(player);
 /* Make the stealth-modified noise (has to occur after monsters have
	 * had a chance to move) */
 monsters_hear(true, true, player->stealth_score);
 /* Stop stealth mode if something happened */
 if (player->stealth_mode == STEALTH_MODE_STOPPING) {
  /* Cancel */
  player->stealth_mode = STEALTH_MODE_OFF;
  /* Recalculate bonuses */
  player->upkeep->update |= (PU_BONUS);
  /* Redraw the state */
  player->upkeep->redraw |= (PR_STATE);
 }
 /* Morgoth will announce a challenge if adjacent */
 if (player->truce && (player->depth == z_info->dun_depth)) {
  check_truce(player);
 }
 /* List all challenge options at the start of the game */
 if (player->turn == 1) {
  options_list_challenge();
 }
 /* Shuffle along the array of previous actions */
 for (i = MAX_ACTION - 1; i > 0; i--) {
  player->previous_action[i] = player->previous_action[i - 1];
 }
 /* Put in a default for this turn */
 player->previous_action[0] = ACTION_NOTHING;
 /* Redraw stuff (if needed) */
 redraw_stuff(player);
 /* Have to update the player bonuses at every turn with sprinting, dodging
	 * etc. This might cause annoying slowdowns, I'm not sure */
 player->upkeep->update |= (PU_BONUS);
}
/**
 * Housekeeping after the processing of any player command
 */
static void process_player_cleanup(void)
{
 int i;
 /* Check for greater vault squares */
 if (square_isgreatervault(cave, player->grid) && cave->vault_name) {
  char note[120];
  strnfmt(note, sizeof(note), "Entered %s", cave->vault_name);
  history_add(player, note, HIST_VAULT_ENTERED);
  /* Give a message unless it is the Gates or the Throne Room */
  if (player->depth > 0 && player->depth < 20) {
   msg("You have entered %s.", cave->vault_name);
  }
  string_free(cave->vault_name);
  cave->vault_name = NULL;
 }
 /* Significant */
 if (player->upkeep->energy_use) {
  /* Use some energy */
  player->energy -= player->upkeep->energy_use;
  /* Increment the total energy counter */
  player->total_energy += player->upkeep->energy_use;
  /* Do nothing else if player has auto-dropped stuff */
  if (!player->upkeep->dropping) {
   /* Hack -- constant hallucination */
   if (player->timed[TMD_IMAGE])
    player->upkeep->redraw |= (PR_MAP);
   /* Shimmer multi-hued monsters */
   for (i = 1; i < cave_monster_max(cave); i++) {
    struct monster *mon = cave_monster(cave, i);
    if (!mon->race)
     continue;
    if (!rf_has(mon->race->flags, RF_ATTR_MULTI))
     continue;
    square_light_spot(cave, mon->grid);
   }
   /* Show marked monsters */
   for (i = 1; i < cave_monster_max(cave); i++) {
    struct monster *mon = cave_monster(cave, i);
    if (mflag_has(mon->mflag, MFLAG_MARK)) {
     if (!mflag_has(mon->mflag, MFLAG_SHOW)) {
      mflag_off(mon->mflag, MFLAG_MARK);
      update_mon(mon, cave, false);
     }
    }
   }
  }
 }
 /* Clear SHOW flag and player drop status */
 for (i = 1; i < cave_monster_max(cave); i++) {
  struct monster *mon = cave_monster(cave, i);
  mflag_off(mon->mflag, MFLAG_SHOW);
 }
 player->upkeep->dropping = false;
 /* Hack - update needed first because inventory may have changed */
 update_stuff(player);
 redraw_stuff(player);
}
/**
 * Housekeeping after the processing of a player game command (ie energy use)
 */
static void process_player_post_energy_use_cleanup(void)
{
    /* If the player is exiting the the game in some manner, stop processing */
    if (player->is_dead || player->upkeep->generate_level) return;
 /* Do song effects */
 player_sing(player);
 /* Make less noise if you did nothing at all (+7 in total whether or
	 * not stealth mode is used) */
 if (player_is_resting(player)) {
  player->stealth_score += (player->stealth_mode) ? 2 : 7;
 }
 /* Make much more noise when smithing */
 if (player->upkeep->smithing) {
  /* Make a lot of noise */
  monsters_hear(true, false, -10);
 }
 /* Update noise and scent */
 cave->player_noise.centre = player->grid;
 update_flow(cave, &cave->player_noise, NULL);
 update_scent();
 /* Possibly identify DANGER flag every so often */
 if (one_in_(500)) {
  equip_learn_flag(player, OF_DANGER);
 }
 /*** Damage over Time ***/
 /* Take damage from poison */
 if (player->timed[TMD_POISONED]) {
  /* Amount is one fifth of the poison, rounding up */
  take_hit(player, (player->timed[TMD_POISONED] + 4) / 5, "poison");
  if (player->is_dead) {
   return;
  }
 }
 /* Take damage from cuts, worse from serious cuts */
 if (player->timed[TMD_CUT]) {
  /* Take damage */
  take_hit(player, (player->timed[TMD_CUT] + 4) / 5, "a fatal wound");
  if (player->is_dead) {
   return;
  }
 }
 /* Reduce the wrath counter */
 if (player->wrath) {
  int amount = (player->wrath / 100) * (player->wrath / 100);
  /* Half as fast if still singing the song */
  if (player_is_singing(player, lookup_song("Slaying"))) {
   player->wrath -= MAX(amount / 2, 1);
  } else {
   player->wrath -= MAX(amount, 1);
  }
  player->upkeep->update |= (PU_BONUS);
  player->upkeep->redraw |= (PR_SONG);
 }
 /*** Check the Food, and Regenerate ***/
 /* Digest */
 player_digest(player);
 if (player->is_dead) {
  return;
 }
 /* Regenerate Hit Points if needed */
 if (player->chp < player->mhp) {
  player_regen_hp(player);
 }
 /* Regenerate voice if needed */
 if (player->csp < player->msp) {
  player_regen_mana(player);
 }
 /* Timeout various things */
 decrease_timeouts();
 /* Notice things after time */
 if (!(turn % 100))
  equip_learn_after_time(player);
 /* Lower the staircasiness */
 if (player->staircasiness > 0) {
  int amount;
        /* Decreases much faster on the escape */
        if (player->on_the_run) {
            /* Amount is one hundredth of the current value, rounding up */
            amount = (player->staircasiness + 99) / 100;
        } else {
            /* Amount is one thousandth of the current value, rounding up */
            amount = (player->staircasiness + 999) / 1000;
        }
  player->staircasiness -= amount;
 }
 /* Increase the time since the last forge */
 player->forge_drought++;
 /* Reset the focus flag if the player didn't 'pass' this turn */
 if (player->previous_action[0] != ACTION_STAND) {
  player->focused = false;
 }
 /* Reset the consecutive attacks if the player didn't attack or 'pass' */
 if (!player->attacked && (player->previous_action[0] != ACTION_STAND)) {
  player->consecutive_attacks = 0;
  player->last_attack_m_idx = 0;
 }
 /* Check for radiance */
 if (player_radiates(player)) {
  sqinfo_on(square(cave, player->grid)->info, SQUARE_GLOW);
 }
 player->turn++;
}
/**
 * Process player commands from the command queue, finishing when there is a
 * command using energy (any regular game command), or we run out of commands
 * and need another from the user, or the character changes level or dies, or
 * the game is stopped.
 *
 * Notice the annoying code to handle "pack overflow", which
 * must come first just in case somebody manages to corrupt
 * the savefiles by clever use of menu commands or something. (Can go? NRM)
 *
 * Notice the annoying code to handle "monster memory" changes,
 * which allows us to avoid having to update the window flags
 * every time we change any internal monster memory field, and
 * also reduces the number of times that the recall window must
 * be redrawn.
 */
void process_player(void)
{
 /* Check for interrupts */
 player_resting_complete_special(player);
 event_signal(EVENT_CHECK_INTERRUPT);
 /* Repeat until energy is reduced */
 do {
  /* Refresh */
  notice_stuff(player);
  handle_stuff(player);
  event_signal(EVENT_REFRESH);
  /* Hack -- Pack Overflow */
  pack_overflow(NULL);
  /* Assume free turn */
  player->upkeep->energy_use = 0;
  /* Reset number of attacks this turn */
  event_signal(EVENT_COMBAT_RESET);
  /* Get base stealth score for the round; this will get modified by
		 * the type of action */
  player->stealth_score = player->state.skill_use[SKILL_STEALTH];
  /* Paralyzed or Knocked Out player gets no turn */
  if (player->timed[TMD_ENTRANCED] ||
   player_timed_grade_eq(player, TMD_STUN, "Knocked Out")) {
   cmdq_push(CMD_SLEEP);
  } else if (player->upkeep->knocked_back) {
   /* Knocked back player needs to recover footing */
   cmdq_push(CMD_SKIP);
  }
  /* Prepare for the next command */
  if (cmd_get_nrepeats() > 0) {
   event_signal(EVENT_COMMAND_REPEAT);
  } else {
   /* Check monster recall */
   if (player->upkeep->monster_race)
    player->upkeep->redraw |= (PR_MONSTER);
   /* Place cursor on player/target */
   event_signal(EVENT_REFRESH);
  }
  //TODO handle autopickup
  /* Get a command from the queue if there is one */
  if (!cmdq_pop(CTX_GAME))
   break;
  if (!player->upkeep->playing)
   break;
  process_player_cleanup();
 } while (!player->upkeep->energy_use &&
    !player->is_dead &&
    !player->upkeep->generate_level);
 if (player->upkeep->energy_use)
  process_player_post_energy_use_cleanup();
 /* Notice stuff (if needed) */
 notice_stuff(player);
}
/**
 * Housekeeping on arriving on a new level
 */
void on_new_level(void)
{
 int i;
 /* Update noise and scent */
 cave->player_noise.centre = player->grid;
 update_flow(cave, &cave->player_noise, NULL);
 update_scent();
 /* Disturb */
 disturb(player, false);
 /* Display the entry poetry, prepare for guaranteed forge */
 if (player->turn == 0) {
  event_signal_poem(EVENT_POEM, player->sex->poetry_name, 5, 15);
  player->forge_count = 0;
  player->forge_drought = 5000;
 }
 /* Flush messages */
 event_signal(EVENT_MESSAGE_FLUSH);
 /* Update display */
 event_signal(EVENT_NEW_LEVEL_DISPLAY);
 /* Track maximum dungeon level */
 if (player->max_depth < player->depth) {
  for (i = player->max_depth + 1; i <= player->depth; i++) {
   if (i > 1) {
    int new_exp = i * 50;
    player_exp_gain(player, new_exp);
    player->descent_exp += new_exp;
   }
  }
  player->max_depth = player->depth;
 }
 /* Update player */
 player->upkeep->update |= (PU_BONUS | PU_HP | PU_SPELLS | PU_INVEN);
 player->upkeep->notice |= (PN_COMBINE);
 notice_stuff(player);
 update_stuff(player);
 redraw_stuff(player);
 /* Refresh */
 event_signal(EVENT_REFRESH);
 /* Explain the truce for the final level */
 if ((player->depth == z_info->dun_depth) && player->truce) {
  msg("There is a strange tension in the air.");
  if (player->state.skill_use[SKILL_PERCEPTION] >= 15) {
   msg("You feel that Morgoth's servants are reluctant to attack before he delivers judgment.");
  }
 }
}
/**
 * Housekeeping on leaving a level
 */
static void on_leave_level(void) {
 /* Don't allow command repeat if moved away from item used. */
 cmd_disable_repeat_floor_item();
 /* Any pending processing */
 notice_stuff(player);
 update_stuff(player);
 redraw_stuff(player);
 /* Flush messages */
 event_signal(EVENT_MESSAGE_FLUSH);
}
/**
 * The main game loop.
 *
 * This function will run until the player needs to enter a command, or closes
 * the game, or the character dies.
 */
void run_game_loop(void)
{
 /* Process the character until energy use or another command is needed */
 while (player->upkeep->playing) {
  process_player();
  if (player->upkeep->energy_use) {
   break;
  } else {
   return;
  }
 }
 /* Now that the player's turn is fully complete, we run the main loop 
	 * until player input is needed again */
 while (true) {
  notice_stuff(player);
  handle_stuff(player);
  event_signal(EVENT_REFRESH);
  /* Process the rest of the world, give the character energy and
		 * increment the turn counter unless we need to stop playing or
		 * generate a new level */
  if (player->is_dead || !player->upkeep->playing) {
   return;
  } else if (!player->upkeep->generate_level) {
   /* Process the rest of the monsters */
   process_monsters(0);
   /* Mark all monsters as ready to act when they have the energy */
   reset_monsters();
   /* Refresh */
   notice_stuff(player);
   handle_stuff(player);
   event_signal(EVENT_REFRESH);
   if (player->is_dead || !player->upkeep->playing)
    return;
   /* Process the world every ten turns */
   if (!(turn % 10) && !player->upkeep->generate_level) {
    process_world(cave);
    /* Refresh */
    notice_stuff(player);
    handle_stuff(player);
    event_signal(EVENT_REFRESH);
    if (player->is_dead || !player->upkeep->playing)
     return;
   }
   /* Give the character some energy */
   player->energy += turn_energy(player->state.speed);
   /* Count game turns */
   turn++;
  } else {
   /* Make a new level if requested */
   if (character_dungeon) {
    on_leave_level();
   }
   if (!in_tutorial()) {
    prepare_next_level(player);
   } else {
    tutorial_prepare_section(
     tutorial_get_next_section(player),
     player);
   }
   on_new_level();
   player->upkeep->generate_level = false;
  }
  /* If the character has enough energy to move they now do so, after
		 * any monsters with more energy take their turns */
  while (player->energy >= z_info->move_energy) {
   /* Do any necessary animations */
   event_signal(EVENT_ANIMATE);
   /* Process monster with even more energy first */
   process_monsters(player->energy + 1);
   if (player->is_dead || !player->upkeep->playing ||
    player->upkeep->generate_level)
    break;
   /* Process the player until they use some energy */
   while (player->upkeep->playing) {
    pre_process_player();
    process_player();
    if (player->upkeep->energy_use) {
     break;
    } else {
     return;
    }
   }
  }
 }
}
/**
 * \file generate.c
 * \brief Dungeon generation.
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 * Copyright (c) 2013 Erik Osheim, Nick McConnell
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 *
 * This is the top level dungeon generation file, which contains room profiles
 * (for determining what rooms are available and their parameters), cave
 * profiles (for determining the level generation function and parameters for
 * different styles of levels), initialisation functions for template rooms and
 * vaults, and the main level generation function (which calls the level
 * builders from gen-cave.c).
 *
 * See the "vault.txt" file for more on vault generation.
 * See the "room_template.txt" file for more room templates.
 */
/*
 * Array of pit types
 */
struct vault *vaults;
static struct cave_profile *cave_profiles;
struct dun_data *dun;
struct room_template *room_templates;
static const struct {
 const char *name;
 cave_builder builder;
} cave_builders[] = {
/**
 * \file list-dun-profiles.h
 * \brief matches dungeon profile names to their building functions
 */
{ "cave", cave_gen },
{ "throne", throne_gen },
{ "gates", gates_gen },

};
static const struct {
 const char *name;
 int max_height;
 int max_width;
 room_builder builder;
} room_builders[] = {
/**
 * \file list-rooms.h
 * \brief matches dungeon room names to their building functions
 *
 * Fields:
 * name: name as appears in edit files
 * rows: Maximum number of rows (for vaults)
 * cols: Maximum number of columns (for vaults)
 * builder: name of room building function (with build_ prepended)
 */
/* name						rows	cols	builder */
{ "simple room", 0, 0, build_simple },
{ "crossed room", 0, 0, build_crossed },
{ "Interesting room", 22, 33, build_interesting },
{ "Lesser vault", 22, 33, build_lesser_vault },
{ "Greater vault", 44, 66, build_greater_vault },
{ "Throne room", 30, 35, build_throne },
{ "Gates of Angband", 32, 64, build_gates },

};
static const char *room_flags[] = {
 "NONE",
/**
 * \file list-room-flags.h
 * \brief List flags for room types
 *
 * Changing these flags would not affect savefiles but would affect the parsing
 * of vault.txt.
 *
 * Fields:
 * name
 * help string
 */
"NO_ROTATION",
"TRAPS",
"WEBS",
"LIGHT",
"TEST",
"MAX",

 NULL
};
/**
 * Parsing functions for dungeon_profile.txt
 */
static enum parser_error parse_profile_name(struct parser *p) {
 struct cave_profile *h = parser_priv(p);
 struct cave_profile *c = mem_zalloc(sizeof *c);
 size_t i;
 c->name = string_make(parser_getstr(p, "name"));
 for (i = 0; i < N_ELEMENTS(cave_builders); i++)
  if (streq(c->name, cave_builders[i].name))
   break;
 if (i == N_ELEMENTS(cave_builders))
  return PARSE_ERROR_NO_BUILDER_FOUND;
 c->builder = cave_builders[i].builder;
 c->next = h;
 parser_setpriv(p, c);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_profile_rooms(struct parser *p) {
 struct cave_profile *c = parser_priv(p);
 if (!c)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 c->dun_rooms = parser_getint(p, "rooms");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_profile_streamer(struct parser *p) {
 struct cave_profile *c = parser_priv(p);
 if (!c)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 c->str.den = parser_getint(p, "den");
 c->str.rng = parser_getint(p, "rng");
 c->str.qua = parser_getint(p, "qua");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_profile_alloc(struct parser *p) {
 struct cave_profile *c = parser_priv(p);
 if (!c)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 c->alloc = parser_getint(p, "alloc");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_profile_room(struct parser *p) {
 struct cave_profile *c = parser_priv(p);
 struct room_profile *r = c->room_profiles;
 size_t i;
 if (!c)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 /* Go to the last valid room profile, then allocate a new one */
 if (!r) {
  c->room_profiles = mem_zalloc(sizeof(struct room_profile));
  r = c->room_profiles;
  /* First profile is empty */
  //r->next = mem_zalloc(sizeof(struct room_profile));
  //r = r->next;
 } else {
  while (r->next)
   r = r->next;
  r->next = mem_zalloc(sizeof(struct room_profile));
  r = r->next;
 }
 /* Now read the data */
 r->name = string_make(parser_getsym(p, "name"));
 for (i = 0; i < N_ELEMENTS(room_builders); i++)
  if (streq(r->name, room_builders[i].name))
   break;
 if (i == N_ELEMENTS(room_builders))
  return PARSE_ERROR_NO_ROOM_FOUND;
 r->builder = room_builders[i].builder;
 r->hardness = parser_getint(p, "hardness");
 r->level = parser_getint(p, "level");
 r->random = parser_getint(p, "random");
 return PARSE_ERROR_NONE;
}
static struct parser *init_parse_profile(void) {
 struct parser *p = parser_new();
 parser_setpriv(p, NULL);
 parser_reg(p, "name str name", parse_profile_name);
 parser_reg(p, "rooms int rooms", parse_profile_rooms);
 parser_reg(p, "streamer int den int rng int qua", parse_profile_streamer);
 parser_reg(p, "alloc int alloc", parse_profile_alloc);
 parser_reg(p, "room sym name int hardness int level int random", parse_profile_room);
 return p;
}
static errr run_parse_profile(struct parser *p) {
 return parse_file_quit_not_found(p, "dungeon_profile");
}
static errr finish_parse_profile(struct parser *p) {
 struct cave_profile *n, *c = parser_priv(p);
 int num;
 /* Count the list */
 z_info->profile_max = 0;
 while (c) {
  z_info->profile_max++;
  c = c->next;
 }
 /* Allocate the array and copy the records to it */
 cave_profiles = mem_zalloc(z_info->profile_max * sizeof(*c));
 num = z_info->profile_max - 1;
 for (c = parser_priv(p); c; c = n) {
  /* Main record */
  memcpy(&cave_profiles[num], c, sizeof(*c));
  n = c->next;
  if (num < z_info->profile_max - 1) {
   cave_profiles[num].next = &cave_profiles[num + 1];
  } else {
   cave_profiles[num].next = NULL;
  }
  if (c->room_profiles) {
   struct room_profile *r_old = c->room_profiles;
   struct room_profile *r_new;
   int i;
   /* Count the room profiles */
   cave_profiles[num].n_room_profiles = 0;
   while (r_old) {
    ++cave_profiles[num].n_room_profiles;
    r_old = r_old->next;
   }
   /* Now allocate the room profile array */
   r_new = mem_zalloc(cave_profiles[num].n_room_profiles
    * sizeof(*r_new));
   r_old = c->room_profiles;
   for (i = 0; i < cave_profiles[num].n_room_profiles; i++) {
    struct room_profile *r_temp = r_old;
    /* Copy from the linked list to the array */
    memcpy(&r_new[i], r_old, sizeof(*r_old));
    /* Set the next profile pointer correctly. */
    if (r_new[i].next) {
     r_new[i].next = &r_new[i + 1];
    }
    /* Tidy up and advance to the next profile. */
    r_old = r_old->next;
    mem_free(r_temp);
   }
   cave_profiles[num].room_profiles = r_new;
  } else {
   cave_profiles[num].n_room_profiles = 0;
   cave_profiles[num].room_profiles = NULL;
  }
  mem_free(c);
  num--;
 }
 parser_destroy(p);
 return 0;
}
static void cleanup_profile(void)
{
 int i, j;
 for (i = 0; i < z_info->profile_max; i++) {
  for (j = 0; j < cave_profiles[i].n_room_profiles; j++)
   string_free((char *) cave_profiles[i].room_profiles[j].name);
  mem_free(cave_profiles[i].room_profiles);
  string_free((char *) cave_profiles[i].name);
 }
 mem_free(cave_profiles);
}
static struct file_parser profile_parser = {
 "dungeon_profile",
 init_parse_profile,
 run_parse_profile,
 finish_parse_profile,
 cleanup_profile
};
/**
 * Parsing functions for vault.txt
 */
static enum parser_error parse_vault_name(struct parser *p) {
 struct vault *h = parser_priv(p);
 struct vault *v = mem_zalloc(sizeof *v);
 v->name = string_make(parser_getstr(p, "name"));
 v->next = h;
 v->index = z_info->v_max;
 z_info->v_max++;
 parser_setpriv(p, v);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_vault_type(struct parser *p) {
 struct vault *v = parser_priv(p);
 if (!v)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 v->typ = string_make(parser_getstr(p, "type"));
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_vault_depth(struct parser *p) {
 struct vault *v = parser_priv(p);
 if (!v)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 v->depth = parser_getuint(p, "depth");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_vault_rarity(struct parser *p) {
 struct vault *v = parser_priv(p);
 if (!v)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 v->rarity = parser_getuint(p, "rarity");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_vault_flags(struct parser *p) {
 struct vault *v = parser_priv(p);
 char *s, *st;
 if (!v)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 s = string_make(parser_getstr(p, "flags"));
 st = strtok(s, " |");
 while (st && !grab_flag(v->flags, ROOMF_SIZE, room_flags, st)) {
  st = strtok(NULL, " |");
 }
 mem_free(s);
 return st ? PARSE_ERROR_INVALID_FLAG : PARSE_ERROR_NONE;
}
static enum parser_error parse_vault_d(struct parser *p) {
 struct vault *v = parser_priv(p);
 const char *desc;
 size_t i;
 if (!v)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 desc = parser_getstr(p, "text");
 if (!v->wid) {
  size_t wid = strlen(desc);
  if (wid > 255) {
   return PARSE_ERROR_VAULT_TOO_BIG;
  }
  v->wid = (uint8_t)wid;
 }
 if (strlen(desc) != v->wid) {
  return PARSE_ERROR_VAULT_DESC_WRONG_LENGTH;
 } else {
  if (v->hgt == 255) {
   return PARSE_ERROR_VAULT_TOO_BIG;
  }
  v->text = string_append(v->text, desc);
  v->hgt++;
  /* Note if there is a forge in the vault */
  if (strchr(desc, '0')) v->forge = true;
 }
 /* Make sure vaults are no higher or wider than the room profiles allow. */
 for (i = 0; i < N_ELEMENTS(room_builders); i++) {
  if (streq(v->typ, room_builders[i].name)) {
   break;
  }
 }
 if (i == N_ELEMENTS(room_builders)) {
  return PARSE_ERROR_NO_ROOM_FOUND;
 }
 if (v->wid > room_builders[i].max_width) {
  return PARSE_ERROR_VAULT_TOO_BIG;
 }
 if (v->hgt > room_builders[i].max_height) {
  return PARSE_ERROR_VAULT_TOO_BIG;
 }
 return PARSE_ERROR_NONE;
}
struct parser *init_parse_vault(void) {
 struct parser *p = parser_new();
 z_info->v_max = 0;
 parser_setpriv(p, NULL);
 parser_reg(p, "name str name", parse_vault_name);
 parser_reg(p, "type str type", parse_vault_type);
 parser_reg(p, "depth uint depth", parse_vault_depth);
 parser_reg(p, "rarity uint rarity", parse_vault_rarity);
 parser_reg(p, "flags str flags", parse_vault_flags);
 parser_reg(p, "D str text", parse_vault_d);
 return p;
}
static errr run_parse_vault(struct parser *p) {
 return parse_file_quit_not_found(p, "vault");
}
static errr finish_parse_vault(struct parser *p) {
 uint32_t rarity_denom = 1;
 struct vault *v;
 vaults = parser_priv(p);
 parser_destroy(p);
 /*
	 * For use in random_vault(), convert rarities from the 1 per value
	 * specified in vault.txt to use a fixed denominator that is the
	 * smallest integer positive integer divisible by all the rarities.
	 */
 for (v = vaults; v; v = v->next) {
  if (v->rarity > 0) {
   /*
			 * Find the greatest common divisor of rarity_denom and
			 * v->rarity using the division-based version of
			 * Euclid's algorithm.
			 */
   uint32_t g = rarity_denom;
   uint32_t b = v->rarity;
   while (b) {
    uint32_t t = b;
    b = g % b;
    g = t;
   }
   /*
			 * Update rarity_denom with the factors from v->rarity
			 * not already present.
			 */
   if (rarity_denom > 4294967295 / (v->rarity / g)) {
    plog("Smallest integer divisible by all vault rarities is too large.");
    return PARSE_ERROR_OUT_OF_BOUNDS;
   }
   rarity_denom *= v->rarity / g;
  }
 }
 /*
	 * Avoid the potential of overflow in random_vault() as it accumulates
	 * the rarities of possible vaults.
	 */
 if (rarity_denom > 4294967295 / z_info->v_max) {
  plog("Product of number of vaults and smallest integer divisible by all vault rarities is too large.");
  return PARSE_ERROR_OUT_OF_BOUNDS;
 }
 for (v = vaults; v; v = v->next) {
  if (v->rarity > 0) {
   v->rarity = rarity_denom / v->rarity;
  }
 }
 return 0;
}
static void cleanup_vault(void)
{
 struct vault *v, *next;
 for (v = vaults; v; v = next) {
  next = v->next;
  mem_free(v->name);
  mem_free(v->typ);
  mem_free(v->text);
  mem_free(v);
 }
}
static struct file_parser vault_parser = {
 "vault",
 init_parse_vault,
 run_parse_vault,
 finish_parse_vault,
 cleanup_vault
};
static void run_template_parser(void) {
 /* Initialize room info */
 event_signal_message(EVENT_INITSTATUS, 0,
       "Initializing arrays... (dungeon profiles)");
 if (run_parser(&profile_parser))
  quit("Cannot initialize dungeon profiles");
 /* Initialize vault info */
 event_signal_message(EVENT_INITSTATUS, 0,
       "Initializing arrays... (vaults)");
 if (run_parser(&vault_parser))
  quit("Cannot initialize vaults");
}
/**
 * Free the template arrays
 */
static void cleanup_template_parser(void)
{
 cleanup_parser(&profile_parser);
 cleanup_parser(&vault_parser);
}
/**
 * Find a cave_profile by name
 * \param name is the name of the cave_profile being looked for
 */
static const struct cave_profile *find_cave_profile(const char *name)
{
 int i;
 for (i = 0; i < z_info->profile_max; i++) {
  const struct cave_profile *profile;
  profile = &cave_profiles[i];
  if (streq(name, profile->name))
   return profile;
 }
 /* Not there */
 return NULL;
}
/**
 * Choose a cave profile (only one for most levels currently - NRM)
 * \param p is the player
 */
static const struct cave_profile *choose_profile(struct player *p)
{
 const struct cave_profile *profile = NULL;
 /* Make the profile choice */
 if (p->depth == 0) {
  profile = find_cave_profile("gates");
 } else if (p->depth == z_info->dun_depth) {
  profile = find_cave_profile("throne");
 } else {
  int total_alloc = 0;
  size_t i;
  /*
		 * Use PowerWyrm's selection algorithm from
		 * get_random_monster_object() so the selection can be done in
		 * one pass and without auxiliary storage (at the cost of more
		 * calls to randint0()).  The mth valid profile out of n valid
		 * profiles appears with probability, alloc(m) /
		 * sum(i = 0 to m, alloc(i)) * product(j = m + 1 to n - 1,
		 * 1 - alloc(j) / sum(k = 0 to j, alloc(k))) which is equal to
		 * alloc(m) / sum(i = 0 to m, alloc(i)) * product(j = m + 1 to
		 * n - 1, sum(k = 0 to j - 1, alloc(k)) / sum(l = 0 to j,
		 * alloc(l))) which, by the canceling of successive numerators
		 * and denominators is alloc(m) / sum(l = 0 to n - 1, alloc(l)).
		 */
  for (i = 0; i < z_info->profile_max; i++) {
   struct cave_profile *test_profile = &cave_profiles[i];
   if (test_profile->alloc <= 0) continue;
   total_alloc += test_profile->alloc;
   if (randint0(total_alloc) < test_profile->alloc) {
    profile = test_profile;
   }
  }
  if (!profile) {
   profile = find_cave_profile("cave");
  }
 }
 /* Return the profile or fail horribly */
 if (profile)
  return profile;
 else
  quit("Failed to find cave profile!");
 return NULL;
}
/**
 * Clear the dungeon, ready for generation to begin.
 */
static void cave_clear(struct chunk *c, struct player *p)
{
 /* Reset smithing leftover (as there is no access to the old forge) */
 p->smithing_leftover = 0;
    /* Reset the forced skipping of next turn (a bit rough to miss
	 * first turn if you fell down) */
    p->upkeep->knocked_back = false;
 /* Forget knowledge of old level */
 if (p->cave && (c == cave)) {
  int x, y;
  /* Deal with artifacts */
  for (y = 0; y < c->height; y++) {
   for (x = 0; x < c->width; x++) {
    struct object *obj = square_object(c, loc(x, y));
    while (obj) {
     if (obj->artifact && object_is_known_artifact(obj)) {
      history_lose_artifact(p, obj->artifact);
      mark_artifact_created(obj->artifact, true);
     }
     obj = obj->next;
    }
   }
  }
  /* Free the known cave */
  cave_free(p->cave);
  p->cave = NULL;
 }
 /* Clear the monsters */
 wipe_mon_list(c, p);
 /* Forget the fire information */
 forget_fire(c);
 /* Free the chunk */
 cave_free(c);
}
/**
 * Release the dynamically allocated resources in a dun_data structure.
 */
static void cleanup_dun_data(struct dun_data *dd)
{
 int i;
 mem_free(dd->cent);
 mem_free(dd->corner);
 mem_free(dd->piece);
 for (i = 0; i < z_info->level_room_max; ++i) {
  mem_free(dd->connection[i]);
 }
 mem_free(dd->connection);
 for (i = 0; i < z_info->dungeon_hgt; ++i) {
  mem_free(dd->tunn1[i]);
  mem_free(dd->tunn2[i]);
 }
 mem_free(dd->tunn1);
 mem_free(dd->tunn2);
}
/**
 * Generate a random level.
 *
 * Confusingly, this function also generates the town level (level 0).
 * \param p is the current player struct, in practice the global player
 * \return a pointer to the new level
 */
static struct chunk *cave_generate(struct player *p)
{
 const char *error = "no generation";
 int i, tries = 0;
 struct chunk *chunk = NULL;
 /* Generate */
 for (tries = 0; tries < 100 && error; tries++) {
  int y, x;
  struct dun_data dun_body;
  bool forge_made = p->unique_forge_made;
  error = NULL;
  /* Mark the dungeon as being unready (to avoid artifact loss, etc) */
  character_dungeon = false;
  /* Allocate global data (will be freed when we leave the loop) */
  dun = &dun_body;
  dun->cent = mem_zalloc(z_info->level_room_max * sizeof(struct loc));
  dun->cent_n = 0;
  dun->corner = mem_zalloc(z_info->level_room_max
         * sizeof(struct rectangle));
  dun->piece = mem_zalloc(z_info->level_room_max * sizeof(int));
  dun->tunn1 = mem_zalloc(z_info->dungeon_hgt * sizeof(int*));
  dun->tunn2 = mem_zalloc(z_info->dungeon_hgt * sizeof(int*));
  for (y = 0; y < z_info->dungeon_hgt; y++) {
   dun->tunn1[y] = mem_zalloc(z_info->dungeon_wid * sizeof(int));
   dun->tunn2[y] = mem_zalloc(z_info->dungeon_wid * sizeof(int));
  }
  dun->connection = mem_zalloc(z_info->level_room_max * sizeof(bool*));
  for (i = 0; i < z_info->level_room_max; ++i) {
   dun->connection[i] = mem_zalloc(z_info->level_room_max
           * sizeof(bool));
  }
  /* Choose a profile and build the level */
  dun->profile = choose_profile(p);
  event_signal_string(EVENT_GEN_LEVEL_START, dun->profile->name);
  chunk = dun->profile->builder(p);
  if (!chunk) {
   error = "Failed to find builder";
   cleanup_dun_data(dun);
   p->unique_forge_made = forge_made;
   event_signal_flag(EVENT_GEN_LEVEL_END, false);
   continue;
  }
  /* Clear generation flags */
  for (y = 0; y < chunk->height; y++) {
   for (x = 0; x < chunk->width; x++) {
    struct loc grid = loc(x, y);
    sqinfo_off(square(chunk, grid)->info, SQUARE_WALL_INNER);
    sqinfo_off(square(chunk, grid)->info, SQUARE_WALL_OUTER);
    sqinfo_off(square(chunk, grid)->info, SQUARE_WALL_SOLID);
   }
  }
  /* Regenerate levels that overflow their maxima */
  if (cave_monster_max(chunk) >= z_info->level_monster_max)
   error = "too many monsters";
  if (error) {
   if (OPT(p, cheat_room)) {
    msg("Generation restarted: %s.", error);
   }
   uncreate_artifacts(chunk);
   uncreate_greater_vaults(chunk, p);
   cave_clear(chunk, p);
   p->unique_forge_made = forge_made;
   event_signal_flag(EVENT_GEN_LEVEL_END, false);
  }
  cleanup_dun_data(dun);
 }
 if (error) quit_fmt("cave_generate() failed 100 times!");
 /* Validate the dungeon (we could use more checks here) */
 chunk_validate_objects(chunk);
 /* Allocate new known level */
 p->cave = cave_new(chunk->height, chunk->width);
 p->cave->depth = chunk->depth;
 p->cave->objects = mem_realloc(p->cave->objects, (chunk->obj_max + 1)
           * sizeof(struct object*));
 p->cave->obj_max = chunk->obj_max;
 for (i = 0; i <= p->cave->obj_max; i++) {
  p->cave->objects[i] = NULL;
 }
 /* Clear stair creation */
 p->upkeep->create_stair = FEAT_NONE;
 return chunk;
}
/**
 * Prepare the level the player is about to enter
 *
 * \param p is the current player struct, in practice the global player
*/
void prepare_next_level(struct player *p)
{
 int x, y;
 bool noted = false;
 /* Deal with any existing current level */
 if (character_dungeon) {
  /* Deal with missing out on stuff */
  for (y = 0; y < cave->height; y++) {
   for (x = 0; x < cave->width; x++) {
    struct loc grid = loc(x, y);
    /* Artifacts */
    struct object *obj = square_object(cave, grid);
    while (obj) {
     if (obj->artifact) {
      history_lose_artifact(p, obj->artifact);
      mark_artifact_created(obj->artifact, true);
     }
     obj = obj->next;
    }
    /* Greater vaults */
    if (!noted && square_isknown(cave, grid) &&
     square_isgreatervault(cave, grid)) {
     history_add(p, format("Left without entering %s",
            cave->vault_name), HIST_VAULT_LOST);
     noted = true;
    }
   }
  }
  /* Clear the old cave */
  if (cave) {
   cave_clear(cave, p);
   cave = NULL;
  }
 }
 /* Generate a new level */
 cave = cave_generate(p);
 event_signal_flag(EVENT_GEN_LEVEL_END, true);
 /* Note any forges generated, done here in case generation fails earlier */
 for (y = 0; y < cave->height; y++) {
  for (x = 0; x < cave->width; x++) {
   if (square_isforge(cave, loc(x, y))) {
    /* Reset the time since the last forge when an interesting room
				 * with a forge is generated */
    player->forge_drought = 0;
    player->forge_count++;
   }
  }
 }
 /* The dungeon is ready */
 character_dungeon = true;
}
/**
 * Return the number of room builders available.
 */
int get_room_builder_count(void)
{
 return (int) N_ELEMENTS(room_builders);
}
/**
 * Convert the name of a room builder into its index.  Return -1 if the
 * name does not match any of the room builders.
 */
int get_room_builder_index_from_name(const char *name)
{
 int i = 0;
 while (1) {
  if (i >= (int) N_ELEMENTS(room_builders)) {
   return -1;
  }
  if (streq(name, room_builders[i].name)) {
   return i;
  }
  ++i;
 }
}
/**
 * Get the name of a room builder given its index.  Return NULL if the index
 * is out of bounds (less than one or greater than or equal to
 * get_room_builder_count()).
 */
const char *get_room_builder_name_from_index(int i)
{
 return (i >= 0 && i < (int) get_room_builder_count()) ?
  room_builders[i].name : NULL;
}
/**
 * Convert the name of a level profile into its index in the cave_profiles
 * list.  Return -1 if the name does not match any of the profiles.
 */
int get_level_profile_index_from_name(const char *name)
{
 const struct cave_profile *p = find_cave_profile(name);
 return (p) ? (int) (p - cave_profiles) : -1;
}
/**
 * Get the name of a level profile given its index.  Return NULL if the index
 * is out of bounds (less than one or greater than or equal to
 * z_info->profile_max).
 */
const char *get_level_profile_name_from_index(int i)
{
 return (i >= 0 && i < z_info->profile_max) ?
  cave_profiles[i].name : NULL;
}
/**
 * The generate module, which initialises template rooms and vaults
 * Should it clean up?
 */
struct init_module generate_module = {
 .name = "generate",
 .init = run_template_parser,
 .cleanup = cleanup_template_parser
};
/**
 * \file gen-cave.c
 * \brief Generation of dungeon levels
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 * Copyright (c) 2013 Erik Osheim, Nick McConnell
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 *
 * In this file, we use the SQUARE_WALL flags to the info field in
 * cave->squares.  Those are applied and tested on granite.  SQUARE_WALL_SOLID
 * fills the areas between rooms and can be carved out by tunneling.
 * SQUARE_WALL_INNER is used in rooms, either for exterior walls that can not
 * be carved out by tunneling or for interior walls.  SQUARE_WALL_OUTER is
 * used in rooms for exterior walls that can be carved out by tunneling.
 *
 * Note that a tunnel which attempts to leave a room near the edge of the
 * dungeon in a direction toward that edge will cause "silly" wall piercings,
 * but will have no permanently incorrect effects, as long as the tunnel can
 * eventually exit from another side. And note that the wall may not come back
 * into the room by the hole it left through, so it must bend to the left or
 * right and then optionally re-enter the room (at least 2 grids away). This is
 * not a problem since every room that is large enough to block the passage of
 * tunnels is also large enough to allow the tunnel to pierce the room itself
 * several times.
 *
 * Note that no two corridors may enter a room through adjacent grids, they
 * must either share an entryway or else use entryways at least two grids
 * apart. This prevents large (or "silly") doorways.
 *
 * Traditionally, to create rooms in the dungeon, it was divided up into
 * "blocks" of 11x11 grids each, and all rooms were required to occupy a
 * rectangular group of blocks.  As long as each room type reserved a
 * sufficient number of blocks, the room building routines would not need to
 * check bounds. Note that in classic generation most of the normal rooms
 * actually only use 23x11 grids, and so reserve 33x11 grids.
 *
 * Note that a lot of the original motivation for the block system was the
 * fact that there was only one size of map available, 22x66 grids, and the
 * dungeon level was divided up into nine of these in three rows of three.
 * Now that the map can be resized and enlarged, and dungeon levels themselves
 * can be different sizes, much of this original motivation has gone.  Blocks
 * can still be used, but different cave profiles can set their own block
 * sizes.  The classic generation method still uses the traditional blocks; the
 * main motivation for using blocks now is for the aesthetic effect of placing
 * rooms on a grid.
 */
/* ------------------ UTILITIES ---------------- */
//static char dumpname[30];
//strnfmt(dumpname, sizeof(dumpname), "%s", whatevs);
//dump_level_simple(dumpname, "Test Level", c);
/**
 * Determines whether the player can pass through a given feature
 * icky locations (inside vaults) are all considered passable.
 */
static bool player_pass(struct chunk *c, struct loc grid, bool ignore_rubble)
{
 bool vault_interior = square_isvault(c, grid) &&
  square_isvault(c, loc(grid.x - 1, grid.y)) &&
  square_isvault(c, loc(grid.x + 1, grid.y)) &&
  square_isvault(c, loc(grid.x, grid.y - 1)) &&
  square_isvault(c, loc(grid.x, grid.y + 1));
 return square_ispassable(c, grid) || square_issecretdoor(c, grid) ||
  square_iscloseddoor(c, grid) ||
  (square_isrubble(c, grid) && ignore_rubble) || vault_interior;
}
/**
 * Floodfills access through the dungeon, marking all accessible squares true
 */
static void flood_access(struct chunk *c, struct loc grid, bool **access,
       bool ignore_rubble)
{
 int i;
 /* First check the map bounds */
 if (!square_in_bounds(c, grid)) return;
 access[grid.y][grid.x] = true;
 for (i = 0; i < 8; i++) {
  struct loc check = loc_sum(grid, ddgrid_ddd[i]);
  if (player_pass(c, check, ignore_rubble) && !access[check.y][check.x]) {
   flood_access(c, check, access, ignore_rubble);
  }
 }
 return;
}
/**
 * Make sure that the level is sufficiently connected.
 *
 * Currently a failure here results in a new level being generated, which is OK
 * as long as it's not happening too often.  Ideally connect_rooms_stairs()
 * should be rewritten so it doesn't happen at all - NRM.
 */
static bool check_connectivity(struct chunk *c)
{
 struct loc grid;
 bool result = false;
 /* Set the array used for checking connectivity */
 bool **access = mem_zalloc(c->height * sizeof(bool*));
 for (grid.y = 0; grid.y < c->height; grid.y++) {
  access[grid.y] = mem_zalloc(c->width * sizeof(bool));
 }
 /* Make sure entire dungeon is connected (ignoring rubble) */
 flood_access(c, player->grid, access, true);
 for (grid.y = 0; grid.y < c->height; grid.y++) {
  for (grid.x = 0; grid.x < c->width; grid.x++) {
   if (player_pass(c, grid, true) && !access[grid.y][grid.x]) {
    goto CLEANUP;
   }
  }
 }
 /* Reset the array used for checking connectivity */
 for (grid.y = 0; grid.y < c->height; grid.y++) {
  for (grid.x = 0; grid.x < c->width; grid.x++) {
   access[grid.y][grid.x] = false;
  }
 }
 /* Make sure player can reach stairs without going through rubble */
 flood_access(c, player->grid, access, false);
 for (grid.y = 0; grid.y < c->height; grid.y++) {
  for (grid.x = 0; grid.x < c->width; grid.x++) {
   if (access[grid.y][grid.x] && square_isstairs(c, grid)) {
    result = true;
    goto CLEANUP;
   }
  }
 }
CLEANUP:
 for (grid.y = 0; grid.y < c->height; grid.y++) {
  mem_free(access[grid.y]);
 }
 mem_free(access);
 return result;
}
/**
 * Floodfills access through the *graph* of the dungeon
 */
static void flood_piece(int n, int piece_num)
{
 int i;
 dun->piece[n] = piece_num;
 for (i = 0; i < dun->cent_n; i++) {
  if (dun->connection[n][i] && (dun->piece[i] == 0)) {
   flood_piece(i, piece_num);
  }
 }
 return;
}
static int dungeon_pieces(void)
{
 int piece_num;
 int i;
 /* First reset the pieces */
 for (i = 0; i < dun->cent_n; i++) {
  dun->piece[i] = 0;
 }
 for (piece_num = 1; piece_num <= dun->cent_n; piece_num++) {
  /* Find the next room that doesn't belong to a piece */
  for (i = 0; (i < dun->cent_n) && (dun->piece[i] != 0); i++);
  if (i == dun->cent_n) {
   break;
  } else {
   flood_piece(i, piece_num);
  }
 }
 return (piece_num - 1);
}
/**
 * Places a streamer of rock through dungeon.
 *
 * \param c is the current chunk
 * \param feat is the base feature (FEAT_MAGMA or FEAT_QUARTZ)
 * \param chance is the number of regular features per one gold
 *
 * Note that their are actually six different terrain features used to
 * represent streamers. Three each of magma and quartz, one for basic vein, one
 * with hidden gold, and one with known gold. The hidden gold types are
 * currently unused.
 */
static bool build_streamer(struct chunk *c, int feat)
{
 /* Hack -- Choose starting point */
 struct loc grid = rand_loc(loc(c->width / 2, c->height / 2), 15, 10);
 /* Choose a random direction */
 int dir = ddd[randint0(8)];
 int tries1 = 0;
 /* Place streamer into dungeon */
 while (true) {
  int i;
  struct loc change;
  tries1++;
  if (tries1 > 2500) return false;
  /* One grid per density */
  for (i = 0; i < dun->profile->str.den; i++) {
   int d = dun->profile->str.rng;
   /* Pick a nearby grid */
   find_nearby_grid(c, &change, grid, d, d);
   /* Only convert walls */
   if (square_isgranitewall(c, change)) {
    /* Turn the rock into the vein type */
    square_set_feat(c, change, feat);
   }
  }
  /* Advance the streamer */
  grid = loc_sum(grid, ddgrid[dir]);
  /* Stop at dungeon edge */
  if (!square_in_bounds(c, grid)) break;
 }
 return true;
}
/**
 * Places a single chasm.
 *
 * \param c is the current chunk
 */
static void build_chasm(struct chunk *c)
{
 bool chasm_ok = false;
 struct loc grid1;
 /* Try to mark squares to be a chasm */
 while (!chasm_ok) {
  int i;
        /* Choose starting point */
        struct loc grid = loc(rand_range(10, c->width - 10),
         rand_range(10, c->height - 10));
  /* Choose a random cardinal direction for it to run in */
  int main_dir = ddd[randint0(4)];
  /* Choose a random length for it */
        int length = damroll(4, 8);
  /* Count floor squares that will be turned to chasm */
        int floor_to_chasm = 0;
  /* Determine its shape */
        for (i = 0; i < length; i++) {
            /* Go in a random direction half the time */
            if (one_in_(2)) {
                /* Choose the random cardinal direction */
                grid = loc_sum(grid, ddgrid_ddd[randint0(4)]);
            } else {
    /* Go straight ahead the other half */
    grid = loc_sum(grid, ddgrid[main_dir]);
   }
   /* Stop near dungeon edge */
            if ((grid.y < 3) || (grid.y > c->height - 3) ||
    (grid.x < 3) || (grid.x > c->width - 3))
    break;
            /* Mark that we want to put a chasm here */
            sqinfo_on(square(c, grid)->info, SQUARE_CHASM);
        }
  /* Start by assuming it will be OK */
        chasm_ok = true;
  /* Check it doesn't wreck the dungeon */
        for (grid.y = 1; grid.y < c->height - 1; grid.y++) {
            for (grid.x = 1; grid.x < c->width - 1; grid.x++) {
    /* Adjacent grids in the cardinal directions */
    struct loc gride = loc_sum(grid, loc(1, 0));
    struct loc grids = loc_sum(grid, loc(0, 1));
    struct loc gridw = loc_sum(grid, loc(-1, 0));
    struct loc gridn = loc_sum(grid, loc(0, -1));
                /* Only inspect squares currently destined to be chasms */
                if (square_tobechasm(c, grid)) {
                    /* Avoid chasms in interesting rooms / vaults */
                    if (square_isvault(c, grid)) {
                        chasm_ok = false;
                    }
                    /* Avoid two chasm square in a row in corridors */
                    if (square_tobechasm(c, grids) && !square_isroom(c, grid) &&
      !square_isroom(c, grids) && square_isfloor(c, grid) &&
      square_isfloor(c, grids)) {
                        chasm_ok = false;
                    }
                    if (square_tobechasm(c, gride) && !square_isroom(c, grid) &&
      !square_isroom(c, gride) && square_isfloor(c, grid) &&
      square_isfloor(c, gride)) {
                        chasm_ok = false;
                    }
                    /* Avoid a chasm taking out the rock next to a door */
                    if (square_iscloseddoor(c, gride) ||
      square_iscloseddoor(c, grids) ||
      square_iscloseddoor(c, gridw) ||
      square_iscloseddoor(c, gridn)) {
                        chasm_ok = false;
                    }
                    /* Avoid a chasm just hitting the wall of a lit room (would
					 * look odd that the light doesn't hit the wall behind) */
                    if (square_isrock(c, grid) && square_isglow(c, grid)) {
                        if ((square_isrock(c, gride) && !square_isglow(c, gride)
        && !square_tobechasm(c, gride)) ||
       (square_isrock(c, grids) && !square_isglow(c, grids)
        && !square_tobechasm(c, grids)) ||
       (square_isrock(c, gridw) && !square_isglow(c, gridw)
        && !square_tobechasm(c, gridw)) ||
       (square_isrock(c, gridn) && !square_isglow(c, gridn)
        && !square_tobechasm(c, gridn))) {
                            chasm_ok = false;
                        }
                    }
                    /* Avoid a chasm having no squares in a room/corridor */
                    if (square_ispassable(c, grid)) {
                        floor_to_chasm++;
                    }
                }
            }
        }
  /* The chasm must affect at least one floor square */
        if (floor_to_chasm < 1) {
   chasm_ok = false;
  }
  /* Clear the flag for failed chasm placement */
        if (!chasm_ok) {
   for (grid.y = 0; grid.y < c->height; grid.y++) {
    for (grid.x = 0; grid.x < c->width; grid.x++) {
     sqinfo_off(square(c, grid)->info, SQUARE_CHASM);
                }
            }
        }
 }
 /* Actually place the chasm and clear the flag */
 for (grid1.y = 0; grid1.y < c->height; grid1.y++) {
  for (grid1.x = 0; grid1.x < c->width; grid1.x++) {
   if (sqinfo_has(square(c, grid1)->info, SQUARE_CHASM)) {
    square_set_feat(c, grid1, FEAT_CHASM);
    sqinfo_off(square(c, grid1)->info, SQUARE_CHASM);
   }
  }
 }
}
/**
 * Places chasms through dungeon
 */
static void build_chasms(struct chunk *c)
{
    int i;
    int chasms = 0;
    int blocks = (c->height / z_info->block_hgt) * (c->width / z_info->block_wid);
    /* Determine whether to add chasms, and how many */
    if ((c->depth > 2) && (c->depth < z_info->dun_depth - 1) &&
  percent_chance(c->depth + 30)) {
        /* Add some chasms */
        chasms += damroll(1, blocks / 3);
        /* Flip a coin, and if it is heads... */
        while (one_in_(2)) {
            /* Add some more chasms and flip again... */
            chasms += damroll(1, blocks / 3);
        }
    }
    /* Build them */
    for (i = 0; i < chasms; i++) {
        build_chasm(c);
    }
    if (OPT(player, cheat_room) && (chasms > 0)) {
  msg("%d chasms.", chasms);
 }
}
/**
 * Check the validity of a horizontal or vertical tunnel
 */
static bool tunnel_ok(struct chunk *c, struct loc grid1, struct loc grid2,
      bool tentative, int desired_changes)
{
 int x, y;
 struct loc grid_lo, grid_hi;
 bool vert = true;
 int changes = 0;
 /* Get the direction */
 if (grid1.y == grid2.y) {
  /* Horizontal */
  vert = false;
  if (grid1.x < grid2.x) {
   grid_lo = grid1;
   grid_hi = grid2;
  } else {
   grid_lo = grid2;
   grid_hi = grid1;
  }
 } else {
  /* Vertical */
  if (grid1.y < grid2.y) {
   grid_lo = grid1;
   grid_hi = grid2;
  } else {
   grid_lo = grid2;
   grid_hi = grid1;
  }
 }
 /* Don't dig corridors ending at a room's outer wall (can happen at corners
	 * of L-corridors) */
 if (square_iswall_outer(c, grid_lo) || square_iswall_outer(c, grid_hi)) {
  return false;
 }
 /* Don't dig L-corridors when the corner is too close to empty space */
 if (!square_isroom(c, grid_lo)) {
  struct loc check1 = loc_sum(grid_lo, loc(-1, -1));
  struct loc check2 = vert ? loc_sum(grid_lo, loc(1, -1)) :
   loc_sum(grid_lo, loc(-1, 1));
  if (square_isfloor(c, check1) || square_isfloor(c, check2)) {
   return false;
  }
 }
 if (!square_isroom(c, grid_hi)) {
  struct loc check1 = vert ? loc_sum(grid_hi, loc(-1, 1)) :
   loc_sum(grid_hi, loc(1, -1));
  struct loc check2 = loc_sum(grid_hi, loc(1, 1));
  if (square_isfloor(c, check1) || square_isfloor(c, check2)) {
   return false;
  }
 }
 /* Test each location in the corridor */
 for (x = grid_lo.x, y = grid_lo.y; x <= grid_hi.x && y <= grid_hi.y;
   vert ? y++ : x++) {
  /* Grid we're testing */
  struct loc grid = loc(x, y);
  /* Grid above or left */
  struct loc perp0 = vert ? loc(x - 1, y) : loc(x, y - 1);
  /* Grid below or right */
  struct loc perp1 = vert ? loc(x + 1, y) : loc(x, y + 1);
  /* Previous grid along the tunnel */
  struct loc prev = vert ? loc(x, y - 1) : loc(x - 1, y);
  /* Abort if the tunnel would go through or adjacent to an existing door
		 * (except in vaults) */
  if (square_iscloseddoor(c, perp0) && !square_isvault(c, perp0)) {
   return false;
  }
  if (square_iscloseddoor(c, grid) && !square_isvault(c, grid)) {
   return false;
  }
  if (square_iscloseddoor(c, perp1) && !square_isvault(c, perp1)) {
   return false;
  }
  /* Abort if the tunnel would have floor beside it at some point
		 * outside a room */
  if ((square_isfloor(c, perp0) || square_isfloor(c, perp1)) &&
   !square_isroom(c, grid)) {
   return false;
  }
  /* The remaining checks compare successive grids along the tunnel,
		 * so we skip the first tunnel grid */
  if ((x == grid_lo.x) && (y == grid_lo.y)) continue;
  /*
		 * Count the number of times it enters or leaves a room.
		 * This matches Sil 1.3's logic but won't count cases
		 * where the interior grid is quartz or rubble (the former
		 * does not seem to happen in Sil 1.3's vaults; that latter
		 * can happen for Sil 1.3's Collapsed Cross, Collapsed Keep,
		 * Cave in, and perhaps others).  Note that a tunnel that
		 * grazes a room's boundary could also contribute to the
		 * count (for instance, a horizontal tunnel hitting a vault
		 * with a horizontal boundary of "$7$").
		 */
  if (square_iswall_outer(c, grid) &&
   (square_ispassable(c, prev) || square_iswall_inner(c, prev))) {
   /* To outside from inside */
   changes++;
  }
  if (square_iswall_outer(c, prev) &&
   (square_ispassable(c, grid) || square_iswall_inner(c, grid))) {
   /* From outside to inside */
   changes++;
  }
  /*
		 * Abort if the tunnel would go through two adjacent squares
		 * of the outside wall of a room.  This matches Sil 1.3's
		 * logic, but Sil 1.3's vaults have grids on the boundaries
		 * that are not SQUARE_WALL_OUTER:  SQUARE_WALL_INNER,
		 * quartz, rubble, and chasms, for instance.  Most problematic
		 * tunnels with those vaults will be screened out by this
		 * test, the test for going through an adjacent
		 * SQUARE_WALL_OUTER and SQUARE_WALL_INNER, the test for
		 * directly accessing the internals of a room without passing
		 * through a SQUARE_WALL_OUTER, or the constraint on the
		 * number of inside/outside crossings.  However, the Glittering
		 * Caves vaults in Sil 1.3 (where there are possible tunnels
		 * that access the internals and only pass through '%') may
		 * be a problem.  It is possible to construct vaults (say
		 * with a horizontal boundary that looks like "$7$", "$:$:$",
		 * or "$%%$%%$") which would allow grazing tunnels that
		 * wouldn't be rejected by the tests here or in Sil 1.3.
		 */
  if (square_iswall_outer(c, grid) && square_iswall_outer(c, prev)) {
   return false;
  }
  /* Abort if the tunnel would go between a door and an outside wall */
  if (square_iswall_outer(c, prev) && square_iscloseddoor(c, grid)) {
   return false;
  }
  if (square_iswall_outer(c, grid) && square_iscloseddoor(c, prev)) {
   return false;
  }
  /* Abort if the tunnel would go between an outside and an inside wall */
  if (square_iswall_outer(c, prev) && square_iswall_inner(c, grid)) {
   return false;
  }
  if (square_iswall_outer(c, grid) && square_iswall_inner(c, prev)) {
   return false;
  }
  /*
		 * Abort if the tunnel would directly enter a vault without
		 * going through a designated square.  This matches Sil 1.3
		 * but does not prevent a tunnel from entering a vault through
		 * quartz or rubble on the boundary.  Converting the test on
		 * second grid to (!square_iswall_outer() && square_is_room))
		 * would do that.
		 */
  if (square_iswall_solid(c, prev) &&
   (square_ispassable(c, grid) || square_iswall_inner(c, grid))) {
   return false;
  }
  if (square_iswall_solid(c, grid) &&
   (square_ispassable(c, prev) || square_iswall_inner(c, prev))) {
   return false;
  }
 }
 /* Reject if we were checking changes and failed, otherwise accept */
 if (tentative && (changes != desired_changes)) {
  return false;
 } else {
  return true;
 }
}
/**
 * Lay the tunnel grids of a straight tunnel between two rooms
 *
 * \return the number of walls converted to floors or doors.
 */
static int lay_tunnel(struct chunk *c, struct loc grid1, struct loc grid2,
        int r1, int r2)
{
        int ncnvt = 0;
 int x, y;
 struct loc grid_lo, grid_hi;
 bool vert = true;
 /* Get the direction */
 if (grid1.y == grid2.y) {
  /* Horizontal */
  vert = false;
  if (grid1.x < grid2.x) {
   grid_lo = grid1;
   grid_hi = grid2;
  } else {
   grid_lo = grid2;
   grid_hi = grid1;
  }
 } else {
  /* Vertical */
  if (grid1.y < grid2.y) {
   grid_lo = grid1;
   grid_hi = grid2;
  } else {
   grid_lo = grid2;
   grid_hi = grid1;
  }
 }
 /* Set floors and doors */
 for (x = grid_lo.x, y = grid_lo.y; x <= grid_hi.x && y <= grid_hi.y;
   vert ? y++ : x++) {
  struct loc grid = loc(x, y);
  if (square_iswall_outer(c, grid)) {
   /* All doors get randomised later */
   square_set_feat(c, grid, FEAT_CLOSED);
   ++ncnvt;
  } else if (square_iswall_solid(c, grid)) {
   square_set_feat(c, grid, FEAT_FLOOR);
   dun->tunn1[y][x] = r1;
   dun->tunn2[y][x] = r2;
   ++ncnvt;
  }
 }
 return ncnvt;
}
/**
 * Build a tunnel between two grids in nominated rooms
 *
 * Build horizontally or vertically if possible, otherwise build an L-shaped
 * tunnel, randomly horizontal or vertical first
 */
static bool build_tunnel(struct chunk *c, int r1, int r2, struct loc grid1,
  struct loc grid2, bool tentative, enum tunnel_type t)
{
 struct loc grid_mid;
 tunnel_direction_type dir;
 int nver, nhor;
 /* Horizontal or vertical */
 if ((grid1.y == grid2.y) || (grid1.x == grid2.x)) {
  /*
		 * Check validity (room to corridor tunnels have already been
		 * checked), tunnel and we're done
		 */
  if (t == TUNNEL_ROOM_TO_CORRIDOR
    || tunnel_ok(c, grid1, grid2, tentative, 2)) {
   nver = lay_tunnel(c, grid1, grid2, r1, r2);
   nhor = 0;
   if (grid1.y == grid2.y) {
    int tmp = nver;
    nver = nhor;
    nhor = tmp;
    dir = TUNNEL_HOR;
   } else {
    dir = TUNNEL_VER;
   }
   event_signal_tunnel(EVENT_GEN_TUNNEL_FINISHED, t, dir,
    nver, nhor);
   return true;
  } else {
   return false;
  }
 } else if (one_in_(2)) {
  /* Horizontal, then vertical */
  grid_mid = loc(grid2.x, grid1.y);
  dir = TUNNEL_BENT;
 } else {
  /* Vertical, then horizontal */
  grid_mid = loc(grid1.x, grid2.y);
  dir = TUNNEL_BENT;
 }
 /* Check validity */
 if (!tunnel_ok(c, grid1, grid_mid, tentative, 1)) return false;
 if (!tunnel_ok(c, grid_mid, grid2, tentative, 1)) return false;
 /* Lay tunnel */
 nver = lay_tunnel(c, grid1, grid_mid, r1, r2);
 nhor = lay_tunnel(c, grid_mid, grid2, r1, r2);
 if (grid_mid.y == grid1.y) {
  int tmp = nver;
  nver = nhor;
  nhor = tmp;
 }
 event_signal_tunnel(EVENT_GEN_TUNNEL_FINISHED, t, dir, nver, nhor);
 return true;
}
static bool connect_two_rooms(struct chunk *c, int r1, int r2, bool tentative,
         bool desperate)
{
 struct loc cent1 = dun->cent[r1];
 struct loc cent2 = dun->cent[r2];
 struct loc top_left1 = dun->corner[r1].top_left;
 struct loc top_left2 = dun->corner[r2].top_left;
 struct loc bottom_right1 = dun->corner[r1].bottom_right;
 struct loc bottom_right2 = dun->corner[r2].bottom_right;
 bool success;
 int distance_limitx = desperate ? 22 : 15;
 int distance_limity = desperate ? 16 : 10;
 /* If the rooms are too far apart, then just give up immediately */
 /* Look at total distance of room centres */
 if ((ABS(cent1.y - cent2.y) > distance_limity * 3) ||
  (ABS(cent1.x - cent2.x) > distance_limitx * 3)) {
  return false;
 }
 /* Then look at distance of relevant room edges */
 if ((cent1.x < cent2.x) &&
  (top_left2.x - bottom_right1.x > distance_limitx)) {
  return false;
 }
 if ((cent2.x < cent1.x) &&
  (top_left1.x - bottom_right2.x > distance_limitx)) {
  return false;
 }
 if ((cent1.y < cent2.y) &&
  (top_left2.y - bottom_right1.y > distance_limity)) {
  return false;
 }
 if ((cent2.y < cent1.y) &&
  (top_left1.y - bottom_right2.y > distance_limity)) {
  return false;
 }
 /* If we have vertical or horizontal overlap, connect a straight tunnel
	 * at a random point where they overlap */
 if ((top_left1.x <= bottom_right2.x) && (top_left2.x <= bottom_right1.x)) {
  /* If horizontal overlap */
  int x = rand_range(MAX(top_left1.x, top_left2.x),
         MIN(bottom_right1.x, bottom_right2.x));
  struct loc grid1 = loc(x, cent1.y);
  struct loc grid2 = loc(x, cent2.y);
  /* Unless careful, there will be too many vertical tunnels
		 * since rooms are wider than they are tall */
  if (tentative && one_in_(2)) {
   return false;
  }
  success = build_tunnel(c, r1, r2, grid1, grid2, tentative,
   (desperate) ? TUNNEL_DESPERATE : TUNNEL_ROOM_TO_ROOM);
 } else if ((top_left1.y <= bottom_right2.y) &&
      (top_left2.y <= bottom_right1.y)) {
  /* If vertical overlap */
  int y = rand_range(MAX(top_left1.y, top_left2.y),
         MIN(bottom_right1.y, bottom_right2.y));
  struct loc grid1 = loc(cent1.x, y);
  struct loc grid2 = loc(cent2.x, y);
  success = build_tunnel(c, r1, r2, grid1, grid2, tentative,
   (desperate) ? TUNNEL_DESPERATE : TUNNEL_ROOM_TO_ROOM);
 } else {
  /* Otherwise, make an L shaped corridor between their centres;
		 * this must fail if any of the tunnels would be too long */
  if (MIN(ABS(cent2.x - top_left1.x), ABS(cent2.x - bottom_right1.x))
   > distance_limitx - 2) {
   return false;
  }
  if (MIN(ABS(cent1.x - top_left2.x), ABS(cent1.x - bottom_right2.x))
   > distance_limitx - 2) {
   return false;
  }
  if (MIN(ABS(cent2.y - top_left1.y), ABS(cent2.y - bottom_right1.y))
   > distance_limity - 2) {
   return false;
  }
  if (MIN(ABS(cent1.y - top_left2.y), ABS(cent1.y - bottom_right2.y))
   > distance_limity - 2) {
   return false;
  }
  success = build_tunnel(c, r1, r2, cent1, cent2, tentative,
   (desperate) ? TUNNEL_DESPERATE : TUNNEL_ROOM_TO_ROOM);
 }
 if (success) {
  dun->connection[r1][r2] = true;
  dun->connection[r2][r1] = true;
 }
 return success;
}
static bool connect_room_to_corridor(struct chunk *c, int r)
{
 int length = 10;
 struct loc grid, cent = dun->cent[r];
 int r1, r2;
 bool success = false;
 bool done = false;
 /* Go down/right half the time, up/left the other half */
 int delta = one_in_(2) ? 1 : -1;
 /* Go horizontal half the time, vertical the other half */
 bool vert = one_in_(2);
 /* Start at the centre and look for a tunnel */
 grid = cent;
 while (!done) {
  if (vert) {
   grid.y += delta;
  } else {
   grid.x += delta;
  }
  /* Abort if the tunnel leaves the map or passes through a door */
  if (!square_in_bounds(c, grid) || (ABS(grid.x - cent.x) > length)
   || (ABS(grid.y - cent.y) > length)
   || square_iscloseddoor(c, grid)) {
   success = false;
   done = true;
  } else if (square_isfloor(c, grid) && !square_isroom(c, grid)) {
   /* It has intercepted a tunnel! */
   r1 = dun->tunn1[grid.y][grid.x];
   r2 = dun->tunn2[grid.y][grid.x];
   /* Make sure that the tunnel intercepts only connects rooms
			 * that aren't connected to this room */
   if ((r1 < 0) || (r2 < 0) ||
    (!(dun->connection[r][r1]) && !(dun->connection[r][r2]))) {
    struct loc grid1 = vert ? loc(grid.x, cent.y)
     : loc(cent.x, grid.y);
    struct loc grid2 = vert ? loc(grid.x, grid.y - (delta * 2))
     : loc(grid.x - (delta * 2), grid.y);
    if (tunnel_ok(c, grid1, grid2, true, 1)) {
     (void) build_tunnel(c, r, r1, grid1,
      grid, false,
      TUNNEL_ROOM_TO_CORRIDOR);
     /* Mark the new room connections */
     dun->connection[r][r1] = true;
     dun->connection[r1][r] = true;
     dun->connection[r][r2] = true;
     dun->connection[r2][r] = true;
     success = true;
    }
   }
   done = true;
  }
 }
 return success;
}
static bool connect_rooms_stairs(struct chunk *c)
{
 int i;
 int corridor_attempts = dun->cent_n * dun->cent_n * 10;
 int r1, r2;
 int pieces = 0;
    int width;
 int stairs = 0;
 /* Phase 1:
	 * Connect each room to the closest room (if not already connected) */
 for (r1 = 0; r1 < dun->cent_n; r1++) {
  int r_closest = 0;
  int d_closest = 1000;
  /* Find closest room */
  for (r2 = 0; r2 < dun->cent_n; r2++) {
   if (r2 != r1) {
    int d = distance(dun->cent[r1], dun->cent[r2]);
    if (d < d_closest) {
     d_closest = d;
     r_closest = r2;
    }
   }
  }
  /* Connect the rooms, if not already connected */
  if (!(dun->connection[r1][r_closest])) {
   (void) connect_two_rooms(c, r1, r_closest, true, false);
  }
 }
 /* Phase 2: */
 /* Make some random connections between rooms so long as they don't
	 * intersect things */
 for (i = 0; i < corridor_attempts; i++) {
  r1 = randint0(dun->cent_n);
  r2 = randint0(dun->cent_n);
  if ((r1 != r2) && !(dun->connection[r1][r2])) {
   (void) connect_two_rooms(c, r1, r2, true, false);
  }
 }
 /* Add some T-intersections in the corridors */
 for (i = 0; i < corridor_attempts; i++) {
  r1 = randint0(dun->cent_n);
  (void) connect_room_to_corridor(c, r1);
 }
 /* Phase 3: */
 /* Cut the dungeon up into connected pieces and try hard to make
	 * corridors that connect them */
 pieces = dungeon_pieces();
 while (pieces > 1) {
  bool joined = false;
  for (r1 = 0; r1 < dun->cent_n; r1++) {
   for (r2 = 0; r2 < dun->cent_n; r2++) {
    if (!joined && (dun->piece[r1] != dun->piece[r2])) {
     for (i = 0; i < 10; i++) {
      if (!(dun->connection[r1][r2])) {
       joined = connect_two_rooms(c, r1, r2, true, true);
      }
     }
    }
   }
  }
  /* This is terrible, and needs fixing - NRM */
  if (!joined) {
   break;
  }
  /* Cut the dungeon up into connected pieces and count them */
  pieces = dungeon_pieces();
 }
 /* Place down stairs */
    width = c->width / z_info->block_wid;
 if (width <= 3) {
  stairs = 1;
    } else if (width == 4) {
  stairs = 2;
    } else {
  stairs = 4;
    }
 if ((player->upkeep->create_stair == FEAT_MORE) ||
  (player->upkeep->create_stair == FEAT_MORE_SHAFT)) {
  stairs--;
 }
 alloc_stairs(c, FEAT_MORE, stairs);
 /* Place up stairs */
    width = c->width / z_info->block_wid;
 if (width <= 3) {
  stairs = 1;
    } else if (width == 4) {
  stairs = 2;
    } else {
  stairs = 4;
    }
    if ((player->upkeep->create_stair == FEAT_LESS) ||
  (player->upkeep->create_stair == FEAT_LESS_SHAFT))
  stairs--;
 alloc_stairs(c, FEAT_LESS, stairs);
 /* Add some quartz streamers */
 for (i = 0; i < dun->profile->str.qua; i++) {
  /* If we can't build streamers, something is wrong with level */
  if (!build_streamer(c, FEAT_QUARTZ)) return false;
 }
    /* Add any chasms if needed */
    build_chasms(c);
 return true;
}
/* ------------------ LEVEL GENERATORS ---------------- */
/**
 * Generate a new dungeon level
 */
struct chunk *cave_gen(struct player *p)
{
 int i, y, x;
 int blocks;
 int room_attempts;
 struct chunk *c;
 /* Hack - variables for allocations */
 int rubble_gen, mon_gen, obj_room_gen;
 /* Sil - determine the dungeon size
	 * note: Block height and width is 1/6 of max height/width */
 /* Between 3 x 3 and 5 x 5 */
 blocks = 3 + ((p->depth + randint1(5)) / 10);
 c = cave_new(blocks * z_info->block_hgt, blocks * z_info->block_wid);
 room_attempts = blocks * blocks * blocks * blocks;
 c->depth = p->depth;
 /* Fill cave area with basic granite */
 fill_rectangle(c, 0, 0, c->height - 1, c->width - 1, FEAT_GRANITE,
       SQUARE_WALL_SOLID);
 /* Initialize the room tunnel arrays */
 for (y = 0; y < c->height; y++) {
  for (x = 0; x < c->width; x++) {
   dun->tunn1[y][x] = -1;
   dun->tunn2[y][x] = -1;
  }
 }
 /* Guarantee a forge if one hasn't been generated in a while */
 if (p->forge_drought >= rand_range(2000, 5000)) {
  struct room_profile profile = lookup_room_profile("Interesting room");
  if (OPT(p, cheat_room)) msg("Trying to force a forge:");
  p->upkeep->force_forge = true;
  /* Failure (not clear why this would happen) */
  if (!room_build(c, profile)) {
   p->upkeep->force_forge = false;
   if (OPT(p, cheat_room)) msg("failed.");
   uncreate_artifacts(c);
   uncreate_greater_vaults(c, p);
   wipe_mon_list(c, p);
   cave_free(c);
   return NULL;
  }
  if (OPT(p, cheat_room)) msg("succeeded.");
  p->upkeep->force_forge = false;
 }
 /* Build some rooms */
 for (i = 0; i < room_attempts; i++) {
  int j;
  struct room_profile profile = dun->profile->room_profiles[0];
  int hardness = randint1(c->depth + 5);
        if (one_in_(5)) hardness += randint1(5);
  /* Once we have a hardness, we iterate through out list of room profiles
		 * looking for a match (whose hardness >= this hardness, or which meets
		 * depth or random conditions). We then try building this room. */
  for (j = 0; j < dun->profile->n_room_profiles; j++) {
   profile = dun->profile->room_profiles[j];
   if ((profile.hardness > hardness) || !profile.hardness) break;
   if (profile.level && (profile.level == c->depth)) break;
   if (profile.random && one_in_(profile.random)) break;
  }
  /* Try again if failed */
  if (!profile.builder) continue;
  /* Build it */
  room_build(c, profile);
  /* Stop if there are too many rooms */
  if (dun->cent_n == z_info->level_room_max - 1) break;
 }
 /* Generate permanent walls around the edge of the generated area */
 draw_rectangle(c, 0, 0, c->height - 1, c->width - 1, FEAT_PERM, SQUARE_NONE,
       true);
 /* Start over on levels with less than two rooms due to inevitable crash */
 if (dun->cent_n < z_info->level_room_min) {
  if (OPT(p, cheat_room)) msg("Not enough rooms.");
  uncreate_artifacts(c);
  uncreate_greater_vaults(c, p);
  wipe_mon_list(c, p);
  cave_free(c);
  return NULL;
 }
 /* Make the tunnels
	 * Sil - This has been changed considerably */
 if (!connect_rooms_stairs(c)) {
  if (OPT(p, cheat_room)) msg("Couldn't connect the rooms.");
  uncreate_artifacts(c);
  uncreate_greater_vaults(c, p);
  wipe_mon_list(c, p);
  cave_free(c);
  return NULL;
 }
 /* Randomise the doors (except those in vaults) */
 for (y = 0; y < c->height; y++) {
  for (x = 0; x < c->width; x++) {
   struct loc grid = loc(x, y);
   if (square_iscloseddoor(c, grid) && !square_isvault(c, grid)) {
    if (one_in_(4)) {
     square_set_feat(c, grid, FEAT_FLOOR);
    } else {
     place_random_door(c, grid);
    }
   }
  }
 }
 /* Place some rubble, occasionally much more on deep levels */
 rubble_gen = randint1((blocks * blocks) / 3);
 if ((c->depth >= 10) && one_in_(10)) {
  rubble_gen += blocks * blocks * 2;
 }
 alloc_object(c, SET_BOTH, TYP_RUBBLE, rubble_gen, c->depth,
  ORIGIN_FLOOR);
 /* Place the player */
 new_player_spot(c, p);
 /* Check dungeon connectivity */
 if (!check_connectivity(c)) {
  if (OPT(p, cheat_room)) msg("Failed connectivity.");
  uncreate_artifacts(c);
  uncreate_greater_vaults(c, p);
  wipe_mon_list(c, p);
  cave_free(c);
  return NULL;
 }
 if (c->depth == 1) {
  /* Smaller number of monsters at 50ft */
  mon_gen = dun->cent_n / 2;
 } else {
  /* Pick some number of monsters (between 0.5 per room and 1 per room) */
  mon_gen = (dun->cent_n + randint1(dun->cent_n)) / 2;
 }
 /* Put some objects in rooms */
 obj_room_gen = 3 * mon_gen / 4;
 if (obj_room_gen > 0) {
  alloc_object(c, SET_ROOM, TYP_OBJECT, obj_room_gen, c->depth,
   ORIGIN_FLOOR);
 }
    /* Place the traps */
    place_traps(c);
 /* Put some monsters in the dungeon */
 for (i = mon_gen; i > 0; i--) {
  (void) pick_and_place_distant_monster(c, p, true, c->depth);
 }
 /* Place Morgoth if on the run */
 if (p->on_the_run && !p->morgoth_slain) {
  /* Place Morgoth */
  struct loc grid;
  int count = 100;
  /* Find a suitable place */
  while (cave_find(c, &grid, square_suits_start) && count--) {
   /* Out of sight of the player */
   if (!los(c, p->grid, grid)) {
    struct monster_group_info info = {0, 0};
    place_new_monster_one(c, grid, lookup_monster("Morgoth"), true,
           true, info, ORIGIN_DROP);
    break;
   }
  }
 }
 /* Add a curved sword near the player if this is the start of the game */
 if (p->turn == 0) {
  place_item_near_player(c, p, TV_SWORD, "Curved Sword");
 }
 return c;
}
/**
 * Create the level containing Morgoth's throne room
 */
struct chunk *throne_gen(struct player *p)
{
 int y, x;
 struct chunk *c;
 struct room_profile profile = lookup_room_profile("Throne room");
 struct loc pgrid = loc(0, 0);
 /* Display the throne poetry */
 event_signal_poem(EVENT_POEM, "throne_poetry", 5, 15);
 /* Set the 'truce' in action */
 p->truce = true;
 /* Restrict to single-screen size */
 c = cave_new(3 * z_info->block_hgt, 3 * z_info->block_wid);
 c->depth = p->depth;
 /* Fill cave area with basic granite */
 fill_rectangle(c, 0, 0, c->height - 1, c->width - 1, FEAT_GRANITE,
       SQUARE_WALL_SOLID);
 /* Generate permanent walls around the edge of the generated area */
 draw_rectangle(c, 0, 0, c->height - 1, c->width - 1, FEAT_PERM, SQUARE_NONE,
       true);
 /* Build it */
 room_build(c, profile);
 /* Find an up staircase */
 for (y = 0; y < c->height; y++) {
  for (x = 0; x < c->width; x++) {
   struct loc grid = loc(x, y);
   /* Assumes the important staircase is at the centre of the level */
   if (square_isupstairs(c, grid) && (x >= 40) && (x <= 55)) {
    pgrid = grid;
    break;
   }
  }
  if (!loc_eq(pgrid, loc(0, 0))) break;
 }
 if (loc_eq(pgrid, loc(0, 0))) {
  msg("Failed to find an up staircase in the throne-room");
 }
 /* Delete any monster on the starting square */
 delete_monster(c, pgrid);
 /* Place the player */
 player_place(c, p, pgrid);
 return c;
}
/**
 * Create the gates to Angband level
 */
struct chunk *gates_gen(struct player *p)
{
 int y, x;
 struct chunk *c;
 struct room_profile profile = lookup_room_profile("Gates of Angband");
 const struct vault *gates_room =
  random_vault(p->depth, "Gates of Angband", false);
 struct loc pgrid = loc(0, 0);
 /* Make it just big enough for the room and permanent boundary. */
 c = cave_new(2 + gates_room->hgt, 2 + gates_room->wid);
 c->depth = p->depth;
 /* Fill cave area with basic granite */
 fill_rectangle(c, 0, 0, c->height - 1, c->width - 1, FEAT_GRANITE,
       SQUARE_WALL_SOLID);
 /* Generate permanent walls around the edge of the generated area */
 draw_rectangle(c, 0, 0, c->height - 1, c->width - 1, FEAT_PERM, SQUARE_NONE,
       true);
 /* Remove the bottom wall */
 for (x = 1; x < c->width - 1; x++) {
  square_set_feat(c, loc(x, c->height - 1), FEAT_FLOOR);
 }
 /* Build it */
 room_build(c, profile);
 /* Find a down staircase */
 for (y = 0; y < c->height; y++) {
  for (x = 0; x < c->width; x++) {
   struct loc grid = loc(x, y);
   /* Assumes the important staircase is at the centre of the level */
   if (square_isdownstairs(c, grid)) {
    pgrid = grid;
    break;
   }
  }
  if (!loc_eq(pgrid, loc(0, 0))) break;
 }
 if (loc_eq(pgrid, loc(0, 0))) {
  msg("Failed to find a down staircase in the gates level");
 }
 /* Delete any monster on the starting square */
 delete_monster(c, pgrid);
 /* Place the player */
 player_place(c, p, pgrid);
 return c;
}
/**
 * \file gen-room.c
 * \brief Dungeon room generation.
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 * Copyright (c) 2013 Erik Osheim, Nick McConnell
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 *
 * This file covers everything to do with generation of individual rooms in
 * the dungeon.  It consists of room generating helper functions plus the 
 * actual room builders (which are referred to in the room profiles in
 * generate.c).
 *
 * The room builders all take as arguments the chunk they are being generated
 * in, and the co-ordinates of the room centre in that chunk.  Each room
 * builder is also able to find space for itself in the chunk using the 
 * find_space() function; the chunk generating functions can ask it to do that
 * by passing too large centre co-ordinates.
 */
/**
 * ------------------------------------------------------------------------
 * Selection of random templates
 * ------------------------------------------------------------------------ */
/**
 * Chooses a vault of a particular kind at random.
 * \param depth the current depth, for vault bound checking
 * \param typ vault type
 * \return a pointer to the vault template
 */
struct vault *random_vault(int depth, const char *typ, bool forge)
{
 struct vault *v = vaults;
 struct vault *r = NULL;
 uint32_t rarity_sum = 0;
 do {
  if (streq(v->typ, typ) && (v->depth <= depth)) {
   bool valid = v->rarity > 0;
   /* Check if we need a forge and don't have one */
   if (forge && !v->forge) {
    valid = false;
   }
   /* Check if it's a greater vault we've already seen */
   if (streq(v->typ, "Greater vault") && player->vaults[v->index]) {
    valid = false;
   }
   if (valid) {
    rarity_sum += v->rarity;
    if (Rand_div(rarity_sum) < v->rarity) r = v;
   }
  }
  v = v->next;
 } while(v);
 return r;
}
/**
 * ------------------------------------------------------------------------
 * Room build helper functions
 * ------------------------------------------------------------------------ */
/**
 * Test a rectangle to see if it is all rock (i.e. not floor and not vault)
 * \param c the current chunk
 * \param y1 inclusive room boundaries
 * \param x1 inclusive room boundaries
 * \param y2 inclusive room boundaries
 * \param x2 inclusive room boundaries
 */
static bool solid_rock(struct chunk *c, int y1, int x1, int y2, int x2)
{
 int y, x;
 for (y = y1; y <= y2; y++) {
  for (x = x1; x <= x2; x++) {
   if (square_isfloor(c, loc(x, y)) || square_isvault(c, loc(x, y))) {
    return false;
   }
  }
 }
 return true;
}
/**
 * Test around a rectangle to see if there would be a doubled wall
 *
 * eg:
 *       ######
 * #######....#
 * #....##....#
 * #....#######
 * ######
 * \param c the current chunk
 * \param y1 inclusive room boundaries
 * \param x1 inclusive room boundaries
 * \param y2 inclusive room boundaries
 * \param x2 inclusive room boundaries
 */
static bool doubled_wall(struct chunk *c, int y1, int x1, int y2, int x2)
{
 int y, x;
 /* Check top wall */
 for (x = x1; x < x2; x++) {
  if (square_iswall_outer(c, loc(x, y1 - 2)) &&
   square_iswall_outer(c, loc(x + 1, y1 - 2)))
   return true;
 }
 /* Check bottom wall */
 for (x = x1; x < x2; x++) {
  if (square_iswall_outer(c, loc(x, y2 + 2)) &&
   square_iswall_outer(c, loc(x + 1, y2 + 2)))
   return true;
 }
 /* Check left wall */
 for (y = y1; y < y2; y++) {
  if (square_iswall_outer(c, loc(x1 - 2, y)) &&
   square_iswall_outer(c, loc(x1 - 2, y + 1)))
   return true;
 }
 /* Check right wall */
 for (y = y1; y < y2; y++) {
  if (square_iswall_outer(c, loc(x2 + 2, y)) &&
   square_iswall_outer(c, loc(x2 + 2, y + 1)))
   return true;
 }
 return false;
}
/**
 * Mark squares as being in a room, and optionally light them.
 * \param c the current chunk
 * \param y1 inclusive room boundaries
 * \param x1 inclusive room boundaries
 * \param y2 inclusive room boundaries
 * \param x2 inclusive room boundaries
 * \param light whether or not to light the room
 */
static void generate_room(struct chunk *c, int y1, int x1, int y2, int x2,
        int light)
{
 struct loc grid;
 for (grid.y = y1; grid.y <= y2; grid.y++)
  for (grid.x = x1; grid.x <= x2; grid.x++) {
   sqinfo_on(square(c, grid)->info, SQUARE_ROOM);
   if (light)
    sqinfo_on(square(c, grid)->info, SQUARE_GLOW);
  }
}
/**
 * Mark a rectangle with a sqinfo flag
 * \param c the current chunk
 * \param y1 inclusive room boundaries
 * \param x1 inclusive room boundaries
 * \param y2 inclusive room boundaries
 * \param x2 inclusive room boundaries
 * \param flag the SQUARE_* flag we are marking with
 */
void generate_mark(struct chunk *c, int y1, int x1, int y2, int x2, int flag)
{
 struct loc grid;
 for (grid.y = y1; grid.y <= y2; grid.y++) {
  for (grid.x = x1; grid.x <= x2; grid.x++) {
   sqinfo_on(square(c, grid)->info, flag);
  }
 }
}
/**
 * Fill a rectangle with a feature.
 * \param c the current chunk
 * \param y1 inclusive room boundaries
 * \param x1 inclusive room boundaries
 * \param y2 inclusive room boundaries
 * \param x2 inclusive room boundaries
 * \param feat the terrain feature
 * \param flag the SQUARE_* flag we are marking with
 */
void fill_rectangle(struct chunk *c, int y1, int x1, int y2, int x2, int feat,
     int flag)
{
 int y, x;
 for (y = y1; y <= y2; y++)
  for (x = x1; x <= x2; x++)
   square_set_feat(c, loc(x, y), feat);
 if (flag) generate_mark(c, y1, x1, y2, x2, flag);
}
/**
 * Fill the edges of a rectangle with a feature.
 * \param c the current chunk
 * \param y1 inclusive room boundaries
 * \param x1 inclusive room boundaries
 * \param y2 inclusive room boundaries
 * \param x2 inclusive room boundaries
 * \param feat the terrain feature
 * \param flag the SQUARE_* flag we are marking with
 * permanent
 */
void draw_rectangle(struct chunk *c, int y1, int x1, int y2, int x2, int feat,
     int flag, bool overwrite_perm)
{
 int y, x;
 for (y = y1; y <= y2; y++) {
  if (overwrite_perm || !square_isperm(c, loc(x1, y))) {
   square_set_feat(c, loc(x1, y), feat);
  }
  if (overwrite_perm || !square_isperm(c, loc(x2, y))) {
   square_set_feat(c, loc(x2, y), feat);
  }
 }
 if (flag) {
  generate_mark(c, y1, x1, y2, x1, flag);
  generate_mark(c, y1, x2, y2, x2, flag);
 }
 for (x = x1; x <= x2; x++) {
  if (overwrite_perm || !square_isperm(c, loc(x, y1))) {
   square_set_feat(c, loc(x, y1), feat);
  }
  if (overwrite_perm || !square_isperm(c, loc(x, y2))) {
   square_set_feat(c, loc(x, y2), feat);
  }
 }
 if (flag) {
  generate_mark(c, y1, x1, y1, x2, flag);
  generate_mark(c, y2, x1, y2, x2, flag);
 }
}
/**
 * Fill the lines of a cross/plus with a feature.
 *
 * \param c the current chunk
 * \param y1 inclusive room boundaries
 * \param x1 inclusive room boundaries
 * \param y2 inclusive room boundaries
 * \param x2 inclusive room boundaries
 * \param feat the terrain feature
 * \param flag the SQUARE_* flag we are marking with
 * When combined with draw_rectangle() this will generate a large rectangular 
 * room which is split into four sub-rooms.
 */
static void generate_plus(struct chunk *c, int y1, int x1, int y2, int x2,
        int feat, int flag)
{
 int y, x;
 /* Find the center */
 int y0 = (y1 + y2) / 2;
 int x0 = (x1 + x2) / 2;
 assert(c);
 for (y = y1; y <= y2; y++) square_set_feat(c, loc(x0, y), feat);
 if (flag) generate_mark(c, y1, x0, y2, x0, flag);
 for (x = x1; x <= x2; x++) square_set_feat(c, loc(x, y0), feat);
 if (flag) generate_mark(c, y0, x1, y0, x2, flag);
}
/**
 * Place a square of granite with a flag
 * \param c the current chunk
 * \param y the square co-ordinates
 * \param x the square co-ordinates
 * \param flag the SQUARE_* flag we are marking with
 */
void set_marked_granite(struct chunk *c, struct loc grid, int flag)
{
 square_set_feat(c, grid, FEAT_GRANITE);
 if (flag) generate_mark(c, grid.y, grid.x, grid.y, grid.x, flag);
}
/**
 * Build a vault from its string representation.
 * \param c the chunk the room is being built in
 * \param centre the room centre; out of chunk centre invokes find_space()
 * \param v pointer to the vault template
 * \return success
 */
bool build_vault(struct chunk *c, struct loc centre, struct vault *v, bool flip)
{
 const char *data = v->text;
 int x, y;
 const char *t;
 bool flip_v = false;
 bool flip_h = false;
 assert(c);
 /* Check that the vault doesn't contain invalid things for its depth */
 for (t = data, y = 0; y < v->hgt; y++) {
  for (x = 0; x < v->wid; x++, t++) {
   /* Barrow wights can't be deeper than level 12 */
   if ((*t == 'W') && (c->depth > 12)) {
    return false;
   }
            /* Chasms can't occur at 950 ft */
   if ((*t == '7') && (c->depth >= z_info->dun_depth - 1)) {
    return false;
   }
  }
 }
    /* Reflections */
    if ((c->depth > 0) && (c->depth < z_info->dun_depth)) {
        /* Reflect it vertically half the time */
        if (one_in_(2)) flip_v = true;
  /* Reflect it horizontally half the time */
        if (one_in_(2)) flip_h = true;
    }
 /* Place dungeon features and objects */
 for (t = data, y = 0; y < v->hgt && *t; y++) {
  int ay = flip_v ? v->hgt - 1 - y : y;
  for (x = 0; x < v->wid && *t; x++, t++) {
   int ax = flip_h ? v->wid - 1 - x : x;
   struct loc grid;
   /* Extract the location, flipping diagonally if requested */
            if (flip) {
                grid.x = centre.x - (v->hgt / 2) + ay;
                grid.y = centre.y - (v->wid / 2) + ax;
            } else {
    grid.x = centre.x - (v->wid / 2) + ax;
    grid.y = centre.y - (v->hgt / 2) + ay;
   }
   /* Skip non-grids */
   if (*t == ' ') continue;
   /* Lay down a floor */
   square_set_feat(c, grid, FEAT_FLOOR);
   /* Debugging assertion */
   assert(square_isempty(c, grid));
   /* Part of a vault */
   sqinfo_on(square(c, grid)->info, SQUARE_ROOM);
   sqinfo_on(square(c, grid)->info, SQUARE_VAULT);
   /* Analyze the grid */
   switch (*t) {
    /* Outer outside granite wall */
   case '$': set_marked_granite(c, grid, SQUARE_WALL_OUTER); break;
    /* Inner or non-tunnelable outside granite wall */
   case '#': set_marked_granite(c, grid, SQUARE_WALL_INNER); break;
    /* Quartz vein */
   case '%': square_set_feat(c, grid, FEAT_QUARTZ); break;
    /* Rubble */
   case ':': square_set_feat(c, grid, FEAT_RUBBLE); break;
    /* Glyph of warding */
   case ';': square_add_glyph(c, grid, GLYPH_WARDING); break;
    /* Stairs */
   case '<': square_set_feat(c, grid, FEAT_LESS); break;
   case '>': square_set_feat(c, grid, FEAT_MORE); break;
    /* Visible door */
   case '+': place_closed_door(c, grid); break;
    /* Secret door */
   case 's': place_secret_door(c, grid); break;
    /* Trap */
   case '^': if (one_in_(2)) square_add_trap(c, grid); break;
    /* Forge */
   case '0': place_forge(c, grid); break;
    /* Chasm */
   case '7': square_set_feat(c, grid, FEAT_CHASM); break;
   }
  }
 }
 /* Place regular dungeon monsters and objects */
 for (t = data, y = 0; y < v->hgt && *t; y++) {
  int ay = flip_v ? v->hgt - 1 - y : y;
  for (x = 0; x < v->wid && *t; x++, t++) {
   int ax = flip_h ? v->wid - 1 - x : x;
   struct loc grid;
   struct monster_group_info info = { 0, 0 };
   /* Extract the location, flipping diagonally if requested */
            if (flip) {
                grid.x = centre.x - (v->hgt / 2) + ay;
                grid.y = centre.y - (v->wid / 2) + ax;
            } else {
    grid.x = centre.x - (v->wid / 2) + ax;
    grid.y = centre.y - (v->hgt / 2) + ay;
   }
   /* Hack -- skip "non-grids" */
   if (*t == ' ') continue;
   /* Analyze the symbol */
   switch (*t)
   {
    /* A monster from 1 level deeper */
    case '1': {
     pick_and_place_monster(c, grid, c->depth + 1, true, true,
              ORIGIN_DROP_VAULT);
     break;
    }
    /* A monster from 2 levels deeper */
    case '2': {
     pick_and_place_monster(c, grid, c->depth + 2, true, true,
              ORIGIN_DROP_VAULT);
     break;
    }
    /* A monster from 3 levels deeper */
    case '3': {
     pick_and_place_monster(c, grid, c->depth + 3, true, true,
              ORIGIN_DROP_VAULT);
     break;
    }
    /* A monster from 4 levels deeper */
    case '4': {
     pick_and_place_monster(c, grid, c->depth + 4, true, true,
              ORIGIN_DROP_VAULT);
     break;
    }
    /* An object from 1-4 levels deeper */
    case '*': {
     place_object(c, grid, c->depth + randint1(4), false, false,
         ORIGIN_VAULT, lookup_drop("not useless"));
     break;
    }
    /* A good object from 1-4 levels deeper */
    case '&': {
     place_object(c, grid, c->depth + randint1(4), true, false,
         ORIGIN_VAULT, lookup_drop("not useless"));
     break;
    }
    /* A chest from 4 levels deeper */
    case '~': {
     int depth = c->depth ? c->depth + 4 : z_info->dun_depth;
     place_object(c, grid, depth, false, false,
         ORIGIN_VAULT, lookup_drop("chest"));
     break;
    }
    /* A skeleton */
    case 'S': {
     /* Make a skeleton 1/2 of the time */
     if (one_in_(2)) {
      struct object *obj = object_new();
      int sval;
      struct object_kind *kind;
      if (one_in_(3)) {
       sval = lookup_sval(TV_USELESS, "Human Skeleton");
      } else {
       sval = lookup_sval(TV_USELESS, "Elf Skeleton");
      }
      kind = lookup_kind(TV_USELESS, sval);
      /* Prepare the item */
      object_prep(obj, kind, c->depth, RANDOMISE);
      /* Drop it in the dungeon */
      drop_near(c, &obj, 0, grid, false, false);
     }
     break;
    }
    /* Monster and/or object from 1 level deeper */
    case '?': {
     int r = randint1(3);
     if (r <= 2) {
      pick_and_place_monster(c, grid, c->depth + 1, true,
              true, ORIGIN_DROP_VAULT);
     }
     if (r >= 2) {
      place_object(c, grid, c->depth + 1, false, false,
          ORIGIN_VAULT, NULL);
     }
     break;
    }
    /* Carcharoth */
    case 'C': {
     place_new_monster_one(c, grid, lookup_monster("Carcharoth"),
            true, true, info,
            ORIGIN_DROP_VAULT);
     break;
    }
    /* silent watcher */
    case 'H': {
     place_new_monster_one(c, grid,
            lookup_monster("Silent watcher"),
            true, false, info,
            ORIGIN_DROP_VAULT);
     break;
    }
    /* easterling spy */
    case '@': {
     place_new_monster_one(c, grid,
            lookup_monster("Easterling spy"),
            true, false, info,
            ORIGIN_DROP_VAULT);
     break;
    }
    /* orc champion */
    case 'o': {
     place_new_monster_one(c, grid,
            lookup_monster("Orc champion"), true,
            false, info, ORIGIN_DROP_VAULT);
     break;
    }
    /* orc captain */
    case 'O': {
     place_new_monster_one(c, grid,
            lookup_monster("Orc captain"), true,
            false, info, ORIGIN_DROP_VAULT);
     break;
    }
    /* cat warrior */
    case 'f': {
     place_new_monster_one(c, grid,
            lookup_monster("Cat warrior"), true,
            false, info, ORIGIN_DROP_VAULT);
     break;
    }
    /* cat assassin */
    case 'F': {
     place_new_monster_one(c, grid,
            lookup_monster("Cat assassin"), true,
            false, info, ORIGIN_DROP_VAULT);
     break;
    }
    /* troll guard */
    case 'T': {
     place_new_monster_one(c, grid,
            lookup_monster("Troll guard"), true,
            false, info, ORIGIN_DROP_VAULT);
     break;
    }
    /* barrow wight */
    case 'W': {
     place_new_monster_one(c, grid,
            lookup_monster("Barrow wight"), true,
            false, info, ORIGIN_DROP_VAULT);
     break;
    }
    /* dragon */
    case 'd': {
     place_monster_by_flag(c, grid, RF_DRAGON, -1, true,
            c->depth + 4, false);
     break;
    }
    /* young cold drake */
    case 'y': {
     place_new_monster_one(c, grid,
            lookup_monster("Young cold-drake"),
            true, false, info,
            ORIGIN_DROP_VAULT);
     break;
    }
    /* young fire drake */
    case 'Y': {
     place_new_monster_one(c, grid,
           lookup_monster("Young fire-drake"),
           true, false, info, ORIGIN_DROP_VAULT);
     break;
    }
    /* Spider */
    case 'M': {
     place_monster_by_flag(c, grid, RF_SPIDER, -1, true,
            c->depth + rand_range(1, 4), false);
     break;
    }
    /* Vampire */
    case 'v': {
     place_monster_by_letter(c, grid, 'v', true,
           c->depth + rand_range(1, 4));
     break;
    }
                /* Archer */
    case 'a': {
     place_monster_by_flag(c, grid, RSF_ARROW1, RSF_ARROW2, true,
            c->depth + 1, true);
     break;
    }
                /* Flier */
    case 'b': {
     place_monster_by_flag(c, grid, RF_FLYING, -1, true,
            c->depth + 1, false);
     break;
    }
    /* Wolf */
    case 'c': {
     place_monster_by_flag(c, grid, RF_WOLF, -1, true,
            c->depth + rand_range(1, 4), false);
     break;
    }
    /* Rauko */
    case 'r': {
     place_monster_by_flag(c, grid, RF_RAUKO, -1, true,
            c->depth + rand_range(1, 4), false);
     break;
    }
                /* Aldor */
    case 'A': {
     place_new_monster_one(c, grid, lookup_monster("Aldor"),
            true, true, info,
            ORIGIN_DROP_VAULT);
     break;
    }
    /* Glaurung */
    case 'D': {
     place_new_monster_one(c, grid, lookup_monster("Glaurung"),
            true, true, info,
            ORIGIN_DROP_VAULT);
     break;
    }
    /* Gothmog */
    case 'R': {
     place_new_monster_one(c, grid, lookup_monster("Gothmog"),
            true, true, info,
            ORIGIN_DROP_VAULT);
     break;
    }
    /* Ungoliant */
    case 'U': {
     place_new_monster_one(c, grid, lookup_monster("Ungoliant"),
            true, true, info,
            ORIGIN_DROP_VAULT);
     break;
    }
    /* Gorthaur */
    case 'G': {
     place_new_monster_one(c, grid, lookup_monster("Gorthaur"),
            true, true, info,
            ORIGIN_DROP_VAULT);
     break;
    }
    /* Morgoth */
    case 'V': {
     place_new_monster_one(c, grid, lookup_monster("Morgoth, Lord of Darkness"),
            true, true, info,
            ORIGIN_DROP_VAULT);
     break;
    }
   }
  }
 }
 for (t = data, y = 0; y < v->hgt && *t; y++) {
  int ay = flip_v ? v->hgt - 1 - y : y;
  for (x = 0; x < v->wid && *t; x++, t++) {
   int ax = flip_h ? v->wid - 1 - x : x;
   struct loc grid;
   int mult;
   /* Extract the location, flipping diagonally if requested */
            if (flip) {
                grid.x = centre.x - (v->hgt / 2) + ay;
                grid.y = centre.y - (v->wid / 2) + ax;
            } else {
    grid.x = centre.x - (v->wid / 2) + ax;
    grid.y = centre.y - (v->hgt / 2) + ay;
   }
   /* Hack -- skip "non-grids" */
   if (*t == ' ') continue;
            /* Some vaults are always lit */
            if (roomf_has(v->flags, ROOMF_LIGHT)) {
                sqinfo_on(square(c, grid)->info, SQUARE_GLOW);
            }
            /* Traps are usually 5 times as likely in vaults,
			 * but are 10 times as likely if the TRAPS flag is set */
            mult = roomf_has(v->flags, ROOMF_TRAPS) ? 10 : 5;
            /* Another chance to place traps, with 4 times the normal chance
			 * so traps in interesting rooms and vaults are a total of 5 times
			 * more likely */
            if (randint1(1000) <= trap_placement_chance(c, grid) * (mult - 1)) {
                square_add_trap(c, grid);
            } else if (roomf_has(v->flags, ROOMF_WEBS) && one_in_(20)) {
    /* Webbed vaults also have a large chance of receiving webs */
                square_add_web(c, grid);
                /* Hide it half the time */
                if (one_in_(2)) {
     struct trap *trap = square_trap(c, grid);
                    trf_on(trap->flags, TRF_INVISIBLE);
                }
            }
        }
    }
 return true;
}
/**
 * Helper function for building vaults.
 * \param c the chunk the room is being built in
 * \param centre the room centre; out of chunk centre invokes find_space()
 * \param typ the vault type
 * \param forge whether we are forcing a forge
 * \return success
 */
static bool build_vault_type(struct chunk *c, struct loc centre,
        const char *typ, bool forge)
{
 bool flip_d;
 int y1, x1, y2, x2;
 struct vault *v = random_vault(c->depth, typ, forge);
 if (v == NULL) {
  return false;
 }
    /* Choose whether to rotate (flip diagonally) if allowed */
    flip_d = one_in_(3) && !roomf_has(v->flags, ROOMF_NO_ROTATION);
    if (flip_d) {
        /* Determine the coordinates with height/width flipped */
        y1 = centre.y - (v->wid / 2);
        x1 = centre.x - (v->hgt / 2);
        y2 = y1 + v->wid - 1;
        x2 = x1 + v->hgt - 1;
    } else {
        /* Determine the coordinates */
        y1 = centre.y - (v->hgt / 2);
        x1 = centre.x - (v->wid / 2);
        y2 = y1 + v->hgt - 1;
        x2 = x1 + v->wid - 1;
    }
 /* Make sure that the location is within the map bounds */
 if ((y1 <= 3) || (x1 <= 3) || (y2 >= c->height - 3) ||(x2 >= c->width - 3)){
  return false;
 }
 /* Make sure that the location is empty */
 if (!solid_rock(c, y1 - 2, x1 - 2, y2 + 2, x2 + 2)) {
  return false;
 }
 /* Build the vault */
 if (!build_vault(c, centre, v, flip_d)) {
  return false;
 }
 /* Save the corner locations */
 dun->corner[dun->cent_n].top_left = loc(x1 + 1, y1 + 1);
 dun->corner[dun->cent_n].bottom_right = loc(x2 - 1, y2 - 1);
 /* Save the room location */
 dun->cent[dun->cent_n] = centre;
 dun->cent_n++;
 ROOM_LOG("%s (%s)", typ, v->name);
 /* Memorise and mark greater vaults */
 if (streq(typ, "Greater vault")) {
  player->vaults[v->index] = true;
  generate_mark(c, y1, x1, y2, x2, SQUARE_G_VAULT);
  assert(!c->vault_name);
  c->vault_name = string_make(v->name);
 }
 return true;
}
/**
 * ------------------------------------------------------------------------
 * Room builders
 * ------------------------------------------------------------------------ */
/**
 * Builds a normal rectangular room.
 * \param c the chunk the room is being built in
 * \param centre the room centre
 * \return success
 */
bool build_simple(struct chunk *c, struct loc centre)
{
 int y, x, y1, x1, y2, x2;
 bool light = false;
 /* Occasional light - chance of darkness starts very small and
	 * increases quadratically until always dark at 950 ft */
 if ((c->depth < randint1(z_info->dun_depth - 1)) ||
  (c->depth < randint1(z_info->dun_depth - 1))) {
  light = true;
 }
 /* Pick a room size */
 y1 = centre.y - randint1(3);
 x1 = centre.x - randint1(5);
 y2 = centre.y + randint1(3);
 x2 = centre.x + randint1(4) + 1;
 /* Sil: bounds checking */
 if (y1 <= 3 || (x1 <= 3) || (y2 >= c->height - 3) || (x2 >= c->width - 3)) {
  return false;
 }
 /* Check to see if the location is all plain rock */
 if (!solid_rock(c, y1 - 1, x1 - 1, y2 + 1, x2 + 1)) {
  return false;
 }
 if (doubled_wall(c, y1, x1, y2, x2)) {
  return false;
 }
 /* Save the corner locations */
 dun->corner[dun->cent_n].top_left = loc(x1, y1);
 dun->corner[dun->cent_n].bottom_right = loc(x2, y2);
 /* Save the room location */
 dun->cent[dun->cent_n] = centre;
 dun->cent_n++;
 /* Generate new room */
 generate_room(c, y1 - 1, x1 - 1, y2 + 1, x2 + 1, light);
 /* Generate outer walls and inner floors */
 draw_rectangle(c, y1 - 1, x1 - 1, y2 + 1, x2 + 1, FEAT_GRANITE,
       SQUARE_WALL_OUTER, false);
 fill_rectangle(c, y1, x1, y2, x2, FEAT_FLOOR, SQUARE_NONE);
 /* Sometimes make a pillar room */
 if (one_in_(20) && ((x2 - x1) % 2 == 0) && ((y2 - y1) % 2 == 0)) {
  event_signal_string(EVENT_GEN_ROOM_CHOOSE_SUBTYPE, "pillared");
  for (y = y1 + 1; y <= y2; y += 2) {
   for (x = x1 + 1; x <= x2; x += 2) {
    set_marked_granite(c, loc(x, y), SQUARE_WALL_INNER);
   }
  }
 } else if (one_in_(10) && ((x2 - x1) % 2 == 0) && ((y2 - y1) % 2 == 0)) {
  /* Sometimes make a pillar-lined room */
  event_signal_string(EVENT_GEN_ROOM_CHOOSE_SUBTYPE, "ragged");
  for (y = y1 + 1; y <= y2; y += 2) {
   for (x = x1 + 1; x <= x2; x += 2) {
    if ((x == x1 + 1) || (x == x2 - 1) || (y == y1 + 1) ||
     (y == y2 - 1)) {
     set_marked_granite(c, loc(x, y), SQUARE_WALL_INNER);
    }
   }
  }
 }
 return true;
}
/**
 * Builds a cross-shaped room.
 * \param c the chunk the room is being built in
 * \param centre the room centre
 * \return success
 *
 * Room "v" runs north/south, and Room "h" runs east/west 
 */
bool build_crossed(struct chunk *c, struct loc centre)
{
 int y, x;
 int y1h, x1h, y2h, x2h;
 int y1v, x1v, y2v, x2v;
 int h_hgt, h_wid, v_hgt, v_wid;
 int light = false;
 /* Occasional light - always at level 1 down to never at Morgoth's level */
 if (c->depth <= randint1(z_info->dun_depth - 1)) light = true;
 /* Pick a room size */
 h_hgt = 1; /* 3 */
 h_wid = rand_range(5, 7); /* 11, 13, 15 */
 y1h = centre.y - h_hgt;
 x1h = centre.x - h_wid;
 y2h = centre.y + h_hgt;
 x2h = centre.x + h_wid;
 v_hgt = rand_range(3, 6); /* 7, 9, 11, 13 */
 v_wid = rand_range(1, 2); /* 3, 5 */
 y1v = centre.y - v_hgt;
 x1v = centre.x - v_wid;
 y2v = centre.y + v_hgt;
 x2v = centre.x + v_wid;
 /* Sil: bounds checking */
 if ((y1v <= 3) || (x1h <= 3) || (y2v >= c->height - 3) ||
  (x2h >= c->width - 3)) {
  return false;
 }
 /* Check to see if the location is all plain rock */
 if (!solid_rock(c, y1v - 1, x1h - 1, y2v + 1, x2h + 1)) {
  return false;
 }
 if (doubled_wall(c, y1v, x1h, y2v, x2h)) {
  return false;
 }
 /* Save the corner locations */
 dun->corner[dun->cent_n].top_left = loc(x1h, y1v);
 dun->corner[dun->cent_n].bottom_right = loc(x2h, y2v);
 /* Save the room location */
 dun->cent[dun->cent_n] = centre;
 dun->cent_n++;
 /* Generate new rooms */
 generate_room(c, y1h - 1, x1h - 1, y2h + 1, x2h + 1, light);
 generate_room(c, y1v - 1, x1v - 1, y2v + 1, x2v + 1, light);
 /* Generate outer walls */
 draw_rectangle(c, y1h - 1, x1h - 1, y2h + 1, x2h + 1,
       FEAT_GRANITE, SQUARE_WALL_OUTER, false);
 draw_rectangle(c, y1v - 1, x1v - 1, y2v + 1, x2v + 1,
       FEAT_GRANITE, SQUARE_WALL_OUTER, false);
 /* Generate inner floors */
 fill_rectangle(c, y1h, x1h, y2h, x2h, FEAT_FLOOR, SQUARE_NONE);
 fill_rectangle(c, y1v, x1v, y2v, x2v, FEAT_FLOOR, SQUARE_NONE);
 /* Special features */
 switch (randint1(7)) {
  case 1: {
   event_signal_string(EVENT_GEN_ROOM_CHOOSE_SUBTYPE, "chest");
   if ((v_wid == 2) && (v_hgt == 6)) {
    for (y = y1v + 1; y <= y2v; y += 2) {
     for (x = x1v + 1; x <= x2v; x += 2) {
      set_marked_granite(c, loc(x, y), SQUARE_WALL_INNER);
     }
    }
    place_object(c, centre, c->depth, false, false, ORIGIN_SPECIAL,
        lookup_drop("chest"));
   }
   break;
  }
  case 2: {
   if ((v_wid == 1) && (h_hgt == 1)) {
    event_signal_string(EVENT_GEN_ROOM_CHOOSE_SUBTYPE, "plus");
    generate_plus(c, centre.y - 1, centre.x - 1, centre.y + 1,
         centre.x + 1, FEAT_GRANITE, SQUARE_WALL_INNER);
   }
   break;
  }
  case 3: {
   if ((v_wid == 1) && (h_hgt == 1)) {
    event_signal_string(EVENT_GEN_ROOM_CHOOSE_SUBTYPE, "pinched");
    set_marked_granite(c, loc(centre.x - 1, centre.y - 1),
           SQUARE_WALL_INNER);
    set_marked_granite(c, loc(centre.x - 1, centre.y + 1),
           SQUARE_WALL_INNER);
    set_marked_granite(c, loc(centre.x + 1, centre.y - 1),
           SQUARE_WALL_INNER);
    set_marked_granite(c, loc(centre.x + 1, centre.y + 1),
           SQUARE_WALL_INNER);
   }
   break;
  }
  case 4: {
   if ((v_wid == 1) && (h_hgt == 1)) {
    event_signal_string(EVENT_GEN_ROOM_CHOOSE_SUBTYPE, "hollow plus");
    set_marked_granite(c, loc(centre.x - 1, centre.y),
           SQUARE_WALL_INNER);
    set_marked_granite(c, loc(centre.x + 1, centre.y),
           SQUARE_WALL_INNER);
    set_marked_granite(c, loc(centre.x, centre.y - 1),
           SQUARE_WALL_INNER);
    set_marked_granite(c, loc(centre.x, centre.y + 1),
           SQUARE_WALL_INNER);
   }
   break;
  }
  default: {
   break;
  }
 }
 return true;
}
/**
 * Build an interesting room.
 * \param c the chunk the room is being built in
 * \param centre the room centre
 * \return success
 */
bool build_interesting(struct chunk *c, struct loc centre)
{
 return build_vault_type(c, centre, "Interesting room",
       player->upkeep->force_forge);
}
/**
 * Build a lesser vault.
 * \param c the chunk the room is being built in
 * \param centre the room centre
 * \return success
 */
bool build_lesser_vault(struct chunk *c, struct loc centre)
{
 return build_vault_type(c, centre, "Lesser vault", false);
}
/**
 * Build a greater vault.
 * \param c the chunk the room is being built in
 * \param centre the room centre
 * \return success
 */
bool build_greater_vault(struct chunk *c, struct loc centre)
{
 /* Can only have one greater vault per level */
 if (c->vault_name) {
  return false;
 }
 return build_vault_type(c, centre, "Greater vault", false);
}
/**
 * Build Morgoth's throne room.
 * \param c the chunk the room is being built in
 * \param centre the room centre
 * \return success
 */
bool build_throne(struct chunk *c, struct loc centre)
{
 int y1, x1, y2, x2;
 struct vault *v = random_vault(c->depth, "Throne room", false);
 if (v == NULL) {
  return false;
 }
 /* Determine the coordinates */
 centre = loc(c->width / 2, c->height / 2);
 y1 = centre.y - (v->hgt / 2);
 x1 = centre.x - (v->wid / 2);
 y2 = y1 + v->hgt - 1;
 x2 = x1 + v->wid - 1;
 /* Build the vault */
 if (!build_vault(c, centre, v, false)) {
  return false;
 }
 /* Memorise and mark */
 generate_mark(c, y1, x1, y2, x2, SQUARE_G_VAULT);
 assert(!c->vault_name);
 c->vault_name = string_make(v->name);
 return true;
}
/**
 * Build the Gates of Angband.
 * \param c the chunk the room is being built in
 * \param centre the room centre
 * \return success
 */
bool build_gates(struct chunk *c, struct loc centre)
{
 int y1, x1, y2, x2;
 struct vault *v = random_vault(c->depth, "Gates of Angband", false);
 if (v == NULL) {
  return false;
 }
 /* Determine the coordinates */
 centre = loc(c->width / 2, c->height / 2);
 y1 = centre.y - (v->hgt / 2);
 x1 = centre.x - (v->wid / 2);
 y2 = y1 + v->hgt - 1;
 x2 = x1 + v->wid - 1;
 /* Build the vault */
 if (!build_vault(c, centre, v, false)) {
  return false;
 }
 /* Memorise and mark */
 generate_mark(c, y1, x1, y2, x2, SQUARE_G_VAULT);
 assert(!c->vault_name);
 c->vault_name = string_make(v->name);
 return true;
}
/**
 * Attempt to build a room of the given type at the given block
 *
 * \param c the chunk the room is being built in
 * \param by0 block co-ordinates of the top left block
 * \param bx0 block co-ordinates of the top left block
 * \param profile the profile of the rooom we're trying to build
 * \param finds_own_space whether we are allowing the room to place itself
 * \return success
 *
 * Note that this code assumes that profile height and width are the maximum
 * possible grid sizes, and then allocates a number of blocks that will always
 * contain them.
 *
 * Note that we restrict the number of pits/nests to reduce
 * the chance of overflowing the monster list during level creation.
 */
bool room_build(struct chunk *c, struct room_profile profile)
{
 struct loc centre = loc(rand_range(5, c->width - 5),
       rand_range(5, c->height - 5));
 if (dun->cent_n >= z_info->level_room_max) {
  return false;
 }
 event_signal_string(EVENT_GEN_ROOM_START, profile.name);
 /* Try to build a room */
 while (!profile.builder(c, centre)) {
  /* Keep trying if we're forcing a forge, but reset the centre
		 * This is a bit dangerous, and may need more modification - NRM */
  centre = loc(rand_range(5, c->width - 5), rand_range(5, c->height - 5));
  if (!player->upkeep->force_forge) {
   event_signal_flag(EVENT_GEN_ROOM_END, false);
   return false;
  }
 }
 /* Success */
 event_signal_flag(EVENT_GEN_ROOM_END, true);
 return true;
}
/**
 * \file gen-util.c
 * \brief Dungeon generation utilities
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 * Copyright (c) 2013 Erik Osheim, Nick McConnell
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 *
 * This file contains various utility functions for dungeon generation - mostly
 * for finding appropriate grids for some purposes, or placing things. 
 */
/**
 * Accept values for y and x (considered as the endpoints of lines) between
 * 0 and 40, and return an angle in degrees (divided by two).  -LM-
 *
 * This table's input and output need some processing:
 *
 * Because this table gives degrees for a whole circle, up to radius 20, its
 * origin is at (x,y) = (20, 20).  Therefore, the input code needs to find
 * the origin grid (where the lines being compared come from), and then map
 * it to table grid 20,20.  Do not, however, actually try to compare the
 * angle of a line that begins and ends at the origin with any other line -
 * it is impossible mathematically, and the table will return the value "255".
 *
 * The output of this table also needs to be massaged, in order to avoid the
 * discontinuity at 0/180 degrees.  This can be done by:
 *   rotate = 90 - first value
 *   this rotates the first input to the 90 degree line)
 *   tmp = ABS(second value + rotate) % 180
 *   diff = ABS(90 - tmp) = the angular difference (divided by two) between
 *   the first and second values.
 *
 * Note that grids diagonal to the origin have unique angles.
 */
uint8_t get_angle_to_grid[41][41] =
{
  { 68, 67, 66, 65, 64, 63, 62, 62, 60, 59, 58, 57, 56, 55, 53, 52, 51, 49, 48, 46, 45, 44, 42, 41, 39, 38, 37, 35, 34, 33, 32, 31, 30, 28, 28, 27, 26, 25, 24, 24, 23 },
  { 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 56, 55, 54, 52, 51, 49, 48, 47, 45, 43, 42, 41, 39, 38, 36, 35, 34, 32, 31, 30, 29, 28, 27, 26, 25, 24, 24, 23, 22 },
  { 69, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 58, 57, 56, 54, 53, 51, 50, 48, 47, 45, 43, 42, 40, 39, 37, 36, 34, 33, 32, 30, 29, 28, 27, 26, 25, 24, 24, 23, 22, 21 },
  { 70, 69, 69, 68, 67, 66, 65, 64, 63, 61, 60, 59, 58, 56, 55, 53, 52, 50, 48, 47, 45, 43, 42, 40, 38, 37, 35, 34, 32, 31, 30, 29, 27, 26, 25, 24, 24, 23, 22, 21, 20 },
  { 71, 70, 69, 69, 68, 67, 66, 65, 63, 62, 61, 60, 58, 57, 55, 54, 52, 50, 49, 47, 45, 43, 41, 40, 38, 36, 35, 33, 32, 30, 29, 28, 27, 25, 24, 24, 23, 22, 21, 20, 19 },
  { 72, 71, 70, 69, 69, 68, 67, 65, 64, 63, 62, 60, 59, 58, 56, 54, 52, 51, 49, 47, 45, 43, 41, 39, 38, 36, 34, 32, 31, 30, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18 },
  { 73, 72, 71, 70, 69, 69, 68, 66, 65, 64, 63, 61, 60, 58, 57, 55, 53, 51, 49, 47, 45, 43, 41, 39, 37, 35, 33, 32, 30, 29, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17 },
  { 73, 73, 72, 71, 70, 70, 69, 68, 66, 65, 64, 62, 61, 59, 57, 56, 54, 51, 49, 47, 45, 43, 41, 39, 36, 34, 33, 31, 29, 28, 26, 25, 24, 23, 21, 20, 20, 19, 18, 17, 17 },
  { 75, 74, 73, 72, 72, 71, 70, 69, 68, 66, 65, 63, 62, 60, 58, 56, 54, 52, 50, 47, 45, 43, 40, 38, 36, 34, 32, 30, 28, 27, 25, 24, 23, 21, 20, 19, 18, 18, 17, 16, 15 },
  { 76, 75, 74, 74, 73, 72, 71, 70, 69, 68, 66, 65, 63, 61, 59, 57, 55, 53, 50, 48, 45, 42, 40, 37, 35, 33, 31, 29, 27, 25, 24, 23, 21, 20, 19, 18, 17, 16, 16, 15, 14 },
  { 77, 76, 75, 75, 74, 73, 72, 71, 70, 69, 68, 66, 64, 62, 60, 58, 56, 53, 51, 48, 45, 42, 39, 37, 34, 32, 30, 28, 26, 24, 23, 21, 20, 19, 18, 17, 16, 15, 15, 14, 13 },
  { 78, 77, 77, 76, 75, 75, 74, 73, 72, 70, 69, 68, 66, 64, 62, 60, 57, 54, 51, 48, 45, 42, 39, 36, 33, 30, 28, 26, 24, 23, 21, 20, 18, 17, 16, 15, 15, 14, 13, 13, 12 },
  { 79, 79, 78, 77, 77, 76, 75, 74, 73, 72, 71, 69, 68, 66, 63, 61, 58, 55, 52, 49, 45, 41, 38, 35, 32, 29, 27, 24, 23, 21, 19, 18, 17, 16, 15, 14, 13, 13, 12, 11, 11 },
  { 80, 80, 79, 79, 78, 77, 77, 76, 75, 74, 73, 71, 69, 68, 65, 63, 60, 57, 53, 49, 45, 41, 37, 33, 30, 27, 25, 23, 21, 19, 17, 16, 15, 14, 13, 13, 12, 11, 11, 10, 10 },
  { 82, 81, 81, 80, 80, 79, 78, 78, 77, 76, 75, 73, 72, 70, 68, 65, 62, 58, 54, 50, 45, 40, 36, 32, 28, 25, 23, 20, 18, 17, 15, 14, 13, 12, 12, 11, 10, 10, 9, 9, 8 },
  { 83, 83, 82, 82, 81, 81, 80, 79, 79, 78, 77, 75, 74, 72, 70, 68, 64, 60, 56, 51, 45, 39, 34, 30, 26, 23, 20, 18, 16, 15, 13, 12, 11, 11, 10, 9, 9, 8, 8, 7, 7 },
  { 84, 84, 84, 83, 83, 83, 82, 81, 81, 80, 79, 78, 77, 75, 73, 71, 68, 63, 58, 52, 45, 38, 32, 27, 23, 19, 17, 15, 13, 12, 11, 10, 9, 9, 8, 7, 7, 7, 6, 6, 6 },
  { 86, 86, 85, 85, 85, 84, 84, 84, 83, 82, 82, 81, 80, 78, 77, 75, 72, 68, 62, 54, 45, 36, 28, 23, 18, 15, 13, 12, 10, 9, 8, 8, 7, 6, 6, 6, 5, 5, 5, 4, 4 },
  { 87, 87, 87, 87, 86, 86, 86, 86, 85, 85, 84, 84, 83, 82, 81, 79, 77, 73, 68, 58, 45, 32, 23, 17, 13, 11, 9, 8, 7, 6, 6, 5, 5, 4, 4, 4, 4, 3, 3, 3, 3 },
  { 89, 88, 88, 88, 88, 88, 88, 88, 88, 87, 87, 87, 86, 86, 85, 84, 83, 81, 77, 68, 45, 23, 13, 9, 7, 6, 5, 4, 4, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 1 },
  { 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { 91, 92, 92, 92, 92, 92, 92, 92, 92, 93, 93, 93, 94, 94, 95, 96, 97, 99, 103, 113, 135, 158, 167, 171, 173, 174, 175, 176, 176, 177, 177, 177, 178, 178, 178, 178, 178, 178, 178, 178, 179 },
  { 93, 93, 93, 93, 94, 94, 94, 94, 95, 95, 96, 96, 97, 98, 99, 101, 103, 107, 113, 122, 135, 148, 158, 163, 167, 169, 171, 172, 173, 174, 174, 175, 175, 176, 176, 176, 176, 177, 177, 177, 177 },
  { 94, 94, 95, 95, 95, 96, 96, 96, 97, 98, 98, 99, 100, 102, 103, 105, 108, 113, 118, 126, 135, 144, 152, 158, 162, 165, 167, 168, 170, 171, 172, 172, 173, 174, 174, 174, 175, 175, 175, 176, 176 },
  { 96, 96, 96, 97, 97, 97, 98, 99, 99, 100, 101, 102, 103, 105, 107, 109, 113, 117, 122, 128, 135, 142, 148, 153, 158, 161, 163, 165, 167, 168, 169, 170, 171, 171, 172, 173, 173, 173, 174, 174, 174 },
  { 97, 97, 98, 98, 99, 99, 100, 101, 101, 102, 103, 105, 106, 108, 110, 113, 116, 120, 124, 129, 135, 141, 146, 150, 154, 158, 160, 162, 164, 165, 167, 168, 169, 169, 170, 171, 171, 172, 172, 173, 173 },
  { 98, 99, 99, 100, 100, 101, 102, 102, 103, 104, 105, 107, 108, 110, 113, 115, 118, 122, 126, 130, 135, 140, 144, 148, 152, 155, 158, 160, 162, 163, 165, 166, 167, 168, 168, 169, 170, 170, 171, 171, 172 },
  { 100, 100, 101, 101, 102, 103, 103, 104, 105, 106, 107, 109, 111, 113, 115, 117, 120, 123, 127, 131, 135, 139, 143, 147, 150, 153, 155, 158, 159, 161, 163, 164, 165, 166, 167, 167, 168, 169, 169, 170, 170 },
  { 101, 101, 102, 103, 103, 104, 105, 106, 107, 108, 109, 111, 113, 114, 117, 119, 122, 125, 128, 131, 135, 139, 142, 145, 148, 151, 153, 156, 158, 159, 161, 162, 163, 164, 165, 166, 167, 167, 168, 169, 169 },
  { 102, 103, 103, 104, 105, 105, 106, 107, 108, 110, 111, 113, 114, 116, 118, 120, 123, 126, 129, 132, 135, 138, 141, 144, 147, 150, 152, 154, 156, 158, 159, 160, 162, 163, 164, 165, 165, 166, 167, 167, 168 },
  { 103, 104, 105, 105, 106, 107, 108, 109, 110, 111, 113, 114, 116, 118, 120, 122, 124, 127, 129, 132, 135, 138, 141, 143, 146, 148, 150, 152, 154, 156, 158, 159, 160, 161, 162, 163, 164, 165, 165, 166, 167 },
  { 104, 105, 106, 106, 107, 108, 109, 110, 111, 113, 114, 115, 117, 119, 121, 123, 125, 127, 130, 132, 135, 138, 140, 143, 145, 147, 149, 151, 153, 155, 156, 158, 159, 160, 161, 162, 163, 164, 164, 165, 166 },
  { 105, 106, 107, 108, 108, 109, 110, 111, 113, 114, 115, 117, 118, 120, 122, 124, 126, 128, 130, 133, 135, 137, 140, 142, 144, 146, 148, 150, 152, 153, 155, 156, 158, 159, 160, 161, 162, 162, 163, 164, 165 },
  { 107, 107, 108, 109, 110, 110, 111, 113, 114, 115, 116, 118, 119, 121, 123, 124, 126, 129, 131, 133, 135, 137, 139, 141, 144, 146, 147, 149, 151, 152, 154, 155, 156, 158, 159, 160, 160, 161, 162, 163, 163 },
  { 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 119, 120, 122, 123, 125, 127, 129, 131, 133, 135, 137, 139, 141, 143, 145, 147, 148, 150, 151, 153, 154, 155, 156, 158, 159, 159, 160, 161, 162, 163 },
  { 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 120, 121, 122, 124, 126, 128, 129, 131, 133, 135, 137, 139, 141, 142, 144, 146, 148, 149, 150, 152, 153, 154, 155, 157, 158, 159, 159, 160, 161, 162 },
  { 109, 110, 111, 112, 113, 114, 114, 115, 117, 118, 119, 120, 122, 123, 125, 126, 128, 130, 131, 133, 135, 137, 139, 140, 142, 144, 145, 147, 148, 150, 151, 152, 153, 155, 156, 157, 158, 159, 159, 160, 161 },
  { 110, 111, 112, 113, 114, 114, 115, 116, 117, 119, 120, 121, 122, 124, 125, 127, 128, 130, 132, 133, 135, 137, 138, 140, 142, 143, 145, 146, 148, 149, 150, 151, 153, 154, 155, 156, 157, 158, 159, 159, 160 },
  { 111, 112, 113, 114, 114, 115, 116, 117, 118, 119, 120, 122, 123, 124, 126, 127, 129, 130, 132, 133, 135, 137, 138, 140, 141, 143, 144, 146, 147, 148, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 159 },
  { 112, 113, 114, 114, 115, 116, 117, 118, 119, 120, 121, 122, 124, 125, 126, 128, 129, 131, 132, 133, 135, 137, 138, 139, 141, 142, 144, 145, 146, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159 },
  { 113, 114, 114, 115, 116, 117, 118, 118, 120, 121, 122, 123, 124, 125, 127, 128, 129, 131, 132, 134, 135, 136, 138, 139, 141, 142, 143, 145, 146, 147, 148, 149, 150, 152, 152, 153, 154, 155, 156, 157, 158 }
};
/**
 * Set up to locate a square in a rectangular region of a chunk.
 *
 * \param top_left is the upper left corner of the rectangle to be searched.
 * \param bottom_right is the lower right corner of the rectangle to be
 * searched.
 * \return the state for the search.  When no longer needed, the returned
 * value should be passed to mem_free().
 */
int *cave_find_init(struct loc top_left, struct loc bottom_right)
{
 struct loc diff = loc_diff(bottom_right, top_left);
 int n = (diff.y < 0 || diff.x < 0) ? 0 : (diff.x + 1) * (diff.y + 1);
 int *state = mem_alloc((5 + n) * sizeof(*state));
 int i;
 state[0] = n;
 state[1] = diff.x + 1;
 state[2] = top_left.x;
 state[3] = top_left.y;
 /* The next to search is the first one. */
 state[4] = 0;
 /*
	 * Set up for left to right, top to bottom, search; will randomize in
	 * cave_find_get_grid().
	 */
 for (i = 5; i < 5 + n; ++i) {
  state[i] = i - 5;
 }
 return state;
}
/**
 * Reset a search created by cave_find_init() to start again from fresh.
 *
 * \param state is the search state created by cave_find_init().
 */
void cave_find_reset(int *state)
{
 /* The next to search is the first one. */
 state[4] = 0;
}
/**
 * Get the next grid for a search created by cave_find_init().
 *
 * \param grid is dereferenced and set to the grid to check.
 * \param state is the search state created by cave_find_init().
 * \return true if grid was dereferenced and set to the next grid to be
 * searched; otherwise return false to indicate that there are no more grids
 * available.
 */
bool cave_find_get_grid(struct loc *grid, int *state)
{
 int j, k;
 assert(state[4] >= 0);
 if (state[4] >= state[0]) return false;
 /*
	 * Choose one of the remaining ones at random.  Swap it with the one
	 * that's next in order.
	 */
 j = randint0(state[0] - state[4]) + state[4];
 k = state[5 + j];
 state[5 + j] = state[5 + state[4]];
 state[5 + state[4]] = k;
 grid->y = (k / state[1]) + state[3];
 grid->x = (k % state[1]) + state[2];
 /*
	 * Increment so a future call to cave_find_get_grid() will get the
	 * next one.
	 */
 ++state[4];
 return true;
}
/**
 * Locate a square in a rectangle which satisfies the given predicate.
 *
 * \param c current chunk
 * \param grid found grid
 * \param top_left top left grid of rectangle
 * \param bottom_right bottom right grid of rectangle
 * \param pred square_predicate specifying what we're looking for
 * \return success
 */
bool cave_find_in_range(struct chunk *c, struct loc *grid,
  struct loc top_left, struct loc bottom_right,
  square_predicate pred)
{
 int *state = cave_find_init(top_left, bottom_right);
 bool found = false;
 while (!found && cave_find_get_grid(grid, state)) {
  found = pred(c, *grid);
 }
 mem_free(state);
 return found;
}
/**
 * Locate a square in the dungeon which satisfies the given predicate.
 * \param c current chunk
 * \param grid found grid
 * \param pred square_predicate specifying what we're looking for
 * \return success
 */
bool cave_find(struct chunk *c, struct loc *grid, square_predicate pred)
{
 struct loc top_left = loc(0, 0);
 struct loc bottom_right = loc(c->width - 1, c->height - 1);
 return cave_find_in_range(c, grid, top_left, bottom_right, pred);
}
/**
 * Locate an empty square for 0 <= y < ymax, 0 <= x < xmax.
 * \param c current chunk
 * \param grid found grid
 * \return success
 */
bool find_empty(struct chunk *c, struct loc *grid)
{
 return cave_find(c, grid, square_isempty);
}
/**
 * Locate an empty square in a given rectangle.
 * \param c current chunk
 * \param grid found grid
 * \param top_left top left grid of rectangle
 * \param bottom_right bottom right grid of rectangle
 * \return success
 */
bool find_empty_range(struct chunk *c, struct loc *grid, struct loc top_left,
 struct loc bottom_right)
{
 return cave_find_in_range(c, grid, top_left, bottom_right,
  square_isempty);
}
/**
 * Locate a grid within +/- yd, xd of a centre.
 * \param c current chunk
 * \param grid found grid
 * \param centre starting grid
 * \param yd y-range
 * \param xd x-range
 * \return success
 */
bool find_nearby_grid(struct chunk *c, struct loc *grid, struct loc centre,
 int yd, int xd)
{
 struct loc top_left = loc(centre.x - xd, centre.y - yd);
 struct loc bottom_right = loc(centre.x + xd, centre.y + yd);
 return cave_find_in_range(c, grid, top_left, bottom_right,
  square_in_bounds_fully);
}
/**
 * Place rubble at a given location, provided we are deep enough.
 * \param c current chunk
 * \param grid location
 */
static void place_rubble(struct chunk *c, struct loc grid)
{
 if (c->depth >= 4) {
  square_set_feat(c, grid, FEAT_RUBBLE);
 }
}
/**
 * Choose either an ordinary up staircase or an up shaft.
 */
static int choose_up_stairs(struct chunk *c)
{
 if (c->depth >= 2) {
  if (one_in_(2)) return FEAT_LESS_SHAFT;
 }
 return FEAT_LESS;
}
/**
 * Choose either an ordinary down staircase or an down shaft.
 */
static int choose_down_stairs(struct chunk *c)
{
 if (c->depth < z_info->dun_depth - 2) {
  if (one_in_(2)) return FEAT_MORE_SHAFT;
 }
 return FEAT_MORE;
}
/**
 * Place stairs (of the requested type 'feat' if allowed) at a given location.
 *
 * \param c current chunk
 * \param grid location
 * \param first is whether or not this is the first stair on the level.
 * \param feat stair terrain type
 *
 * All stairs from the surface go down. All stairs on the bottom level go up.
 */
static void place_stairs(struct chunk *c, struct loc grid, bool first, int feat)
{
 if (!c->depth) {
  /* Surface -- must go down */
  square_set_feat(c, grid, FEAT_MORE);
 } else if (c->depth >= z_info->dun_depth) {
  /* Bottom -- must go up */
  if (first) {
   square_set_feat(c, grid, FEAT_LESS);
  } else {
   square_set_feat(c, grid, choose_up_stairs(c));
  }
 } else {
  /* Allow shafts, but guarantee the first one is an ordinary stair */
  if (!first) {
   if (feat == FEAT_LESS) {
    feat = choose_up_stairs(c);
   } else if (feat == FEAT_MORE) {
    feat = choose_down_stairs(c);
   }
  }
  square_set_feat(c, grid, feat);
 }
}
/**
 * Generate the chosen item at a random spot near the player.
 */
void place_item_near_player(struct chunk *c, struct player *p, int tval,
       const char *name)
{
 struct loc grid;
 int count = 100;
 struct object *obj;
 struct object_kind *kind;
 /* Find a possible place */
 while (find_nearby_grid(c, &grid, p->grid, 5, 5) && count--) {
  /* Must be empty, in a room and in view of the player */
  if (square_isempty(c, grid) && square_isroom(c, grid) &&
   los(c, p->grid, grid)) {
   break;
  }
 }
 /* Get local object */
 obj = object_new();
 /* Get the object_kind */
 kind = lookup_kind(tval, lookup_sval(tval, name));
 /* Valid item? */
 if (!kind) return;
 /* Prepare the item */
 object_prep(obj, kind, c->depth, RANDOMISE);
 if (tval == TV_ARROW) {
  obj->number = 24;
 } else {
  obj->number = 1;
 }
 drop_near(c, &obj, 0, grid, false, false);
}
/**
 * Place a random object at a given location.
 * \param c current chunk
 * \param grid location
 * \param level generation depth
 * \param good is it a good object?
 * \param great is it a great object?
 * \param origin item origin
 * \param drop constrains the type of object created or may be NULL to no
 * constraint on the object type
 */
void place_object(struct chunk *c, struct loc grid, int level, bool good,
  bool great, uint8_t origin, struct drop *drop)
{
 struct object *new_obj;
 bool dummy = true;
 if (!square_in_bounds(c, grid)) return;
 if (!square_canputitem(c, grid)) return;
 /* Make an appropriate object */
 new_obj = make_object(c, level, good, great, drop);
 if (!new_obj) return;
 new_obj->origin = origin;
 new_obj->origin_depth = convert_depth_to_origin(c->depth);
 /* Give it to the floor */
 if (!floor_carry(c, grid, new_obj, &dummy)) {
  if (new_obj->artifact) {
   mark_artifact_created(new_obj->artifact, false);
  }
  object_delete(c, NULL, &new_obj);
  return;
 } else {
  list_object(c, new_obj);
 }
}
/**
 * Place a secret door at a given location.
 * \param c current chunk
 * \param grid location
 */
void place_secret_door(struct chunk *c, struct loc grid)
{
 square_set_feat(c, grid, FEAT_SECRET);
}
/**
 * Place a closed (and possibly locked or jammed) door at a given location.
 * \param c current chunk
 * \param grid location
 */
void place_closed_door(struct chunk *c, struct loc grid)
{
 int value = randint0(100);
 square_set_feat(c, grid, FEAT_CLOSED);
 if (square_isvault(c, grid)) {
  int power = (10 + c->depth + randint1(15)) / 5;
  power = MIN(7, power);
  if (value < 4) {
   /* Locked doors (8%) */
   square_set_door_lock(c, grid, power);
  } else if (value < 8) {
   /* Jammed doors (4%) */
   square_set_door_jam(c, grid, power);
  }
 } else {
  int power = (c->depth + randint1(15)) / 5;
  power = MIN(7, power);
  if (value < 24) {
   /* Locked doors (24%) */
   square_set_door_lock(c, grid, power);
  } else if (value < 25) {
   /* Jammed doors (1%) */
   square_set_door_jam(c, grid, power);
  }
 }
}
/**
 * Place a random door at a given location.
 * \param c current chunk
 * \param grid location
 *
 * The door generated could be closed (and possibly locked), open, or secret.
 */
void place_random_door(struct chunk *c, struct loc grid)
{
 int tmp = randint0(60 + c->depth);
 if (tmp < 20) {
  square_set_feat(c, grid, FEAT_OPEN);
 } else if (tmp < 60) {
  place_closed_door(c, grid);
 } else {
  place_secret_door(c, grid);
 }
}
/**
 * Place a forge at a given location.
 * \param c current chunk
 * \param grid location
 */
void place_forge(struct chunk *c, struct loc grid)
{
 int i;
 int effective_depth = c->depth;
 int power = 1;
 int uses = damroll(2, 2);
 if (square_isgreatervault(c, grid)) {
  effective_depth *= 2;
 }
 /* Roll once per level of depth and keep the best roll */
 for (i = 0; i < effective_depth; i++) {
  int p = randint1(1000);
  power = MAX(power, p);
 }
 /* To prevent start-scumming on the initial forge */
 if (c->depth <= 2) {
  uses = 3;
  power = 0;
 }
 /* Pick the forge type */
 if ((power >= 1000) && !player->unique_forge_made) {
  /* Unique forge */
  uses = 3;
  square_set_feat(c, grid, FEAT_FORGE_UNIQUE);
  square_set_forge(c, grid, uses);
  player->unique_forge_made = true;
  if (OPT(player, cheat_room)) msg("Orodruth.");
 } else if (power >= 990) {
  /* Enchanted forge */
  square_set_feat(c, grid, FEAT_FORGE_GOOD);
  square_set_forge(c, grid, uses);
  if (OPT(player, cheat_room)) msg("Enchanted forge.");
 } else {
  /* Normal forge */
  square_set_feat(c, grid, FEAT_FORGE);
  square_set_forge(c, grid, uses);
  if (OPT(player, cheat_room)) msg("Forge.");
 }
}
/**
 * Place some staircases near walls.
 * \param c the current chunk
 * \param feat the stair terrain type
 * \param num number of staircases to place
 */
void alloc_stairs(struct chunk *c, int feat, int num)
{
 int i = 0;
 /* Smaller levels don't need that many stairs, but there are a minimum of
	 * 4 rooms*/
 if (dun->cent_n == 4) {
  num = 1;
 } else if (num > (dun->cent_n / 2)) {
  num = dun->cent_n / 2;
 }
 /* Place "num" stairs */
 while (i < num) {
  struct loc grid;
  bool first = (i == 0);
  /* Find a suitable grid */
  cave_find(c, &grid, square_suits_stairs);
  place_stairs(c, grid, first, feat);
  assert(square_isstairs(c, grid) || (!first && square_isshaft(c, grid)));
  ++i;
 }
}
/**
 * Are there any stairs within line of sight?
 */
static bool stairs_within_los(struct chunk *c, struct loc grid0)
{
 int y, x;
 /* Scan the visible area */
 for (y = grid0.y - 15; y < grid0.y + 15; y++) {
  for (x = grid0.x - 15; x < grid0.x + 15; x++) {
   struct loc grid = loc(x, y);
   if (!square_in_bounds_fully(c, grid)) continue;
   if (!los(c, grid0, grid)) continue;
   /* Detect stairs */
   if (square_isstairs(c, grid)) {
    return true;
   }
  }
 }
 return false;
}
/**
 * Determine whether the given coordinate is a valid starting location.
 * \param c current chunk
 * \param y co-ordinates
 * \param x co-ordinates
 * \return success
 */
static bool find_start(struct chunk *c, struct loc *grid)
{
 int *state = cave_find_init(loc(1, 1), loc(c->width - 2, c->height - 2));
 bool found = false;
 int count = 100;
 /* Find the best possible place */
 while (!found && cave_find_get_grid(grid, state) && count--) {
  /* Require empty square that isn't in an interesting room or vault */
  found = square_suits_start(c, *grid);
  /* Require a room if it is the first level */
  if ((player->turn == 0) && !square_isroom(c, *grid)) found = false;
  /* Don't generate stairs in line of sight if player arrived by stairs */
  if (stairs_within_los(c, *grid) && player->upkeep->create_stair) {
   found = false;
  }
 }
 mem_free(state);
 return found;
}
/**
 * Place the player at a random starting location.
 * \param c current chunk
 * \param p the player
 * \return true on success or false on failure
 */
bool new_player_spot(struct chunk *c, struct player *p)
{
 struct loc grid;
 /* Try to find a good place to put the player */
 if (!find_start(c, &grid)) {
  msg("Failed to place player; please report.  Restarting generation.");
  dump_level_simple(NULL, "Player Placement Failure", c);
  return false;
 }
 /* Destroy area if falling due to blasting through the floor */
    if (p->upkeep->create_stair == FEAT_RUBBLE) {
  effect_simple(EF_EARTHQUAKE, source_grid(grid), "0", 0, 5, 0, NULL);
 }
 if (p->upkeep->create_stair && square_changeable(c, grid)) {
  object_pile_free(c, NULL, square_object(c, grid));
  square_set_feat(c, grid, p->upkeep->create_stair);
 }
 player_place(c, p, grid);
 return true;
}
/**
 * Determines the chance (out of 1000) that a trap will be placed in a given
 * square.
 */
int trap_placement_chance(struct chunk *c, struct loc grid)
{
    int chance = 0;
    /* Extra chance of having a trap for certain squares inside rooms */
    if (square_isfloor(c, grid) && square_isroom(c, grid) &&
  !square_object(c, grid)) {
  int y, x, d;
        chance = 1;
        /* Check the squares that neighbour grid */
        for (y = grid.y - 1; y <= grid.y + 1; y++) {
            for (x = grid.x - 1; x <= grid.x + 1; x++) {
    struct loc check = loc(x, y);
    if (loc_eq(grid, check)) continue;
    /* Item */
    if (square_object(c, check)) chance += 10;
    /* Stairs */
    if (square_isstairs(c, check)) chance += 10;
    /* closed doors (including secret) */
    if (square_iscloseddoor(c, check)) chance += 10;
   }
  }
        /* Opposing impassable squares (chasm or wall) */
  for (d = 0; d < 4; d += 2) {
   struct loc adj1 = loc_sum(grid, ddgrid_ddd[d]);
   struct loc adj2 = loc_sum(grid, ddgrid_ddd[d + 1]);
   if (square_isimpassable(c, adj1) && square_isimpassable(c, adj2)) {
    chance += 10;
   }
  }
    }
    return chance;
}
/**
 * Place traps randomly on the level.
 * Biased towards certain sneaky locations.
 */
void place_traps(struct chunk *c)
{
    struct loc grid;
 /* scan the map */
 for (grid.y = 0; grid.y < c->height; grid.y++) {
  for (grid.x = 0; grid.x < c->width; grid.x++) {
            /* Randomly determine whether to place a trap based on the above */
            if (randint1(1000) <= trap_placement_chance(c, grid)) {
                square_add_trap(c, grid);
            }
  }
 }
}
/**
 * Allocates zero or more random objects in the dungeon.
 * \param c the current chunk
 * \param set where the entity is placed (corridor, room or either)
 * \param typ what is placed (rubble, trap, gold, item)
 * \param num is the number of objects to allocate
 * \param depth generation depth
 * \param origin item origin (if appropriate)
 * \return the number of objects actually placed
 *
 * 'set' controls where the object is placed (corridor, room, either).
 * 'typ' conrols the kind of object (rubble, trap, gold, item).
 */
int alloc_object(struct chunk *c, int set, int typ, int num, int depth,
       uint8_t origin)
{
 int nrem = num;
 int *state = cave_find_init(loc(1, 1),
  loc(c->width - 2, c->height - 2));
 struct loc grid;
 while (nrem > 0 && cave_find_get_grid(&grid, state)) {
  /*
		 * If we're ok with a corridor and we're in one, we're done.
		 * If we are ok with a room and we're in one, we're done
		 */
  bool matched = ((set & SET_CORR) && !square_isroom(c, grid))
   || ((set & SET_ROOM) && square_isroom(c, grid));
  if (square_isempty(c, grid) && matched) {
   /* Place something */
   switch (typ) {
   case TYP_RUBBLE:
    place_rubble(c, grid);
    break;
   case TYP_OBJECT:
    place_object(c, grid, depth, false, false, origin, 0);
    break;
   }
   --nrem;
  }
 }
 mem_free(state);
 return num - nrem;
}
/**
 * Lookup a room profile by name
 */
struct room_profile lookup_room_profile(const char *name)
{
 int num_rooms = dun->profile->n_room_profiles;
 struct room_profile profile;
 int i;
 for (i = 1; i < num_rooms; i++) {
  profile = dun->profile->room_profiles[i];
  if (streq(profile.name, name)) {
   return profile;
  }
 }
 return dun->profile->room_profiles[0];
}
/**
 * Mark artifacts in a failed chunk as not created
 */
void uncreate_artifacts(struct chunk *c)
{
 int y, x;
 /* Also mark created artifacts as not created... */
 for (y = 0; y < c->height; y++) {
  for (x = 0; x < c->width; x++) {
   struct loc grid = loc(x, y);
   struct object *obj = square_object(c, grid);
   while (obj) {
    if (obj->artifact) {
     mark_artifact_created(obj->artifact, false);
    }
    obj = obj->next;
   }
  }
 }
}
/**
 * Mark greater vaults in a failed chunk as not created.
 */
void uncreate_greater_vaults(struct chunk *c, struct player *p)
{
 const struct vault *v;
 if (!c->vault_name) return;
 for (v = vaults; v; v = v->next) {
  if (streq(v->typ, "Greater vault")
    && streq(c->vault_name, v->name)) {
   p->vaults[v->index] = false;
   break;
  }
 }
}
/**
 * Validate that the chunk contains no NULL objects.
 * Only checks for nonzero tval.
 * \param c is the chunk to validate.
 */
void chunk_validate_objects(struct chunk *c) {
 int x, y;
 struct object *obj;
 for (y = 0; y < c->height; y++) {
  for (x = 0; x < c->width; x++) {
   struct loc grid = loc(x, y);
   for (obj = square_object(c, grid); obj; obj = obj->next)
    assert(obj->tval != 0);
   if (square(c, grid)->mon > 0) {
    struct monster *mon = square_monster(c, grid);
    if (mon->held_obj)
     for (obj = mon->held_obj; obj; obj = obj->next)
      assert(obj->tval != 0);
   }
  }
 }
}
/**
 * Dump the given level for post-mortem analysis; handle all I/O.
 * \param basefilename Is the base name (no directory or extension) for the
 * file to use.  If NULL, "dumpedlevel" will be used.
 * \param title Is the label to use within the file.  If NULL, "Dumped Level"
 * will be used.
 * \param c Is the chunk to dump.
 */
void dump_level_simple(const char *basefilename, const char *title,
 struct chunk *c)
{
 char path[1024];
 ang_file *fo;
 path_build(path, sizeof(path), ANGBAND_DIR_USER, (basefilename) ?
  format("%s.html", basefilename) : "dumpedlevel.html");
 fo = file_open(path, MODE_WRITE, FTYPE_TEXT);
 if (fo) {
  dump_level(fo, (title) ? title : "Dumped Level", c, NULL);
  if (file_close(fo)) {
   msg("Level dumped to %s.html",
    (basefilename) ? basefilename : "dumpedlevel");
  }
 }
}
/**
 * Dump the given level to a file for post-mortem analysis.
 * \param fo Is the file handle to use.  Must be capable of sequential writes
 * in text format.  The level is dumped starting at the current offset in the
 * file.
 * \param title Is the title to use for the contents.
 * \param c Is the chunk to dump.
 * \param dist If not NULL, must act like a two dimensional C array with the
 * first dimension being at least c->height elements and the second being at
 * least c->width elements.  For a location (x,y) in the level, if dist[y][x]
 * is negative, the contents will be rendered differently.
 *
 * The current output format is HTML since a typical browser will happily
 * display the content in a scrollable area without wrapping lines.  This
 * function is a convenience to replace a set of calls to dump_level_header(),
 * dump_level_body(), and dump_level_footer().
 */
void dump_level(ang_file *fo, const char *title, struct chunk *c, int **dist)
{
 dump_level_header(fo, title);
 dump_level_body(fo, title, c, dist);
 dump_level_footer(fo);
}
/**
 * Helper function to write a string while escaping any special characters.
 * \param fo Is the file handle to use.
 * \param s Is the string to write.
 */
static void dump_level_escaped_string(ang_file *fo, const char *s)
{
 while (*s) {
  switch (*s) {
  case '&':
   file_put(fo, "&amp;");
   break;
  case '<':
   file_put(fo, "&lt;");
   break;
  case '>':
   file_put(fo, "&gt;");
   break;
  case '\"':
   file_put(fo, "&quot;");
   break;
  default:
   file_putf(fo, "%c", *s);
   break;
  }
  ++s;
 }
}
/**
 * Write the introductory material for the dump of one or move levels.
 * \param fo Is the file handle to use.  Must be capable of sequential writes
 * in text format.  Writes start at the current offset in the file.
 * \param title Is the title to use for the contents of the file.
 *
 * The current format uses HTML.  This should be called once per dump (or
 * take other measures to overwrite a previous call).
 */
void dump_level_header(ang_file *fo, const char *title)
{
 file_put(fo,
  "<!DOCTYPE html>\n"
  "<html lang=\"en\" xml:lang=\"en\" xmlns=\"http://www.w3.org/1999/xhtml\">\n"
  "  <head>\n"
  "    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n"
  "    <title>");
 dump_level_escaped_string(fo, title);
 file_put(fo, "</title>\n  </head>\n  <body>\n");
}
/**
 * Dump the given level to a file.
 * \param fo Is the file handle to use.  Must be capable of sequential writes
 * in text format.  The level is dumped starting at the current offset in the
 * file.
 * \param title Is the title to use for the level.
 * \param c Is the chunk to dump.
 * \param dist If not NULL, must act like a two dimensional C array with the
 * first dimension being at least c->height elements and the second being at
 * least c->width elements.  For a location (x,y) in the level, if dist[y][x]
 * is negative, the contents will be rendered differently.
 *
 * The current output format is HTML.  You can dump more than one level to
 * the same file by calling dump_level_header() once for the file, followed
 * by calling dump_level_body() for each level of interest, then calling
 * dump_level_footer() once to finish things off before you close the file
 * with file_close().
 */
void dump_level_body(ang_file *fo, const char *title, struct chunk *c,
 int **dist)
{
 int y;
 file_put(fo, "    <p>");
 dump_level_escaped_string(fo, title);
 if (dist != NULL) {
  file_put(fo, "\n    <p>A location where the distance array was negative is marked with *.");
 }
 file_put(fo, "\n    <pre>\n");
 for (y = 0; y < c->height; ++y) {
  int x;
  for (x = 0; x < c->width; ++x) {
   struct loc grid = loc(x, y);
   const char *s = "#";
   if (square_in_bounds_fully(c, grid)) {
    if (square_isplayer(c, grid)) {
     s = "@";
    } else if (square_isoccupied(c, grid)) {
     s = (dist == NULL || dist[y][x] >= 0) ?
      "M" : "*";
    } else if (square_isdoor(c, grid)) {
     s = (dist == NULL || dist[y][x] >= 0) ?
      "+" : "*";
    } else if (square_isrubble(c, grid)) {
     s = (dist == NULL || dist[y][x] >= 0) ?
      ":" : "*";
    } else if (square_isdownstairs(c, grid)) {
     s = (dist == NULL || dist[y][x] >= 0) ?
      "&gt;" : "*";
    } else if (square_isupstairs(c, grid)) {
     s = (dist == NULL || dist[y][x] >= 0) ?
      "&lt;" : "*";
    } else if (square_isforge(c, grid)) {
     s = (dist == NULL || dist[y][x] >= 0) ?
      "0" : "*";
    } else if (square_ischasm(c, grid)) {
     s = (dist == NULL || dist[y][x] >= 0) ?
      "7" : "*";
    } else if (square_istrap(c, grid) ||
     square_isplayertrap(c, grid)) {
     s = (dist == NULL || dist[y][x] >= 0) ?
      "^" : "*";
    } else if (square_iswebbed(c, grid)) {
     s = (dist == NULL || dist[y][x] >= 0) ?
      "w" : "*";
    } else if (square_object(c, grid)) {
     s = (dist == NULL || dist[y][x] >= 0) ?
      "$" : "*";
    } else if (square_isempty(c, grid) &&
      square_isvault(c, grid)) {
     s = (dist == NULL || dist[y][x] >= 0) ?
      " " : "*";
    } else if (square_ispassable(c, grid)) {
     s = (dist == NULL || dist[y][x] >= 0) ?
      "." : "*";
    }
   }
   file_put(fo, s);
  }
  file_put(fo, "\n");
 }
 file_put(fo, "    </pre>\n");
}
/**
 * Write the concluding material for the dump of one or more levels.
 * \param fo Is the file handle to use.  Must be capable of sequential writes
 * in text format.  Writes start at the current offset in the file.
 */
void dump_level_footer(ang_file *fo)
{
 file_put(fo, "  </body>\n</html>\n");
}
/**
 * \file grafmode.c
 * \brief Load a list of possible graphics modes.
 *
 * Copyright (c) 2011 Brett Reid
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband license":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
graphics_mode *graphics_modes;
graphics_mode *current_graphics_mode = NULL;
int graphics_mode_high_id;
static enum parser_error parse_graf_name(struct parser *p) {
 graphics_mode *list = parser_priv(p);
 graphics_mode *mode = mem_zalloc(sizeof(graphics_mode));
 if (!mode) {
  return PARSE_ERROR_OUT_OF_MEMORY;
 }
 mode->pNext = list;
 mode->grafID = parser_getuint(p, "index");
 my_strcpy(mode->menuname, parser_getstr(p, "menuname"), 32);
 mode->alphablend = 0;
 mode->overdrawRow = 0;
 mode->overdrawMax = 0;
 my_strcpy(mode->file, "", 32);
 my_strcpy(mode->pref, "none", 32);
 parser_setpriv(p, mode);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_graf_directory(struct parser *p) {
 graphics_mode *mode = parser_priv(p);
 const char *dir = parser_getsym(p, "dirname");
 if (!mode) {
  return PARSE_ERROR_INVALID_VALUE;
 }
 /* Build a usable path */
 path_build(mode->path, sizeof(mode->path), ANGBAND_DIR_TILES, dir);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_graf_size(struct parser *p) {
 graphics_mode *mode = parser_priv(p);
 if (!mode) {
  return PARSE_ERROR_INVALID_VALUE;
 }
 mode->cell_width = parser_getuint(p, "wid");
 mode->cell_height = parser_getuint(p, "hgt");
 my_strcpy(mode->file, parser_getstr(p, "filename"), 32);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_graf_pref(struct parser *p) {
 graphics_mode *mode = parser_priv(p);
 if (!mode) {
  return PARSE_ERROR_INVALID_VALUE;
 }
 my_strcpy(mode->pref, parser_getstr(p, "prefname"), 32);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_graf_extra(struct parser *p) {
 graphics_mode *mode = parser_priv(p);
 if (!mode) {
  return PARSE_ERROR_INVALID_VALUE;
 }
 mode->alphablend = parser_getuint(p, "alpha");
 mode->overdrawRow = parser_getuint(p, "row");
 mode->overdrawMax = parser_getuint(p, "max");
 return PARSE_ERROR_NONE;
}
static struct parser *init_parse_grafmode(void) {
 struct parser *p = parser_new();
 parser_setpriv(p, NULL);
 parser_reg(p, "name uint index str menuname", parse_graf_name);
 parser_reg(p, "directory sym dirname", parse_graf_directory);
 parser_reg(p, "size uint wid uint hgt str filename", parse_graf_size);
 parser_reg(p, "pref str prefname", parse_graf_pref);
 parser_reg(p, "extra uint alpha uint row uint max", parse_graf_extra);
 return p;
}
static errr finish_parse_grafmode(struct parser *p) {
 graphics_mode *mode, *n;
 int max = 0;
 int count = 0;
 int i;
 /* See how many graphics modes we have and what the highest index is */
 if (p) {
  mode = parser_priv(p);
  while (mode) {
   if (mode->grafID > max) {
    max = mode->grafID;
   }
   count++;
   mode = mode->pNext;
  }
 }
 /* Copy the loaded modes to the global variable */
 if (graphics_modes) {
  close_graphics_modes();
 }
 graphics_modes = mem_zalloc(sizeof(graphics_mode) * (count+1));
 if (p) {
  mode = parser_priv(p);
  for (i = count-1; i >= 0; i--, mode = mode->pNext) {
   memcpy(&(graphics_modes[i]), mode, sizeof(graphics_mode));
   graphics_modes[i].pNext = &(graphics_modes[i+1]);
  }
 }
 /* Hardcode the no graphics option */
 graphics_modes[count].pNext = NULL;
 graphics_modes[count].grafID = GRAPHICS_NONE;
 graphics_modes[count].alphablend = 0;
 graphics_modes[count].overdrawRow = 0;
 graphics_modes[count].overdrawMax = 0;
 my_strcpy(graphics_modes[count].pref, "none", 8);
 my_strcpy(graphics_modes[count].path, "", 32);
 my_strcpy(graphics_modes[count].file, "", 32);
 my_strcpy(graphics_modes[count].menuname, "None", 32);
 graphics_mode_high_id = max;
 /* Set the default graphics mode to be no graphics */
 current_graphics_mode = &(graphics_modes[count]);
 if (p) {
  mode = parser_priv(p);
  while (mode) {
   n = mode->pNext;
   mem_free(mode);
   mode = n;
  }
  parser_setpriv(p, NULL);
  parser_destroy(p);
 }
 return PARSE_ERROR_NONE;
}
static void print_error(const char *name, struct parser *p) {
 struct parser_state s;
 parser_getstate(p, &s);
 msg("Parse error in %s line %d column %d: %s: %s", name,
            s.line, s.col, s.msg, parser_error_str[s.error]);
 event_signal(EVENT_MESSAGE_FLUSH);
}
bool init_graphics_modes(void) {
 char buf[1024];
 ang_file *f;
 struct parser *p;
 errr e = 0;
 /* Build the filename */
 path_build(buf, sizeof(buf), ANGBAND_DIR_TILES, "list.txt");
 f = file_open(buf, MODE_READ, FTYPE_TEXT);
 if (!f) {
  msg("Cannot open '%s'.", buf);
  finish_parse_grafmode(NULL);
 } else {
  char line[1024];
  p = init_parse_grafmode();
  while (file_getl(f, line, sizeof line)) {
   e = parser_parse(p, line);
   if (e != PARSE_ERROR_NONE) {
    print_error(buf, p);
    break;
   }
  }
  finish_parse_grafmode(p);
  file_close(f);
 }
 /* Result */
 return e == PARSE_ERROR_NONE;
}
void close_graphics_modes(void) {
 if (graphics_modes) {
  mem_free(graphics_modes);
  graphics_modes = NULL;
 }
}
graphics_mode *get_graphics_mode(uint8_t id) {
 graphics_mode *test = graphics_modes;
 while (test) {
  if (test->grafID == id) {
   return test;
  }
  test = test->pNext;
 }
 return NULL;
}
/**
 * Test for whether an attribute/character pair corresponds to a double-height
 * tile.
 * \param a Is the attribute.
 * \param c Is the character.
 * Intended for use as struct term's dblh_hook field.
 */
int is_dh_tile(int a, wchar_t c)
{
 int tileset_row;
 /*
	 * If it's not a tile (assumes tiles have high-bit set on the
	 * attribute), graphics aren't enabled, or the graphics mode doesn't
	 * use double-height tiles, it can't be double-height.
	 */
 if (!(a & 0x80) || !current_graphics_mode ||
   !current_graphics_mode->overdrawRow) {
  return 0;
 }
 /* Test the row for the tile. */
 tileset_row = a & 0x7f;
 return tileset_row >= current_graphics_mode->overdrawRow &&
  tileset_row <= current_graphics_mode->overdrawMax;
}
/**
 * \file guid.c
 * \brief Entity guids.
 *
 * Copyright (c) 2011 elly+angband@leptoquark.net
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
int guid_eq(guid a, guid b)
{
 return a == b;
}
/**
 * \file init.c
 * \brief Various game initialization routines
 *
 * Copyright (c) 1997 Ben Harrison
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 *
 * This file is used to initialize various variables and arrays for the
 * Angband game.
 *
 * Several of the arrays for Angband are built from data files in the
 * "lib/gamedata" directory.
 */
bool play_again = false;
/**
 * Structure (not array) of game constants
 */
struct angband_constants *z_info;
/*
 * Hack -- The special Angband "System Suffix"
 * This variable is used to choose an appropriate "pref-xxx" file
 */
const char *ANGBAND_SYS = "xxx";
/**
 * Various directories. These are no longer necessarily all subdirs of "lib"
 */
char *ANGBAND_DIR_GAMEDATA;
char *ANGBAND_DIR_CUSTOMIZE;
char *ANGBAND_DIR_HELP;
char *ANGBAND_DIR_SCREENS;
char *ANGBAND_DIR_FONTS;
char *ANGBAND_DIR_TILES;
char *ANGBAND_DIR_SOUNDS;
char *ANGBAND_DIR_ICONS;
char *ANGBAND_DIR_USER;
char *ANGBAND_DIR_SAVE;
char *ANGBAND_DIR_PANIC;
char *ANGBAND_DIR_SCORES;
char *ANGBAND_DIR_ARCHIVE;
static const char *slots[] = {
/**
 * \file list-equip-slots.h
 * \brief types of slot for equipment
 *
 * Fields:
 * slot - The index name of the slot
 * acid_v - whether equipment in the slot needs checking for acid damage
 * name - whether the actual item name is mentioned when things happen to it
 * mention - description for when the slot is mentioned briefly
 * describe - description for when the slot is described at length
 */
/* slot				acid_v	name	mention			describe */
"NONE",
"WEAPON",
"BOW",
"RING",
"AMULET",
"LIGHT",
"BODY_ARMOR",
"CLOAK",
"SHIELD",
"HAT",
"GLOVES",
"BOOTS",
"QUIVER",

 NULL
};
const char *list_obj_flag_names[] = {
 "NONE",
/**
 * \file list-object-flags.h
 * \brief object flags for all objects
 *
 * Changing flag order will break savefiles. Flags
 * below start from 1 on line 17, so a flag's sequence number is its line
 * number minus 16.
 *
 * Each sustain flag (SUST_*) has a matching stat in src/list-stats.h,
 * which should be at the same index in that file as the sustain in this file.
 *
 * The second argument to OF is the label used in the debugging commands
 * object flag display.  At most the first five characters are used.
 *
 * Flag properties are defined in lib/gamedata/object_property.txt
 */
"SUST_STR",
"SUST_DEX",
"SUST_CON",
"SUST_GRA",
"PROT_FEAR",
"PROT_BLIND",
"PROT_CONF",
"PROT_STUN",
"PROT_HALLU",
"SLOW_DIGEST",
"REGEN",
"SEE_INVIS",
"FREE_ACT",
"RADIANCE",
"LIGHT",
"SPEED",
"SHARPNESS",
"SHARPNESS2",
"VAMPIRIC",
"BURNS_OUT",
"TAKES_FUEL",
"NO_FUEL",
"COWARDICE",
"HUNGER",
"DARKNESS",
"DANGER",
"HAUNTED",
"AGGRAVATE",
"CURSED",
"DIG_1",
"DIG_2",
"THROWING",
"INDESTRUCTIBLE",
"NO_SMITHING",
"NO_RANDOM",
"MITHRIL",
"AXE",
"POLEARM",
"ENCHANTABLE",
"HAND_AND_A_HALF",
"TWO_HANDED",
"MAX",

 NULL
};
const char *list_element_names[] = {
/**
 * \file list-elements.h
 * \brief Elements used in spells and other attacks.
 */
"ACID",
"FIRE",
"COLD",
"POIS",
"DARK",

 NULL
};
static const char *effect_list[] = {
 "NONE",
/**
 * \file list-effects.h
 * \brief List of effects
 *
 * name: effect code
 * aim: does the effect require aiming?
 * info: info label for spells
 * args: how many arguments the description takes
 * info flags: flags for object description
 * description: text of description
 * menu_name: format string for menu name; use an empty string if there's no
 * plan to use it from a menu
 */
/* name 							aim		info		args	info flags		description	menu_name */
"HEAL_HP",
"DAMAGE",
"DART",
"PIT",
"PROJECT_LOS",
"PROJECT_LOS_GRIDS",
"DEADFALL",
"EARTHQUAKE",
"SPOT",
"SPHERE",
"EXPLOSION",
"BREATH",
"BOLT",
"BEAM",
"TERRAIN_BEAM",
"NOURISH",
"CURE",
"TIMED_SET",
"TIMED_INC",
"TIMED_INC_CHECK",
"TIMED_INC_NO_RES",
"TERROR",
"GLYPH",
"RESTORE_STAT",
"DRAIN_STAT",
"RESTORE_MANA",
"REMOVE_CURSE",
"MAP_AREA",
"DETECT_TRAPS",
"DETECT_DOORS",
"DETECT_OBJECTS",
"DETECT_MONSTERS",
"REVEAL_MONSTER",
"CLOSE_CHASMS",
"IDENTIFY",
"RECHARGE",
"SUMMON",
"TELEPORT_TO",
"DARKEN_LEVEL",
"LIGHT_AREA",
"DARKEN_AREA",
"SONG_OF_ELBERETH",
"SONG_OF_LORIEN",
"SONG_OF_FREEDOM",
"SONG_OF_BINDING",
"SONG_OF_PIERCING",
"SONG_OF_OATHS",
"AGGRAVATE",
"NOISE",
"CREATE_TRAPS",

 "MAX"
};
static const char *terrain_flags[] =
{
/**
 * \file list-terrain-flags.h
 * \brief monster race blow effects
 *
 * Adjusting these flags does not break savefiles. Flags below start from 1
 * on line 13, so a flag's sequence number is its line number minus 12.
 *
 *
 */
/*  symbol     descr */
"NONE",
"LOS",
"PROJECT",
"PASSABLE",
"INTERESTING",
"PERMANENT",
"EASY",
"TRAP",
"NO_SCENT",
"NO_FLOW",
"OBJECT",
"TORCH",
"HIDDEN",
"GOLD",
"CLOSABLE",
"FLOOR",
"WALL",
"ROCK",
"GRANITE",
"DOOR_ANY",
"DOOR_CLOSED",
"FORGE",
"DOOR_JAMMED",
"DOOR_LOCKED",
"MAGMA",
"QUARTZ",
"STAIR",
"SHAFT",
"UPSTAIR",
"DOWNSTAIR",
"PIT",
"CHASM",

    NULL
};
static const char *player_info_flags[] =
{
/**
 * \file list-player-flags.h
 * \brief player race and class flags
 *
 * Adjusting these flags does not break savefiles. Flags below start from 1
 * on line 14, so a flag's sequence number is its line number minus 13.
 *
 * Fields:
 * symbol - the flag name
 * additional details in player_property.txt
 */
"NONE",
"BLADE_PROFICIENCY",
"AXE_PROFICIENCY",

 NULL
};
errr grab_effect_data(struct parser *p, struct effect *effect)
{
 const char *type;
 int val;
 if (grab_name("effect", parser_getsym(p, "eff"), effect_list,
      N_ELEMENTS(effect_list), &val))
  return PARSE_ERROR_INVALID_EFFECT;
 effect->index = val;
 if (parser_hasval(p, "type")) {
  type = parser_getsym(p, "type");
  if (type == NULL)
   return PARSE_ERROR_UNRECOGNISED_PARAMETER;
  /* Check for a value */
  val = effect_subtype(effect->index, type);
  if (val < 0)
   return PARSE_ERROR_INVALID_VALUE;
  else
   effect->subtype = val;
 }
 if (parser_hasval(p, "radius"))
  effect->radius = parser_getint(p, "radius");
 if (parser_hasval(p, "other"))
  effect->other = parser_getint(p, "other");
 return PARSE_ERROR_NONE;
}
/**
 * Find the default paths to all of our important sub-directories.
 *
 * All of the sub-directories should, for a single-user install, be
 * located inside the main directory, whose location is very system-dependent.
 * For shared installations, typically on Unix or Linux systems, the
 * directories may be scattered - see config.h for more info.
 *
 * This function takes buffers, holding the paths to the "config", "lib",
 * and "data" directories (for example, those could be "/etc/angband/",
 * "/usr/share/angband", and "/var/games/angband").  Some system-dependent
 * expansion/substitution may be done when copying those base paths to the
 * paths Angband uses:  see path_process() in z-file.c for details (Unix
 * implementations, for instance, try to replace a leading ~ or ~username with
 * the path to a home directory).
 *
 * Various command line options may allow some of the important
 * directories to be changed to user-specified directories, most
 * importantly, the "scores" and "user" and "save" directories,
 * but this is done after this function, see "main.c".
 *
 * In general, the initial path should end in the appropriate "PATH_SEP"
 * string.  All of the "sub-directory" paths (created below or supplied
 * by the user) will NOT end in the "PATH_SEP" string, see the special
 * "path_build()" function in "util.c" for more information.
 *
 * Hack -- first we free all the strings, since this is known
 * to succeed even if the strings have not been allocated yet,
 * as long as the variables start out as "NULL".  This allows
 * this function to be called multiple times, for example, to
 * try several base "path" values until a good one is found.
 */
void init_file_paths(const char *configpath, const char *libpath, const char *datapath)
{
 char buf[1024];
 char *userpath = NULL;
 /*** Free everything ***/
 /* Free the sub-paths */
 string_free(ANGBAND_DIR_GAMEDATA);
 string_free(ANGBAND_DIR_CUSTOMIZE);
 string_free(ANGBAND_DIR_HELP);
 string_free(ANGBAND_DIR_SCREENS);
 string_free(ANGBAND_DIR_FONTS);
 string_free(ANGBAND_DIR_TILES);
 string_free(ANGBAND_DIR_SOUNDS);
 string_free(ANGBAND_DIR_ICONS);
 string_free(ANGBAND_DIR_USER);
 string_free(ANGBAND_DIR_SAVE);
 string_free(ANGBAND_DIR_PANIC);
 string_free(ANGBAND_DIR_SCORES);
 string_free(ANGBAND_DIR_ARCHIVE);
 /*** Prepare the paths ***/
 /* Paths generally containing configuration data for Angband. */
 { path_build(buf, sizeof(buf), (configpath), ("gamedata")); ANGBAND_DIR_GAMEDATA = string_make(buf); };
 { path_build(buf, sizeof(buf), (configpath), ("customize")); ANGBAND_DIR_CUSTOMIZE = string_make(buf); };
 { path_build(buf, sizeof(buf), (libpath), ("help")); ANGBAND_DIR_HELP = string_make(buf); };
 { path_build(buf, sizeof(buf), (libpath), ("screens")); ANGBAND_DIR_SCREENS = string_make(buf); };
 { path_build(buf, sizeof(buf), (libpath), ("fonts")); ANGBAND_DIR_FONTS = string_make(buf); };
 { path_build(buf, sizeof(buf), (libpath), ("tiles")); ANGBAND_DIR_TILES = string_make(buf); };
 { path_build(buf, sizeof(buf), (libpath), ("sounds")); ANGBAND_DIR_SOUNDS = string_make(buf); };
 { path_build(buf, sizeof(buf), (libpath), ("icons")); ANGBAND_DIR_ICONS = string_make(buf); };
 /* Build the path to the user specific directory */
 if (strncmp(ANGBAND_SYS, "test", 4) == 0)
  path_build(buf, sizeof(buf), "~/.angband", "Test");
 else
  path_build(buf, sizeof(buf), "~/.angband", VERSION_NAME);
 ANGBAND_DIR_USER = string_make(buf);
 /* Build the path to the archive directory. */
 { path_build(buf, sizeof(buf), (ANGBAND_DIR_USER), ("archive")); ANGBAND_DIR_ARCHIVE = string_make(buf); };
 userpath = ANGBAND_DIR_USER;
 /* Build the path to the score and save directories */
 { path_build(buf, sizeof(buf), (userpath), ("scores")); ANGBAND_DIR_SCORES = string_make(buf); };
 { path_build(buf, sizeof(buf), (userpath), ("save")); ANGBAND_DIR_SAVE = string_make(buf); };
 { path_build(buf, sizeof(buf), (userpath), ("panic")); ANGBAND_DIR_PANIC = string_make(buf); };
}
/**
 * Create any missing directories. We create only those dirs which may be
 * empty (user/, save/, scores/, info/, help/). The others are assumed
 * to contain required files and therefore must exist at startup
 * (edit/, pref/, file/, xtra/).
 *
 * ToDo: Only create the directories when actually writing files.
 */
void create_needed_dirs(void)
{
 char dirpath[512];
 path_build(dirpath, sizeof(dirpath), ANGBAND_DIR_USER, "");
 if (!dir_create(dirpath)) quit_fmt("Cannot create '%s'", dirpath);
 path_build(dirpath, sizeof(dirpath), ANGBAND_DIR_SAVE, "");
 if (!dir_create(dirpath)) quit_fmt("Cannot create '%s'", dirpath);
 path_build(dirpath, sizeof(dirpath), ANGBAND_DIR_PANIC, "");
 if (!dir_create(dirpath)) quit_fmt("Cannot create '%s'", dirpath);
 path_build(dirpath, sizeof(dirpath), ANGBAND_DIR_SCORES, "");
 if (!dir_create(dirpath)) quit_fmt("Cannot create '%s'", dirpath);
 path_build(dirpath, sizeof(dirpath), ANGBAND_DIR_ARCHIVE, "");
 if (!dir_create(dirpath)) quit_fmt("Cannot create '%s'", dirpath);
}
/**
 * ------------------------------------------------------------------------
 * Initialize game constants
 * ------------------------------------------------------------------------ */
static enum parser_error parse_constants_level_max(struct parser *p) {
 struct angband_constants *z;
 const char *label;
 int value;
 z = parser_priv(p);
 label = parser_getsym(p, "label");
 value = parser_getint(p, "value");
 if (value < 0)
  return PARSE_ERROR_INVALID_VALUE;
 if (streq(label, "monsters"))
  z->level_monster_max = value;
 else
  return PARSE_ERROR_UNDEFINED_DIRECTIVE;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_constants_mon_gen(struct parser *p) {
 struct angband_constants *z;
 const char *label;
 int value;
 z = parser_priv(p);
 label = parser_getsym(p, "label");
 value = parser_getint(p, "value");
 if (value < 0)
  return PARSE_ERROR_INVALID_VALUE;
 if (streq(label, "chance"))
  z->alloc_monster_chance = value;
 else if (streq(label, "group-max"))
  z->monster_group_max = value;
 else
  return PARSE_ERROR_UNDEFINED_DIRECTIVE;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_constants_mon_play(struct parser *p) {
 struct angband_constants *z;
 const char *label;
 int value;
 z = parser_priv(p);
 label = parser_getsym(p, "label");
 value = parser_getint(p, "value");
 if (value < 0)
  return PARSE_ERROR_INVALID_VALUE;
 if (streq(label, "mult-rate"))
  z->repro_monster_rate = value;
 else if (streq(label, "mana-cost"))
  z->mana_cost = value;
 else if (streq(label, "mana-max")) {
  /* A monster's mana is stored and saved as a uint8_t. */
  if (value > 255) return PARSE_ERROR_INVALID_VALUE;
  z->mana_max = (uint8_t)value;
 } else if (streq(label, "flee-range")) {
  /*
		 * Influences a monster's minimum range which is stored as a
		 * uint8_t.
		 */
  if (value > 255) return PARSE_ERROR_INVALID_VALUE;
  z->flee_range = (uint8_t)value;
 } else if (streq(label, "turn-range"))
  z->turn_range = value;
 else if (streq(label, "hide-range"))
  z->hide_range = value;
 else if (streq(label, "wander-range")) {
  /* A monster's wandering distance is stored as a uint8_t. */
  if (value > 255) return PARSE_ERROR_INVALID_VALUE;
  z->wander_range = (uint8_t)value;
 } else if (streq(label, "regen-hp-period"))
  z->mon_regen_hp_period = value;
 else if (streq(label, "regen-sp-period"))
  z->mon_regen_sp_period = value;
 else
  return PARSE_ERROR_UNDEFINED_DIRECTIVE;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_constants_dun_gen(struct parser *p) {
 struct angband_constants *z;
 const char *label;
 int value;
 z = parser_priv(p);
 label = parser_getsym(p, "label");
 value = parser_getint(p, "value");
 if (value < 0)
  return PARSE_ERROR_INVALID_VALUE;
 if (streq(label, "room-max"))
  z->level_room_max = value;
 else if (streq(label, "room-min"))
  z->level_room_min = value;
 else if (streq(label, "block-hgt"))
  z->block_hgt = value;
 else if (streq(label, "block-wid"))
  z->block_wid = value;
 else
  return PARSE_ERROR_UNDEFINED_DIRECTIVE;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_constants_world(struct parser *p) {
 struct angband_constants *z;
 const char *label;
 int value;
 z = parser_priv(p);
 label = parser_getsym(p, "label");
 value = parser_getint(p, "value");
 if (value < 0)
  return PARSE_ERROR_INVALID_VALUE;
 if (streq(label, "dun-depth"))
  z->dun_depth = value;
 else if (streq(label, "max-depth"))
  z->max_depth = value;
 else if (streq(label, "day-length"))
  z->day_length = value;
 else if (streq(label, "dungeon-hgt"))
  z->dungeon_hgt = value;
 else if (streq(label, "dungeon-wid"))
  z->dungeon_wid = value;
 else if (streq(label, "move-energy"))
  z->move_energy = value;
 else if (streq(label, "flow-max"))
  z->flow_max = value;
 else
  return PARSE_ERROR_UNDEFINED_DIRECTIVE;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_constants_carry_cap(struct parser *p) {
 struct angband_constants *z;
 const char *label;
 int value;
 z = parser_priv(p);
 label = parser_getsym(p, "label");
 value = parser_getint(p, "value");
 if (value < 0)
  return PARSE_ERROR_INVALID_VALUE;
 if (streq(label, "pack-size"))
  z->pack_size = value;
 else if (streq(label, "floor-size"))
  z->floor_size = value;
 else
  return PARSE_ERROR_UNDEFINED_DIRECTIVE;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_constants_obj_make(struct parser *p) {
 struct angband_constants *z;
 const char *label;
 int value;
 z = parser_priv(p);
 label = parser_getsym(p, "label");
 value = parser_getint(p, "value");
 if (value < 0)
  return PARSE_ERROR_INVALID_VALUE;
 if (streq(label, "max-depth"))
  z->max_obj_depth = value;
 else if (streq(label, "great-obj"))
  z->great_obj = value;
 else if (streq(label, "great-spec"))
  z->great_ego = value;
 else if (streq(label, "default-torch"))
  z->default_torch = value;
 else if (streq(label, "fuel-torch"))
  z->fuel_torch = value;
 else if (streq(label, "default-lamp"))
  z->default_lamp = value;
 else if (streq(label, "fuel-lamp"))
  z->fuel_lamp = value;
 else if (streq(label, "self-arts"))
  z->self_arts_max = value;
 else
  return PARSE_ERROR_UNDEFINED_DIRECTIVE;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_constants_player(struct parser *p) {
 struct angband_constants *z;
 const char *label;
 int value;
 z = parser_priv(p);
 label = parser_getsym(p, "label");
 value = parser_getint(p, "value");
 if (value < 0)
  return PARSE_ERROR_INVALID_VALUE;
 if (streq(label, "max-sight"))
  z->max_sight = value;
 else if (streq(label, "max-range"))
  z->max_range = value;
 else if (streq(label, "start-exp"))
  z->start_exp = value;
 else if (streq(label, "ability-cost"))
  z->ability_cost = value;
 else if (streq(label, "stealth-bonus"))
  z->stealth_bonus = value;
 else if (streq(label, "regen-period"))
  z->player_regen_period = value;
 else
  return PARSE_ERROR_UNDEFINED_DIRECTIVE;
 return PARSE_ERROR_NONE;
}
static struct parser *init_parse_constants(void) {
 struct angband_constants *z = mem_zalloc(sizeof *z);
 struct parser *p = parser_new();
 parser_setpriv(p, z);
 parser_reg(p, "level-max sym label int value", parse_constants_level_max);
 parser_reg(p, "mon-gen sym label int value", parse_constants_mon_gen);
 parser_reg(p, "mon-play sym label int value", parse_constants_mon_play);
 parser_reg(p, "dun-gen sym label int value", parse_constants_dun_gen);
 parser_reg(p, "world sym label int value", parse_constants_world);
 parser_reg(p, "carry-cap sym label int value", parse_constants_carry_cap);
 parser_reg(p, "obj-make sym label int value", parse_constants_obj_make);
 parser_reg(p, "player sym label int value", parse_constants_player);
 return p;
}
static errr run_parse_constants(struct parser *p) {
 return parse_file_quit_not_found(p, "constants");
}
static errr finish_parse_constants(struct parser *p) {
 z_info = parser_priv(p);
 parser_destroy(p);
 return 0;
}
static void cleanup_constants(void)
{
 mem_free(z_info);
}
struct file_parser constants_parser = {
 "constants",
 init_parse_constants,
 run_parse_constants,
 finish_parse_constants,
 cleanup_constants
};
/**
 * Initialize game constants.
 *
 * Assumption: Paths are set up correctly before calling this function.
 */
void init_game_constants(void)
{
 event_signal_message(EVENT_INITSTATUS, 0, "Initializing constants");
 if (run_parser(&constants_parser))
  quit_fmt("Cannot initialize constants.");
}
/**
 * Free the game constants
 */
static void cleanup_game_constants(void)
{
 cleanup_parser(&constants_parser);
}
/**
 * ------------------------------------------------------------------------
 * Initialize world map
 * ------------------------------------------------------------------------ */
static enum parser_error parse_world_level(struct parser *p) {
 const int depth = parser_getint(p, "depth");
 const char *name = parser_getsym(p, "name");
 const char *up = parser_getsym(p, "up");
 const char *down = parser_getsym(p, "down");
 struct level *last = parser_priv(p);
 struct level *lev = mem_zalloc(sizeof *lev);
 if (last) {
  last->next = lev;
 } else {
  world = lev;
 }
 lev->depth = depth;
 lev->name = string_make(name);
 lev->up = streq(up, "None") ? NULL : string_make(up);
 lev->down = streq(down, "None") ? NULL : string_make(down);
 parser_setpriv(p, lev);
 return PARSE_ERROR_NONE;
}
static struct parser *init_parse_world(void) {
 struct parser *p = parser_new();
 parser_reg(p, "level int depth sym name sym up sym down",
      parse_world_level);
 return p;
}
static errr run_parse_world(struct parser *p) {
 return parse_file_quit_not_found(p, "world");
}
static errr finish_parse_world(struct parser *p) {
 struct level *level_check;
 /* Check that all levels referred to exist */
 for (level_check = world; level_check; level_check = level_check->next) {
  struct level *level_find = world;
  /* Check upwards */
  if (level_check->up) {
   while (level_find && !streq(level_check->up, level_find->name)) {
    level_find = level_find->next;
   }
   if (!level_find) {
    quit_fmt("Invalid level reference %s", level_check->up);
   }
  }
  /* Check downwards */
  level_find = world;
  if (level_check->down) {
   while (level_find && !streq(level_check->down, level_find->name)) {
    level_find = level_find->next;
   }
   if (!level_find) {
    quit_fmt("Invalid level reference %s", level_check->down);
   }
  }
 }
 parser_destroy(p);
 return 0;
}
static void cleanup_world(void)
{
 struct level *level = world;
 while (level) {
  struct level *old = level;
  string_free(level->name);
  string_free(level->up);
  string_free(level->down);
  level = level->next;
  mem_free(old);
 }
}
struct file_parser world_parser = {
 "world",
 init_parse_world,
 run_parse_world,
 finish_parse_world,
 cleanup_world
};
/**
 * ------------------------------------------------------------------------
 * Initialize terrain
 * ------------------------------------------------------------------------ */
static enum parser_error parse_feat_code(struct parser *p) {
 const char *code = parser_getstr(p, "code");
 int idx = lookup_feat_code(code);
 struct feature *f;
 if (idx < 0) {
  /*
		 * Of the existing parser errors, PARSE_ERROR_INVALID_VALUE
		 * could also be used; this matches what ui-prefs.c returns
		 * for an unknown feature code or name.
		 */
  return PARSE_ERROR_OUT_OF_BOUNDS;
 }
 assert(idx < FEAT_MAX);
 f = &f_info[idx];
 f->fidx = idx;
 parser_setpriv(p, f);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_feat_name(struct parser *p) {
 const char *name = parser_getstr(p, "name");
 struct feature *f = parser_priv(p);
 if (!f) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 if (f->name) {
  return PARSE_ERROR_REPEATED_DIRECTIVE;
 }
 f->name = string_make(name);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_feat_graphics(struct parser *p) {
 wchar_t glyph = parser_getchar(p, "glyph");
 const char *color = parser_getsym(p, "color");
 int attr = 0;
 struct feature *f = parser_priv(p);
 if (!f)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 f->d_char = glyph;
 if (strlen(color) > 1)
  attr = color_text_to_attr(color);
 else
  attr = color_char_to_attr(color[0]);
 if (attr < 0)
  return PARSE_ERROR_INVALID_COLOR;
 f->d_attr = attr;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_feat_mimic(struct parser *p) {
 const char *mimic_name = parser_getstr(p, "feat");
 struct feature *f = parser_priv(p);
 int mimic_idx;
 if (!f) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 /* Verify that it refers to a valid feature. */
 mimic_idx = lookup_feat_code(mimic_name);
 if (mimic_idx < 0) {
  return PARSE_ERROR_OUT_OF_BOUNDS;
 }
 f->mimic = &f_info[mimic_idx];
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_feat_priority(struct parser *p) {
 unsigned int priority = parser_getuint(p, "priority");
 struct feature *f = parser_priv(p);
 if (!f)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 f->priority = priority;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_feat_flags(struct parser *p) {
 struct feature *f = parser_priv(p);
 char *flags, *s;
 if (!f) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 if (!parser_hasval(p, "flags")) {
  return PARSE_ERROR_NONE;
 }
 flags = string_make(parser_getstr(p, "flags"));
 s = strtok(flags, " |");
 while (s) {
  if (grab_flag(f->flags, TF_SIZE, terrain_flags, s)) {
   break;
  }
  s = strtok(NULL, " |");
 }
 string_free(flags);
 return s ? PARSE_ERROR_INVALID_FLAG : PARSE_ERROR_NONE;
}
static enum parser_error parse_feat_info(struct parser *p) {
 struct feature *f = parser_priv(p);
 if (!f)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 f->forge_bonus = parser_getint(p, "bonus");
 f->dig = parser_getint(p, "dig");
 f->pit_difficulty = parser_getint(p, "pit");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_feat_desc(struct parser *p) {
 struct feature *f = parser_priv(p);
 if (!f) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 f->desc = string_append(f->desc, parser_getstr(p, "text"));
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_feat_walk_msg(struct parser *p) {
 struct feature *f = parser_priv(p);
 if (!f) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 f->walk_msg = string_append(f->walk_msg, parser_getstr(p, "text"));
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_feat_run_msg(struct parser *p) {
 struct feature *f = parser_priv(p);
 if (!f) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 f->run_msg = string_append(f->run_msg, parser_getstr(p, "text"));
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_feat_hurt_msg(struct parser *p) {
 struct feature *f = parser_priv(p);
 if (!f) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 f->hurt_msg = string_append(f->hurt_msg, parser_getstr(p, "text"));
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_feat_dig_msg(struct parser *p) {
 struct feature *f = parser_priv(p);
 if (!f) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 f->dig_msg = string_append(f->dig_msg, parser_getstr(p, "text"));
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_feat_fail_msg(struct parser *p) {
 struct feature *f = parser_priv(p);
 if (!f) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 f->fail_msg = string_append(f->fail_msg, parser_getstr(p, "text"));
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_feat_str_msg(struct parser *p) {
 struct feature *f = parser_priv(p);
 if (!f) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 f->str_msg = string_append(f->str_msg, parser_getstr(p, "text"));
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_feat_die_msg(struct parser *p) {
 struct feature *f = parser_priv(p);
 if (!f) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 f->die_msg = string_append(f->die_msg, parser_getstr(p, "text"));
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_feat_confused_msg(struct parser *p) {
 struct feature *f = parser_priv(p);
 if (!f) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 f->confused_msg =
  string_append(f->confused_msg, parser_getstr(p, "text"));
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_feat_look_prefix(struct parser *p) {
 struct feature *f = parser_priv(p);
 if (!f) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 f->look_prefix =
  string_append(f->look_prefix, parser_getstr(p, "text"));
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_feat_look_in_preposition(struct parser *p) {
 struct feature *f = parser_priv(p);
 if (!f) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 f->look_in_preposition =
  string_append(f->look_in_preposition, parser_getstr(p, "text"));
 return PARSE_ERROR_NONE;
}
static struct parser *init_parse_feat(void) {
 struct parser *p = parser_new();
 parser_setpriv(p, NULL);
 parser_reg(p, "code str code", parse_feat_code);
 parser_reg(p, "name str name", parse_feat_name);
 parser_reg(p, "graphics char glyph sym color", parse_feat_graphics);
 parser_reg(p, "mimic str feat", parse_feat_mimic);
 parser_reg(p, "priority uint priority", parse_feat_priority);
 parser_reg(p, "flags ?str flags", parse_feat_flags);
 parser_reg(p, "info int bonus int dig int pit", parse_feat_info);
 parser_reg(p, "desc str text", parse_feat_desc);
 parser_reg(p, "walk-msg str text", parse_feat_walk_msg);
 parser_reg(p, "run-msg str text", parse_feat_run_msg);
 parser_reg(p, "hurt-msg str text", parse_feat_hurt_msg);
 parser_reg(p, "dig-msg str text", parse_feat_dig_msg);
 parser_reg(p, "fail-msg str text", parse_feat_fail_msg);
 parser_reg(p, "str-msg str text", parse_feat_str_msg);
 parser_reg(p, "die-msg str text", parse_feat_die_msg);
 parser_reg(p, "confused-msg str text", parse_feat_confused_msg);
 parser_reg(p, "look-prefix str text", parse_feat_look_prefix);
 parser_reg(p, "look-in-preposition str text", parse_feat_look_in_preposition);
 /*
	 * Since the layout of the terrain array is fixed by list-terrain.h,
	 * allocate it now and fill in the customizable parts when parsing.
	 */
 f_info = mem_zalloc(FEAT_MAX * sizeof(*f_info));
 return p;
}
static errr run_parse_feat(struct parser *p) {
 return parse_file_quit_not_found(p, "terrain");
}
static errr finish_parse_feat(struct parser *p) {
 int fidx;
 for (fidx = 0; fidx < FEAT_MAX; ++fidx) {
  /* Ensure the prefixes and prepositions end with a space for
		 * ease of use with the targeting code. */
  if (f_info[fidx].look_prefix && !suffix(
    f_info[fidx].look_prefix, " ")) {
   f_info[fidx].look_prefix = string_append(
    f_info[fidx].look_prefix, " ");
  }
  if (f_info[fidx].look_in_preposition && !suffix(
    f_info[fidx].look_in_preposition, " ")) {
   f_info[fidx].look_in_preposition =
    string_append(f_info[fidx].look_in_preposition,
    " ");
  }
 }
 parser_destroy(p);
 return 0;
}
static void cleanup_feat(void) {
 int idx;
 for (idx = 0; idx < FEAT_MAX; idx++) {
  string_free(f_info[idx].look_in_preposition);
  string_free(f_info[idx].look_prefix);
  string_free(f_info[idx].confused_msg);
  string_free(f_info[idx].str_msg);
  string_free(f_info[idx].fail_msg);
  string_free(f_info[idx].dig_msg);
  string_free(f_info[idx].die_msg);
  string_free(f_info[idx].hurt_msg);
  string_free(f_info[idx].run_msg);
  string_free(f_info[idx].walk_msg);
  string_free(f_info[idx].desc);
  string_free(f_info[idx].name);
 }
 mem_free(f_info);
}
struct file_parser feat_parser = {
 "terrain",
 init_parse_feat,
 run_parse_feat,
 finish_parse_feat,
 cleanup_feat
};
/**
 * ------------------------------------------------------------------------
 * Initialize player bodies
 * ------------------------------------------------------------------------ */
static enum parser_error parse_body_body(struct parser *p) {
 struct player_body *h = parser_priv(p);
 struct player_body *b = mem_zalloc(sizeof *b);
 b->next = h;
 b->name = string_make(parser_getstr(p, "name"));
 parser_setpriv(p, b);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_body_slot(struct parser *p) {
 struct player_body *b = parser_priv(p);
 struct equip_slot *slot;
 int n;
 if (!b) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 /* Go to the last valid slot, then allocate a new one */
 slot = b->slots;
 if (!slot) {
  b->slots = mem_zalloc(sizeof(struct equip_slot));
  slot = b->slots;
 } else {
  while (slot->next) slot = slot->next;
  slot->next = mem_zalloc(sizeof(struct equip_slot));
  slot = slot->next;
 }
 n = lookup_flag(slots, parser_getsym(p, "slot"));
 if (!n) {
  return PARSE_ERROR_INVALID_FLAG;
 }
 slot->type = n;
 slot->name = string_make(parser_getsym(p, "name"));
 b->count++;
 return PARSE_ERROR_NONE;
}
static struct parser *init_parse_body(void) {
 struct parser *p = parser_new();
 parser_setpriv(p, NULL);
 parser_reg(p, "body str name", parse_body_body);
 parser_reg(p, "slot sym slot sym name", parse_body_slot);
 return p;
}
static errr run_parse_body(struct parser *p) {
 return parse_file_quit_not_found(p, "body");
}
static errr finish_parse_body(struct parser *p) {
 struct player_body *b;
 int i;
 bodies = parser_priv(p);
 /* Scan the list for the max slots */
 z_info->equip_slots_max = 0;
 for (b = bodies; b; b = b->next) {
  if (b->count > z_info->equip_slots_max)
   z_info->equip_slots_max = b->count;
 }
 /* Allocate the slot list and copy */
 for (b = bodies; b; b = b->next) {
  struct equip_slot *s_new;
  s_new = mem_zalloc(z_info->equip_slots_max * sizeof(*s_new));
  if (b->slots) {
   struct equip_slot *s_temp, *s_old = b->slots;
   /* Allocate space and copy */
   for (i = 0; i < z_info->equip_slots_max; i++) {
    memcpy(&s_new[i], s_old, sizeof(*s_old));
    s_old = s_old->next;
    if (!s_old) break;
   }
   /* Make next point correctly */
   for (i = 0; i < z_info->equip_slots_max; i++)
    if (s_new[i].next)
     s_new[i].next = &s_new[i + 1];
   /* Tidy up */
   s_old = b->slots;
   s_temp = s_old;
   while (s_temp) {
    s_temp = s_old->next;
    mem_free(s_old);
    s_old = s_temp;
   }
  }
  b->slots = s_new;
 }
 parser_destroy(p);
 return 0;
}
static void cleanup_body(void)
{
 struct player_body *b = bodies;
 struct player_body *next;
 int i;
 while (b) {
  next = b->next;
  string_free((char *)b->name);
  for (i = 0; i < b->count; i++)
   string_free((char *)b->slots[i].name);
  mem_free(b->slots);
  mem_free(b);
  b = next;
 }
}
struct file_parser body_parser = {
 "body",
 init_parse_body,
 run_parse_body,
 finish_parse_body,
 cleanup_body
};
/**
 * ------------------------------------------------------------------------
 * Initialize player histories
 * ------------------------------------------------------------------------ */
static struct history_chart *histories;
static struct history_chart *findchart(struct history_chart *hs,
            unsigned int idx) {
 for (; hs; hs = hs->next)
  if (hs->idx == idx)
   break;
 return hs;
}
static enum parser_error parse_history_chart(struct parser *p) {
 struct history_chart *oc = parser_priv(p);
 struct history_chart *c;
 struct history_entry *e = mem_zalloc(sizeof *e);
 unsigned int idx = parser_getuint(p, "chart");
 if (!(c = findchart(oc, idx))) {
  c = mem_zalloc(sizeof *c);
  c->next = oc;
  c->idx = idx;
  parser_setpriv(p, c);
 }
 e->isucc = parser_getint(p, "next");
 e->roll = parser_getint(p, "roll");
 e->next = c->entries;
 c->entries = e;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_history_phrase(struct parser *p) {
 struct history_chart *h = parser_priv(p);
 if (!h)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 assert(h->entries);
 h->entries->text = string_append(h->entries->text, parser_getstr(p, "text"));
 return PARSE_ERROR_NONE;
}
static struct parser *init_parse_history(void) {
 struct parser *p = parser_new();
 parser_setpriv(p, NULL);
 parser_reg(p, "chart uint chart int next int roll", parse_history_chart);
 parser_reg(p, "phrase str text", parse_history_phrase);
 return p;
}
static errr run_parse_history(struct parser *p) {
 return parse_file_quit_not_found(p, "history");
}
static errr finish_parse_history(struct parser *p) {
 struct history_chart *c;
 struct history_entry *e, *prev, *next;
 histories = parser_priv(p);
 /* Go fix up the entry successor pointers. We can't compute them at
	 * load-time since we may not have seen the successor history yet. Also,
	 * we need to put the entries in the right order; the parser actually
	 * stores them backwards, which is not desirable.
	 */
 for (c = histories; c; c = c->next) {
  e = c->entries;
  prev = NULL;
  while (e) {
   next = e->next;
   e->next = prev;
   prev = e;
   e = next;
  }
  c->entries = prev;
  for (e = c->entries; e; e = e->next) {
   if (!e->isucc)
    continue;
   e->succ = findchart(histories, e->isucc);
   if (!e->succ) {
    return -1;
   }
  }
 }
 parser_destroy(p);
 return 0;
}
static void cleanup_history(void)
{
 struct history_chart *c, *next_c;
 struct history_entry *e, *next_e;
 c = histories;
 while (c) {
  next_c = c->next;
  e = c->entries;
  while (e) {
   next_e = e->next;
   mem_free(e->text);
   mem_free(e);
   e = next_e;
  }
  mem_free(c);
  c = next_c;
 }
}
struct file_parser history_parser = {
 "history",
 init_parse_history,
 run_parse_history,
 finish_parse_history,
 cleanup_history
};
/**
 * ------------------------------------------------------------------------
 * Initialize player sexes
 * ------------------------------------------------------------------------ */
static enum parser_error parse_sex_name(struct parser *p) {
 struct player_sex *h = parser_priv(p);
 struct player_sex *s = mem_zalloc(sizeof *s);
 s->next = h;
 s->name = string_make(parser_getstr(p, "name"));
 parser_setpriv(p, s);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_sex_possess(struct parser *p) {
 struct player_sex *s = parser_priv(p);
 if (!s)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 string_free((char*)s->possessive);
 s->possessive = string_make(parser_getstr(p, "pronoun"));
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_sex_poetry(struct parser *p) {
 struct player_sex *s = parser_priv(p);
 if (!s)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 string_free((char*)s->poetry_name);
 s->poetry_name = string_make(parser_getstr(p, "name"));
 return PARSE_ERROR_NONE;
}
static struct parser *init_parse_sex(void) {
 struct parser *p = parser_new();
 parser_setpriv(p, NULL);
 parser_reg(p, "name str name", parse_sex_name);
 parser_reg(p, "possess str pronoun", parse_sex_possess);
 parser_reg(p, "poetry str name", parse_sex_poetry);
 return p;
}
static errr run_parse_sex(struct parser *p) {
 return parse_file_quit_not_found(p, "sex");
}
static errr finish_parse_sex(struct parser *p) {
 struct player_sex *s;
 int num = 0;
 sexes = parser_priv(p);
 for (s = sexes; s; s = s->next) num++;
 for (s = sexes; s; s = s->next, num--) {
  assert(num);
  s->sidx = num - 1;
 }
 parser_destroy(p);
 return 0;
}
static void cleanup_sex(void)
{
 struct player_sex *s = sexes;
 struct player_sex *next;
 while (s) {
  next = s->next;
  string_free((char *)s->poetry_name);
  string_free((char *)s->possessive);
  string_free((char *)s->name);
  mem_free(s);
  s = next;
 }
}
struct file_parser sex_parser = {
 "sex",
 init_parse_sex,
 run_parse_sex,
 finish_parse_sex,
 cleanup_sex
};
/**
 * ------------------------------------------------------------------------
 * Initialize player races
 * ------------------------------------------------------------------------ */
static enum parser_error parse_race_name(struct parser *p) {
 struct player_race *h = parser_priv(p);
 struct player_race *r = mem_zalloc(sizeof *r);
 r->next = h;
 r->name = string_make(parser_getstr(p, "name"));
 /* Default body is humanoid */
 r->body = 0;
 parser_setpriv(p, r);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_race_stats(struct parser *p) {
 struct player_race *r = parser_priv(p);
 if (!r)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 r->stat_adj[STAT_STR] = parser_getint(p, "str");
 r->stat_adj[STAT_DEX] = parser_getint(p, "dex");
 r->stat_adj[STAT_CON] = parser_getint(p, "con");
 r->stat_adj[STAT_GRA] = parser_getint(p, "gra");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_race_skills(struct parser *p) {
 struct player_race *r = parser_priv(p);
 if (!r)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 r->skill_adj[SKILL_MELEE] = parser_getint(p, "mel");
 r->skill_adj[SKILL_ARCHERY] = parser_getint(p, "arc");
 r->skill_adj[SKILL_EVASION] = parser_getint(p, "evn");
 r->skill_adj[SKILL_STEALTH] = parser_getint(p, "stl");
 r->skill_adj[SKILL_PERCEPTION] = parser_getint(p, "per");
 r->skill_adj[SKILL_WILL] = parser_getint(p, "wil");
 r->skill_adj[SKILL_SMITHING] = parser_getint(p, "smt");
 r->skill_adj[SKILL_SONG] = parser_getint(p, "sng");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_race_history(struct parser *p) {
 struct player_race *r = parser_priv(p);
 if (!r)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 r->history = findchart(histories, parser_getuint(p, "hist"));
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_race_age(struct parser *p) {
 struct player_race *r = parser_priv(p);
 if (!r)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 r->b_age = parser_getint(p, "base_age");
 r->m_age = parser_getint(p, "mod_age");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_race_height(struct parser *p) {
 struct player_race *r = parser_priv(p);
 if (!r)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 r->base_hgt = parser_getint(p, "base_hgt");
 r->mod_hgt = parser_getint(p, "mod_hgt");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_race_weight(struct parser *p) {
 struct player_race *r = parser_priv(p);
 if (!r)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 r->base_wgt = parser_getint(p, "base_wgt");
 r->mod_wgt = parser_getint(p, "mod_wgt");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_race_play_flags(struct parser *p) {
 struct player_race *r = parser_priv(p);
 char *flags;
 char *s;
 if (!r)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 if (!parser_hasval(p, "flags"))
  return PARSE_ERROR_NONE;
 flags = string_make(parser_getstr(p, "flags"));
 s = strtok(flags, " |");
 while (s) {
  if (grab_flag(r->pflags, PF_SIZE, player_info_flags, s))
   break;
  s = strtok(NULL, " |");
 }
 string_free(flags);
 return s ? PARSE_ERROR_INVALID_FLAG : PARSE_ERROR_NONE;
}
static enum parser_error parse_race_equip(struct parser *p) {
 struct player_race *r = parser_priv(p);
 struct start_item *si;
 int tval, sval;
 if (!r)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 tval = tval_find_idx(parser_getsym(p, "tval"));
 if (tval < 0)
  return PARSE_ERROR_UNRECOGNISED_TVAL;
 sval = lookup_sval(tval, parser_getsym(p, "sval"));
 if (sval < 0)
  return PARSE_ERROR_UNRECOGNISED_SVAL;
 si = mem_zalloc(sizeof *si);
 si->tval = tval;
 si->sval = sval;
 si->min = parser_getuint(p, "min");
 si->max = parser_getuint(p, "max");
 if (si->min > 99 || si->max > 99) {
  mem_free(si);
  return PARSE_ERROR_INVALID_ITEM_NUMBER;
 }
 si->next = r->start_items;
 r->start_items = si;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_race_desc(struct parser *p) {
 struct player_race *r = parser_priv(p);
 if (!r)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 r->desc = string_append((char *)r->desc, parser_getstr(p, "desc"));
 return PARSE_ERROR_NONE;
}
static struct parser *init_parse_race(void) {
 struct parser *p = parser_new();
 parser_setpriv(p, NULL);
 parser_reg(p, "name str name", parse_race_name);
 parser_reg(p, "stats int str int dex int con int gra", parse_race_stats);
 parser_reg(p, "skills int mel int arc int evn int stl int per int wil int smt int sng", parse_race_skills);
 parser_reg(p, "history uint hist", parse_race_history);
 parser_reg(p, "age int base_age int mod_age", parse_race_age);
 parser_reg(p, "height int base_hgt int mod_hgt", parse_race_height);
 parser_reg(p, "weight int base_wgt int mod_wgt", parse_race_weight);
 parser_reg(p, "player-flags ?str flags", parse_race_play_flags);
 parser_reg(p, "equip sym tval sym sval uint min uint max",
      parse_race_equip);
 parser_reg(p, "desc str desc", parse_race_desc);
 return p;
}
static errr run_parse_race(struct parser *p) {
 return parse_file_quit_not_found(p, "race");
}
static errr finish_parse_race(struct parser *p) {
 struct player_race *r;
 int num = 0;
 races = parser_priv(p);
 for (r = races; r; r = r->next) num++;
 for (r = races; r; r = r->next, num--) {
  assert(num);
  r->ridx = num - 1;
 }
 parser_destroy(p);
 return 0;
}
static void cleanup_race(void)
{
 struct player_race *r = races;
 struct player_race *next;
 struct start_item *item, *item_next;
 while (r) {
  next = r->next;
  item = r->start_items;
  while(item) {
   item_next = item->next;
   mem_free(item);
   item = item_next;
  }
  string_free((char *)r->name);
  string_free((char *)r->desc);
  mem_free(r);
  r = next;
 }
}
struct file_parser race_parser = {
 "race",
 init_parse_race,
 run_parse_race,
 finish_parse_race,
 cleanup_race
};
/**
 * ------------------------------------------------------------------------
 * Initialize player houses
 * ------------------------------------------------------------------------ */
static enum parser_error parse_house_name(struct parser *p) {
 struct player_house *n = parser_priv(p);
 struct player_house *h = mem_zalloc(sizeof *h);
 h->name = string_make(parser_getstr(p, "name"));
 h->next = n;
 parser_setpriv(p, h);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_house_alt_name(struct parser *p) {
 struct player_house *h = parser_priv(p);
 if (!h) return PARSE_ERROR_MISSING_RECORD_HEADER;
 string_free((char*)h->alt_name);
 h->alt_name = string_make(parser_getstr(p, "name"));
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_house_short_name(struct parser *p) {
 struct player_house *h = parser_priv(p);
 if (!h) return PARSE_ERROR_MISSING_RECORD_HEADER;
 string_free((char*)h->short_name);
 h->short_name = string_make(parser_getstr(p, "name"));
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_house_race(struct parser *p) {
 struct player_house *h = parser_priv(p);
 struct player_race *r;
 const char *race_name = parser_getstr(p, "name");
 if (!h) return PARSE_ERROR_MISSING_RECORD_HEADER;
 for (r = races; r; r = r->next) {
  if (streq(r->name, race_name)) {
   h->race = r;
   break;
  }
 }
 if (!r) return PARSE_ERROR_INVALID_PLAYER_RACE;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_house_stats(struct parser *p) {
 struct player_house *h = parser_priv(p);
 if (!h)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 h->stat_adj[STAT_STR] = parser_getint(p, "str");
 h->stat_adj[STAT_DEX] = parser_getint(p, "dex");
 h->stat_adj[STAT_CON] = parser_getint(p, "con");
 h->stat_adj[STAT_GRA] = parser_getint(p, "gra");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_house_skills(struct parser *p) {
 struct player_house *h = parser_priv(p);
 if (!h)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 h->skill_adj[SKILL_MELEE] = parser_getint(p, "mel");
 h->skill_adj[SKILL_ARCHERY] = parser_getint(p, "arc");
 h->skill_adj[SKILL_EVASION] = parser_getint(p, "evn");
 h->skill_adj[SKILL_STEALTH] = parser_getint(p, "stl");
 h->skill_adj[SKILL_PERCEPTION] = parser_getint(p, "per");
 h->skill_adj[SKILL_WILL] = parser_getint(p, "wil");
 h->skill_adj[SKILL_SMITHING] = parser_getint(p, "smt");
 h->skill_adj[SKILL_SONG] = parser_getint(p, "sng");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_house_play_flags(struct parser *p) {
 struct player_house *h = parser_priv(p);
 char *flags;
 char *s;
 if (!h)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 if (!parser_hasval(p, "flags"))
  return PARSE_ERROR_NONE;
 flags = string_make(parser_getstr(p, "flags"));
 s = strtok(flags, " |");
 while (s) {
  if (grab_flag(h->pflags, PF_SIZE, player_info_flags, s))
   break;
  s = strtok(NULL, " |");
 }
 string_free(flags);
 return s ? PARSE_ERROR_INVALID_FLAG : PARSE_ERROR_NONE;
}
static enum parser_error parse_house_desc(struct parser *p) {
 struct player_house *h = parser_priv(p);
 if (!h)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 h->desc = string_append((char *)h->desc, parser_getstr(p, "desc"));
 return PARSE_ERROR_NONE;
}
static struct parser *init_parse_house(void) {
 struct parser *p = parser_new();
 parser_setpriv(p, NULL);
 parser_reg(p, "name str name", parse_house_name);
 parser_reg(p, "alt-name str name", parse_house_alt_name);
 parser_reg(p, "short-name str name", parse_house_short_name);
 parser_reg(p, "race str name", parse_house_race);
 parser_reg(p, "stats int str int dex int con int gra", parse_house_stats);
 parser_reg(p, "skills int mel int arc int evn int stl int per int wil int smt int sng", parse_house_skills);
 parser_reg(p, "player-flags ?str flags", parse_house_play_flags);
 parser_reg(p, "desc str desc", parse_house_desc);
 return p;
}
static errr run_parse_house(struct parser *p) {
 return parse_file_quit_not_found(p, "house");
}
static errr finish_parse_house(struct parser *p) {
 struct player_house *h;
 int num = 0;
 houses = parser_priv(p);
 for (h = houses; h; h = h->next) num++;
 for (h = houses; h; h = h->next, num--) {
  assert(num);
  h->hidx = num - 1;
 }
 parser_destroy(p);
 return 0;
}
static void cleanup_house(void)
{
 struct player_house *h = houses;
 struct player_house *next;
 while (h) {
  next = h->next;
  string_free((char *)h->name);
  string_free((char *)h->alt_name);
  string_free((char *)h->short_name);
  string_free((char *)h->desc);
  mem_free(h);
  h = next;
 }
}
struct file_parser house_parser = {
 "house",
 init_parse_house,
 run_parse_house,
 finish_parse_house,
 cleanup_house
};
/**
 * ------------------------------------------------------------------------
 * Initialize random names
 * ------------------------------------------------------------------------ */
struct name {
 struct name *next;
 char *str;
};
struct names_parse {
 unsigned int section;
 unsigned int nnames[RANDNAME_NUM_TYPES];
 struct name *names[RANDNAME_NUM_TYPES];
};
static enum parser_error parse_names_section(struct parser *p) {
 unsigned int section = parser_getuint(p, "section");
 struct names_parse *s = parser_priv(p);
 if (section >= RANDNAME_NUM_TYPES) {
  return PARSE_ERROR_OUT_OF_BOUNDS;
 }
 s->section = section;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_names_word(struct parser *p) {
 const char *name = parser_getstr(p, "name");
 struct names_parse *s = parser_priv(p);
 struct name *ns = mem_zalloc(sizeof *ns);
 s->nnames[s->section]++;
 ns->next = s->names[s->section];
 ns->str = string_make(name);
 s->names[s->section] = ns;
 return PARSE_ERROR_NONE;
}
static struct parser *init_parse_names(void) {
 struct parser *p = parser_new();
 struct names_parse *n = mem_zalloc(sizeof *n);
 n->section = 0;
 parser_setpriv(p, n);
 parser_reg(p, "section uint section", parse_names_section);
 parser_reg(p, "word str name", parse_names_word);
 return p;
}
static errr run_parse_names(struct parser *p) {
 return parse_file_quit_not_found(p, "names");
}
static errr finish_parse_names(struct parser *p) {
 int i;
 unsigned int j;
 struct names_parse *n = parser_priv(p);
 struct name *nm;
 name_sections = mem_zalloc(sizeof(char**) * RANDNAME_NUM_TYPES);
 for (i = 0; i < RANDNAME_NUM_TYPES; i++) {
  name_sections[i] = mem_alloc(sizeof(char*) * (n->nnames[i] + 1));
  for (nm = n->names[i], j = 0; nm && j < n->nnames[i]; nm = nm->next, j++) {
   name_sections[i][j] = nm->str;
  }
  name_sections[i][n->nnames[i]] = NULL;
  while (n->names[i]) {
   nm = n->names[i]->next;
   mem_free(n->names[i]);
   n->names[i] = nm;
  }
 }
 mem_free(n);
 parser_destroy(p);
 return 0;
}
static void cleanup_names(void)
{
 int i, j;
 for (i = 0; i < RANDNAME_NUM_TYPES; i++) {
  for (j = 0; name_sections[i][j]; j++) {
   string_free((char *)name_sections[i][j]);
  }
  mem_free(name_sections[i]);
 }
 mem_free(name_sections);
}
struct file_parser names_parser = {
 "names",
 init_parse_names,
 run_parse_names,
 finish_parse_names,
 cleanup_names
};
/**
 * ------------------------------------------------------------------------
 * Initialize flavors
 * ------------------------------------------------------------------------ */
static wchar_t flavor_glyph;
static unsigned int flavor_tval;
static enum parser_error parse_flavor_flavor(struct parser *p) {
 struct flavor *h = parser_priv(p);
 struct flavor *f = mem_zalloc(sizeof *f);
 const char *attr;
 int d_attr;
 f->next = h;
 f->fidx = parser_getuint(p, "index");
 f->tval = flavor_tval;
 f->d_char = flavor_glyph;
 if (parser_hasval(p, "sval"))
  f->sval = lookup_sval(f->tval, parser_getsym(p, "sval"));
 else
  f->sval = SV_UNKNOWN;
 attr = parser_getsym(p, "attr");
 if (strlen(attr) == 1)
  d_attr = color_char_to_attr(attr[0]);
 else
  d_attr = color_text_to_attr(attr);
 if (d_attr < 0)
  return PARSE_ERROR_INVALID_COLOR;
 f->d_attr = d_attr;
 if (parser_hasval(p, "desc"))
  f->text = string_append(f->text, parser_getstr(p, "desc"));
 parser_setpriv(p, f);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_flavor_kind(struct parser *p) {
 int tval = tval_find_idx(parser_getsym(p, "tval"));
 if (tval <= 0) {
  return PARSE_ERROR_UNRECOGNISED_TVAL;
 }
 flavor_glyph = parser_getchar(p, "glyph");
 flavor_tval = tval;
 return PARSE_ERROR_NONE;
}
static struct parser *init_parse_flavor(void) {
 struct parser *p = parser_new();
 parser_setpriv(p, NULL);
 parser_reg(p, "kind sym tval char glyph", parse_flavor_kind);
 parser_reg(p, "flavor uint index sym attr ?str desc", parse_flavor_flavor);
 parser_reg(p, "fixed uint index sym sval sym attr ?str desc", parse_flavor_flavor);
 return p;
}
static errr run_parse_flavor(struct parser *p) {
 return parse_file_quit_not_found(p, "flavor");
}
static errr finish_parse_flavor(struct parser *p) {
 flavors = parser_priv(p);
 parser_destroy(p);
 return 0;
}
static void cleanup_flavor(void)
{
 struct flavor *f, *next;
 f = flavors;
 while(f) {
  next = f->next;
  string_free(f->text);
  mem_free(f);
  f = next;
 }
}
struct file_parser flavor_parser = {
 "flavor",
 init_parse_flavor,
 run_parse_flavor,
 finish_parse_flavor,
 cleanup_flavor
};
/**
 * ------------------------------------------------------------------------
 * Game data initialization
 * ------------------------------------------------------------------------ */
/**
 * A list of all the above parsers, plus those found in mon-init.c and
 * obj-init.c
 */
static struct {
 const char *name;
 struct file_parser *parser;
} pl[] = {
 { "world", &world_parser },
 { "projections", &projection_parser },
 { "features", &feat_parser },
 { "slays", &slay_parser },
 { "brands", &brand_parser },
 { "object bases", &object_base_parser },
 { "monster pain messages", &pain_parser },
 { "monster pursuit messages", &pursuit_parser },
 { "monster warning messages", &warning_parser },
 { "monster bases", &mon_base_parser },
 { "summons", &summon_parser },
 { "objects", &object_parser },
 { "abilities", &ability_parser },
 { "ego-items", &ego_parser },
 { "history charts", &history_parser },
 { "bodies", &body_parser },
 { "player races", &race_parser },
 { "player houses", &house_parser },
 { "player sexes", &sex_parser },
 { "artifacts", &artifact_parser },
 { "drops", &drop_parser },
 { "object properties", &object_property_parser },
 { "timed effects", &player_timed_parser },
 { "blow methods", &meth_parser },
 { "blow effects", &eff_parser },
 { "monster spells", &mon_spell_parser },
 { "monsters", &monster_parser },
 { "monster lore" , &lore_parser },
 { "traps", &trap_parser },
 { "songs", &song_parser },
 { "chest_traps", &chest_trap_parser },
 { "flavours", &flavor_parser },
 { "random names", &names_parser }
};
/**
 * Initialize just the internal arrays.
 * This should be callable by the test suite, without relying on input, or
 * anything to do with a user or savefiles.
 *
 * Assumption: Paths are set up correctly before calling this function.
 */
void init_arrays(void)
{
 unsigned int i;
 for (i = 0; i < N_ELEMENTS(pl); i++) {
  char *msg = string_make(format("Initializing %s...", pl[i].name));
  event_signal_message(EVENT_INITSTATUS, 0, msg);
  string_free(msg);
  if (run_parser(pl[i].parser))
   quit_fmt("Cannot initialize %s.", pl[i].name);
 }
}
/**
 * Free all the internal arrays
 */
static void cleanup_arrays(void)
{
 unsigned int i;
 for (i = 1; i < N_ELEMENTS(pl); i++)
  cleanup_parser(pl[i].parser);
 cleanup_parser(pl[0].parser);
}
static struct init_module arrays_module = {
 .name = "arrays",
 .init = init_arrays,
 .cleanup = cleanup_arrays
};
extern struct init_module z_quark_module;
extern struct init_module generate_module;
extern struct init_module rune_module;
extern struct init_module obj_make_module;
extern struct init_module ignore_module;
extern struct init_module mon_make_module;
extern struct init_module player_module;
extern struct init_module store_module;
extern struct init_module messages_module;
extern struct init_module options_module;
extern struct init_module ui_equip_cmp_module;
extern struct init_module tutorial_module;
static struct init_module *modules[] = {
 &z_quark_module,
 &messages_module,
 &arrays_module,
 &generate_module,
 &player_module,
 &rune_module,
 &obj_make_module,
 &ignore_module,
 &mon_make_module,
 &options_module,
 &tutorial_module,
 NULL
};
/**
 * Initialise Angband's data stores and allocate memory for structures,
 * etc, so that the game can get started.
 *
 * The only input/output in this file should be via event_signal_string().
 * We cannot rely on any particular UI as this part should be UI-agnostic.
 * We also cannot rely on anything else having being initialised into any
 * particlar state.  Which is why you'd be calling this function in the
 * first place.
 *
 * Old comment, not sure if still accurate:
 * Note that the "graf-xxx.prf" file must be loaded separately,
 * if needed, in the first (?) pass through "TERM_XTRA_REACT".
 */
bool init_angband(void)
{
 int i;
 event_signal(EVENT_ENTER_INIT);
 init_game_constants();
 /* Initialise modules */
 for (i = 0; modules[i]; i++)
  if (modules[i]->init)
   modules[i]->init();
 /* Initialise field-of-fire (should be rewritten, or a module - NRM) */
 (void) vinfo_init();
 /* Initialize some other things */
 event_signal_message(EVENT_INITSTATUS, 0, "Initializing other stuff...");
 /* List display codes */
 monster_list_init();
 object_list_init();
 /* Initialise RNG */
 event_signal_message(EVENT_INITSTATUS, 0, "Getting the dice rolling...");
 Rand_init();
 return true;
}
/**
 * Free all the stuff initialised in init_angband()
 */
void cleanup_angband(void)
{
 int i;
 for (i = 0; modules[i]; i++)
  if (modules[i]->cleanup)
   modules[i]->cleanup();
 event_remove_all_handlers();
 /* Free the main cave */
 if (cave) {
  forget_fire(cave);
  cave_free(cave);
  cave = NULL;
 }
 monster_list_finalize();
 object_list_finalize();
 cleanup_game_constants();
 cmdq_release();
 if (play_again) return;
 /* Free the format() buffer */
 vformat_kill();
 /* Free the directories */
 string_free(ANGBAND_DIR_GAMEDATA);
 string_free(ANGBAND_DIR_CUSTOMIZE);
 string_free(ANGBAND_DIR_HELP);
 string_free(ANGBAND_DIR_SCREENS);
 string_free(ANGBAND_DIR_FONTS);
 string_free(ANGBAND_DIR_TILES);
 string_free(ANGBAND_DIR_SOUNDS);
 string_free(ANGBAND_DIR_ICONS);
 string_free(ANGBAND_DIR_USER);
 string_free(ANGBAND_DIR_SAVE);
 string_free(ANGBAND_DIR_PANIC);
 string_free(ANGBAND_DIR_SCORES);
 string_free(ANGBAND_DIR_ARCHIVE);
}
/**
 * \file load.c
 * \brief Individual loading functions
 *
 * Copyright (c) 1997 Ben Harrison, and others
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Dungeon constants
 */
static uint8_t square_size = 0;
/**
 * Player constants
 */
static uint8_t hist_size = 0;
/**
 * Object constants
 */
static uint8_t obj_mod_max = 0;
static uint8_t of_size = 0;
static uint8_t elem_max = 0;
static uint8_t brand_max;
static uint8_t slay_max;
/**
 * Monster constants
 */
static uint8_t mflag_size = 0;
/**
 * Trap constants
 */
static uint8_t trf_size = 0;
/**
 * Read an object.
 */
static struct object *rd_item(void)
{
 struct object *obj = object_new();
 uint8_t tmp8u;
 uint16_t tmp16u;
 size_t i;
 char buf[128];
 rd_u16b(&tmp16u);
 /* Unused */
 rd_byte(&tmp8u);
 if (tmp16u != 0xffff)
  return NULL;
 rd_u16b(&obj->oidx);
 /* Location */
 rd_byte(&tmp8u);
 obj->grid.y = tmp8u;
 rd_byte(&tmp8u);
 obj->grid.x = tmp8u;
 /* Type/Subtype */
 rd_string(buf, sizeof(buf));
 if (buf[0]) {
  obj->tval = tval_find_idx(buf);
 }
 rd_string(buf, sizeof(buf));
 if (buf[0]) {
  obj->sval = lookup_sval(obj->tval, buf);
 }
 /* Image Type/Subtype */
 rd_string(buf, sizeof(buf));
 if (buf[0]) {
  int tv, sv;
  tv = tval_find_idx(buf);
  rd_string(buf, sizeof(buf));
  if (buf[0]) {
   sv = lookup_sval(tv, buf);
   obj->image_kind = lookup_kind(tv, sv);
  }
 }
 rd_s16b(&obj->pval);
 rd_byte(&obj->number);
 rd_s16b(&obj->weight);
 rd_string(buf, sizeof(buf));
 if (buf[0]) {
  obj->artifact = lookup_artifact_name(buf);
  if (!obj->artifact) {
   note(format("Couldn't find artifact %s!", buf));
   return NULL;
  }
 }
 rd_string(buf, sizeof(buf));
 if (buf[0]) {
  obj->ego = lookup_ego_item(buf, obj->tval, obj->sval);
  if (!obj->ego) {
   note(format("Couldn't find ego item %s!", buf));
   return NULL;
  }
 }
 rd_s16b(&obj->timeout);
 rd_byte(&obj->used);
 rd_s16b(&obj->att);
 rd_byte(&obj->dd);
 rd_byte(&obj->ds);
 rd_s16b(&obj->evn);
 rd_byte(&obj->pd);
 rd_byte(&obj->ps);
 rd_byte(&obj->origin);
 rd_byte(&obj->origin_depth);
 rd_string(buf, sizeof(buf));
 if (buf[0]) {
  obj->origin_race = lookup_monster(buf);
 }
 rd_byte(&obj->notice);
 rd_byte(&obj->pseudo);
 for (i = 0; i < of_size; i++)
  rd_byte(&obj->flags[i]);
 for (i = 0; i < obj_mod_max; i++) {
  rd_s16b(&obj->modifiers[i]);
 }
 /* Read brands */
 rd_byte(&tmp8u);
 if (tmp8u) {
  obj->brands = mem_zalloc(z_info->brand_max * sizeof(bool));
  for (i = 0; i < brand_max; i++) {
   rd_byte(&tmp8u);
   obj->brands[i] = tmp8u ? true : false;
  }
 }
 /* Read slays */
 rd_byte(&tmp8u);
 if (tmp8u) {
  obj->slays = mem_zalloc(z_info->slay_max * sizeof(bool));
  for (i = 0; i < slay_max; i++) {
   rd_byte(&tmp8u);
   obj->slays[i] = tmp8u ? true : false;
  }
 }
 for (i = 0; i < elem_max; i++) {
  rd_s16b(&obj->el_info[i].res_level);
  rd_byte(&obj->el_info[i].flags);
 }
 /* Read the abilities */
 while (true) {
  struct ability *ability;
  rd_string(buf, sizeof(buf));
  if (streq(buf, "end")) break;
  rd_byte(&tmp8u);
  ability = lookup_ability(tmp8u, buf);
  if (ability == NULL) {
   note(format("Ability not found (%s).", buf));
   return NULL;
  }
  add_ability(&obj->abilities, ability);
 }
 /* Monster holding object */
 rd_s16b(&obj->held_m_idx);
 /* Read the inscription */
 rd_byte(&tmp8u);
 if (tmp8u) {
  rd_string(buf, sizeof(buf));
  if (buf[0]) obj->note = quark_add(buf);
 }
 /* Lookup item kind */
 obj->kind = lookup_kind(obj->tval, obj->sval);
 /* Check we have a kind */
 if ((!obj->tval && !obj->sval) || !obj->kind) {
  object_delete(NULL, NULL, &obj);
  return NULL;
 }
 /* Success */
 return obj;
}
/**
 * Read a monster
 */
static bool rd_monster(struct chunk *c, struct monster *mon)
{
 uint8_t tmp8u;
 uint16_t tmp16u;
 char race_name[80];
 size_t j;
 /* Read the monster race */
 rd_u16b(&tmp16u);
 mon->midx = tmp16u;
 rd_string(race_name, sizeof(race_name));
 mon->race = lookup_monster(race_name);
 if (!mon->race) {
  note(format("Monster race %s no longer exists!", race_name));
  return false;
 }
 rd_string(race_name, sizeof(race_name));
 if (streq(race_name, "none")) {
  mon->image_race = NULL;
 } else {
  mon->image_race = lookup_monster(race_name);
 }
 /* Read the other information */
 rd_byte(&tmp8u);
 mon->grid.y = tmp8u;
 rd_byte(&tmp8u);
 mon->grid.x = tmp8u;
 rd_s16b(&mon->hp);
 rd_s16b(&mon->maxhp);
 rd_byte(&mon->mana);
 rd_byte(&tmp8u);
 mon->song = song_by_idx(tmp8u);
 rd_s16b(&mon->alertness);
 rd_byte(&mon->mspeed);
 rd_byte(&mon->energy);
 rd_byte(&mon->origin);
 rd_byte(&mon->stance);
 rd_s16b(&mon->morale);
 rd_s16b(&mon->tmp_morale);
 rd_byte(&mon->noise);
 rd_byte(&mon->encountered);
 rd_byte(&tmp8u);
 for (j = 0; j < tmp8u; j++)
  rd_s16b(&mon->m_timed[j]);
 /* Read and extract the flag */
 for (j = 0; j < mflag_size; j++)
  rd_byte(&mon->mflag[j]);
 for (j = 0; j < of_size; j++)
  rd_s16b(&mon->known_pstate.flags[j]);
 for (j = 0; j < elem_max; j++)
  rd_s16b(&mon->known_pstate.el_info[j].res_level);
 for (j = 0; j < MAX_ACTION; j++)
  rd_byte(&mon->previous_action[j]);
 /* Read all the held objects (order is unimportant) */
 while (true) {
  struct object *obj = rd_item();
  if (!obj)
   break;
  pile_insert(&mon->held_obj, obj);
  assert(obj->oidx);
  assert(c->objects[obj->oidx] == NULL);
  c->objects[obj->oidx] = obj;
 }
 /* Read group info */
 rd_u16b(&tmp16u);
 mon->group_info.index = tmp16u;
 rd_byte(&tmp8u);
 mon->group_info.role = tmp8u;
 rd_byte(&tmp8u);
 mon->target.grid.y = tmp8u;
 rd_byte(&tmp8u);
 mon->target.grid.x = tmp8u;
 rd_byte(&mon->skip_this_turn);
 rd_byte(&mon->skip_next_turn);
 rd_s16b(&mon->consecutive_attacks);
 rd_s16b(&mon->turns_stationary);
 return true;
}
/**
 * Read a trap record
 */
static void rd_trap(struct trap *trap)
{
 int i;
 uint8_t tmp8u;
 char buf[80];
 rd_string(buf, sizeof(buf));
 if (buf[0]) {
  trap->kind = lookup_trap(buf);
  trap->t_idx = trap->kind->tidx;
 }
 rd_byte(&tmp8u);
 trap->grid.y = tmp8u;
 rd_byte(&tmp8u);
 trap->grid.x = tmp8u;
 rd_byte(&trap->power);
 for (i = 0; i < trf_size; i++)
  rd_byte(&trap->flags[i]);
}
/**
 * Read RNG state
 *
 * There were originally 64 bytes of randomizer saved. Now we only need
 * 32 + 5 bytes saved, so we'll read an extra 27 bytes at the end which won't
 * be used.
 */
int rd_randomizer(void)
{
 int i;
 uint32_t noop;
 /* current value for the simple RNG */
 rd_u32b(&Rand_value);
 /* state index */
 rd_u32b(&state_i);
 /* for safety, make sure state_i < RAND_DEG */
 state_i = state_i % RAND_DEG;
 /* RNG variables */
 rd_u32b(&z0);
 rd_u32b(&z1);
 rd_u32b(&z2);
 /* RNG state */
 for (i = 0; i < RAND_DEG; i++)
  rd_u32b(&STATE[i]);
 /* NULL padding */
 for (i = 0; i < 59 - RAND_DEG; i++)
  rd_u32b(&noop);
 Rand_quick = false;
 return 0;
}
/**
 * Read options.
 */
int rd_options(void)
{
 uint8_t b;
 /*** Special info */
 /* Read "delay_factor" */
 rd_byte(&b);
 player->opts.delay_factor = b;
 /* Read "hitpoint_warn" */
 rd_byte(&b);
 player->opts.hitpoint_warn = b;
 /* Read lazy movement delay */
 rd_byte(&b);
 player->opts.lazymove_delay = b;
 /* Read sidebar mode (if it's an actual game) */
 if (angband_term[0]) {
  rd_byte(&b);
  if (b >= SIDEBAR_MAX) b = SIDEBAR_LEFT;
  SIDEBAR_MODE = b;
 } else {
  strip_bytes(1);
 }
 /* Read options */
 while (1) {
  uint8_t value;
  char name[40];
  rd_string(name, sizeof name);
  if (!name[0])
   break;
  rd_byte(&value);
  option_set(name, !!value);
 }
 return 0;
}
/**
 * Read the saved messages
 */
int rd_messages(void)
{
 int i;
 char buf[128];
 uint16_t tmp16u;
 int16_t num;
 /* Total */
 rd_s16b(&num);
 /* Read the messages */
 for (i = 0; i < num; i++) {
  /* Read the message */
  rd_string(buf, sizeof(buf));
  /* Read the message type */
  rd_u16b(&tmp16u);
  /* Save the message */
  message_add(buf, tmp16u);
 }
 return 0;
}
/**
 * Read monster memory.
 */
int rd_monster_memory(void)
{
 uint16_t nkill, nsight;
 char buf[128];
 int i;
 /* Monster temporary flags */
 rd_byte(&mflag_size);
 /* Incompatible save files */
 if (mflag_size > MFLAG_SIZE) {
         note(format("Too many (%u) monster temporary flags!", mflag_size));
  return (-1);
 }
 /* Reset maximum numbers per level */
 for (i = 1; z_info && i < z_info->r_max; i++) {
  struct monster_race *race = &r_info[i];
  race->max_num = 100;
  if (rf_has(race->flags, RF_UNIQUE))
   race->max_num = 1;
 }
 rd_string(buf, sizeof(buf));
 while (!streq(buf, "No more monsters")) {
  struct monster_race *race = lookup_monster(buf);
  /* Get the kill and sight counts, skip if monster invalid */
  rd_u16b(&nkill);
  rd_u16b(&nsight);
  if (!race) continue;
  /* Store the kill count, ensure dead uniques stay dead */
  l_list[race->ridx].pkills = nkill;
  if (rf_has(race->flags, RF_UNIQUE) && nkill)
   race->max_num = 0;
  /* Store the sight count */
  l_list[race->ridx].psights = nsight;
  /* Look for the next monster */
  rd_string(buf, sizeof(buf));
 }
 return 0;
}
int rd_object_memory(void)
{
 size_t i;
 uint16_t tmp16u;
 /* Object Memory */
 rd_u16b(&tmp16u);
 if (tmp16u > z_info->k_max) {
  note(format("Too many (%u) object kinds!", tmp16u));
  return (-1);
 }
 /* Object flags */
 rd_byte(&of_size);
 if (of_size > OF_SIZE) {
         note(format("Too many (%u) object flags!", of_size));
  return (-1);
 }
 /* Object modifiers */
 rd_byte(&obj_mod_max);
 if (obj_mod_max > OBJ_MOD_MAX) {
         note(format("Too many (%u) object modifiers allowed!",
      obj_mod_max));
  return (-1);
 }
 /* Elements */
 rd_byte(&elem_max);
 if (elem_max > ELEM_MAX) {
         note(format("Too many (%u) elements allowed!", elem_max));
  return (-1);
 }
 /* Brands */
 rd_byte(&brand_max);
 if (brand_max > z_info->brand_max) {
         note(format("Too many (%u) brands allowed!", brand_max));
  return (-1);
 }
 /* Slays */
 rd_byte(&slay_max);
 if (slay_max > z_info->slay_max) {
         note(format("Too many (%u) slays allowed!", slay_max));
  return (-1);
 }
 /* Read the kind knowledge */
 for (i = 0; i < tmp16u; i++) {
  uint8_t tmp8u;
  struct object_kind *kind = &k_info[i];
  rd_byte(&tmp8u);
  kind->aware = (tmp8u & 0x01) ? true : false;
  kind->tried = (tmp8u & 0x02) ? true : false;
  kind->everseen = (tmp8u & 0x08) ? true : false;
  if (tmp8u & 0x04) kind_ignore_when_aware(kind);
  if (tmp8u & 0x10) kind_ignore_when_unaware(kind);
 }
 return 0;
}
/**
 * Read the player information
 */
int rd_player(void)
{
 int i;
 uint8_t tmp8u, num;
 uint8_t stat_max = 0;
 uint8_t skill_max = 0;
 uint16_t vault_max = 0;
 char buf[80];
 struct player_sex *s;
 struct player_race *r;
 struct player_house *h;
 rd_string(player->full_name, sizeof(player->full_name));
 rd_string(player->died_from, 80);
 player->history = mem_zalloc(250);
 rd_string(player->history, 250);
 /* Player race */
 rd_string(buf, sizeof(buf));
 for (r = races; r; r = r->next) {
  if (streq(r->name, buf)) {
   player->race = r;
   break;
  }
 }
 /* Verify player race */
 if (!player->race) {
  note(format("Invalid player race (%s).", buf));
  return -1;
 }
 /* Player house */
 rd_string(buf, sizeof(buf));
 for (h = houses; h; h = h->next) {
  if (streq(h->name, buf)) {
   player->house = h;
   break;
  }
 }
 if (!player->house) {
  note(format("Invalid player house (%s).", buf));
  return -1;
 }
 /* Player sex */
 rd_string(buf, sizeof(buf));
 for (s = sexes; s; s = s->next) {
  if (streq(s->name, buf)) {
   player->sex = s;
   break;
  }
 }
 if (!player->sex) {
  note(format("Invalid player sex (%s).", buf));
  return -1;
 }
 /* Numeric name suffix */
 rd_byte(&player->opts.name_suffix);
 /* Age/Height/Weight */
 rd_s16b(&player->game_type);
 rd_s16b(&player->age);
 rd_s16b(&player->ht);
 rd_s16b(&player->wt);
 rd_s16b(&player->ht_birth);
 rd_s16b(&player->wt_birth);
 /* Read the stat info */
 rd_byte(&stat_max);
 if (stat_max > STAT_MAX) {
  note(format("Too many stats (%d).", stat_max));
  return -1;
 }
 for (i = 0; i < stat_max; i++) rd_s16b(&player->stat_base[i]);
 for (i = 0; i < stat_max; i++) rd_s16b(&player->stat_drain[i]);
 /* Read the skill info */
 rd_byte(&skill_max);
 if (skill_max > SKILL_MAX) {
  note(format("Too many skills (%d).", skill_max));
  return -1;
 }
 for (i = 0; i < skill_max; i++) rd_s16b(&player->skill_base[i]);
 /* Read the abilities */
 while (true) {
  struct ability *ability;
  rd_string(buf, sizeof(buf));
  if (streq(buf, "end")) break;
  rd_byte(&tmp8u);
  ability = lookup_ability(tmp8u, buf);
  if (ability == NULL) {
   note(format("Ability not found (%s).", buf));
   return -1;
  }
  add_ability(&player->abilities, ability);
  rd_byte(&tmp8u);
  if (tmp8u) {
   struct ability *instance = player->abilities;
   instance = locate_ability(player->abilities, ability);
   instance->active = true;
  }
 }
 while (true) {
  struct ability *ability;
  rd_string(buf, sizeof(buf));
  if (streq(buf, "end")) break;
  rd_byte(&tmp8u);
  ability = lookup_ability(tmp8u, buf);
  if (ability == NULL) {
   note(format("Ability not found (%s).", buf));
   return -1;
  }
  add_ability(&player->item_abilities, ability);
  rd_byte(&tmp8u);
  if (tmp8u) {
   struct ability *instance = player->item_abilities;
   instance = locate_ability(player->item_abilities, ability);
   instance->active = true;
  }
 }
 /* Read the action list */
 for (i = 0; i < MAX_ACTION; i++) {
  rd_byte(&tmp8u);
  player->previous_action[i] = tmp8u;
 }
 /* Player body */
 rd_string(buf, sizeof(buf));
 player->body.name = string_make(buf);
 rd_u16b(&player->body.count);
 if (player->body.count > z_info->equip_slots_max) {
  note(format("Too many (%u) body parts!", player->body.count));
  return (-1);
 }
 player->body.slots = mem_zalloc(player->body.count *
         sizeof(struct equip_slot));
 for (i = 0; i < player->body.count; i++) {
  rd_u16b(&player->body.slots[i].type);
  rd_string(buf, sizeof(buf));
  player->body.slots[i].name = string_make(buf);
 }
 rd_s32b(&player->new_exp);
 rd_s32b(&player->exp);
 rd_s32b(&player->encounter_exp);
 rd_s32b(&player->kill_exp);
 rd_s32b(&player->descent_exp);
 rd_s32b(&player->ident_exp);
 rd_s32b(&player->turn);
 rd_s16b(&player->mhp);
 rd_s16b(&player->chp);
 rd_s16b(&player->msp);
 rd_s16b(&player->csp);
 rd_s16b(&player->max_depth);
 rd_u16b(&player->staircasiness);
 /* Hack -- Repair maximum dungeon level */
 if (player->max_depth < 0) player->max_depth = 1;
 /* Hack -- Reset cause of death */
 if (player->chp >= 0)
  my_strcpy(player->died_from, "(alive and well)",
      sizeof(player->died_from));
 rd_s16b(&player->energy);
 /* Total energy used so far */
 rd_u32b(&player->total_energy);
 /* # of turns spent resting */
 rd_u32b(&player->resting_turn);
 /* Find the number of timed effects */
 rd_byte(&num);
 if (num <= TMD_MAX) {
  /* Read all the effects */
  for (i = 0; i < num; i++)
   rd_s16b(&player->timed[i]);
  /* Initialize any entries not read */
  if (num < TMD_MAX)
   memset(player->timed + num, 0, (TMD_MAX - num) * sizeof(int16_t));
 } else {
  /* Probably in trouble anyway */
  for (i = 0; i < TMD_MAX; i++)
   rd_s16b(&player->timed[i]);
  /* Discard unused entries */
  strip_bytes(2 * (num - TMD_MAX));
  note("Discarded unsupported timed effects");
 }
 /* Greater vaults seen */
 rd_u16b(&vault_max);
 if (vault_max > z_info->v_max) {
  note(format("Too many (%u) vaults!", vault_max));
  return (-1);
 }
 for (i = 0; i < vault_max; i++) {
  rd_byte(&tmp8u);
  player->vaults[i] = tmp8u ? true : false;
 }
 /* More info */
 rd_byte(&player->unignoring);
 rd_s16b(&player->last_attack_m_idx);
 rd_s16b(&player->consecutive_attacks);
 rd_s16b(&player->bane_type);
 rd_byte(&tmp8u);
 player->focused = tmp8u ? true : false;
 rd_byte(&tmp8u);
 player->song[SONG_MAIN] = song_by_idx(tmp8u);
 rd_byte(&tmp8u);
 player->song[SONG_MINOR] = song_by_idx(tmp8u);
 rd_s16b(&player->song_duration);
 rd_s16b(&player->wrath);
 rd_u16b(&player->stairs_taken);
 rd_u16b(&player->forge_drought);
 rd_u16b(&player->forge_count);
 rd_byte(&tmp8u);
 player->stealth_mode = tmp8u;
 rd_byte(&player->self_made_arts);
 rd_byte(&tmp8u);
 player->truce = tmp8u ? true : false;
 rd_byte(&player->morgoth_hits);
 rd_byte(&tmp8u);
 player->crown_hint = tmp8u ? true : false;
 rd_byte(&tmp8u);
 player->crown_shatter = tmp8u ? true : false;
 rd_byte(&tmp8u);
 player->cursed = tmp8u ? true : false;
 rd_byte(&tmp8u);
 player->on_the_run = tmp8u ? true : false;
 rd_byte(&tmp8u);
 player->morgoth_slain = tmp8u ? true : false;
 rd_byte(&tmp8u);
 player->escaped = tmp8u ? true : false;
 rd_u16b(&player->noscore);
 rd_s16b(&player->smithing_leftover);
 rd_byte(&tmp8u);
 player->unique_forge_made = tmp8u ? true : false;
 rd_byte(&tmp8u);
 player->unique_forge_seen = tmp8u ? true : false;
 return 0;
}
/**
 * Read ignore and autoinscription submenu for all known objects
 */
int rd_ignore(void)
{
 size_t i, j;
 uint8_t tmp8u = 24;
 uint16_t file_e_max;
 uint16_t itype_size;
 uint16_t inscriptions;
 /* Read how many ignore bytes we have */
 rd_byte(&tmp8u);
 /* Check against current number */
 if (tmp8u != ignore_size) {
  strip_bytes(tmp8u);
 } else {
  for (i = 0; i < ignore_size; i++)
   rd_byte(&ignore_level[i]);
 }
 /* Read the number of saved ego-item */
 rd_u16b(&file_e_max);
 rd_u16b(&itype_size);
 if (itype_size > ITYPE_SIZE) {
  note(format("Too many (%u) ignore bytes!", itype_size));
  return (-1);
 }
 for (i = 0; i < file_e_max; i++) {
  if (i < z_info->e_max) {
   bitflag flags, itypes[ITYPE_SIZE];
   /* Read and extract the everseen and aware flags */
   rd_byte(&flags);
   e_info[i].everseen = (flags & 0x02) ? true : false;
   e_info[i].aware = (flags & 0x04) ? true : false;
   /* Read and extract the ignore flags */
   for (j = 0; j < itype_size; j++)
    rd_byte(&itypes[j]);
   /* If number of ignore types has changed, don't set anything */
   if (itype_size == ITYPE_SIZE) {
    for (j = ITYPE_NONE; j < ITYPE_MAX; j++)
     if (itype_has(itypes, j))
      ego_ignore_toggle(i, j);
   }
  }
 }
 /* Read the current number of aware object auto-inscriptions */
 rd_u16b(&inscriptions);
 /* Read the aware object autoinscriptions array */
 for (i = 0; i < inscriptions; i++) {
  char tmp[80];
  uint8_t tval, sval;
  struct object_kind *k;
  rd_string(tmp, sizeof(tmp));
  tval = tval_find_idx(tmp);
  rd_string(tmp, sizeof(tmp));
  sval = lookup_sval(tval, tmp);
  k = lookup_kind(tval, sval);
  if (!k)
   quit_fmt("lookup_kind(%d, %d) failed", tval, sval);
  rd_string(tmp, sizeof(tmp));
  k->note_aware = quark_add(tmp);
 }
 /* Read the current number of unaware object auto-inscriptions */
 rd_u16b(&inscriptions);
 /* Read the unaware object autoinscriptions array */
 for (i = 0; i < inscriptions; i++) {
  char tmp[80];
  uint8_t tval, sval;
  struct object_kind *k;
  rd_string(tmp, sizeof(tmp));
  tval = tval_find_idx(tmp);
  rd_string(tmp, sizeof(tmp));
  sval = lookup_sval(tval, tmp);
  k = lookup_kind(tval, sval);
  if (!k)
   quit_fmt("lookup_kind(%d, %d) failed", tval, sval);
  rd_string(tmp, sizeof(tmp));
  k->note_unaware = quark_add(tmp);
 }
 return 0;
}
int rd_misc(void)
{
 size_t i;
 uint8_t tmp8u;
 /* Read the randart seed */
 rd_u32b(&seed_randart);
 /* Read the flavors seed */
 rd_u32b(&seed_flavor);
 flavor_init();
 /* Special stuff */
 rd_u16b(&player->noscore);
 /* Read "death" */
 rd_byte(&tmp8u);
 player->is_dead = tmp8u;
 /* Current turn */
 rd_s32b(&turn);
 /* Handle smithed artifact file parsing */
 if (player->self_made_arts > 0) {
  activate_randart_file();
  run_parser(&randart_parser);
  deactivate_randart_file();
 }
 /* Property knowledge */
 /* Flags */
 for (i = 0; i < OF_SIZE; i++)
  rd_byte(&player->obj_k->flags[i]);
 /* Modifiers */
 for (i = 0; i < OBJ_MOD_MAX; i++) {
  rd_s16b(&player->obj_k->modifiers[i]);
 }
 /* Elements */
 for (i = 0; i < ELEM_MAX; i++) {
  rd_s16b(&player->obj_k->el_info[i].res_level);
  rd_byte(&player->obj_k->el_info[i].flags);
 }
 /* Read brands */
 for (i = 0; i < brand_max; i++) {
  rd_byte(&tmp8u);
  player->obj_k->brands[i] = tmp8u ? true : false;
 }
 /* Read slays */
 for (i = 0; i < slay_max; i++) {
  rd_byte(&tmp8u);
  player->obj_k->slays[i] = tmp8u ? true : false;
 }
 /* Combat data */
 rd_s16b(&player->obj_k->att);
 rd_s16b(&player->obj_k->evn);
 rd_byte(&player->obj_k->pd);
 rd_byte(&player->obj_k->ps);
 rd_byte(&player->obj_k->dd);
 rd_byte(&player->obj_k->ds);
 return 0;
}
int rd_artifacts(void)
{
 int i;
 uint16_t tmp16u;
 const struct artifact *crown = lookup_artifact_name("of Morgoth");
 /* Load the Artifacts */
 rd_u16b(&tmp16u);
 if (tmp16u > z_info->a_max) {
  /* Saved number may be greater for dead characters, skip the check */
  if (!player->is_dead) {
   note(format("Too many (%u) artifacts!", tmp16u));
   return (-1);
  }
  tmp16u = z_info->a_max;
 } else if(tmp16u < z_info->a_max) {
  /*
		 * Tolerate getting fewer artifacts than expected, but if
		 * the additional artifacts are not at the end of the list,
		 * the loaded data for aup_info will not match up with the
		 * expanded set of artifacts.
		 */
  if (!player->is_dead) {
   note(format("Expected %u artifacts; got %u.",
    z_info->a_max, tmp16u));
  }
 }
 /* Read the artifact flags */
 for (i = 0; i < tmp16u; i++) {
  uint8_t tmp8u;
  rd_byte(&tmp8u);
  aup_info[i].created = tmp8u ? true : false;
  rd_byte(&tmp8u);
  aup_info[i].seen = tmp8u ? true : false;
  rd_byte(&tmp8u);
  aup_info[i].everseen = tmp8u ? true : false;
  rd_byte(&tmp8u);
 }
 /* Change Morgoth's stats if his crown has been knocked off */
 if (is_artifact_created(crown)) {
  struct monster_race *race = lookup_monster("Morgoth, Lord of Darkness");
  race->pd -= 1;
  race->light = 0;
  race->wil += 5;
  race->per += 5;
 }
 return 0;
}
/**
 * Read the player gear
 */
static int rd_gear_aux(struct object **gear)
{
 uint8_t code;
 struct object *last_gear_obj = NULL;
 /* Get the first item code */
 rd_byte(&code);
 /* Read until done */
 while (code != FINISHED_CODE) {
  struct object *obj = rd_item();
  /* Read the item */
  if (!obj) {
   note("Error reading item");
   return (-1);
  }
  /* Append the object */
  obj->prev = last_gear_obj;
  if (last_gear_obj)
   last_gear_obj->next = obj;
  else
   *gear = obj;
  last_gear_obj = obj;
  /* If it's equipment, wield it */
  if (code < player->body.count) {
   player->body.slots[code].obj = obj;
   player->upkeep->equip_cnt++;
  }
  /* Get the next item code */
  rd_byte(&code);
 }
 /* Success */
 return (0);
}
/**
 * Read the player gear - wrapper functions
 */
int rd_gear(void)
{
 struct object *obj, *known_obj;
 /* Get gear */
 if (rd_gear_aux(&player->gear))
  return -1;
 /* Get known gear */
 if (rd_gear_aux(&player->gear_k))
  return -1;
 /* Align the two, add weight */
 for (obj = player->gear, known_obj = player->gear_k; obj;
   obj = obj->next, known_obj = known_obj->next) {
  obj->known = known_obj;
  player->upkeep->total_weight +=
   obj->number * obj->weight;
 }
 calc_inventory(player);
 return 0;
}
/**
 * Read the dungeon
 *
 * The monsters/objects must be loaded in the same order
 * that they were stored, since the actual indexes matter.
 *
 * Note that the size of the dungeon is now the currrent dimensions of the
 * cave global variable.
 *
 * Note that dungeon objects, including objects held by monsters, are
 * placed directly into the dungeon, using "object_copy()", which will
 * copy "iy", "ix", and "held_m_idx", leaving "next_o_idx" blank for
 * objects held by monsters, since it is not saved in the savefile.
 *
 * After loading the monsters, the objects being held by monsters are
 * linked directly into those monsters.
 */
static int rd_dungeon_aux(struct chunk **c)
{
 struct chunk *c1;
 int i, n, y, x;
 uint16_t height, width;
 uint8_t count;
 uint8_t tmp8u;
 char name[100];
 /* Header info */
 rd_string(name, sizeof(name));
 rd_u16b(&height);
 rd_u16b(&width);
 /* We need a cave struct */
 c1 = cave_new(height, width);
 c1->name = string_make(name);
 rd_byte(&tmp8u);
 if (tmp8u) {
  rd_string(name, sizeof(name));
  c1->vault_name = string_make(name);
 }
    /* Run length decoding of cave->squares[y][x].info */
 for (n = 0; n < square_size; n++) {
  /* Load the dungeon data */
  for (x = y = 0; y < c1->height; ) {
   /* Grab RLE info */
   rd_byte(&count);
   rd_byte(&tmp8u);
   /* Apply the RLE info */
   for (i = count; i > 0; i--) {
    /* Extract "info" */
    c1->squares[y][x].info[n] = tmp8u;
    /* Advance/Wrap */
    if (++x >= c1->width) {
     /* Wrap */
     x = 0;
     /* Advance/Wrap */
     if (++y >= c1->height) break;
    }
   }
  }
 }
 /* Run length decoding of dungeon data */
 for (x = y = 0; y < c1->height; ) {
  /* Grab RLE info */
  rd_byte(&count);
  rd_byte(&tmp8u);
  /* Apply the RLE info */
  for (i = count; i > 0; i--) {
   /* Extract "feat" */
   square_set_feat(c1, loc(x, y), tmp8u);
   /* Advance/Wrap */
   if (++x >= c1->width) {
    /* Wrap */
    x = 0;
    /* Advance/Wrap */
    if (++y >= c1->height) break;
   }
  }
 }
 /* Assign */
 *c = c1;
 return 0;
}
/**
 * Read the floor object list
 */
static int rd_objects_aux(struct chunk *c)
{
 int i;
 /* Only if the player's alive */
 if (player->is_dead)
  return 0;
 /* Make the object list */
 rd_u16b(&c->obj_max);
 c->objects = mem_realloc(c->objects,
        (c->obj_max + 1) * sizeof(struct object*));
 for (i = 0; i <= c->obj_max; i++)
  c->objects[i] = NULL;
 /* Read the dungeon items until one isn't returned */
 while (true) {
  struct object *obj = rd_item();
  if (!obj)
   break;
  if (square_in_bounds_fully(c, obj->grid)) {
   pile_insert_end(&c->squares[obj->grid.y][obj->grid.x].obj, obj);
  }
  assert(obj->oidx);
  assert(c->objects[obj->oidx] == NULL);
  c->objects[obj->oidx] = obj;
 }
 return 0;
}
/**
 * Read monsters
 */
static int rd_monsters_aux(struct chunk *c)
{
 int i;
 uint16_t limit;
 /* Only if the player's alive */
 if (player->is_dead)
  return 0;
 /* Read the monster count */
 rd_u16b(&limit);
 if (limit > z_info->level_monster_max) {
  note(format("Too many (%d) monster entries!", limit));
  return (-1);
 }
 /* Read the monsters */
 for (i = 1; i < limit; i++) {
  struct monster *mon;
  struct monster monster_body;
  /* Get local monster */
  mon = &monster_body;
  memset(mon, 0, sizeof(*mon));
  /* Read the monster */
  if (!rd_monster(c, mon)) {
   note(format("Cannot read monster %d", i));
   return (-1);
  }
  /* Place monster in dungeon */
  if (place_monster(c, mon->grid, mon, mon->origin) != i) {
   note(format("Cannot place monster %d", i));
   return (-1);
  }
  /* Initialize flow */
  mon = cave_monster(c, mon->midx);
  flow_new(c, &mon->flow);
 }
 return 0;
}
static int rd_traps_aux(struct chunk *c)
{
 struct loc grid;
 struct trap *trap;
 /* Only if the player's alive */
 if (player->is_dead)
  return 0;
 rd_byte(&trf_size);
 /* Read traps until one has no location */
 while (true) {
  trap = mem_zalloc(sizeof(*trap));
  rd_trap(trap);
  grid = trap->grid;
  if (loc_is_zero(grid))
   break;
  else {
   /* Put the trap at the front of the grid trap list */
   trap->next = square_trap(c, grid);
   square_set_trap(c, grid, trap);
  }
 }
 mem_free(trap);
 return 0;
}
int rd_dungeon(void)
{
 uint16_t depth;
 uint16_t py, px;
 /* Header info */
 rd_u16b(&depth);
 rd_u16b(&daycount);
 rd_u16b(&py);
 rd_u16b(&px);
 rd_byte(&square_size);
 /* Only if the player's alive */
 if (player->is_dead)
  return 0;
 /* Ignore illegal dungeons */
 if (depth > z_info->dun_depth) {
  note(format("Ignoring illegal dungeon depth (%d)", depth));
  return (0);
 }
 if (rd_dungeon_aux(&cave))
  return 1;
 /* Ignore illegal dungeons */
 if ((px >= cave->width) || (py >= cave->height)) {
  note(format("Ignoring illegal player location (%d,%d).", py, px));
  return (1);
 }
 /* Load player depth */
 player->depth = depth;
 cave->depth = depth;
 /* Place player in dungeon */
 player_place(cave, player, loc(px, py));
 /* The dungeon is ready */
 character_dungeon = true;
 /* Read known cave */
 if (rd_dungeon_aux(&player->cave)) {
  return 1;
 }
 player->cave->depth = depth;
 return 0;
}
/**
 * Read the objects - wrapper functions
 */
int rd_objects(void)
{
 if (rd_objects_aux(cave))
  return -1;
 if (rd_objects_aux(player->cave))
  return -1;
 return 0;
}
/**
 * Read the monster list - wrapper functions
 */
int rd_monsters(void)
{
 int i;
 /* Only if the player's alive */
 if (player->is_dead)
  return 0;
 if (rd_monsters_aux(cave))
  return -1;
 if (rd_monsters_aux(player->cave))
  return -1;
 /* Associate known objects */
 for (i = 0; i < player->cave->obj_max; i++)
  if (cave->objects[i] && player->cave->objects[i])
   cave->objects[i]->known = player->cave->objects[i];
 return 0;
}
/**
 * Read the traps - wrapper functions
 */
int rd_traps(void)
{
 if (rd_traps_aux(cave))
  return -1;
 if (rd_traps_aux(player->cave))
  return -1;
 return 0;
}
int rd_history(void)
{
 uint32_t tmp32u;
 size_t i, j;
 history_clear(player);
 /* History type flags */
 rd_byte(&hist_size);
 if (hist_size > HIST_SIZE) {
         note(format("Too many (%u) history types!", hist_size));
  return (-1);
 }
 rd_u32b(&tmp32u);
 for (i = 0; i < tmp32u; i++) {
  int32_t turnno;
  int16_t dlev;
  bitflag type[HIST_SIZE];
  const struct artifact *art = NULL;
  int aidx = 0;
  char name[80];
  char text[80];
  for (j = 0; j < hist_size; j++)
   rd_byte(&type[j]);
  rd_s32b(&turnno);
  rd_s16b(&dlev);
  rd_string(name, sizeof(name));
  if (name[0]) {
   art = lookup_artifact_name(name);
   if (art) {
    aidx = art->aidx;
   }
  }
  rd_string(text, sizeof(text));
  if (name[0] && !art) {
   note(format("Couldn't find artifact %s!", name));
   continue;
  }
  history_add_full(player, type, aidx, dlev, turnno, text);
 }
 return 0;
}
/**
 * For blocks that don't need loading anymore.
 */
int rd_null(void) {
 return 0;
}
int rd_monster_groups(void)
{
 uint16_t tmp16u;
 uint8_t tmp8u;
 int16_t tmp16s;
 struct monster_group *group;
 /* Only if the player's alive */
 if (player->is_dead)
  return 0;
 /* Read the group flow centres and wandering pauses */
 rd_u16b(&tmp16u);
 while (tmp16u) {
  group = cave->monster_groups[tmp16u];
  rd_byte(&tmp8u);
  group->flow.centre.x = tmp8u;
  rd_byte(&tmp8u);
  group->flow.centre.y = tmp8u;
  rd_s16b(&tmp16s);
  group->wandering_pause = tmp16s;
  rd_u16b(&tmp16u);
 }
 return 0;
}
/**
 * \file message.c
 * \brief Message handling
 *
 * Copyright (c) 2007 Elly, Andi Sidwell
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
typedef struct _message_t
{
 char *str;
 struct _message_t *newer;
 struct _message_t *older;
 uint16_t type;
 uint16_t count;
} message_t;
typedef struct _msgcolor_t
{
 uint16_t type;
 uint8_t color;
 struct _msgcolor_t *next;
} msgcolor_t;
typedef struct _msgqueue_t
{
 message_t *head;
 message_t *tail;
 msgcolor_t *colors;
 uint32_t count;
 uint32_t max;
} msgqueue_t;
static msgqueue_t *messages = NULL;
/**
 * ------------------------------------------------------------------------
 * Functions operating on the entire list
 * ------------------------------------------------------------------------ */
/**
 * Initialise the messages package.  Should be called before using any other
 * functions in the package.
 */
void messages_init(void)
{
 messages = mem_zalloc(sizeof(msgqueue_t));
 messages->max = 2048;
}
/**
 * Free the message package.
 */
void messages_free(void)
{
 msgcolor_t *c = messages->colors;
 msgcolor_t *nextc;
 message_t *m = messages->head;
 message_t *nextm;
 while (m) {
  nextm = m->older;
  mem_free(m->str);
  mem_free(m);
  m = nextm;
 }
 while (c) {
  nextc = c->next;
  mem_free(c);
  c = nextc;
 }
 mem_free(messages);
}
/**
 * Return the current number of messages stored.
 */
uint16_t messages_num(void)
{
 return messages->count;
}
/**
 * ------------------------------------------------------------------------
 * Functions for individual messages
 * ------------------------------------------------------------------------ */
/**
 * Save a new message into the memory buffer, with text `str` and type `type`.
 * The type should be one of the MSG_ constants defined in message.h.
 *
 * The new message may not be saved if it is identical to the one saved before
 * it, in which case the "count" of the message will be increased instead.
 * This count can be fetched using the message_count() function.
 */
void message_add(const char *str, uint16_t type)
{
 message_t *m;
 if (messages->head &&
     messages->head->type == type &&
     streq(messages->head->str, str) &&
     messages->head->count != (uint16_t)-1) {
  messages->head->count++;
  return;
 }
 m = mem_zalloc(sizeof(message_t));
 m->str = string_make(str);
 m->type = type;
 m->count = 1;
 m->older = messages->head;
 if (messages->head)
  messages->head->newer = m;
 messages->head = m;
 messages->count++;
 if (!messages->tail)
  messages->tail = m;
 if (messages->count > messages->max) {
  message_t *old_tail = messages->tail;
  messages->tail = old_tail->newer;
  messages->tail->older = NULL;
  mem_free(old_tail->str);
  mem_free(old_tail);
  messages->count--;
 }
}
/**
 * Returns the message of age `age`.
 */
static message_t *message_get(uint16_t age)
{
 message_t *m = messages->head;
 while (m && age) {
  age--;
  m = m->older;
 }
 return m;
}
/**
 * Returns the text of the message of age `age`.  The age of the most recently
 * saved message is 0, the one before that is of age 1, etc.
 *
 * Returns the empty string if the no messages of the age specified are
 * available.
 */
const char *message_str(uint16_t age)
{
 message_t *m = message_get(age);
 return (m ? m->str : "");
}
/**
 * Returns the number of times the message of age `age` was saved. The age of
 * the most recently saved message is 0, the one before that is of age 1, etc.
 *
 * In other words, if message_add() was called five times, one after the other,
 * with the message "The orc sets your hair on fire.", then the text will only
 * have one age (age = 0), but will have a count of 5.
 */
uint16_t message_count(uint16_t age)
{
 message_t *m = message_get(age);
 return (m ? m->count : 0);
}
/**
 * Returns the type of the message of age `age`.  The age of the most recently
 * saved message is 0, the one before that is of age 1, etc.
 *
 * The type is one of the MSG_ constants, defined in message.h.
 */
uint16_t message_type(uint16_t age)
{
 message_t *m = message_get(age);
 return (m ? m->type : 0);
}
/**
 * Returns the display colour of the message memorised `age` messages ago.
 * (i.e. age = 0 represents the last memorised message, age = 1 is the one
 * before that, etc).
 */
uint8_t message_color(uint16_t age)
{
 message_t *m = message_get(age);
 return (m ? message_type_color(m->type) : COLOUR_WHITE);
}
/**
 * ------------------------------------------------------------------------
 * Message-color functions
 * ------------------------------------------------------------------------ */
/**
 * Defines the color `color` for the message type `type`.
 */
void message_color_define(uint16_t type, uint8_t color)
{
 msgcolor_t *mc;
 if (!messages->colors)
 {
  messages->colors = mem_zalloc(sizeof(msgcolor_t));
  messages->colors->type = type;
  messages->colors->color = color;
  return;
 }
 mc = messages->colors;
 while (1)
 {
  if (mc->type == type)
  {
   mc->color = color;
   break;
  }
  if (! mc->next) {
   mc->next = mem_zalloc(sizeof(msgcolor_t));
   mc->next->type = type;
   mc->next->color = color;
   break;
  }
  mc = mc->next;
 }
}
/**
 * Returns the colour for the message type `type`.
 */
uint8_t message_type_color(uint16_t type)
{
 msgcolor_t *mc;
 uint8_t color = COLOUR_WHITE;
 if (messages)
 {
  mc = messages->colors;
  while (mc && mc->type != type)
   mc = mc->next;
  if (mc && (mc->color != COLOUR_DARK))
   color = mc->color;
 }
 return color;
}
/**
 * Return the MSG_ flag that matches the given string. This does not handle
 * SOUND_MAX.
 *
 * \param name is a string that contains the name of a flag or a number.
 * \return The MSG_ flag that matches the given name.
 */
int message_lookup_by_name(const char *name)
{
 static const char *message_names[] = {
/**
 * \file list-message.h
 * \brief List of message types
 *
 * sound - the name, case-insensitive, of the entry in sound.prf (redundant)
 */
/* id					sound */
"GENERIC",
"BIRTH",
"HIT",
"MISS",
"FLEE",
"DROP",
"KILL",
"LEVEL",
"DEATH",
"STUDY",
"TELEPORT",
"SHOOT",
"QUAFF",
"ZAP_ROD",
"WALK",
"TPOTHER",
"HITWALL",
"EAT",
"STORE1",
"STORE2",
"STORE3",
"STORE4",
"DIG",
"OPENDOOR",
"SHUTDOOR",
"TPLEVEL",
"BELL",
"NOTHING_TO_OPEN",
"LOCKPICK_FAIL",
"STAIRS_DOWN",
"HITPOINT_WARN",
"ACT_ARTIFACT",
"USE_STAFF",
"DESTROY",
"MON_HIT",
"MON_TOUCH",
"MON_PUNCH",
"MON_KICK",
"MON_CLAW",
"MON_BITE",
"MON_STING",
"MON_BUTT",
"MON_CRUSH",
"MON_ENGULF",
"MON_CRAWL",
"MON_DROOL",
"MON_SPIT",
"MON_GAZE",
"MON_WAIL",
"MON_SPORE",
"MON_BEG",
"MON_INSULT",
"MON_MOAN",
"RECOVER",
"BLIND",
"CONFUSED",
"POISONED",
"AFRAID",
"PARALYZED",
"DRUGGED",
"SPEED",
"SLOW",
"SHIELD",
"BLESSED",
"HERO",
"BERSERK",
"BOLD",
"PROT_EVIL",
"INVULN",
"SEE_INVIS",
"INFRARED",
"RES_ACID",
"RES_ELEC",
"RES_FIRE",
"RES_COLD",
"RES_POIS",
"STUN",
"CUT",
"STAIRS_UP",
"STORE_ENTER",
"STORE_LEAVE",
"STORE_HOME",
"MONEY1",
"MONEY2",
"MONEY3",
"SHOOT_HIT",
"STORE5",
"LOCKPICK",
"DISARM",
"IDENT_BAD",
"IDENT_EGO",
"IDENT_ART",
"BR_ELEMENTS",
"BR_FROST",
"BR_ELEC",
"BR_ACID",
"BR_GAS",
"BR_FIRE",
"BR_DISEN",
"BR_CHAOS",
"BR_SHARDS",
"BR_SOUND",
"BR_LIGHT",
"BR_DARK",
"BR_NETHER",
"BR_NEXUS",
"BR_TIME",
"BR_INERTIA",
"BR_GRAVITY",
"BR_PLASMA",
"BR_FORCE",
"SUM_MONSTER",
"SUM_AINU",
"SUM_UNDEAD",
"SUM_ANIMAL",
"SUM_SPIDER",
"SUM_HOUND",
"SUM_HYDRA",
"SUM_DEMON",
"SUM_DRAGON",
"SUM_HI_UNDEAD",
"SUM_HI_DRAGON",
"SUM_HI_DEMON",
"SUM_WRAITH",
"SUM_UNIQUE",
"WIELD",
"QUIVER",
"CURSED",
"RUNE",
"HUNGRY",
"NOTICE",
"AMBIENT_DAY",
"AMBIENT_NITE",
"AMBIENT_DNG1",
"AMBIENT_DNG2",
"AMBIENT_DNG3",
"AMBIENT_DNG4",
"AMBIENT_DNG5",
"CREATE_TRAP",
"SHRIEK",
"CAST_FEAR",
"HIT_GOOD",
"HIT_GREAT",
"HIT_SUPERB",
"HIT_HI_GREAT",
"HIT_HI_SUPERB",
"SPELL",
"PRAYER",
"KILL_UNIQUE",
"KILL_KING",
"DRAIN_STAT",
"MULTIPLY",
"SCRAMBLE",
"MAX",

 };
 size_t i;
 char *pe;
 unsigned long number = strtoul(name, &pe, 10);
 if (pe != name) {
  return (contains_only_spaces(pe) && number < MSG_MAX) ?
   (int)number : -1;
 }
 for (i = 0; i < N_ELEMENTS(message_names); i++) {
  if (my_stricmp(name, message_names[i]) == 0)
   return (int)i;
 }
 return -1;
}
/**
 * Return the MSG_ flag that matches the given sound event name.
 *
 * \param name is the sound name from sound.prf.
 * \return The MSG_ flag for the corresponding sound.
 */
int message_lookup_by_sound_name(const char *name)
{
 static const char *sound_names[] = {
/**
 * \file list-message.h
 * \brief List of message types
 *
 * sound - the name, case-insensitive, of the entry in sound.prf (redundant)
 */
/* id					sound */
"",
"",
"hit",
"miss",
"flee",
"drop",
"kill",
"level",
"death",
"study",
"teleport",
"shoot",
"quaff",
"zap_rod",
"walk",
"tpother",
"hitwall",
"eat",
"store1",
"store2",
"store3",
"store4",
"dig",
"opendoor",
"shutdoor",
"tplevel",
"bell",
"nothing_to_open",
"lockpick_fail",
"stairs_down",
"hitpoint_warn",
"act_artifact",
"use_staff",
"destroy",
"mon_hit",
"mon_touch",
"mon_punch",
"mon_kick",
"mon_claw",
"mon_bite",
"mon_sting",
"mon_butt",
"mon_crush",
"mon_engulf",
"mon_crawl",
"mon_drool",
"mon_spit",
"mon_gaze",
"mon_wail",
"mon_spore",
"mon_beg",
"mon_insult",
"mon_moan",
"recover",
"blind",
"confused",
"poisoned",
"afraid",
"paralyzed",
"drugged",
"speed",
"slow",
"shield",
"blessed",
"hero",
"berserk",
"bold",
"prot_evil",
"invuln",
"see_invis",
"infrared",
"res_acid",
"res_elec",
"res_fire",
"res_cold",
"res_pois",
"stun",
"cut",
"stairs_up",
"store_enter",
"store_leave",
"store_home",
"money1",
"money2",
"money3",
"shoot_hit",
"store5",
"lockpick",
"disarm",
"identify_bad",
"identify_ego",
"identify_art",
"breathe_elements",
"breathe_frost",
"breathe_elec",
"breathe_acid",
"breathe_gas",
"breathe_fire",
"breathe_disenchant",
"breathe_chaos",
"breathe_shards",
"breathe_sound",
"breathe_light",
"breathe_dark",
"breathe_nether",
"breathe_nexus",
"breathe_time",
"breathe_inertia",
"breathe_gravity",
"breathe_plasma",
"breathe_force",
"summon_monster",
"summon_ainu",
"summon_undead",
"summon_animal",
"summon_spider",
"summon_hound",
"summon_hydra",
"summon_demon",
"summon_dragon",
"summon_gr_undead",
"summon_gr_dragon",
"summon_gr_demon",
"summon_ringwraith",
"summon_unique",
"wield",
"quiver",
"cursed",
"rune",
"hungry",
"notice",
"ambient_day",
"ambient_nite",
"ambient_dng1",
"ambient_dng2",
"ambient_dng3",
"ambient_dng4",
"ambient_dng5",
"mon_create_trap",
"mon_shriek",
"mon_cast_fear",
"hit_good",
"hit_great",
"hit_superb",
"hit_hi_great",
"hit_hi_superb",
"cast_spell",
"pray_prayer",
"kill_unique",
"kill_king",
"drain_stat",
"multiply",
"scramble",
NULL,

 };
 size_t i;
 /* Exclude MSG_MAX since it has NULL for the sound's name. */
 for (i = 0; i < N_ELEMENTS(sound_names) - 1; i++) {
  if (my_stricmp(name, sound_names[i]) == 0)
   return (int)i;
 }
 return MSG_GENERIC;
}
/**
 * Return the sound name for the given message.
 *
 * \param message is the MSG_ flag to find.
 * \return The sound.prf sound name.
 */
const char *message_sound_name(int message)
{
 static const char *sound_names[] = {
/**
 * \file list-message.h
 * \brief List of message types
 *
 * sound - the name, case-insensitive, of the entry in sound.prf (redundant)
 */
/* id					sound */
"",
"",
"hit",
"miss",
"flee",
"drop",
"kill",
"level",
"death",
"study",
"teleport",
"shoot",
"quaff",
"zap_rod",
"walk",
"tpother",
"hitwall",
"eat",
"store1",
"store2",
"store3",
"store4",
"dig",
"opendoor",
"shutdoor",
"tplevel",
"bell",
"nothing_to_open",
"lockpick_fail",
"stairs_down",
"hitpoint_warn",
"act_artifact",
"use_staff",
"destroy",
"mon_hit",
"mon_touch",
"mon_punch",
"mon_kick",
"mon_claw",
"mon_bite",
"mon_sting",
"mon_butt",
"mon_crush",
"mon_engulf",
"mon_crawl",
"mon_drool",
"mon_spit",
"mon_gaze",
"mon_wail",
"mon_spore",
"mon_beg",
"mon_insult",
"mon_moan",
"recover",
"blind",
"confused",
"poisoned",
"afraid",
"paralyzed",
"drugged",
"speed",
"slow",
"shield",
"blessed",
"hero",
"berserk",
"bold",
"prot_evil",
"invuln",
"see_invis",
"infrared",
"res_acid",
"res_elec",
"res_fire",
"res_cold",
"res_pois",
"stun",
"cut",
"stairs_up",
"store_enter",
"store_leave",
"store_home",
"money1",
"money2",
"money3",
"shoot_hit",
"store5",
"lockpick",
"disarm",
"identify_bad",
"identify_ego",
"identify_art",
"breathe_elements",
"breathe_frost",
"breathe_elec",
"breathe_acid",
"breathe_gas",
"breathe_fire",
"breathe_disenchant",
"breathe_chaos",
"breathe_shards",
"breathe_sound",
"breathe_light",
"breathe_dark",
"breathe_nether",
"breathe_nexus",
"breathe_time",
"breathe_inertia",
"breathe_gravity",
"breathe_plasma",
"breathe_force",
"summon_monster",
"summon_ainu",
"summon_undead",
"summon_animal",
"summon_spider",
"summon_hound",
"summon_hydra",
"summon_demon",
"summon_dragon",
"summon_gr_undead",
"summon_gr_dragon",
"summon_gr_demon",
"summon_ringwraith",
"summon_unique",
"wield",
"quiver",
"cursed",
"rune",
"hungry",
"notice",
"ambient_day",
"ambient_nite",
"ambient_dng1",
"ambient_dng2",
"ambient_dng3",
"ambient_dng4",
"ambient_dng5",
"mon_create_trap",
"mon_shriek",
"mon_cast_fear",
"hit_good",
"hit_great",
"hit_superb",
"hit_hi_great",
"hit_hi_superb",
"cast_spell",
"pray_prayer",
"kill_unique",
"kill_king",
"drain_stat",
"multiply",
"scramble",
NULL,

 };
 if (message < MSG_GENERIC || message >= MSG_MAX)
  return NULL;
 return sound_names[message];
}
/**
 * Make a noise, without a message.  Sound modules hook into this event.
 * 
 * \param type MSG_* constant for the sound type
 */
void sound(int type)
{
 /* No sound */
 if (!OPT(player, use_sound)) return;
 /* Dispatch */
 event_signal_message(EVENT_SOUND, type, NULL);
}
/**
 * Ring the system bell.
 */
void bell(void)
{
 /* Send bell event */
 event_signal_message(EVENT_BELL, MSG_BELL, NULL);
}
/**
 * Display a formatted message.
 *
 * NB: Never call this function directly with a string read in from a
 * file, because it may contain format characters and crash the game.
 * Always use msg("%s", string) in those situations.
 *
 * \param fmt Format string
 */
void msg(const char *fmt, ...)
{
 va_list vp;
 char buf[1024];
 /* Begin the Varargs Stuff */
 va_start(vp, fmt);
 /* Format the args, save the length */
 (void)vstrnfmt(buf, sizeof(buf), fmt, vp);
 /* End the Varargs Stuff */
 va_end(vp);
 /* Fail if messages not loaded */
 if (!messages) return;
 /* Add to message log */
 message_add(buf, MSG_GENERIC);
 /* Send refresh event */
 event_signal_message(EVENT_MESSAGE, MSG_GENERIC, buf);
}
/**
 * Display a formatted message with a given type, making a sound
 * relevant to the message tyoe.
 *
 * \param type MSG_ constant
 * \param fmt Format string
 */
void msgt(unsigned int type, const char *fmt, ...)
{
 va_list vp;
 char buf[1024];
 va_start(vp, fmt);
 vstrnfmt(buf, sizeof(buf), fmt, vp);
 va_end(vp);
 /* Fail if messages not loaded */
 if (!messages) return;
 /* Add to message log */
 message_add(buf, type);
 /* Send refresh event */
 sound(type);
 event_signal_message(EVENT_MESSAGE, type, buf);
}
struct init_module messages_module = {
 .name = "messages",
 .init = messages_init,
 .cleanup = messages_free
};
/**
 * \file mon-attack.c
 * \brief Monster attacks
 *
 * Monster ranged attacks - choosing an attack spell or shot and making it.
 * Monster melee attacks - monster critical blows, whether a monster 
 * attack hits, what happens when a monster attacks an adjacent player.
 *
 * Copyright (c) 1997 Ben Harrison, David Reeve Sward, Keldon Jones.
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * ------------------------------------------------------------------------
 * Ranged attacks
 * ------------------------------------------------------------------------ */
/**
 * Count the number of castable spells.
 *
 * If exactly 1 spell is available cast it.  If more than one is
 * available, and random is set, pick one.
 */
static int choose_attack_spell_fast(const bitflag f[RSF_SIZE], bool do_random)
{
 int i, num = 0;
 uint8_t spells[RSF_MAX];
 /* Paranoid initialization */
 for (i = 0; i < RSF_MAX; i++) {
  spells[i] = 0;
 }
 /* Extract the spells  */
 for (i = FLAG_START; i != FLAG_END; i = rsf_next(f, i + 1)) {
  if (rsf_has(f, i)) {
   spells[num++] = i;
  }
 }
 /* Paranoia */
 if (num == 0) return 0;
 /* Go quick if possible */
 if (num == 1) {
  /* Cast the one spell */
  return (spells[0]);
 }
 /* If we aren't allowed to choose at random and we have multiple spells
	 * left, give up on quick selection */
 if (!do_random) return 0;
 /* Pick at random */
 return (spells[randint0(num)]);
}
/**
 * Have a monster choose a spell.
 *
 * Monsters use this function to select a legal attack spell.
 * Spell casting AI is based here.
 *
 * First the code will try to save time by seeing if
 * choose_attack_spell_fast is helpful.  Otherwise, various AI
 * parameters are used to calculate a 'desirability' for each spell.
 * There is some randomness.  The most desirable spell is cast.
 *
 * Returns the spell number, or '0' if no spell is selected.
 */
static int choose_ranged_attack(struct monster *mon)
{
 bitflag f[RSF_SIZE];
 bool do_random = false;
 int best_spell, best_spell_rating = 0;
 int i;
 /* Extract the racial spell flags */
 rsf_copy(f, mon->race->spell_flags);
 /* Remove spells that cost too much or have unfulfilled conditions */
 remove_bad_spells(mon, f);
 /* No spells left */
 if (!rsf_count(f)) return 0;
 /* Mindless monsters always cast randomly and sometimes non-smart
	 * do (though both always use the restricted list). */
 if (rf_has(mon->race->flags, RF_MINDLESS)
   || (!rf_has(mon->race->flags, RF_SMART) && one_in_(5))) {
  do_random = true;
 }
 /* Try fast selection first. If there is only one spell, choose that spell.
	 * If there are multiple spells, choose one randomly if the 'random' flag
	 * is set. Otherwise fail, and let the AI choose. */
 best_spell = choose_attack_spell_fast(f, do_random);
 if (best_spell) return best_spell;
 /* Use full AI */
 for (i = FLAG_START; i != FLAG_END; i = rsf_next(mon->race->spell_flags, i + 1)) {
  int spell_range, cur_spell_rating;
  const struct monster_spell *spell;
  /* Do we even have this spell? */
  if (!rsf_has(f, i)) continue;
  spell = monster_spell_by_index(i);
  /* Get base range and desirability */
  spell_range = spell->best_range;
  cur_spell_rating = spell->desire;
  /* Penalty for range if attack drops off in power */
  if (spell_range) {
   int cur_range = mon->cdis;
   while (cur_range > spell_range) {
    cur_spell_rating *= spell->use_past_range;
    cur_spell_rating /= 100;
    --cur_range;
   }
  }
  /* Random factor; less random for smart monsters */
  if (rf_has(mon->race->flags, RF_SMART)) {
   cur_spell_rating += randint0(10);
  } else {
   cur_spell_rating += randint0(50);
  }
  /* Is this the best spell yet?, or alternate between equal spells */
  if ((cur_spell_rating > best_spell_rating) ||
   ((cur_spell_rating == best_spell_rating) && one_in_(2))) {
   best_spell_rating = cur_spell_rating;
   best_spell = i;
  }
 }
 if (player->wizard) {
  msg("Spell rating: %i.", best_spell_rating);
 }
 /* Abort if there are no good spells */
 if (!best_spell_rating) return 0;
 /* Return best spell */
 assert(best_spell);
 return best_spell;
}
/**
 * Creatures can cast spells, shoot missiles, and breathe.
 *
 * Returns "true" if a spell (or whatever) was (successfully) cast.
 */
bool make_ranged_attack(struct monster *mon)
{
 struct monster_lore *lore = get_lore(mon->race);
 bool seen = (player->timed[TMD_BLIND] == 0) && monster_is_visible(mon);
 /* Choose attack, or give up */
 int choice = choose_ranged_attack(mon);
 if (!choice) return false;
 /* Monster has cast a spell*/
 mflag_off(mon->mflag, MFLAG_ALWAYS_CAST);
 /* Cast the spell. */
 do_mon_spell(choice, mon, seen);
 /* Mark minimum desired range for recalculation */
 mon->min_range = 0;
 /* Remember what the monster did */
 if (seen) {
  rsf_on(lore->spell_flags, choice);
  if (lore->ranged < UCHAR_MAX)
   lore->ranged++;
 }
 /* Always take note of monsters that kill you */
 if (player->is_dead && (lore->deaths < SHRT_MAX)) {
  lore->deaths++;
 }
 lore_update(mon->race, lore);
 /* A spell was cast */
 return true;
}
/**
 * ------------------------------------------------------------------------
 * Melee attack
 * ------------------------------------------------------------------------ */
/**
 * Determine whether a monster is making a valid charge attack
 */
static bool monster_charge(struct monster *mon, struct player *p)
{
    int speed = mon->race->speed;
    int deltay = p->grid.y - mon->grid.y;
    int deltax = p->grid.x - mon->grid.x;
    /* Paranoia */
    if (distance(mon->grid, p->grid) > 1) return false;
    /* Determine the monster speed */
    if (mon->m_timed[MON_TMD_SLOW]) speed--;
    /* If it has the ability and isn't slow */
    if (rf_has(mon->race->flags, RF_CHARGE) && (speed >= 2)) {
  int d, i;
        /* Try all three directions */
        for (i = -1; i <= 1; i++) {
            d = cycle[chome[dir_from_delta(deltay, deltax)] + i];
            if (mon->previous_action[1] == d) {
                return true;
            }
        }
    }
    return false;
}
/**
 * Determine whether there is a bonus die for an elemental attack that
 * the player doesn't resist
 *
 * Ideally this would be incorporated into melee_effect_elemental - NRM
 */
static int elem_bonus(struct player *p, struct blow_effect *effect)
{
 int resistance = 1;
 if (streq(effect->name, "FIRE")) {
  resistance = p->state.el_info[ELEM_FIRE].res_level;
 } else if (streq(effect->name, "COLD")) {
  resistance = p->state.el_info[ELEM_COLD].res_level;
 } else if (streq(effect->name, "POISON")) {
  resistance = p->state.el_info[ELEM_POIS].res_level;
 } else if (streq(effect->name, "DARK")) {
  resistance = p->state.el_info[ELEM_DARK].res_level;
 } else {
  return 0;
 }
 if (resistance == 1) {
  return 1;
 } else if (resistance < 0) {
  return -resistance;
 }
 return 0;
}
/**
 * Critical hits by monsters can inflict cuts and stuns.
 *
 * The chance is greater for WOUND and BATTER attacks
 */
static bool monster_cut_or_stun(int dice, int dam, struct blow_effect *effect)
{
 if (dam <= 0) return false;
 /* Special case -- wounding/battering attack */
 if (streq(effect->name, "WOUND") || streq(effect->name, "BATTER")) {
  if (dice >= randint1(2)) return true;
 } else if (one_in_(10)) {
  /* Standard attack */
  if (dice >= randint1(2)) return true;
 }
 return false;
}
/**
 * Monster cruel blow ability
 *
 * Ideally we'd use a call to allow_player_confuse() here, but that doesn't
 * work as it can't take the level of the critical into account.
 * Sadly my solution doesn't let you ID confusion resistance items.
 */
static void cruel_blow(struct monster *mon, struct player *p, int dice)
{
 struct monster_lore *lore = get_lore(mon->race);
 int difficulty = p->state.skill_use[SKILL_WILL] +
  (p->state.flags[OF_PROT_CONF] * 10);
 if (skill_check(source_monster(mon->midx), dice * 4, difficulty,
     source_player()) > 0) {
  /* Remember that the monster can do this */
  if (monster_is_visible(mon)) {
   rf_on(lore->flags, RF_CRUEL_BLOW);
  }
  msg("You reel in pain!");
  /* Confuse the player */
  player_inc_timed(p, TMD_CONFUSED, dice, true, true, true);
 }
}
/**
 * Attack the player via physical attacks.
 */
bool make_attack_normal(struct monster *mon, struct player *p)
{
 struct monster_lore *lore = get_lore(mon->race);
 int rlev = ((mon->race->level >= 1) ? mon->race->level : 1);
 char m_name[80];
 char ddesc[80];
 int blow;
 struct blow_effect *effect;
 struct blow_method *method;
 int att, dd, ds;
 int total_attack_mod, total_evasion_mod;
 bool visible = monster_is_visible(mon) || (mon->race->light > 0);
 bool obvious = false;
 bool do_cut, do_stun, do_prt;
 int sound_msg = MSG_GENERIC;
 int hit_result = 0;
 int net_dam = 0;
 char *act = NULL;
 bool act_allocated = false;
 /* Get the monster name (or "it") */
 monster_desc(m_name, sizeof(m_name), mon, MDESC_STANDARD);
 /* Get the "died from" information (i.e. "a kobold") */
 monster_desc(ddesc, sizeof(ddesc), mon, MDESC_SHOW | MDESC_IND_VIS);
 /* Monsters might notice */
 p->been_attacked = true;
 /* Use the alternate attack one in three times */
 blow = mon->race->blow[1].method && one_in_(3) ? 1 : 0;
 effect = mon->race->blow[blow].effect;
 method = mon->race->blow[blow].method;
 att = mon->race->blow[blow].dice.base;
 dd = mon->race->blow[blow].dice.dice;
 ds = mon->race->blow[blow].dice.sides;
 /* Determine the monster's attack score */
 total_attack_mod = total_monster_attack(p, mon, att);
 if (monster_charge(mon, p)) {
  total_attack_mod += 3;
  ds += 3;
 }
 /* Determine the player's evasion score */
 total_evasion_mod = total_player_evasion(p, mon, false);
 /* Check if the player was hit */
 hit_result = hit_roll(total_attack_mod, total_evasion_mod,
        source_monster(mon->midx), source_player(), true);
 /* Monster hits player */
 assert(effect);
 if (streq(effect->name, "NONE") || (hit_result > 0)) {
  melee_effect_handler_f effect_handler;
  int crit_bonus_dice = 0;
  int elem_bonus_dice = 0;
  int dam = 0, prt = 0;
  /* Always disturbing */
  disturb(p, true);
  /* Describe the attack method */
  act = monster_blow_method_action(method, -1);
  act_allocated = true;
  do_cut = method->cut;
  do_stun = method->stun;
  do_prt = method->prt;
  sound_msg = method->msgt;
  /* Special case */
  if (streq(method->name, "HIT") && streq(effect->name, "BATTER")) {
   if (act_allocated) {
    string_free(act);
   }
   act = (char *) "batters you";
   act_allocated = false;
  }
  /* Hack -- assume all attacks are obvious */
  obvious = true;
  /* Determine critical-hit bonus dice (if any)
		 * treats attack as weapon weighing 2 pounds per damage die */
  crit_bonus_dice = crit_bonus(p, hit_result, 20 * dd, NULL, SKILL_MELEE,
          false);
  /* Determine elemental attack bonus dice (if any)  */
  elem_bonus_dice = elem_bonus(p, effect);
  /* Certain attacks can't do criticals */
  if (!do_prt) crit_bonus_dice = 0;
  /* Roll out the damage */
  dam = damroll(dd + crit_bonus_dice + elem_bonus_dice, ds);
  /* Determine the armour based damage-reduction for the player */
  prt = do_prt ? protection_roll(p, PROJ_HURT, true, RANDOMISE) : 0;
  /* Now calculate net_dam, taking protection into account */
  net_dam = MAX((dam - prt), 0);
  /* Message */
  if (act) {
   char punct[20];
   /* Determine the punctuation for the attack ("...", ".", "!" etc) */
   attack_punctuation(punct, sizeof(punct), net_dam, crit_bonus_dice);
   if (monster_charge(mon, p)) {
    /* Remember that the monster can do this */
    if (monster_is_visible(mon)) {
     rf_on(lore->flags, RF_CHARGE);
     if (act_allocated) {
      string_free(act);
     }
     act = (char *) "charges you";
     act_allocated = false;
                }
   }
   msgt(sound_msg, "%s %s%s", m_name, act, punct);
   if (act_allocated) {
    string_free(act);
   }
  }
  /* Perform the actual effect. */
  effect_handler = melee_handler_for_blow_effect(effect->name);
  if (effect_handler != NULL) {
   melee_effect_handler_context_t context = {
    p,
    mon,
    rlev,
    method,
    ddesc,
    obvious,
    do_stun,
    do_cut,
    dam,
    net_dam,
   };
   effect_handler(&context);
   /* Save any changes made in the handler for later use. */
   obvious = context.obvious;
   do_stun = context.stun;
   do_cut = context.cut;
   net_dam = context.damage;
   event_signal_combat_damage(EVENT_COMBAT_DAMAGE,
            dd + crit_bonus_dice + elem_bonus_dice,
            ds, dam, -1, -1, prt, do_prt ? 100 : 0,
            effect->dam_type, true);
   event_signal_hit(EVENT_HIT, net_dam, effect->dam_type, p->is_dead,
        p->grid);
  } else {
   msg("ERROR: Effect handler not found for %s.", effect->name);
  }
  /* Don't cut or stun if player is dead */
  if (p->is_dead) {
   do_cut = false;
   do_stun = false;
  }
  /* Hack -- only one of cut or stun */
  if (do_cut && do_stun) {
   if (one_in_(2)) {
    /* Cancel cut */
    do_cut = false;
   } else {
   /* Cancel stun */
    do_stun = false;
   }
  }
  /* Handle cut */
  if ((do_cut) && monster_cut_or_stun(crit_bonus_dice, net_dam, effect)) {
   /* Apply the cut */
   (void)player_inc_timed(p, TMD_CUT, dam / 2,
     true, true, true);
  }
  /* Handle stun */
  if ((do_stun) && monster_cut_or_stun(crit_bonus_dice, net_dam, effect)){
   /* Apply the stun */
   (void)player_inc_timed(p, TMD_STUN, dam,
    true, true, true);
  }
  /* Deal with Cruel Blow */
  if (rf_has(mon->race->flags, RF_CRUEL_BLOW) && (crit_bonus_dice >= 1) &&
   (net_dam > 0)) {
   cruel_blow(mon, p, crit_bonus_dice);
  }
  /* Deal with Knock Back */
  if (rf_has(mon->race->flags, RF_KNOCK_BACK)) {
   /* Only happens on the main attack (so bites don't knock back) */
   if (blow == 0) {
    /* Determine if the player is knocked back */
    if (skill_check(source_monster(mon->midx),
        monster_stat(mon, STAT_STR) * 2,
        p->state.stat_use[STAT_CON] * 2,
        source_player()) > 0) {
     /* Do the knocking back */
     knock_back(mon->grid, p->grid);
     /* Remember that the monster can do this */
     if (monster_is_visible(mon)) {
      rf_on(lore->flags, RF_KNOCK_BACK);
                    }
                }
            }
  }
  /* Deal with cowardice */
  if ((p->state.flags[OF_COWARDICE] > 0) &&
   (net_dam >= 10 / p->state.flags[OF_COWARDICE])) {
   if (!p->timed[TMD_AFRAID]) {
    if (player_inc_timed(p, TMD_AFRAID, damroll(10, 4), true, true, true)) {
     player_inc_timed(p, TMD_FAST, damroll(5, 4), true, true, true);
     /* Give the player a chance to identify what's causing it */
     player_learn_flag(p, OF_COWARDICE);
    }
   }
  }
 } else {
  /* Visible monster missed player, so notify if appropriate. */
  if (monster_is_visible(mon) && !p->timed[TMD_CONFUSED] &&
   method->miss) {
   /* Disturbing */
   disturb(p, true);
   /* Deal with earthquakes if they miss you by 1 or 2 or 3 points */
   if (streq(effect->name, "SHATTER") && (hit_result > -3)) {
    /* Message */
    msg("%s just misses you.", m_name);
    /* Morgoth */
    if (rf_has(mon->race->flags, RF_QUESTOR)) {
     msg("You leap aside as his great hammer slams into the floor.");
     msg("The ground shakes violently with the force of the blow!");
     /* Radius 5 earthquake centered on the monster */
     effect_simple(EF_EARTHQUAKE, source_monster(mon->midx), "0",
          0, 5, 1, NULL);
    } else {
     /* Kemenrauko */
     msg("You leap aside as its stony fist slams into the floor.");
     msg("The ground shakes violently with the force of the blow!");
     /* Radius 4 earthquake centered on the monster */
     effect_simple(EF_EARTHQUAKE, source_monster(mon->midx), "0",
          0, 4, 1, NULL);
    }
   } else {
    /* A normal miss */
    msg("%s misses you.", m_name);
    /* Allow for ripostes */
    if (player_can_riposte(p, hit_result)) {
     msg("You riposte!");
     p->upkeep->riposte = true;
     py_attack_real(p, mon->grid, ATT_RIPOSTE);
    }
   }
  }
 }
 if (lore) {
  /* Analyze "visible" monsters only */
  if (visible) {
   /* Count "obvious" attacks (and ones that cause damage) */
   if (obvious || net_dam || (lore->blows[blow].times_seen > 10)) {
    /* Count attacks of this type */
    if (lore->blows[blow].times_seen < UCHAR_MAX)
     lore->blows[blow].times_seen++;
   }
  }
  /* Always notice cause of death */
  if (p->is_dead && (lore->deaths < SHRT_MAX))
   lore->deaths++;
  /* Learn lore */
  lore_update(mon->race, lore);
 }
 /* Assume we attacked */
 return true;
}
/**
 * \file mon-blows.c
 * \brief Monster melee module.
 *
 * Copyright (c) 1997 Ben Harrison, David Reeve Sward, Keldon Jones.
 *               2013 Ben Semmler
 *               2016 Nick McConnell
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * ------------------------------------------------------------------------
 * Monster blow methods
 * ------------------------------------------------------------------------ */
typedef enum {
 BLOW_TAG_NONE,
 BLOW_TAG_TARGET,
 BLOW_TAG_OF_TARGET,
 BLOW_TAG_HAS
} blow_tag_t;
static blow_tag_t blow_tag_lookup(const char *tag)
{
 if (strncmp(tag, "target", 6) == 0)
  return BLOW_TAG_TARGET;
 else if (strncmp(tag, "oftarget", 8) == 0)
  return BLOW_TAG_OF_TARGET;
 else if (strncmp(tag, "has", 3) == 0)
  return BLOW_TAG_HAS;
 else
  return BLOW_TAG_NONE;
}
/**
 * Print a monster blow message.
 *
 * We fill in the monster name and/or pronoun where necessary in
 * the message to replace instances of {name} or {pronoun}.
 */
char *monster_blow_method_action(struct blow_method *method, int midx)
{
 const char punct[] = ".!?;:,'";
 char buf[1024] = "\0";
 const char *next;
 const char *s;
 const char *tag;
 const char *in_cursor;
 size_t end = 0;
 struct monster *t_mon = NULL;
 int choice = randint0(method->num_messages);
 struct blow_message *msg = method->messages;
 /* Get the target monster, if any */
 if (midx > 0) {
  t_mon = cave_monster(cave, midx);
 }
 /* Pick a message */
 while (choice--) {
  msg = msg->next;
 }
 in_cursor = msg->act_msg;
 /* Add info to the message */
 next = strchr(in_cursor, '{');
 while (next) {
  /* Copy the text leading up to this { */
  strnfcat(buf, 1024, &end, "%.*s", (int) (next - in_cursor),
   in_cursor);
  s = next + 1;
  while (*s && isalpha((unsigned char) *s)) s++;
  /* Valid tag */
  if (*s == '}') {
   /* Start the tag after the { */
   tag = next + 1;
   in_cursor = s + 1;
   switch (blow_tag_lookup(tag)) {
    case BLOW_TAG_TARGET: {
     char m_name[80];
     if (midx > 0) {
      int mdesc_mode = MDESC_TARG;
      if (!strchr(punct, *in_cursor)) {
       mdesc_mode |= MDESC_COMMA;
      }
      monster_desc(m_name,
       sizeof(m_name), t_mon,
       mdesc_mode);
      strnfcat(buf, sizeof(buf),
       &end, "%s", m_name);
     } else {
      strnfcat(buf, sizeof(buf), &end, "you");
     }
     break;
    }
    case BLOW_TAG_OF_TARGET: {
     char m_name[80];
     if (midx > 0) {
      monster_desc(m_name,
       sizeof(m_name), t_mon,
       MDESC_TARG | MDESC_POSS);
      strnfcat(buf, sizeof(buf), &end, "%s", m_name);
     } else {
      strnfcat(buf, sizeof(buf), &end, "your");
     }
     break;
    }
    case BLOW_TAG_HAS: {
     if (midx > 0) {
      strnfcat(buf, sizeof(buf), &end, "has");
     } else {
      strnfcat(buf, sizeof(buf), &end, "have");
     }
     break;
    }
    default: {
     break;
    }
   }
  } else {
   /* An invalid tag, skip it */
   in_cursor = next + 1;
  }
  next = strchr(in_cursor, '{');
 }
 strnfcat(buf, 1024, &end, "%s", in_cursor);
 return string_make(buf);
}
/**
 * ------------------------------------------------------------------------
 * Monster blow effect helper functions
 * ------------------------------------------------------------------------ */
int blow_index(const char *name)
{
 int i;
 for (i = 1; i < z_info->blow_effects_max; i++) {
  struct blow_effect *effect = &blow_effects[i];
  if (my_stricmp(name, effect->name) == 0)
   return i;
 }
 return 0;
}
/**
 * Monster steals an item from the player
 */
static void steal_player_item(melee_effect_handler_context_t *context)
{
 int tries;
    /* Find an item */
    for (tries = 0; tries < 10; tries++) {
  struct object *obj, *stolen;
  char o_name[80];
  bool split = false;
  bool none_left = false;
        /* Pick an item */
  int index = randint0(z_info->pack_size);
        /* Obtain the item */
        obj = context->p->upkeep->inven[index];
  /* Skip non-objects */
  if (obj == NULL) continue;
        /* Skip artifacts */
        if (obj->artifact) continue;
        /* Get a description */
        object_desc(o_name, sizeof(o_name), obj, ODESC_FULL, context->p);
  /* Is it one of a stack being stolen? */
  if (obj->number > 1)
   split = true;
  /* Message */
  msg("%s %s (%c) was stolen!",
   (split ? "One of your" : "Your"), o_name,
   gear_to_label(context->p, obj));
  /* Steal and carry */
  stolen = gear_object_for_use(context->p, obj, 1,
          false, &none_left);
  (void)monster_carry(cave, context->mon, stolen);
  /* Obvious */
  context->obvious = true;
  /* Done */
  break;
 }
}
/**
 * Deal the actual melee damage from a monster to a target player or monster
 *
 * This function is used in handlers where there is no further processing of
 * a monster after damage, so we always return true for monster targets
 */
static bool monster_damage_target(melee_effect_handler_context_t *context,
          bool no_further_monster_effect)
{
 /* Take damage */
 if (context->p) {
  take_hit(context->p, context->net_dam, context->ddesc);
  if (context->p->is_dead) return true;
 }
 return false;
}
/**
 * ------------------------------------------------------------------------
 * Monster blow multi-effect handlers
 * These are each called by several individual effect handlers
 * ------------------------------------------------------------------------ */
/**
 * Do damage as the result of a melee attack that has an elemental aspect.
 *
 * \param context is information for the current attack.
 * \param type is the PROJ_ constant for the element.
 * \param pure_element should be true if no side effects (mostly a hack
 * for poison).
 */
static void melee_effect_elemental(melee_effect_handler_context_t *context,
           int type)
{
 int res = type < ELEM_MAX ? context->p->state.el_info[type].res_level : 0;
 /* Obvious */
 context->obvious = true;
 if (!context->damage) return;
 switch (type) {
  case PROJ_ACID: msg("You are covered in acid!");
   break;
  case PROJ_FIRE: msg("You are enveloped in flames!");
   break;
  case PROJ_COLD: msg("You are covered with frost!");
   break;
 }
 take_hit(context->p, context->net_dam, context->ddesc);
 if (!context->p->is_dead) {
  if (type == PROJ_ACID) {
   minus_ac(context->p);
  }
  inven_damage(context->p, type, MIN((context->net_dam / 10) + 1, 3), res);
  equip_learn_element(context->p, type);
 }
}
/**
 * Do damage as the result of a melee attack that has a status effect.
 *
 * \param context is the information for the current attack.
 * \param type is the TMD_ constant for the effect.
 * \param amount is the amount that the timer should be increased by.
 * \param of_flag is the OF_ flag that is passed on to monster learning for
 * this effect.
 * \param attempt_save indicates if a saving throw should be attempted for
 * this effect.
 * \param save_msg is the message that is displayed if the saving throw is
 * successful.
 */
static void melee_effect_timed(melee_effect_handler_context_t *context,
          int type, int amount, const char *save_msg)
{
 /* Take damage */
 if (monster_damage_target(context, false)) return;
 /* No status effect if tried and failed to damage */
 if (context->damage && !context->net_dam) return;
 /* Handle status */
 if (player_inc_timed(context->p, type, amount, true, true, true)) {
  context->obvious = true;
 } else if (save_msg != NULL) {
  msg("%s", save_msg);
 }
}
/**
 * Do damage as the result of a melee attack that drains a stat.
 *
 * \param context is the information for the current attack.
 * \param stat is the STAT_ constant for the desired stat.
 * \param damage is whether to inflict damage (needed for multiple stat effects)
 */
static void melee_effect_stat(melee_effect_handler_context_t *context, int stat,
         bool damage)
{
 /* Take damage */
 if (damage) {
  if (monster_damage_target(context, true)) return;
  /* No stat effect if tried and failed to damage */
  if (context->damage && !context->net_dam) return;
 }
 /* Drain stat */
 effect_simple(EF_DRAIN_STAT,
   source_monster(context->mon->midx),
   "0",
   stat,
   0,
   0,
   &context->obvious);
}
/**
 * ------------------------------------------------------------------------
 * Monster blow effect handlers
 * ------------------------------------------------------------------------ */
/**
 * Melee effect handler: Hit the player, but don't do any damage.
 */
static void melee_effect_handler_NONE(melee_effect_handler_context_t *context)
{
 context->obvious = true;
 context->damage = 0;
}
/**
 * Melee effect handler: Hurt the player with no side effects.
 */
static void melee_effect_handler_HURT(melee_effect_handler_context_t *context)
{
 /* Obvious */
 context->obvious = true;
 /* Take damage */
 (void) monster_damage_target(context, true);
}
/**
 * Melee effect handler: Hurt the player with increased chance to wound.
 */
static void melee_effect_handler_WOUND(melee_effect_handler_context_t *context)
{
 /* Obvious */
 context->obvious = true;
 /* Take damage */
 (void) monster_damage_target(context, true);
 /* Usually don't stun */
 if (context->stun && !one_in_(5)) {
  context->stun = false;
 }
 /* Always give a chance to inflict cuts */
 context->cut = true;
}
/**
 * Melee effect handler: Hurt the player with increased chance to stun.
 */
static void melee_effect_handler_BATTER(melee_effect_handler_context_t *context)
{
 /* Obvious */
 context->obvious = true;
 /* Take damage */
 (void) monster_damage_target(context, true);
 /* Usually don't cut */
 if (context->cut && !one_in_(5)) {
  context->cut = false;
 }
 /* Always give a chance to inflict stuns */
 context->stun = true;
}
/**
 * Melee effect handler: Hurt the player with increased chance to stun, 
 * causes an earthquake around the player if it misses.
 */
static void melee_effect_handler_SHATTER(melee_effect_handler_context_t *context)
{
 /* Obvious */
 context->obvious = true;
 /* Take damage */
 (void) monster_damage_target(context, true);
 /* Usually don't cut */
 if (context->cut && !one_in_(5)) {
  context->cut = false;
 }
 /* Always give a chance to inflict stuns */
 context->stun = true;
}
/**
 * Melee effect handler: Take something from the player's inventory.
 */
static void melee_effect_handler_EAT_ITEM(melee_effect_handler_context_t *context)
{
    /* Take damage */
 if (monster_damage_target(context, false)) return;
 /* Steal from player */
 steal_player_item(context);
}
/**
 * Melee effect handler: Attack the player with darkness.
 */
static void melee_effect_handler_DARK(melee_effect_handler_context_t *context)
{
 if (!context->damage) return;
 /* Take damage */
 (void) monster_damage_target(context, true);
 equip_learn_element(context->p, PROJ_DARK);
}
/**
 * Melee effect handler: Hit to reduce nutrition.
 */
static void melee_effect_handler_HUNGER(melee_effect_handler_context_t *context)
{
 int amount = 500;
 /* Take damage */
 if (!monster_damage_target(context, true) && (context->damage > 0)) {
  /* Message -- only if appropriate */
  if (!player_saving_throw(context->p, context->mon, 0)) {
   msg("You feel an unnatural hunger...");
   /* Modify the hunger caused by the player's hunger rate
			 * but go up/down by factors of 1.5 rather than 3 */
   if (context->p->state.hunger < 0) {
    amount *= int_exp(2, -(context->p->state.hunger));
    amount /= int_exp(3, -(context->p->state.hunger));
   } else if (context->p->state.hunger > 0) {
    amount *= int_exp(3, context->p->state.hunger);
    amount /= int_exp(2, context->p->state.hunger);
   }
   /* Reduce food counter, but not too much. */
   player_dec_timed(context->p, TMD_FOOD, amount, false,
    true);
  }
 }
}
/**
 * Melee effect handler: Poison the player.
 *
 * We can't use melee_effect_timed(), because this is both and elemental attack
 * and a status attack. Note the false value for pure_element for
 * melee_effect_elemental().
 */
static void melee_effect_handler_POISON(melee_effect_handler_context_t *context)
{
 if (!context->damage) return;
 /* Take "poison" effect */
 if (player_inc_timed(context->p, TMD_POISONED, context->damage, true,
   true, true))
  context->obvious = true;
 equip_learn_element(context->p, PROJ_POIS);
}
/**
 * Melee effect handler: Attack the player with acid.
 */
static void melee_effect_handler_ACID(melee_effect_handler_context_t *context)
{
 melee_effect_elemental(context, PROJ_ACID);
}
/**
 * Melee effect handler: Attack the player with fire.
 */
static void melee_effect_handler_FIRE(melee_effect_handler_context_t *context)
{
 melee_effect_elemental(context, PROJ_FIRE);
}
/**
 * Melee effect handler: Attack the player with cold.
 */
static void melee_effect_handler_COLD(melee_effect_handler_context_t *context)
{
 melee_effect_elemental(context, PROJ_COLD);
}
/**
 * Melee effect handler: Blind the player.
 */
static void melee_effect_handler_BLIND(melee_effect_handler_context_t *context)
{
 bool blind = context->p->timed[TMD_BLIND] > 0;
 melee_effect_timed(context, TMD_BLIND, damroll(5, 4),
        blind ? NULL : "Your vision quickly clears.");
}
/**
 * Melee effect handler: Confuse the player.
 */
static void melee_effect_handler_CONFUSE(melee_effect_handler_context_t *context)
{
 melee_effect_timed(context, TMD_CONFUSED, damroll(2, 4),
        "You resist the effects.");
}
/**
 * Melee effect handler: Paralyze the player.
 */
static void melee_effect_handler_ENTRANCE(melee_effect_handler_context_t *context)
{
 melee_effect_timed(context, TMD_ENTRANCED, damroll(4, 4),
        "You are unaffected!");
}
/**
 * Melee effect handler: Make the player hallucinate.
 */
static void melee_effect_handler_HALLU(melee_effect_handler_context_t *context)
{
 melee_effect_timed(context, TMD_IMAGE, damroll(10, 4),
        "You resist the effects.");
}
/**
 * Melee effect handler: Drain the player's strength.
 */
static void melee_effect_handler_LOSE_STR(melee_effect_handler_context_t *context)
{
 melee_effect_stat(context, STAT_STR, true);
}
/**
 * Melee effect handler: Drain the player's dexterity.
 */
static void melee_effect_handler_LOSE_DEX(melee_effect_handler_context_t *context)
{
 melee_effect_stat(context, STAT_DEX, true);
}
/**
 * Melee effect handler: Drain the player's constitution.
 */
static void melee_effect_handler_LOSE_CON(melee_effect_handler_context_t *context)
{
 melee_effect_stat(context, STAT_CON, true);
}
/**
 * Melee effect handler: Drain the player's grace.
 */
static void melee_effect_handler_LOSE_GRA(melee_effect_handler_context_t *context)
{
 melee_effect_stat(context, STAT_GRA, true);
}
/**
 * Melee effect handler: Drain the player's strength and constitution.
 */
static void melee_effect_handler_LOSE_STR_CON(melee_effect_handler_context_t *context)
{
 melee_effect_stat(context, STAT_STR, true);
 melee_effect_stat(context, STAT_CON, false);
}
/**
 * Melee effect handler: Drain all of the player's stats.
 */
static void melee_effect_handler_LOSE_ALL(melee_effect_handler_context_t *context)
{
 melee_effect_stat(context, STAT_STR, true);
 melee_effect_stat(context, STAT_DEX, false);
 melee_effect_stat(context, STAT_CON, false);
 melee_effect_stat(context, STAT_GRA, false);
}
/**
 * Melee effect handler: Hit to disarm.
 *
 * Note that we don't use melee_effect_timed(), due to the different monster
 * learning function.
 */
static void melee_effect_handler_DISARM(melee_effect_handler_context_t *context)
{
 struct object *obj = equipped_item_by_slot_name(context->p, "weapon");
 char o_name[120];
 char m_name[80];
 /* Base difficulty */
 int difficulty = 2;
 /* Nothing to disarm */
 if (!obj) return;
 /* Describe */
 object_desc(o_name, sizeof(o_name), obj, ODESC_BASE, context->p);
 /* Get the monster name (or "it") */
 monster_desc(m_name, sizeof(m_name), context->mon, MDESC_STANDARD);
 /* Adjustment for two handed weapons */
 if (two_handed_melee(context->p)) {
  difficulty -= 4;
 }
 /* Attempt a skill check against strength */
 if (skill_check(source_monster(context->mon->midx), difficulty,
     context->p->state.stat_use[STAT_STR] * 2,
     source_player()) <= 0) {
  msg("%s tries to disarm you, but you keep a grip on your weapon.",
   m_name);
 } else {
  struct object *dislodged;
  bool none_left = false;
  /* Oops */
  msg("%s disarms you! Your %s falls to the ground nearby.", m_name,
   o_name);
  /* Take off equipment */
  inven_takeoff(obj);
  /* Get the original object */
  dislodged = gear_object_for_use(context->p, obj, 1, false, &none_left);
  drop_near(cave, &dislodged, 0, context->p->grid, true, false);
 }
}
/**
 * ------------------------------------------------------------------------
 * Monster blow melee handler selection
 * ------------------------------------------------------------------------ */
melee_effect_handler_f melee_handler_for_blow_effect(const char *name)
{
 static const struct effect_handler_s {
  const char *name;
  melee_effect_handler_f function;
 } effect_handlers[] = {
  { "NONE", melee_effect_handler_NONE },
  { "HURT", melee_effect_handler_HURT },
  { "WOUND", melee_effect_handler_WOUND },
  { "BATTER", melee_effect_handler_BATTER },
  { "SHATTER", melee_effect_handler_SHATTER },
  { "EAT_ITEM", melee_effect_handler_EAT_ITEM },
  { "DARK", melee_effect_handler_DARK },
  { "HUNGER", melee_effect_handler_HUNGER },
  { "POISON", melee_effect_handler_POISON },
  { "ACID", melee_effect_handler_ACID },
  { "FIRE", melee_effect_handler_FIRE },
  { "COLD", melee_effect_handler_COLD },
  { "BLIND", melee_effect_handler_BLIND },
  { "CONFUSE", melee_effect_handler_CONFUSE },
  { "ENTRANCE", melee_effect_handler_ENTRANCE },
  { "HALLU", melee_effect_handler_HALLU },
  { "LOSE_STR", melee_effect_handler_LOSE_STR },
  { "LOSE_DEX", melee_effect_handler_LOSE_DEX },
  { "LOSE_CON", melee_effect_handler_LOSE_CON },
  { "LOSE_GRA", melee_effect_handler_LOSE_GRA },
  { "LOSE_STR_CON", melee_effect_handler_LOSE_STR_CON },
  { "LOSE_ALL", melee_effect_handler_LOSE_ALL },
  { "DISARM", melee_effect_handler_DISARM },
  { NULL, NULL },
 };
 const struct effect_handler_s *current = effect_handlers;
 while (current->name != NULL && current->function != NULL) {
  if (my_stricmp(name, current->name) == 0)
   return current->function;
  current++;
 }
 return NULL;
}
/**
 * \file mon-calcs.c
 * \brief Monster status calculation 
 *	status changes.
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 * Copyright (c) 2022 Nick McConnell
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * ------------------------------------------------------------------------
 * Morale
 * ------------------------------------------------------------------------ */
/**
 * Bonus for elf bane against elves.
 */
int monster_elf_bane_bonus(struct monster *mon, struct player *p)
{
 bool elf = (streq(p->race->name, "Noldor") ||
    streq(p->race->name, "Sindar"));
    if (!mon) return 0;
 /* Dagohir must have killed between 32 and 63 elves */
    return (rf_has(mon->race->flags, RF_ELFBANE) && elf) ? 5 : 0;
}
/**
 * Calculate the number of monsters of the same type within LOS of a given
 * monster.
 */
static int morale_from_friends(struct monster *mon)
{
 int i;
 int morale_bonus = 0;
 int morale_penalty = 0;
 /* Scan monsters */
 for (i = 1; i < cave_monster_max(cave); i++) {
  struct monster *mon1 = cave_monster(cave, i);
  /* Skip dead monsters */
  if (!mon1->race) continue;
  /* Skip self! */
  if (mon == mon1) continue;
  /* Skip monsters not in LoS */
  if (!los(cave, mon->grid, mon1->grid)) continue;
  /* Skip dissimilar monsters */
  if (!similar_monsters(mon, mon1)) continue;
  /* Only consider alert monsters */
  if (mon1->alertness >= ALERTNESS_ALERT) {
   int multiplier = 1;
   if (rf_has(mon1->race->flags, RF_ESCORT) ||
    rf_has(mon1->race->flags, RF_ESCORTS)) {
    multiplier = 4;
   }
   /* Add bonus or penalty to morale */
   if (mon1->stance == STANCE_FLEEING) {
    morale_penalty += 10 * multiplier;
   } else {
    morale_bonus += 10 * multiplier;
   }
  }
 }
 return (morale_bonus - morale_penalty);
}
/**
 * Calculate the morale for a monster.
 */
void calc_morale(struct monster *mon)
{
 int morale;
    int difference;
 struct monster_race *race = mon->race;
 /* Starting morale is 60 */
 morale = 60;
 /* Monsters have boosted morale during the endgame */
 if (player->on_the_run) {
  morale += 20;
 } else {
  /* Monsters have higher morale if they are usually found deeper than
		 * this and vice versa */
  morale += (race->level - player->depth) * 10;
  /* Make sure orcs etc in throne room don't have too low morale */
  if (player->depth == z_info->dun_depth) {
   morale = MAX(morale, 20);
  }
 }
 /* Take player's conditions into account */
 if (player->timed[TMD_IMAGE]) {
  morale += 20;
 }
 if (player->timed[TMD_BLIND]) {
  morale += 20;
 }
 if (player->timed[TMD_CONFUSED]) {
  morale += 40;
 }
 if (player->timed[TMD_SLOW]) {
  morale += 40;
 }
 if (player->timed[TMD_AFRAID]) {
  morale += 40;
 }
 if (player->timed[TMD_ENTRANCED]) {
  morale += 80;
 } else if (player->timed[TMD_STUN] > 100) {
  morale += 80;
 } else if (player->timed[TMD_STUN] > 50) {
  morale += 40;
 } else if (player->timed[TMD_STUN] > 0) {
  morale += 20;
 }
 /* Take player's health into account */
 switch (health_level(player->chp, player->mhp)) {
  case HEALTH_WOUNDED: morale += 20; break; /* <= 75% health */
  case HEALTH_BADLY_WOUNDED: morale += 40; break; /* <= 50% health */
  case HEALTH_ALMOST_DEAD: morale += 80; break; /* <= 25% health */
 }
 /* Take monster's conditions into account */
 if (mon->m_timed[MON_TMD_STUN]) {
  morale -= 20;
 }
 /* Skip confusion as it is less good if confused monsters flee */
 if (mon->m_timed[MON_TMD_FAST]) {
  morale += 40;
 }
 /* Take monster's health into account */
 switch (health_level(mon->hp, mon->maxhp))
 {
  case HEALTH_WOUNDED: morale -= 20; break; /* <= 75% health */
  case HEALTH_BADLY_WOUNDED: morale -= 40; break; /* <= 50% health */
  case HEALTH_ALMOST_DEAD: morale -= 80; break; /* <= 25% health */
 }
 /* Extra penalty if <=75% health and already fleeing
	 * helps avoid them coming back too quickly */
 if ((mon->stance == STANCE_FLEEING) &&
  (health_level(mon->hp, mon->maxhp) <= HEALTH_WOUNDED)) {
  morale -= 20;
 }
 /* Get a bonus for non-fleeing friends and a penalty for fleeing ones */
 morale += morale_from_friends(mon);
 /* Reduce morale for light averse monsters facing a brightly lit player */
 if (rf_has(race->flags, RF_HURT_LIGHT) &&
  (square_light(cave, player->grid) >= 4)) {
  morale -= (square_light(cave, player->grid) - 3) * 10;
 }
 /* Reduce morale for each carried object for non-uniques, so thieves avoid
	 * the player */
 if (!rf_has(race->flags, RF_UNIQUE)) {
  struct object *obj = mon->held_obj;
  while (obj) {
   /* Lower morale */
   morale -= 20;
   /* Get the next object */
   obj = obj->next;
  }
 }
 /* Reduce morale for the Majesty ability */
    difference = MAX(player->state.skill_use[SKILL_WILL]
      - monster_skill(mon, SKILL_WILL), 0);
 if (player_active_ability(player, "Majesty")) {
  morale -= difference / 2 * 10;
 }
 /* Reduce morale for the Bane ability */
 if (player_active_ability(player, "Bane")) {
  morale -= player_bane_bonus(player, mon) * 10;
 }
    /* Increase morale for the Elf-Bane ability */
 morale += monster_elf_bane_bonus(mon, player) * 10;
 /* Add temporary morale modifiers */
 morale += mon->tmp_morale;
 /* Update the morale */
 mon->morale = morale;
}
/**
 * ------------------------------------------------------------------------
 * Stance
 * ------------------------------------------------------------------------ */
/**
 * Calculate the stance for a monster.
 *
 * Based on the monster's morale, type, and other effects.
 *
 * Can be:
 *    STANCE_FLEEING
 *    STANCE_CONFIDENT
 *    STANCE_AGGRESSIVE
 */
void calc_stance(struct monster *mon)
{
 struct monster_race *race = mon->race;
 int stance;
 int stances[3];
 /* Set the default stances */
 stances[0] = STANCE_FLEEING;
 stances[1] = STANCE_CONFIDENT;
 stances[2] = STANCE_AGGRESSIVE;
 /* Some monsters are immune to (non-magical) fear */
 if (rf_has(race->flags, RF_NO_FEAR) && (mon->tmp_morale >= 0)) {
  stances[0] = STANCE_CONFIDENT;
 }
 /* Mindless monsters just attack */
 if (rf_has(race->flags, RF_MINDLESS)) {
  stances[0] = STANCE_AGGRESSIVE;
  stances[1] = STANCE_AGGRESSIVE;
 }
 /* Trolls are aggressive rather than confident */
 if (rf_has(race->flags, RF_TROLL)) {
  stances[1] = STANCE_AGGRESSIVE;
 }
 /* Aggravation makes non-mindless things much more hostile */
 if (player->state.flags[OF_AGGRAVATE] && !rf_has(race->flags, RF_MINDLESS)){
  stances[1] = STANCE_AGGRESSIVE;
  if (monster_is_in_view(mon)) {
   equip_learn_flag(player, OF_AGGRAVATE);
  }
 }
 /* Monsters that have been angered have confident turned into aggressive */
 if (mflag_has(mon->mflag, MFLAG_AGGRESSIVE)) {
  stances[1] = STANCE_AGGRESSIVE;
 }
 /* Determine the stance */
 if (mon->morale > 200) {
  stance = stances[2];
 } else if (mon->morale > 0) {
  stance = stances[1];
 } else {
  stance = stances[0];
 }
 /* Override this for unwary/sleeping monsters */
 if (mon->alertness < ALERTNESS_ALERT) {
  stance = stances[1];
 }
 /* React to changes in stance */
 if (stance != mon->stance) {
  enum mon_messages stance_msg = MON_MSG_NONE;
  switch (mon->stance) {
   case STANCE_FLEEING: {
    /* Give the monster a temporary 'rally' bonus to its morale */
    mon->tmp_morale += 60;
    calc_morale(mon);
    if (!player->truce) {
     stance_msg = MON_MSG_TURN_TO_FIGHT;
    } else {
     stance_msg = MON_MSG_RECOVER_COMPOSURE;
    }
    break;
   }
   case STANCE_CONFIDENT:
   case STANCE_AGGRESSIVE: {
    if (stance == STANCE_FLEEING) {
     /* Give the monster a temporary 'break' penalty to morale */
     mon->tmp_morale -= 60;
     calc_morale(mon);
     stance_msg = MON_MSG_FLEE_IN_TERROR;
    }
    break;
   }
  }
  /* Inform player of visible changes */
  if (stance_msg && monster_is_visible(mon) &&
   !rf_has(race->flags, RF_NEVER_MOVE)) {
   add_monster_message(mon, stance_msg, true);
  }
  /* Force recalculation of range if stance changes */
  mon->min_range = 0;
  }
 /* Update the monster's stance */
 mon->stance = stance;
}
/**
 * ------------------------------------------------------------------------
 * Alertness
 * ------------------------------------------------------------------------ */
/**
 * Changes a monster's alertness value and displays any appropriate messages
 */
void make_alert(struct monster *mon, int dam)
{
 int random_level = rand_range(ALERTNESS_ALERT, ALERTNESS_QUITE_ALERT);
 set_alertness(mon, MAX(mon->alertness + dam, random_level + dam));
}
/**
 * Changes a monster's alertness value and displays any appropriate messages
 */
void set_alertness(struct monster *mon, int alertness)
{
 bool redisplay = false;
 enum mon_messages alert_msg = MON_MSG_NONE;
 /* Nothing to be done... */
 if (mon->alertness == alertness) return;
 /* Bound the alertness value */
 alertness = (MAX(MIN(alertness, ALERTNESS_MAX), ALERTNESS_MIN));
 /* First deal with cases where the monster becomes more alert */
 if (mon->alertness < alertness) {
  if (mon->alertness < ALERTNESS_UNWARY) {
   if (alertness >= ALERTNESS_ALERT) {
    /* Monster must spend its next turn noticing you */
    mon->skip_next_turn = true;
    /* Notice the "waking up and noticing" */
    if (monster_is_visible(mon)) {
     /* Dump a message */
     alert_msg = MON_MSG_WAKE_AND_NOTICE;
    }
    /* Disturb the player */
    disturb(player, true);
    /* Redisplay the monster */
    redisplay = true;
   } else if (alertness >= ALERTNESS_UNWARY) {
    /* Notice the "waking up" */
    if (monster_is_visible(mon)) {
     /* Dump a message */
     alert_msg = MON_MSG_WAKES_UP;
    }
    /* Disturb the player */
    disturb(player, true);
    /* Redisplay the monster */
    redisplay = true;
   }
  } else if ((mon->alertness < ALERTNESS_ALERT) &&
       (alertness >= ALERTNESS_ALERT)) {
   /* Monster must spend its next turn noticing you */
   mon->skip_next_turn = true;
   /* Notice the "noticing" (!) */
   if (monster_is_visible(mon)) {
    /* Dump a message */
    alert_msg = MON_MSG_NOTICE;
    /* Disturb the player */
    disturb(player, true);
    /* Redisplay the monster */
    redisplay = true;
   }
  } else if ((mon->alertness < ALERTNESS_UNWARY) &&
       (alertness < ALERTNESS_UNWARY) &&
       (alertness >= ALERTNESS_UNWARY - 2)) {
   /* Notice the "stirring" */
   if (monster_is_visible(mon)) {
    /* Dump a message */
    alert_msg = MON_MSG_STIR;
   }
  } else if ((mon->alertness < ALERTNESS_ALERT) &&
       (alertness < ALERTNESS_ALERT) &&
       (alertness >= ALERTNESS_ALERT - 2)) {
   /* Notice the "looking around" */
   if (monster_is_visible(mon)) {
    /* Dump a message */
    alert_msg = MON_MSG_LOOK_AROUND;
   }
  }
 } else {
  /* Deal with cases where the monster becomes less alert */
  if ((mon->alertness >= ALERTNESS_UNWARY) &&
   (alertness < ALERTNESS_UNWARY)) {
   /* Notice the falling asleep */
   if (monster_is_visible(mon)) {
    /* Dump a message */
    alert_msg = MON_MSG_FALL_ASLEEP;
    /* Morgoth drops his iron crown if he falls asleep */
    if (rf_has(mon->race->flags, RF_QUESTOR)) {
     drop_iron_crown(mon, "His crown slips from off his brow and falls to the ground nearby.");
    }
    /* Redisplay the monster */
    redisplay = true;
   }
  } else if ((mon->alertness >= ALERTNESS_ALERT) &&
       (alertness < ALERTNESS_ALERT)) {
   /* Notice the becoming unwary */
   if (monster_is_visible(mon)) {
    /* Dump a message */
    alert_msg = MON_MSG_BECOME_UNWARY;
    /* Redisplay the monster */
    redisplay = true;
    /* Give the monster a new place to wander towards */
    if (!rf_has(mon->race->flags, RF_TERRITORIAL)) {
     monster_group_new_wandering_flow(cave, mon, player->grid);
    }
   }
  }
 }
 /* Add the message */
 if (alert_msg) {
  add_monster_message(mon, alert_msg, true);
 }
 /* Do the actual alerting */
 mon->alertness = alertness;
 /* Redisplay the monster */
 if (redisplay) {
  square_light_spot(cave, mon->grid);
 }
}
/**
 * ------------------------------------------------------------------------
 * Monster updates
 * ------------------------------------------------------------------------ */
/**
 * Try to locate a monster by the noise it is making
 */
static void listen(struct chunk *c, struct player *p, struct monster *mon)
{
 int result;
 int difficulty = flow_dist(c->player_noise, mon->grid) - mon->noise;
 struct song *silence = lookup_song("Silence");
 /* Reset the monster noise */
 mon->noise = 0;
 /* Must have the listen skill */
 if (!player_active_ability(p, "Listen")) return;
 /* Must not be visible */
 if (monster_is_visible(mon)) return;
 /* Monster must be able to move */
 if (rf_has(mon->race->flags, RF_NEVER_MOVE)) return;
 /* Use monster stealth */
 difficulty += monster_skill(mon, SKILL_STEALTH);
 /* Bonus for awake but unwary monsters (to simulate their lack of care) */
 if ((mon->alertness >= ALERTNESS_UNWARY) &&
  (mon->alertness < ALERTNESS_ALERT)) {
  difficulty -= 3;
 }
 /* Penalty for song of silence */
 if (player_is_singing(p, silence)) {
  difficulty += song_bonus(p, p->state.skill_use[SKILL_SONG], silence);
 }
 /* Make the check */
 result = skill_check(source_player(), p->state.skill_use[SKILL_PERCEPTION],
       difficulty, source_monster(mon->midx));
 /* Give up if it is a failure */
 if (result <= 0) {
  square_light_spot(c, mon->grid);
  return;
 }
 /* Make the monster completely visible if a dramatic success */
 if (result > 10) {
  mflag_on(mon->mflag, MFLAG_VISIBLE);
  square_light_spot(c, mon->grid);
  return;
 }
 /* Let's see if this works... */
 mflag_on(mon->mflag, MFLAG_LISTENED);
}
/**
 * Analyse the path from player to infravision-seen monster and forget any
 * grids which would have blocked line of sight
 */
static void path_analyse(struct chunk *c, struct loc grid)
{
 int path_n, i;
 struct loc path_g[256];
 if (c != cave) {
  return;
 }
 /* Plot the path. */
 path_n = project_path(c, path_g, z_info->max_range, player->grid,
  &grid, PROJECT_NONE);
 /* Project along the path */
 for (i = 0; i < path_n - 1; ++i) {
  /* Forget grids which would block los */
  if (!square_allowslos(player->cave, path_g[i])) {
   sqinfo_off(square(c, path_g[i])->info, SQUARE_SEEN);
   square_forget(c, path_g[i]);
   square_light_spot(c, path_g[i]);
  }
 }
}
/**
 * This function updates the monster record of the given monster
 *
 * This involves extracting the distance to the player (if requested),
 * and then checking for visibility (natural, infravision, see-invis,
 * telepathy), updating the monster visibility flag, redrawing (or
 * erasing) the monster when its visibility changes, and taking note
 * of any interesting monster flags (cold-blooded, invisible, etc).
 *
 * Note the new "mflag" field which encodes several monster state flags,
 * including "view" for when the monster is currently in line of sight,
 * and "mark" for when the monster is currently visible via detection.
 *
 * The only monster fields that are changed here are "cdis" (the
 * distance from the player), "ml" (visible to the player), and
 * "mflag" (to maintain the "MFLAG_VIEW" flag).
 *
 * Note the special "update_monsters()" function which can be used to
 * call this function once for every monster.
 *
 * Note the "full" flag which requests that the "cdis" field be updated;
 * this is only needed when the monster (or the player) has moved.
 *
 * Every time a monster moves, we must call this function for that
 * monster, and update the distance, and the visibility.  Every time
 * the player moves, we must call this function for every monster, and
 * update the distance, and the visibility.  Whenever the player "state"
 * changes in certain ways ("blindness", "infravision", "telepathy",
 * and "see invisible"), we must call this function for every monster,
 * and update the visibility.
 *
 * Routines that change the "illumination" of a grid must also call this
 * function for any monster in that grid, since the "visibility" of some
 * monsters may be based on the illumination of their grid.
 *
 * Note that this function is called once per monster every time the
 * player moves.  When the player is running, this function is one
 * of the primary bottlenecks, along with "update_view()" and the
 * "process_monsters()" code, so efficiency is important.
 *
 * Note the optimized "inline" version of the "distance()" function.
 *
 * A monster is "visible" to the player if (1) it has been detected
 * by the player, (2) it is close to the player and the player has
 * telepathy, or (3) it is close to the player, and in line of sight
 * of the player, and it is "illuminated" by some combination of
 * infravision, torch light, or permanent light (invisible monsters
 * are only affected by "light" if the player can see invisible).
 *
 * Monsters which are not on the current panel may be "visible" to
 * the player, and their descriptions will include an "offscreen"
 * reference.  Currently, offscreen monsters cannot be targeted
 * or viewed directly, but old targets will remain set.  XXX XXX
 *
 * The player can choose to be disturbed by several things, including
 * "OPT(player, disturb_near)" (monster which is "easily" viewable moves in some
 * way).  Note that "moves" includes "appears" and "disappears".
 */
void update_mon(struct monster *mon, struct chunk *c, bool full)
{
 struct monster_lore *lore;
 struct monster_race *race;
 int d;
 /* Seen at all */
 bool flag = false;
 /* Seen by vision */
 bool easy = false;
    /* Known because immobile */
    bool immobile_seen = false;
 assert(mon != NULL);
 /* Return if this is not the current level */
 if (c != cave) {
  return;
 }
 lore = get_lore(mon->race);
 race = mon->race;
    /* Unmoving mindless monsters can be seen once encountered */
    if (rf_has(race->flags, RF_NEVER_MOVE) &&
  rf_has(race->flags, RF_MINDLESS) && mon->encountered) {
  immobile_seen = true;
 }
 /* Compute distance, or just use the current one */
 if (full) {
  /* Distance components */
  int dy = ABS(player->grid.y - mon->grid.y);
  int dx = ABS(player->grid.x - mon->grid.x);
  /* Approximate distance */
  d = (dy > dx) ? (dy + (dx >> 1)) : (dx + (dy >> 1));
  /* Restrict distance */
  if (d > 255) d = 255;
  /* Save the distance */
  mon->cdis = d;
 } else {
  /* Extract the distance */
  d = mon->cdis;
 }
 /* Detected */
 if (mflag_has(mon->mflag, MFLAG_MARK)) flag = true;
 /* Clear the listen flag */
 mflag_off(mon->mflag, MFLAG_LISTENED);
 /* Nearby */
 if (d <= z_info->max_sight) {
  /* Normal line of sight and player is not blind */
  if (square_isview(c, mon->grid) && !player->timed[TMD_BLIND]) {
   bool do_invisible = false;
   /* Use illumination */
   if (square_isseen(c, mon->grid)) {
    /* Handle invisibility */
    if (monster_is_invisible(mon)) {
     int difficulty = monster_skill(mon, SKILL_WILL) +
      (2 * distance(player->grid, mon->grid)) -
      10 * player->state.flags[OF_SEE_INVIS];
     /* Take note */
     do_invisible = true;
     /* Keen senses */
     if (player_active_ability(player, "Keen Senses")) {
      /* Makes things a bit easier */
      difficulty -= 5;
     }
     /* See invisible through perception skill */
     if (skill_check(source_player(),
         player->state.skill_use[SKILL_PERCEPTION],
         difficulty, source_monster(mon->midx)) > 0){
      /* Easy to see */
      easy = flag = true;
     }
    } else {
     /* Easy to see */
     easy = flag = true;
    }
   } else if (square_seen_by_keen_senses(c, mon->grid)) {
    /* Easy to see */
    easy = flag = true;
   }
   /* Visible */
   if (flag && do_invisible) {
    /* Learn about invisibility */
    rf_on(lore->flags, RF_INVISIBLE);
   }
   /* Learn about intervening squares */
   path_analyse(c, mon->grid);
  }
 }
 /* Is the monster now visible? */
 if (flag || immobile_seen) {
        /* Untarget if this is an out-of-LOS stationary monster */
        if (immobile_seen && !flag) {
            if (target_get_monster() == mon) {
    target_set_monster(NULL);
   }
            if (player->upkeep->health_who == mon) {
    health_track(player->upkeep, NULL);
   }
  }
  /* It was previously unseen */
  if (!monster_is_visible(mon)) {
   /* Mark as visible */
   mflag_on(mon->mflag, MFLAG_VISIBLE);
   /* Draw the monster */
   square_light_spot(c, mon->grid);
   /* Update health bar as needed */
   if (player->upkeep->health_who == mon)
    player->upkeep->redraw |= (PR_HEALTH);
   /* Window stuff */
   player->upkeep->redraw |= PR_MONLIST;
   /* Identify see invisible items */
   if (rf_has(race->flags, RF_INVISIBLE) &&
    (player->state.flags[OF_SEE_INVIS] > 0)) {
    player_learn_flag(player, OF_SEE_INVIS);
   }
  }
 } else if (monster_is_visible(mon)) {
  /* Not visible but was previously seen */
  mflag_off(mon->mflag, MFLAG_VISIBLE);
  /* Erase the monster */
  square_light_spot(c, mon->grid);
  /* Update health bar as needed */
  if (player->upkeep->health_who == mon)
   player->upkeep->redraw |= (PR_HEALTH);
  /* Window stuff */
  player->upkeep->redraw |= PR_MONLIST;
 }
 /* Is the monster is now easily visible? */
 if (easy) {
  /* Change */
  if (!monster_is_in_view(mon)) {
   /* Mark as easily visible */
   mflag_on(mon->mflag, MFLAG_VIEW);
   /* Disturb on appearance */
   disturb(player, false);
   /* Re-draw monster window */
   player->upkeep->redraw |= PR_MONLIST;
  }
 } else {
  /* Change */
  if (monster_is_in_view(mon)) {
   /* Mark as not easily visible */
   mflag_off(mon->mflag, MFLAG_VIEW);
   /* Re-draw monster list window */
   player->upkeep->redraw |= PR_MONLIST;
  }
 }
 listen(c, player, mon);
 /* Check encounters with monsters (must be visible and in line of sight) */
 if (monster_is_visible(mon) && !mon->encountered &&
  square_isseen(c, mon->grid) && (lore->psights < SHRT_MAX)) {
  int new_exp = adjusted_mon_exp(race, false);
  /* Gain experience for encounter */
  player_exp_gain(player, new_exp);
  player->encounter_exp += new_exp;
  /* Update stats */
  mon->encountered = true;
  lore->psights++;
  if (lore->tsights < SHRT_MAX) lore->tsights++;
  /* If the player encounters a Unique for the first time, write a note */
  if (rf_has(race->flags, RF_UNIQUE)) {
   char note[120];
   /* Write note */
   my_strcpy(note, format("Encountered %s", race->name), sizeof(note));
   history_add(player, note, HIST_MEET_UNIQUE);
  }
  /* If it was a wraith, possibly realise you are haunted */
  if (rf_has(race->flags, RF_UNDEAD) &&
   !rf_has(race->flags, RF_TERRITORIAL)) {
   player_learn_flag(player, OF_HAUNTED);
  }
 }
}
/**
 * Updates all the (non-dead) monsters via update_mon().
 */
void update_monsters(bool full)
{
 int i;
 /* Update each (live) monster */
 for (i = 1; i < cave_monster_max(cave); i++) {
  struct monster *mon = cave_monster(cave, i);
  /* Update the monster if alive */
  if (mon->race)
   update_mon(mon, cave, full);
 }
}
/**
 * ------------------------------------------------------------------------
 * Skills and stats
 * ------------------------------------------------------------------------ */
/**
 * Calculates a skill score for a monster
 */
int monster_skill(struct monster *mon, int skill_type)
{
 struct monster_race *race = mon->race;
 int skill = 0;
    switch (skill_type) {
        case SKILL_MELEE:
            msg("Can't determine the monster's Melee score.");
            break;
        case SKILL_ARCHERY:
            msg("Can't determine the monster's Archery score.");
            break;
        case SKILL_EVASION:
            msg("Can't determine the monster's Evasion score.");
            break;
        case SKILL_STEALTH:
            skill = race->stl;
            break;
        case SKILL_PERCEPTION:
            skill = race->per;
            break;
        case SKILL_WILL:
            skill = race->wil;
            break;
        case SKILL_SMITHING:
            msg("Can't determine the monster's Smithing score.");
            break;
        case SKILL_SONG:
            msg("Can't determine the monster's Song score.");
            break;
        default:
            msg("Asked for an invalid monster skill.");
            break;
    }
 /* Penalise stunning */
 if (mon->m_timed[MON_TMD_STUN]) {
  skill -= 2;
 }
 return skill;
}
/**
 * Calculates a Stat score for a monster
 */
int monster_stat(struct monster *mon, int stat_type)
{
 struct monster_race *race = mon->race;
 int stat = 0;
 int mhp = mon->maxhp;
 int base = 20;
    switch (stat_type) {
        case STAT_STR:
            stat = (race->blow[0].dice.dice * 2) + (race->hdice / 10) - 4;
            break;
        case STAT_DEX:
            msg("Can't determine the monster's Dex score.");
            break;
        case STAT_CON:
            if (mhp < base) {
                while (mhp < base) {
                    stat--;
                    base = (base * 10) / 12;
                }
            } else if (mhp >= base) {
                stat--;
                while (mhp >= base) {
                    stat++;
                    base = (base * 12) / 10;
                }
            }
            break;
        case STAT_GRA:
            msg("Can't determine the monster's Gra score.");
            break;
        default:
            msg("Asked for an invalid monster stat.");
            break;
    }
 return stat;
}
/**
 * ------------------------------------------------------------------------
 * Speed
 * ------------------------------------------------------------------------ */
/**
 * Calculate the speed of a given monster
 */
void calc_monster_speed(struct monster *mon)
{
 int speed;
 /* Paranoia */
 if (!mon) return;
 /* Get the monster base speed */
 speed = mon->race->speed;
 /* Factor in the hasting and slowing counters */
 if (mon->m_timed[MON_TMD_FAST]) speed += 1;
 if (mon->m_timed[MON_TMD_SLOW]) speed -= 1;
 if (speed < 1) speed = 1;
 /* Set the speed and return */
 mon->mspeed = speed;
 return;
}
/**
 * \file mon-desc.c
 * \brief Monster description
 *
 * Copyright (c) 1997-2007 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Perform simple English pluralization on a monster name.
 */
void plural_aux(char *name, size_t max)
{
 size_t name_len = strlen(name);
 assert(name_len != 0);
 if (name[name_len - 1] == 's')
  my_strcat(name, "es", max);
 else
  my_strcat(name, "s", max);
}
/**
 * Helper function for display monlist.  Prints the number of creatures,
 * followed by either a singular or plural version of the race name as
 * appropriate.
 */
void get_mon_name(char *buf, size_t buflen,
      const struct monster_race *race, int num)
{
 assert(race != NULL);
    /* Unique names don't have a number */
 if (rf_has(race->flags, RF_UNIQUE)) {
  strnfmt(buf, buflen, "[U] %s", race->name);
    } else {
     strnfmt(buf, buflen, "%3d ", num);
     if (num == 1) {
         my_strcat(buf, race->name, buflen);
     } else if (race->plural != NULL) {
         my_strcat(buf, race->plural, buflen);
     } else {
         my_strcat(buf, race->name, buflen);
         plural_aux(buf, buflen);
     }
    }
}
/**
 * Builds a string describing a monster in some way.
 *
 * We can correctly describe monsters based on their visibility.
 * We can force all monsters to be treated as visible or invisible.
 * We can build nominatives, objectives, possessives, or reflexives.
 * We can selectively pronominalize hidden, visible, or all monsters.
 * We can use definite or indefinite descriptions for hidden monsters.
 * We can use definite or indefinite descriptions for visible monsters.
 *
 * Pronominalization involves the gender whenever possible and allowed,
 * so that by cleverly requesting pronominalization / visibility, you
 * can get messages like "You hit someone.  She screams in agony!".
 *
 * Reflexives are acquired by requesting Objective plus Possessive.
 *
 * Note that "offscreen" monsters will get a special "(offscreen)"
 * notation in their name if they are visible but offscreen.  This
 * may look silly with possessives, as in "the rat's (offscreen)".
 * Perhaps the "offscreen" descriptor should be abbreviated.
 *
 * Mode Flags:
 *   0x01 --> Objective (or Reflexive)
 *   0x02 --> Possessive (or Reflexive)
 *   0x04 --> Use indefinites for hidden monsters ("something")
 *   0x08 --> Use indefinites for visible monsters ("a kobold")
 *   0x10 --> Pronominalize hidden monsters
 *   0x20 --> Pronominalize visible monsters
 *   0x40 --> Assume the monster is hidden
 *   0x80 --> Assume the monster is visible
 *  0x100 --> Capitalise monster name
 *  0x200 --> Add a comma if the name includes an unterminated phrase,
 *            "Wormtongue, Agent of Saruman" is an example
 *
 * Useful Modes:
 *   0x00 --> Full nominative name ("the kobold") or "it"
 *   0x04 --> Full nominative name ("the kobold") or "something"
 *   0x80 --> Banishment resistance name ("the kobold")
 *   0x88 --> Killing name ("a kobold")
 *   0x22 --> Possessive, genderized if visable ("his") or "its"
 *   0x23 --> Reflexive, genderized if visable ("himself") or "itself"
 */
void monster_desc(char *desc, size_t max, const struct monster *mon, int mode)
{
 assert(mon != NULL);
 /* Can we see it? (forced, or not hidden + visible) */
 bool seen = (mode & MDESC_SHOW) ||
  (!(mode & MDESC_HIDE) && monster_is_visible(mon));
 /* Sexed pronouns (seen and forced, or unseen and allowed) */
 bool use_pronoun = (seen && (mode & MDESC_PRO_VIS)) ||
   (!seen && (mode & MDESC_PRO_HID));
 /* Monster race, or hallucinatory race */
 struct monster_race *race = (player && player->timed[TMD_IMAGE]) ?
  mon->image_race : mon->race;
 /* First, try using pronouns, or describing hidden monsters */
 if (!seen || use_pronoun) {
  const char *choice = "it";
  /* an encoding of the monster "sex" */
  int msex = 0x00;
  /* Extract the gender (if applicable) */
  if (use_pronoun) {
   if (rf_has(race->flags, RF_FEMALE)) {
    msex = 0x20;
   } else if (rf_has(race->flags, RF_MALE)) {
    msex = 0x10;
   }
  }
  /* Brute force: split on the possibilities */
  switch (msex + (mode & 0x07)) {
   /* Neuter */
   case 0x00: choice = "it"; break;
   case 0x01: choice = "it"; break;
   case 0x02: choice = "its"; break;
   case 0x03: choice = "itself"; break;
   case 0x04: choice = "something"; break;
   case 0x05: choice = "something"; break;
   case 0x06: choice = "something's"; break;
   case 0x07: choice = "itself"; break;
   /* Male */
   case 0x10: choice = "he"; break;
   case 0x11: choice = "him"; break;
   case 0x12: choice = "his"; break;
   case 0x13: choice = "himself"; break;
   case 0x14: choice = "someone"; break;
   case 0x15: choice = "someone"; break;
   case 0x16: choice = "someone's"; break;
   case 0x17: choice = "himself"; break;
   /* Female */
   case 0x20: choice = "she"; break;
   case 0x21: choice = "her"; break;
   case 0x22: choice = "her"; break;
   case 0x23: choice = "herself"; break;
   case 0x24: choice = "someone"; break;
   case 0x25: choice = "someone"; break;
   case 0x26: choice = "someone's"; break;
   case 0x27: choice = "herself"; break;
  }
  my_strcpy(desc, choice, max);
 } else if ((mode & MDESC_POSS) && (mode & MDESC_OBJE)) {
  /* The monster is visible, so use its gender */
  if (rf_has(race->flags, RF_FEMALE))
   my_strcpy(desc, "herself", max);
  else if (rf_has(race->flags, RF_MALE))
   my_strcpy(desc, "himself", max);
  else
   my_strcpy(desc, "itself", max);
 } else {
  const char *comma_pos;
  /* Unique, indefinite or definite */
  if (rf_has(race->flags, RF_UNIQUE)) {
   /* Start with the name (thus nominative and objective) */
   /*
			 * Strip off descriptive phrase if a possessive will be
			 * added.
			 */
   if ((mode & MDESC_POSS)
     && rf_has(race->flags, RF_NAME_COMMA)
     && (comma_pos = strchr(race->name, ','))
     && comma_pos - race->name < 1024) {
    strnfmt(desc, max, "%.*s",
     (int) (comma_pos - race->name),
     race->name);
   } else {
    my_strcpy(desc, race->name, max);
   }
  } else {
   if (mode & MDESC_IND_VIS) {
    /* XXX Check plurality for "some" */
    /* Indefinite monsters need an indefinite article */
    my_strcpy(desc, is_a_vowel(race->name[0]) ? "an " : "a ", max);
   } else {
    /* Definite monsters need a definite article */
    my_strcpy(desc, "the ", max);
   }
   /*
			 * As with uniques, strip off phrase if a possessive
			 * will be added.
			 */
   if ((mode & MDESC_POSS)
     && rf_has(race->flags, RF_NAME_COMMA)
     && (comma_pos = strchr(race->name, ','))
     && comma_pos - race->name < 1024) {
    my_strcat(desc, format("%.*s",
     (int) (comma_pos - race->name),
     race->name), max);
   } else {
    my_strcat(desc, race->name, max);
   }
  }
  if ((mode & MDESC_COMMA)
    && rf_has(race->flags, RF_NAME_COMMA)) {
   my_strcat(desc, ",", max);
  }
  /* Handle the possessive */
  /* XXX Check for trailing "s" */
  if (mode & MDESC_POSS) {
   my_strcat(desc, "'s", max);
  }
  /* Mention "offscreen" monsters */
  if (!panel_contains(mon->grid.y, mon->grid.x)) {
   my_strcat(desc, " (offscreen)", max);
  }
 }
 if (mode & MDESC_CAPITAL) {
  my_strcap(desc);
 }
}
/**
 * \file mon-group.c
 * \brief Monster group behaviours
 *
 * Copyright (c) 2018 Nick McConnell
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Allocate a new monster group
 */
static struct monster_group *monster_group_new(struct chunk *c)
{
 struct monster_group *group = mem_zalloc(sizeof(struct monster_group));
 flow_new(c, &group->flow);
 return group;
}
/**
 * Free a monster group
 */
void monster_group_free(struct chunk *c, struct monster_group *group)
{
 /* Free the member list */
 while (group->member_list) {
  struct mon_group_list_entry *next = group->member_list->next;
  mem_free(group->member_list);
  group->member_list = next;
 }
 flow_free(c, &group->flow);
 mem_free(group);
}
/**
 * Handle the leader of a group being removed
 *
 * In Sil, we just grab the next monster in the list
 */
static void monster_group_remove_leader(struct chunk *c, struct monster *leader,
          struct monster_group *group)
{
 struct mon_group_list_entry *list_entry = group->member_list;
 /* Look for another leader */
 while (list_entry) {
  struct monster *mon = cave_monster(c, list_entry->midx);
  if (!mon) {
   list_entry = list_entry->next;
   continue;
  } else {
   /* Appoint the new leader */
   group->leader = mon->midx;
   mon->group_info.role = MON_GROUP_LEADER;
   break;
  }
 }
 monster_groups_verify(c);
}
/**
 * Remove a monster from a monster group, deleting the group if it's empty.
 * Deal with removal of the leader.
 */
void monster_remove_from_group(struct chunk *c, struct monster *mon)
{
 struct monster_group *group = c->monster_groups[mon->group_info.index];
 struct mon_group_list_entry *list_entry = group->member_list;
 /* Check if the first entry is the one we want */
 if (list_entry->midx == mon->midx) {
  if (!list_entry->next) {
   /* If it's the only monster, remove the group */
   monster_group_free(c, group);
   c->monster_groups[mon->group_info.index] = NULL;
  } else {
   /* Otherwise remove the first entry */
   group->member_list = list_entry->next;
   mem_free(list_entry);
   if (group->leader == mon->midx) {
    monster_group_remove_leader(c, mon, group);
   }
  }
  return;
 }
 /* Check - necessary? */
 if (list_entry->next == NULL) {
  quit_fmt("Bad group: index=%d, monster=%d", mon->group_info.index,
     mon->midx);
 }
 /* We have to look further down the member list */
 while (list_entry->next) {
  if (list_entry->next->midx == mon->midx) {
   struct mon_group_list_entry *remove = list_entry->next;
   list_entry->next = list_entry->next->next;
   mem_free(remove);
   if (group->leader == mon->midx) {
    monster_group_remove_leader(c, mon, group);
   }
   break;
  }
  list_entry = list_entry->next;
 }
 group->size--;
 monster_groups_verify(c);
}
/**
 * Get the next available monster group index
 */
int monster_group_index_new(struct chunk *c)
{
 int index;
 for (index = 1; index < z_info->level_monster_max; index++) {
  if (!(c->monster_groups[index])) return index;
 }
 /* Fail, very unlikely */
 return 0;
}
/**
 * Add a monster to an existing monster group
 */
void monster_add_to_group(struct chunk *c, struct monster *mon,
        struct monster_group *group)
{
 struct mon_group_list_entry *list_entry;
 /* Confirm we're adding to the right group */
 assert(mon->group_info.index == group->index);
 /* Make a new list entry and add it to the start of the list */
 list_entry = mem_zalloc(sizeof(struct mon_group_list_entry));
 list_entry->midx = mon->midx;
 list_entry->next = group->member_list;
 group->member_list = list_entry;
 group->size++;
 mon->group_info.role = MON_GROUP_MEMBER;
}
/**
 * Make a monster group for a single monster
 */
static void monster_group_start(struct chunk *c, struct monster *mon)
{
 /* Get a group and a group index */
 struct monster_group *group = monster_group_new(c);
 int index = monster_group_index_new(c);
 assert(index);
 /* Put the group in the group list */
 c->monster_groups[index] = group;
 /* Fill out the group */
 group->index = index;
 group->leader = mon->midx;
 group->member_list = mem_zalloc(sizeof(struct mon_group_list_entry));
 group->member_list->midx = mon->midx;
 group->size = 1;
 /* Write the index to the monster's group info, make it leader */
 mon->group_info.index = index;
 mon->group_info.role = MON_GROUP_LEADER;
}
/**
 * Assign a monster to a monster group
 */
void monster_group_assign(struct chunk *c, struct monster *mon,
        struct monster_group_info info, bool loading)
{
 int index = info.index;
 struct monster_group *group = monster_group_by_index(c, index);
 if (!loading) {
  /* For newly created monsters, use the group start and add functions */
  if (group) {
   monster_add_to_group(c, mon, group);
  } else {
   monster_group_start(c, mon);
  }
 } else {
  /* For loading from a savefile, build by hand */
  struct mon_group_list_entry *entry = mem_zalloc(sizeof(*entry));
  /* Check the index */
  index = info.index;
  if (!index) {
   /* Everything should have a group */
   quit_fmt("Monster %d has no group", mon->midx);
  }
  /* Fill out the group, creating if necessary */
  group = monster_group_by_index(c, index);
  if (!group) {
   group = monster_group_new(c);
   group->index = index;
   c->monster_groups[index] = group;
  }
  if (info.role == MON_GROUP_LEADER) {
   group->leader = mon->midx;
  }
  /* Add this monster */
  entry->midx = mon->midx;
  entry->next = group->member_list;
  group->member_list = entry;
  group->size++;
 }
}
/**
 * Get the index of a monster group
 */
int monster_group_index(struct monster_group *group)
{
 return group->index;
}
/**
 * Get a monster group from its index
 */
struct monster_group *monster_group_by_index(struct chunk *c, int index)
{
 return index ? c->monster_groups[index] : NULL;
}
/**
 * Change the group record of the index of a monster
 */
bool monster_group_change_index(struct chunk *c, int new, int old)
{
 int index = cave_monster(c, old)->group_info.index;
 struct monster_group *group = monster_group_by_index(c, index);
 struct mon_group_list_entry *entry = group->member_list;
 if (group->leader == old) {
  group->leader = new;
 }
 while (entry) {
  if (entry->midx == old) {
   entry->midx = new;
   return true;
  }
  entry = entry->next;
 }
 return false;
}
/**
 * Get the size of a monster's group
 */
int monster_group_size(struct chunk *c, const struct monster *mon)
{
 int index = mon->group_info.index;
 struct monster_group *group = c->monster_groups[index];
 return group->size;
}
/**
 * Get the index of the leader of a monster group
 */
int monster_group_leader_idx(struct monster_group *group)
{
 return group->leader;
}
/**
 * Get the leader of a monster's group
 */
struct monster *monster_group_leader(struct chunk *c, struct monster *mon)
{
 int index = mon->group_info.index;
 struct monster_group *group = c->monster_groups[index];
 return cave_monster(c, group->leader);
}
/**
 * Set the centre of a new flow for a monster group, and update the flow
 */
void monster_group_new_wandering_flow(struct chunk *c, struct monster *mon,
           struct loc tgrid)
{
 int i;
 struct monster_group *group = monster_group_by_index(c,
               mon->group_info.index);
 struct monster *leader = cave_monster(c, group->leader);
 struct monster_race *race = !!leader ? leader->race : NULL;
 struct loc grid;
 /* On loading, the leader may not be loaded yet, so set this when it is */
 if (!leader) return;
 /* Territorial monsters target their creation location; same with
	 * the tutorial */
 if (rf_has(race->flags, RF_TERRITORIAL) || in_tutorial()) {
  /* They only pick a new location on creation.  Detect this using the
		 * fact that speed hasn't been determined yet on creation */
  if (mon->mspeed == 0) {
   group->flow.centre = leader->grid;
   update_flow(c, &group->flow, leader);
  }
 } else if (square_in_bounds_fully(c, tgrid)) {
  /* If a location was requested, use that */
  group->flow.centre = tgrid;
  update_flow(c, &group->flow, leader);
 } else {
  /* Otherwise choose a location */
  if (rf_has(race->flags, RF_SMART) &&
   !rf_has(race->flags, RF_TERRITORIAL) &&
   (player->depth != z_info->dun_depth) && one_in_(5) &&
   cave_find(c, &grid, square_isstairs) &&
   !square_isplayer(c, grid) && !square_isvault(c, grid)) {
   /* Sometimes intelligent monsters want to pick a staircase and leave
			 * the level */
   group->flow.centre = grid;
   update_flow(c, &group->flow, leader);
  } else {
   /* Otherwise pick a random location (on a floor, in a room, and not
			 * in a vault) */
   for (i = 0; i < 100; i++) {
    grid.y = randint0(c->height);
    grid.x = randint0(c->width);
    if (square_in_bounds_fully(c, grid) &&
     square_isfloor(c, grid) &&
     square_isroom(c, grid) &&
     !square_isvault(c, grid)) {
     group->flow.centre = grid;
     update_flow(c, &group->flow, leader);
     break;
    }
   }
  }
 }
 /* Reset the pause (if any) */
 group->wandering_pause = 0;
}
/**
 * Verify the integrity of all the monster groups
 */
void monster_groups_verify(struct chunk *c)
{
 int i;
 for (i = 0; i < z_info->level_monster_max; i++) {
  if (c->monster_groups[i]) {
   struct monster_group *group = c->monster_groups[i];
   struct mon_group_list_entry *entry = group->member_list;
   bool leader_found = false;
   while (entry) {
    struct monster *mon = cave_monster(c, entry->midx);
    struct monster_group_info info = mon->group_info;
    if (info.index != i) {
     quit_fmt("Bad group index: group: %d, monster: %d", i,
        info.index);
    }
    if (info.role == MON_GROUP_LEADER) {
     if (leader_found) {
      assert(0);
     }
     leader_found = true;
    }
    entry = entry->next;
   }
  }
 }
}
/**
 * \file mon-init.c
 * \brief Monster initialization routines.
 *
 * Copyright (c) 1997 Ben Harrison
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
struct blow_method *blow_methods;
struct blow_effect *blow_effects;
struct monster_pain *pain_messages;
struct monster_pursuit *pursuit_messages;
struct monster_warning *warning_messages;
struct monster_spell *monster_spells;
struct monster_base *rb_info;
struct monster_race *r_info;
const struct monster_race *ref_race = NULL;
struct monster_lore *l_list;
const char *r_info_flags[] =
{
/**
 * \file list-mon-race-flags.h
 * \brief monster race flags
 *
 */
/* symbol		type			descr */
"NONE",
"UNIQUE",
"QUESTOR",
"MALE",
"FEMALE",
"NAME_COMMA",
"SPECIAL_GEN",
"CHAR_CLEAR",
"ATTR_MULTI",
"ATTR_FLICKER",
"FORCE_DEPTH",
"INVISIBLE",
"MULTIPLY",
"REGENERATE",
"NO_CRIT",
"RES_CRIT",
"FRIEND",
"FRIENDS",
"ESCORT",
"ESCORTS",
"UNIQUE_FRIEND",
"NEVER_MOVE",
"HIDDEN_MOVE",
"RAND_25",
"RAND_50",
"GLOW",
"TERRITORIAL",
"SHORT_SIGHTED",
"MINDLESS",
"SMART",
"CRUEL_BLOW",
"EXCHANGE",
"RIPOSTE",
"FLANKING",
"CHARGE",
"ELFBANE",
"KNOCK_BACK",
"CRIPPLING",
"OPPORTUNIST",
"ZONE",
"DROP_33",
"DROP_100",
"DROP_1D2",
"DROP_2D2",
"DROP_3D2",
"DROP_4D2",
"DROP_GOOD",
"DROP_GREAT",
"FLYING",
"PASS_DOOR",
"UNLOCK_DOOR",
"OPEN_DOOR",
"BASH_DOOR",
"PASS_WALL",
"KILL_WALL",
"TUNNEL_WALL",
"TAKE_ITEM",
"KILL_ITEM",
"ORC",
"TROLL",
"SERPENT",
"DRAGON",
"RAUKO",
"SPIDER",
"WOLF",
"UNDEAD",
"HURT_LIGHT",
"STONE",
"HURT_FIRE",
"HURT_COLD",
"RES_FIRE",
"RES_COLD",
"RES_POIS",
"NO_FEAR",
"NO_STUN",
"NO_CONF",
"NO_SLEEP",
"NO_SLOW",
/* end flags */

 NULL
};
const char *r_info_spell_flags[] =
{
/**
 * \file list-mon-spells.h
 * \brief List of monster spell flags 
 *
 * Flags below start from 0 on line 13, so a flag's sequence number is its line
 * number minus 13.
 *
 * Fields:
 * name - spell name
 * type - spell type
 */
/* 	name		type*/
"NONE",
"ARROW1",
"ARROW2",
"BOULDER",
"BR_FIRE",
"BR_COLD",
"BR_POIS",
"BR_DARK",
"EARTHQUAKE",
"SHRIEK",
"SCREECH",
"DARKNESS",
"FORGET",
"SCARE",
"CONF",
"HOLD",
"SLOW",
"SNG_BIND",
"SNG_PIERCE",
"SNG_OATHS",
"MAX",

 NULL
};
static const char *obj_flags[] =
{
 "NONE",
/**
 * \file list-object-flags.h
 * \brief object flags for all objects
 *
 * Changing flag order will break savefiles. Flags
 * below start from 1 on line 17, so a flag's sequence number is its line
 * number minus 16.
 *
 * Each sustain flag (SUST_*) has a matching stat in src/list-stats.h,
 * which should be at the same index in that file as the sustain in this file.
 *
 * The second argument to OF is the label used in the debugging commands
 * object flag display.  At most the first five characters are used.
 *
 * Flag properties are defined in lib/gamedata/object_property.txt
 */
"SUST_STR",
"SUST_DEX",
"SUST_CON",
"SUST_GRA",
"PROT_FEAR",
"PROT_BLIND",
"PROT_CONF",
"PROT_STUN",
"PROT_HALLU",
"SLOW_DIGEST",
"REGEN",
"SEE_INVIS",
"FREE_ACT",
"RADIANCE",
"LIGHT",
"SPEED",
"SHARPNESS",
"SHARPNESS2",
"VAMPIRIC",
"BURNS_OUT",
"TAKES_FUEL",
"NO_FUEL",
"COWARDICE",
"HUNGER",
"DARKNESS",
"DANGER",
"HAUNTED",
"AGGRAVATE",
"CURSED",
"DIG_1",
"DIG_2",
"THROWING",
"INDESTRUCTIBLE",
"NO_SMITHING",
"NO_RANDOM",
"MITHRIL",
"AXE",
"POLEARM",
"ENCHANTABLE",
"HAND_AND_A_HALF",
"TWO_HANDED",
"MAX",

    ""
};
/**
 * Return the index of a flag from its name.
 */
static int flag_index_by_name(const char *name)
{
 size_t i;
 for (i = 0; i < N_ELEMENTS(obj_flags); i++) {
  if (streq(name, obj_flags[i])) {
   return i;
  }
 }
 return -1;
}
/**
 * ------------------------------------------------------------------------
 * Initialize monster blow methods
 * ------------------------------------------------------------------------ */
static struct blow_method *findmeth(const char *meth_name) {
 struct blow_method *meth = &blow_methods[1];
 while (meth) {
  if (streq(meth->name, meth_name))
   break;
  meth = meth->next;
 }
 return meth;
}
static enum parser_error parse_meth_name(struct parser *p) {
 const char *name = parser_getstr(p, "name");
 struct blow_method *h = parser_priv(p);
 struct blow_method *meth = mem_zalloc(sizeof *meth);
 meth->next = h;
 parser_setpriv(p, meth);
 meth->name = string_make(name);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_meth_cut(struct parser *p) {
 struct blow_method *meth = parser_priv(p);
 int val;
 assert(meth);
 val = parser_getuint(p, "cut");
 meth->cut = val ? true : false;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_meth_stun(struct parser *p) {
 struct blow_method *meth = parser_priv(p);
 int val;
 assert(meth);
 val = parser_getuint(p, "stun");
 meth->stun = val ? true : false;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_meth_miss(struct parser *p) {
 struct blow_method *meth = parser_priv(p);
 int val;
 assert(meth);
 val = parser_getuint(p, "miss");
 meth->miss = val ? true : false;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_meth_prt(struct parser *p) {
 struct blow_method *meth = parser_priv(p);
 int val;
 assert(meth);
 val = parser_getuint(p, "prt");
 meth->prt = val ? true : false;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_meth_message_type(struct parser *p)
{
 int msg_index;
 const char *type;
 struct blow_method *meth = parser_priv(p);
 assert(meth);
 if (parser_hasval(p, "msg")) {
  type = parser_getstr(p, "msg");
  msg_index = message_lookup_by_name(type);
  if (msg_index < 0)
   return PARSE_ERROR_INVALID_MESSAGE;
  meth->msgt = msg_index;
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_meth_act_msg(struct parser *p) {
 const char *message = parser_getstr(p, "act");
 struct blow_method *meth = parser_priv(p);
 struct blow_message *msg;
 if (!meth) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 msg = mem_zalloc(sizeof(*msg));
 msg->act_msg = string_make(message);
 msg->next = meth->messages;
 meth->messages = msg;
 meth->num_messages++;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_meth_desc(struct parser *p) {
 struct blow_method *meth = parser_priv(p);
 assert(meth);
 meth->desc = string_append(meth->desc, parser_getstr(p, "desc"));
 return PARSE_ERROR_NONE;
}
static struct parser *init_parse_meth(void) {
 struct parser *p = parser_new();
 parser_setpriv(p, NULL);
 parser_reg(p, "name str name", parse_meth_name);
 parser_reg(p, "cut uint cut", parse_meth_cut);
 parser_reg(p, "stun uint stun", parse_meth_stun);
 parser_reg(p, "miss uint miss", parse_meth_miss);
 parser_reg(p, "prt uint prt", parse_meth_prt);
 parser_reg(p, "msg ?str msg", parse_meth_message_type);
 parser_reg(p, "act str act", parse_meth_act_msg);
 parser_reg(p, "desc str desc", parse_meth_desc);
 return p;
}
static errr run_parse_meth(struct parser *p) {
 return parse_file_quit_not_found(p, "blow_methods");
}
static errr finish_parse_meth(struct parser *p) {
 struct blow_method *meth, *next = NULL;
 int count = 1;
 /* Count the entries */
 z_info->blow_methods_max = 0;
 meth = parser_priv(p);
 while (meth) {
  z_info->blow_methods_max++;
  meth = meth->next;
 }
 /* Allocate the direct access list and copy the data to it */
 blow_methods = mem_zalloc((z_info->blow_methods_max + 1) * sizeof(*meth));
 for (meth = parser_priv(p); meth; meth = next, count++) {
  memcpy(&blow_methods[count], meth, sizeof(*meth));
  next = meth->next;
  if (next)
   blow_methods[count].next = &blow_methods[count + 1];
  else
   blow_methods[count].next = NULL;
  mem_free(meth);
 }
 z_info->blow_methods_max += 1;
 parser_destroy(p);
 return 0;
}
static void cleanup_meth(void)
{
 struct blow_method *meth = &blow_methods[1];
 while (meth) {
  struct blow_message *msg = meth->messages;
  string_free(meth->desc);
  while (msg) {
   struct blow_message *next = msg->next;
   string_free(msg->act_msg);
   mem_free(msg);
   msg = next;
  }
  string_free(meth->name);
  meth = meth->next;
 }
 mem_free(blow_methods);
}
struct file_parser meth_parser = {
 "blow_methods",
 init_parse_meth,
 run_parse_meth,
 finish_parse_meth,
 cleanup_meth
};
/**
 * ------------------------------------------------------------------------
 * Initialize monster blow effects
 * ------------------------------------------------------------------------ */
static struct blow_effect *findeff(const char *eff_name) {
 struct blow_effect *eff = &blow_effects[0];
 while (eff) {
  if (streq(eff->name, eff_name))
   break;
  eff = eff->next;
 }
 return eff;
}
static enum parser_error parse_eff_name(struct parser *p) {
 const char *name = parser_getstr(p, "name");
 struct blow_effect *h = parser_priv(p);
 struct blow_effect *eff = mem_zalloc(sizeof *eff);
 eff->next = h;
 parser_setpriv(p, eff);
 eff->name = string_make(name);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_eff_power(struct parser *p) {
 struct blow_effect *eff = parser_priv(p);
 assert(eff);
 eff->power = parser_getint(p, "power");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_eff_eval(struct parser *p) {
 struct blow_effect *eff = parser_priv(p);
 assert(eff);
 eff->eval = parser_getint(p, "eval");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_eff_desc(struct parser *p) {
 struct blow_effect *eff = parser_priv(p);
 assert(eff);
 eff->desc = string_append(eff->desc, parser_getstr(p, "desc"));
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_eff_effect_type(struct parser *p) {
 struct blow_effect *eff = parser_priv(p);
 assert(eff);
 eff->effect_type = string_make(parser_getstr(p, "type"));
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_eff_resist(struct parser *p) {
 struct blow_effect *eff = parser_priv(p);
 const char *resist = parser_getstr(p, "resist");
 assert(eff);
 if (streq(eff->effect_type, "element")) {
  eff->resist = proj_name_to_idx(resist);
 } else if (streq(eff->effect_type, "flag")) {
  eff->resist = flag_index_by_name(resist);
 } else {
  return PARSE_ERROR_MISSING_BLOW_EFF_TYPE;
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_eff_dam_type(struct parser *p) {
 struct blow_effect *eff = parser_priv(p);
 int type;
 assert(eff);
 type = proj_name_to_idx(parser_getstr(p, "type"));
 eff->dam_type = type >= 0 ? type : PROJ_HURT;
 return PARSE_ERROR_NONE;
}
static struct parser *init_parse_eff(void) {
 struct parser *p = parser_new();
 parser_setpriv(p, NULL);
 parser_reg(p, "name str name", parse_eff_name);
 parser_reg(p, "power int power", parse_eff_power);
 parser_reg(p, "eval int eval", parse_eff_eval);
 parser_reg(p, "desc str desc", parse_eff_desc);
 parser_reg(p, "effect-type str type", parse_eff_effect_type);
 parser_reg(p, "resist str resist", parse_eff_resist);
 parser_reg(p, "dam-type str type", parse_eff_dam_type);
 return p;
}
static errr run_parse_eff(struct parser *p) {
 return parse_file_quit_not_found(p, "blow_effects");
}
static errr finish_parse_eff(struct parser *p) {
 struct blow_effect *eff, *next = NULL;
 int count;
 /* Count the entries */
 z_info->blow_effects_max = 0;
 eff = parser_priv(p);
 while (eff) {
  z_info->blow_effects_max++;
  eff = eff->next;
 }
 /* Allocate the direct access list and copy the data to it */
 count = z_info->blow_effects_max - 1;
 blow_effects = mem_zalloc((z_info->blow_effects_max + 1) * sizeof(*eff));
 for (eff = parser_priv(p); eff; eff = next, count--) {
  memcpy(&blow_effects[count], eff, sizeof(*eff));
  next = eff->next;
  if (count < z_info->blow_effects_max - 1)
   blow_effects[count].next = &blow_effects[count + 1];
  else
   blow_effects[count].next = NULL;
  mem_free(eff);
 }
 z_info->blow_effects_max++;
 parser_destroy(p);
 return 0;
}
static void cleanup_eff(void)
{
 struct blow_effect *eff = blow_effects;
 struct blow_effect *next;
 while (eff) {
  next = eff->next;
  string_free(eff->effect_type);
  string_free(eff->desc);
  string_free(eff->name);
  eff = next;
 }
 mem_free(blow_effects);
}
struct file_parser eff_parser = {
 "blow_effects",
 init_parse_eff,
 run_parse_eff,
 finish_parse_eff,
 cleanup_eff
};
/**
 * ------------------------------------------------------------------------
 * Initialize monster pain messages
 * ------------------------------------------------------------------------ */
static enum parser_error parse_pain_type(struct parser *p) {
 struct monster_pain *h = parser_priv(p);
 struct monster_pain *mp = mem_zalloc(sizeof *mp);
 mp->next = h;
 mp->pain_idx = parser_getuint(p, "index");
 parser_setpriv(p, mp);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_pain_message(struct parser *p) {
 struct monster_pain *mp = parser_priv(p);
 int i;
 if (!mp)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 for (i = 0; i < (int) N_ELEMENTS(mp->messages); i++)
  if (!mp->messages[i])
   break;
 if (i == (int) N_ELEMENTS(mp->messages))
  return PARSE_ERROR_TOO_MANY_ENTRIES;
 mp->messages[i] = string_make(parser_getstr(p, "message"));
 return PARSE_ERROR_NONE;
}
struct parser *init_parse_pain(void) {
 struct parser *p = parser_new();
 parser_setpriv(p, NULL);
 parser_reg(p, "type uint index", parse_pain_type);
 parser_reg(p, "message str message", parse_pain_message);
 return p;
}
static errr run_parse_pain(struct parser *p) {
 return parse_file_quit_not_found(p, "pain");
}
static errr finish_parse_pain(struct parser *p) {
 struct monster_pain *mp, *n;
 /* scan the list for the max id */
 z_info->pain_max = 0;
 mp = parser_priv(p);
 while (mp) {
  if (mp->pain_idx > z_info->pain_max)
   z_info->pain_max = mp->pain_idx;
  mp = mp->next;
 }
 /* allocate the direct access list and copy the data to it */
 pain_messages = mem_zalloc((z_info->pain_max + 1) * sizeof(*mp));
 for (mp = parser_priv(p); mp; mp = n) {
  memcpy(&pain_messages[mp->pain_idx], mp, sizeof(*mp));
  n = mp->next;
  if (n)
   pain_messages[mp->pain_idx].next = &pain_messages[n->pain_idx];
  else
   pain_messages[mp->pain_idx].next = NULL;
  mem_free(mp);
 }
 z_info->pain_max += 1;
 parser_destroy(p);
 return 0;
}
static void cleanup_pain(void)
{
 int idx, i;
 for (idx = 0; idx < z_info->pain_max; idx++) {
  for (i = 0; i < 3; i++) {
   string_free((char *)pain_messages[idx].messages[i]);
  }
 }
 mem_free(pain_messages);
}
struct file_parser pain_parser = {
 "pain messages",
 init_parse_pain,
 run_parse_pain,
 finish_parse_pain,
 cleanup_pain
};
/**
 * ------------------------------------------------------------------------
 * Initialize monster pursuit messages
 * ------------------------------------------------------------------------ */
static enum parser_error parse_pursuit_type(struct parser *p) {
 struct monster_pursuit *h = parser_priv(p);
 struct monster_pursuit *mp = mem_zalloc(sizeof *mp);
 mp->next = h;
 mp->idx = parser_getuint(p, "index");
 parser_setpriv(p, mp);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_pursuit_message_vis(struct parser *p) {
 struct monster_pursuit *mp = parser_priv(p);
 if (!mp)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 mp->msg_vis = string_make(parser_getstr(p, "message"));
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_pursuit_message_near(struct parser *p) {
 struct monster_pursuit *mp = parser_priv(p);
 if (!mp)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 mp->msg_close = string_make(parser_getstr(p, "message"));
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_pursuit_message_far(struct parser *p) {
 struct monster_pursuit *mp = parser_priv(p);
 if (!mp)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 mp->msg_far = string_make(parser_getstr(p, "message"));
 return PARSE_ERROR_NONE;
}
static struct parser *init_parse_pursuit(void) {
 struct parser *p = parser_new();
 parser_setpriv(p, NULL);
 parser_reg(p, "type uint index", parse_pursuit_type);
 parser_reg(p, "visible str message", parse_pursuit_message_vis);
 parser_reg(p, "close str message", parse_pursuit_message_near);
 parser_reg(p, "far str message", parse_pursuit_message_far);
 return p;
}
static errr run_parse_pursuit(struct parser *p) {
 return parse_file_quit_not_found(p, "pursuit");
}
static errr finish_parse_pursuit(struct parser *p) {
 struct monster_pursuit *mp, *n;
 /* scan the list for the max id */
 z_info->pursuit_max = 0;
 mp = parser_priv(p);
 while (mp) {
  if (mp->idx > z_info->pursuit_max)
   z_info->pursuit_max = mp->idx;
  mp = mp->next;
 }
 /* allocate the direct access list and copy the data to it */
 pursuit_messages = mem_zalloc((z_info->pursuit_max + 1) * sizeof(*mp));
 for (mp = parser_priv(p); mp; mp = n) {
  memcpy(&pursuit_messages[mp->idx], mp, sizeof(*mp));
  n = mp->next;
  if (n)
   pursuit_messages[mp->idx].next = &pursuit_messages[n->idx];
  else
   pursuit_messages[mp->idx].next = NULL;
  mem_free(mp);
 }
 z_info->pursuit_max += 1;
 parser_destroy(p);
 return 0;
}
static void cleanup_pursuit(void)
{
 int idx;
 for (idx = 0; idx < z_info->pursuit_max; idx++) {
  string_free((char *)pursuit_messages[idx].msg_vis);
  string_free((char *)pursuit_messages[idx].msg_close);
  string_free((char *)pursuit_messages[idx].msg_far);
 }
 mem_free(pursuit_messages);
}
struct file_parser pursuit_parser = {
 "pursuit messages",
 init_parse_pursuit,
 run_parse_pursuit,
 finish_parse_pursuit,
 cleanup_pursuit
};
/**
 * ------------------------------------------------------------------------
 * Initialize monster warning messages
 * ------------------------------------------------------------------------ */
static enum parser_error parse_warning_type(struct parser *p) {
 struct monster_warning *h = parser_priv(p);
 struct monster_warning *mw = mem_zalloc(sizeof *mw);
 mw->next = h;
 mw->idx = parser_getuint(p, "index");
 parser_setpriv(p, mw);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_warning_message_vis(struct parser *p) {
 struct monster_warning *mw = parser_priv(p);
 if (!mw)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 mw->msg_vis = string_make(parser_getstr(p, "message"));
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_warning_message_invis(struct parser *p) {
 struct monster_warning *mw = parser_priv(p);
 if (!mw)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 mw->msg_invis = string_make(parser_getstr(p, "message"));
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_warning_message_vis_silence(struct parser *p) {
 struct monster_warning *mw = parser_priv(p);
 if (!mw)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 mw->msg_vis_silence = string_make(parser_getstr(p, "message"));
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_warning_message_invis_silence(struct parser *p) {
 struct monster_warning *mw = parser_priv(p);
 if (!mw)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 mw->msg_invis_silence = string_make(parser_getstr(p, "message"));
 return PARSE_ERROR_NONE;
}
static struct parser *init_parse_warning(void) {
 struct parser *p = parser_new();
 parser_setpriv(p, NULL);
 parser_reg(p, "type uint index", parse_warning_type);
 parser_reg(p, "vis str message", parse_warning_message_vis);
 parser_reg(p, "invis str message", parse_warning_message_invis);
 parser_reg(p, "vis-silence str message", parse_warning_message_vis_silence);
 parser_reg(p, "invis-silence str message",
      parse_warning_message_invis_silence);
 return p;
}
static errr run_parse_warning(struct parser *p) {
 return parse_file_quit_not_found(p, "warning");
}
static errr finish_parse_warning(struct parser *p) {
 struct monster_warning *mw, *n;
 /* scan the list for the max id */
 z_info->warning_max = 0;
 mw = parser_priv(p);
 while (mw) {
  if (mw->idx > z_info->warning_max)
   z_info->warning_max = mw->idx;
  mw = mw->next;
 }
 /* allocate the direct access list and copy the data to it */
 warning_messages = mem_zalloc((z_info->warning_max + 1) * sizeof(*mw));
 for (mw = parser_priv(p); mw; mw = n) {
  memcpy(&warning_messages[mw->idx], mw, sizeof(*mw));
  n = mw->next;
  if (n)
   warning_messages[mw->idx].next = &warning_messages[n->idx];
  else
   warning_messages[mw->idx].next = NULL;
  mem_free(mw);
 }
 z_info->warning_max += 1;
 parser_destroy(p);
 return 0;
}
static void cleanup_warning(void)
{
 int idx;
 for (idx = 0; idx < z_info->warning_max; idx++) {
  string_free((char *)warning_messages[idx].msg_vis);
  string_free((char *)warning_messages[idx].msg_invis);
  string_free((char *)warning_messages[idx].msg_vis_silence);
  string_free((char *)warning_messages[idx].msg_invis_silence);
 }
 mem_free(warning_messages);
}
struct file_parser warning_parser = {
 "warning messages",
 init_parse_warning,
 run_parse_warning,
 finish_parse_warning,
 cleanup_warning
};
/**
 * ------------------------------------------------------------------------
 * Initialize monster spells
 * ------------------------------------------------------------------------ */
static enum parser_error parse_mon_spell_name(struct parser *p) {
 struct monster_spell *h = parser_priv(p);
 const char *name = parser_getstr(p, "name");
 struct monster_spell *s;
 int index;
 if (grab_name("monster spell", name, r_info_spell_flags,
   N_ELEMENTS(r_info_spell_flags) - 1, &index)) {
  return PARSE_ERROR_INVALID_SPELL_NAME;
 }
 s = mem_zalloc(sizeof(*s));
 s->next = h;
 s->index = index;
 s->max_range = z_info->max_range;
 s->level = mem_zalloc(sizeof(*(s->level)));
 parser_setpriv(p, s);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_mon_spell_message_type(struct parser *p)
{
 struct monster_spell *s = parser_priv(p);
 const char *type = parser_getsym(p, "type");
 int msg_index = message_lookup_by_name(type);
 if (!s) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 if (msg_index < 0) {
  return PARSE_ERROR_INVALID_MESSAGE;
 }
 s->msgt = msg_index;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_mon_spell_mana(struct parser *p) {
 struct monster_spell *s = parser_priv(p);
 if (!s) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 s->mana = parser_getuint(p, "mana");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_mon_spell_best_range(struct parser *p) {
 struct monster_spell *s = parser_priv(p);
 if (!s) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 s->best_range = parser_getuint(p, "range");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_mon_spell_max_range(struct parser *p) {
 struct monster_spell *s = parser_priv(p);
 if (!s) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 s->max_range = parser_getuint(p, "range");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_mon_spell_desire(struct parser *p) {
 struct monster_spell *s = parser_priv(p);
 if (!s) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 s->desire = parser_getuint(p, "desire");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_mon_spell_disturb(struct parser *p) {
 struct monster_spell *s = parser_priv(p);
 if (!s) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 s->disturb_stealth = parser_getuint(p, "value") > 0;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_mon_spell_use_past_range(struct parser *p) {
 struct monster_spell *s = parser_priv(p);
 if (!s) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 s->use_past_range = parser_getuint(p, "value");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_mon_spell_effect(struct parser *p) {
 struct monster_spell *s = parser_priv(p);
 struct effect *effect, *new_effect;
 if (!s) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 new_effect = mem_zalloc(sizeof(*new_effect));
 /* Go to the next vacant effect and set it to the new one  */
 if (s->effect) {
  effect = s->effect;
  while (effect->next)
   effect = effect->next;
  effect->next = new_effect;
 } else {
  s->effect = new_effect;
 }
 /* Fill in the detail */
 return grab_effect_data(p, new_effect);
}
static enum parser_error parse_mon_spell_dice(struct parser *p) {
 struct monster_spell *s = parser_priv(p);
 struct effect *effect;
 dice_t *dice;
 const char *string;
 if (!s) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 /* If there is no effect, assume that this is human and not parser error. */
 effect = s->effect;
 if (effect == NULL) {
  return PARSE_ERROR_NONE;
 }
 while (effect->next) effect = effect->next;
 dice = dice_new();
 if (dice == NULL) {
  return PARSE_ERROR_INVALID_DICE;
 }
 string = parser_getstr(p, "dice");
 if (dice_parse_string(dice, string)) {
  dice_free(effect->dice);
  effect->dice = dice;
 } else {
  dice_free(dice);
  return PARSE_ERROR_INVALID_DICE;
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_mon_spell_expr(struct parser *p) {
 struct monster_spell *s = parser_priv(p);
 struct effect *effect;
 expression_t *expression;
 expression_base_value_f function = NULL;
 const char *name;
 const char *base;
 const char *expr;
 if (!s) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 /* If there is no effect, assume that this is human and not parser error. */
 effect = s->effect;
 if (effect == NULL) {
  return PARSE_ERROR_NONE;
 }
 while (effect->next) effect = effect->next;
 /* If there are no dice, assume that this is human and not parser error. */
 if (effect->dice == NULL) {
  return PARSE_ERROR_NONE;
 }
 expression = expression_new();
 if (expression == NULL) {
  return PARSE_ERROR_INVALID_EXPRESSION;
 }
 name = parser_getsym(p, "name");
 base = parser_getsym(p, "base");
 expr = parser_getstr(p, "expr");
 function = effect_value_base_by_name(base);
 expression_set_base_value(expression, function);
 if (expression_add_operations_string(expression, expr) < 0) {
  expression_free(expression);
  return PARSE_ERROR_BAD_EXPRESSION_STRING;
 }
 if (dice_bind_expression(effect->dice, name, expression) < 0) {
  expression_free(expression);
  return PARSE_ERROR_UNBOUND_EXPRESSION;
 }
 /* The dice object makes a deep copy of the expression, so we can free it */
 expression_free(expression);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_mon_spell_effect_xtra(struct parser *p) {
 struct monster_spell *s = parser_priv(p);
 struct effect *effect, *new_effect;
 if (!s) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 new_effect = mem_zalloc(sizeof(*new_effect));
 /* Go to the next vacant effect and set it to the new one  */
 if (s->effect_xtra) {
  effect = s->effect_xtra;
  while (effect->next)
   effect = effect->next;
  effect->next = new_effect;
 } else {
  s->effect_xtra = new_effect;
 }
 /* Fill in the detail */
 return grab_effect_data(p, new_effect);
}
static enum parser_error parse_mon_spell_dice_xtra(struct parser *p) {
 struct monster_spell *s = parser_priv(p);
 struct effect *effect;
 dice_t *dice;
 const char *string;
 if (!s) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 /* If there is no effect, assume that this is human and not parser error. */
 effect = s->effect_xtra;
 if (effect == NULL) {
  return PARSE_ERROR_NONE;
 }
 while (effect->next) effect = effect->next;
 dice = dice_new();
 if (dice == NULL) {
  return PARSE_ERROR_INVALID_DICE;
 }
 string = parser_getstr(p, "dice");
 if (dice_parse_string(dice, string)) {
  dice_free(effect->dice);
  effect->dice = dice;
 } else {
  dice_free(dice);
  return PARSE_ERROR_INVALID_DICE;
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_mon_spell_expr_xtra(struct parser *p) {
 struct monster_spell *s = parser_priv(p);
 struct effect *effect;
 expression_t *expression;
 expression_base_value_f function = NULL;
 const char *name;
 const char *base;
 const char *expr;
 if (!s) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 /* If there is no effect, assume that this is human and not parser error. */
 effect = s->effect_xtra;
 if (effect == NULL) {
  return PARSE_ERROR_NONE;
 }
 while (effect->next) effect = effect->next;
 /* If there are no dice, assume that this is human and not parser error. */
 if (effect->dice == NULL) {
  return PARSE_ERROR_NONE;
 }
 expression = expression_new();
 if (expression == NULL) {
  return PARSE_ERROR_INVALID_EXPRESSION;
 }
 name = parser_getsym(p, "name");
 base = parser_getsym(p, "base");
 expr = parser_getstr(p, "expr");
 function = effect_value_base_by_name(base);
 expression_set_base_value(expression, function);
 if (expression_add_operations_string(expression, expr) < 0) {
  expression_free(expression);
  return PARSE_ERROR_BAD_EXPRESSION_STRING;
 }
 if (dice_bind_expression(effect->dice, name, expression) < 0) {
  expression_free(expression);
  return PARSE_ERROR_UNBOUND_EXPRESSION;
 }
 /* The dice object makes a deep copy of the expression, so we can free it */
 expression_free(expression);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_mon_spell_power_cutoff(struct parser *p) {
 struct monster_spell *s = parser_priv(p);
 struct monster_spell_level *l, *new;
 if (!s) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 new = mem_zalloc(sizeof(*new));
 new->power = parser_getint(p, "power");
 l = s->level;
 while (l->next) {
  l = l->next;
 }
 l->next = new;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_mon_spell_lore_desc(struct parser *p) {
 struct monster_spell *s = parser_priv(p);
 struct monster_spell_level *l;
 if (!s) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 l = s->level;
 while (l->next) {
  l = l->next;
 }
 l->lore_desc = string_append(l->lore_desc, parser_getstr(p, "text"));
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_mon_spell_message(struct parser *p) {
 struct monster_spell *s = parser_priv(p);
 const char *msg = (parser_hasval(p, "text")) ?
  parser_getstr(p, "text") : "";
 struct monster_spell_level *l;
 if (!s) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 l = s->level;
 while (l->next) {
  l = l->next;
 }
 l->message = string_append(l->message, msg);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_mon_spell_blind_message(struct parser *p) {
 struct monster_spell *s = parser_priv(p);
 const char *msg = (parser_hasval(p, "text")) ?
  parser_getstr(p, "text") : "";
 struct monster_spell_level *l;
 if (!s) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 l = s->level;
 while (l->next) {
  l = l->next;
 }
 l->blind_message = string_append(l->blind_message, msg);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_mon_spell_silence_message(struct parser *p) {
 struct monster_spell *s = parser_priv(p);
 const char *msg = (parser_hasval(p, "text")) ?
  parser_getstr(p, "text") : "";
 struct monster_spell_level *l;
 if (!s) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 l = s->level;
 while (l->next) {
  l = l->next;
 }
 l->silence_message = string_append(l->silence_message, msg);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_mon_spell_blind_silence_message(struct parser *p) {
 struct monster_spell *s = parser_priv(p);
 const char *msg = (parser_hasval(p, "text")) ?
  parser_getstr(p, "text") : "";
 struct monster_spell_level *l;
 if (!s) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 l = s->level;
 while (l->next) {
  l = l->next;
 }
 l->blind_silence_message = string_append(l->blind_silence_message, msg);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_mon_spell_smart_message(struct parser *p) {
 struct monster_spell *s = parser_priv(p);
 const char *msg = (parser_hasval(p, "text")) ?
  parser_getstr(p, "text") : "";
 struct monster_spell_level *l;
 if (!s) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 l = s->level;
 while (l->next) {
  l = l->next;
 }
 l->smart_message = string_append(l->smart_message, msg);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_mon_spell_smart_blind_message(struct parser *p) {
 struct monster_spell *s = parser_priv(p);
 const char *msg = (parser_hasval(p, "text")) ?
  parser_getstr(p, "text") : "";
 struct monster_spell_level *l;
 if (!s) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 l = s->level;
 while (l->next) {
  l = l->next;
 }
 l->smart_blind_message = string_append(l->smart_blind_message, msg);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_mon_spell_smart_silence_message(struct parser *p) {
 struct monster_spell *s = parser_priv(p);
 const char *msg = (parser_hasval(p, "text")) ?
  parser_getstr(p, "text") : "";
 struct monster_spell_level *l;
 if (!s) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 l = s->level;
 while (l->next) {
  l = l->next;
 }
 l->smart_silence_message = string_append(l->smart_silence_message, msg);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_mon_spell_smart_blind_silence_message(struct parser *p) {
 struct monster_spell *s = parser_priv(p);
 const char *msg = (parser_hasval(p, "text")) ?
  parser_getstr(p, "text") : "";
 struct monster_spell_level *l;
 if (!s) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 l = s->level;
 while (l->next) {
  l = l->next;
 }
 l->smart_blind_silence_message =
  string_append(l->smart_blind_silence_message, msg);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_mon_spell_save_message(struct parser *p) {
 struct monster_spell *s = parser_priv(p);
 struct monster_spell_level *l;
 if (!s) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 l = s->level;
 while (l->next) {
  l = l->next;
 }
 l->save_message = string_append(l->save_message, parser_getstr(p, "text"));
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_mon_spell_no_save_message(struct parser *p) {
 struct monster_spell *s = parser_priv(p);
 struct monster_spell_level *l;
 if (!s) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 l = s->level;
 while (l->next) {
  l = l->next;
 }
 l->no_save_message = string_append(l->no_save_message,
            parser_getstr(p, "text"));
 return PARSE_ERROR_NONE;
}
static struct parser *init_parse_mon_spell(void) {
 struct parser *p = parser_new();
 parser_setpriv(p, NULL);
 parser_reg(p, "name str name", parse_mon_spell_name);
 parser_reg(p, "msgt sym type", parse_mon_spell_message_type);
 parser_reg(p, "mana uint mana", parse_mon_spell_mana);
 parser_reg(p, "best-range uint range", parse_mon_spell_best_range);
 parser_reg(p, "max-range uint range", parse_mon_spell_max_range);
 parser_reg(p, "desire uint desire", parse_mon_spell_desire);
 parser_reg(p, "disturb uint value", parse_mon_spell_disturb);
 parser_reg(p, "use-past-range uint value", parse_mon_spell_use_past_range);
 parser_reg(p, "effect sym eff ?sym type ?int radius ?int other",
      parse_mon_spell_effect);
 parser_reg(p, "dice str dice", parse_mon_spell_dice);
 parser_reg(p, "expr sym name sym base str expr", parse_mon_spell_expr);
 parser_reg(p, "effect-xtra sym eff ?sym type ?int radius ?int other",
      parse_mon_spell_effect_xtra);
 parser_reg(p, "dice-xtra str dice", parse_mon_spell_dice_xtra);
 parser_reg(p, "expr-xtra sym name sym base str expr",
      parse_mon_spell_expr_xtra);
 parser_reg(p, "power-cutoff int power", parse_mon_spell_power_cutoff);
 parser_reg(p, "lore str text", parse_mon_spell_lore_desc);
 parser_reg(p, "message-vis ?str text", parse_mon_spell_message);
 parser_reg(p, "message-invis ?str text", parse_mon_spell_blind_message);
 parser_reg(p, "message-smart-vis ?str text", parse_mon_spell_smart_message);
 parser_reg(p, "message-smart-invis ?str text",
      parse_mon_spell_smart_blind_message);
 parser_reg(p, "message-silence-vis ?str text",
      parse_mon_spell_silence_message);
 parser_reg(p, "message-silence-invis ?str text",
      parse_mon_spell_blind_silence_message);
 parser_reg(p, "message-silence-smart-vis ?str text",
      parse_mon_spell_smart_silence_message);
 parser_reg(p, "message-silence-smart-invis ?str text",
      parse_mon_spell_smart_blind_silence_message);
 parser_reg(p, "message-save str text", parse_mon_spell_save_message);
 parser_reg(p, "message-no-save str text", parse_mon_spell_no_save_message);
 return p;
}
static errr run_parse_mon_spell(struct parser *p) {
 return parse_file_quit_not_found(p, "monster_spell");
}
static errr finish_parse_mon_spell(struct parser *p) {
 monster_spells = parser_priv(p);
 parser_destroy(p);
 return 0;
}
static void cleanup_mon_spell(void)
{
 struct monster_spell *rs = monster_spells;
 struct monster_spell *next;
 struct monster_spell_level *level;
 while (rs) {
  next = rs->next;
  level = rs->level;
  if (rs->effect_xtra) {
   free_effect(rs->effect_xtra);
  }
  free_effect(rs->effect);
  while (level) {
   struct monster_spell_level *next_level = level->next;
   string_free(level->lore_desc);
   string_free(level->message);
   string_free(level->blind_message);
   string_free(level->smart_message);
   string_free(level->smart_blind_message);
   string_free(level->silence_message);
   string_free(level->blind_silence_message);
   string_free(level->smart_silence_message);
   string_free(level->smart_blind_silence_message);
   string_free(level->save_message);
   string_free(level->no_save_message);
   mem_free(level);
   level = next_level;
  }
  mem_free(rs);
  rs = next;
 }
}
struct file_parser mon_spell_parser = {
 "monster_spell",
 init_parse_mon_spell,
 run_parse_mon_spell,
 finish_parse_mon_spell,
 cleanup_mon_spell
};
/**
 * ------------------------------------------------------------------------
 * Initialize monster bases
 * ------------------------------------------------------------------------ */
static enum parser_error parse_mon_base_name(struct parser *p) {
 struct monster_base *h = parser_priv(p);
 struct monster_base *rb = mem_zalloc(sizeof *rb);
 rb->next = h;
 rb->name = string_make(parser_getstr(p, "name"));
 parser_setpriv(p, rb);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_mon_base_glyph(struct parser *p) {
 struct monster_base *rb = parser_priv(p);
 if (!rb)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 rb->d_char = parser_getchar(p, "glyph");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_mon_base_pain(struct parser *p) {
 struct monster_base *rb = parser_priv(p);
 int pain_idx;
 if (!rb)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 pain_idx = parser_getuint(p, "pain");
 if (pain_idx >= z_info->pain_max)
  return PARSE_ERROR_OUT_OF_BOUNDS;
 rb->pain = &pain_messages[pain_idx];
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_mon_base_pursuit(struct parser *p) {
 struct monster_base *rb = parser_priv(p);
 int pursuit_idx;
 if (!rb)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 pursuit_idx = parser_getuint(p, "pursuit");
 if (pursuit_idx >= z_info->pursuit_max)
  return PARSE_ERROR_OUT_OF_BOUNDS;
 rb->pursuit = &pursuit_messages[pursuit_idx];
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_mon_base_warning(struct parser *p) {
 struct monster_base *rb = parser_priv(p);
 int warning_idx;
 if (!rb)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 warning_idx = parser_getuint(p, "warning");
 if (warning_idx >= z_info->warning_max)
  return PARSE_ERROR_OUT_OF_BOUNDS;
 rb->warning = &warning_messages[warning_idx];
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_mon_base_flags(struct parser *p) {
 struct monster_base *rb = parser_priv(p);
 char *flags;
 char *s;
 if (!rb)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 if (!parser_hasval(p, "flags"))
  return PARSE_ERROR_NONE;
 flags = string_make(parser_getstr(p, "flags"));
 s = strtok(flags, " |");
 while (s) {
  if (grab_flag(rb->flags, RF_SIZE, r_info_flags, s)) {
   plog(format("bad monster base flag: %s", s));
   string_free(flags);
   return PARSE_ERROR_INVALID_FLAG;
  }
  s = strtok(NULL, " |");
 }
 string_free(flags);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_mon_base_desc(struct parser *p) {
 struct monster_base *rb = parser_priv(p);
 if (!rb)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 rb->text = string_append(rb->text, parser_getstr(p, "desc"));
 return PARSE_ERROR_NONE;
}
static struct parser *init_parse_mon_base(void) {
 struct parser *p = parser_new();
 parser_setpriv(p, NULL);
 parser_reg(p, "name str name", parse_mon_base_name);
 parser_reg(p, "glyph char glyph", parse_mon_base_glyph);
 parser_reg(p, "pain uint pain", parse_mon_base_pain);
 parser_reg(p, "pursuit uint pursuit", parse_mon_base_pursuit);
 parser_reg(p, "warning uint warning", parse_mon_base_warning);
 parser_reg(p, "flags ?str flags", parse_mon_base_flags);
 parser_reg(p, "desc str desc", parse_mon_base_desc);
 return p;
}
static errr run_parse_mon_base(struct parser *p) {
 return parse_file_quit_not_found(p, "monster_base");
}
static errr finish_parse_mon_base(struct parser *p) {
 rb_info = parser_priv(p);
 parser_destroy(p);
 return 0;
}
static void cleanup_mon_base(void)
{
 struct monster_base *rb, *next;
 rb = rb_info;
 while (rb) {
  next = rb->next;
  string_free(rb->text);
  string_free(rb->name);
  mem_free(rb);
  rb = next;
 }
}
struct file_parser mon_base_parser = {
 "monster_base",
 init_parse_mon_base,
 run_parse_mon_base,
 finish_parse_mon_base,
 cleanup_mon_base
};
/**
 * ------------------------------------------------------------------------
 * Initialize monsters
 * ------------------------------------------------------------------------ */
static enum parser_error parse_monster_name(struct parser *p) {
 struct monster_race *h = parser_priv(p);
 struct monster_race *r = mem_zalloc(sizeof *r);
 r->next = h;
 r->name = string_make(parser_getstr(p, "name"));
 parser_setpriv(p, r);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_monster_base(struct parser *p) {
 struct monster_race *r = parser_priv(p);
 if (!r)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 r->base = lookup_monster_base(parser_getsym(p, "base"));
 if (r->base == NULL)
  return PARSE_ERROR_INVALID_MONSTER_BASE;
 /* The template sets the default display character */
 r->d_char = r->base->d_char;
 /* Give the monster its default flags */
 rf_union(r->flags, r->base->flags);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_monster_depth(struct parser *p) {
 struct monster_race *r = parser_priv(p);
 if (!r)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 r->level = parser_getint(p, "level");
 /* Level is default spell power */
 r->spell_power = r->level;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_monster_rarity(struct parser *p) {
 struct monster_race *r = parser_priv(p);
 if (!r)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 r->rarity = parser_getint(p, "rarity");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_monster_glyph(struct parser *p) {
 struct monster_race *r = parser_priv(p);
 if (!r)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 /* If the display character is specified, it overrides any template */
 r->d_char = parser_getchar(p, "glyph");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_monster_color(struct parser *p) {
 struct monster_race *r = parser_priv(p);
 const char *color;
 int attr;
 if (!r)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 color = parser_getsym(p, "color");
 if (strlen(color) > 1)
  attr = color_text_to_attr(color);
 else
  attr = color_char_to_attr(color[0]);
 if (attr < 0)
  return PARSE_ERROR_INVALID_COLOR;
 r->d_attr = attr;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_monster_speed(struct parser *p) {
 struct monster_race *r = parser_priv(p);
 if (!r)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 r->speed = parser_getint(p, "speed");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_monster_health(struct parser *p) {
 struct monster_race *r = parser_priv(p);
 struct random health;
 if (!r)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 health = parser_getrand(p, "dice");
 r->hdice = health.dice;
 r->hside = health.sides;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_monster_light(struct parser *p) {
 struct monster_race *r = parser_priv(p);
 if (!r)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 r->light = parser_getint(p, "light");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_monster_sleep(struct parser *p) {
 struct monster_race *r = parser_priv(p);
 if (!r)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 r->sleep = parser_getint(p, "sleep");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_monster_percept(struct parser *p) {
 struct monster_race *r = parser_priv(p);
 if (!r)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 r->per = parser_getint(p, "per");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_monster_stealth(struct parser *p) {
 struct monster_race *r = parser_priv(p);
 if (!r)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 r->stl = parser_getint(p, "stealth");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_monster_will(struct parser *p) {
 struct monster_race *r = parser_priv(p);
 if (!r)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 r->wil = parser_getint(p, "will");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_monster_song(struct parser *p) {
 struct monster_race *r = parser_priv(p);
 if (!r)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 r->song = parser_getint(p, "song");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_monster_protection(struct parser *p) {
 struct monster_race *r = parser_priv(p);
 struct random dice;
 if (!r)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 r->evn = parser_getint(p, "evn");
 if (parser_hasval(p, "dice")) {
  dice = parser_getrand(p, "dice");
  r->pd = dice.dice;
  r->ps = dice.sides;
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_monster_blow(struct parser *p) {
 struct monster_race *r = parser_priv(p);
 struct monster_blow *b;
 int att;
 if (!r)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 /* Go to the last valid blow, then allocate a new one */
 b = r->blow;
 if (!b) {
  r->blow = mem_zalloc(sizeof(struct monster_blow));
  b = r->blow;
 } else {
  while (b->next)
   b = b->next;
  b->next = mem_zalloc(sizeof(struct monster_blow));
  b = b->next;
 }
 /* Now read the data */
 b->method = findmeth(parser_getsym(p, "method"));
 if (!b->method)
  return PARSE_ERROR_UNRECOGNISED_BLOW;
 b->effect = findeff(parser_getsym(p, "effect"));
 if (!b->effect)
  return PARSE_ERROR_INVALID_EFFECT;
 att = parser_getuint(p, "att");
 if (parser_hasval(p, "damage")) {
  b->dice = parser_getrand(p, "damage");
 }
 /* Store the attack as the base of the dice */
 b->dice.base = att;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_monster_flags(struct parser *p) {
 struct monster_race *r = parser_priv(p);
 char *flags;
 char *s;
 if (!r)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 if (!parser_hasval(p, "flags"))
  return PARSE_ERROR_NONE;
 flags = string_make(parser_getstr(p, "flags"));
 s = strtok(flags, " |");
 while (s) {
  if (grab_flag(r->flags, RF_SIZE, r_info_flags, s)) {
   plog(format("bad monster race flag: %s", s));
   string_free(flags);
   return PARSE_ERROR_INVALID_FLAG;
  }
  s = strtok(NULL, " |");
 }
 string_free(flags);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_monster_desc(struct parser *p) {
 struct monster_race *r = parser_priv(p);
 if (!r)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 r->text = string_append(r->text, parser_getstr(p, "desc"));
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_monster_ranged_freq(struct parser *p) {
 struct monster_race *r = parser_priv(p);
 int pct;
 if (!r)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 pct = parser_getint(p, "freq");
 if (pct < 1 || pct > 100)
  return PARSE_ERROR_INVALID_SPELL_FREQ;
 r->freq_ranged = pct;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_monster_spell_power(struct parser *p) {
 struct monster_race *r = parser_priv(p);
 if (!r)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 r->spell_power = parser_getuint(p, "power");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_monster_spells(struct parser *p) {
 struct monster_race *r = parser_priv(p);
 char *flags;
 char *s;
 int ret = PARSE_ERROR_NONE;
 if (!r)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 flags = string_make(parser_getstr(p, "spells"));
 s = strtok(flags, " |");
 while (s) {
  if (grab_flag(r->spell_flags, RSF_SIZE, r_info_spell_flags, s)) {
   plog(format("bad monster spell flag: %s", s));
   ret = PARSE_ERROR_INVALID_FLAG;
   break;
  }
  s = strtok(NULL, " |");
 }
 mem_free(flags);
 return ret;
}
static void add_alternate_spell_message(struct monster_race *r,
  int s_idx, enum monster_altmsg_type msg_type, const char *msg)
{
 struct monster_altmsg *alt = mem_alloc(sizeof(*alt));
 alt->next = r->spell_msgs;
 r->spell_msgs = alt;
 if (msg == NULL || contains_only_spaces(msg)) {
  alt->message = string_make("");
 } else {
  alt->message = string_make(msg);
 }
 alt->msg_type = msg_type;
 assert(s_idx >= 0 && s_idx <= 0xFFFF);
 alt->index = (uint16_t) s_idx;
}
static enum parser_error parse_monster_msg_vis(struct parser *p) {
 struct monster_race *r = parser_priv(p);
 const char *spell = parser_getsym(p, "spell");
 const char *msg = (parser_hasval(p, "message")) ?
  parser_getstr(p, "message") : NULL;
 int s_idx;
 if (!r) return PARSE_ERROR_MISSING_RECORD_HEADER;
 if (grab_name("monster spell", spell, r_info_spell_flags,
   N_ELEMENTS(r_info_spell_flags) - 1, &s_idx))
   return PARSE_ERROR_INVALID_SPELL_NAME;
 add_alternate_spell_message(r, s_idx, MON_ALTMSG_SEEN, msg);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_monster_msg_invis(struct parser *p) {
 struct monster_race *r = parser_priv(p);
 const char *spell = parser_getsym(p, "spell");
 const char *msg = (parser_hasval(p, "message")) ?
  parser_getstr(p, "message") : NULL;
 int s_idx;
 if (!r) return PARSE_ERROR_MISSING_RECORD_HEADER;
 if (grab_name("monster spell", spell, r_info_spell_flags,
   N_ELEMENTS(r_info_spell_flags) - 1, &s_idx))
   return PARSE_ERROR_INVALID_SPELL_NAME;
 add_alternate_spell_message(r, s_idx, MON_ALTMSG_UNSEEN, msg);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_monster_drop(struct parser *p) {
 struct monster_race *r = parser_priv(p);
 struct monster_drop *d;
 struct object_kind *k;
 int tval, sval;
 if (!r)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 tval = tval_find_idx(parser_getsym(p, "tval"));
 if (tval < 0)
  return PARSE_ERROR_UNRECOGNISED_TVAL;
 sval = lookup_sval(tval, parser_getsym(p, "sval"));
 if (sval < 0)
  return PARSE_ERROR_UNRECOGNISED_SVAL;
 k = lookup_kind(tval, sval);
 if (!k)
  return PARSE_ERROR_UNRECOGNISED_SVAL;
 d = mem_zalloc(sizeof *d);
 d->kind = k;
 d->percent_chance = parser_getuint(p, "chance");
 d->dice = parser_getrand(p, "dice");
 d->next = r->drops;
 r->drops = d;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_monster_drop_artifact(struct parser *p) {
 struct monster_race *r = parser_priv(p);
 struct monster_drop *d;
 const struct artifact *art;
 if (!r)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 art = lookup_artifact_name(parser_getstr(p, "name"));
 if (!art)
  return PARSE_ERROR_NO_ARTIFACT_NAME;
 d = mem_zalloc(sizeof *d);
 d->art = art;
 d->percent_chance = 100;
 d->next = r->drops;
 r->drops = d;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_monster_plural(struct parser *p)
{
 struct monster_race *r = parser_priv(p);
 if (r == NULL)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 if (parser_hasval(p, "plural")) {
  const char *plural = parser_getstr(p, "plural");
  if (strlen(plural) > 0)
   r->plural = string_make(plural);
  else
   r->plural = NULL;
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_monster_color_cycle(struct parser *p)
{
 struct monster_race *r = parser_priv(p);
 const char *group = parser_getsym(p, "group");
 const char *ccycle = parser_getsym(p, "cycle");
 if (r == NULL)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 if (group == NULL || strlen(group) == 0)
  return PARSE_ERROR_INVALID_VALUE;
 if (ccycle == NULL || strlen(ccycle) == 0)
  return PARSE_ERROR_INVALID_VALUE;
 visuals_cycler_set_cycle_for_race(r, group, ccycle);
 return PARSE_ERROR_NONE;
}
struct parser *init_parse_monster(void) {
 struct parser *p = parser_new();
 parser_setpriv(p, NULL);
 parser_reg(p, "name str name", parse_monster_name);
 parser_reg(p, "plural ?str plural", parse_monster_plural);
 parser_reg(p, "base sym base", parse_monster_base);
 parser_reg(p, "depth int level", parse_monster_depth);
 parser_reg(p, "rarity int rarity", parse_monster_rarity);
 parser_reg(p, "glyph char glyph", parse_monster_glyph);
 parser_reg(p, "color sym color", parse_monster_color);
 parser_reg(p, "speed int speed", parse_monster_speed);
 parser_reg(p, "health rand dice", parse_monster_health);
 parser_reg(p, "light int light", parse_monster_light);
 parser_reg(p, "sleep int sleep", parse_monster_sleep);
 parser_reg(p, "percept int per", parse_monster_percept);
 parser_reg(p, "stealth int stealth", parse_monster_stealth);
 parser_reg(p, "will int will", parse_monster_will);
 parser_reg(p, "song int song", parse_monster_song);
 parser_reg(p, "prot int evn ?rand dice", parse_monster_protection);
 parser_reg(p, "blow sym method sym effect uint att ?rand damage",
      parse_monster_blow);
 parser_reg(p, "flags ?str flags", parse_monster_flags);
 parser_reg(p, "desc str desc", parse_monster_desc);
 parser_reg(p, "ranged-freq int freq", parse_monster_ranged_freq);
 parser_reg(p, "spell-power uint power", parse_monster_spell_power);
 parser_reg(p, "spells str spells", parse_monster_spells);
 parser_reg(p, "message-vis sym spell ?str message", parse_monster_msg_vis);
 parser_reg(p, "message-invis sym spell ?str message", parse_monster_msg_invis);
 parser_reg(p, "drop sym tval sym sval uint chance rand dice",
      parse_monster_drop);
 parser_reg(p, "drop-artifact str name", parse_monster_drop_artifact);
 parser_reg(p, "color-cycle sym group sym cycle", parse_monster_color_cycle);
 return p;
}
static errr run_parse_monster(struct parser *p) {
 return parse_file_quit_not_found(p, "monster");
}
static errr finish_parse_monster(struct parser *p) {
 struct monster_race *r, *n;
 size_t i;
 int ridx;
 /* Scan the list for the max id and max blows */
 z_info->r_max = 0;
 z_info->mon_blows_max = 0;
 r = parser_priv(p);
 while (r) {
  int max_blows = 0;
  struct monster_blow *b = r->blow;
  z_info->r_max++;
  while (b) {
   b = b->next;
   max_blows++;
  }
  if (max_blows > z_info->mon_blows_max)
   z_info->mon_blows_max = max_blows;
  r = r->next;
 }
 /* Allocate the direct access list and copy the race records to it */
 r_info = mem_zalloc((z_info->r_max + 1) * sizeof(*r));
 ridx = z_info->r_max - 1;
 for (r = parser_priv(p); r; r = n, ridx--) {
  struct monster_blow *b_new;
  assert(ridx >= 0);
  /* Main record */
  memcpy(&r_info[ridx], r, sizeof(*r));
  r_info[ridx].ridx = ridx;
  n = r->next;
  if (ridx < z_info->r_max - 1)
   r_info[ridx].next = &r_info[ridx + 1];
  else
   r_info[ridx].next = NULL;
  /* Blows */
  b_new = mem_zalloc(z_info->mon_blows_max * sizeof(*b_new));
  if (r->blow) {
   struct monster_blow *b_temp, *b_old = r->blow;
   /* Allocate space and copy */
   for (i = 0; i < z_info->mon_blows_max; i++) {
    memcpy(&b_new[i], b_old, sizeof(*b_old));
    b_old = b_old->next;
    if (!b_old) break;
   }
   /* Make next point correctly */
   for (i = 0; i < z_info->mon_blows_max; i++)
    if (b_new[i].next)
     b_new[i].next = &b_new[i + 1];
   /* Tidy up */
   b_old = r->blow;
   b_temp = b_old;
   while (b_temp) {
    b_temp = b_old->next;
    mem_free(b_old);
    b_old = b_temp;
   }
  }
  r_info[ridx].blow = b_new;
  mem_free(r);
 }
 z_info->r_max += 1;
 /* Allocate space for the monster lore */
 l_list = mem_zalloc(z_info->r_max * sizeof(struct monster_lore));
 for (i = 0; i < z_info->r_max; i++) {
  struct monster_lore *l = &l_list[i];
  l->blows = mem_zalloc(z_info->mon_blows_max * sizeof(struct monster_blow));
  l->blow_known = mem_zalloc(z_info->mon_blows_max * sizeof(bool));
 }
 parser_destroy(p);
 return 0;
}
static void cleanup_monster(void)
{
 int ridx;
 for (ridx = 0; ridx < z_info->r_max; ridx++) {
  struct monster_race *r = &r_info[ridx];
  struct monster_altmsg *am;
  struct monster_drop *d;
  am = r->spell_msgs;
  while (am) {
   struct monster_altmsg *amn = am->next;
   string_free(am->message);
   mem_free(am);
   am = amn;
  }
  d = r->drops;
  while (d) {
   struct monster_drop *dn = d->next;
   mem_free(d);
   d = dn;
  }
  string_free(r->plural);
  string_free(r->text);
  string_free(r->name);
  mem_free(r->blow);
 }
 mem_free(r_info);
}
struct file_parser monster_parser = {
 "monster",
 init_parse_monster,
 run_parse_monster,
 finish_parse_monster,
 cleanup_monster
};
/**
 * ------------------------------------------------------------------------
 * Initialize monster lore
 * ------------------------------------------------------------------------ */
static enum parser_error parse_lore_name(struct parser *p) {
 struct monster_race *race = lookup_monster(parser_getstr(p, "name"));
 struct monster_lore *l = NULL;
 /* Only set lore if we have a race, to allow for non-existent monsters */
 if (race) {
  l = &l_list[race->ridx];
  l->ridx = race->ridx;
 }
 parser_setpriv(p, l);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_lore_base(struct parser *p) {
 struct monster_lore *l = parser_priv(p);
 struct monster_base *base = lookup_monster_base(parser_getsym(p, "base"));
 if (!l)
  return PARSE_ERROR_NONE;
 if (base == NULL)
  return PARSE_ERROR_INVALID_MONSTER_BASE;
 /* Know everything */
 l->all_known = true;
 rf_setall(l->flags);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_lore_counts(struct parser *p) {
 struct monster_lore *l = parser_priv(p);
 if (!l)
  return PARSE_ERROR_NONE;
 l->tsights = parser_getint(p, "sights");
 l->deaths = parser_getint(p, "deaths");
 l->tkills = parser_getint(p, "kills");
 l->notice = parser_getint(p, "notice");
 l->ignore = parser_getint(p, "ignore");
 l->ranged = parser_getint(p, "ranged");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_lore_blow(struct parser *p) {
 struct monster_lore *l = parser_priv(p);
 struct blow_method *method = NULL;
 struct blow_effect *effect = NULL;
 int seen = 0, index = 0;
 struct random dam = { 0, 0, 0, 0 };
 if (!l)
  return PARSE_ERROR_NONE;
 /* Read in all the data */
 method = findmeth(parser_getsym(p, "method"));
 if (!method)
  return PARSE_ERROR_UNRECOGNISED_BLOW;
 if (parser_hasval(p, "effect")) {
  effect = findeff(parser_getsym(p, "effect"));
  if (!effect)
   return PARSE_ERROR_INVALID_EFFECT;
 }
 if (parser_hasval(p, "damage"))
  dam = parser_getrand(p, "damage");
 if (parser_hasval(p, "seen"))
  seen = parser_getint(p, "seen");
 if (parser_hasval(p, "index"))
  index = parser_getint(p, "index");
 if (index >= z_info->mon_blows_max)
  return PARSE_ERROR_TOO_MANY_ENTRIES;
 /* Interpret */
 if (seen) {
  struct monster_blow *b = &l->blows[index];
  b->method = method;
  b->effect = effect;
  b->dice = dam;
  b->times_seen = seen;
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_lore_flags(struct parser *p) {
 struct monster_lore *l = parser_priv(p);
 char *flags;
 char *s;
 if (!l)
  return PARSE_ERROR_NONE;
 if (!parser_hasval(p, "flags"))
  return PARSE_ERROR_NONE;
 flags = string_make(parser_getstr(p, "flags"));
 s = strtok(flags, " |");
 while (s) {
  (void) grab_flag(l->flags, RF_SIZE, r_info_flags, s);
  s = strtok(NULL, " |");
 }
 mem_free(flags);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_lore_spells(struct parser *p) {
 struct monster_lore *l = parser_priv(p);
 char *flags;
 char *s;
 int ret = PARSE_ERROR_NONE;
 if (!l)
  return PARSE_ERROR_NONE;
 flags = string_make(parser_getstr(p, "spells"));
 s = strtok(flags, " |");
 while (s) {
  (void) grab_flag(l->spell_flags, RSF_SIZE, r_info_spell_flags, s);
  s = strtok(NULL, " |");
 }
 mem_free(flags);
 return ret;
}
static enum parser_error parse_lore_drop(struct parser *p) {
 struct monster_lore *l = parser_priv(p);
 struct monster_drop *d;
 struct object_kind *k;
 int tval, sval;
 if (!l)
  return PARSE_ERROR_NONE;
 tval = tval_find_idx(parser_getsym(p, "tval"));
 if (tval < 0)
  return PARSE_ERROR_UNRECOGNISED_TVAL;
 sval = lookup_sval(tval, parser_getsym(p, "sval"));
 if (sval < 0)
  return PARSE_ERROR_UNRECOGNISED_SVAL;
 k = lookup_kind(tval, sval);
 if (!k)
  return PARSE_ERROR_UNRECOGNISED_SVAL;
 d = mem_zalloc(sizeof *d);
 d->kind = k;
 d->percent_chance = parser_getuint(p, "chance");
 d->dice = parser_getrand(p, "dice");
 d->next = l->drops;
 l->drops = d;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_lore_drop_artifact(struct parser *p) {
 struct monster_lore *l = parser_priv(p);
 struct monster_drop *d;
 const char *name;
 if (!l)
  return PARSE_ERROR_NONE;
 name = parser_getstr(p, "name");
 d = mem_zalloc(sizeof *d);
 d->art = lookup_artifact_name(name);
 d->percent_chance = 100;
 d->next = l->drops;
 l->drops = d;
 return PARSE_ERROR_NONE;
}
static struct parser *init_parse_lore(void) {
 struct parser *p = parser_new();
 parser_setpriv(p, NULL);
 parser_reg(p, "name str name", parse_lore_name);
 parser_reg(p, "plural ?str plural", ignored);
 parser_reg(p, "base sym base", parse_lore_base);
 parser_reg(p, "depth int level", ignored);
 parser_reg(p, "rarity int rarity", ignored);
 parser_reg(p, "glyph char glyph", ignored);
 parser_reg(p, "color sym color", ignored);
 parser_reg(p, "speed int speed", ignored);
 parser_reg(p, "health rand dice", ignored);
 parser_reg(p, "light int light", ignored);
 parser_reg(p, "sleep int sleep", ignored);
 parser_reg(p, "percept int per", ignored);
 parser_reg(p, "stealth int stealth", ignored);
 parser_reg(p, "will int will", ignored);
 parser_reg(p, "song int song", ignored);
 parser_reg(p, "prot int evn ?rand dice", ignored);
 parser_reg(p, "counts int sights int deaths int kills int notice int ignore int ranged", parse_lore_counts);
 parser_reg(p, "blow sym method ?sym effect ?rand damage ?int seen ?int index", parse_lore_blow);
 parser_reg(p, "flags ?str flags", parse_lore_flags);
 parser_reg(p, "desc str desc", ignored);
 parser_reg(p, "ranged-freq int freq", ignored);
 parser_reg(p, "spell-power uint power", ignored);
 parser_reg(p, "spells str spells", parse_lore_spells);
 parser_reg(p, "message-vis sym spell ?str message", ignored);
 parser_reg(p, "message-invis sym spell ?str message", ignored);
 parser_reg(p, "drop sym tval sym sval uint chance rand dice", parse_lore_drop);
 parser_reg(p, "drop-artifact str name", parse_lore_drop_artifact);
 parser_reg(p, "color-cycle sym group sym cycle", ignored);
 return p;
}
static errr run_parse_lore(struct parser *p) {
 /* Failure is always an option */
 if (parse_file(p, "lore")) {
  event_signal_message(EVENT_INITSTATUS, 0, "No monster lore file found");
 }
 return PARSE_ERROR_NONE;
}
static errr finish_parse_lore(struct parser *p) {
 size_t i;
 /* Processing */
 for (i = 0; i < z_info->r_max; i++) {
  struct monster_lore *l = &l_list[i];
  struct monster_race *r = &r_info[i];
  int j;
  /* Base flag knowledge */
  if (r->base) {
   rf_union(l->flags, r->base->flags);
  }
  /* Remove blows data for non-blows */
  for (j = 0; j < z_info->mon_blows_max; j++) {
   if (!r->blow) break;
   if (!(r->blow[j].effect || r->blow[j].method))
    l->blows[j].times_seen = 0;
  }
  /* update any derived values */
  lore_update(r, l);
 }
 parser_destroy(p);
 return 0;
}
static void cleanup_lore(void)
{
 int ridx;
 for (ridx = 0; ridx < z_info->r_max; ridx++) {
  struct monster_lore *l = &l_list[ridx];
  struct monster_drop *d;
  d = l->drops;
  while (d) {
   struct monster_drop *dn = d->next;
   mem_free(d);
   d = dn;
  }
  mem_free(l->blows);
  mem_free(l->blow_known);
 }
 mem_free(l_list);
}
struct file_parser lore_parser = {
 "lore",
 init_parse_lore,
 run_parse_lore,
 finish_parse_lore,
 cleanup_lore
};
/**
 * \file mon-list.c
 * \brief Monster list UI.
 *
 * Copyright (c) 1997-2007 Ben Harrison, James E. Wilson, Robert A. Koeneke
 * Copyright (c) 2013 Ben Semmler
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Allocate a new monster list based on the size of the current cave's monster
 * array.
 */
monster_list_t *monster_list_new(void)
{
 monster_list_t *list = mem_zalloc(sizeof(monster_list_t));
 size_t size = cave_monster_max(cave);
 if (list == NULL)
  return NULL;
 list->entries = mem_zalloc(size * sizeof(monster_list_entry_t));
 if (list->entries == NULL) {
  mem_free(list);
  return NULL;
 }
 list->entries_size = size;
 return list;
}
/**
 * Free a monster list.
 */
void monster_list_free(monster_list_t *list)
{
 if (list == NULL)
  return;
 if (list->entries != NULL) {
  mem_free(list->entries);
  list->entries = NULL;
 }
 mem_free(list);
 list = NULL;
}
/**
 * Shared monster list instance.
 */
static monster_list_t *monster_list_subwindow = NULL;
/**
 * Initialize the monster list module.
 */
void monster_list_init(void)
{
 monster_list_subwindow = NULL;
}
/**
 * Tear down the monster list module.
 */
void monster_list_finalize(void)
{
 monster_list_free(monster_list_subwindow);
}
/**
 * Return a common monster list instance.
 */
monster_list_t *monster_list_shared_instance(void)
{
 if (monster_list_subwindow == NULL) {
  monster_list_subwindow = monster_list_new();
 }
 return monster_list_subwindow;
}
/**
 * Return true if there is nothing preventing the list from being updated. This
 * should be for structural sanity checks and not gameplay checks.
 */
static bool monster_list_can_update(const monster_list_t *list)
{
 if (list == NULL || list->entries == NULL)
  return false;
 return (int)list->entries_size >= cave_monster_max(cave);
}
/**
 * Zero out the contents of a monster list. If needed, this function will
 * reallocate the entry list if the number of monsters has changed.
 */
void monster_list_reset(monster_list_t *list)
{
 if (list == NULL || list->entries == NULL)
  return;
 if ((int)list->entries_size < cave_monster_max(cave)) {
  list->entries = mem_realloc(list->entries, sizeof(list->entries[0])
         * cave_monster_max(cave));
  list->entries_size = cave_monster_max(cave);
 }
 memset(list->entries, 0, list->entries_size * sizeof(monster_list_entry_t));
 memset(list->total_entries, 0, MONSTER_LIST_SECTION_MAX * sizeof(uint16_t));
 memset(list->total_monsters, 0, MONSTER_LIST_SECTION_MAX * sizeof(uint16_t));
 list->distinct_entries = 0;
 list->creation_turn = 0;
 list->sorted = false;
}
/**
 * Collect monster information from the current cave's monster list.
 */
void monster_list_collect(monster_list_t *list)
{
 int i;
 if (list == NULL || list->entries == NULL)
  return;
 if (!monster_list_can_update(list))
  return;
 /* Use cave_monster_max() here in case the monster list isn't compacted. */
 for (i = 1; i < cave_monster_max(cave); i++) {
  struct monster *mon = cave_monster(cave, i);
  monster_list_entry_t *entry = NULL;
  int j, field;
  bool los = false;
  /* Only consider visible, known monsters */
  if (!monster_is_visible(mon))
   continue;
  /* Find or add a list entry. */
  for (j = 0; j < (int)list->entries_size; j++) {
   if (list->entries[j].race == NULL) {
    /* We found an empty slot, so add this race here. */
    entry = &list->entries[j];
    memset(entry, 0, sizeof(monster_list_entry_t));
    entry->race = mon->race;
    break;
   }
   else if (list->entries[j].race == mon->race) {
    /* We found a matching race and we'll use that. */
    entry = &list->entries[j];
    break;
   }
  }
  if (entry == NULL)
   continue;
  /* Always collect the latest monster attribute so that flicker
		 * animation works. If this is 0, it needs to be replaced by 
		 * the standard glyph in the UI */
  entry->attr = mon->attr;
  /*
		 * Check for LOS
		 * Hack - we should use (mon->mflag & (MFLAG_VIEW)) here,
		 * but this does not catch monsters detected by ESP which are
		 * targetable, so we cheat and use projectable() instead
		 */
  los = projectable(cave, player->grid, mon->grid, PROJECT_NONE);
  field = (los) ? MONSTER_LIST_SECTION_LOS : MONSTER_LIST_SECTION_ESP;
  entry->count[field]++;
  if (mon->alertness >= ALERTNESS_ALERT)
   entry->alert[field]++;
  /* Store the location offset from the player; this is only used for
		 * monster counts of 1 */
  entry->dx[field] = mon->grid.x - player->grid.x;
  entry->dy[field] = mon->grid.y - player->grid.y;
 }
 /* Collect totals for easier calculations of the list. */
 for (i = 0; i < (int)list->entries_size; i++) {
  if (list->entries[i].race == NULL)
   continue;
  if (list->entries[i].count[MONSTER_LIST_SECTION_LOS] > 0)
   list->total_entries[MONSTER_LIST_SECTION_LOS]++;
  if (list->entries[i].count[MONSTER_LIST_SECTION_ESP] > 0)
   list->total_entries[MONSTER_LIST_SECTION_ESP]++;
  list->total_monsters[MONSTER_LIST_SECTION_LOS] +=
   list->entries[i].count[MONSTER_LIST_SECTION_LOS];
  list->total_monsters[MONSTER_LIST_SECTION_ESP] +=
   list->entries[i].count[MONSTER_LIST_SECTION_ESP];
  list->distinct_entries++;
 }
 list->creation_turn = turn;
 list->sorted = false;
}
/**
 * Standard comparison function for the monster list: sort by depth and then
 * power.
 */
int monster_list_standard_compare(const void *a, const void *b)
{
 const struct monster_race *ar = ((monster_list_entry_t *)a)->race;
 const struct monster_race *br = ((monster_list_entry_t *)b)->race;
 /* If this happens, something might be wrong in the collect function. */
 if (ar == NULL || br == NULL)
  return 1;
 /* Check depth first.*/
 if (ar->level > br->level)
  return -1;
 if (ar->level < br->level)
  return 1;
 return 0;
}
/**
 * Comparison function for the monster list: sort by level
 */
int monster_list_compare_exp(const void *a, const void *b)
{
 const struct monster_race *ar = ((monster_list_entry_t *)a)->race;
 const struct monster_race *br = ((monster_list_entry_t *)b)->race;
 long a_exp, b_exp;
 /* If this happens, something might be wrong in the collect function. */
 if (ar == NULL || br == NULL)
  return 1;
 /* Experience, integer part */
 a_exp = (long)ar->level;
 b_exp = (long)br->level;
 /* Evaluate exp gained when killing */
 if (a_exp > b_exp)
  return -1;
 if (a_exp < b_exp)
  return 1;
 return 0;
}
/**
 * Sort the monster list with the given sort function.
 */
void monster_list_sort(monster_list_t *list,
        int (*compare)(const void *, const void *))
{
 size_t elements;
 if (list == NULL || list->entries == NULL)
  return;
 if (list->sorted)
  return;
 elements = list->distinct_entries;
 if (elements <= 1)
  return;
 sort(list->entries, MIN(elements, list->entries_size), sizeof(list->entries[0]), compare);
 list->sorted = true;
}
/**
 * Return an color to display a particular list entry with.
 *
 * \param entry is the monster list entry to display.
 * \return a color for the monster entry.
 */
int monster_list_entry_line_color(const monster_list_entry_t *entry)
{
 /* Display uniques in a special colour */
 if (rf_has(entry->race->flags, RF_UNIQUE))
  return COLOUR_VIOLET;
 else if (entry->race->level > player->depth)
  return COLOUR_RED;
 else
  return COLOUR_WHITE;
}
/**
 * \file mon-lore.c
 * \brief Monster memory code.
 *
 * Copyright (c) 1997-2007 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Monster genders
 */
enum monster_sex {
 MON_SEX_NEUTER = 0,
 MON_SEX_MALE,
 MON_SEX_FEMALE,
 MON_SEX_MAX,
};
typedef enum monster_sex monster_sex_t;
void lore_learn_flag_if_visible(struct monster_lore *lore, const struct monster *mon, int flag)
{
 if (monster_is_visible(mon)) {
  rf_on(lore->flags, flag);
 }
}
/**
 * Update which bits of lore are known
 */
void lore_update(const struct monster_race *race, struct monster_lore *lore)
{
 int i;
 bitflag mask[RF_SIZE];
 if (!race || !lore) return;
 /* Assume some "obvious" flags */
 create_mon_flag_mask(mask, RFT_OBV, RFT_ABIL_OBV, RFT_MAX);
 rf_union(lore->flags, mask);
 /* Blows */
 for (i = 0; i < z_info->mon_blows_max; i++) {
  if (!race->blow) break;
  if (lore->blow_known[i] || (lore->blows[i].times_seen) ||
   lore->all_known) {
   lore->blow_known[i] = true;
   lore->blows[i].method = race->blow[i].method;
   lore->blows[i].effect = race->blow[i].effect;
   lore->blows[i].dice = race->blow[i].dice;
  }
 }
 /* Killing a monster reveals some properties */
 if ((lore->tkills > 0) || lore->all_known) {
  lore->armour_known = true;
  lore->drop_known = true;
  create_mon_flag_mask(mask, RFT_RACE_A, RFT_RACE_N, RFT_DROP, RFT_MAX);
  rf_union(lore->flags, mask);
  rf_on(lore->flags, RF_FORCE_DEPTH);
 }
 /* Awareness */
 if ((lore->ranged == UCHAR_MAX) || lore->all_known ||
     ((player && lore->tsights > 1) &&
   (10 - lore->tsights < player->state.skill_use[SKILL_PERCEPTION])))
  lore->sleep_known = true;
 /* Spellcasting frequency */
 if (lore->ranged == UCHAR_MAX || lore->all_known) {
  lore->ranged_freq_known = true;
 }
 /* Flags for probing and cheating */
 if (lore->all_known) {
  rf_setall(lore->flags);
  rsf_copy(lore->spell_flags, race->spell_flags);
 }
}
/**
 * Learn everything about a monster.
 *
 * Sets the all_known variable, all flags and all relevant spell flags.
 */
void cheat_monster_lore(const struct monster_race *race, struct monster_lore *lore)
{
 assert(race);
 assert(lore);
 /* Full knowledge */
 lore->all_known = true;
 lore_update(race, lore);
}
/**
 * Forget everything about a monster.
 */
void wipe_monster_lore(const struct monster_race *race, struct monster_lore *lore)
{
 struct monster_blow *blows;
 bool *blow_known;
 struct monster_drop *d;
 assert(race);
 assert(lore);
 d = lore->drops;
 while (d) {
  struct monster_drop *dn = d->next;
  mem_free(d);
  d = dn;
 }
 /*
	 * Keep the blows and blow_known pointers - other code assumes they
	 * are not NULL.  Wipe the pointed to memory.
	 */
 blows = lore->blows;
 memset(blows, 0, z_info->mon_blows_max * sizeof(*blows));
 blow_known = lore->blow_known;
 memset(blow_known, 0, z_info->mon_blows_max * sizeof(*blow_known));
 memset(lore, 0, sizeof(*lore));
 lore->blows = blows;
 lore->blow_known = blow_known;
}
/**
 * Learn about a monster (by "probing" it)
 */
void lore_do_probe(struct monster *mon)
{
 struct monster_lore *lore = get_lore(mon->race);
 lore->all_known = true;
 lore_update(mon->race, lore);
 /* Update monster recall window */
 if (player->upkeep->monster_race == mon->race)
  player->upkeep->redraw |= (PR_MONSTER);
}
/**
 * Determine whether the monster is fully known
 */
bool lore_is_fully_known(const struct monster_race *race)
{
 unsigned i;
 struct monster_lore *lore = get_lore(race);
 /* Check if already known */
 if (lore->all_known)
  return true;
 if (!lore->armour_known)
  return false;
 /* Only check spells if the monster can cast them */
 if (!lore->ranged_freq_known && race->freq_ranged)
  return false;
 if (!lore->drop_known)
  return false;
 if (!lore->sleep_known)
  return false;
 /* Check if blows are known */
 for (i = 0; i < z_info->mon_blows_max; i++){
  /* Only check if the blow exists */
  if (!race->blow[i].method)
   break;
  if (!lore->blow_known[i])
   return false;
 }
 /* Check all the flags */
 for (i = 0; i < RF_SIZE; i++)
  if (!lore->flags[i])
   return false;
 /* Check spell flags */
 for (i = 0; i < RSF_SIZE; i++)
  if (lore->spell_flags[i] != race->spell_flags[i])
   return false;
 /* The player knows everything */
 lore->all_known = true;
 lore_update(race, lore);
 return true;
}
/**
 * Take note that the given monster just dropped some treasure
 *
 * Note that learning the "GOOD"/"GREAT" flags gives information
 * about the treasure (even when the monster is killed for the first
 * time, such as uniques, and the treasure has not been examined yet).
 *
 * This "indirect" method was used to prevent the player from learning
 * exactly how much treasure a monster can drop from observing only
 * a single example of a drop.  This method actually observes how many
 * items are dropped, and remembers that information to be described later
 * by the monster recall code.
 */
void lore_treasure(struct monster *mon, int num_item)
{
 struct monster_lore *lore = get_lore(mon->race);
 assert(num_item >= 0);
 /* Note the number of things dropped */
 if (num_item > lore->drop_item) {
  lore->drop_item = num_item;
 }
 /* Learn about drop quality */
 rf_on(lore->flags, RF_DROP_GOOD);
 rf_on(lore->flags, RF_DROP_GREAT);
 /* Update monster recall window */
 if (player->upkeep->monster_race == mon->race) {
  player->upkeep->redraw |= (PR_MONSTER);
 }
}
/**
 * Copies into `flags` the flags of the given monster race that are known
 * to the given lore structure (usually the player's knowledge).
 *
 * Known flags will be 1 for present, or 0 for not present. Unknown flags
 * will always be 0.
 */
void monster_flags_known(const struct monster_race *race,
       const struct monster_lore *lore,
       bitflag flags[RF_SIZE])
{
 rf_copy(flags, race->flags);
 rf_inter(flags, lore->flags);
}
/**
 * Return a description for the given monster race awareness value.
 *
 * Descriptions are in a table within the function. Returns a sensible string
 * for values not in the table.
 *
 * \param awareness is the inactivity counter of the race (monster_race.sleep).
 */
static const char *lore_describe_awareness(int16_t awareness)
{
 /* Value table ordered descending, for priority. Terminator is
	 * {SHRT_MAX, NULL}. */
 static const struct lore_awareness {
  int16_t threshold;
  const char *description;
 } lore_awareness_description[] = {
  {20, "is usually found asleep"},
  {15, "is often found asleep"},
  {10, "is sometimes found asleep"},
  {5, "is never found asleep"},
  {1, "is quick to notice intruders"},
  {0, "is very quick to notice intruders"},
  {SHRT_MAX, NULL},
 };
 const struct lore_awareness *current = lore_awareness_description;
 while (current->threshold != SHRT_MAX && current->description != NULL) {
  if (awareness > current->threshold)
   return current->description;
  current++;
 }
 /* Values zero and less are the most vigilant */
 return "is ever vigilant";
}
/**
 * Return a description for the given monster race speed value.
 *
 * Descriptions are in a table within the function. Returns a sensible string
 * for values not in the table.
 *
 * \param speed is the speed rating of the race (monster_race.speed).
 */
static const char *lore_describe_speed(uint8_t speed)
{
 /* Value table ordered descending, for priority. Terminator is
	 * {UCHAR_MAX, NULL}. */
 static const struct lore_speed {
  uint8_t threshold;
  const char *description;
 } lore_speed_description[] = {
  {5, "incredibly quickly"},
  {4, "extremely quickly"},
  {3, "very quickly"},
  {2, "quickly"},
  {1, "normal speed"}, /* 1 is normal speed */
  {0, "slowly"},
  {UCHAR_MAX, NULL},
 };
 const struct lore_speed *current = lore_speed_description;
 while (current->threshold != UCHAR_MAX && current->description != NULL) {
  if (speed > current->threshold)
   return current->description;
  current++;
 }
 /* Return a weird description, since the value wasn't found in the table */
 return "erroneously";
}
/**
 * Append the monster speed, in words, to a textblock.
 *
 * \param tb is the textblock we are adding to.
 * \param race is the monster race we are describing.
 */
static void lore_adjective_speed(textblock *tb, const struct monster_race *race)
{
 /* "at" is separate from the normal speed description in order to use the
	 * normal text colour */
 if (race->speed == 2)
  textblock_append(tb, "at ");
 textblock_append_c(tb, COLOUR_GREEN, "%s", lore_describe_speed(race->speed));
}
/**
 * Return a value describing the sex of the provided monster race.
 */
static monster_sex_t lore_monster_sex(const struct monster_race *race)
{
 if (rf_has(race->flags, RF_FEMALE))
  return MON_SEX_FEMALE;
 else if (rf_has(race->flags, RF_MALE))
  return MON_SEX_MALE;
 return MON_SEX_NEUTER;
}
/**
 * Return a pronoun for a monster; used as the subject of a sentence.
 *
 * Descriptions are in a table within the function. Table must match
 * monster_sex_t values.
 *
 * \param sex is the gender value (as provided by `lore_monster_sex()`.
 * \param title_case indicates whether the initial letter should be
 * capitalized; `true` is capitalized, `false` is not.
 */
static const char *lore_pronoun_nominative(monster_sex_t sex, bool title_case)
{
 static const char *lore_pronouns[MON_SEX_MAX][2] = {
  {"it", "It"},
  {"he", "He"},
  {"she", "She"},
 };
 int pronoun_index = MON_SEX_NEUTER, case_index = 0;
 if (sex < MON_SEX_MAX)
  pronoun_index = sex;
 if (title_case)
  case_index = 1;
 return lore_pronouns[pronoun_index][case_index];
}
/**
 * Return a pronoun for a monster; used as the object of a sentence.
 *
 * Descriptions are in a table within the function. Table must match
 * monster_sex_t values.
 *
 * \param sex is the gender value (as provided by `lore_monster_sex()`.
 * \param title_case indicates whether the initial letter should be
 * capitalized; `true` is capitalized, `false` is not.
 */
static const char *lore_pronoun_accusative(monster_sex_t sex, bool title_case)
{
 static const char *lore_pronouns[MON_SEX_MAX][2] = {
  {"it", "It"},
  {"him", "Him"},
  {"her", "Her"},
 };
 int pronoun_index = MON_SEX_NEUTER, case_index = 0;
 if (sex < MON_SEX_MAX)
  pronoun_index = sex;
 if (title_case)
  case_index = 1;
 return lore_pronouns[pronoun_index][case_index];
}
/**
 * Return a possessive pronoun for a monster.
 *
 * Descriptions are in a table within the function. Table must match
 * monster_sex_t values.
 *
 * \param sex is the gender value (as provided by `lore_monster_sex()`.
 * \param title_case indicates whether the initial letter should be
 * capitalized; `true` is capitalized, `false` is not.
 */
static const char *lore_pronoun_possessive(monster_sex_t sex, bool title_case)
{
 static const char *lore_pronouns[MON_SEX_MAX][2] = {
  {"its", "Its"},
  {"his", "His"},
  {"her", "Her"},
 };
 int pronoun_index = MON_SEX_NEUTER, case_index = 0;
 if (sex < MON_SEX_MAX)
  pronoun_index = sex;
 if (title_case)
  case_index = 1;
 return lore_pronouns[pronoun_index][case_index];
}
/**
 * Append a clause containing a list of descriptions of monster flags from
 * list-mon-race-flags.h to a textblock.
 *
 * The text that joins the list is drawn using the default attributes. The list
 * uses a serial comma ("a, b, c, and d").
 *
 * \param tb is the textblock we are adding to.
 * \param f is the set of flags to be described.
 * \param attr is the attribute each list item will be drawn with.
 * \param start is a string to start the clause.
 * \param conjunction is a string that is added before the last item.
 * \param end is a string that is added after the last item.
 */
static void lore_append_clause(textblock *tb, bitflag *f, int attr,
          const char *start, const char *conjunction,
          const char *end)
{
 int count = rf_count(f);
 bool comma = count > 2;
 if (count) {
  int flag;
  textblock_append(tb, "%s", start);
  for (flag = rf_next(f, FLAG_START); flag; flag = rf_next(f, flag + 1)) {
   /* First entry starts immediately */
   if (flag != rf_next(f, FLAG_START)) {
    if (comma) {
     textblock_append(tb, ",");
    }
    /* Last entry */
    if (rf_next(f, flag + 1) == FLAG_END) {
     textblock_append(tb, " ");
     textblock_append(tb, "%s", conjunction);
    }
    textblock_append(tb, " ");
   }
   textblock_append_c(tb, attr, "%s", describe_race_flag(flag));
  }
  textblock_append(tb, "%s", end);
 }
}
/**
 * Append a list of spell descriptions.
 *
 * This is a modified version of `lore_append_clause()` to format spells.
 *
 * \param tb is the textblock we are adding to.
 * \param f is the set of flags to be described.
 * \param know_hp is whether the player knows the monster's AC.
 * \param race is the monster race.
 * \param conjunction is a string that is added before the last item.
 * \param end is a string that is added after the last item.
 */
static void lore_append_spell_clause(textblock *tb, bitflag *f,
          const struct monster_race *race,
          int attr, int dam_attr)
{
 int count = rsf_count(f);
 bool comma = count > 2;
 if (count) {
  int spell;
  for (spell = rsf_next(f, FLAG_START); spell;
    spell = rsf_next(f, spell + 1)) {
   random_value damage = mon_spell_lore_damage(spell);
            int archery_bonus = 0;
            archery_bonus = mon_spell_lore_archery_bonus(spell, race);
   /* First entry starts immediately */
   if (spell != rsf_next(f, FLAG_START)) {
    if (comma) {
     textblock_append(tb, ",");
    }
    /* Last entry */
    if (rsf_next(f, spell + 1) == FLAG_END) {
     textblock_append(tb, " or");
    }
    textblock_append(tb, " ");
   }
   textblock_append_c(tb, attr, "%s",
          mon_spell_lore_description(spell, race));
            /* If it's not an archery spell, archery_bonus is 0 */
            if (damage.dice && damage.sides && archery_bonus) {
                textblock_append_c(tb, dam_attr, " (+%d, %dd%d)",
           archery_bonus, damage.dice, damage.sides);
            } else if (damage.dice && damage.sides) {
    textblock_append_c(tb, dam_attr, " (%dd%d)", damage.dice,
           damage.sides);
   }
  }
  textblock_append(tb, ".  ");
 }
}
/**
 * Append the kill history to a texblock for a given monster race.
 *
 * Known race flags are passed in for simplicity/efficiency.
 *
 * \param tb is the textblock we are adding to.
 * \param race is the monster race we are describing.
 * \param lore is the known information about the monster race.
 * \param known_flags is the preprocessed bitfield of race flags known to the
 *        player.
 */
void lore_append_kills(textblock *tb, const struct monster_race *race,
        const struct monster_lore *lore,
        const bitflag known_flags[RF_SIZE])
{
 monster_sex_t msex = MON_SEX_NEUTER;
 bool out = true;
 assert(tb && race && lore);
 /* Extract a gender (if applicable) */
 msex = lore_monster_sex(race);
 /* Treat by whether unique, then by whether they have any player kills */
 if (rf_has(known_flags, RF_UNIQUE)) {
  /* Hack -- Determine if the unique is "dead" */
  bool dead = (race->max_num == 0) ? true : false;
  /* We've been killed... */
  if (lore->deaths) {
   /* Killed ancestors */
   textblock_append(tb, "%s has slain %d of your ancestors",
        lore_pronoun_nominative(msex, true), lore->deaths);
   /* But we've also killed it */
   if (dead)
    textblock_append(tb, ", but you have taken revenge!  ");
   /* Unavenged (ever) */
   else
    textblock_append(tb, ", who %s unavenged.  ",
         VERB_AGREEMENT(lore->deaths, "remains",
            "remain"));
  } else if (dead) { /* Dead unique who never hurt us */
   textblock_append(tb, "You have slain this foe.  ");
  } else {
   /* Alive and never killed us */
   out = false;
  }
  if (!dead) {
   if (lore->psights) {
    textblock_append(tb, "You have encountered this foe.  ");
   } else {
    textblock_append(tb, "You are yet to encounter this foe.  ");
   }
  }
 } else if (lore->deaths) {
  /* Dead ancestors */
  textblock_append(tb, "%d of your predecessors %s been killed by this creature, ", lore->deaths, VERB_AGREEMENT(lore->deaths, "has", "have"));
  if (lore->pkills) {
   /* Some kills this life */
   textblock_append(tb, "and you have slain %d of the %d you have encountered.  ", lore->pkills, lore->psights);
  } else if (lore->tkills) {
   /* Some kills past lives */
   textblock_append(tb, "and your predecessors have slain %d in return.  ", lore->tkills);
  } else {
   /* No kills */
   textblock_append_c(tb, COLOUR_RED, "and %s is not ever known to have been defeated.  ", lore_pronoun_nominative(msex, false));
   if (lore->psights) {
    textblock_append(tb, "You have encountered %d.  ",
         lore->psights);
   } else {
    textblock_append(tb, "You are yet to encounter one.  ");
   }
  }
 } else {
  /* Encountered some this life */
  if (lore->psights && !lore->pkills) {
   textblock_append(tb, "You have encountered %d of these creatures, ",
        lore->psights);
   /* Killed some la.  st life */
   if (lore->tkills) {
    textblock_append(tb, "and your predecessors have slain %d.  ",
         lore->tkills);
   } else {
    /* Killed none */
    textblock_append(tb,
         "but no battles to the death are recalled.  ");
   }
  } else if (lore->pkills) {
   /* Killed some this life */
   textblock_append(tb, "You have slain %d of the %d you have encountered.  ", lore->pkills, lore->psights);
  } else {
   textblock_append(tb,
        "You have encountered none of these creatures, ");
   if (lore->tkills) {
    /* Killed some last life */
    textblock_append(tb, "but your predecessors have slain %d.  ",
         lore->tkills);
   } else {
    /* Killed none */
    textblock_append(tb,
         "and no battles to the death are recalled.  ");
   }
  }
 }
 /* Separate */
 if (out)
  textblock_append(tb, "\n");
}
/**
 * Append the monster race description to a textblock.
 *
 * \param tb is the textblock we are adding to.
 * \param race is the monster race we are describing.
 */
void lore_append_flavor(textblock *tb, const struct monster_race *race)
{
 assert(tb && race);
 textblock_append(tb, "%s\n", race->text);
}
/**
 * Append the monster type, location, and movement patterns to a textblock.
 *
 * Known race flags are passed in for simplicity/efficiency.
 *
 * \param tb is the textblock we are adding to.
 * \param race is the monster race we are describing.
 * \param lore is the known information about the monster race.
 * \param known_flags is the preprocessed bitfield of race flags known to the
 *        player.
 */
void lore_append_movement(textblock *tb, const struct monster_race *race,
        const struct monster_lore *lore,
        bitflag known_flags[RF_SIZE])
{
 int f;
 bitflag flags[RF_SIZE];
 assert(tb && race && lore);
 textblock_append(tb, "This");
 /* Get adjectives */
 create_mon_flag_mask(flags, RFT_RACE_A, RFT_MAX);
 rf_inter(flags, race->flags);
 for (f = rf_next(flags, FLAG_START); f; f = rf_next(flags, f + 1)) {
  textblock_append_c(tb, COLOUR_L_BLUE, " %s", describe_race_flag(f));
 }
 /* Get noun */
 create_mon_flag_mask(flags, RFT_RACE_N, RFT_MAX);
 rf_inter(flags, race->flags);
 f = rf_next(flags, FLAG_START);
 if (f) {
  textblock_append_c(tb, COLOUR_L_BLUE, " %s", describe_race_flag(f));
 } else {
  textblock_append_c(tb, COLOUR_L_BLUE, " creature");
 }
 /* Describe location */
 if (race->level == 0) {
  textblock_append_c(tb, COLOUR_YELLOW,
         " dwells at the gates of Angband");
 } else {
  if (rf_has(known_flags, RF_FORCE_DEPTH))
   textblock_append(tb, " is found ");
  else
   textblock_append(tb, " is normally found ");
  if (race == lookup_monster("Carcharoth")) {
   textblock_append_c(tb, COLOUR_YELLOW,
          "guarding the gates of Angband");
  } else if (race->level < z_info->dun_depth) {
   textblock_append(tb, "at depths of ");
   textblock_append_c(tb, COLOUR_YELLOW, "%d", race->level * 50);
   textblock_append(tb, " feet");
  } else {
   textblock_append(tb, "at depths of ");
   textblock_append_c(tb, COLOUR_YELLOW, "%d", z_info->dun_depth * 50);
   textblock_append(tb, " feet");
  }
 }
 textblock_append(tb, ", and");
 if (rf_has(known_flags, RF_NEVER_MOVE)) {
  textblock_append(tb, " cannot move");
 } else if (rf_has(known_flags, RF_HIDDEN_MOVE)) {
  textblock_append(tb, " never moves when you are looking");
  //} else if ((race->speed != 2) || rf_has(known_flags, RF_RAND_25) ||
  //	   rf_has(known_flags, RF_RAND_50)) {
 } else {
  textblock_append(tb, " moves");
 }
 /* Random-ness */
 if (flags_test(known_flags, RF_SIZE, RF_RAND_50, RF_RAND_25, FLAG_END)){
  /* Adverb */
  if (rf_has(known_flags, RF_RAND_50) &&
   rf_has(known_flags, RF_RAND_25))
   textblock_append(tb, " extremely");
  else if (rf_has(known_flags, RF_RAND_50))
   textblock_append(tb, " somewhat");
  else if (rf_has(known_flags, RF_RAND_25))
   textblock_append(tb, " a bit");
  /* Adjective */
  textblock_append(tb, " erratically");
  /* Hack -- Occasional conjunction */
  if (race->speed != 2) textblock_append(tb, ", and");
 }
 /* Speed */
 textblock_append(tb, " ");
 lore_adjective_speed(tb, race);
 /* End this sentence */
 textblock_append(tb, ".  ");
 /* Note if this monster does not pursue you */
 if (rf_has(known_flags, RF_TERRITORIAL)) {
  monster_sex_t msex = lore_monster_sex(race);
  const char *initial_pronoun = lore_pronoun_nominative(msex, true);
  textblock_append(tb, "%s does not deign to pursue you.  ",
       initial_pronoun);
 }
}
/**
 * Append the monster AC, HP, and hit chance to a textblock.
 *
 * Known race flags are passed in for simplicity/efficiency.
 *
 * \param tb is the textblock we are adding to.
 * \param race is the monster race we are describing.
 * \param lore is the known information about the monster race.
 * \param known_flags is the preprocessed bitfield of race flags known to the
 *        player.
 */
void lore_append_toughness(textblock *tb, const struct monster_race *race,
         const struct monster_lore *lore,
         bitflag known_flags[RF_SIZE])
{
 monster_sex_t msex = MON_SEX_NEUTER;
 assert(tb && race && lore);
 /* Extract a gender (if applicable) */
 msex = lore_monster_sex(race);
 /* Describe monster "toughness" */
 if (lore->armour_known) {
  /* Hitpoints */
  textblock_append(tb, "%s has ", lore_pronoun_nominative(msex, true));
  if (rf_has(known_flags, RF_UNIQUE)) {
   textblock_append_c(tb, COLOUR_GREEN, "%d ",
          race->hdice * (1 + race->hside) / 2);
  } else {
   textblock_append_c(tb, COLOUR_GREEN, "%dd%d ", race->hdice,
          race->hside);
  }
  textblock_append(tb, "health");
  /* Armor */
  textblock_append(tb, ", and a defence of ");
  if ((race->pd > 0) && (race->ps > 0)) {
   textblock_append_c(tb, COLOUR_SLATE, "[%+d, %dd%d]", race->evn,
          race->pd, race->ps);
  } else {
   textblock_append_c(tb, COLOUR_SLATE, "[%+d]", race->evn);
  }
  textblock_append(tb, ".  ");
 }
}
/**
 * Append the experience value description to a textblock.
 *
 * Known race flags are passed in for simplicity/efficiency.
 *
 * \param tb is the textblock we are adding to.
 * \param race is the monster race we are describing.
 * \param lore is the known information about the monster race.
 * \param known_flags is the preprocessed bitfield of race flags known to the
 *        player.
 */
void lore_append_exp(textblock *tb, const struct monster_race *race,
      const struct monster_lore *lore,
      bitflag known_flags[RF_SIZE])
{
 long exp;
 monster_sex_t msex = MON_SEX_NEUTER;
 /* Check legality and that this is a placeable monster */
 assert(tb && race && lore);
 if (!race->rarity) return;
 /* Must have a kill or sighting */
 if (!lore->tkills && !lore->tsights) return;
 /* Extract a gender (if applicable) */
 msex = lore_monster_sex(race);
 /* Introduction for Encounters */
 if (lore->psights) {
  if (rf_has(known_flags, RF_UNIQUE)) {
   textblock_append(tb, "Encountering %s was worth",
        lore_pronoun_accusative(msex, false));
  } else {
   textblock_append(tb, "Encountering another would be worth");
  }
 } else {
  if (rf_has(known_flags, RF_UNIQUE)) {
   textblock_append(tb, "Encountering %s would be worth",
        lore_pronoun_accusative(msex, false));
  } else {
   textblock_append(tb, "Encountering one would be worth");
  }
 }
 /* Calculate the integer exp part */
 exp = adjusted_mon_exp(race, false);
 /* Mention the experience */
 textblock_append(tb, " %ld experience.  ", (long) exp);
 /* Introduction for Kills */
 if (lore->pkills) {
  if (rf_has(known_flags, RF_UNIQUE)) {
   textblock_append(tb, "Killing %s was worth",
        lore_pronoun_accusative(msex, false));
  } else {
   textblock_append(tb, "Killing another would be worth");
  }
 } else {
  if (rf_has(known_flags, RF_UNIQUE)) {
   textblock_append(tb, "Killing %s would be worth",
        lore_pronoun_accusative(msex, false));
  } else {
   textblock_append(tb, "Killing one would be worth");
  }
 }
 /* Calculate the integer exp part */
 exp = adjusted_mon_exp(race, true);
 /* Mention the experience */
 textblock_append(tb, " %ld.  ", (long) exp);
}
/**
 * Append the monster drop description to a textblock.
 *
 * Known race flags are passed in for simplicity/efficiency.
 *
 * \param tb is the textblock we are adding to.
 * \param race is the monster race we are describing.
 * \param lore is the known information about the monster race.
 * \param known_flags is the preprocessed bitfield of race flags known to the
 *        player.
 */
void lore_append_drop(textblock *tb, const struct monster_race *race,
       const struct monster_lore *lore,
       bitflag known_flags[RF_SIZE])
{
 int n = 0;
 monster_sex_t msex = MON_SEX_NEUTER;
 assert(tb && race && lore);
 if (!lore->drop_known) return;
 /* Extract a gender (if applicable) */
 msex = lore_monster_sex(race);
 /* Count maximum drop */
 n = mon_create_drop_count(race, true);
 /* Drops gold and/or items */
 if (n > 0) {
  if (rf_has(race->flags, RF_TERRITORIAL)) {
   textblock_append(tb, "%s may be found with",
        lore_pronoun_nominative(msex, true));
  } else {
   textblock_append(tb, "%s may carry",
        lore_pronoun_nominative(msex, true));
  }
  /* Report general drops */
  if (n == 1) {
   if (rf_has(known_flags, RF_DROP_GOOD) &&
    !rf_has(known_flags, RF_DROP_GREAT)) {
    textblock_append(tb, " a ");
   } else {
    textblock_append(tb, " an ");
   }
  } else if (n == 2) {
   textblock_append(tb, " one or two ");
  } else {
   textblock_append(tb, " up to %d ", n);
  }
  /* Quality */
  if (rf_has(known_flags, RF_DROP_GREAT)) {
   textblock_append_c(tb, COLOUR_BLUE,
          "exceptional ");
  } else if (rf_has(known_flags, RF_DROP_GOOD)) {
   textblock_append_c(tb, COLOUR_BLUE, "good ");
  }
  /* Objects */
  textblock_append(tb, "object%s.  ", PLURAL(n));
 }
}
/**
 * Append the monster abilities (resists, weaknesses, other traits) to a
 * textblock.
 *
 * Known race flags are passed in for simplicity/efficiency. Note the macros
 * that are used to simplify the code.
 *
 * \param tb is the textblock we are adding to.
 * \param race is the monster race we are describing.
 * \param lore is the known information about the monster race.
 * \param known_flags is the preprocessed bitfield of race flags known to the
 *        player.
 */
void lore_append_abilities(textblock *tb, const struct monster_race *race,
         const struct monster_lore *lore,
         bitflag known_flags[RF_SIZE])
{
 int flag;
 char start[40];
 const char *initial_pronoun;
 bitflag current_flags[RF_SIZE];
 monster_sex_t msex = MON_SEX_NEUTER;
 assert(tb && race && lore);
 /* Extract a gender (if applicable) and get a pronoun for the start of
	 * sentences */
 msex = lore_monster_sex(race);
 initial_pronoun = lore_pronoun_nominative(msex, true);
 /* Describe abilities. */
 create_mon_flag_mask(current_flags, RFT_ABIL, RFT_ABIL_OBV, RFT_MAX);
 rf_inter(current_flags, known_flags);
 strnfmt(start, sizeof(start), "%s has the abilities: ",
  initial_pronoun);
 lore_append_clause(tb, current_flags, COLOUR_RED, start, "and", ".  ");
 /* Describe light */
 if (race->light > 0) {
  /* Humanoids carry torches, others glow */
  if (streq(race->base->name, "person") ||
   streq(race->base->name, "giant")) {
   textblock_append(tb, "%s can use a light source.  ",
        initial_pronoun);
  } else {
   textblock_append(tb, "%s radiate light.  ", initial_pronoun);
  }
 } else if (race->light < 0) {
  textblock_append(tb, "%s can produce an unnatural darkness.  ",
       initial_pronoun);
 }
 /* Describe movement abilities. */
 create_mon_flag_mask(current_flags, RFT_MOVE, RFT_MAX);
 rf_inter(current_flags, known_flags);
 strnfmt(start, sizeof(start), "%s can ", initial_pronoun);
 lore_append_clause(tb, current_flags, COLOUR_WHITE, start, "and", ".  ");
 /* Describe special things */
 create_mon_flag_mask(current_flags, RFT_NOTE, RFT_MAX);
 rf_inter(current_flags, known_flags);
 //strnfmt(start, sizeof(start), "%s ", initial_pronoun);
 //lore_append_clause(tb, current_flags, COLOUR_WHITE, start, "and", ".  ");
 for (flag = rf_next(current_flags, FLAG_START); flag;
   flag = rf_next(current_flags, flag + 1)) {
  textblock_append(tb, "%s %s.  ", initial_pronoun,
       describe_race_flag(flag));
 }
 /* Describe detection traits */
 create_mon_flag_mask(current_flags, RFT_MIND, RFT_MAX);
 rf_inter(current_flags, known_flags);
 strnfmt(start, sizeof(start), "%s is ", initial_pronoun);
 lore_append_clause(tb, current_flags, COLOUR_WHITE, start, "and", ".  ");
 /* Describe susceptibilities */
 create_mon_flag_mask(current_flags, RFT_VULN, RFT_VULN_I, RFT_MAX);
 rf_inter(current_flags, known_flags);
 strnfmt(start, sizeof(start), "%s is vulnerable to ", initial_pronoun);
 lore_append_clause(tb, current_flags, COLOUR_L_BLUE, start, "and", ".  ");
 /* Describe resistances */
 create_mon_flag_mask(current_flags, RFT_RES, RFT_MAX);
 rf_inter(current_flags, known_flags);
 strnfmt(start, sizeof(start), "%s resists ", initial_pronoun);
 lore_append_clause(tb, current_flags, COLOUR_WHITE, start, "and", ".  ");
 /* Describe non-effects */
 create_mon_flag_mask(current_flags, RFT_PROT, RFT_MAX);
 rf_inter(current_flags, known_flags);
 strnfmt(start, sizeof(start), "%s cannot be ", initial_pronoun);
 lore_append_clause(tb, current_flags, COLOUR_YELLOW, start, "or", ".  ");
 /* Describe groups */
 create_mon_flag_mask(current_flags, RFT_GROUP, RFT_MAX);
 rf_inter(current_flags, known_flags);
 for (flag = rf_next(current_flags, FLAG_START); flag;
   flag = rf_next(current_flags, flag + 1)) {
  textblock_append(tb, "%s %s.  ", initial_pronoun,
       describe_race_flag(flag));
 }
}
/**
 * Append how the monster reacts to intruders and at what distance it does so.
 *
 * \param tb is the textblock we are adding to.
 * \param race is the monster race we are describing.
 * \param lore is the known information about the monster race.
 * \param known_flags is the preprocessed bitfield of race flags known to the
 *        player.
 */
void lore_append_skills(textblock *tb, const struct monster_race *race,
         const struct monster_lore *lore,
         bitflag known_flags[RF_SIZE])
{
 monster_sex_t msex = MON_SEX_NEUTER;
 assert(tb && race && lore);
 /* Extract a gender (if applicable) */
 msex = lore_monster_sex(race);
 /* Do we know how aware it is? */
 if (lore->sleep_known) {
  const char *aware = lore_describe_awareness(race->sleep);
  textblock_append(tb, "%s has %d Will,",
       lore_pronoun_nominative(msex, true), race->wil);
  if (player_active_ability(player, "Listen")) {
   textblock_append(tb, " %d Stealth,", race->stl);
  }
  textblock_append(tb, " %d Perception", race->per);
  if (rf_has(race->flags, RF_MINDLESS)) {
   textblock_append(tb, ".  ");
  } else {
   textblock_append(tb, ", and %s.  ", aware);
  }
 }
}
/**
 * Append the monster's attack spells to a textblock.
 *
 * Known race flags are passed in for simplicity/efficiency. Note the macros
 * that are used to simplify the code.
 *
 * \param tb is the textblock we are adding to.
 * \param race is the monster race we are describing.
 * \param lore is the known information about the monster race.
 * \param known_flags is the preprocessed bitfield of race flags known to the
 *        player.
 */
void lore_append_spells(textblock *tb, const struct monster_race *race,
      const struct monster_lore *lore,
      bitflag known_flags[RF_SIZE])
{
 monster_sex_t msex = MON_SEX_NEUTER;
 const char *initial_pronoun;
 bitflag current_flags[RSF_SIZE];
 const struct monster_race *old_ref;
 assert(tb && race && lore);
 /* Set the race for expressions in the spells. */
 old_ref = ref_race;
 ref_race = race;
 /* Extract a gender (if applicable) and get a pronoun for the start of
	 * sentences */
 msex = lore_monster_sex(race);
 initial_pronoun = lore_pronoun_nominative(msex, true);
 /* Collect innate attacks */
 create_mon_spell_mask(current_flags, RST_INNATE, RST_NONE);
 rsf_inter(current_flags, lore->spell_flags);
 if (!rsf_is_empty(current_flags)) {
  textblock_append(tb, "%s may ", initial_pronoun);
  lore_append_spell_clause(tb, current_flags, race, COLOUR_L_RED,
         COLOUR_UMBER);
 }
 /* Collect breaths */
 create_mon_spell_mask(current_flags, RST_BREATH, RST_NONE);
 rsf_inter(current_flags, lore->spell_flags);
 if (!rsf_is_empty(current_flags)) {
  textblock_append(tb, "%s may breathe ", initial_pronoun);
  lore_append_spell_clause(tb, current_flags, race, COLOUR_L_RED,
         COLOUR_WHITE);
 }
 /* Collect spell information */
 create_mon_spell_mask(current_flags, RST_SPELL, RST_NONE);
 rsf_inter(current_flags, lore->spell_flags);
 if (!rsf_is_empty(current_flags)) {
  textblock_append(tb, "%s may attempt to ", initial_pronoun);
  lore_append_spell_clause(tb, current_flags, race, COLOUR_ORANGE,
         COLOUR_WHITE);
 }
 /* Restore the previous reference. */
 ref_race = old_ref;
}
/**
 * Append the monster's melee attacks to a textblock.
 *
 * Known race flags are passed in for simplicity/efficiency.
 *
 * \param tb is the textblock we are adding to.
 * \param race is the monster race we are describing.
 * \param lore is the known information about the monster race.
 * \param known_flags is the preprocessed bitfield of race flags known to the
 *        player.
 * \param melee_colors is a list of colors that is associated with each
 *        blow effect.
 */
void lore_append_attack(textblock *tb, const struct monster_race *race,
      const struct monster_lore *lore,
      bitflag known_flags[RF_SIZE])
{
 int i, known_attacks = 0, described_count = 0;
 monster_sex_t msex = MON_SEX_NEUTER;
 assert(tb && race && lore);
 /* Extract a gender (if applicable) */
 msex = lore_monster_sex(race);
 /* Count the number of defined and known attacks */
 for (i = 0; i < z_info->mon_blows_max; i++) {
  /* Skip non-attacks */
  if (!race->blow[i].method) continue;
  if (lore->blow_known[i])
   known_attacks++;
 }
 /* Describe the lack of knowledge */
 if (known_attacks == 0) {
  textblock_append(tb, "Nothing is known about %s attack.  ",
       lore_pronoun_possessive(msex, false));
  return;
 }
 /* Describe each melee attack */
 for (i = 0; i < z_info->mon_blows_max; i++) {
  random_value dice;
  const char *effect_str = NULL;
  /* Skip unknown and undefined attacks */
  if (!race->blow[i].method || !lore->blow_known[i]) continue;
  /* Extract the attack info */
  dice = race->blow[i].dice;
  effect_str = race->blow[i].effect->desc;
  /* Introduce the attack description */
  if (described_count == 0)
   textblock_append(tb, "%s can ",
        lore_pronoun_nominative(msex, true));
  else if (described_count < known_attacks - 1)
   textblock_append(tb, ", ");
  else
   textblock_append(tb, ", or ");
  /* Describe the method */
  textblock_append(tb, "%s", race->blow[i].method->desc);
  /* Describe the effect (if any) */
  if (effect_str && strlen(effect_str) > 0) {
   /* Describe the attack type */
   textblock_append(tb, " to ");
   textblock_append_c(tb, COLOUR_L_RED, "%s", effect_str);
   textblock_append(tb, " (");
   /* Describe damage */
   if (dice.base || (dice.dice && dice.sides)) {
    textblock_append_c(tb, COLOUR_L_WHITE, "%+d", dice.base);
    if (dice.dice && dice.sides) {
     textblock_append(tb, ", %dd%d", dice.dice, dice.sides);
    }
    textblock_append(tb, ")");
   }
  }
  described_count++;
 }
 assert(described_count == known_attacks);
 textblock_append(tb, ".  ");
}
/**
 * Get the lore record for this monster race.
 */
struct monster_lore *get_lore(const struct monster_race *race)
{
 assert(race);
 return &l_list[race->ridx];
}
/**
 * Write the monster lore
 */
static void write_lore_entries(ang_file *fff)
{
 int i, n;
 for (i = 0; i < z_info->r_max; i++) {
  /* Current entry */
  struct monster_race *race = &r_info[i];
  struct monster_lore *lore = &l_list[i];
  /* Ignore non-existent or unseen monsters */
  if (!race->name) continue;
  if (!lore->tsights && !lore->all_known) continue;
  /* Output 'name' */
  file_putf(fff, "name:%s\n", race->name);
  /* Output base if we're remembering everything */
  if (lore->all_known)
   file_putf(fff, "base:%s\n", race->base->name);
  /* Output counts */
  file_putf(fff, "counts:%d:%d:%d:%d:%d:%d\n", lore->tsights,
      lore->deaths, lore->tkills, lore->notice, lore->ignore,
      lore->ranged);
  /* Output blow (up to max blows) */
  for (n = 0; n < z_info->mon_blows_max; n++) {
   /* End of blows */
   if (!lore->blow_known[n] && !lore->all_known) continue;
   if (!lore->blows[n].method) continue;
   /* Output blow method */
   file_putf(fff, "blow:%s", lore->blows[n].method->name);
   /* Output blow effect (may be none) */
   file_putf(fff, ":%s", lore->blows[n].effect->name);
   /* Output blow damage (may be 0) */
   file_putf(fff, ":%d+%dd%dM%d", lore->blows[n].dice.base,
     lore->blows[n].dice.dice,
     lore->blows[n].dice.sides,
     lore->blows[n].dice.m_bonus);
   /* Output number of times that blow has been seen */
   file_putf(fff, ":%d", lore->blows[n].times_seen);
   /* Output blow index */
   file_putf(fff, ":%d", n);
   /* End line */
   file_putf(fff, "\n");
  }
  /* Output flags */
  write_flags(fff, "flags:", lore->flags, RF_SIZE, r_info_flags);
  /* Output spell flags (multiple lines) */
  rsf_inter(lore->spell_flags, race->spell_flags);
  write_flags(fff, "spells:", lore->spell_flags, RSF_SIZE,
     r_info_spell_flags);
  /* Output 'drop' */
  if (lore->drops) {
   struct monster_drop *drop = lore->drops;
   char name[120] = "";
   while (drop) {
    struct object_kind *kind = drop->kind;
    if (kind) {
     object_short_name(name, sizeof name, kind->name);
     file_putf(fff, "drop:%s:%s:%d:%d:%d\n",
         tval_find_name(kind->tval), name,
         drop->percent_chance, drop->dice.dice,
         drop->dice.sides);
    } else {
     assert(drop->art);
     file_putf(fff, "drop-artifact:%s\n", drop->art->name);
    }
    drop = drop->next;
   }
  }
  file_putf(fff, "\n");
 }
}
/**
 * Save the lore to a file in the user directory.
 *
 * \param name is the filename
 *
 * \returns true on success, false otherwise.
 */
bool lore_save(const char *name)
{
 char path[1024];
 /* Write to the user directory */
 path_build(path, sizeof(path), ANGBAND_DIR_USER, name);
 if (text_lines_to_file(path, write_lore_entries)) {
  msg("Failed to create file %s.new", path);
  return false;
 }
 return true;
}
/**
 * \file mon-make.c
 * \brief Monster creation / placement code.
 *
 * Copyright (c) 1997-2007 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * ------------------------------------------------------------------------
 * Monster race allocation
 *
 * Monster race allocation is done using an allocation table (see alloc.h).
 * This table is sorted by depth.  Each line of the table contains the
 * monster race index, the monster race level, and three probabilities:
 * - prob1 is the base probability of the race, calculated from monster.txt.
 * - prob2 is calculated by get_mon_num_prep(), which decides whether a
 *         monster is appropriate based on a secondary function; prob2 is
 *         always either prob1 or 0.
 * - prob3 is calculated by get_mon_num(), which checks whether universal
 *         restrictions apply (for example, unique monsters can only appear
 *         once on a given level); prob3 is always either prob2 or 0.
 * ------------------------------------------------------------------------ */
static int16_t alloc_race_size;
static struct alloc_entry *alloc_race_table;
/**
 * Initialize monster allocation info
 */
static void init_race_allocs(void) {
 int i;
 struct monster_race *race;
 struct alloc_entry *table;
 int16_t *num = mem_zalloc(z_info->max_depth * sizeof(int16_t));
 int16_t *already_counted =
  mem_zalloc(z_info->max_depth * sizeof(int16_t));
 /* Size of "alloc_race_table" */
 alloc_race_size = 0;
 /* Scan the monsters (not the ghost) */
 for (i = 1; i < z_info->r_max - 1; i++) {
  /* Get the i'th race */
  race = &r_info[i];
  /* Legal monsters */
  if (race->rarity) {
   /* Count the entries */
   alloc_race_size++;
   /* Group by level */
   num[race->level]++;
  }
 }
 /* Calculate the cumultive level totals */
 for (i = 1; i < z_info->max_depth; i++) {
  /* Group by level */
  num[i] += num[i - 1];
 }
 /* Allocate the alloc_race_table */
 alloc_race_table = mem_zalloc(alloc_race_size * sizeof(struct alloc_entry));
 /* Get the table entry */
 table = alloc_race_table;
 /* Scan the monsters (not the ghost) */
 for (i = 1; i < z_info->r_max - 1; i++) {
  /* Get the i'th race */
  race = &r_info[i];
  /* Count valid races */
  if (race->rarity) {
   int p, lev, prev_lev_count, race_index;
   /* Extract this race's level */
   lev = race->level;
   /* Extract the base probability */
   p = (100 / race->rarity);
   /* Skip entries preceding this monster's level */
   prev_lev_count = (lev > 0) ? num[lev - 1] : 0;
   /* Skip entries already counted for this level */
   race_index = prev_lev_count + already_counted[lev];
   /* Load the entry */
   table[race_index].index = i;
   table[race_index].level = lev;
   table[race_index].prob1 = p;
   table[race_index].prob2 = p;
   table[race_index].prob3 = p;
   /* Another entry complete for this locale */
   already_counted[lev]++;
  }
 }
 mem_free(already_counted);
 mem_free(num);
}
static void cleanup_race_allocs(void) {
 mem_free(alloc_race_table);
}
/**
 * Apply a monster restriction function to the monster allocation table.
 * This way, we can use get_mon_num() to get a level-appropriate monster that
 * satisfies certain conditions (such as belonging to a particular monster
 * family).
 */
void get_mon_num_prep(bool (*get_mon_num_hook)(struct monster_race *race))
{
 int i;
 /* Scan the allocation table */
 for (i = 0; i < alloc_race_size; i++) {
  struct alloc_entry *entry = &alloc_race_table[i];
  /* Check the restriction, if any */
  if (!get_mon_num_hook || (*get_mon_num_hook)(&r_info[entry->index])) {
   /* Accept this monster */
   entry->prob2 = entry->prob1;
  } else {
   /* Do not use this monster */
   entry->prob2 = 0;
  }
 }
}
/**
 * Helper function for get_mon_num(). Scans the prepared monster allocation
 * table and picks a random monster. Returns the race of a monster in
 * `table`.
 */
static struct monster_race *get_mon_race_aux(long total,
            const struct alloc_entry *table)
{
 int i;
 /* Pick a monster */
 long value = randint0(total);
 /* Find the monster */
 for (i = 0; i < alloc_race_size; i++) {
  /* Found the entry */
  if (value < table[i].prob3) break;
  /* Decrement */
  value -= table[i].prob3;
 }
 return &r_info[table[i].index];
}
/**
 * Chooses a monster race that seems appropriate to the given level
 *
 * \param generated_level is the level to use when choosing the race.
 * \param current_level is the level where the monster will be placed - used
 * for checks on an out-of-depth monster.
 *
 * This function uses the "prob2" field of the monster allocation table,
 * and various local information, to calculate the "prob3" field of the
 * same table, which is then used to choose an appropriate monster, in
 * a relatively efficient manner.
 *
 * Note that town monsters will *only* be created in the town, and
 * "normal" monsters will *never* be created in the town, unless the
 * level is modified, for example, by polymorph or summoning.
 *
 * There is a small chance (1/25) of boosting the given depth by
 * a small amount (up to four levels), except in the town.
 *
 * It is (slightly) more likely to acquire a monster of the given level
 * than one of a lower level.  This is done by choosing several monsters
 * appropriate to the given level and keeping the deepest one.
 *
 * Note that if no monsters are appropriate, then this function will
 * fail, and return zero, but this should *almost* never happen.
 */
struct monster_race *get_mon_num(int level, bool special, bool allow_non_smart,
         bool vault)
{
 int i;
 long total = 0L;
 struct monster_race *race;
 struct alloc_entry *table = alloc_race_table;
 bool pursuing_monster = false;
 /* Level 24 monsters can only be generated if especially asked for */
 bool allow_24 = (level == z_info->dun_depth + 4);
 /* Default level */
 int generation_level = level;
 /* If generating escorts or similar, just use the level (which will be the
	 * captain's level); this will function as the *maximum* level
	 * for generation.  Otherwise, modify the level. */
 if (!special) {
  /* Deal with 'danger' items */
  generation_level += player->state.flags[OF_DANGER];
  /* Various additional modifications when not created in a vault */
  if (!vault) {
   /* If on the run from Morgoth, then levels 17--23 used for all
			 * forced smart monsters and half of others */
   if (player->on_the_run && (one_in_(2) || !allow_non_smart)) {
    pursuing_monster = true;
    generation_level = rand_range(17, 23);
   }
   /* The surface generates monsters as levels 17--23 */
   if (level == 0) {
    pursuing_monster = true;
    generation_level = rand_range(17, 23);
   }
   /* Most of the time use a small distribution */
            if (pursuing_monster) {
    /* Leave as is */
            } else if (level == player->depth) {
    /* Modify the effective level by a small random amount:
				 * [1, 4, 6, 4, 1] */
    generation_level += damroll(2, 2) - damroll(2, 2);
   } else {
    /* Modify the effective level by a tiny random amount:
				 * [1, 2, 1] */
    generation_level += damroll(1, 2) - damroll(1, 2);
   }
  }
 }
 /* Final bounds checking */
 if (generation_level < 1) generation_level = 1;
 if (allow_24) {
  generation_level = MIN(generation_level, z_info->dun_depth + 4);
 } else {
  generation_level = MIN(generation_level, z_info->dun_depth + 3);
 }
 /* Process probabilities */
 for (i = 0; i < alloc_race_size; i++) {
  /* Monsters are sorted by depth */
  if (table[i].level > generation_level) break;
  /* Default */
  table[i].prob3 = 0;
  /* Get the chosen monster */
  race = &r_info[table[i].index];
  /* Ignore monsters before the set level unless in special generation */
  if (!special && (table[i].level < generation_level)) continue;
  /* Even in special generation ignore monsters before 1/2 the level */
  if (special && (table[i].level <= generation_level / 2)) continue;
  /* Only one copy of a unique must be around at the same time */
  if (rf_has(race->flags, RF_UNIQUE) && (race->cur_num >= race->max_num))
   continue;
  /* Some monsters never appear out of depth */
  if (rf_has(race->flags, RF_FORCE_DEPTH) && race->level > player->depth)
   continue;
  /* Non-moving monsters can't appear as out-of-depth pursuing monsters */
  if (rf_has(race->flags, RF_NEVER_MOVE) && pursuing_monster) continue;
  /* Territorial monsters can't appear as out-of-depth pursuing monsters*/
  if (rf_has(race->flags, RF_TERRITORIAL) && pursuing_monster) continue;
  /* Forbid the generation of non-smart monsters except at level-creation
		 * or specific summons */
  if (!allow_non_smart && !rf_has(race->flags, RF_SMART) &&
   !rf_has(race->flags, RF_TERRITORIAL)) continue;
  /* Accept */
  table[i].prob3 = table[i].prob2;
  /* Total */
  total += table[i].prob3;
 }
 /* No legal monsters */
 if (total <= 0) return NULL;
 /* Pick a monster */
 race = get_mon_race_aux(total, table);
 /* Result */
 return race;
}
/**
 * ------------------------------------------------------------------------
 * Deleting of monsters and monster list handling
 * ------------------------------------------------------------------------ */
/**
 * Deletes a monster by index.
 *
 * When a monster is deleted, all of its objects are deleted.
 */
void delete_monster_idx(struct chunk *c, int m_idx)
{
 struct monster *mon = cave_monster(c, m_idx);
 struct loc grid;
 assert(m_idx > 0);
 assert(square_in_bounds(c, mon->grid));
 grid = mon->grid;
 /* Hack -- Reduce the racial counter */
 mon->race->cur_num--;
 /* Affect light? */
 if (mon->race->light != 0)
  player->upkeep->update |= PU_UPDATE_VIEW | PU_MONSTERS;
 /* Hack -- remove target monster */
 if (target_get_monster() == mon)
  target_set_monster(NULL);
 /* Hack -- remove tracked monster */
 if (player->upkeep->health_who == mon)
  health_track(player->upkeep, NULL);
 /* Monster is gone from square and group */
 square_set_mon(c, grid, 0);
 monster_remove_from_group(c, mon);
 /* Delete objects */
 struct object *obj = mon->held_obj;
 while (obj && (c == cave)) {
  struct object *next = obj->next;
  /* Delete the object.  Since it's in the cave's list do
		 * some additional bookkeeping. */
  if (obj->known) {
   /* It's not in a floor pile so remove it completely.
			 * Once compatibility with old savefiles isn't needed
			 * can skip the test and simply delist and delete
			 * since any obj->known from a monster's inventory
			 * will not be in a floor pile. */
   if (loc_is_zero(obj->known->grid) && (c == cave)) {
    delist_object(player->cave, obj->known);
    object_delete(player->cave, NULL, &obj->known);
   }
  }
  delist_object(c, obj);
  if (c == cave) {
   object_delete(cave, player->cave, &obj);
  }
  obj = next;
 }
 /* Free flow */
 flow_free(c, &mon->flow);
 /* Wipe the Monster */
 memset(mon, 0, sizeof(struct monster));
 /* Count monsters */
 c->mon_cnt--;
 /* Visual update */
 square_light_spot(c, grid);
}
/**
 * Deletes the monster, if any, at the given location.
 */
void delete_monster(struct chunk *c, struct loc grid)
{
 assert(square_in_bounds(c, grid));
 /* Delete the monster (if any) */
 if (square(c, grid)->mon > 0) {
  delete_monster_idx(c, square(c, grid)->mon);
 }
}
/**
 * Move a monster from index i1 to index i2 in the monster list.
 *
 * This should only be called when there is an actual monster at i1
 */
void monster_index_move(int i1, int i2)
{
 struct monster *mon;
 struct object *obj;
 /* Do nothing */
 if (i1 == i2) return;
 /* Old monster */
 mon = cave_monster(cave, i1);
 if (!mon) return;
 /* Update the cave */
 square_set_mon(cave, mon->grid, i2);
 /* Update midx */
 mon->midx = i2;
 /* Update group */
 if (!monster_group_change_index(cave, i2, i1)) {
  quit("Bad monster group info!") ;
  monster_groups_verify(cave);
 }
 /* Repair objects being carried by monster */
 for (obj = mon->held_obj; obj; obj = obj->next)
  obj->held_m_idx = i2;
 /* Update the target */
 if (target_get_monster() == mon)
  target_set_monster(cave_monster(cave, i2));
 /* Update the health bar */
 if (player->upkeep->health_who == mon)
  player->upkeep->health_who = cave_monster(cave, i2);
 /* Move monster */
 memcpy(cave_monster(cave, i2),
   cave_monster(cave, i1),
   sizeof(struct monster));
 /* Wipe hole */
 memset(cave_monster(cave, i1), 0, sizeof(struct monster));
}
/**
 * Compacts and reorders the monster list.
 *
 * This function can be very dangerous, use with caution!
 *
 * When `num_to_compact` is 0, we just reorder the monsters into a more compact
 * order, eliminating any "holes" left by dead monsters. If `num_to_compact` is
 * positive, then we delete at least that many monsters and then reorder.
 * We try not to delete monsters that are high level or close to the player.
 * Each time we make a full pass through the monster list, if we haven't
 * deleted enough monsters, we relax our bounds a little to accept
 * monsters of a slightly higher level, and monsters slightly closer to
 * the player.
 */
void compact_monsters(struct chunk *c, int num_to_compact)
{
 int m_idx, num_compacted, iter;
 int max_lev, min_dis, chance;
 /* Message (only if compacting) */
 if (num_to_compact)
  msg("Compacting monsters...");
 /* Compact at least 'num_to_compact' objects */
 for (num_compacted = 0, iter = 1; num_compacted < num_to_compact; iter++) {
  /* Get more vicious each iteration */
  max_lev = 5 * iter;
  /* Get closer each iteration */
  min_dis = 5 * (20 - iter);
  /* Check all the monsters */
  for (m_idx = 1; m_idx < cave_monster_max(c); m_idx++) {
   struct monster *mon = cave_monster(c, m_idx);
   /* Skip "dead" monsters */
   if (!mon->race) continue;
   /* High level monsters start out "immune" */
   if (mon->race->level > max_lev) continue;
   /* Ignore nearby monsters */
   if ((min_dis > 0) && (mon->cdis < min_dis)) continue;
   /* Saving throw chance */
   chance = 90;
   /* Only compact "Quest" Monsters in emergencies */
   if (rf_has(mon->race->flags, RF_QUESTOR) && (iter < 1000))
    chance = 100;
   /* Try not to compact Unique Monsters */
   if (rf_has(mon->race->flags, RF_UNIQUE)) chance = 99;
   /* All monsters get a saving throw */
   if (randint0(100) < chance) continue;
   /* Delete the monster */
   delete_monster(c, mon->grid);
   /* Count the monster */
   num_compacted++;
  }
 }
 /* Excise dead monsters (backwards!) */
 for (m_idx = cave_monster_max(c) - 1; m_idx >= 1; m_idx--) {
  struct monster *mon = cave_monster(c, m_idx);
  /* Skip real monsters */
  if (mon->race) continue;
  /* Move last monster into open hole */
  monster_index_move(cave_monster_max(c) - 1, m_idx);
  /* Compress "c->mon_max" */
  c->mon_max--;
 }
}
/**
 * Deletes all the monsters when the player leaves the level.
 *
 * This is an efficient method of simulating multiple calls to the
 * "delete_monster()" function, with no visual effects.
 *
 * Note that we must delete the objects the monsters are carrying, but we
 * do nothing with mimicked objects.
 */
void wipe_mon_list(struct chunk *c, struct player *p)
{
 int m_idx, i;
 /* Delete all the monsters */
 for (m_idx = cave_monster_max(c) - 1; m_idx >= 1; m_idx--) {
  struct monster *mon = cave_monster(c, m_idx);
  struct object *held_obj = mon ? mon->held_obj : NULL;
  /* Skip dead monsters */
  if (!mon->race) continue;
  /* Delete all the objects */
  if (held_obj) {
   /* Go through all held objects and remove from the cave's object
			 * list.  That way, the scan for orphaned objects in cave_free()
			 * doesn't attempt to access freed memory or free memory twice. */
   struct object *obj = held_obj;
   while (obj) {
    if (obj->oidx) {
     c->objects[obj->oidx] = NULL;
    }
    obj = obj->next;
   }
   object_pile_free(c, (p && c == cave) ? p->cave : NULL,
    held_obj);
  }
  /* Reduce the racial counter */
  mon->race->cur_num--;
  /* Monster is gone from square */
  square_set_mon(c, mon->grid, 0);
  /* Free flow */
  flow_free(c, &mon->flow);
  /* Wipe the Monster */
  memset(mon, 0, sizeof(struct monster));
 }
 /* Delete all the monster groups */
 for (i = 1; i < z_info->level_monster_max; i++) {
  if (c->monster_groups[i]) {
   monster_group_free(c, c->monster_groups[i]);
  }
 }
 /* Reset "cave->mon_max" */
 c->mon_max = 1;
 /* Reset "mon_cnt" */
 c->mon_cnt = 0;
 /* Hack -- no more target */
 target_set_monster(0);
 /* Hack -- no more tracking */
 health_track(p->upkeep, 0);
}
/**
 * ------------------------------------------------------------------------
 * Monster creation utilities:
 *  Getting a new monster index
 *  Creating objects for monsters to carry or mimic
 *  Calculating hitpoints
 * ------------------------------------------------------------------------ */
/**
 * Returns the index of a "free" monster, or 0 if no slot is available.
 *
 * This routine should almost never fail, but it *can* happen.
 * The calling code must check for and handle a 0 return.
 */
int16_t mon_pop(struct chunk *c)
{
 int m_idx;
 /* Normal allocation */
 if (cave_monster_max(c) < z_info->level_monster_max) {
  /* Get the next hole */
  m_idx = cave_monster_max(c);
  /* Expand the array */
  c->mon_max++;
  /* Count monsters */
  c->mon_cnt++;
  return m_idx;
 }
 /* Recycle dead monsters if we've run out of room */
 for (m_idx = 1; m_idx < cave_monster_max(c); m_idx++) {
  struct monster *mon = cave_monster(c, m_idx);
  /* Skip live monsters */
  if (!mon->race) {
   /* Count monsters */
   c->mon_cnt++;
   /* Use this monster */
   return m_idx;
  }
 }
 /* Warn the player if no index is available */
 if (character_dungeon)
  msg("Too many monsters!");
 /* Try not to crash */
 return 0;
}
/**
 * Set hallucinatory monster race
 */
static void set_hallucinatory_race(struct monster *mon)
{
 /* Try hard to find a random race */
 int tries = 1000;
 while (tries) {
  int race_idx = randint0(z_info->r_max);
  struct monster_race *race = &r_info[race_idx];
  if ((race->rarity != 0) && one_in_(race->rarity)) {
   mon->image_race = race;
   return;
  }
  tries--;
 }
 /* No hallucination this time */
 mon->image_race = mon->race;
}
/**
 * Determines a wandering destination for a monster.
 */
static void new_wandering_destination(struct chunk *c, struct monster *mon)
{
 struct monster_race *race = mon->race;
 /* Many monsters don't get wandering destinations: */
 if (rf_has(race->flags, RF_NEVER_MOVE) ||
  rf_has(race->flags, RF_HIDDEN_MOVE) ||
  !(rf_has(race->flags, RF_SMART) ||
    rf_has(race->spell_flags, RSF_SHRIEK))) {
  return;
 }
 mon->wandering_dist = z_info->wander_range;
 monster_group_new_wandering_flow(c, mon, loc(0, 0));
}
/**
 * ------------------------------------------------------------------------
 * Placement of a single monster
 * These are the functions that actually put the monster into the world
 * ------------------------------------------------------------------------ */
/**
 * Attempts to place a copy of the given monster at the given position in
 * the dungeon.
 *
 * All of the monster placement routines eventually call this function. This
 * is what actually puts the monster in the dungeon (i.e., it notifies the cave
 * and sets the monster's position). The dungeon loading code also calls this
 * function directly.
 *
 * `origin` is the item origin to use for any monster drops (e.g. ORIGIN_DROP,
 * ORIGIN_DROP_PIT, etc.) The dungeon loading code calls this with origin = 0,
 * which prevents the monster's drops from being generated again.
 *
 * Returns the m_idx of the newly copied monster, or 0 if the placement fails.
 */
int16_t place_monster(struct chunk *c, struct loc grid, struct monster *mon,
  uint8_t origin)
{
 int16_t m_idx;
 struct monster *new_mon;
 struct monster_group_info info = mon->group_info;
 bool loading = mon->midx > 0;
 assert(square_in_bounds(c, grid));
 assert(!square_monster(c, grid));
 /* Get a new record, or recycle the old one */
 if (loading) {
  m_idx = mon->midx;
  c->mon_max++;
  c->mon_cnt++;
 } else {
  m_idx = mon_pop(c);
  if (!m_idx) return 0;
 }
 /* Copy the monster */
 new_mon = cave_monster(c, m_idx);
 memcpy(new_mon, mon, sizeof(struct monster));
 /* Set the ID */
 new_mon->midx = m_idx;
 /* Set the location and origin */
 square_set_mon(c, grid, new_mon->midx);
 new_mon->grid = grid;
 assert(square_monster(c, grid) == new_mon);
 mon->origin = origin;
 /* Assign monster to its monster group */
 monster_group_assign(c, new_mon, info, loading);
 /* Give the monster a place to wander towards */
 new_wandering_destination(c, mon);
 /* Update the monster */
 update_mon(new_mon, c, true);
 /* Count racial occurrences */
 new_mon->race->cur_num++;
 /* Result */
 return m_idx;
}
/**
 * Attempts to place a monster of the given race at the given location.
 *
 * If `sleep` is true, the monster is placed with its default sleep value,
 * which is given in monster.txt.
 *
 * `origin` is the item origin to use for any monster drops (e.g. ORIGIN_DROP,
 * ORIGIN_DROP_PIT, etc.)
 *
 * This routine refuses to place out-of-depth "FORCE_DEPTH" monsters.
 *
 * This is the only function which may place a monster in the dungeon,
 * except for the savefile loading code, which calls place_monster()
 * directly.
 */
bool place_new_monster_one(struct chunk *c, struct loc grid,
         struct monster_race *race, bool sleep,
         bool ignore_depth,
         struct monster_group_info group_info, uint8_t origin)
{
 struct monster *mon, *leader;
 struct monster monster_body;
 int index = group_info.index;
 struct monster_group *group;
 assert(square_in_bounds(c, grid));
 assert(race && race->name);
 /* Not where monsters already are */
 if (square_monster(c, grid)) return false;
 /* Not where the player already is */
 if (loc_eq(player->grid, grid)) return false;
 /* Prevent monsters from being placed where they cannot walk, but allow
	 * other feature types */
 if (!square_is_monster_walkable(c, grid)) return false;
 /* No creation on glyphs */
 if (square_iswarded(c, grid)) return false;
 /* "unique" monsters must be "unique" */
 if (rf_has(race->flags, RF_UNIQUE) && (race->cur_num >= race->max_num))
  return false;
 /* Check for depth issues except where we're ignoring that */
 if (!ignore_depth) {
  /* Force depth monsters may NOT normally be created out of depth */
  if (rf_has(race->flags, RF_FORCE_DEPTH) && c->depth < race->level)
   return false;
  /* Special generation may NOT normally be created */
  if (rf_has(race->flags, RF_SPECIAL_GEN))
   return false;
 }
 /* Check out-of-depth-ness */
 if (OPT(player, cheat_hear)) {
  if (race->level > c->depth) {
   if (rf_has(race->flags, RF_UNIQUE)) {
    /* OOD unique */
    msg("Deep unique (%s).", race->name);
   } else {
    /* Normal monsters but OOD */
    msg("Deep monster (%s).", race->name);
   }
  } else if (rf_has(race->flags, RF_UNIQUE)) {
   msg("Unique (%s).", race->name);
  }
 }
 /* Get local monster */
 mon = &monster_body;
 /* Clean out the monster */
 memset(mon, 0, sizeof(struct monster));
 /* Save the race */
 mon->race = race;
 /* Determine group leader, if any */
 group = monster_group_by_index(c, index);
 if (group) {
  leader = cave_monster(c, group->leader);
 } else {
  leader = NULL;
 }
 /* Save the hallucinatory race */
 if (race == lookup_monster("Morgoth, Lord of Darkness")) {
  mon->image_race = lookup_monster("Melkor, Rightful Lord of Arda");
 } else if (leader) {
  mon->image_race = leader->image_race;
 } else {
  set_hallucinatory_race(mon);
 }
 /* Set alertness */
 if (sleep) {
  int amount = 0;
  /* Enforce sleeping if needed */
  if (race->sleep) {
   amount = randint1(race->sleep);
  }
  /* If there is a lead monster, copy its value */
  if (leader) {
   amount = ALERTNESS_ALERT - leader->alertness;
  } else if (player->on_the_run) {
   /* Many monsters are more alert during the player's escape */
   if ((player->depth == 0) && (amount > 0)) {
    /* including all monsters on the Gates level */
    amount = damroll(1, 3);
   } else if ((race->level > player->depth + 2) &&
        !square_isvault(c, grid) && (amount > 0)) {
    /* and dangerous monsters out of vaults (which are assumed
				 * to be in direct pursuit) */
    amount = damroll(1, 3);
   }
  }
  mon->alertness = ALERTNESS_ALERT - amount;
 }
 /* Uniques get a fixed amount of HP */
 if (rf_has(race->flags, RF_UNIQUE)) {
  mon->maxhp = race->hdice * (1 + race->hside) / 2;
 } else {
  mon->maxhp = damroll(race->hdice, race->hside);
 }
 /* Initialize mana */
 mon->mana = z_info->mana_max;
 /* Initialize song */
 mon->song = NULL;
 /* And start out fully healthy */
 mon->hp = mon->maxhp;
 /* Extract the monster base speed */
 calc_monster_speed(mon);
 /* Mark minimum range for recalculation */
 mon->min_range = 0;
 /* Initialize flow */
 flow_new(c, &mon->flow);
 /* Give almost no starting energy (avoids clumped movement) -
	 * same as old FORCE_SLEEP flag, which is now the default behaviour */
 mon->energy = (uint8_t)randint0(10);
 /* Affect light? */
 if (mon->race->light != 0)
  player->upkeep->update |= PU_UPDATE_VIEW | PU_MONSTERS;
 /* Set the group info */
 mon->group_info.index = index ? index : monster_group_index_new(c);
 mon->group_info.role = group_info.role;
 /* Place the monster in the dungeon */
 if (!place_monster(c, grid, mon, origin))
  return (false);
 /* Monsters that don't pursue you drop their treasure upon being created */
 if (rf_has(mon->race->flags, RF_TERRITORIAL)) {
  drop_loot(c, mon, grid, false);
 }
 /* Success */
 return (true);
}
/**
 * ------------------------------------------------------------------------
 * More complex monster placement routines
 * ------------------------------------------------------------------------ */
/**
 * Race for escort type
 */
static struct monster_race *place_escort_race = NULL;
/**
 * Help pick an escort type
 */
static bool place_escort_okay(struct monster_race *race)
{
 /* Require similar "race" */
 if (race->base != place_escort_race->base) return false;
 /* Skip more advanced monsters */
 if (race->level > place_escort_race->level) return false;
 /* Skip unique monsters */
 if (rf_has(race->flags, RF_UNIQUE)) return false;
 /* Paranoia -- Skip identical monsters */
 if (place_escort_race == race) return false;
 /* Okay */
 return true;
}
/**
 * Attempt to place a unique's unique ally at a given location
 */
static void place_monster_unique_friend(struct chunk *c, struct loc grid,
          struct monster_race *race, bool sleep,
          struct monster_group_info group_info,
          uint8_t origin)
{
 int i, r;
 /* Find the unique friend */
 for (r = 1; r < z_info->r_max; r++) {
  struct monster_race *race1 = &r_info[r];
  if ((race->base == race1->base) &&
   rf_has(race1->flags, RF_UNIQUE_FRIEND)) {
   /* Random direction */
   int start = randint0(8);
   /* Check each direction */
   for (i = start; i < 8 + start; i++) {
    struct loc try = loc_sum(grid, ddgrid_ddd[i % 8]);
    if (place_new_monster_one(c, try, race1, sleep, true, group_info,
            origin)) {
     /* Success */
     break;
    }
   }
  }
 }
}
/**
 * Attempts to place a group of monsters of race `r_idx` around
 * the given location. The number of monsters to place is `total`.
 *
 * If `sleep` is true, the monster is placed with its default sleep value,
 * which is given in monster.txt.
 *
 * `origin` is the item origin to use for any monster drops (e.g. ORIGIN_DROP,
 * ORIGIN_DROP_PIT, etc.)
 */
static bool place_new_monster_group(struct chunk *c, struct loc grid,
  struct monster_race *race, bool sleep,
  struct monster_group_info group_info,
  int total, uint8_t origin)
{
 int n, i;
 int loc_num;
 /* Locations of the placed monsters */
 struct loc *loc_list = mem_zalloc(sizeof(struct loc) *
           z_info->monster_group_max);
 /* Sanity and bounds check */
 assert(race);
 total = MIN(total, z_info->monster_group_max);
 /* Start on the monster */
 loc_num = 1;
 loc_list[0] = grid;
 /* Puddle monsters, breadth first, up to total */
 for (n = 0; (n < loc_num) && (loc_num < total); n++) {
  int start = randint0(8);
  /* Check each direction, up to total */
  for (i = start; (i < 8) && (loc_num < total); i++) {
   struct loc try = loc_sum(loc_list[n], ddgrid_ddd[i % 8]);
   /* Walls and Monsters block flow */
   if (!square_isempty(c, try)) continue;
   /* Attempt to place another monster */
   if (place_new_monster_one(c, try, race, sleep, false, group_info,
           origin)) {
    /* Add it to the "hack" set */
    loc_list[loc_num] = try;
    loc_num++;
   }
  }
 }
 mem_free(loc_list);
 /* Return true if it places >= 1 monster (even if fewer than desired) */
 return (loc_num > 1);
}
/**
 * Helper function to place monsters that appear as friends or escorts
 */
static void place_monster_escort(struct chunk *c, struct loc grid,
         struct monster_race *race, bool sleep,
         struct monster_group_info group_info,
         uint8_t origin)
{
 int n, i;
 int loc_num;
 int escort_size;
 int extras = 0;
 /* Locations of the placed monsters */
 struct loc *loc_list = mem_zalloc(sizeof(struct loc) *
           z_info->monster_group_max);
 /* Monster races of the placed monsters */
 struct monster_race **escort_races =
  mem_zalloc(sizeof(struct monster_race*) * z_info->monster_group_max);
 struct monster_race *escort_race;
 assert(race);
 /* Calculate the number of escorts we want. */
 if (rf_has(race->flags, RF_ESCORTS)) {
  escort_size = rand_range(8, 16);
 } else {
  escort_size = rand_range(4, 7);
 }
 escort_size = MIN(escort_size, z_info->monster_group_max);
 /* Use the leader's monster type to restrict the escorts. */
 place_escort_race = race;
 /* Prepare allocation table */
 get_mon_num_prep(place_escort_okay);
 /* Build monster table, get indices of all escorts */
 for (i = 0; i < escort_size; i++) {
  if (extras > 0) {
   escort_races[i] = escort_races[i - 1];
   extras--;
  } else {
   escort_races[i] = get_mon_num(race->level, true, false, false);
   /* Skip this creature if get_mon_num failed (paranoia) */
   if (escort_races[i] == NULL) continue;
   if (rf_has(escort_races[i]->flags, RF_FRIENDS)) {
    extras = rand_range(2, 3);
   } else if (rf_has(escort_races[i]->flags, RF_FRIEND)) {
    extras = rand_range(1, 2);
   } else {
    extras = 0;
   }
  }
 }
 escort_race = escort_races[0];
 /* Start on the monster */
 loc_num = 1;
 loc_list[0] = grid;
 /* Puddle monsters, breadth first, up to escort size */
 for (n = 0; (n < loc_num) && (loc_num < escort_size); n++) {
  int start = randint0(8);
  /* Check each direction, up to escort size */
  for (i = start; (i < 8) && (loc_num < escort_size); i++) {
   struct loc try = loc_sum(loc_list[n], ddgrid_ddd[i % 8]);
   /* Walls and Monsters block flow */
   if (!square_isempty(c, try)) continue;
   /* Attempt to place another monster */
   if (place_new_monster_one(c, try, escort_race, sleep, false, group_info,
           origin)) {
    /* Get index of the next escort */
    escort_race = escort_races[loc_num];
    /* Add it to the "hack" set */
    loc_list[loc_num] = try;
    loc_num++;
   }
  }
 }
 /* Prepare allocation table */
 get_mon_num_prep(NULL);
 /* Success */
 mem_free(loc_list);
 mem_free(escort_races);
}
/**
 * Attempts to place a monster of the given race at the given location.
 *
 * Note that certain monsters are placed with a large group of
 * identical or similar monsters. However, if `group_okay` is false,
 * then such monsters are placed by themselves.
 *
 * If `sleep` is true, the monster is placed with its default sleep value,
 * which is given in monster.txt.
 *
 * `origin` is the item origin to use for any monster drops (e.g. ORIGIN_DROP,
 * ORIGIN_DROP_PIT, etc.)
 */
bool place_new_monster(struct chunk *c, struct loc grid,
        struct monster_race *race, bool sleep, bool group_ok,
        struct monster_group_info group_info, uint8_t origin)
{
 assert(c);
 assert(race);
 /* If we don't have a group index already, make one; our first monster
	 * will be the leader */
 if (!group_info.index) {
  group_info.index = monster_group_index_new(c);
 }
 /* Place one monster, or fail */
 if (!place_new_monster_one(c, grid, race, sleep, false, group_info,
          origin)) {
  return (false);
 }
 /* We're done unless the group flag is set */
 if (!group_ok) return (true);
 /* Go through friends/escorts flags */
 if (rf_has(race->flags, RF_UNIQUE_FRIEND)) {
  place_monster_unique_friend(c, grid, race, sleep, group_info, origin);
 } else if (rf_has(race->flags, RF_FRIENDS)) {
  /* relative depth  |  number in group  (FRIENDS) */
  /*             -2  |    2                        */
  /*             -1  |  2 / 3                      */
  /*              0  |    3                        */
  /*             +1  |  3 / 4                      */
  /*             +2  |    4                        */
  int amount = (rand_range(6,7) + (c->depth - race->level)) / 2;
  amount = MIN(MAX(amount, 2), 4);
  group_info.role = MON_GROUP_MEMBER;
  return place_new_monster_group(c, grid, race, sleep, group_info,
            amount, origin);
 } else if (rf_has(race->flags, RF_FRIEND)) {
  /* relative depth  |  chance of having a companion  (FRIEND) */
  /*             -2  |    0%                                   */
  /*             -1  |   25%                                   */
  /*              0  |   50%                                   */
  /*             +1  |   75%                                   */
  /*             +2  |  100%                                   */
  int amount = 1;
  if (randint1(4) <= c->depth - race->level + 2) amount++;
  group_info.role = MON_GROUP_MEMBER;
  return place_new_monster_group(c, grid, race, sleep, group_info,
            amount, origin);
 } else if (rf_has(race->flags, RF_ESCORT) ||
      rf_has(race->flags, RF_ESCORTS)) {
  group_info.role = MON_GROUP_SERVANT;
  place_monster_escort(c, grid, race, sleep, group_info, origin);
 }
 /* Success */
 return true;
}
/**
 * Picks a monster race, makes a new monster of that race, then attempts to
 * place it in the dungeon. The monster race chosen will be appropriate for
 * dungeon level equal to `depth`.
 *
 * If `sleep` is true, the monster is placed with its default sleep value,
 * which is given in monster.txt.
 *
 * If `group_okay` is true, we allow the placing of a group, if the chosen
 * monster appears with friends or an escort.
 *
 * `origin` is the item origin to use for any monster drops (e.g. ORIGIN_DROP,
 * ORIGIN_DROP_PIT, etc.)
 *
 * Returns true if we successfully place a monster.
 */
bool pick_and_place_monster(struct chunk *c, struct loc grid, int depth,
  bool sleep, bool group_okay, uint8_t origin)
{
 /* Pick a monster race, no specified group */
 struct monster_race *race = get_mon_num(depth, false, sleep,
           origin == ORIGIN_DROP_VAULT);
 struct monster_group_info info = { 0, 0 };
 if (race) {
  return place_new_monster(c, grid, race, sleep, group_okay, info,
         origin);
 } else {
  return false;
 }
}
/**
 * Has a very good go at placing a monster of kind represented by a flag
 * (eg RF_DRAGON) at grid. It is governed by a maximum depth and tries
 * 100 times at this depth and each shallower depth.
 */
void place_monster_by_flag(struct chunk *c, struct loc grid, int flg1, int flg2,
         bool allow_unique, int max_depth, bool spell)
{
 bool got_race = false;
 int tries = 0;
 struct monster_race *race = NULL;
 int depth = max_depth;
 struct monster_group_info info = { 0, 0 };
 while (!got_race && (depth > 0)) {
  race = get_mon_num(depth, false, true, true);
        if (race && (allow_unique || !rf_has(race->flags, RF_UNIQUE))) {
            if (rf_has(race->flags, flg1)) {
                got_race = true;
                break;
            } else if ((flg2 > 0) && rf_has(race->flags, flg2)) {
                got_race = true;
                break;
   }
  }
  tries++;
  if (tries >= 100) {
   tries = 0;
   depth--;
  }
 }
 /* Place a monster of that type if you could find one */
 if (got_race) {
  place_new_monster_one(c, grid, race, true, false, info,
         ORIGIN_DROP_VAULT);
 }
}
/**
 * Has a very good go at placing a monster of kind represented by its base
 * glyph (eg 'v' for vampire) at grid. It is governed by a maximum depth and
 * tries 100 times at this depth and each shallower depth.
 */
void place_monster_by_letter(struct chunk *c, struct loc grid, char ch,
        bool allow_unique, int max_depth)
{
 bool got_race = false;
 int tries = 0;
 struct monster_race *race = NULL;
 int depth = max_depth;
 char stmp[2] = { '\0', '\0' };
 wchar_t wtmp[2];
 struct monster_group_info info = { 0, 0 };
 /* Try to convert the character to one wide character, return on failure */
 stmp[0] = ch;
 if (text_mbstowcs(wtmp, stmp, N_ELEMENTS(wtmp)) != 1) {
  return;
 }
 while (!got_race && (depth > 0)) {
  race = get_mon_num(depth, false, true, true);
  if (race->d_char == wtmp[0] &&
   (allow_unique || !rf_has(race->flags, RF_UNIQUE))) {
   got_race = true;
   break;
  }
  tries++;
  if (tries >= 100) {
   tries = 0;
   depth--;
  }
 }
 /* Place a monster of that type if you could find one */
 if (got_race) {
  place_new_monster_one(c, grid, race, true, false, info,
         ORIGIN_DROP_VAULT);
 }
}
/**
 * Picks a monster race, makes a new monster of that race, then attempts to
 * place it in the dungeon at least `dis` away from the player. The monster
 * race chosen will be appropriate for dungeon level equal to `depth`.
 *
 * If `sleep` is true, the monster is placed with its default sleep value,
 * which is given in monster.txt.
 *
 * Returns true if we successfully place a monster.
 */
bool pick_and_place_monster_on_stairs(struct chunk *c, struct player *p,
           bool sleep, int depth, bool force_undead)
{
 struct loc stair, grid;
 struct monster *mon;
 bool displaced = false;
 bool placed = false;
 char dir[5];
 int tries = 0;
 /* No monsters come through the stairs on tutorial/challenge levels */
 if (in_tutorial() || p->game_type > 0) return false;
 /* Get a stair location */
 if (!cave_find(c, &stair, square_isstairs)) return false;
 /* Default the new location to this location */
 grid = stair;
 /* If there is something on the stairs, try adjacent squares */
 mon = square_monster(c, stair);
 if (mon || loc_eq(p->grid, stair)) {
  int d, start;
  /* If the monster on the squares cannot move, then simply give up */
  if (mon && (rf_has(mon->race->flags, RF_NEVER_MOVE) ||
     rf_has(mon->race->flags, RF_HIDDEN_MOVE))) {
   return false;
  }
  /* Look through the eligible squares and choose an empty one randomly */
  start = randint0(8);
  for (d = start; d < 8 + start; d++) {
   struct loc grid1 = loc_sum(grid, ddgrid_ddd[d % 8]);
   /* Check Bounds */
   if (!square_in_bounds(c, grid1)) continue;
   /* Check Empty Square */
   if (!(square_isempty(c, grid1) ||
      square_isplayer(c, grid1))) {
    continue;
   }
   /* Displace the existing monster */
   grid = grid1;
   displaced = true;
   break;
  }
  /* Give up */
  if (!displaced) return false;
 }
 /* First, displace the existing monster to the safe square */
 if (displaced) {
  monster_swap(stair, grid);
  /* Need to update the player's field of view if she is moved */
  if (loc_eq(p->grid, grid)) {
    update_view(c, p);
  }
 }
 /* Try hard to put a monster on the stairs */
 while (!placed && (tries < 50)) {
  /* Modify the monster generation level based on the stair type */
  int monster_level = depth;
  int feat = square_feat(c, stair)->fidx;
  if (feat == FEAT_LESS_SHAFT) {
   monster_level -= 2;
   my_strcpy(dir, "down", sizeof(dir));
  } else if (feat == FEAT_LESS) {
   monster_level -= 1;
   my_strcpy(dir, "down", sizeof(dir));
  } else if (feat == FEAT_MORE) {
   monster_level += 1;
   my_strcpy(dir, "up", sizeof(dir));
  } else if (feat == FEAT_MORE_SHAFT) {
   monster_level += 2;
   my_strcpy(dir, "up", sizeof(dir));
  }
  /* Correct deviant monster levels */
  if (monster_level < 1) monster_level = 1;
  /* Sometimes only wraiths are allowed */
  if (force_undead) {
   place_monster_by_flag(c, stair, RF_UNDEAD, -1, true,
          MAX(monster_level + 3, 13), false);
   placed = true;
  } else {
   /* But usually allow most monsters */
   placed = pick_and_place_monster(c, stair, monster_level, false,
           true, ORIGIN_DROP);
  }
  tries++;
 }
 /* Print messages etc */
 if (placed) {
  struct monster *mon1 = square_monster(c, stair);
  /* Display a message if seen */
  if (monster_is_visible(mon1)) {
   char message[240];
   if (monster_has_friends(mon1)) {
    strnfmt(message, sizeof(message),
     "A group of enemies come %s the stair",
     dir);
   } else {
    char m_name[80];
    monster_desc(m_name, sizeof(m_name), mon1,
     MDESC_STANDARD);
    strnfmt(message, sizeof(message),
     "%s comes %s the stair", m_name, dir);
   }
   if (displaced) {
    char who[80];
    if (loc_eq(p->grid, grid)) {
     my_strcpy(who, "you", 80);
    } else {
     monster_desc(who, sizeof(who),
      square_monster(c, grid),
      MDESC_DIED_FROM);
    }
    msg("%s, forcing %s out of the way!", message,
     who);
   } else {
    msg("%s!", message);
   }
   return true;
  }
 }
 /* Didn't happen or not seen */
 return false;
}
/**
 * Picks a monster race, makes a new monster of that race, then attempts to
 * place it in the dungeon at least `dis` away from the player. The monster
 * race chosen will be appropriate for dungeon level equal to `depth`.
 *
 * If `sleep` is true, the monster is placed with its default sleep value,
 * which is given in monster.txt.
 *
 * Returns true if we successfully place a monster.
 */
bool pick_and_place_distant_monster(struct chunk *c, struct player *p,
         bool sleep, int depth)
{
 struct loc grid;
 int attempts_left = 1000;
 assert(c);
 /* Find a legal, distant, unoccupied, space */
 while (--attempts_left) {
  /* Pick a location */
  grid = loc(randint0(c->width), randint0(c->height));
  /* Require "naked" floor grid */
  if (!square_isempty(c, grid)) continue;
  /* Accept grids out of view */
  if (!los(c, grid, p->grid)) break;
 }
 if (!attempts_left) {
  if (OPT(p, cheat_xtra) || OPT(p, cheat_hear))
   msg("Warning! Could not allocate a new monster.");
  return false;
 }
 /* Attempt to place the monster, allow groups */
 if (pick_and_place_monster(c, grid, depth, sleep, true, ORIGIN_DROP))
  return true;
 /* Nope */
 return false;
}
struct init_module mon_make_module = {
 .name = "monster/mon-make",
 .init = init_race_allocs,
 .cleanup = cleanup_race_allocs
};
/**
 * \file mon-move.c
 * \brief Monster movement
 *
 * Monster AI affecting movement and spells, process a monster 
 * (with spells and actions of all kinds, reproduction, effects of any 
 * terrain on monster movement, picking up and destroying objects), 
 * process all monsters.
 *
 * Copyright (c) 1997 Ben Harrison, David Reeve Sward, Keldon Jones.
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * ------------------------------------------------------------------------
 * Routines to enable decisions on monster behaviour
 * ------------------------------------------------------------------------ */
/**
 * Check if the monster can smell anything
 */
static bool monster_can_smell(struct monster *mon)
{
 int age = get_scent(cave, mon->grid);
 if (age == -1) return false;
 /* Wolves are amazing trackers */
 if (streq("wolf", mon->race->base->name)) {
  /* I smell a character! */
  return true;
 } else if (streq("cat", mon->race->base->name)) {
  /* Felines are also quite good */
  if (age <= SMELL_STRENGTH / 2) {
   /* Something's in the air... */
   return true;
  }
 }
 return false;
}
/**
 * Check if the monster normally occurs with other monsters
 */
static bool monster_talks_to_friends(struct monster *mon)
{
 struct monster_race *race = mon->race;
 return rf_has(race->flags, RF_FRIENDS) ||
  rf_has(race->flags, RF_FRIEND) ||
  rf_has(race->flags, RF_UNIQUE_FRIEND) ||
  rf_has(race->flags, RF_ESCORT) ||
  rf_has(race->flags, RF_ESCORTS) ||
  rsf_has(race->spell_flags, RSF_SHRIEK);
}
/**
 * Check if the monster can occupy a grid safely
 */
static bool monster_can_exist(struct chunk *c, struct monster *mon,
         struct loc grid, bool occupied_ok, bool can_dig)
{
 struct monster_race *race = mon->race;
 /* Check Bounds */
 if (!square_in_bounds(c, grid)) return false;
 /* The grid is already occupied. */
 if (square_monster(c, grid) && !occupied_ok) return false;
 /* Glyphs -- must break first */
 if (square_iswarded(c, grid)) return false;
    /* Only flying creatures can pass chasms */
    if (square_ischasm(c, grid)) {
        if (rf_has(race->flags, RF_FLYING)) {
   return true;
        } else {
   return false;
  }
 }
 /* Anything else passable is fine */
 if (square_ispassable(c, grid)) return true;
 /* Permanent walls are never OK */
 if (square_isperm(c, grid)) return false;
 /* Monster can pass through walls */
 if (rf_has(race->flags, RF_PASS_WALL)) return true;
 /* Monster can bore through walls, and is allowed to. */
 if (rf_has(race->flags, RF_KILL_WALL) && (can_dig)) return true;
 /* Monster can dig through walls, and is allowed to. */
 if (rf_has(race->flags, RF_TUNNEL_WALL) && (can_dig)) return true;
 /* Some monsters can pass under doors */
 if (square_isdoor(c, grid) && rf_has(race->flags, RF_PASS_DOOR))
  return true;
 /* Not passable, and the monster can do nothing about it */
 return false;
}
/**
 * Determines the chance of a skill or hit roll succeeding.
 * (1 d sides + skill) - (1 d sides + difficulty)
 * Results <= 0 count as fails.
 * Results > 0 are successes.
 *
 * returns the number of ways you could succeed
 * (i.e. number of chances out of sides*sides
 *
 * note that this will be a percentage for normal skills (10 sides)
 * but will be out of 400 for hit rolls
 */
static int success_chance(int sides, int skill, int difficulty)
{
 int i, j;
 int ways = 0;
 for (i = 1; i <= sides; i++)
  for (j = 1; j <= sides; j++)
   if (i + skill > j + difficulty)
    ways++;
 return ways;
}
/**
 * Can the monster enter this grid?  How easy is it for them to do so?
 *
 * Returns the percentage chance of success.
 *
 * The code that uses this function sometimes assumes that it will never
 * return a value greater than 100.
 *
 * The usage of level to determine whether one monster can push past
 * another is a tad iffy, but ensures that orc soldiers can always
 * push past other orc soldiers.
 */
int monster_entry_chance(struct chunk *c, struct monster *mon, struct loc grid,
       bool *bash)
{
 struct monster *mon1 = square_monster(c, grid);
 /* Assume nothing in the grid other than the terrain hinders movement */
 int move_chance = 100;
 /* Check Bounds */
 if (!square_in_bounds(c, grid)) return 0;
 /* Permanent walls are never passable */
 if (square_isperm(c, grid)) return 0;
 /* The grid is occupied by the player or a monster. */
 if (square_isplayer(c, grid)) {
  return 100;
 } else if (mon1) {
  /* All monsters can attempt to push past monsters that can move */
  if (!rf_has(mon1->race->flags, RF_NEVER_MOVE) &&
   !rf_has(mon1->race->flags, RF_HIDDEN_MOVE)) {
   /* It is easy to push past unwary or sleeping monsters */
   if ((mon1->alertness < ALERTNESS_ALERT) &&
    (monster_group_leader(c, mon) !=
     monster_group_leader(c, mon1))) {
    move_chance = 80;
   } else if ((mon1->stance == STANCE_FLEEING) &&
        (mon->stance != STANCE_FLEEING)) {
    /* Easy for non-fleeing monsters to push past fleeing ones */
    move_chance = 80;
   } else if ((mon1->stance != STANCE_FLEEING) &&
        (mon->stance == STANCE_FLEEING)) {
    /* Easy for fleeing monsters to push past non-fleeing ones */
    move_chance = 80;
   } else if (mon->race->level > mon1->race->level) {
    /* It is easy to push past weaker monsters */
    move_chance = 80;
   } else if (mon->race->level == mon1->race->level) {
    /* It is quite hard to push past monsters of equal strength */
    move_chance = 20;
   } else {
    /* It is very difficult to move past alert, unafraid,
				 * stronger monsters */
    move_chance = 10;
   }
  } else {
   /* Cannot do anything to clear away the other monster */
   return 0;
  }
 }
 /* Glyphs */
 if (square_iswarded(c, grid)) {
  /* A simulated Will check */
  int chance = success_chance(10, monster_skill(mon, SKILL_WILL), 20);
  /* Unwary monsters won't break glyphs */
  if (mon->alertness < ALERTNESS_ALERT) {
   chance = 0;
  }
  /* Glyphs are hard to break */
  move_chance = MIN(move_chance, chance);
 }
    /* Only flying creatures can pass chasms */
    if (square_ischasm(c, grid)) {
        if (!rf_has(mon->race->flags, RF_FLYING)) {
   return 0;
  }
 }
 /* Feature is passable */
 if (square_ispassable(c, grid)) {
  /* Glyphs and chasms are handled above, everything else is fine */
  return move_chance;
 } else {
  /* Granite, Quartz, Rubble */
  if (square_iswall(c, grid) && !square_isdoor(c, grid)) {
   /* Impassible except for monsters that move through walls */
   if (rf_has(mon->race->flags, RF_PASS_WALL) ||
    rf_has(mon->race->flags, RF_KILL_WALL)) {
    return move_chance;
   } else if (rf_has(mon->race->flags, RF_TUNNEL_WALL) &&
     (mon->alertness >= ALERTNESS_ALERT)) {
    /* Alert monsters can slowly tunnel through walls */
    return move_chance;
   }
   return 0;
  }
  /* Doors */
  if (square_isdoor(c, grid)) {
   int unlock_chance = 0;
   int bash_chance = 0;
   /* Some monsters can simply pass through doors */
   if (rf_has(mon->race->flags, RF_PASS_DOOR) ||
    rf_has(mon->race->flags, RF_PASS_WALL)) {
    return move_chance;
   }
   /* Unwary monsters won't open doors in vaults or interesting rooms*/
   if ((mon->alertness < ALERTNESS_ALERT) &&
    square_isvault(c, grid)) {
    return 0;
   }
   /* No monsters open secret doors in vaults or interesting rooms */
   if (square_issecretdoor(c, grid) && square_isvault(c, grid)) {
    return 0;
   }
   /* Monster can open doors that are not jammed */
   if (rf_has(mon->race->flags, RF_OPEN_DOOR) &&
    !square_isjammeddoor(c, grid)) {
    /* Closed doors and secret doors
				 * Note:  This section will have to be rewritten if
				 * secret doors can be jammed or locked as well. */
    if (!square_islockeddoor(c, grid)) {
     /* It usually takes two turns to open a door
					 * and move into the doorway. */
     return move_chance;
    } else if (rf_has(mon->race->flags, RF_UNLOCK_DOOR)) {
     /* Lock difficulty (power + 5) */
     int difficulty = square_door_lock_power(c, grid) + 5;
     /* Unlocking skill equals monster perception */
     int skill = monster_skill(mon, SKILL_PERCEPTION);
     /* We ignore the fact that it takes extra time to
					 * open the door and walk into the entranceway. */
     unlock_chance = success_chance(10, skill, difficulty);
    }
   }
   /* Monster can bash doors */
   if (rf_has(mon->race->flags, RF_BASH_DOOR)) {
    /* Door difficulty (power + 2)
				 * Just because a door is difficult to unlock
				 * shouldn't mean that it's hard to bash.  Until the
				 * character door bashing code is changed, however,
				 * we'll stick with this.
				 */
    int difficulty = square_islockeddoor(c, grid) ?
     square_door_lock_power(c, grid) :
     square_door_jam_power(c, grid);
    /* Calculate bashing ability (ie effective strength) */
    int skill = monster_stat(mon, STAT_STR) * 2;
    /* Note that monsters "fall" into the entranceway in the same
				 * turn that they bash the door down. */
    bash_chance = success_chance(10, skill, difficulty);
   }
   /* A monster cannot both bash and unlock a door in the same
			 * turn.  It needs to pick one of the two methods to use. */
   if ((unlock_chance > bash_chance) || (bash_chance == 0)) {
    *bash = false;
   } else {
    *bash = true;
   }
   return MIN(move_chance, MAX(unlock_chance, bash_chance));
  }
  /* Any grid that isn't explicitly made passable is impassable. */
  return 0;
 }
}
/**
 * Counts the number of monsters adjacent to a given square
 */
int adj_mon_count(struct loc grid)
{
 int d, count = 0;
 for (d = 0; d < 8; d++) {
  if (square_monster(cave, loc_sum(grid, ddgrid_ddd[d]))) {
   count++;
  }
 }
 return count;
}
/**
 * The square of the distance between two points.
 *
 * Used when we need a fine-grained ordering of euclidean distance.
 * e.g. helps an archer who is stuck against a wall to find his way out.
 */
static int distance_squared(struct loc grid1, struct loc grid2)
{
 int y_diff = grid1.y - grid2.y;
 int x_diff = grid1.x - grid2.x;
 return y_diff * y_diff + x_diff * x_diff;
}
/**
 * ------------------------------------------------------------------------
 * Monster wandering and alertness
 * Also other diverse things, need to re-org
 * ------------------------------------------------------------------------ */
/**
 * Calculate minimum and desired combat ranges.  -BR-
 *
 * Afraid monsters will set this to their maximum flight distance.
 * Currently this is recalculated every turn - if it becomes a significant
 * overhead it could be calculated only when something has changed (monster HP,
 * chance of escaping, etc)
 */
static void monster_find_range(struct monster *mon)
{
 /* Monsters will run up to z_info->flee_range grids out of sight */
 int flee_range = MIN(z_info->max_sight + z_info->flee_range, 255);
 /* All "afraid" monsters will run away */
 if (mon->stance == STANCE_FLEEING) {
  mon->min_range = flee_range;
 } else {
  /* Other monsters default to range 1 */
  mon->min_range = 1;
  /* Creatures that don't move never like to get too close */
  if (rf_has(mon->race->flags, RF_NEVER_MOVE)) {
   mon->min_range += 3;
  }
  /* Spies have a high minimum range */
  if (rf_has(mon->race->flags, RF_SMART) &&
   rsf_has(mon->race->spell_flags, RSF_SHRIEK) &&
   (mon->stance != STANCE_AGGRESSIVE)) {
   mon->min_range = 10;
  }
 }
 /* Nearby monsters won't run away */
 if ((mon->cdis < z_info->turn_range) &&
  (mon->mspeed < player->state.speed)) {
  mon->min_range = 1;
 }
 /* Now find preferred range */
 mon->best_range = mon->min_range;
 /* Breathers like range 2 */
 if ((mon->race->freq_ranged > 15) && !rf_has(mon->race->flags, RF_QUESTOR)){
  if (monster_breathes(mon) && (mon->best_range < 6)) {
   mon->best_range = 2;
  } else if (mon->mana >= z_info->mana_max / 5) {
   /* Specialized ranged attackers will sit back */
   mon->best_range = MAX(1, MIN(8, mon->best_range +
    (mon->race->freq_ranged - 15) / 5));
   mon->min_range = MAX(1, mon->best_range - 1);
  }
 }
 /* Deal with the 'truce' on Morgoth's level (overrides everything else) */
 if (player->truce && (mon->min_range < 5)) {
  mon->min_range = 5;
  mon->best_range = 5;
 }
}
/**
 * Determine whether a monster is active or passive
 */
static bool monster_check_active(struct monster *mon)
{
 /* Monsters with targets are all active */
 if (!loc_eq(mon->target.grid, loc(0, 0))) {
  return true;
 } else if (mon->stance == STANCE_FLEEING) {
  /* Monsters that are fleeing are active, so as to get far enough away */
  return true;
 } else if (rf_has(mon->race->flags, RF_QUESTOR) && player->on_the_run) {
  /* Morgoth is always active during the escape */
  return true;
 } else if ((mon->race->level > 17) && (player->depth == 0)) {
  /* Pursuing creatures are always active at the Gates */
  return true;
 } else if (rf_has(mon->race->flags, RF_SHORT_SIGHTED)) {
  /* Short sighted monsters are active when the player is *very* close */
  if (mon->cdis <= 2) return true;
 } else {
  /* Monsters that can see the player are active */
  if (los(cave, mon->grid, player->grid)) return true;
  /* Monsters that can hear the player are active */
  if (flow_dist(cave->player_noise, mon->grid) < 20) return true;
  /* Monsters that can smell the player are active */
  if (monster_can_smell(mon)) return true;
 }
 return false;
}
/**
 * Determine the next move for an unwary wandering monster
 */
static bool get_move_wander(struct monster *mon, struct loc *tgrid)
{
 struct loc grid1 = mon->grid, grid;
 struct monster_group *group = monster_group_by_index(cave,
               mon->group_info.index);
 struct monster_race *race = mon->race;
 bool random_move = false;
 bool no_move = false;
 int d;
    int dist;
 int closest = z_info->flow_max - 1;
 /* Deal with monsters that don't have a destination */
 if (loc_eq(group->flow.centre, loc(0, 0))) {
  /* Some monsters cannot move at all */
  if (rf_has(race->flags, RF_NEVER_MOVE)) {
   return false;
  } else if (rf_has(race->flags, RF_SHORT_SIGHTED) ||
       rf_has(race->flags, RF_HIDDEN_MOVE)) {
   /* Some just never wander */
   return false;
  } else {
   /* Many monsters can only make random moves */
   random_move = true;
  }
 } else {
  /* Deal with some special cases for monsters that have a destination */
  int group_size = monster_group_size(cave, mon);
  struct mon_group_list_entry *list_entry = group->member_list;
  int group_furthest = 0;
  int group_sleepers = 0;
  struct loc sleeper_grid = loc(0, 0);
  bitflag mask[RF_SIZE];
  bool hoarder = false;
        /* How far is the monster from its wandering destination? */
        dist = flow_dist(group->flow, grid1);
  /* Check out monsters in the same group */
  while (list_entry) {
   struct monster *mon1 = cave_monster(cave, list_entry->midx);
   if (mon1->alertness < ALERTNESS_UNWARY) {
    group_sleepers++;
    if (group_sleepers == 1) {
     sleeper_grid = mon1->grid;
    }
   }
   if (mon1->wandering_dist > group_furthest) {
    group_furthest = mon1->wandering_dist;
   }
   list_entry = list_entry->next;
  }
  /* No wandering on the Gates level */
  if (player->depth == 0) {
   return false;
  }
  /* No wandering in the throne room during the truce */
  if (player->truce) {
   return false;
  }
  /* Determine if the monster has a hoard */
  create_mon_flag_mask(mask, RFT_DROP, RFT_MAX);
  if (rf_is_inter(mon->race->flags, mask)) {
   hoarder = true;
  }
  /* Treasure-hoarding territorial monsters stay still at their hoard...*/
  if (rf_has(race->flags, RF_TERRITORIAL) && hoarder && (dist == 0)) {
   /* Very occasionally fall asleep */
   if (one_in_(100) && !in_tutorial() &&
     !rf_has(race->flags, RF_NO_SLEEP)) {
    set_alertness(mon, rand_range(ALERTNESS_MIN,
             ALERTNESS_UNWARY - 1));
   }
   return false;
  }
  /* If the destination is too far away, pick a new one */
  if (dist > z_info->wander_range) {
   monster_group_new_wandering_flow(cave, mon, loc(0, 0));
  }
  /* If the group is at the destination and not pausing, then start */
  if ((group->wandering_pause == 0) && (dist <= 0)) {
   group->wandering_pause = randint1(50) * group_size;
  } else if (group->wandering_pause > 1) {
   /* If the group is pausing, then decrease the pause counter */
   random_move = true;
   group->wandering_pause--;
  } else if (group->wandering_pause == 1) {
   /* If the group has finished pausing at an old destination,
			 * choose a new destination */
   monster_group_new_wandering_flow(cave, mon, loc(0, 0));
   group->wandering_pause--;
  }
  /* If the monster is not making progress */
  if (dist >= mon->wandering_dist) {
   /* Possibly pick a new destination */
   if (one_in_(20 * group_size)) {
    monster_group_new_wandering_flow(cave, mon, loc(0, 0));
   }
  }
  /* Sometimes delay to let others catch up */
  if (dist < group_furthest - group_size) {
   if (one_in_(2)) no_move = true;
  }
  /* Unwary monsters won't wander off while others are sleeping */
  if ((mon->alertness < ALERTNESS_ALERT) && (group_sleepers > 0)) {
   /* Only set the new flow if needed */
   if (!loc_eq(group->flow.centre, sleeper_grid)) {
    monster_group_new_wandering_flow(cave, mon, sleeper_grid);
   }
   if (one_in_(2)) random_move = true;
  }
  /* Non-territorial monsters in vaults move randomly */
  if (!rf_has(race->flags, RF_TERRITORIAL) &&
   square_isvault(cave, mon->grid)) {
   random_move = true;
  }
  /* Update the wandering_dist */
  group->dist = dist;
 }
 if (no_move) return false;
 /* Do a random move if needed */
 if (random_move) {
  /* Mostly stay still */
  if (!one_in_(4)) {
   return false;
  } else {
   /* Random direction */
   grid = loc_sum(grid1, ddgrid_ddd[randint0(8)]);
   /* Check Bounds */
   if (!square_in_bounds(cave, grid)) return false;
   /* Monsters in vaults shouldn't leave them */
   if (square_isvault(cave, mon->grid) &&
    !square_isvault(cave, grid)) return false;
   /* Save the location */
   *tgrid = grid;
  }
 } else {
  /* Smart monsters who are at the stairs they are aiming for
		 * leave the level */
  if (rf_has(race->flags, RF_SMART) &&
   !rf_has(race->flags, RF_TERRITORIAL) &&
   (player->depth != z_info->dun_depth) &&
   square_isstairs(cave, mon->grid) && (mon->wandering_dist == 0)) {
   if (monster_is_visible(mon)) {
    if (square_isdownstairs(cave, mon->grid)) {
     add_monster_message(mon, MON_MSG_GO_DOWN_STAIRS, true);
    } else {
     add_monster_message(mon, MON_MSG_GO_UP_STAIRS, true);
    }
   }
   /* Stop pausing to allow others to use the stairs */
   group->wandering_pause = 0;
   delete_monster(cave, mon->grid);
   return false;
  }
  /* Using flow information, check nearby grids, diagonals first. */
  for (d = 7; d >= 0; d--) {
   /* Get the location */
   grid = loc_sum(grid1, ddgrid_ddd[d]);
   /* Check Bounds */
   if (!square_in_bounds(cave, grid)) continue;
   dist = flow_dist(group->flow, grid);
   /* Ignore grids that are further than the current favourite */
   if (closest < dist) continue;
   /* Save the location */
   closest = dist;
   *tgrid = grid;
  }
  /* If no useful square to wander into was found, then abort */
  if (closest == z_info->flow_max - 1) {
   return false;
  }
 }
 /* Success */
 return true;
}
/**
 * ------------------------------------------------------------------------
 * Monster movement routines
 * These routines, culminating in get_move(), choose if and where a monster
 * will move on its turn
 * ------------------------------------------------------------------------ */
/**
 * "Do not be seen."
 *
 * Monsters in LOS that want to retreat are primarily interested in
 * finding a nearby place that the character can't see into.
 * Search for such a place with the lowest cost to get to up to 15
 * grids away.
 *
 * Look outward from the monster's current position in a square-
 * shaped search pattern.  Calculate the approximate cost in monster
 * turns to get to each passable grid, using a crude route finder.  Penal-
 * ize grids close to or approaching the character.  Ignore hiding places
 * with no safe exit.  Once a passable grid is found that the character
 * can't see, the code will continue to search a little while longer,
 * depending on how pricey the first option seemed to be.
 *
 * If the search is successful, the monster will target that grid,
 * and (barring various special cases) run for it until it gets there.
 *
 * We use a limited waypoint system (see function "get_route_to_target()"
 * to reduce the likelihood that monsters will get stuck at a wall between
 * them and their target (which is kinda embarrassing...).
 *
 * This function does not yield perfect results; it is known to fail
 * in cases where the previous code worked just fine.  The reason why
 * it is used is because its failures are less common and (usually)
 * less embarrassing than was the case before.  In particular, it makes
 * monsters great at not being seen.
 *
 * This function is fairly expensive.  Call it only when necessary.
 */
static bool get_move_find_safety(struct monster *mon, struct loc *tgrid)
{
 int i, j, d, x, y;
 int range = z_info->hide_range;
 int countdown = range;
 int least_cost = 100;
 struct loc least_cost_grid = loc(0, 0);
 int chance, cost, parent_cost;
 bool dummy;
 bool stair;
 /* Origin of the table as an actual dungeon grid */
 struct loc origin = loc_diff(loc(range, range), mon->grid);
 /* Allocate and initialize a table of movement costs.
	 * Both axes must be (2 * range + 1). */
 uint8_t **safe_cost;
 safe_cost = mem_zalloc((range * 2 + 1) * sizeof(uint8_t*));
 for (i = 0; i < range * 2 + 1; i++) {
  safe_cost[i] = mem_zalloc((range * 2 + 1) *
          sizeof(uint8_t));
 }
 /* Mark the origin */
 safe_cost[range][range] = 1;
 /* If the character's grid is in range, mark it as being off-limits */
 if ((ABS(mon->grid.y - player->grid.y) <= range) &&
     (ABS(mon->grid.x - player->grid.x) <= range)) {
  safe_cost[player->grid.y + origin.y][player->grid.x + origin.x] = 100;
 }
 /* Work outward from the monster's current position */
 for (d = 0; d < range; d++) {
  for (y = range - d; y <= range + d; y++) {
   for (x = range - d; x <= range + d; x++) {
    struct loc grid = loc(x, y);
    int x_tmp;
    /* Scan grids of top and bottom rows, just outline other rows */
    if ((y != range - d) && (y != range + d)) {
     if (x == range + d) {
      x_tmp = 999;
     } else {
      x_tmp = range + d;
     }
    } else {
     x_tmp = x + 1;
    }
    /* Grid and adjacent grids must be legal */
    if (!square_in_bounds_fully(cave, loc_diff(grid, origin))) {
     x = x_tmp;
     continue;
    }
    /* Grid is inaccessible (or at least very difficult to enter) */
    if ((safe_cost[y][x] == 0) || (safe_cost[y][x] >= 100)) {
     x = x_tmp;
     continue;
    }
    /* Get the accumulated cost to enter this grid */
    parent_cost = safe_cost[y][x];
    /* Scan all adjacent grids */
    for (i = 0; i < 8; i++) {
     struct loc grid1 = loc_sum(grid, ddgrid_ddd[i]);
     struct loc actual = loc_diff(grid1, origin);
     /* Check bounds */
     if ((grid1.y < 0) || (grid1.y > range*2) ||
      (grid1.x < 0) || (grid1.x > range*2)) continue;
     /* Handle grids with empty cost and passable grids
					 * with costs we have a chance of beating. */
     if ((safe_cost[grid1.y][grid1.x] == 0) ||
      ((safe_cost[grid1.y][grid1.x] > parent_cost + 1) &&
       (safe_cost[grid1.y][grid1.x] < 100))) {
      /* Get the cost to enter this grid */
      chance = monster_entry_chance(cave, mon, actual,&dummy);
      /* Impassable */
      if (!chance) {
       /* Cannot enter this grid */
       safe_cost[grid1.y][grid1.x] = 100;
       continue;
      }
      /* Calculate approximate cost (in monster turns) */
      cost = 100 / chance;
      /* Next to character */
      if (distance(actual, player->grid)
       <= 1) {
       /* Don't want to maneuver next to the character */
       cost += 3;
      }
      /* Mark this grid with a cost value */
      safe_cost[grid1.y][grid1.x] = parent_cost + cost;
      /* Check if it is a stair and the monster can use it */
      stair = square_isstairs(cave, actual) &&
       rf_has(mon->race->flags, RF_SMART) &&
       !rf_has(mon->race->flags, RF_TERRITORIAL);
      /* Character can't see this grid, or it is a stair... */
      if (!square_isview(cave, actual) || stair) {
       int this_cost = safe_cost[grid1.y][grid1.x];
       /* Penalize grids that approach character */
       if (ABS(player->grid.y - actual.y) <
           ABS(mon->grid.y - actual.y)) {
        this_cost *= 2;
       }
       if (ABS(player->grid.x - actual.x) <
           ABS(mon->grid.x - actual.x)) {
        this_cost *= 2;
       }
       /* Value stairs very highly */
       if (stair) {
        this_cost /= 2;
       }
       /* Accept lower-cost, sometimes accept same-cost
							 * options */
       if ((least_cost > this_cost) ||
           ((least_cost == this_cost) && one_in_(2))) {
        bool has_escape = false;
        /* Scan all adjacent grids for escape routes */
        for (j = 0; j < 8; j++) {
         /* Calculate real adjacent grids */
         struct loc grid2 = loc_sum(actual,
                  ddgrid_ddd[i]);
         /* Check bounds */
         if (!square_in_bounds(cave, grid2))
          continue;
         /* Take any passable grid not in LOS */
         if (!square_isview(cave, grid2) &&
             monster_entry_chance(cave, mon, grid2,
                &dummy)) {
          /* Not a one-grid cul-de-sac */
          has_escape = true;
          break;
         }
        }
        /* Ignore cul-de-sacs other than stairs */
        if ((has_escape == false) && !stair) continue;
        least_cost = this_cost;
        least_cost_grid = grid1;
        /* Look hard for alternative hiding places if
								 * this one seems pricey. */
        countdown = 1 + least_cost - d;
       }
      }
     }
    }
    /* Adjust x as instructed */
    x = x_tmp;
   }
  }
  /* We found a good place a while ago, and haven't done better
		 * since, so we're probably done. */
  if (countdown-- <= 0) break;
 }
 /* Free memory */
 for (i = 0; i < range * 2 + 1; i++) {
  mem_free(safe_cost[i]);
 }
 mem_free(safe_cost);
 /* We found a place that can be reached in reasonable time */
 if (least_cost < 50) {
  /* Convert to actual dungeon grid. */
  struct loc grid = loc_diff(least_cost_grid, origin);
  /* Move towards the hiding place */
  *tgrid = grid;
  /* Target the hiding place */
  mon->target.grid = grid;
  return true;
 }
 /* No good place found */
 return false;
}
/**
 * Helper function for monsters that want to retreat from the character.
 * Used for any monster that is terrified, frightened, is looking for a
 * temporary hiding spot, or just wants to open up some space between it
 * and the character.
 *
 * If the monster is well away from danger, let it relax.
 * If the monster's current target is not in LOS, use it (+).
 * If the monster is not in LOS, and cannot pass through walls, try to
 * use flow (noise) information.
 * If the monster is in LOS, even if it can pass through walls,
 * search for a hiding place (helper function "find_safety()").
 * If no hiding place is found, and there seems no way out, go down
 * fighting.
 *
 * If none of the above solves the problem, run away blindly.
 *
 * (+) There is one exception to the automatic usage of a target.  If the
 * target is only out of LOS because of "knight's move" rules (distance
 * along one axis is 2, and along the other, 1), then the monster will try
 * to find another adjacent grid that is out of sight.  What all this boils
 * down to is that monsters can now run around corners properly!
 *
 * Return true if the monster did actually want to do anything.
 */
static bool get_move_retreat(struct monster *mon, struct loc *tgrid)
{
 struct monster_race *race = mon->race;
 int i;
 struct loc grid;
 bool dummy;
 /* If it can call for help, then it might */
 if (rf_has(race->spell_flags, RSF_SHRIEK) &&
  (randint0(100) < race->freq_ranged)) {
  do_mon_spell(RSF_SHRIEK, mon, square_isview(cave, mon->grid));
  return false;
 }
 /* If the monster is well away from danger, let it relax. */
 if (mon->cdis >= z_info->flee_range) {
  return false;
 }
 /* Intelligent monsters that are fleeing can try to use stairs */
 if (rf_has(race->flags, RF_SMART) && !rf_has(race->flags, RF_TERRITORIAL) &&
  (mon->stance == STANCE_FLEEING)) {
  if (square_isstairs(cave, mon->grid)) {
   *tgrid = mon->grid;
   return true;
  }
  /* Check for adjacent stairs and move towards one */
  for (i = 0; i < 8; i++) {
   grid = loc_sum(mon->grid, ddgrid_ddd[i]);
   /* Check for (accessible) stairs */
   if (square_isstairs(cave, grid) &&
    (monster_entry_chance(cave, mon, grid, &dummy) > 0) &&
    !square_isplayer(cave, grid)) {
    *tgrid = grid;
    return true;
   }
  }
 }
 /* Monsters that like ranged attacks a lot (e.g. archers) try to stay
	 * in good shooting locations */
 if (race->freq_ranged >= 50) {
  int start = randint0(8);
  bool acceptable = false;
  int best_score = 0;
  struct loc best_grid = mon->grid;
  int dist;
  /* The 'score to beat' as the score for the monster's current square */
  dist = distance_squared(mon->grid, player->grid);
  best_score += dist;
  if (projectable(cave, mon->grid, player->grid, PROJECT_STOP) &&
   (mon->cdis > 1)) {
   best_score += 100;
  }
  /* The position is only acceptable if it isn't adjacent to the player */
  if (mon->cdis > 1) acceptable = true;
  /* Set the hacky path ignore variable so that the project_path()
		 * function doesn't consider the monster's current location to
		 * block line of fire. */
  cave->project_path_ignore = mon->grid;
  /* Look for adjacent shooting places */
  for (i = start; i < 8 + start; i++) {
   int score = 0;
   grid = loc_sum(mon->grid, ddgrid_ddd[i % 8]);
   dist = distance_squared(grid, player->grid);
   /* Check Bounds */
   if (!square_in_bounds(cave, grid)) continue;
   /* Skip the player's square */
   if (square_isplayer(cave, grid)) continue;
   /* Grid must be pretty easy to enter */
   if (monster_entry_chance(cave, mon, grid, &dummy) < 50) continue;
   /* Skip adjacent squares */
   if (distance(grid, player->grid) == 1) continue;
   /* Any position non-adjacent to the player will be acceptable */
   acceptable = true;
   /* Reward distance from player */
   score += dist;
   /* Reward having a shot at the player */
   if (projectable(cave, grid, player->grid, PROJECT_STOP)) {
    score += 100;
   }
   if (score > best_score) {
    best_score = score;
    best_grid = grid;
   }
  }
  /* Unset the hacky path ignore variable so that the project_path()
		 * function didn't consider the monster's current location to
		 * block line of fire. */
  cave->project_path_ignore = loc(0, 0);
  if (acceptable) {
   *tgrid = best_grid;
   /* Success */
   return true;
  } else if ((mon->stance != STANCE_FLEEING) &&
       !rf_has(race->flags, RF_UNIQUE) &&
       monster_is_visible(mon)) {
   /* This step is artificial stupidity for archers and other serious
			 * ranged weapon users.  They only evade you properly near walls
			 * if they are: afraid or uniques or invisible.
			 * Otherwise things are a bit too annoying */
   return false;
  }
 }
 /* Monster has a target */
 if (!loc_eq(mon->target.grid, loc(0, 0))) {
  /* It's out of LOS; keep using it, except in "knight's move" cases */
  if (!square_isview(cave, mon->target.grid)) {
   /* Get axis distance from character to current target */
   int dist_y = ABS(player->grid.y - mon->target.grid.y);
   int dist_x = ABS(player->grid.x - mon->target.grid.x);
   /* It's only out of LOS because of "knight's move" rules */
   if (((dist_y == 2) && (dist_x == 1)) ||
    ((dist_y == 1) && (dist_x == 2))) {
    /* If there is another grid adjacent to the monster that
				 * the character cannot see into, and it isn't any harder
				 * to enter, use it instead.  Prefer diagonals. */
    for (i = 7; i >= 0; i--) {
     grid = loc_sum(mon->grid, ddgrid_ddd[i]);
     /* Check Bounds */
     if (!square_in_bounds(cave, grid)) continue;
     if (square_isview(cave, grid)) continue;
     if (loc_eq(grid, mon->target.grid)) continue;
     if (monster_entry_chance(cave, mon, mon->target.grid,
            &dummy) >
         monster_entry_chance(cave, mon, grid, &dummy)) continue;
     mon->target.grid = grid;
     break;
    }
   }
   /* Move towards the target */
   *tgrid = mon->target.grid;
   return true;
  } else if (!square_isstairs(cave, mon->target.grid)) {
   /* It's in LOS, but not a stair; cancel it. */
   mon->target.grid = loc(0, 0);
  }
 }
 /* The monster is not in LOS, but thinks it's still too close. */
 if (!square_isview(cave, mon->grid)) {
        /* Run away from noise */
        if (flow_dist(mon->flow, mon->grid) < z_info->flow_max) {
   bool done = false;
            /* Look at adjacent grids, diagonals first */
            for (i = 7; i >= 0; i--) {
    grid = loc_sum(mon->grid, ddgrid_ddd[i]);
                /* Check bounds */
                if (!square_in_bounds(cave, grid)) continue;
                /* Accept the first non-visible grid with a higher cost */
                if (flow_dist(mon->flow, grid) >
     flow_dist(mon->flow, mon->grid)) {
                    if (!square_isview(cave, grid)) {
                        *tgrid = grid;
                        done = true;
                        break;
                    }
                }
            }
            /* Return if successful */
            if (done) return true;
        }
  /* No flow info, or don't need it -- see bottom of function */
 } else {
  /* The monster is in line of sight. */
  int prev_dist = flow_dist(mon->flow, mon->grid);
  int start = randint0(8);
  /* Look for adjacent hiding places */
  for (i = start; i < 8 + start; i++) {
   grid = loc_sum(mon->grid, ddgrid_ddd[i % 8]);
   /* Check Bounds */
   if (!square_in_bounds(cave, grid)) continue;
   /* No grids in LOS */
   if (square_isview(cave, grid)) continue;
   /* Grid must be pretty easy to enter */
   if (monster_entry_chance(cave, mon, grid, &dummy) < 50) continue;
   /* Accept any grid that doesn't have a lower flow (noise) cost. */
   if (flow_dist(mon->flow, grid) >= prev_dist) {
    *tgrid = grid;
    /* Success */
    return true;
   }
  }
  /* Find a nearby grid not in LOS of the character. */
  if (get_move_find_safety(mon, tgrid) == true) return true;
  /* No safe place found; a monster in LOS and close will turn to fight */
  if (square_isview(cave, mon->grid) &&
      ((mon->cdis < z_info->turn_range) ||
    (mon->mspeed < player->state.speed)) &&
   !player->truce && (race->freq_ranged < 50)) {
   /* Message if visible */
   if (monster_is_visible(mon)) {
    /* Dump a message */
    add_monster_message(mon, MON_MSG_PANIC, true);
   }
            /* Boost morale and make the monster aggressive */
            mon->tmp_morale = MAX(mon->tmp_morale + 60, 60);
            calc_morale(mon);
            calc_stance(mon);
            mflag_on(mon->mflag, MFLAG_AGGRESSIVE);
   return true;
  }
 }
 /* Move directly away from character. */
 *tgrid = loc_diff(mon->grid, loc_diff(player->grid, mon->grid));
 /* We want to run away */
 return true;
}
/**
 * Helper function for monsters that want to advance toward the character.
 * Assumes that the monster isn't frightened, and is not in LOS of the
 * character.
 *
 * Ghosts and rock-eaters do not use flow information, because they
 * can - in general - move directly towards the character.  We could make
 * them look for a grid at their preferred range, but the character
 * would then be able to avoid them better (it might also be a little
 * hard on those poor warriors...).
 *
 * Other monsters will use target information, then their ears, then their
 * noses (if they can), and advance blindly if nothing else works.
 *
 * When flowing, monsters prefer non-diagonal directions.
 *
 * XXX - At present, this function does not handle difficult terrain
 * intelligently.  Monsters using flow may bang right into a door that
 * they can't handle.  Fixing this may require code to set monster
 * paths.
 */
static void get_move_advance(struct monster *mon, struct loc *tgrid)
{
 int i;
  int closest = z_info->flow_max;
 bool can_use_scent = false;
 struct monster_lore *lore = get_lore(mon->race);
 /* Some monsters don't try to pursue when out of sight */
 if (rf_has(mon->race->flags, RF_TERRITORIAL) &&
  !los(cave, player->grid, mon->grid)) {
  *tgrid = mon->grid;
        /* Remember that the monster behaves like this */
  rf_on(lore->flags, RF_TERRITORIAL);
  /* Sometimes become unwary and wander back to its lair */
  if (one_in_(10) && (mon->alertness >= ALERTNESS_ALERT)) {
   set_alertness(mon, mon->alertness - 1);
  }
  return;
 }
 /* Use target information if available */
 if (!loc_eq(mon->target.grid, loc(0, 0))) {
  *tgrid = mon->target.grid;
  return;
 }
 /* If we can't hear noises */
 if (flow_dist(mon->flow, mon->grid) >= z_info->flow_max) {
  /* Otherwise, try to follow a scent trail */
  if (monster_can_smell(mon)) {
   can_use_scent = true;
  } else {
   /* Sight but no sound means blocked by a chasm, get out of there! */
   if (los(cave, mon->grid, player->grid)) {
    get_move_retreat(mon, tgrid);
    return;
   } else {
    /* No sound, no scent, no sight: advance blindly */
    *tgrid = player->grid;
    return;
   }
  }
 }
 /* Using flow information.  Check nearby grids, diagonals first. */
 for (i = 7; i >= 0; i--) {
  /* Get the location */
  struct loc grid = loc_sum(mon->grid, ddgrid_ddd[i]);
  /* Check Bounds */
  if (!square_in_bounds(cave, grid)) continue;
  /* We're following a scent trail */
  if (can_use_scent) {
   int age = get_scent(cave, grid);
   if (age == -1) continue;
   /* Accept younger scent */
   if (closest < age) continue;
   closest = age;
  } else {
   /* We're using sound */
   int dist = flow_dist(mon->flow, grid);
   /* Accept louder sounds */
   if (closest < dist) continue;
   closest = dist;
  }
  /* Save the location */
  *tgrid = grid;
 }
}
/**
 * This determines how vulnerable the player is to monster attacks
 * It combines elements for available spaces to attack from and for
 * the player's condition and other monsters attacking
 *
 * I'm sure it could be further improved
 */
static int get_move_calc_vulnerability(struct loc mgrid)
{
 struct loc pgrid = player->grid;
 int vulnerability = 0;
    /* Determine the main direction from the player to the monster */
    int dir = rough_direction(pgrid, mgrid);
    /* Extract the deltas from the direction */
    int dy = ddy[dir];
    int dx = ddx[dir];
 /* If monster in an orthogonal direction   753
	 *                                         8@1 m
	 *                                         642 */
 if (dy * dx == 0) {
  int i;
  /* Note array indices are one less than the diagram directions */
  struct loc grid[8] = { loc_sum(pgrid, loc(dx, dy)),
          loc_sum(pgrid, loc(dx - dy, dx + dy)),
          loc_sum(pgrid, loc(dx + dy, dy - dx)),
          loc_sum(pgrid, loc(-dy, dx)),
          loc_sum(pgrid, loc(dy, -dx)),
          loc_sum(pgrid, loc(-dx - dy, dx - dy)),
          loc_sum(pgrid, loc(dy - dx, -dx - dy)),
          loc_sum(pgrid, loc(-dx, -dy))};
  /* Increase vulnerability for each open square towards the monster */
  for (i = 0; i < 5; i++) {
   if (square_isprojectable(cave, grid[i])) vulnerability++;
  }
  /* Increase for monsters already engaged with the player
		 * (but not the one directly between)... */
  for (i = 1; i < 5; i++) {
   if (square_monster(cave, grid[i])) vulnerability++;
  }
  /* ...especially if they are behind the player */
  for (i = 5; i < 8; i++) {
   if (square_monster(cave, grid[i])) vulnerability += 2;
  }
 } else {
  /* If monster in a diagonal direction   875 
		 *                                      6@3 
		 *                                      421 
		 *                                          m */
  int i;
  /* Note array indices are one less than the diagram directions */
  struct loc grid[8] = { loc_sum(pgrid, loc(dx, dy)),
          loc_sum(pgrid, loc(0, dy)),
          loc_sum(pgrid, loc(dx, 0)),
          loc_sum(pgrid, loc(-dy, dx)),
          loc_sum(pgrid, loc(dy, -dx)),
          loc_sum(pgrid, loc(0, -dy)),
          loc_sum(pgrid, loc(-dx, 0)),
          loc_sum(pgrid, loc(-dx, -dy))};
  /* Increase vulnerability for each open square towards the monster */
  for (i = 0; i < 5; i++) {
   if (square_isprojectable(cave, grid[i])) vulnerability++;
  }
  /* Increase for monsters already engaged with the player
		 * (but not the one directly between)... */
  for (i = 1; i < 5; i++) {
   if (square_monster(cave, grid[i])) vulnerability++;
  }
  /* ...especially if they are behind the player */
  for (i = 5; i < 8; i++) {
   if (square_monster(cave, grid[i])) vulnerability += 2;
  }
 }
 /* Take player's health into account */
 switch (health_level(player->chp, player->mhp)) {
  case HEALTH_WOUNDED: vulnerability += 1; break; /* <= 75% health */
  case HEALTH_BADLY_WOUNDED:vulnerability += 1; break;/* <= 50% health */
  case HEALTH_ALMOST_DEAD: vulnerability += 2; break; /* <= 25% health */
 }
 /* Take player's conditions into account */
 if (player->timed[TMD_BLIND] || player->timed[TMD_IMAGE] ||
  player->timed[TMD_CONFUSED] || player->timed[TMD_AFRAID] ||
  player->timed[TMD_ENTRANCED] || (player->timed[TMD_STUN] > 50) ||
  player->timed[TMD_SLOW]) {
  vulnerability += 2;
 }
 return vulnerability;
}
/**
 * This determines how hesitant the monster is to attack.
 * If the hesitance is lower than the player's vulnerability, it will attack
 *
 * The main way to gain hesitance is to have similar smart monsters who could
 * gang up if they waited for the player to get into the open.
 */
static int get_move_calc_hesitance(struct monster *mon)
{
 int x, y;
 int hesitance = 1;
 /* Gain hesitance for up to one nearby similar monster
	 * who isn't yet engaged in combat */
 for (y = -5; y <= +5; y++) {
  for (x = -5; x <= +5; x++) {
   struct loc grid = loc_sum(mon->grid, loc(x, y));
   if (!loc_eq(grid, mon->grid) && square_in_bounds(cave, grid)) {
    struct monster *mon1 = square_monster(cave, grid);
    if (mon1 && similar_monsters(mon, mon1) &&
     (distance(grid, player->grid) > 1) && (hesitance < 2)) {
     hesitance++;
    }
   }
  }
 }
 /* Archers should be slightly more hesitant as they are
	 * in an excellent situation */
 if ((mon->race->freq_ranged > 30) && (hesitance == 2)) {
  hesitance++;
 }
 return hesitance;
}
/**
 * Choose the probable best direction for a monster to move in.  This
 * is done by choosing a target grid and then finding the direction that
 * best approaches it.
 *
 * Monsters that cannot move always attack if possible.
 * Frightened monsters retreat.
 * Monsters adjacent to the character attack if possible.
 *
 * Monster packs lure the character into open ground and then leap
 * upon him.  Monster groups try to surround the character.  -KJ-
 *
 * Monsters not in LOS always advance (this avoids player frustration).
 * Monsters in LOS will advance to the character, up to their standard
 * combat range, to a grid that allows them to target the character, or
 * just stay still if they are happy where they are, depending on the
 * tactical situation and the monster's preferred and minimum combat
 * ranges.
 * NOTE:  Here is an area that would benefit from more development work.
 *
 * Non-trivial movement calculations are performed by the helper
 * functions get_move_advance() and get_move_retreat(), which keeps
 * this function relatively simple.
 *
 * The variable "must_use_target" is used for monsters that can't
 * currently perceive the character, but have a known target to move
 * towards.  With a bit more work, this will lead to semi-realistic
 * "hunting" behavior.
 *
 * Return false if monster doesn't want to move or can't.
 */
static bool get_move(struct monster *mon, struct loc *tgrid, bool *fear,
      bool must_use_target)
{
 struct monster_race *race = mon->race;
 struct monster_lore *lore = get_lore(race);
 int i, start;
 struct loc grid;
 /* Assume no movement */
 *tgrid = mon->grid;
 /* Some monsters will not move into sight of the player. */
 if (rf_has(race->flags, RF_HIDDEN_MOVE) &&
   (square_isseen(cave, mon->grid) ||
    square_seen_by_keen_senses(cave, mon->grid))) {
  /* Memorize lack of moves after a while. */
  if (monster_is_visible(mon) && one_in_(50)) {
   rf_on(lore->flags, RF_HIDDEN_MOVE);
  }
  /* If we are in sight, do not move */
  return false;
 }
 /* Morgoth will not move during the 'truce' */
 if (rf_has(race->flags, RF_QUESTOR) && player->truce) {
  return false;
 }
    /* Worm masses, nameless things and the like won't deliberately move
	 * towards the player if she is too far away */
 if (rf_has(race->flags, RF_MINDLESS) &&
  rf_has(race->flags, RF_TERRITORIAL) && (mon->cdis > 5)) {
  return false;
 }
 /* Monsters that cannot move will attack the character if he is
	 * adjacent.  Otherwise, they cannot move. */
 if (rf_has(race->flags, RF_NEVER_MOVE)) {
  /* Hack -- memorize lack of moves after a while. */
  if (monster_is_visible(mon) && one_in_(20)) {
   rf_on(lore->flags, RF_NEVER_MOVE);
  }
  /* Is character in range? */
  if (mon->cdis <= 1) {
   /* Kill. */
   *fear = false;
   *tgrid = player->grid;
   return true;
  }
  /* If we can't hit anything, do not move */
  return false;
 }
 /* Monster is only allowed to use targeting information. */
 if (must_use_target) {
  *tgrid = mon->target.grid;
  return true;
 }
 /* Is the monster scared? */
 *fear = ((mon->min_range >= z_info->flee_range) || (mon->stance == STANCE_FLEEING));
 /* Monster is frightened or terrified. */
 if (*fear) {
  /* The character is too close to avoid, and faster than we are */
  if ((mon->stance != STANCE_FLEEING) && (mon->cdis < z_info->turn_range)
   && (player->state.speed > mon->mspeed)) {
   /* Recalculate range */
   monster_find_range(mon);
   /* Note changes in monster attitude */
   if (mon->min_range < mon->cdis) {
    /* Cancel fear */
    *fear = false;
    /* Charge! */
    *tgrid = player->grid;
    return true;
   }
  } else if (mon->cdis < z_info->flee_range) {
   /* Find and move towards a hidey-hole */
   get_move_retreat(mon, tgrid);
   return true;
  } else {
   /* Monster is well away from danger, no need to move */
   return false;
  }
 }
 /* If far too close, step back towards the monster's minimum range */
 if (!*fear && (mon->cdis < mon->min_range - 2)) {
  if (get_move_retreat(mon, tgrid)) {
   *fear = true;
   return true;
  } else {
   /* No safe spot -- charge */
   *tgrid = player->grid;
  }
 }
 /* If the character is adjacent, back off, surround the player, or attack */
 if (!*fear && (mon->cdis <= 1)) {
  /* Smart monsters try harder to surround the player */
  if (rf_has(race->flags, RF_SMART)) {
   struct loc mgrid = mon->grid;
   int count = adj_mon_count(mgrid);
   int dy = player->grid.y - mon->grid.y;
   int dx = player->grid.x - mon->grid.x;
   start = randint0(8);
   /* Maybe move to a less crowded square near the player if we can */
   for (i = start; i < 8 + start; i++) {
    /* Pick squares near player */
    grid = loc_sum(player->grid, ddgrid_ddd[i % 8]);
    /* If also adjacent to monster */
    if (distance(mon->grid, grid) == 1) {
     /* if it is free... */
     if (square_ispassable(cave, grid) &&
      !square_monster(cave, grid)) {
      /* and has a lower count... */
      if ((adj_mon_count(grid) <= count) &&
       (rf_has(race->flags, RF_FLANKING) || one_in_(2))) {
       /* then maybe set it as a new target */
       *tgrid = grid;
       return true;
      }
     }
    }
   }
   /* If the monster didn't do that, check for end-corridor cases
			 * if player is in an orthogonal direction, eg:
			 *  X#A
			 *  Xo@
			 *  X#B */
   if (dy * dx == 0) {
    /* If walls on either side of monster (#) */
    struct loc wall1 = loc(mgrid.x + dy, mgrid.y + dx);
    struct loc wall2 = loc(mgrid.x - dy, mgrid.y - dx);
    if (!square_isprojectable(cave, wall1) &&
     !square_isprojectable(cave, wall2)) {
     /* If there is a monster in 1 of the 3 squares behind (X) */
     struct loc grid1 = loc_diff(wall1, loc(dx, dy));
     struct loc grid2 = loc_diff(mgrid, loc(dx, dy));
     struct loc grid3 = loc_diff(wall2, loc(dx, dy));
     struct loc grida = loc_sum(wall1, loc(dx, dy));
     struct loc gridb = loc_sum(wall2, loc(dx, dy));
     struct monster *mon1 = square_monster(cave, grid1);
     struct monster *mon2 = square_monster(cave, grid2);
     struct monster *mon3 = square_monster(cave, grid3);
     struct monster *mona = square_monster(cave, grida);
     struct monster *monb = square_monster(cave, gridb);
     if (mon1 || mon2 || mon3) {
      /* if 'A' and 'B' are free, go to one at random */
      if (!mona && !monb) {
       *tgrid = one_in_(2) ? grida : gridb;
       return true;
      } else if (!mona) {
       /* if 'A' is free, go there */
       *tgrid = grida;
       return true;
      } else if (!monb) {
       /* if 'B' is free, go there */
       *tgrid = gridb;
       return true;
      }
     }
    }
   } else {
    /* If player is in a diagonal direction, eg: 
				*  X#       XXX
				*  XoA  or  #o#
				*  X#@       A@ */
    struct loc gridn = loc_sum(mgrid, loc(0, -1));
    struct loc grids = loc_sum(mgrid, loc(0, 1));
    struct loc gride = loc_sum(mgrid, loc(1, 0));
    struct loc gridw = loc_sum(mgrid, loc(-1, 0));
    /* If walls north and south of monster ('#') */
    if (!square_isprojectable(cave, gridn) &&
     !square_isprojectable(cave, grids)) {
     /* If there is a monster in 1 of the 3 squares behind (X) */
     struct loc grid1 = loc_diff(mgrid, loc(dx, -1));
     struct loc grid2 = loc_diff(mgrid, loc(dx, 0));
     struct loc grid3 = loc_diff(mgrid, loc(dx, 1));
     struct loc grida = loc_sum(mgrid, loc(dx, 0));
     struct monster *mon1 = square_monster(cave, grid1);
     struct monster *mon2 = square_monster(cave, grid2);
     struct monster *mon3 = square_monster(cave, grid3);
     struct monster *mona = square_monster(cave, grida);
     if (mon1 || mon2 || mon3) {
      /* If 'A' is free, go there */
      if (!mona) {
       *tgrid = grida;
       return true;
      }
     }
    } else if (!square_isprojectable(cave, gride) &&
         !square_isprojectable(cave, gridw)) {
     /* If walls east and west of monster (#) and there is
					 * a monster in one of the three squares behind (X) */
     struct loc grid1 = loc_diff(mgrid, loc(-1, dy));
     struct loc grid2 = loc_diff(mgrid, loc(0, dy));
     struct loc grid3 = loc_diff(mgrid, loc(1, dy));
     struct loc grida = loc_sum(mgrid, loc(0, dy));
     struct monster *mon1 = square_monster(cave, grid1);
     struct monster *mon2 = square_monster(cave, grid2);
     struct monster *mon3 = square_monster(cave, grid3);
     struct monster *mona = square_monster(cave, grida);
     if (mon1 || mon2 || mon3) {
      /* If 'A' is free, go there */
      if (!mona) {
       *tgrid = grida;
       return true;
      }
     }
    }
   }
  }
  /* All other monsters attack. */
  *tgrid = player->grid;
  return true;
 }
 /* Smart monsters try to lure the character into the open. */
 if (!*fear && rf_has(race->flags, RF_SMART) &&
  !rf_has(race->flags, RF_PASS_WALL) &&
  !rf_has(race->flags, RF_KILL_WALL) &&
  (mon->stance == STANCE_CONFIDENT)) {
  /* Determine how vulnerable the player is */
  int vulnerability = get_move_calc_vulnerability(mon->grid);
  /* determine how hesitant the monster is */
  int hesitance = get_move_calc_hesitance(mon);
  /* Character is insufficiently vulnerable */
  if (vulnerability < hesitance) {
   /* Monster has to be willing to melee */
   if (mon->min_range == 1) {
    /* If we're in sight, find a hiding place */
    if (square_isseen(cave, mon->grid) ||
     square_isfire(cave, mon->grid)) {
     /* Find a safe spot to lurk in */
     if (get_move_retreat(mon, tgrid)) {
      *fear = true;
     } else {
      /* No safe spot -- charge */
      *tgrid = player->grid;
     }
    } else {
     /* Otherwise, we advance cautiously ... */
     get_move_advance(mon, tgrid);
     /* ... but make sure we stay hidden. */
     if (mon->cdis > 1) *fear = true;
    }
    /* Done */
    return true;
   } else if (square_isseen(cave, mon->grid) ||
        square_isfire(cave, mon->grid)) {
    /* Find a safe spot to lurk in */
    if (get_move_retreat(mon, tgrid)) {
     *fear = true;
    } else {
     /* No safe spot -- charge */
     *tgrid = player->grid;
    }
   }
  }
 }
 /* Monster groups try to surround the character */
 if ((!*fear) && (mon->cdis <= 3) && square_isview(cave, mon->grid) &&
  (rf_has(race->flags, RF_FRIENDS) || rf_has(race->flags, RF_FRIEND))) {
  /* Only if we do not have a clean path to player */
  if (projectable(cave, mon->grid, player->grid, PROJECT_CHCK)
   != PROJECT_PATH_CLEAR) {
   start = randint0(8);
   /* Find a random empty square next to the player to head for */
   for (i = start; i < 8 + start; i++) {
    /* Pick squares near player */
    grid = loc_sum(player->grid, ddgrid_ddd[i % 8]);
    /* Check Bounds */
    if (!square_in_bounds(cave, grid)) continue;
    /* Ignore occupied grids */
    if (square_monster(cave, grid)) continue;
    /* Ignore grids that monster can't enter immediately */
    if (!monster_can_exist(cave, mon, grid, false, true)) continue;
    /* Accept */
    *tgrid = grid;
    return true;
   }
  }
 }
 /* No special moves made -- use standard movement */
 if (!*fear) {
  /*
		 * XXX XXX -- The monster cannot see the character.  Make it
		 * advance, so the player can have fun ambushing it.
		 */
  if (!square_isview(cave, mon->grid)) {
   /* Advance */
   get_move_advance(mon, tgrid);
  } else {
   /* Always reset the monster's target */
   mon->target.grid = player->grid;
   /* Monsters too far away will advance. */
   if (mon->cdis > mon->best_range) {
    *tgrid = player->grid;
   } else if ((mon->cdis > mon->min_range) && one_in_(2)) {
    /* Monsters not too close will often advance */
    *tgrid = player->grid;
   } else if (!square_isfire(cave, mon->grid)) {
    /* Monsters that can't target the character will advance. */
    *tgrid = player->grid;
   } else {
    /* Otherwise they will stay still or move randomly. */
    if (rf_has(race->flags, RF_RAND_50) ||
     rf_has(race->flags, RF_RAND_25)) {
     /* Pick a random grid next to the monster */
     i = randint0(8);
     *tgrid = loc_sum(mon->grid, ddgrid_ddd[i]);
    }
    /* Monsters could look for better terrain... */
   }
            /* In most cases where the monster is targetting the player,
			 * use the clever pathfinding instead */
            if (loc_eq(*tgrid, player->grid)) {
                mon->target.grid = loc(0, 0);
                /* Advance */
                get_move_advance(mon, tgrid);
            }
  }
 } else {
  /* Back away -- try to be smart about it */
  get_move_retreat(mon, tgrid);
 }
 /* We do not want to move */
 if (loc_eq(*tgrid, mon->grid)) return false;
 /* We want to move */
 return true;
}
/**
 * ------------------------------------------------------------------------
 * make_move*()
 * ------------------------------------------------------------------------ */
/**
 * Choose the basic direction of movement, and whether to bias left or right
 * if the main direction is blocked.
 *
 * Note that the input is an offset to the monster's current position, and
 * the output direction is intended as an index into the side_dirs array.
 */
static int make_move_choose_direction(struct loc offset)
{
 int dir = 0;
 int dx = offset.x, dy = offset.y;
 /* Extract the "absolute distances" */
 int ay = ABS(dy);
 int ax = ABS(dx);
 /* We mostly want to move vertically */
 if (ay > (ax * 2)) {
  /* Choose between directions '8' and '2' */
  if (dy > 0) {
   /* We're heading down */
   dir = 2;
   if ((dx > 0) || (dx == 0 && turn % 2 == 0))
    dir += 10;
  } else {
   /* We're heading up */
   dir = 8;
   if ((dx < 0) || (dx == 0 && turn % 2 == 0))
    dir += 10;
  }
 }
 /* We mostly want to move horizontally */
 else if (ax > (ay * 2)) {
  /* Choose between directions '4' and '6' */
  if (dx > 0) {
   /* We're heading right */
   dir = 6;
   if ((dy < 0) || (dy == 0 && turn % 2 == 0))
    dir += 10;
  } else {
   /* We're heading left */
   dir = 4;
   if ((dy > 0) || (dy == 0 && turn % 2 == 0))
    dir += 10;
  }
 }
 /* We want to move down and sideways */
 else if (dy > 0) {
  /* Choose between directions '1' and '3' */
  if (dx > 0) {
   /* We're heading down and right */
   dir = 3;
   if ((ay < ax) || (ay == ax && turn % 2 == 0))
    dir += 10;
  } else {
   /* We're heading down and left */
   dir = 1;
   if ((ay > ax) || (ay == ax && turn % 2 == 0))
    dir += 10;
  }
 }
 /* We want to move up and sideways */
 else {
  /* Choose between directions '7' and '9' */
  if (dx > 0) {
   /* We're heading up and right */
   dir = 9;
   if ((ay > ax) || (ay == ax && turn % 2 == 0))
    dir += 10;
  } else {
   /* We're heading up and left */
   dir = 7;
   if ((ay < ax) || (ay == ax && turn % 2 == 0))
    dir += 10;
  }
 }
 return dir;
}
/**
 * A simple method to help fleeing monsters who are having trouble getting
 * to their target.  It's very stupid, but works fairly well in the
 * situations it is called upon to resolve.  XXX XXX
 *
 * If this function claims success, ty and tx must be set to a grid
 * adjacent to the monster.
 *
 * Return true if this function actually did any good.
 */
static bool make_move_get_route_to_target(struct monster *mon,
            struct loc *tgrid)
{
 int i, j;
 int dist_y, dist_x;
 struct loc grid, grid1, tar_grid = loc(0, 0);
 bool dummy;
 bool below = false;
 bool right = false;
 /* Is the target further away vertically or horizontally? */
 dist_y = ABS(mon->target.grid.y - mon->grid.y);
 dist_x = ABS(mon->target.grid.x - mon->grid.x);
 /* Target is further away vertically than horizontally */
 if (dist_y > dist_x) {
  /* Find out if the target is below the monster */
  if (mon->target.grid.y - mon->grid.y > 0) below = true;
  /* Search adjacent grids */
  for (i = 0; i < 8; i++) {
   grid = loc_sum(mon->grid, ddgrid_ddd[i]);
   /* Check bounds */
   if (!square_in_bounds_fully(cave, grid)) continue;
   /* Grid is not passable */
   if (!monster_entry_chance(cave, mon, grid, &dummy)) continue;
   /* Grid will take me further away */
   if ((below && (grid.y < mon->grid.y)) ||
    (!below && (grid.y > mon->grid.y))) {
    continue;
   } else if (grid.y == mon->grid.y) {
    /* Grid will not take me closer or further, see if it
				 * leads to better things */
    for (j = 0; j < 8; j++) {
     grid1 = loc_sum(grid, ddgrid_ddd[j]);
     /* Grid does lead to better things */
     if ((below && (grid1.y > mon->grid.y)) ||
      (!below && (grid1.y < mon->grid.y))) {
      /* But it is not passable */
      if (!monster_entry_chance(cave, mon, grid1, &dummy))
       continue;
      /* Accept (original) grid, but don't immediately claim
						 * success */
      tar_grid = grid;
     }
    }
   } else {
    /* Grid will take me closer, don't look this gift horse
				 * in the mouth. */
    *tgrid = grid;
    return true;
   }
  }
 } else if (dist_x > dist_y) {
  /* Target is further away horizontally than vertically,
		 * find out if the target is right of the monster */
  if (mon->target.grid.x - mon->grid.x > 0) right = true;
  /* Search adjacent grids */
  for (i = 0; i < 8; i++) {
   grid = loc_sum(mon->grid, ddgrid_ddd[i]);
   /* Check bounds */
   if (!square_in_bounds_fully(cave, grid)) continue;
   /* Grid is not passable */
   if (!monster_entry_chance(cave, mon, grid, &dummy)) continue;
   /* Grid will take me further away */
   if ((right && (grid.x < mon->grid.x)) ||
       (!right && (grid.x > mon->grid.x))) {
    continue;
   } else if (grid.x == mon->grid.x) {
    /* Grid will not take me closer or further, see if it
				 * leads to better things */
    for (j = 0; j < 8; j++) {
     grid1 = loc_sum(grid, ddgrid_ddd[j]);
     /* Grid does lead to better things */
     if ((right && (grid1.x > mon->grid.x)) ||
      (!right && (grid1.x < mon->grid.x))) {
      /* But it is not passable */
      if (!monster_entry_chance(cave, mon, grid1, &dummy))
       continue;
      /* Accept (original) grid, but don't immediately claim
						 * success */
      tar_grid = grid;
     }
    }
   } else {
    /* Grid will take me closer, don't look this gift horse
				 * in the mouth. */
    *tgrid = grid;
    return true;
   }
  }
 } else {
  /* Target is the same distance away along both axes. */
  /* XXX XXX - code something later to fill this hole. */
  return false;
 }
 /* If we found a solution, claim success */
 if (!loc_eq(tar_grid, loc(0, 0))) {
  *tgrid = tar_grid;
  return true;
 }
 /* No luck */
 return false;
}
/**
 * Confused monsters bang into walls and doors.  This function assumes that
 * the monster does not belong in this grid, and therefore should suffer for
 * trying to enter it.
 */
static void make_confused_move(struct monster *mon, struct loc grid)
{
 bool seen = monster_is_visible(mon) && square_isseen(cave, grid);
 /* Check Bounds (fully) */
 if (!square_in_bounds_fully(cave, grid)) return;
    /* Feature is a chasm */
    if (square_ischasm(cave, grid)) {
  /* The creature can't fly and the grid is empty */
        if (!rf_has(mon->race->flags, RF_FLYING) &&
   !square_monster(cave, grid)) {
            monster_swap(mon->grid, grid);
        }
    } else if (square_iswall(cave, grid)) {
  if (square_isdoor(cave, grid)) {
   if (seen)
    add_monster_message(mon, MON_MSG_STAGGER_DOOR, true);
  } else if (square_isrubble(cave, grid)) {
   if (seen)
    add_monster_message(mon, MON_MSG_STAGGER_RUBBLE, true);
  } else {
   if (seen)
    add_monster_message(mon, MON_MSG_STAGGER_WALL, true);
  }
  /* Possibly update the monster health bar */
  if (player->upkeep->health_who == mon)
   player->upkeep->redraw |= (PR_HEALTH);
 } else {
  /* No changes */
 }
}
/**
 * Given a target grid, calculate the grid the monster will actually
 * attempt to move into.
 *
 * The simplest case is when the target grid is adjacent to us and
 * able to be entered easily.  Usually, however, one or both of these
 * conditions don't hold, and we must pick an initial direction, than
 * look at several directions to find that most likely to be the best
 * choice.  If so, the monster needs to know the order in which to try
 * other directions on either side.  If there is no good logical reason
 * to prioritize one side over the other, the monster will act on the
 * "spur of the moment", using current turn as a randomizer.
 *
 * The monster then attempts to move into the grid.  If it fails, this
 * function returns false and the monster ends its turn.
 *
 * The variable "fear" is used to invoke any special rules for monsters
 * wanting to retreat rather than advance.  For example, such monsters
 * will not leave an non-viewable grid for a viewable one and will try
 * to avoid the character.
 *
 * The variable "bash" remembers whether a monster had to bash a door
 * or not.  This has to be remembered because the choice to bash is
 * made in a different function than the actual bash move.  XXX XXX  If
 * the number of such variables becomes greater, a structure to hold them
 * would look better than passing them around from function to function.
 */
static bool make_move(struct monster *mon, struct loc *tgrid, bool fear,
       bool *bash)
{
 int i, j;
 /* Start direction, current direction */
 int dir0, dir;
 /* Existing monster location, proposed new location */
 struct loc current = mon->grid, next;
 bool avoid = false;
 bool passable = false;
 bool look_again = false;
 int chance;
 /* Build a structure to hold movement data */
 static struct move_data {
  int move_chance;
  bool move_bash;
 } moves_data[8];
 /* Get the direction needed to get to the target */
 dir0 = make_move_choose_direction(loc_diff(*tgrid, current));
 /* If the monster wants to stay still... */
 if (loc_eq(*tgrid, mon->grid)) {
  /* If it is adjacent to the player, then just attack */
  if (mon->cdis == 1) {
   *tgrid = player->grid;
  } else {
   /* Otherwise just do nothing */
   return false;
  }
 }
 /* Apply monster confusion */
 if ((mon->m_timed[MON_TMD_CONF]) &&
  !rf_has(mon->race->flags, RF_NEVER_MOVE)) {
  /* Undo +10 modifiers */
  if (dir0 > 10) dir0 -= 10;
  /* Gives 3 chances to be turned left and 3 chances to be turned right
		 * leads to a binomial distribution of direction around the
		 * intended one:
		 * 15 20 15
		 *  6     6   (chances are all out of 64)
		 *  1  0  1 */
  i = damroll(3, 2) - damroll(3, 2);
  dir0 = cycle[chome[dir0] + i];
 }
 /* Is the target grid adjacent to the current monster's position? */
 if ((distance(*tgrid, current) <= 1) && !mon->m_timed[MON_TMD_CONF]) {
  /* If it is, try the shortcut of simply moving into the grid */
  chance = monster_entry_chance(cave, mon, *tgrid, bash);
  /* Grid must be pretty easy to enter */
  if (chance >= 50) {
   /* We can enter this grid */
   if ((chance >= 100) || (randint0(100) < chance)) {
    return true;
   } else {
    /* Failure to enter grid.  Cancel move */
    return false;
   }
  }
 }
 /* Now that we have an initial direction, we must determine which
	 * grid to actually move into.
	 * Scan each of the eight possible directions, in the order of
	 * priority given by the table "side_dirs", choosing the one that
	 * looks like it will get the monster to the character - or away
	 * from them - most effectively. */
 for (i = 0; i <= 8; i++) {
  /* Out of options */
  if (i == 8) break;
  /* Get the actual direction */
  dir = side_dirs[dir0][i];
  /* Get the grid in our chosen direction */
  next = loc_sum(current, ddgrid[dir]);
  /* Check Bounds */
  if (!square_in_bounds(cave, next)) continue;
  /* Store this grid's movement data. */
  moves_data[i].move_chance = monster_entry_chance(cave, mon, next, bash);
  moves_data[i].move_bash = *bash;
  /* Confused monsters must choose the first grid */
  if (mon->m_timed[MON_TMD_CONF]) break;
  /* If this grid is totally impassable, skip it */
  if (moves_data[i].move_chance == 0) continue;
  /* Frightened monsters work hard not to be seen. */
  if (fear) {
   /* Monster is having trouble navigating to its target. */
   if (!loc_eq(mon->target.grid, loc(0, 0)) && (i >= 2) &&
    (distance(mon->grid, mon->target.grid) > 1)) {
    /* Look for an adjacent grid leading to the target */
    if (make_move_get_route_to_target(mon, tgrid)) {
     /* Calculate the chance to enter the grid */
     chance = monster_entry_chance(cave, mon, *tgrid, bash);
     /* Try to move into the grid */
     if (randint0(100) < chance) {
      /* Can move */
      return true;
     }
     /* Can't move */
     return (false);
    } else if (i >= 3) {
     /* We can't get to our hiding place.  We're in line of fire.
					 * The only thing left to do is go down fighting. */
     if (monster_is_visible(mon) &&
      (square_isfire(cave, current)) &&
      !player->truce && (mon->race->freq_ranged < 50)) {
      /* Dump a message */
      add_monster_message(mon, MON_MSG_PANIC, true);
      /* Boost morale and make the monster aggressive */
      mon->tmp_morale = MAX(mon->tmp_morale + 60, 60);
      calc_morale(mon);
      calc_stance(mon);
      mflag_on(mon->mflag, MFLAG_AGGRESSIVE);
     }
    }
   }
   /* Attacking the character as a first choice? */
   if ((i == 0) && loc_eq(next, player->grid)) {
    /* Need to rethink some plans XXX XXX XXX */
    mon->target.grid = loc(0, 0);
   }
   /* Monster is visible */
   if (monster_is_visible(mon)) {
    /* And is in LOS */
    if (square_isview(cave, current)) {
     /* Accept any easily passable grid out of LOS */
     if ((!square_isview(cave, next)) &&
      (moves_data[i].move_chance > 40)) {
      break;
     }
    } else {
     /* Do not enter a grid in LOS */
     if (square_isview(cave, next)) {
      moves_data[i].move_chance = 0;
      continue;
     }
    }
   } else {
    /* Monster can't be seen, and is not in a "seen" grid. */
    if (!square_isview(cave, current)) {
     /* Do not enter a grid in LOS */
     if (square_isview(cave, next)) {
      moves_data[i].move_chance = 0;
      continue;
     }
    }
   }
  }
  /* XXX XXX -- Sometimes attempt to break glyphs. */
  if (square_iswarded(cave, next) && (!fear) && one_in_(5)) {
   break;
  }
  /* Initial direction is almost certainly the best one */
  if ((i == 0) && (moves_data[i].move_chance >= 80)) {
   /* If backing away and close, try not to walk next
			 * to the character, or get stuck fighting them. */
   if ((fear) && (mon->cdis <= 2) &&
    (distance(player->grid, next) <= 1)) {
    avoid = true;
   } else {
    break;
   }
  } else if (((i == 1) || (i == 2)) &&
       (moves_data[i].move_chance >= 50)) {
   /* Either of the first two side directions looks good */
   if ((moves_data[0].move_chance >= moves_data[i].move_chance)) {
    /* Accept the central direction if at least as good */
    if (avoid) {
     /* Frightened monsters try to avoid the character */
     if (distance(player->grid, next) == 0) {
      i = 0;
     }
    } else {
     i = 0;
    }
   }
   /* Accept this direction */
   break;
  }
  /* This is the first passable direction */
  if (!passable) {
   /* Note passable */
   passable = true;
   /* All the best directions are blocked. */
   if (i >= 3) {
    /* Settle for "good enough" */
    break;
   }
  }
  /* We haven't made a decision yet; look again. */
  if (i == 7) look_again = true;
 }
 /* We've exhausted all the easy answers. */
 if (look_again) {
  /* There are no passable directions. */
  if (!passable) {
   return false;
  }
  /* We can move. */
  for (j = 0; j < 8; j++) {
   /* Accept the first option, however poor.  XXX */
   if (moves_data[j].move_chance) {
    i = j;
    break;
   }
  }
 }
 /* If no direction was acceptable, end turn */
 if (i >= 8) {
  return false;
 }
 /* Get movement information (again) */
 dir = side_dirs[dir0][i];
 *bash = moves_data[i].move_bash;
 /* No good moves, so we just sit still and wait. */
 if ((dir == DIR_NONE) || (dir == DIR_UNKNOWN)) {
  return false;
 }
 /* Get grid to move into */
 *tgrid = loc_sum(current, ddgrid[dir]);
 /* Amusing messages and effects for confused monsters trying
	 * to enter terrain forbidden to them. */
 if (mon->m_timed[MON_TMD_CONF] && (moves_data[i].move_chance <= 25)) {
  /* Sometimes hurt the poor little critter */
  make_confused_move(mon, *tgrid);
  /* Do not actually move */
  if (!moves_data[i].move_chance) return false;
 }
 /* Try to move in the chosen direction.  If we fail, end turn. */
 if ((moves_data[i].move_chance < 100) &&
  (randint0(100) > moves_data[i].move_chance)) {
  return false;
 }
 /* Monster is frightened, and is obliged to fight. */
 if ((fear) && square_isplayer(cave, *tgrid) && !player->truce) {
  /* Message if visible */
  if (monster_is_visible(mon)) {
   /* Dump a message */
   add_monster_message(mon, MON_MSG_PANIC, true);
  }
  /* Boost morale and make the monster aggressive */
  mon->tmp_morale = MAX(mon->tmp_morale + 60, 60);
  calc_morale(mon);
  calc_stance(mon);
  mflag_on(mon->mflag, MFLAG_AGGRESSIVE);
 }
 /* We can move. */
 return true;
}
/**
 * ------------------------------------------------------------------------
 * process_move*()
 * ------------------------------------------------------------------------ */
/**
 * Deal with the monster Ability: exchange places
 */
static void process_move_exchange_places(struct monster *mon)
{
    struct monster_lore *lore = get_lore(mon->race);
    char m_name1[80];
    char m_name2[80];
 monster_desc(m_name1, sizeof(m_name1), mon, (MDESC_PRO_VIS | MDESC_OBJE));
    monster_desc(m_name2, sizeof(m_name2), mon, MDESC_PRO_VIS);
    /* Message */
 add_monster_message(mon, MON_MSG_EXCHANGE, true);
    /* Swap positions with the player */
    monster_swap(mon->grid, player->grid);
    /* Attack of opportunity */
    if (!player->timed[TMD_AFRAID] && !player->timed[TMD_ENTRANCED] &&
  (player->timed[TMD_STUN] <= 100)) {
        /* This might be the most complicated auto-grammatical message
		 * in the game... */
        msg("You attack %s as %s slips past.", m_name1, m_name2);
        py_attack_real(player, mon->grid, ATT_OPPORTUNITY);
    }
    /* Remember that the monster can do this */
    if (monster_is_visible(mon)) {
  rf_on(lore->flags, RF_EXCHANGE);
 }
    /* Set off traps etc */
 player_handle_post_move(player, true, true);
}
/**
 * If one monster moves into another monster's grid, they will
 * normally swap places.  If the second monster cannot exist in the
 * grid the first monster left, this can't happen.  In such cases,
 * the first monster tries to push the second out of the way.
 */
static bool process_move_push_aside(struct monster *mon, struct monster *mon1)
{
 int i, dir = 0;
 struct loc grid;
 /* Translate the difference between the locations of the two monsters
	 * into a direction of travel. */
 for (i = 0; i < 10; i++) {
  /* Require correct difference */
  if (!loc_eq(loc_diff(mon1->grid, mon->grid), ddgrid[i])) continue;
  /* Found the direction */
  dir = i;
  break;
 }
 /* Favor either the left or right side on the "spur of the moment". */
 if (one_in_(2)) dir += 10;
 /* Check all directions radiating out from the initial direction. */
 for (i = 0; i < 7; i++) {
  int side_dir = side_dirs[dir][i];
  grid = loc_sum(mon1->grid, ddgrid[side_dir]);
  /* Illegal grid */
  if (!square_in_bounds_fully(cave, grid)) continue;
  /* Grid is not occupied, and the 2nd monster can exist in it. */
  if (monster_can_exist(cave, mon1, grid, false, true)) {
   /* Push the 2nd monster into the empty grid. */
   monster_swap(mon1->grid, grid);
   return true;
  }
 }
 /* We didn't find any empty, legal grids */
 return false;
}
/**
 * Grab all objects from the grid.
 */
static void process_move_grab_objects(struct monster *mon, struct loc new)
{
 struct monster_lore *lore = get_lore(mon->race);
 struct object *obj = square_object(cave, new);
 bool visible = monster_is_visible(mon);
 char m_name[80];
 /*
	 * Don't allow item pickup or smashing in the tutorial:  items on the
	 * floor are likely specially placed and having them disappear
	 * because a monster happened by is inconvenient.
	 */
 if (in_tutorial()) {
  return;
 }
 /* Abort if can't pickup */
 if (!rf_has(mon->race->flags, RF_TAKE_ITEM)) return;
 /* Get the monster name/poss */
 monster_desc(m_name, sizeof(m_name), mon, MDESC_STANDARD);
 /* Take objects on the floor */
 obj = square_object(cave, new);
 while (obj) {
  char o_name[80];
  bool useless = obj_is_cursed(obj) || obj_is_broken(obj);
  struct object *next = obj->next;
  /* Get the object name */
  object_desc(o_name, sizeof(o_name), obj, ODESC_PREFIX | ODESC_FULL,
     player);
  /* Try to pick up */
  if (useless && visible && square_isview(cave, new)) {
   /* Dump a message */
   msg("%s looks at %s, but moves on.", m_name, o_name);
  } else {
   /* Make a copy so the original can remain as a placeholder if
			 * the player remembers seeing the object. */
   struct object *taken = object_new();
   /* Learn about item pickup behavior */
   rf_on(lore->flags, RF_TAKE_ITEM);
   object_copy(taken, obj);
   taken->oidx = 0;
   if (obj->known) {
    taken->known = object_new();
    object_copy(taken->known, obj->known);
    taken->known->oidx = 0;
    taken->known->grid = loc(0, 0);
   }
   /* Try to carry the copy */
   if (monster_carry(cave, mon, taken)) {
    /* Describe observable situations */
    if (square_isseen(cave, new) && !ignore_item_ok(player, obj)) {
     msg("%s picks up %s.", m_name, o_name);
    }
    /* Delete the object */
    square_delete_object(cave, new, obj, true, true);
   } else {
    if (taken->known) {
     object_delete(player->cave, NULL, &taken->known);
    }
    object_delete(cave, player->cave, &taken);
   }
  }
  /* Next object */
  obj = next;
 }
}
/**
 * Process a monster's move.
 *
 * All the plotting and planning has been done, and all this function
 * has to do is move the monster into the chosen grid.
 *
 * This may involve attacking the character, breaking a glyph of
 * warding, bashing down a door, etc..  Once in the grid, monsters may
 * stumble into monster traps, hit a scent trail, pick up or destroy
 * objects, and so forth.
 *
 * A monster's move may disturb the character, depending on which
 * disturbance options are set.
 */
static void process_move(struct monster *mon, struct loc tgrid, bool bash)
{
 struct monster_race *race = mon->race;
 struct monster_lore *lore = get_lore(race);
 /* Existing monster location, proposed new location */
 struct loc current = mon->grid, next = tgrid;
 /* Default move, default lack of view */
 bool do_move = true;
 bool do_view = false;
 /* Assume nothing */
    bool did_swap = false;
 bool did_pass_door = false;
 bool did_open_door = false;
 bool did_unlock_door = false;
 bool did_bash_door = false;
 bool did_pass_wall = false;
 bool did_kill_wall = false;
 bool did_tunnel_wall = false;
 /* Check Bounds */
 if (!square_in_bounds(cave, next)) return;
 /* Some monsters will not move into sight of the player. */
 if (rf_has(race->flags, RF_HIDDEN_MOVE) &&
     (square_isseen(cave, tgrid) ||
   square_seen_by_keen_senses(cave, tgrid))) {
  /* Hack -- memorize lack of moves after a while. */
  if (!rf_has(lore->flags, RF_HIDDEN_MOVE)) {
   if (monster_is_visible(mon) && (one_in_(50))) {
    rf_on(lore->flags, RF_HIDDEN_MOVE);
   }
  }
  /* If we are in sight, do not move */
  return;
 }
 /* The grid is occupied by the player. */
 if (square_isplayer(cave, next)) {
  /* Unalert monsters notice the player instead of attacking */
  if (mon->alertness < ALERTNESS_ALERT) {
   set_alertness(mon,rand_range(ALERTNESS_ALERT, ALERTNESS_ALERT + 5));
   /* We must unset this flag to avoid the monster missing *2* turns */
   mon->skip_next_turn = false;
  } else if (!player->truce) {
   /* Otherwise attack if possible */
            if (rf_has(race->flags, RF_EXCHANGE) && one_in_(4) &&
                (adj_mon_count(mon->grid) >= adj_mon_count(player->grid))) {
                process_move_exchange_places(mon);
            } else {
                (void)make_attack_normal(mon, player);
            }
  }
  /* End move */
  do_move = false;
 }
 /* Can still move */
 if (do_move) {
  /* Entering a wall */
  if (square_iswall(cave, next)) {
   /* Monster passes through walls (and doors) */
   if (rf_has(race->flags, RF_PASS_WALL)) {
    /* Monster went through a wall */
    did_pass_wall = true;
   } else if (rf_has(race->flags, RF_KILL_WALL)) {
    /* Monster destroys walls (and doors) */
    bool note = false;
    /* Noise distance depends on monster "dangerousness"  XXX */
    int noise_dist = 10;
    /* Note that the monster killed the wall */
    if (square_isview(cave, next)) {
     do_view = true;
     did_kill_wall = true;
    } else if (mon->cdis <= noise_dist) {
     /* Output warning messages if the racket gets too loud */
     note = true;
    }
    /* Grid is currently a door */
    if (square_isdoor(cave, next)) {
     square_set_feat(cave, next, FEAT_BROKEN);
     if (note) {
      /* Disturb the player */
      disturb(player, false);
      msg("You hear a door being smashed open.");
     }
     /* Monster noise */
     mon->noise += 10;
    } else {
     /* Grid is anything else */
     square_set_feat(cave, next, FEAT_FLOOR);
     if (note) {
      /* Disturb the player */
      disturb(player, false);
      msg("You hear grinding noises.");
     }
     /* Monster noise */
     mon->noise += 15;
    }
   } else if (rf_has(race->flags, RF_TUNNEL_WALL) &&
        !square_iscloseddoor(cave, next)) {
    bool note = false;
    /* Noise distance depends on monster "dangerousness"  XXX */
    int noise_dist = 10;
    /* Do not move */
    do_move = false;
    /* Note that the monster killed the wall */
    if (square_isview(cave, next)) {
     do_view = true;
     did_tunnel_wall = true;
    } else if (mon->cdis <= noise_dist) {
     /* Output warning messages if the racket gets too loud */
     note = true;
    }
    /* Grid is currently rubble */
    if (square_isrubble(cave, next)) {
     square_set_feat(cave, next, FEAT_FLOOR);
     if (note) {
      /* Disturb the player */
      disturb(player, false);
      msg("You hear grinding noises.");
     }
     /* Monster noise */
     mon->noise += 15;
    } else {
     /* Grid is granite or quartz */
     square_set_feat(cave, next, FEAT_RUBBLE);
     if (note) {
      /* Disturb the player */
      disturb(player, false);
      msg("You hear grinding noises.");
     }
     /* Monster noise */
     mon->noise += 15;
    }
   } else if (square_iscloseddoor(cave, next)) {
    /* Monster passes through doors */
    if (rf_has(race->flags, RF_PASS_DOOR)) {
     /* Monster went through a door */
     did_pass_door = true;
    } else if (bash) {
     /* Monster bashes the door down */
     if (square_isview(cave, next)) {
      /* Handle doors in sight */
      disturb(player, false);
      msg("The door bursts open!");
      do_view = true;
     } else if (mon->cdis < 20) {
      /* Character is not too far away */
      disturb(player, false);
      msg("You hear a door burst open!");
     }
     /* Note that the monster bashed the door (if visible) */
     did_bash_door = true;
     /* Monster noise */
     mon->noise += 10;
     /* Break down the door */
     if (one_in_(2)) {
      square_set_feat(cave, next, FEAT_BROKEN);
     } else {
      square_set_feat(cave, next, FEAT_OPEN);
     }
    } else {
     /* Monster opens the door */
     if (square_islockeddoor(cave, next)) {
      /* Note that the monster unlocked the door */
      did_unlock_door = true;
      /* Unlock the door */
      square_set_feat(cave, next, FEAT_CLOSED);
      /* Do not move */
      do_move = false;
      /* Handle doors in sight */
      if (square_isview(cave, next)) {
       msg("You hear a 'click'.");
      }
     } else {
      /* Note that the monster opened the door */
      did_open_door = true;
      /* Open the door */
      square_set_feat(cave, next, FEAT_OPEN);
      /* Step into doorway sometimes */
      if (!one_in_(5)) do_move = false;
     }
     /* Handle doors in sight */
     if (square_isview(cave, next)) {
      /* Do not disturb automatically */
      do_view = true;
     }
    }
   } else {
    /* Paranoia -- Ignore all features not added to this code */
    return;
   }
  } else if (square_iswarded(cave, next)) {
   /* Describe observable breakage */
   if (square_isseen(cave, next)) {
    msg("The glyph of warding is broken!");
    /* Forget the rune */
    square_unmark(cave, next);
   }
   /* Break the rune */
   square_destroy_trap(cave, next);
  }
 }
 /* Monster is still allowed to move */
 if (do_move) {
  /* The grid is occupied by a monster. */
  struct monster *mon1 = square_monster(cave, next);
  if (mon1) {
   /* Swap with or push aside the other monster */
   did_swap = true;
   /* The other monster cannot switch places */
   if (!monster_can_exist(cave, mon1, mon->grid, true, true)) {
    /* Try to push it aside */
    if (!process_move_push_aside(mon, mon1)) {
     /* Cancel move on failure */
     do_move = false;
    }
   }
  }
 }
 /* Monster can (still) move */
 if (do_move) {
  struct monster *mon1;
  /* Deal with possible flanking attack */
        if (rf_has(race->flags, RF_FLANKING) &&
            (distance(current, player->grid) == 1) &&
   (distance(next, player->grid) == 1) &&
            (mon->alertness >= ALERTNESS_ALERT) &&
   (mon->stance != STANCE_FLEEING) && !mon->m_timed[MON_TMD_CONF] &&
   !did_swap) {
   add_monster_message(mon, MON_MSG_FLANK, false);
            make_attack_normal(mon, player);
            /* Remember that the monster can do this */
            if (monster_is_visible(mon)) {
    rf_on(lore->flags, RF_FLANKING);
   }
        }
  /* Move the monster */
  monster_swap(current, next);
  /* Monster may have been killed in the swap */
  if (!mon->race) return;
  /* Cancel target when reached */
  if (loc_eq(mon->target.grid, next)) {
   mon->target.grid = loc(0, 0);
  }
  /* Did a new monster get pushed into the old space? */
  mon1 = square_monster(cave, current);
  if (mon1) {
   mflag_on(mon1->mflag, MFLAG_PUSHED);
            /* Exchanging places doesn't count as movement in a direction
			 * for abilities */
        } else {
   /* If it moved into a free space, record the direction of travel
			 * (for charge attacks) */
            mon->previous_action[0] = rough_direction(current, next);
        }
  /* If a member of a monster group capable of smelling hits a
		 * scent trail while out of LOS of the character, it will
		 * communicate this to similar monsters. */
  if (!square_isview(cave, next) && rf_has(race->flags, RF_FRIENDS) &&
      monster_can_smell(mon) && (get_scent(cave, current) == -1) &&
      loc_eq(mon->target.grid, loc(0, 0))) {
   int i;
   bool alerted_others = false;
   /* Scan all other monsters */
   for (i = cave_monster_max(cave) - 1; i >= 1; i--) {
    /* Access the monster */
    mon1 = cave_monster(cave, i);
    /* Ignore dead monsters */
    if (!mon1->race) continue;
    /* Ignore monsters with the wrong base */
    if (race->base != mon1->race->base) continue;
    /* Ignore monsters with specific orders */
    if (!loc_eq(mon->target.grid, loc(0, 0))) continue;
    /* Ignore monsters picking up a good scent */
    if (get_scent(cave, mon1->grid) < SMELL_STRENGTH - 10)
     continue;
    /* Ignore monsters not in LOS */
    if (!los(cave, mon->grid, mon1->grid)) continue;
    /* Activate all other monsters and give directions */
    make_alert(mon, 0);
    mflag_on(mon1->mflag, MFLAG_ACTIVE);
    mon1->target.grid = next;
    alerted_others = true;
   }
   if (alerted_others) {
    message_pursuit(mon);
   }
  }
  /* Monster is visible and not cloaked */
  if (monster_is_visible(mon)) {
   /* Report passing through doors */
   if (did_pass_door) {
    add_monster_message(mon, MON_MSG_PASS_DOOR, true);
   }
   /* Player will always be disturbed */
   disturb(player, false);
  }
  /* Take objects on the floor */
  process_move_grab_objects(mon, next);
 }
 /* Notice changes in view */
 if (do_view) {
  /* Update the visuals */
  player->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
 }
 /* Learn things from observable monster */
 if (monster_is_visible(mon)) {
  /* Monster passed through a door */
  if (did_pass_door) rf_on(lore->flags, RF_PASS_DOOR);
  /* Monster opened a door */
  if (did_open_door) rf_on(lore->flags, RF_OPEN_DOOR);
  /* Monster unlocked a door */
  if (did_unlock_door) rf_on(lore->flags, RF_UNLOCK_DOOR);
  /* Monster bashed a door */
  if (did_bash_door) rf_on(lore->flags, RF_BASH_DOOR);
  /* Monster passed through a wall */
  if (did_pass_wall) rf_on(lore->flags, RF_PASS_WALL);
  /* Monster killed a wall */
  if (did_kill_wall) rf_on(lore->flags, RF_KILL_WALL);
  /* Monster tunneled through a wall */
  if (did_tunnel_wall) rf_on(lore->flags, RF_TUNNEL_WALL);
 }
}
/**
 * ------------------------------------------------------------------------
 * Monster turn routines
 * These routines, culminating in monster_turn(), decide how a monster uses
 * its turn
 * ------------------------------------------------------------------------ */
/**
 * Deal with monsters trying to wander around the dungeon
 *
 * This function will finish the monster's turn
 */
static void monster_turn_wander(struct monster *mon)
{
 struct monster_group *group = monster_group_by_index(cave,
               mon->group_info.index);
 struct loc tgrid;
 bool fear = false;
 bool bash = false;
 const struct artifact *crown = lookup_artifact_name("of Morgoth");
    /* Begin a song of piercing if possible; Morgoth must be uncrowned */
    if (rsf_has(mon->race->spell_flags, RSF_SNG_PIERCE) &&
  (mon->song != lookup_song("Piercing")) &&
  (mon->alertness < ALERTNESS_ALERT) &&
  (mon->mana >= z_info->mana_cost) &&
  is_artifact_created(crown)) {
  do_mon_spell(RSF_SNG_PIERCE, mon, square_isview(cave, mon->grid));
    }
    /* Occasionally update the flow to take account of changes in the dungeon
	 * (new glyphs of warding, doors closed etc) */
    if (one_in_(10) && !loc_eq(group->flow.centre, loc(0, 0))) {
  update_flow(cave, &group->flow, mon);
     }
 /* Choose a target grid, or cancel the move. */
 if (!get_move_wander(mon, &tgrid)) return;
 /* Calculate the actual move.  Cancel move on failure to enter grid. */
 if (!make_move(mon, &tgrid, fear, &bash)) return;
 /* Change terrain, move the monster, handle secondary effects. */
 process_move(mon, tgrid, bash);
}
/**
 * Check whether there are nearby kin who are asleep/unwary
 */
static bool monster_has_sleeping_kin(struct monster *mon)
{
 int i;
 bool has_kin = false;
 /* Scan all other monsters */
 for (i = cave_monster_max(cave) - 1; i >= 1; i--) {
  /* Access the monster */
  struct monster *mon1 = cave_monster(cave, i);
  /* Ignore dead monsters */
  if (!mon1->race) continue;
  /* Ignore monsters with the wrong base */
  if (mon->race->base != mon1->race->base) continue;
  /* Determine line of sight between the monsters */
  if (!los(cave, mon->grid, mon1->grid)) continue;
  /* Ignore monsters that are awake */
  if (mon1->alertness >= ALERTNESS_ALERT) continue;
  /* Activate all other monsters and communicate to them */
  has_kin = true;
 }
 return has_kin;
}
/**
 * Alert others in pack about something using the m_flag, and wake them up
 */
void tell_allies(struct monster *mon, int flag)
{
 int i;
 bool warned = false;
 /* Scan all other monsters */
 for (i = cave_monster_max(cave) - 1; i >= 1; i--) {
  /* Access the monster */
  struct monster *mon1 = cave_monster(cave, i);
  int dist;
  /* Ignore dead monsters */
  if (!mon1->race) continue;
  /* Ignore monsters with the wrong base */
  if (mon->race->base != mon1->race->base) continue;
  /* Ignore monsters that already know */
  if ((mon1->alertness >= ALERTNESS_ALERT) &&
   mflag_has(mon1->mflag, flag)) {
   continue;
  }
  /* Determine the distance between the monsters */
  dist = distance(mon->grid, mon1->grid);
  /* Penalize this for not being in line of sight */
  if (!los(cave, mon->grid, mon1->grid)) {
   dist *= 2;
  }
  /* Ignore monsters that are too far away */
  if (dist > 15) continue;
  /* When the first monster in need of warning is found,
		 * make the warning shout */
  if (!warned) {
   message_warning(mon);
   warned = true;
  }
  /* If an eligible monster is now alert, then set the flag */
  if (mon1->alertness >= ALERTNESS_ALERT) {
   mflag_on(mon1->mflag, (MFLAG_ACTIVE | flag));
  }
 }
}
/**
 * Deal with a monster hit by a ranged attack from the player
 */
static void monster_turn_hit_by_ranged(struct monster *mon)
{
 /* Monster will be very upset if it can't see the player or if it is
	 * in a corridor and can't fire back */
 if (((mon->best_range == 1) && !square_isroom(cave, mon->grid)) ||
  !square_isview(cave, mon->grid)) {
  mflag_on(mon->mflag, MFLAG_AGGRESSIVE);
  /* If smart and has allies, let them know */
  if (rf_has(mon->race->flags, RF_SMART)
   && monster_talks_to_friends(mon)) {
   tell_allies(mon, MFLAG_AGGRESSIVE);
  }
  /* Monsters with ranged attacks will try to cast a spell*/
  if (mon->race->freq_ranged) mflag_on(mon->mflag, MFLAG_ALWAYS_CAST);
  calc_monster_speed(mon);
 }
 /* Clear the flag */
 mflag_off(mon->mflag, MFLAG_HIT_BY_RANGED);
}
/**
 * Deal with a monster hit by a melee attack from the player
 */
static void monster_turn_hit_by_melee(struct monster *mon)
{
 /* Monster will be very upset if it isn't next to the player on its turn
	 * (pillar dance, hack-n-back, etc) */
 if ((mon->cdis > 1) && !mflag_has(mon->mflag, MFLAG_PUSHED)) {
  mflag_on(mon->mflag, MFLAG_AGGRESSIVE);
  /* If smart and has allies, let them know */
  if (rf_has(mon->race->flags, RF_SMART) &&
   monster_talks_to_friends(mon)) {
   tell_allies(mon, MFLAG_AGGRESSIVE);
  }
  /* Monsters with ranged attacks will try to cast a spell*/
  if (mon->race->freq_ranged) mflag_on(mon->mflag, MFLAG_ALWAYS_CAST);
  calc_monster_speed(mon);
 }
 /* Clear the flag */
 mflag_off(mon->mflag, MFLAG_HIT_BY_MELEE);
}
/**
 * Lets the given monster attempt to reproduce.
 *
 * Note that "reproduction" REQUIRES empty space.
 *
 * Returns true if the monster successfully reproduced.
 */
bool multiply_monster(const struct monster *mon)
{
 struct loc grid;
 struct monster_group_info info = { 0, 0 };
 /* Pick an empty location. */
 if (scatter_ext(cave, &grid, 1, mon->grid, 1, true, square_isempty) > 0) {
  /* Create a new monster (awake, no groups) */
  return place_new_monster(cave, grid, mon->race, false, false,
         info, ORIGIN_DROP_BREED);
 }
 /* Fail */
 return false;
}
/**
 * Attempt to reproduce, if possible.  All monsters are checked here for
 * lore purposes, the unfit fail.
 */
static bool monster_turn_multiply(struct monster *mon)
{
 int k = 0, y, x;
 struct monster_lore *lore = get_lore(mon->race);
 /* Leave now if not a breeder */
 if (!rf_has(mon->race->flags, RF_MULTIPLY)) return false;
 /* Too many monsters on the level already */
 if (cave_monster_count(cave) > z_info->level_monster_max - 50) return false;
 /* Count the adjacent monsters */
 for (y = mon->grid.y - 1; y <= mon->grid.y + 1; y++) {
  for (x = mon->grid.x - 1; x <= mon->grid.x + 1; x++) {
   if (!square_in_bounds(cave, loc(x, y))) continue;
   if (square(cave, loc(x, y))->mon > 0) k++;
  }
 }
 /* Multiply slower in crowded areas */
 if ((k < 4) && one_in_(k * z_info->repro_monster_rate)) {
  /* Try to multiply */
  if (multiply_monster(mon)) {
   if (monster_is_visible(mon)) {
    /* Make a sound */
    sound(MSG_MULTIPLY);
    /* Successful breeding attempt, learn about that now */
    rf_on(lore->flags, RF_MULTIPLY);
   }
   /* Multiplying takes energy */
   return true;
  }
 }
 return false;
}
/**
 * Check if a monster should step at random or not.
 */
static bool monster_turn_random_move(struct monster *mon)
{
 struct monster_lore *lore = get_lore(mon->race);
 int chance = 0;
 /* RAND_25 and RAND_50 are cumulative */
 if (rf_has(mon->race->flags, RF_RAND_25)) {
  chance += 25;
  if (monster_is_visible(mon))
   rf_on(lore->flags, RF_RAND_25);
 }
 if (rf_has(mon->race->flags, RF_RAND_50)) {
  chance += 50;
  if (monster_is_visible(mon))
   rf_on(lore->flags, RF_RAND_50);
 }
 /* Adjacent to the character means more chance of just attacking normally */
 if (mon->cdis == 1) {
  chance /= 2;
 }
 return randint0(100) < chance;
}
/**
 * Monster takes its turn.
 */
static void monster_turn(struct monster *mon)
{
 struct song *mastery = lookup_song("Mastery");
 int i;
 struct loc tgrid = loc(0, 0), grid;
 bool random_move = false;
 bool fear = false;
 bool bash = false;
 /* Assume the monster doesn't have a target */
 bool must_use_target = false;
    /* Assume we are not under the influence of the Song of Mastery */
    mon->skip_this_turn = false;
 /* First work out if the song of mastery stops the monster's turn */
 if (player_is_singing(player, mastery)) {
  int pskill = song_bonus(player, player->state.skill_use[SKILL_SONG],
        mastery);
  int mskill = monster_skill(mon, SKILL_WILL) + 5
   + flow_dist(cave->player_noise, mon->grid);
  if (skill_check(source_player(), pskill, mskill,
      source_monster(mon->midx)) > 0) {
            /* Make sure the monster doesn't do any free attacks before its
			 * next turn */
            mon->skip_this_turn = true;
            /* End the monster's turn */
            return;
  }
 }
    /* Deal with monster songs */
    if (mon->song) {
        int dist = flow_dist(cave->player_noise, mon->grid);
        if ((mon->mana == 0) || ((mon->song == lookup_song("Piercing")) &&
         (mon->alertness >= ALERTNESS_ALERT))) {
            if (monster_is_visible(mon)) {
    add_monster_message(mon, MON_MSG_END_SONG, false);
   } else if (dist <= 30) {
    msg("The song ends.");
   }
            mon->song = NULL;
        } else {
            mon->mana--;
   effect_simple(mon->song->effect->index, source_monster(mon->midx),
        "0", 0, 0, 0, NULL);
        }
    }
 /* Update view if the monster affects light and is close enough */
 if ((mon->race->light != 0) &&
  (mon->cdis < z_info->max_sight + ABS(mon->race->light))) {
  player->upkeep->update |= (PU_UPDATE_VIEW);
 }
    /* Shuffle along the array of previous actions, enter this turn's default */
    for (i = MAX_ACTION - 1; i > 0; i--) {
        mon->previous_action[i] = mon->previous_action[i - 1];
    }
 mon->previous_action[0] = ACTION_MISC;
 /* Unwary but awake monsters can wander around the dungeon */
 if (mon->alertness < ALERTNESS_ALERT) {
  monster_turn_wander(mon);
  return;
 }
    /* Update monster flow information */
 mon->flow.centre = player->grid;
    update_flow(cave, &mon->flow, mon);
 /* Calculate the monster's preferred combat range when needed */
 if (mon->min_range == 0) {
  monster_find_range(mon);
 }
 /* Determine if the monster should be active */
 if (monster_check_active(mon)) {
  mflag_on(mon->mflag, MFLAG_ACTIVE);
 } else {
  mflag_off(mon->mflag, MFLAG_ACTIVE);
 }
 /* Special handling if the first turn a monster has after
	 * being attacked by the player, but the player is out of sight */
 if (mflag_has(mon->mflag, MFLAG_HIT_BY_RANGED)) {
  monster_turn_hit_by_ranged(mon);
 }
 /* First turn a monster has after being attacked by the player*/
 if (mflag_has(mon->mflag, MFLAG_HIT_BY_MELEE)) {
  monster_turn_hit_by_melee(mon);
 }
 /* If a smart monster has sleeping friends and sees the player,
	 * sometimes shout a warning */
 if (one_in_(2) && rf_has(mon->race->flags, RF_SMART) &&
     square_isview(cave, mon->grid) && monster_has_sleeping_kin(mon) &&
  monster_talks_to_friends(mon)) {
  tell_allies(mon, MFLAG_ACTIVE);
  calc_monster_speed(mon);
 }
 /* Clear CHARGED and PUSHED flags */
 mflag_off(mon->mflag, MFLAG_CHARGED);
 mflag_off(mon->mflag, MFLAG_PUSHED);
 /* A monster in passive mode will end its turn at this point. */
 if (!mflag_has(mon->mflag, MFLAG_ACTIVE)) {
  monster_turn_wander(mon);
  return;
 }
 /* Redraw (later) if needed */
 if (player->upkeep->health_who == mon)
  player->upkeep->redraw |= (PR_HEALTH);
 /* Try to multiply - this can use up a turn */
 if (monster_turn_multiply(mon)) return;
 /* Attempt a ranged attack */
 if ((randint0(100) < monster_cast_chance(mon)) && make_ranged_attack(mon)) {
  return;
 }
 /* Innate semi-random movement. */
 random_move = monster_turn_random_move(mon);
 /* Monster isn't moving randomly, isn't running away, doesn't hear
	 * or smell the character */
 if (!random_move) {
  /* Monsters who can't cast, are aggressive, and are not afraid
		 * just want to charge */
  if ((mon->stance == STANCE_AGGRESSIVE) && (!mon->race->freq_ranged)) {
   mon->target.grid = loc(0, 0);
  }
  /* Player can see the monster, and it is not afraid */
  if (square_isview(cave, mon->grid) && (mon->stance != STANCE_FLEEING)) {
   mon->target.grid = loc(0, 0);
  }
  /* Monster still has a known target */
  if (!loc_eq(mon->target.grid, loc(0, 0))) {
   must_use_target = true;
  }
 }
 /* Find a target to move to */
 if (random_move) {
  /* Monster isn't confused, just moving semi-randomly */
  int start = randint0(8);
  bool dummy, no_move = rf_has(mon->race->flags, RF_NEVER_MOVE);
  /* Is the monster scared? */
  if (((mon->min_range >= z_info->flee_range) ||
    (mon->stance == STANCE_FLEEING))
   && !no_move) {
   fear = true;
  }
  /* Look at adjacent grids, starting at random. */
  for (i = start; i < 8 + start; i++) {
   grid = loc_sum(mon->grid, ddgrid_ddd[i % 8]);
   /* Accept first passable grid. */
   if (monster_entry_chance(cave, mon, grid, &dummy) != 0) {
    tgrid = grid;
    break;
   }
  }
  /* No passable grids found */
  if (loc_eq(tgrid, loc(0, 0))) return;
  /* Cannot move, target grid does not contain the character */
  if (no_move && !square_isplayer(cave, tgrid)) return;
 } else {
        /* Extremely frightened monsters next to chasms may jump into the void*/
        if ((mon->stance == STANCE_FLEEING) && (mon->morale < -200) &&
   !rf_has(mon->race->flags, RF_FLYING) && one_in_(2)) {
   struct loc chasm = loc(0, 0);
   /* Look at adjacent grids */
            for (i = 0; i < 8; i++) {
                grid = loc_sum(mon->grid, ddgrid_ddd[i]);
                /* Check bounds */
                if (!square_in_bounds(cave, grid)) continue;
                /* Accept a chasm square */
                if (square_ischasm(cave, grid)) {
                    chasm = grid;
                    break;
                }
            }
            if (!loc_eq(chasm, loc(0, 0))) {
                monster_swap(mon->grid, chasm);
                return;
            }
  }
  /* Choose a pair of target grids, or cancel the move. */
  if (!get_move(mon, &tgrid, &fear, must_use_target)) {
   return;
  }
 }
 /* If the monster thinks its location is optimal... */
 if (loc_eq(tgrid, mon->grid)) {
  /* Intelligent monsters (but not territorial ones) that are fleeing
		 * can try to use stairs */
  if (rf_has(mon->race->flags, RF_SMART) &&
   !rf_has(mon->race->flags, RF_TERRITORIAL) &&
   (mon->stance == STANCE_FLEEING) &&
   square_isstairs(cave, tgrid)) {
   if (monster_is_visible(mon)) {
    if (square_isdownstairs(cave, tgrid)) {
     add_monster_message(mon, MON_MSG_FLEE_DOWN_STAIRS, true);
    } else {
     add_monster_message(mon, MON_MSG_FLEE_UP_STAIRS, true);
    }
   }
   /* If adjacent, player gets a chance for an opportunist attack,
			 * which might kill the monster */
   player_opportunist_or_zone(player, tgrid, player->grid, true);
   /* Removes the monster if it is still alive */
   delete_monster(cave, tgrid);
   return;
  }
  /* If the square is non-adjacent to the player,
		 * then allow a ranged attack instead of a move */
  if ((mon->cdis > 1) && mon->race->freq_ranged) {
   make_ranged_attack(mon);
  }
  /* Nothing left to do */
  return;
 }
 /* Calculate the actual move.  Cancel move on failure to enter grid. */
 if (!make_move(mon, &tgrid, fear, &bash)) return;
 /* Change terrain, move the monster, handle secondary effects. */
 process_move(mon, tgrid, bash);
}
/**
 * ------------------------------------------------------------------------
 * Processing routines that happen to a monster regardless of whether it
 * gets a turn, and/or to decide whether it gets a turn
 * ------------------------------------------------------------------------ */
/**
 * Monster regeneration of HPs.
 */
static void regen_monster(struct monster *mon, int num)
{
 int regen_period = z_info->mon_regen_hp_period;
 /* Regenerate (if needed) */
 if (mon->hp < mon->maxhp) {
  /* Some monsters regenerate quickly */
  if (rf_has(mon->race->flags, RF_REGENERATE)) regen_period /= 5;
  /* Regenerate */
  mon->hp += regen_amount(turn / 10, mon->maxhp, regen_period);
  /* Do not over-regenerate */
  if (mon->hp > mon->maxhp) mon->hp = mon->maxhp;
  /* Fully healed -> flag minimum range for recalculation */
  if (mon->hp == mon->maxhp) mon->min_range = 0;
  /* Redraw (later) if needed */
  if (player->upkeep->health_who == mon)
   player->upkeep->redraw |= (PR_HEALTH);
 }
 /* Allow mana regeneration, if needed. */
 if (mon->mana != z_info->mana_max) {
  /* Can only regenerate mana if not singing */
  if (!mon->song) {
   mon->mana += regen_amount(turn / 10, z_info->mana_max,
           z_info->mon_regen_sp_period);
   /* Do not over-regenerate */
   if (mon->mana > z_info->mana_max) mon->mana = z_info->mana_max;
   /* Fully healed -> flag minimum range for recalculation */
   if (mon->mana == z_info->mana_max) mon->min_range = 0;
  }
 }
}
/**
 * Process a monster's timed effects and other things that need to be done
 * every turn
 */
static void process_monster_recover(struct monster *mon)
{
 int i;
    /* Summoned monsters have a half-life of one turn after the song stops */
 if (mflag_has(mon->mflag, MFLAG_SUMMONED)) {
        int still_singing = false;
        for (i = 1; i < cave_monster_max(cave); i++) {
            struct monster *mon1 = cave_monster(cave, i);
            /* Skip dead monsters */
            if (!mon1->race) continue;
            /* Note if any monster is singing the song of oaths */
            if (mon1->song == lookup_song("Oaths")) {
    still_singing = true;
    break;
   }
  }
        if (!still_singing && one_in_(2)) {
            /* Remove the monster */
            delete_monster(cave, mon->grid);
   return;
        }
    }
 /* Reduce timed effects */
 for (i = 0; i < MON_TMD_MAX; i++) {
  if (mon->m_timed[i]) {
   mon_dec_timed(mon, i, 1, MON_TMD_FLG_NOTIFY);
  }
 }
 /* Reduce temporary morale modifiers by 10% */
 if (mon->tmp_morale != 0) {
  mon->tmp_morale *= 9;
  mon->tmp_morale /= 10;
 }
 /* Hack -- Update the health and mana bar (always) */
 if (player->upkeep->health_who == mon)
  player->upkeep->redraw |= (PR_HEALTH);
 /* Monsters who are out of sight and fail their perception rolls by 25
	 * or more (15 with Vanish) start to lose track of the player */
 if (!los(cave, mon->grid, player->grid) &&
  (mon->alertness >= ALERTNESS_ALERT) &&
     (mon->stance != STANCE_FLEEING) && (mon->race->sleep > 0)) {
  int bonus = player_active_ability(player, "Vanish") ? 15 : 25;
  int result = skill_check(source_monster(mon->midx),
                           monster_skill(mon, SKILL_PERCEPTION) + bonus,
                           player->state.skill_use[SKILL_STEALTH] +
         flow_dist(cave->player_noise, mon->grid),
         source_player());
  if (result < 0) {
   set_alertness(mon, MAX(mon->alertness + result, ALERTNESS_UNWARY));
  }
 }
 /* Calculate the monster's morale and stance */
 calc_morale(mon);
 calc_stance(mon);
}
/**
 * ------------------------------------------------------------------------
 * Monster processing routines to be called by the main game loop
 * ------------------------------------------------------------------------ */
/**
 * Process all the "live" monsters, once per game turn.
 *
 * During each game turn, we scan through the list of all the "live" monsters,
 * (backwards, so we can excise any "freshly dead" monsters), energizing each
 * monster, and allowing fully energized monsters to move, attack, pass, etc.
 *
 * This function and its children are responsible for a considerable fraction
 * of the processor time in normal situations, greater if the character is
 * resting.
 */
void process_monsters(int minimum_energy)
{
 int i;
 /* Only process some things every so often */
 bool regen = false;
 /* If time is stopped, no monsters can move */
 if (OPT(player, cheat_timestop)) return;
 /* Regenerate hitpoints and mana every 100 game turns */
 if (turn % 10 == 0)
  regen = true;
 /* Process the monsters (backwards) */
 for (i = cave_monster_max(cave) - 1; i >= 1; i--) {
  struct monster *mon;
  bool moving;
  /* Handle "leaving" */
  if (player->is_dead || player->upkeep->generate_level) break;
  /* Get a 'live' monster */
  mon = cave_monster(cave, i);
  if (!mon->race) continue;
  /* Ignore monsters that have already been handled */
  if (mflag_has(mon->mflag, MFLAG_HANDLED))
   continue;
  /* Not enough energy to move yet */
  if (mon->energy < minimum_energy) continue;
  /* Does this monster have enough energy to move? */
  moving = mon->energy >= z_info->move_energy ? true : false;
  /* Prevent reprocessing */
  mflag_on(mon->mflag, MFLAG_HANDLED);
  /* Handle monster regeneration if requested */
  if (regen)
   regen_monster(mon, 1);
  /* Give this monster some energy */
  mon->energy += turn_energy(mon->mspeed);
  /* End the turn of monsters without enough energy to move */
  if (!moving) continue;
  /* Process timed effects and other every-turn things */
  process_monster_recover(mon);
  /* Use up "some" energy */
  mon->energy -= z_info->move_energy;
  /* Sleeping monsters don't get a move */
  if (mon->alertness < ALERTNESS_UNWARY) continue;
  /* Monsters who have just noticed you miss their turns (as do those
		 * who have been knocked back...) */
  if (mon->skip_next_turn) {
            /* Reset its previous movement to stop it charging etc. */
   mon->previous_action[0] = ACTION_MISC;
   mon->skip_next_turn = false;
   continue;
  }
  /* Set this monster to be the current actor */
  cave->mon_current = i;
  /* The monster takes its turn */
  monster_turn(mon);
  /* Monster is no longer current */
  cave->mon_current = -1;
 }
 /* Update monster visibility after this */
 /* XXX This may not be necessary */
 player->upkeep->update |= PU_MONSTERS;
}
/**
 * Clear 'moved' status from all monsters.
 *
 * Clear noise if appropriate.
 */
void reset_monsters(void)
{
 int i;
 struct monster *mon;
 /* Process the monsters (backwards) */
 for (i = cave_monster_max(cave) - 1; i >= 1; i--) {
  /* Access the monster */
  mon = cave_monster(cave, i);
  /* Monster is ready to go again */
  mflag_off(mon->mflag, MFLAG_HANDLED);
 }
}
/**
 * \file mon-msg.c
 * \brief Monster message code.
 *
 * Copyright (c) 1997-2016 Jeff Greene, Andi Sidwell
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Maxinum number of stacked monster messages
 */
/**
 * Flags for whether monsters are offscreen or invisible
 */
/**
 * A stacked monster message entry
 */
struct monster_race_message {
 struct monster_race *race; /* The race of the monster */
 int flags; /* Flags */
 int msg_code; /* The coded message */
 int count; /* How many monsters triggered this message */
 int delay; /* messages will be processed in this order: delay = 0, 1, 2 */
};
/**
 * A (monster, message type) pair used for duplicate checking
 */
struct monster_message_history {
 struct monster *mon; /* The monster */
 int message_code; /* The coded message */
};
static int size_mon_hist = 0;
static int size_mon_msg = 0;
static struct monster_race_message mon_msg[200];
static struct monster_message_history mon_message_hist[400];
/**
 * An array of monster messages in order of monster message type.
 *
 * Singular and plural modifiers are encoded in the same string. Example:
 * "[is|are] hurt" is expanded to "is hurt" if you request the singular form.
 * The string is expanded to "are hurt" if the plural form is requested.
 *
 * The singular and plural parts are optional. Example:
 * "rear[s] up in anger" only includes a modifier for the singular form.
 *
 * Any of these strings can start with "~", in which case we consider that
 * string as a whole message, not as a part of a larger message. This
 * is useful to display Moria-like death messages.
 */
static const struct {
 const char *msg;
 bool omit_subject;
 int type;
} msg_repository[] = {
/**
 * \file list-mon-message.h
 * \brief List of monster message types
 *
 * id           - the message constant name
 * msg          - MSG_ type for the printed message
 * omit_subject - true to omit a monster name beforehand (see mon-msg.c)
 * text         - the message text
 */
/* id						MSG_GENERIC,	text */
{ "[is|are] hurt.", false, MSG_GENERIC },
{ "die[s].", false, MSG_KILL },
{ "[is|are] destroyed.", false, MSG_KILL },
{ "resist[s] a lot.", false, MSG_GENERIC },
{ "[is|are] hit hard.", false, MSG_GENERIC },
{ "resist[s].", false, MSG_GENERIC },
{ "[is|are] immune.", false, MSG_GENERIC },
{ "resist[s] somewhat.", false, MSG_GENERIC },
{ "[is|are] unaffected!", false, MSG_GENERIC },
{ "spawn[s]!", false, MSG_GENERIC },
{ "look[s] healthier.", false, MSG_GENERIC },
{ "fall[s] asleep.", false, MSG_GENERIC },
{ "wake[s] up.", false, MSG_GENERIC },
{ "notice[s] you.", false, MSG_GENERIC },
{ "wake[s] up and notice[s] you.", false, MSG_GENERIC },
{ "stir[s].", false, MSG_GENERIC },
{ "look[s] around.", false, MSG_GENERIC },
{ "become[s] unwary.", false, MSG_GENERIC },
{ "cringe[s] from the light!", false, MSG_GENERIC },
{ "shrivel[s] away in the light!", false, MSG_KILL },
{ "partly shatter[s]!", false, MSG_GENERIC },
{ "shatter[s]!", false, MSG_KILL },
{ "catch[es] fire!", false, MSG_GENERIC },
{ "[is|are] badly frozen.", false, MSG_GENERIC },
{ "shudder[s].", false, MSG_GENERIC },
{ "change[s]!", false, MSG_GENERIC },
{ "disappear[s]!", false, MSG_GENERIC },
{ "[is|are] even more stunned.", false, MSG_GENERIC },
{ "[is|are] stunned.", false, MSG_GENERIC },
{ "[is|are] no longer stunned.", false, MSG_GENERIC },
{ "look[s] more confused.", false, MSG_GENERIC },
{ "look[s] confused.", false, MSG_GENERIC },
{ "[is|are] no longer confused.", false, MSG_GENERIC },
{ "look[s] more slowed.", false, MSG_GENERIC },
{ "look[s] slowed.", false, MSG_GENERIC },
{ "speed[s] up.", false, MSG_GENERIC },
{ "look[s] even faster!", false, MSG_GENERIC },
{ "start[s] moving faster.", false, MSG_GENERIC },
{ "slow[s] down.", false, MSG_GENERIC },
{ "look[s] more terrified!", false, MSG_GENERIC },
{ "flee[s] in terror!", false, MSG_FLEE },
{ "[is|are] no longer afraid.", false, MSG_GENERIC },
{ "turn[s] to fight!", false, MSG_GENERIC },
{ "recover[s] [its|their] composure.", false, MSG_GENERIC },
{ "panics.", false, MSG_GENERIC },
{ "staggers into a door.", false, MSG_GENERIC },
{ "staggers into some rubble.", false, MSG_GENERIC },
{ "bashes into a wall.", false, MSG_GENERIC },
{ "[is|are] frozen to the spot!", false, MSG_GENERIC },
{ "can move again.", false, MSG_GENERIC },
{ "[is|are] blown backwards by the force.", false, MSG_GENERIC },
{ "holds firm against the force of the blast.", false, MSG_GENERIC },
{ "falls under your spell!", false, MSG_GENERIC },
{ "is no longer under your control.", false, MSG_GENERIC },
{ "shimmers for a moment.", false, MSG_GENERIC },
{ "You hear [a|several] scream[|s] of agony!", true, MSG_KILL },
{ "disintegrate[s]!", false, MSG_KILL },
{ "freeze[s] and shatter[s]!", false, MSG_KILL },
{ "lose[s] some mana!", false, MSG_GENERIC },
{ "look[s] briefly puzzled.", false, MSG_GENERIC },
{ "maintain[s] the same shape.", false, MSG_GENERIC },
{ "[is|are] unharmed.", false, MSG_GENERIC },
{ "appear[s]!", false, MSG_GENERIC },
{ "There is a puff of smoke!", true, MSG_GENERIC },
{ "[goes|go] up the stairs.", false, MSG_GENERIC },
{ "[goes|go] down the stairs.", false, MSG_GENERIC },
{ "flee[s] up the stairs.", false, MSG_GENERIC },
{ "flee[s] down the stairs.", false, MSG_GENERIC },
{ "exchanges places with you.", false, MSG_GENERIC },
{ "attacks you as it moves by.", false, MSG_GENERIC },
{ "passes under the door.", false, MSG_GENERIC },
{ "ends his song.", false, MSG_GENERIC },
/* Dummy messages for monster pain, pursuit, warning - use edit file info. */
{ "", true, MSG_GENERIC },
{ "", true, MSG_GENERIC },
{ "", true, MSG_GENERIC },
{ "", false, MSG_GENERIC },
{ "", true, MSG_GENERIC },
{ "", true, MSG_GENERIC },
{ "", false, MSG_GENERIC },
{ "", true, MSG_GENERIC },
{ "", false, MSG_GENERIC },
{ "", true, MSG_GENERIC },
{ "", false, MSG_GENERIC },

};
/**
 * Adds to the message queue a message describing a monster's reaction
 * to damage.
 */
void message_pain(struct monster *mon, int dam)
{
 int msg_code = MON_MSG_UNHARMED;
 struct monster_race *race = player->timed[TMD_IMAGE] ? mon->image_race :
  mon->race;
 /* Return now for monsters with no pain messages */
 if (race->base->pain == NULL) return;
 /* Calculate damage levels */
 if (dam > 0) {
  /* Note -- subtle fix -CFT */
  long newhp = (long)(mon->hp);
  long oldhp = newhp + (long)(dam);
  long tmp = (newhp * 100L) / oldhp;
  int percentage = (int)(tmp);
  if (percentage > 66) msg_code = MON_MSG_66;
  else if (percentage > 33) msg_code = MON_MSG_33;
  else msg_code = MON_MSG_0;
 }
 add_monster_message(mon, msg_code, false);
}
/**
 * Adds to the message queue a message describing a monster's encouragement
 * of others to pursue the player.
 */
void message_pursuit(struct monster *mon)
{
 int msg_code = MON_MSG_NONE;
 int dist = distance(player->grid, mon->grid);
 struct monster_race *race = player->timed[TMD_IMAGE] ? mon->image_race :
  mon->race;
 /* Return now for monsters with no pursuit messages */
 if (race->base->pursuit == NULL) return;
 /* Visible, or near or far */
 if (monster_is_visible(mon)) {
  msg_code = MON_MSG_PURSUE_VIS;
 } else if (dist < 20) {
  msg_code = MON_MSG_PURSUE_CLOSE;
 } else {
  msg_code = MON_MSG_PURSUE_FAR;
 }
 add_monster_message(mon, msg_code, false);
}
/**
 * Adds to the message queue a message describing a monster's warning
 * to others of the player's presence.
 */
void message_warning(struct monster *mon)
{
 int msg_code = MON_MSG_NONE;
 bool silence = player_is_singing(player, lookup_song("Silence"));
 struct monster_race *race = player->timed[TMD_IMAGE] ? mon->image_race :
  mon->race;
 /* Return now for monsters with no warning messages */
 if (race->base->warning == NULL) return;
 /* Visible, or near or far */
 if (monster_is_visible(mon)) {
  if (silence) {
   msg_code = MON_MSG_WARN_VIS_SIL;
  } else {
   msg_code = MON_MSG_WARN_VIS;
  }
 } else if (silence) {
  msg_code = MON_MSG_WARN_INVIS_SIL;
 } else {
  msg_code = MON_MSG_WARN_INVIS;
 }
 add_monster_message(mon, msg_code, false);
 /* Hard not to notice */
 cave->monster_noise.centre = mon->grid;
 update_flow(cave, &cave->monster_noise, NULL);
 monsters_hear(false, false, -10);
 /* Makes monster noise too */
 mon->noise += 10;
}
/**
 * Tracks which monster has had which pain message stored, so redundant
 * messages don't happen due to monster attacks hitting other monsters.
 * Returns true if the message is redundant.
 */
static bool redundant_monster_message(struct monster *mon, int msg_code)
{
 assert(mon);
 assert(msg_code >= 0);
 assert(msg_code < MON_MSG_MAX);
 for (int i = 0; i < size_mon_hist; i++) {
  /* Check for a matched monster & monster code */
  if (mon == mon_message_hist[i].mon &&
    msg_code == mon_message_hist[i].message_code) {
   return true;
  }
 }
 return false;
}
/**
 * Work out what flags a message should have from a monster
 */
static int message_flags(const struct monster *mon)
{
 int flags = 0;
 if (!panel_contains(mon->grid.y, mon->grid.x)) {
  flags |= 0x01;
 }
 if (!monster_is_visible(mon)) {
  flags |= 0x02;
 }
 return flags;
}
/**
 * Store the monster in the monster history for duplicate checking later
 */
static void store_monster(struct monster *mon, int msg_code)
{
 /* Record which monster had this message stored */
 if (size_mon_hist < 400) {
  mon_message_hist[size_mon_hist].mon = mon;
  mon_message_hist[size_mon_hist].message_code = msg_code;
  size_mon_hist++;
 }
}
/**
 * Try to stack a message on top of existing ones
 *
 * \returns true if successful, false if failed
 */
static bool stack_message(struct monster *mon, int msg_code, int flags)
{
 int i;
 struct monster_race *race = player->timed[TMD_IMAGE] ? mon->image_race :
  mon->race;
 for (i = 0; i < size_mon_msg; i++) {
  /* We found the race and the message code */
  if (mon_msg[i].race == race &&
   mon_msg[i].flags == flags &&
   mon_msg[i].msg_code == msg_code) {
   mon_msg[i].count++;
   store_monster(mon, msg_code);
   return true;
  }
 }
 return false;
}
static int what_delay(int msg_code, int delay)
{
 if (msg_code == MON_MSG_DIE || msg_code == MON_MSG_DESTROYED) {
  return 2;
 } else {
  return delay ? 1 : 0;
 }
}
/**
 * Stack a codified message for the given monster race.
 *
 * Return true on success.
 */
bool add_monster_message(struct monster *mon, int msg_code, bool delay)
{
 assert(msg_code >= 0);
 assert(msg_code < MON_MSG_MAX);
 int flags = message_flags(mon);
 /* Try to stack the message on top of older messages if it isn't redunant */
 /* If not possible, check we have storage space for more messages and add */
 if (!redundant_monster_message(mon, msg_code) &&
   !stack_message(mon, msg_code, flags) &&
   size_mon_msg < 200) {
  mon_msg[size_mon_msg].race = player->timed[TMD_IMAGE] ?
   mon->image_race : mon->race;
  mon_msg[size_mon_msg].flags = flags;
  mon_msg[size_mon_msg].msg_code = msg_code;
  mon_msg[size_mon_msg].count = 1;
  mon_msg[size_mon_msg].delay = what_delay(msg_code, delay);
  size_mon_msg++;
  store_monster(mon, msg_code);
  player->upkeep->notice |= PN_MON_MESSAGE;
  return true;
 } else {
  return false;
 }
}
/**
 * Create the subject of the sentence for monster messages
 */
static void get_subject(char *buf, size_t buflen,
  struct monster_race *race,
  int count,
  bool invisible,
  bool offscreen)
{
 if (invisible) {
  if (count == 1) {
   my_strcpy(buf, "It", buflen);
  } else {
   strnfmt(buf, buflen, "%d monsters", count);
  }
 } else {
  /* Uniques, multiple monsters, or just one */
  if (rf_has(race->flags, RF_UNIQUE)) {
   my_strcpy(buf, race->name, buflen);
  } else if (count == 1) {
   strnfmt(buf, buflen, "The %s", race->name);
  } else {
   /* Get the plural of the race name */
   if (race->plural != NULL) {
    strnfmt(buf, buflen, "%d %s", count, race->plural);
   } else {
    strnfmt(buf, buflen, "%d %s", count, race->name);
    plural_aux(buf, buflen);
   }
  }
  if (rf_has(race->flags, RF_NAME_COMMA)) {
   my_strcat(buf, ",", buflen);
  }
 }
 if (offscreen)
  my_strcat(buf, " (offscreen)", buflen);
 /* Add a separator */
 my_strcat(buf, " ", buflen);
}
/* State machine constants for get_message_text() */
/**
 * Formats a message based on the given message code and the plural flag.
 *
 * \param	pos		the position in buf to start writing the message into
 */
static void get_message_text(char *buf, size_t buflen,
  int msg_code,
  const struct monster_race *race,
  bool do_plural)
{
 assert(msg_code < MON_MSG_MAX);
 assert(race != NULL);
 assert(race->base != NULL);
 /* Find the appropriate message */
 const char *source = msg_repository[msg_code].msg;
 switch (msg_code) {
  case MON_MSG_66: {
   assert(race->base->pain != NULL);
   source = race->base->pain->messages[0];
   break;
  }
  case MON_MSG_33: {
   assert(race->base->pain != NULL);
   source = race->base->pain->messages[1];
   break;
  }
  case MON_MSG_0: {
   assert(race->base->pain != NULL);
   source = race->base->pain->messages[2];
   break;
  }
  case MON_MSG_PURSUE_VIS: {
   assert(race->base->pursuit != NULL);
   source = race->base->pursuit->msg_vis;
   break;
  }
  case MON_MSG_PURSUE_CLOSE: {
   assert(race->base->pursuit != NULL);
   source = race->base->pursuit->msg_close;
   break;
  }
  case MON_MSG_PURSUE_FAR: {
   assert(race->base->pursuit != NULL);
   source = race->base->pursuit->msg_far;
   break;
  }
  case MON_MSG_WARN_VIS: {
   assert(race->base->warning != NULL);
   source = race->base->warning->msg_vis;
   break;
  }
  case MON_MSG_WARN_INVIS: {
   assert(race->base->warning != NULL);
   source = race->base->warning->msg_invis;
   break;
  }
  case MON_MSG_WARN_VIS_SIL: {
   assert(race->base->warning != NULL);
   source = race->base->warning->msg_vis_silence;
   break;
  }
  case MON_MSG_WARN_INVIS_SIL: {
   assert(race->base->warning != NULL);
   source = race->base->warning->msg_invis_silence;
   break;
  }
 }
 int state = 0;
 size_t maxlen = strlen(source);
 size_t pos = 0;
 /* Put the message characters in the buffer */
 /* XXX This logic should be used everywhere for pluralising strings */
 for (size_t i = 0; i < maxlen && pos < buflen - 1; i++) {
  char cur = source[i];
  /*
		 * The characters '[|]' switch parsing mode and are never output.
		 * The syntax is [singular|plural]
		 */
  if (state == 0 && cur == '[') {
   state = 1;
  } else if (state == 1 && cur == '|') {
   state = 2;
  } else if (state != 0 && cur == ']') {
   state = 0;
  } else if (state == 0 ||
    (state == 1 && do_plural == false) ||
    (state == 2 && do_plural == true)) {
   /* Copy the characters according to the mode */
   buf[pos++] = cur;
  }
 }
 /* We should always return to the normal state */
 assert(state == 0);
 /* Terminate the buffer */
 buf[pos] = 0;
}
/**
 * Accessor function - should we skip the monster name for this message type?
 */
static bool skip_subject(int msg_code)
{
 assert(msg_code >= 0);
 assert(msg_code < MON_MSG_MAX);
 return msg_repository[msg_code].omit_subject;
}
/**
 * Return a MSG_ type for the given message code (and monster)
 */
static int get_message_type(int msg_code, const struct monster_race *race)
{
 int type = msg_repository[msg_code].type;
 if (type == MSG_KILL) {
  /* Play a special sound if the monster was unique */
  if (rf_has(race->flags, RF_UNIQUE)) {
   if (race->base == lookup_monster_base("Morgoth")) {
    type = MSG_KILL_KING;
   } else {
    type = MSG_KILL_UNIQUE;
   }
  }
 }
 return type;
}
/**
 * Show the given monster message.
 */
static void show_message(struct monster_race_message *msg)
{
 char subject[60] = "";
 char body[60];
 /* Some messages don't require a monster name */
 if (!skip_subject(msg->msg_code)) {
  /* Get 'it ' or '3 monsters (offscreen) ' or '15000 snakes ' etc */
  get_subject(subject, sizeof(subject),
    msg->race,
    msg->count,
    msg->flags & 0x02,
    msg->flags & 0x01);
 }
 /* Get the message proper, corrected for singular/plural etc. */
 get_message_text(body, sizeof(body),
   msg->msg_code,
   msg->race,
   msg->count > 1);
 /* Show the message */
 msgt(get_message_type(msg->msg_code, msg->race),
   "%s%s",
   subject,
   body);
}
/**
 * Show and then cler all stacked monster messages.
 */
void show_monster_messages(void)
{
 for (int delay = 0; delay < 3; delay++) {
  for (int i = 0; i < size_mon_msg; i++) {
   struct monster_race_message *msg = &mon_msg[i];
   /* Skip irrelevant entries */
   if (msg->delay == delay) {
    show_message(msg);
   }
  }
 }
 /* Delete all the stacked messages and history */
 size_mon_msg = size_mon_hist = 0;
}
/**
 * \file mon-predicate.c
 * \brief Monster predicates
 *
 * Copyright (c) 1997-2007 Ben Harrison, James E. Wilson, Robert A. Koeneke
 * Copyright (c) 2017 Nick McConnell
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * ------------------------------------------------------------------------
 * Permanent monster properties
 * ------------------------------------------------------------------------ */
/**
 * Undead monsters
 */
bool monster_is_undead(const struct monster *mon)
{
 return rf_has(mon->race->flags, RF_UNDEAD);
}
/**
 * Nonliving monsters are immune to life drain
 */
bool monster_is_nonliving(const struct monster *mon)
{
 return (monster_is_undead(mon) || rf_has(mon->race->flags, RF_RAUKO) ||
   rf_has(mon->race->flags, RF_STONE) ||
   (mon->race->base == lookup_monster_base("deathblade")));
}
/**
 * Living monsters
 */
bool monster_is_living(const struct monster *mon)
{
 return !monster_is_nonliving(mon);
}
/**
 * Monster is invisible
 */
bool monster_is_invisible(const struct monster *mon)
{
 return rf_has(mon->race->flags, RF_INVISIBLE);
}
/**
 * Monster is unique
 */
bool monster_is_unique(const struct monster *mon)
{
 return rf_has(mon->race->flags, RF_UNIQUE);
}
/**
 * Monster is (or was) smart
 */
bool monster_is_smart(const struct monster *mon)
{
 return rf_has(mon->race->flags, RF_SMART);
}
/**
 * Monster has friends
 */
bool monster_has_friends(const struct monster *mon)
{
 return rf_has(mon->race->flags, RF_FRIEND) ||
  rf_has(mon->race->flags, RF_FRIENDS) ||
  rf_has(mon->race->flags, RF_ESCORT) ||
  rf_has(mon->race->flags, RF_ESCORTS);
}
/**
 * Monster has damaging breath
 */
bool monster_breathes(const struct monster *mon)
{
 bitflag breaths[RSF_SIZE];
 create_mon_spell_mask(breaths, RST_BREATH, RST_NONE);
 rsf_inter(breaths, mon->race->spell_flags);
 return rsf_is_empty(breaths) ? false : true;
}
/**
 * ------------------------------------------------------------------------
 * Temporary monster properties
 * ------------------------------------------------------------------------ */
/**
 * Monster is in the player's field of view
 */
bool monster_is_in_view(const struct monster *mon)
{
 return mflag_has(mon->mflag, MFLAG_VIEW);
}
/**
 * Monster is visible to the player
 */
bool monster_is_visible(const struct monster *mon)
{
 return mflag_has(mon->mflag, MFLAG_VISIBLE);
}
/**
 * Monster is currently heard by the listen ability
 */
bool monster_is_listened(const struct monster *mon)
{
 return mflag_has(mon->mflag, MFLAG_LISTENED);
}
/**
 * \file mon-spell.c
 * \brief Monster spell casting and selection
 *
 * Copyright (c) 2010-14 Chris Carr and Nick McConnell
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * ------------------------------------------------------------------------
 * Spell casting
 * ------------------------------------------------------------------------ */
typedef enum {
 SPELL_TAG_NONE,
 SPELL_TAG_NAME,
 SPELL_TAG_PRONOUN,
} spell_tag_t;
static spell_tag_t spell_tag_lookup(const char *tag)
{
 if (strncmp(tag, "name", 4) == 0)
  return SPELL_TAG_NAME;
 else if (strncmp(tag, "pronoun", 7) == 0)
  return SPELL_TAG_PRONOUN;
 else
  return SPELL_TAG_NONE;
}
/**
 * Lookup a race-specific message for a spell.
 *
 * \param r is the race.
 * \param s_idx is the spell index.
 * \param msg_type is the type of message.
 * \return the text of the message if there's a race-specific one or NULL if
 * there is not.
 */
static const char *find_alternate_spell_message(const struct monster_race *r,
  int s_idx, enum monster_altmsg_type msg_type)
{
 const struct monster_altmsg *am = r->spell_msgs;
 while (1) {
  if (!am) {
   return NULL;
  }
  if (am->index == s_idx && am->msg_type == msg_type) {
    return am->message;
  }
  am = am->next;
 }
}
/**
 * Print a monster spell message.
 *
 * We fill in the monster name and/or pronoun where necessary in
 * the message to replace instances of {name} or {pronoun}.
 */
static void spell_message(struct monster *mon,
        const struct monster_spell *spell,
        bool seen)
{
 const char punct[] = ".!?;:,'";
 char buf[1024] = "\0";
 const char *next;
 const char *s;
 const char *tag;
 const char *in_cursor;
 size_t end = 0;
 struct monster_spell_level *level = spell->level;
 bool smart = rf_has(mon->race->flags, RF_SMART);
 bool silence = player_is_singing(player, lookup_song("Silence"));
 bool is_leading;
 /* Get the right level of message */
 while (level->next && mon->race->spell_power >= level->next->power) {
  level = level->next;
 }
 /* Get the message */
 if (!seen) {
  in_cursor = find_alternate_spell_message(mon->race, spell->index,
             MON_ALTMSG_UNSEEN);
  if (in_cursor == NULL) {
   if (smart && (level->smart_blind_silence_message ||
        level->smart_blind_message)) {
    if (silence && level->smart_blind_silence_message) {
     in_cursor = level->smart_blind_silence_message;
    } else {
     in_cursor = level->smart_blind_message;
    }
   } else {
    if (silence && level->blind_silence_message) {
     in_cursor = level->blind_silence_message;
    } else {
     in_cursor = level->blind_message;
    }
   }
   if (in_cursor == NULL) {
    msg("No message-invis for monster spell %d "
     "cast by %s%s.  Please report this "
     "bug.", (int)spell->index,
     (silence) ? "silenced " : "",
     mon->race->name);
    return;
   }
  } else if (in_cursor[0] == '\0') {
   return;
  }
 } else {
  in_cursor = find_alternate_spell_message(mon->race, spell->index,
             MON_ALTMSG_SEEN);
  if (in_cursor == NULL) {
   if (smart && (level->smart_silence_message ||
        level->smart_message)) {
    if (silence && level->smart_silence_message) {
     in_cursor = level->smart_silence_message;
    } else {
     in_cursor = level->smart_message;
    }
   } else {
    if (silence && level->silence_message) {
     in_cursor = level->silence_message;
    } else {
     in_cursor = level->message;
    }
   }
   if (in_cursor == NULL) {
    msg("No message-vis for monster spell %d "
     "cast by %s%s.  Please report this "
     "bug.", (int)spell->index,
     (silence) ? "silenced " : "",
     mon->race->name);
    return;
   }
  } else if (in_cursor[0] == '\0') {
   return;
  }
 }
 next = strchr(in_cursor, '{');
 is_leading = (next == in_cursor);
 while (next) {
  /* Copy the text leading up to this { */
  strnfcat(buf, 1024, &end, "%.*s", (int) (next - in_cursor),
   in_cursor);
  s = next + 1;
  while (*s && isalpha((unsigned char) *s)) s++;
  /* Valid tag */
  if (*s == '}') {
   /* Start the tag after the { */
   tag = next + 1;
   in_cursor = s + 1;
   switch (spell_tag_lookup(tag)) {
    case SPELL_TAG_NAME: {
     char m_name[80];
     int mdesc_mode = (MDESC_IND_HID |
      MDESC_PRO_HID);
     if (is_leading) {
      mdesc_mode |= MDESC_CAPITAL;
     }
     if (!strchr(punct, *in_cursor)) {
      mdesc_mode |= MDESC_COMMA;
     }
     monster_desc(m_name, sizeof(m_name),
      mon, mdesc_mode);
     strnfcat(buf, sizeof(buf), &end, "%s",
      m_name);
     break;
    }
    case SPELL_TAG_PRONOUN: {
     char m_poss[80];
     /* Get the monster possessive ("his"/"her"/"its") */
     monster_desc(m_poss, sizeof(m_poss), mon, MDESC_PRO_VIS | MDESC_POSS);
     strnfcat(buf, sizeof(buf), &end, "%s",
      m_poss);
     break;
    }
    default: {
     break;
    }
   }
  } else {
   /* An invalid tag, skip it */
   in_cursor = next + 1;
  }
  next = strchr(in_cursor, '{');
  is_leading = false;
 }
 strnfcat(buf, 1024, &end, "%s", in_cursor);
 msgt(spell->msgt, "%s", buf);
}
/**
 * Return the chance of a monster casting a spell this turn
 */
int monster_cast_chance(struct monster *mon)
{
 int chance = mon->race->freq_ranged;
 /* Not allowed to cast spells */
 if (!chance) return 0;
 /* Certain conditions always cause a monster to always cast */
 if (mflag_has(mon->mflag, MFLAG_ALWAYS_CAST)) chance = 100;
 /* Cannot use ranged attacks when confused. */
 if (mon->m_timed[MON_TMD_CONF]) chance = 0;
 /* Cannot use ranged attacks during the truce. */
 if (player->truce) chance = 0;
 /* Stunned monsters use ranged attacks half as often. */
 if (mon->m_timed[MON_TMD_STUN]) chance /= 2;
 return chance;
}
const struct monster_spell *monster_spell_by_index(int index)
{
 const struct monster_spell *spell = monster_spells;
 while (spell) {
  if (spell->index == index)
   break;
  spell = spell->next;
 }
 return spell;
}
/**
 * Check if a spell effect has been saved against, learn any object property
 * that may have helped
 */
static bool spell_check_for_save(const struct monster_spell *spell)
{
 struct effect *effect = spell->effect;
 bool save = false;
 while (effect) {
  if ((effect->index == EF_TIMED_INC) ||
   (effect->index == EF_TIMED_INC_NO_RES)) {
   /* Timed effects */
   save = player_inc_check(player, effect->subtype, false);
  } else {
   /* Direct call to player_saving_throw() */
   struct monster *mon = cave->mon_current > 0 ?
    cave_monster(cave, cave->mon_current) : NULL;
   save = player_saving_throw(player, mon, 0);
  }
  effect = effect->next;
 }
 return save;
}
/**
 * Process a monster spell 
 *
 * \param index is the monster spell flag (RSF_FOO)
 * \param mon is the attacking monster
 * \param seen is whether the player can see the monster at this moment
 */
void do_mon_spell(int index, struct monster *mon, bool seen)
{
 const struct monster_spell *spell = monster_spell_by_index(index);
 struct monster_spell_level *level = spell->level;
 bool ident = false;
 /* Hacks for SCARE spell - NRM */
 bool afraid = player->timed[TMD_AFRAID] && (spell->index == RSF_SCARE);
 if (spell->effect_xtra && seen && one_in_(2)) seen = false;
 /* Tell the player what's going on */
 disturb(player, spell->disturb_stealth);
 spell_message(mon, spell, seen);
 /* Get the right level of save message */
 while (level->next && mon->race->spell_power >= level->next->power) {
  level = level->next;
 }
 /* Extra effect - only for SCARE spell currently */
 if (spell->effect_xtra && !seen) {
  effect_do(spell->effect_xtra, source_monster(mon->midx), NULL,
      &ident, true, 0, NULL);
 }
 /* Try a saving throw if available */
 if (level->save_message && spell_check_for_save(spell) && !afraid) {
  msg("%s", level->save_message);
 } else {
  if (level->no_save_message) {
   msg("%s", level->no_save_message);
  }
  effect_do(spell->effect, source_monster(mon->midx), NULL, &ident,
      true, 0, NULL);
 }
}
/**
 * ------------------------------------------------------------------------
 * Spell selection
 * ------------------------------------------------------------------------ */
/**
 * Types of monster spells used for spell selection.
 */
static const struct mon_spell_info {
 uint16_t index; /* Numerical index (RSF_FOO) */
 int type; /* Type bitflag */
} mon_spell_types[] = {
/**
 * \file list-mon-spells.h
 * \brief List of monster spell flags 
 *
 * Flags below start from 0 on line 13, so a flag's sequence number is its line
 * number minus 13.
 *
 * Fields:
 * name - spell name
 * type - spell type
 */
/* 	name		type*/
{ RSF_NONE, 0 },
{ RSF_ARROW1, RST_INNATE | RST_ARCHERY | RST_DISTANT },
{ RSF_ARROW2, RST_INNATE | RST_ARCHERY | RST_DISTANT },
{ RSF_BOULDER, RST_INNATE | RST_ARCHERY | RST_DISTANT },
{ RSF_BR_FIRE, RST_BREATH },
{ RSF_BR_COLD, RST_BREATH },
{ RSF_BR_POIS, RST_BREATH },
{ RSF_BR_DARK, RST_BREATH },
{ RSF_EARTHQUAKE, RST_SPELL | RST_DISTANT },
{ RSF_SHRIEK, RST_SPELL },
{ RSF_SCREECH, RST_SPELL },
{ RSF_DARKNESS, RST_SPELL },
{ RSF_FORGET, RST_SPELL },
{ RSF_SCARE, RST_SPELL },
{ RSF_CONF, RST_SPELL },
{ RSF_HOLD, RST_SPELL },
{ RSF_SLOW, RST_SPELL },
{ RSF_SNG_BIND, RST_SONG },
{ RSF_SNG_PIERCE, RST_SONG },
{ RSF_SNG_OATHS, RST_SONG },
{ RSF_MAX, 0 },

};
static bool mon_spell_is_valid(int index)
{
 return index > RSF_NONE && index < RSF_MAX;
}
static bool mon_spell_is_archery(int index)
{
 return (mon_spell_types[index].type & RST_ARCHERY) ? true : false;
}
static bool mon_spell_is_breath(int index)
{
 return (mon_spell_types[index].type & RST_BREATH) ? true : false;
}
static bool mon_spell_is_innate(int index)
{
 return (mon_spell_types[index].type & RST_INNATE) ? true : false;
}
static bool mon_spell_is_distant(int index)
{
 return (mon_spell_types[index].type & RST_DISTANT) ? true : false;
}
static bool mon_spell_is_song(int index)
{
 return (mon_spell_types[index].type & RST_SONG) ? true : false;
}
/**
 * Given the monster, *mon, and cave *c, set *dist to the distance to the
 * monster's target and *grid to the target's location.  Either dist or grid
 * may be NULL if that value is not needed.
 */
static void monster_get_target_dist_grid(struct monster *mon, int *dist,
           struct loc *grid)
{
 if (dist) {
  *dist = mon->cdis;
 }
 if (grid) {
  *grid = player->grid;
 }
}
/**
 * Remove the "bad" spells from a spell list.
 *
 * This includes spells which are too expensive for the monster to cast and
 * spells which have no benefit.
 */
void remove_bad_spells(struct monster *mon, bitflag f[RSF_SIZE])
{
 int tdist;
 struct loc tgrid;
 int path, i;
 /* Get distance from the player */
 monster_get_target_dist_grid(mon, &tdist, &tgrid);
 /* Do we have the player in sight at all? */
 path = projectable(cave, mon->grid, tgrid, PROJECT_STOP);
 if (path == PROJECT_PATH_NO) {
  rsf_wipe(f);
  return;
 }
 /* Iterate through the spells */
 for (i = FLAG_START; i != FLAG_END; i = rsf_next(f, i + 1)) {
  const struct monster_spell *spell;
  /* Do we even have this spell ? */
  if (!rsf_has(f, i)) continue;
  spell = monster_spell_by_index(i);
  /* Check for a clean bolt shot */
  if (mon_spell_is_archery(i) && (path == PROJECT_PATH_NOT_CLEAR)) {
   rsf_off(f, i);
  }
  /* Remove unaffordable spells */
  if (spell->mana > mon->mana) {
   rsf_off(f, i);
  }
  /*
		 * A mindless monster does no further checking if this spell
		 * should be cast.
		 */
  if (rf_has(mon->race->flags, RF_MINDLESS)) {
   continue;
  }
  /* Some attacks have limited range */
  if (tdist > spell->max_range) {
   rsf_off(f, i);
  }
  /* Make sure that missile attacks are never done at melee range or
		 * when afraid */
  if (((tdist == 1) || (mon->stance == STANCE_FLEEING) || player->truce)
    && (mon_spell_is_distant(i))) {
   rsf_off(f, i);
  }
  /* Make sure that fleeing monsters never use breath attacks */
  if ((mon->stance == STANCE_FLEEING) && mon_spell_is_breath(i)) {
   rsf_off(f, i);
  }
  /* No songs during the truce, or by Morgoth until uncrowned */
  if (mon_spell_is_song(i)) {
   const struct artifact *crown = lookup_artifact_name("of Morgoth");
   if (player->truce) {
    rsf_off(f, i);
   }
   if (rf_has(mon->race->flags, RF_QUESTOR) &&
     !is_artifact_created(crown)) {
    rsf_off(f, i);
   }
  }
  /* Earthquake is only useful if there is no monster in the
		 * smashed square */
  if (i == RSF_EARTHQUAKE) {
   struct loc grid = player->grid;
   if (mon->grid.y > grid.y) {
    grid.y--;
   } else if (mon->grid.y < grid.y) {
    grid.y++;
   }
   if (mon->grid.x > grid.x) {
    grid.x--;
   } else if (mon->grid.x < grid.x) {
    grid.x++;
   }
   if (square_monster(cave, grid)) {
    rsf_off(f, i);
   }
  }
  /* Darkness is only useful if the player's square is lit */
  if ((i == RSF_DARKNESS) && !square_islit(cave, player->grid)) {
   rsf_off(f, i);
  }
 }
}
/**
 * Create a mask of monster spell flags of a specific type.
 *
 * \param f is the flag array we're filling
 * \param ... is the list of flags we're looking for
 *
 * N.B. RST_NONE must be the last item in the ... list
 */
void create_mon_spell_mask(bitflag *f, ...)
{
 const struct mon_spell_info *rs;
 int i;
 va_list args;
 rsf_wipe(f);
 va_start(args, f);
 /* Process each type in the va_args */
    for (i = va_arg(args, int); i != RST_NONE; i = va_arg(args, int)) {
  for (rs = mon_spell_types; rs->index < RSF_MAX; rs++) {
   if (rs->type & i) {
    rsf_on(f, rs->index);
   }
  }
 }
 va_end(args);
 return;
}
const char *mon_spell_lore_description(int index,
            const struct monster_race *race)
{
 if (mon_spell_is_valid(index)) {
  const struct monster_spell *spell = monster_spell_by_index(index);
  /* Get the right level of description */
  struct monster_spell_level *level = spell->level;
  while (level->next && race->spell_power >= level->next->power) {
   level = level->next;
  }
  return level->lore_desc;
 } else {
  return "";
 }
}
random_value mon_spell_lore_damage(int index)
{
 random_value val = { 0, 0, 0, 0 };
 if (mon_spell_is_valid(index) &&
  (mon_spell_is_innate(index) || mon_spell_is_breath(index))) {
  const struct monster_spell *spell = monster_spell_by_index(index);
  if (spell->effect->dice != NULL) {
   (void) dice_roll(spell->effect->dice, &val);
  }
 }
 return val;
}
/**
 * Probably breaks with negative power, but eh, four other things
 * probably break too with negative power.
 */
int mon_spell_lore_archery_bonus(int index, const struct monster_race *race)
{
    int power = 0;
    if (mon_spell_is_valid(index) && mon_spell_is_archery(index)) {
        power = race->spell_power;
    }
    return power;
}
/**
 * \file mon-summon.c
 * \brief Monster summoning
 *
 * Copyright (c) 1997-2007 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * The "type" of the current "summon specific"
 */
static int summon_specific_type = 0;
/**
 * Maximum number of summon types
 */
static int summon_max = 0;
/**
 * The kin base for S_KIN
 */
struct monster_base *kin_base;
/**
 * The summon array
 */
struct summon *summons;
static const char *mon_race_flags[] =
{
/**
 * \file list-mon-race-flags.h
 * \brief monster race flags
 *
 */
/* symbol		type			descr */
"NONE",
"UNIQUE",
"QUESTOR",
"MALE",
"FEMALE",
"NAME_COMMA",
"SPECIAL_GEN",
"CHAR_CLEAR",
"ATTR_MULTI",
"ATTR_FLICKER",
"FORCE_DEPTH",
"INVISIBLE",
"MULTIPLY",
"REGENERATE",
"NO_CRIT",
"RES_CRIT",
"FRIEND",
"FRIENDS",
"ESCORT",
"ESCORTS",
"UNIQUE_FRIEND",
"NEVER_MOVE",
"HIDDEN_MOVE",
"RAND_25",
"RAND_50",
"GLOW",
"TERRITORIAL",
"SHORT_SIGHTED",
"MINDLESS",
"SMART",
"CRUEL_BLOW",
"EXCHANGE",
"RIPOSTE",
"FLANKING",
"CHARGE",
"ELFBANE",
"KNOCK_BACK",
"CRIPPLING",
"OPPORTUNIST",
"ZONE",
"DROP_33",
"DROP_100",
"DROP_1D2",
"DROP_2D2",
"DROP_3D2",
"DROP_4D2",
"DROP_GOOD",
"DROP_GREAT",
"FLYING",
"PASS_DOOR",
"UNLOCK_DOOR",
"OPEN_DOOR",
"BASH_DOOR",
"PASS_WALL",
"KILL_WALL",
"TUNNEL_WALL",
"TAKE_ITEM",
"KILL_ITEM",
"ORC",
"TROLL",
"SERPENT",
"DRAGON",
"RAUKO",
"SPIDER",
"WOLF",
"UNDEAD",
"HURT_LIGHT",
"STONE",
"HURT_FIRE",
"HURT_COLD",
"RES_FIRE",
"RES_COLD",
"RES_POIS",
"NO_FEAR",
"NO_STUN",
"NO_CONF",
"NO_SLEEP",
"NO_SLOW",
/* end flags */

 NULL
};
/**
 * ------------------------------------------------------------------------
 * Initialize monster summon types
 * ------------------------------------------------------------------------ */
static enum parser_error parse_summon_name(struct parser *p) {
 struct summon *h = parser_priv(p);
 struct summon *s = mem_zalloc(sizeof *s);
 s->next = h;
 parser_setpriv(p, s);
 s->name = string_make(parser_getstr(p, "name"));
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_summon_message_type(struct parser *p) {
 struct summon *s = parser_priv(p);
 int msg_index;
 const char *type;
 assert(s);
 type = parser_getsym(p, "type");
 msg_index = message_lookup_by_name(type);
 if (msg_index < 0)
  return PARSE_ERROR_INVALID_MESSAGE;
 s->message_type = msg_index;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_summon_unique(struct parser *p) {
 struct summon *s = parser_priv(p);
 int unique = 0;
 assert(s);
 unique = parser_getint(p, "allowed");
 if (unique) {
  s->unique_allowed = true;
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_summon_base(struct parser *p) {
 struct summon *s = parser_priv(p);
 struct monster_base *base;
 struct monster_base_list *b = mem_zalloc(sizeof(*b));
 assert(s);
 base = lookup_monster_base(parser_getsym(p, "base"));
 if (base == NULL) {
  mem_free(b);
  return PARSE_ERROR_INVALID_MONSTER_BASE;
 }
 b->base = base;
 b->next = s->bases;
 s->bases = b;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_summon_race_flag(struct parser *p) {
 struct summon *s = parser_priv(p);
 int flag;
 assert(s);
 flag = lookup_flag(mon_race_flags, parser_getsym(p, "flag"));
 if (flag == FLAG_END) {
  return PARSE_ERROR_INVALID_FLAG;
 } else {
  s->race_flag = flag;
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_summon_fallback(struct parser *p) {
 struct summon *s = parser_priv(p);
 assert(s);
 s->fallback_name = string_make(parser_getstr(p, "fallback"));
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_summon_desc(struct parser *p) {
 struct summon *s = parser_priv(p);
 assert(s);
 s->desc = string_make(parser_getstr(p, "desc"));
 return PARSE_ERROR_NONE;
}
static struct parser *init_parse_summon(void) {
 struct parser *p = parser_new();
 parser_setpriv(p, NULL);
 parser_reg(p, "name str name", parse_summon_name);
 parser_reg(p, "msgt sym type", parse_summon_message_type);
 parser_reg(p, "uniques int allowed", parse_summon_unique);
 parser_reg(p, "base sym base", parse_summon_base);
 parser_reg(p, "race-flag sym flag", parse_summon_race_flag);
 parser_reg(p, "fallback str fallback", parse_summon_fallback);
 parser_reg(p, "desc str desc", parse_summon_desc);
 return p;
}
static errr run_parse_summon(struct parser *p) {
 return parse_file_quit_not_found(p, "summon");
}
static errr finish_parse_summon(struct parser *p) {
 struct summon *summon, *next;
 int index;
 /* Count the entries */
 summon_max = 0;
 summon = parser_priv(p);
 while (summon) {
  summon_max++;
  summon = summon->next;
 }
 /* Allocate the direct access list and copy the data to it */
 summons = mem_zalloc((summon_max + 1) * sizeof(*summon));
 index = summon_max - 1;
 for (summon = parser_priv(p); summon; summon = next, index--) {
  memcpy(&summons[index], summon, sizeof(*summon));
  next = summon->next;
  summons[index].next = NULL;
  mem_free(summon);
 }
 summon_max += 1;
 /* Add indices of fallback summons */
 for (index = 0; index < summon_max; index++) {
  char *name = summons[index].fallback_name;
  summons[index].fallback = summon_name_to_idx(name);
 }
 parser_destroy(p);
 return 0;
}
static void cleanup_summon(void)
{
 int idx;
 for (idx = 0; idx < summon_max; idx++) {
  struct monster_base_list *s = summons[idx].bases;
  while (s) {
   struct monster_base_list *next = s->next;
   mem_free(s);
   s = next;
  }
  string_free(summons[idx].desc);
  string_free(summons[idx].fallback_name);
  string_free(summons[idx].name);
 }
 mem_free(summons);
}
struct file_parser summon_parser = {
 "summon",
 init_parse_summon,
 run_parse_summon,
 finish_parse_summon,
 cleanup_summon
};
/**
 * Lookup function to translate names of summons to indices
 */
int summon_name_to_idx(const char *name)
{
    int i;
    for (i = 0; i < summon_max; i++) {
        if (name && summons[i].name && streq(name, summons[i].name)) {
            return i;
  }
    }
    return -1;
}
/**
 * The message type for a particular summon
 */
int summon_message_type(int summon_type)
{
 return summons[summon_type].message_type;
}
/**
 * The fallback type for a particular summon
 */
int summon_fallback_type(int summon_type)
{
 return summons[summon_type].fallback;
}
/**
 * The description for a particular summon
 */
const char *summon_desc(int type)
{
 if (type < 0 || type >= summon_max)
  return 0;
 return summons[type].desc;
}
/**
 * Decide if a monster race is "okay" to summon.
 *
 * Compares the given monster to the monster type specified by
 * summon_specific_type. Returns true if the monster is eligible to
 * be summoned, false otherwise. 
 */
static bool summon_specific_okay(struct monster_race *race)
{
 struct summon *summon = &summons[summon_specific_type];
 struct monster_base_list *bases = summon->bases;
 bool unique = rf_has(race->flags, RF_UNIQUE);
 /* Forbid uniques? */
 if (!summon->unique_allowed && unique) {
  return false;
 }
 /* A valid base and no match means disallowed */
 while (bases) {
  if (race->base == bases->base) break;
  if (bases->next == NULL) return false;
  bases = bases->next;
 }
 /* A valid race flag and no match means disallowed */
 if (summon->race_flag && !rf_has(race->flags, summon->race_flag)) {
  return false;
 }
 /* Special case - summon kin */
 if (summon_specific_type == summon_name_to_idx("KIN")) {
  return (!unique && race->base == kin_base);
 }
 /* If we made it here, we're fine */
 return true;
}
/**
 * Places a monster (of the specified "type") near the given
 * location.  Return the siummoned monster's level iff a monster was
 * actually summoned.
 *
 * We will attempt to place the monster up to 10 times before giving up.
 *
 * This function takes the "monster level"
 * of the summoning monster as a parameter, and use that, along with
 * the current dungeon level, to help determine the level of the
 * desired monster.  Note that this is an upper bound, and also
 * tends to "prefer" monsters of that level.  Currently, we use
 * the average of the dungeon and monster levels, and then add
 * five to allow slight increases in monster power.
 *
 * Note that we use the new "monster allocation table" creation code
 * to restrict the "get_mon_num()" function to the set of "legal"
 * monsters, making this function much faster and more reliable.
 *
 * Note that this function may not succeed, though this is very rare.
 */
int summon_specific(struct loc grid, int lev, int type)
{
 int d;
 struct loc near = grid;
 struct monster_race *race;
 struct monster_group_info info = { 0, 0 };
 /* Look for a location, allow up to 4 squares away */
 for (d = 1; d < 5; ++d) {
  /* Pick a location. */
  if (scatter_ext(cave, &near, 1, grid, d, true,
    square_allows_summon) > 0) break;
 }
 /* Failure */
 if (d == 5) return 0;
 /* Save the "summon" type */
 summon_specific_type = type;
 /* Prepare allocation table */
 get_mon_num_prep(summon_specific_okay);
 /* Pick a monster, using the level calculation */
 race = get_mon_num(lev, false, true, false);
 /* Prepare allocation table */
 get_mon_num_prep(NULL);
 /* Handle failure */
 if (!race) return 0;
 /* Attempt to place the monster (awake, don't allow groups) */
 if (!place_new_monster(cave, near, race, false, false, info,
         ORIGIN_DROP_SUMMON)) {
  return 0;
 }
 /* Success, return the number of monsters */
 return 1;
}
/**
 * \file mon-timed.c
 * \brief Monster timed teffects.
 *
 * Copyright (c) 1997-2007 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * The different ways increases can stack - see mon_inc_timed()
 */
enum stack_type {
 STACK_NO,
 STACK_INCR,
 STACK_MAX
};
/**
 * Monster timed teffects.
 */
static struct mon_timed_effect {
 const char *name;
 bool gets_save;
 enum stack_type stacking;
 int flag_resist;
 int max_timer;
 int message_begin;
 int message_end;
 int message_increase;
} teffects[] = {
/**
 * \file list-mon-timed.h
 * \brief Monster timed flags
 *
 * Fields:
 * - name         - the index name for this timed flag
 * - save         - does this effect get a saving throw?
 * - stack        - how does this effect stack? either NO, MAX, or INCR
 * - resist_flag  - monsters with this monster race flag will resist this effect
 * - time         - maximum that the timer for this effect can reach (must be below 32767)
 * (messages)
 * - message_begin - the argument to the message code when the effect begins
 * - message_end - the argument to the message code when the effect ends
 * - message_increase - the argument to the message code when the effect increases
 */
/*     name  	save  	stack  	resist_flag  	time  	message_begin           message_end             message_increase       */
{ "STUN", false, STACK_MAX, RF_NO_STUN, 200, MON_MSG_DAZED, MON_MSG_NOT_DAZED, MON_MSG_MORE_DAZED },
{ "CONF", true, STACK_MAX, RF_NO_CONF, 200, MON_MSG_CONFUSED, MON_MSG_NOT_CONFUSED, MON_MSG_MORE_CONFUSED },
{ "SLOW", true, STACK_INCR, RF_NO_SLOW, 5000, MON_MSG_SLOWED, MON_MSG_NOT_SLOWED, MON_MSG_MORE_SLOWED },
{ "FAST", false, STACK_INCR, 0, 5000, MON_MSG_HASTED, MON_MSG_NOT_HASTED, MON_MSG_MORE_HASTED },
{ "MAX", true, STACK_INCR, 0, 0, 0, 0, 0 },

};
/**
 * Find the timed monster effect with the name `name`.
 *
 * Returns -1 on failure.
 */
int mon_timed_name_to_idx(const char *name)
{
    for (size_t i = 0; i < MON_TMD_MAX; i++) {
        if (streq(name, teffects[i].name))
            return i;
    }
    return -1;
}
/**
 * Attempts to set the timer of the given monster effect to `timer`.
 *
 * Checks to see if the monster resists the effect, using does_resist().
 * If not, the effect is set to `timer` turns. If `timer` is 0, or if the
 * effect timer was 0, or if MON_TMD_FLG_NOTIFY is set in `flag`, then a
 * message is printed, unless MON_TMD_FLG_NOMESSAGE is set in `flag`.
 *
 * Set a timed monster event to 'v'.  Give messages if the right flags are set.
 * Check if the monster is able to resist the spell.  Mark the lore.
 *
 * Returns true if the monster was affected, false if not.
 */
static bool mon_set_timed(struct monster *mon,
  int effect_type,
  int timer,
  int flag)
{
 assert(mon != NULL);
 assert(mon->race != NULL);
 assert(effect_type >= 0);
 assert(effect_type < MON_TMD_MAX);
 assert(timer >= 0);
 struct mon_timed_effect *effect = &teffects[effect_type];
 int m_note = 0;
 int old_timer = mon->m_timed[effect_type];
 /* Limit time of effect */
 if (timer > effect->max_timer) {
  timer = effect->max_timer;
 }
 /* No change */
 if (old_timer == timer) {
  return false;
 } else if (timer == 0) {
  /* Turning off, usually mention */
  m_note = effect->message_end;
  flag |= MON_TMD_FLG_NOTIFY;
 } else if (old_timer == 0) {
  /* Turning on, usually mention */
  m_note = effect->message_begin;
  flag |= MON_TMD_FLG_NOTIFY;
 } else if (timer > old_timer) {
  /* Different message for increases, but don't automatically mention. */
  m_note = effect->message_increase;
 }
 /* Set the timer */
 mon->m_timed[effect_type] = timer;
 calc_monster_speed(mon);
 /* Print a message if there is one, if the effect allows for it, and if
	 * either the monster is visible, or we're trying to ID something */
 if (m_note &&
  !(flag & MON_TMD_FLG_NOMESSAGE) &&
  (flag & MON_TMD_FLG_NOTIFY)
  && monster_is_visible(mon)) {
   add_monster_message(mon, m_note, true);
 }
 /* Update the visuals, as appropriate. */
 if (player->upkeep->health_who == mon)
  player->upkeep->redraw |= (PR_HEALTH);
 player->upkeep->redraw |= (PR_MONLIST);
 return true;
}
/** Minimum number of turns a new timed effect can last */
/**
 * Increases the timed effect `effect_type` by `timer`.
 *
 * Calculates the new timer, then passes that to mon_set_timed().
 * Note that each effect has a maximum number of turns it can be active for.
 * If this function would put an effect timer over that cap, it sets it for
 * that cap instead.
 *
 * Returns true if the monster's timer changed.
 */
bool mon_inc_timed(struct monster *mon, int effect_type, int timer, int flag)
{
 assert(effect_type >= 0);
 assert(effect_type < MON_TMD_MAX);
 assert(timer > 0); /* For negative amounts, we use mon_dec_timed instead */
 struct mon_timed_effect *effect = &teffects[effect_type];
 int new_value = timer;
 /* Make it last for a mimimum # of turns if it is a new effect */
 if (mon->m_timed[effect_type] == 0 && timer < 2) {
  timer = 2;
 }
 /* Stack teffects correctly */
 switch (effect->stacking) {
  case STACK_NO: {
   new_value = mon->m_timed[effect_type];
   if (new_value == 0) {
    new_value = timer;
   }
   break;
  }
  case STACK_MAX: {
   new_value = MAX(mon->m_timed[effect_type], timer);
   break;
  }
  case STACK_INCR: {
   new_value = mon->m_timed[effect_type] + timer;
   break;
  }
 }
 return mon_set_timed(mon, effect_type, new_value, flag);
}
/**
 * Decreases the timed effect `effect_type` by `timer`.
 *
 * Calculates the new timer, then passes that to mon_set_timed().
 * If a timer would be set to a negative number, it is set to 0 instead.
 * Note that decreasing a timed effect should never fail.
 *
 * Returns true if the monster's timer changed.
 */
bool mon_dec_timed(struct monster *mon, int effect_type, int timer, int flag)
{
 assert(effect_type >= 0);
 assert(effect_type < MON_TMD_MAX);
 assert(timer > 0); /* For negative amounts, we use mon_inc_timed instead */
 int new_level = mon->m_timed[effect_type] - timer;
 if (new_level < 0) {
  new_level = 0;
 }
 return mon_set_timed(mon, effect_type, new_level, flag);
}
/**
 * Clears the timed effect `effect_type`.
 *
 * Returns true if the monster's timer was changed.
 */
bool mon_clear_timed(struct monster *mon, int effect_type, int flag)
{
 assert(effect_type >= 0);
 assert(effect_type < MON_TMD_MAX);
 if (mon->m_timed[effect_type] == 0) {
  return false;
 } else {
  return mon_set_timed(mon, effect_type, 0, flag);
 }
}
/**
 * \file mon-util.c
 * \brief Monster manipulation utilities.
 *
 * Copyright (c) 1997-2007 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * ------------------------------------------------------------------------
 * Lore utilities
 * ------------------------------------------------------------------------ */
static const struct monster_flag monster_flag_table[] =
{
/**
 * \file list-mon-race-flags.h
 * \brief monster race flags
 *
 */
/* symbol		type			descr */
{ RF_NONE, RFT_NONE, "" },
{ RF_UNIQUE, RFT_OBV, "" },
{ RF_QUESTOR, RFT_OBV, "" },
{ RF_MALE, RFT_OBV, "" },
{ RF_FEMALE, RFT_OBV, "" },
{ RF_NAME_COMMA, RFT_OBV, "" },
{ RF_SPECIAL_GEN, RFT_OBV, "" },
{ RF_CHAR_CLEAR, RFT_DISP, "" },
{ RF_ATTR_MULTI, RFT_DISP, "" },
{ RF_ATTR_FLICKER, RFT_DISP, "" },
{ RF_FORCE_DEPTH, RFT_GEN, "" },
{ RF_INVISIBLE, RFT_NOTE, "is very difficult to see" },
{ RF_MULTIPLY, RFT_NOTE, "breeds explosively" },
{ RF_REGENERATE, RFT_NOTE, "regenerates quickly" },
{ RF_NO_CRIT, RFT_NOTE, "cannot be critically hit" },
{ RF_RES_CRIT, RFT_NOTE, "is resistant to critical hits" },
{ RF_FRIEND, RFT_GROUP, "sometimes appears in groups" },
{ RF_FRIENDS, RFT_GROUP, "usually appears in groups" },
{ RF_ESCORT, RFT_GROUP, "usually appears with escorts" },
{ RF_ESCORTS, RFT_GROUP, "usually appears with many escorts" },
{ RF_UNIQUE_FRIEND, RFT_BEHAV, "" },
{ RF_NEVER_MOVE, RFT_BEHAV, "" },
{ RF_HIDDEN_MOVE, RFT_BEHAV, "" },
{ RF_RAND_25, RFT_BEHAV, "" },
{ RF_RAND_50, RFT_BEHAV, "" },
{ RF_GLOW, RFT_BEHAV, "" },
{ RF_TERRITORIAL, RFT_BEHAV, "" },
{ RF_SHORT_SIGHTED, RFT_BEHAV, "" },
{ RF_MINDLESS, RFT_MIND, "mindless" },
{ RF_SMART, RFT_MIND, "intelligent" },
{ RF_CRUEL_BLOW, RFT_ABIL, "cruel blow" },
{ RF_EXCHANGE, RFT_ABIL, "exchange places" },
{ RF_RIPOSTE, RFT_ABIL, "riposte" },
{ RF_FLANKING, RFT_ABIL, "flanking" },
{ RF_CHARGE, RFT_ABIL, "charge" },
{ RF_ELFBANE, RFT_ABIL_OBV, "elf-bane" },
{ RF_KNOCK_BACK, RFT_ABIL, "knock back" },
{ RF_CRIPPLING, RFT_ABIL, "crippling shot" },
{ RF_OPPORTUNIST, RFT_ABIL, "opportunist" },
{ RF_ZONE, RFT_ABIL, "zone of control" },
{ RF_DROP_33, RFT_DROP, "" },
{ RF_DROP_100, RFT_DROP, "" },
{ RF_DROP_1D2, RFT_DROP, "" },
{ RF_DROP_2D2, RFT_DROP, "" },
{ RF_DROP_3D2, RFT_DROP, "" },
{ RF_DROP_4D2, RFT_DROP, "" },
{ RF_DROP_GOOD, RFT_DROP, "" },
{ RF_DROP_GREAT, RFT_DROP, "" },
{ RF_FLYING, RFT_MOVE, "fly" },
{ RF_PASS_DOOR, RFT_MOVE, "pass through doors" },
{ RF_UNLOCK_DOOR, RFT_MOVE, "unlock doors" },
{ RF_OPEN_DOOR, RFT_MOVE, "open doors" },
{ RF_BASH_DOOR, RFT_MOVE, "bash down doors" },
{ RF_PASS_WALL, RFT_MOVE, "pass through walls" },
{ RF_KILL_WALL, RFT_MOVE, "bore through walls" },
{ RF_TUNNEL_WALL, RFT_MOVE, "tunnel through walls" },
{ RF_TAKE_ITEM, RFT_MOVE, "pick up objects" },
{ RF_KILL_ITEM, RFT_MOVE, "destroy objects" },
{ RF_ORC, RFT_RACE_N, "orc" },
{ RF_TROLL, RFT_RACE_N, "troll" },
{ RF_SERPENT, RFT_RACE_N, "serpent" },
{ RF_DRAGON, RFT_RACE_N, "dragon" },
{ RF_RAUKO, RFT_RACE_N, "rauko" },
{ RF_SPIDER, RFT_RACE_N, "spider" },
{ RF_WOLF, RFT_RACE_N, "wolf" },
{ RF_UNDEAD, RFT_RACE_A, "undead" },
{ RF_HURT_LIGHT, RFT_VULN, "bright light" },
{ RF_STONE, RFT_VULN, "shattering" },
{ RF_HURT_FIRE, RFT_VULN_I, "fire" },
{ RF_HURT_COLD, RFT_VULN_I, "cold" },
{ RF_RES_FIRE, RFT_RES, "fire" },
{ RF_RES_COLD, RFT_RES, "cold" },
{ RF_RES_POIS, RFT_RES, "poison" },
{ RF_NO_FEAR, RFT_PROT, "frightened" },
{ RF_NO_STUN, RFT_PROT, "stunned" },
{ RF_NO_CONF, RFT_PROT, "confused" },
{ RF_NO_SLEEP, RFT_PROT, "put to sleep" },
{ RF_NO_SLOW, RFT_PROT, "slowed" },
/* end flags */

 {RF_MAX, 0, NULL}
};
/**
 * Return a description for the given monster race flag.
 *
 * Returns an empty string for an out-of-range flag.
 *
 * \param flag is one of the RF_ flags.
 */
const char *describe_race_flag(int flag)
{
 const struct monster_flag *rf = &monster_flag_table[flag];
 if (flag <= RF_NONE || flag >= RF_MAX)
  return "";
 return rf->desc;
}
/**
 * Create a mask of monster flags of a specific type.
 *
 * \param f is the flag array we're filling
 * \param ... is the list of flags we're looking for
 *
 * N.B. RFT_MAX must be the last item in the ... list
 */
void create_mon_flag_mask(bitflag *f, ...)
{
 const struct monster_flag *rf;
 int i;
 va_list args;
 rf_wipe(f);
 va_start(args, f);
 /* Process each type in the va_args */
    for (i = va_arg(args, int); i != RFT_MAX; i = va_arg(args, int)) {
  for (rf = monster_flag_table; rf->index < RF_MAX; rf++)
   if (rf->type == i)
    rf_on(f, rf->index);
 }
 va_end(args);
 return;
}
/**
 * ------------------------------------------------------------------------
 * Lookup utilities
 * ------------------------------------------------------------------------ */
/**
 * Returns the monster with the given name. If no monster has the exact name
 * given, returns the first monster with the given name as a (case-insensitive)
 * substring.
 */
struct monster_race *lookup_monster(const char *name)
{
 int i;
 struct monster_race *closest = NULL;
 /* Look for it */
 for (i = 0; i < z_info->r_max; i++) {
  struct monster_race *race = &r_info[i];
  if (!race->name)
   continue;
  /* Test for equality */
  if (my_stricmp(name, race->name) == 0)
   return race;
  /* Test for close matches */
  if (!closest && my_stristr(race->name, name))
   closest = race;
 }
 /* Return our best match */
 return closest;
}
/**
 * Return the monster base matching the given name.
 */
struct monster_base *lookup_monster_base(const char *name)
{
 struct monster_base *base;
 /* Look for it */
 for (base = rb_info; base; base = base->next) {
  if (streq(name, base->name))
   return base;
 }
 return NULL;
}
/**
 * Return whether the given base matches any of the names given.
 *
 * Accepts a variable-length list of name strings. The list must end with NULL.
 *
 * This function is currently unused, except in a test... -NRM-
 */
bool match_monster_bases(const struct monster_base *base, ...)
{
 bool ok = false;
 va_list vp;
 char *name;
 va_start(vp, base);
 while (!ok && ((name = va_arg(vp, char *)) != NULL))
  ok = base == lookup_monster_base(name);
 va_end(vp);
 return ok;
}
/**
 * ------------------------------------------------------------------------
 * Monster (and player) actual movement
 * ------------------------------------------------------------------------ */
/**
 * Check if the monster in the given location needs to fall down a chasm
 */
static void monster_fall_in_chasm(struct loc grid)
{
    struct monster *mon = square_monster(cave, grid);
    struct monster_race *race = mon ? mon->race : NULL;;
    char m_name[80];
    int dice;
    int dam;
    /* Paranoia */
    if (!mon) return;
    if (square_ischasm(cave, grid) && !rf_has(race->flags, RF_FLYING)) {
  /* Get the monster name */
        monster_desc(m_name, sizeof(m_name), mon, MDESC_DEFAULT);
        /* Message for visible monsters */
        if (monster_is_visible(mon)) {
            /* Dump a message */
            if (mon->morale < -200) {
    msg("%s leaps into the abyss!", m_name);
            } else {
    msg("%s topples into the abyss!", m_name);
   }
  }
  /* Pause so that the monster will be displayed in the chasm before
		 * it disappears */
  event_signal(EVENT_MESSAGE_FLUSH);
  /* Determine the falling damage */
  if (player->depth == z_info->dun_depth - 2) {
   dice = 3; /* only fall one floor in this case */
  } else {
   dice = 6;
  }
  /* Roll the damage dice */
        dam = damroll(dice, 4);
        /* Update combat rolls if visible */
        if (monster_is_visible(mon)) {
   event_signal_combat_attack(EVENT_COMBAT_ATTACK, source_grid(grid),
            source_monster(mon->midx), true, -1, -1,
            -1, -1, false);
   event_signal_combat_damage(EVENT_COMBAT_DAMAGE, dice, 4, dam, -1,
            -1, 0, 0, PROJ_HURT, false);
        }
        /* Kill monsters which cannot survive the damage */
        if (mon->hp <= dam) {
            /* Kill the monster, gain experience etc */
            monster_death(mon, player, true, NULL, false);
            /* Delete the monster */
            delete_monster(cave, grid);
        } else {
   /* Otherwise the monster survives! (mainly relevant for uniques) */
   delete_monster(cave, grid);
        }
    }
}
/**
 * Does any opportunist or zone of control attack necessary when player moves
 *
 * Note the use of skip_next_turn to stop the player getting opportunist
 * attacks after knocking back
 */
void monster_opportunist_or_zone(struct player *p, struct loc grid_to)
{
 int y, x;
 /* Handle Opportunist and Zone of Control */
 for (y = p->grid.y - 1; y <= p->grid.y + 1; y++) {
  for (x = p->grid.x - 1; x <= p->grid.x + 1; x++) {
   struct loc grid = loc(x, y);
   char m_name[80];
   struct monster *mon = square_monster(cave, grid);
   if (mon && (mon->alertness >= ALERTNESS_ALERT) &&
    !mon->m_timed[MON_TMD_CONF] && !mon->skip_next_turn &&
    (mon->stance != STANCE_FLEEING) && !mon->skip_this_turn) {
    bool opp = rf_has(mon->race->flags, RF_OPPORTUNIST);
    bool zone = rf_has(mon->race->flags, RF_ZONE);
    struct monster_lore *lore = get_lore(mon->race);
    /* Opportunist */
    if (opp && (distance(grid_to, grid) > 1)) {
     monster_desc(m_name, sizeof(m_name), mon, MDESC_STANDARD);
     msg("%s attacks you as you step away.", m_name);
     make_attack_normal(mon, p);
     /* Remember that the monster can do this */
     if (monster_is_visible(mon)) {
      rf_on(lore->flags, RF_OPPORTUNIST);
     }
    }
    /* Zone of control */
    if (zone && (distance(grid_to, p->grid) == 1)) {
     monster_desc(m_name, sizeof(m_name), mon, MDESC_POSS);
     msg("You move through %s zone of control.", m_name);
     make_attack_normal(mon, p);
     /* Remember that the monster can do this */
     if (monster_is_visible(mon)) {
      rf_on(lore->flags, RF_ZONE);
     }
    }
   }
  }
 }
}
/**
 * Swap the players/monsters (if any) at two locations.
 */
void monster_swap(struct loc grid1, struct loc grid2)
{
 struct monster *mon;
 /* Monsters */
 int m1 = square(cave, grid1)->mon;
 int m2 = square(cave, grid2)->mon;
 /* Needed for polearms check */
 bool m1_is_monster = false;
 /* Nothing to do if locations are the same */
 if (loc_eq(grid1, grid2)) return;
 /* Monster 1 */
 if (m1 > 0) {
  /* Monster */
  m1_is_monster = true;
  mon = cave_monster(cave, m1);
  /* Handle Opportunist and Zone of Control */
  player_opportunist_or_zone(player, grid1, grid2, false);
  /* Monster may be dead */
  if (mon->hp <= 0) return;
  /* Makes noise when moving */
  if (mon->noise == 0) {
   mon->noise = 5;
  }
  /* Update monster */
  mon->grid = grid2;
  update_mon(mon, cave, true);
  /* Affect light? */
  if (mon->race->light != 0)
   player->upkeep->update |= PU_UPDATE_VIEW | PU_MONSTERS;
  /* Redraw monster list */
  player->upkeep->redraw |= (PR_MONLIST);
 } else if (m1 < 0) {
  /* Handle Opportunist and Zone of Control */
  monster_opportunist_or_zone(player, grid2);
  /* Player may be dead */
  if (player->chp < 0) return;
  /* Move player */
  player->grid = grid2;
  /* Updates */
  player->upkeep->update |= (PU_PANEL | PU_UPDATE_VIEW | PU_DISTANCE);
  /* Redraw monster list */
  player->upkeep->redraw |= (PR_MONLIST);
  /* Don't allow command repeat if moved away from item used. */
  cmd_disable_repeat_floor_item();
 }
 /* Monster 2 */
 if (m2 > 0) {
  /* Monster */
  mon = cave_monster(cave, m2);
  /* Makes noise when moving */
  if (mon->noise == 0) {
   mon->noise = 5;
  }
  /* Update monster */
  mon->grid = grid1;
  update_mon(mon, cave, true);
  /* Affect light? */
  if (mon->race->light != 0)
   player->upkeep->update |= PU_UPDATE_VIEW | PU_MONSTERS;
  /* Redraw monster list */
  player->upkeep->redraw |= (PR_MONLIST);
 } else if (m2 < 0) {
  /* Player */
  player->grid = grid1;
  /* Updates */
  player->upkeep->update |= (PU_PANEL | PU_UPDATE_VIEW | PU_DISTANCE);
  /* Redraw monster list */
  player->upkeep->redraw |= (PR_MONLIST);
  /* Don't allow command repeat if moved away from item used. */
  cmd_disable_repeat_floor_item();
 }
 /* Update grids */
 square_set_mon(cave, grid1, m2);
 square_set_mon(cave, grid2, m1);
 /* Redraw */
 square_light_spot(cave, grid1);
 square_light_spot(cave, grid2);
 /* Deal with set polearm attacks */
 if (player_active_ability(player, "Polearm Mastery") && m1_is_monster) {
  player_polearm_passive_attack(player, grid1, grid2);
 }
 /* Deal with falling down chasms */
    if (m1 > 0) monster_fall_in_chasm(grid2);
    if (m2 > 0) monster_fall_in_chasm(grid1);
    /* Describe object you are standing on if any */
    if ((m1 < 0) || (m2 < 0)) {
        event_signal(EVENT_SEEFLOOR);
    }
}
/**
 * ------------------------------------------------------------------------
 * Awareness and learning
 * ------------------------------------------------------------------------ */
/**
 * Monster can see a grid
 */
bool monster_can_see(struct chunk *c, struct monster *mon, struct loc grid)
{
 return los(c, mon->grid, grid);
}
/**
 * Lets all monsters attempt to notice the player.
 * It can get called multiple times per player turn.
 *
 * Once each turn is the 'main roll' which is handled differently from the
 * others; the other rolls correspond to noisy events.  These events can be
 * caused by the player (in which case 'player_centered' is set to true),
 * or can be caused by a monster, in which case it will be false and
 * the monster_noise flow will be used instead of the usual player_noise flow.
 */
void monsters_hear(bool player_centered, bool main_roll, int difficulty)
{
 int i;
 int m_perception;
 int result;
 int noise_dist;
 int difficulty_roll;
 int difficulty_roll_alt;
 int combat_noise_bonus = 0;
 int combat_sight_bonus = 0;
 struct song *silence = lookup_song("Silence");
 /* Player is dead or leaving the current level */
 if (player->is_dead || !player->upkeep->playing ||
   player->upkeep->generate_level) return;
 /* No perception on the first turn of the game */
 if (turn == 0) return;
 /* If time is stopped, no monsters can perceive */
 if (OPT(player, cheat_timestop)) return;
 /* Bonuses for monsters if the player attacked a monster or was attacked */
 if (main_roll) {
  if (player->attacked) {
   combat_noise_bonus += 2;
   combat_sight_bonus += 2;
   player->attacked = false;
   /* Keep track of this for the ability 'Concentration' */
   player->consecutive_attacks++;
  }
  if (player->been_attacked) {
   combat_noise_bonus += 2;
   combat_sight_bonus += 2;
   player->been_attacked = false;
  }
 }
 /* Make the difficulty roll just once per sound source (i.e. once per call
	 * to this function).  This is a manual version of a 'skill_check()' and
	 * should be treated as such */
 difficulty_roll = difficulty + randint1(10);
 /* Deal with player curses for skill rolls.  This is not perfect as some
	 * 'player_centered' things are not actually caused by the player */
 difficulty_roll_alt = difficulty + randint1(10);
 if (player->cursed && player_centered) {
  difficulty_roll = MIN(difficulty_roll, difficulty_roll_alt);
 }
 /* The song of silence quietens this a bit */
 if (player_is_singing(player, silence)) {
  difficulty_roll += song_bonus(player,
           player->state.skill_use[SKILL_SONG],
           silence);
 }
 /* Process the monsters (backwards) */
 for (i = cave_monster_max(cave) - 1; i >= 1; i--) {
  /* Access the monster */
  struct monster *mon = cave_monster(cave, i);
  /* Ignore dead monsters */
  if (!mon->race) continue;
  /* Ignore if character is within detection range
		 * (unlimited for most monsters, 2 for shortsighted ones) */
  if (rf_has(mon->race->flags, RF_SHORT_SIGHTED) && (mon->cdis > 2)) {
   continue;
  }
  if (player_centered) {
   noise_dist = flow_dist(cave->player_noise, mon->grid);
  } else {
   noise_dist = flow_dist(cave->monster_noise, mon->grid);
  }
  /* Start building up the monster's total perception */
  m_perception = monster_skill(mon, SKILL_PERCEPTION) - noise_dist
   + combat_noise_bonus;
  /* Deal with bane ability (theoretically should modify player roll,
		 * but this is equivalent) */
  m_perception -= player_bane_bonus(player, mon);
  /* Increase morale for the Elf-Bane ability */
  m_perception += monster_elf_bane_bonus(mon, player);
  /* Monsters are looking more carefully during the escape */
  if (player->on_the_run) {
   m_perception += 5;
  }
  /* Monsters that are already alert get a penalty to the roll to
		 * stop them getting *too* alert */
  if (mon->alertness >= ALERTNESS_ALERT) {
   m_perception -= mon->alertness;
  }
  /* Aggravation makes non-sleeping monsters much more likely
		 * to notice the player */
  if (player->state.flags[OF_AGGRAVATE] &&
   (mon->alertness >= ALERTNESS_UNWARY) &&
   !rf_has(mon->race->flags, RF_MINDLESS)) {
   m_perception += player->state.flags[OF_AGGRAVATE] * 10;
   if (monster_is_in_view(mon)) {
    equip_learn_flag(player, OF_AGGRAVATE);
   }
  }
  /* Awake creatures who have line of sight on player get a bonus */
  if (los(cave, mon->grid, player->grid) &&
   (mon->alertness >= ALERTNESS_UNWARY)) {
   int d, dir, open_squares = 0;
   struct loc grid;
   /* Check adjacent squares for impassable squares */
   for (d = 0; d < 8; d++) {
    dir = cycle[d];
    grid = loc_sum(player->grid, ddgrid[dir]);
    if (square_ispassable(cave, grid)) {
     open_squares++;
    }
   }
   /* Bonus reduced if the player has 'disguise' */
   if (player_active_ability(player, "Disguise")) {
    m_perception += (open_squares + combat_sight_bonus) / 2;
   } else {
    m_perception += open_squares + combat_sight_bonus;
   }
  }
  /* Do the 'skill_check()' versus the quietness of the sound... */
  result = (m_perception + randint1(10)) - difficulty_roll;
  /* Debugging message */
  if (OPT(player, cheat_skill_rolls)) {
   msg("{%d+%d v %d+%d = %d}.",
    result - m_perception + difficulty_roll, m_perception,
    difficulty_roll - difficulty, difficulty,
    result);
  }
  if (result > 0) {
   struct monster_lore *lore = get_lore(mon->race);
   /* Partly alert monster */
   set_alertness(mon, mon->alertness + result);
   /* Still not alert */
   if (mon->alertness < ALERTNESS_ALERT) {
    if (monster_is_visible(mon) && (lore->ignore < UCHAR_MAX)) {
     lore->ignore++;
    }
   } else {
    /* Just became alert */
    if (monster_is_visible(mon) && (lore->notice < UCHAR_MAX)) {
     lore->notice++;
    }
   }
  }
 }
}
/**
 * ------------------------------------------------------------------------
 * Monster damage and death utilities
 * ------------------------------------------------------------------------ */
/**
 * This adjusts a monster's raw experience point value according to the number
 * killed so far. The formula is:
 *
 * (depth * 10) / (kills + 1)
 *
 * This is doubled for uniques.
 *
 * ((depth * 25) * 4) / (kills + 4)  <- previous version
 *
 * 100 90 83 76 71 66 62  (10,10)   <- earliest version?
 * 100 80 66 57 50 44 40  (4,4)     <- this is the previous version
 *                                     (without the 1.5 multiplier)
 * 100 66 50 40 33 28 25  (2,2)
 * 100 50 33 25 20 16 14  (1,1)     <- this is the current version
 *
 * 100 90 81 72 65 59 53  (10%)     <- exponential alternatives
 * 100 80 64 51 40 32 25  (20%)     
 *
 * This function is called when gaining experience and when displaying it in
 * monster recall.
 */
int32_t adjusted_mon_exp(const struct monster_race *race, bool kill)
{
 int32_t exp;
 int mexp = race->level * 10;
 struct monster_lore *lore = get_lore(race);
 if (kill) {
  if (rf_has(race->flags, RF_UNIQUE)) {
   exp = mexp;
  } else {
   exp = (mexp) / (lore->pkills + 1);
  }
 } else {
  if (rf_has(race->flags, RF_UNIQUE)) {
   exp = mexp;
  } else {
   exp = (mexp) / (lore->psights + 1);
  }
 }
 return exp;
}
/**
 * Return the number of things dropped by a monster.
 *
 * \param race is the monster race.
 * \param maximize should be set to false for a random number, true to find
 * out the maximum count.
 */
int mon_create_drop_count(const struct monster_race *race, bool maximize)
{
 int number = 0;
 if (maximize) {
  if (rf_has(race->flags, RF_DROP_33)) number++;
  if (rf_has(race->flags, RF_DROP_100)) number++;
  if (rf_has(race->flags, RF_DROP_1D2)) number += 2;
  if (rf_has(race->flags, RF_DROP_2D2)) number += 4;
  if (rf_has(race->flags, RF_DROP_3D2)) number += 6;
  if (rf_has(race->flags, RF_DROP_4D2)) number += 8;
 } else {
  if (rf_has(race->flags, RF_DROP_33) && percent_chance(33)) number++;
  if (rf_has(race->flags, RF_DROP_100)) number++;
  if (rf_has(race->flags, RF_DROP_1D2)) number += damroll(1, 2);
  if (rf_has(race->flags, RF_DROP_2D2)) number += damroll(2, 2);
  if (rf_has(race->flags, RF_DROP_3D2)) number += damroll(3, 2);
  if (rf_has(race->flags, RF_DROP_4D2)) number += damroll(4, 2);
 }
 return number;
}
/**
 * Creates a specific monster's drop, including any drops specified
 * in the monster.txt file.
 *
 * Returns true if anything is created, false if nothing is.
 */
static int mon_create_drop(struct chunk *c, struct monster *mon,
         struct loc grid, bool stats)
{
 struct monster_drop *drop;
 bool great, good;
 bool visible;
 int number = 0, count = 0, level, j;
 struct object *obj;
 assert(mon);
 great = rf_has(mon->race->flags, RF_DROP_GREAT);
 good = rf_has(mon->race->flags, RF_DROP_GOOD);
 visible = monster_is_visible(mon) || monster_is_unique(mon);
 /* Determine how much we can drop */
 number = mon_create_drop_count(mon->race, false);
 /* Use the monster's level */
 level = mon->race->level;
 /* Specified drops */
 for (drop = mon->race->drops; drop; drop = drop->next) {
  if (percent_chance((int) drop->percent_chance)) {
   /* Specified by tval or by kind */
   if (drop->kind) {
    /* Allocate by hand, prep */
    obj = mem_zalloc(sizeof(*obj));
    object_prep(obj, drop->kind, level, RANDOMISE);
    obj->number = randcalc(drop->dice, 0, RANDOMISE);
    /* Deathblades only */
    if (streq(mon->race->base->name, "deathblade")) {
     apply_magic(obj, c->depth, false, false, false);
    }
   } else {
    /* Artifact */
    const struct artifact *art;
    struct object_kind *kind;
    assert(drop->art);
    art = drop->art;
    kind = lookup_kind(art->tval, art->sval);
    obj = mem_zalloc(sizeof(*obj));
    object_prep(obj, kind, 100, RANDOMISE);
    obj->artifact = art;
    copy_artifact_data(obj, obj->artifact);
    mark_artifact_created(art, true);
   }
   /* Skip if the object couldn't be created. */
   if (!obj) continue;
   /* Set origin details */
   obj->origin = visible || stats ? mon->origin : ORIGIN_DROP_UNKNOWN;
   obj->origin_depth = convert_depth_to_origin(c->depth);
   obj->origin_race = mon->race;
   number--;
   count++;
   drop_near(c, &obj, 0, grid, true, false);
  }
 }
 /* Make and drop some objects */
 for (j = 0; j < number; j++) {
  obj = make_object(c, level, good, great, lookup_drop("not useless"));
  if (!obj) continue;
  /* Set origin details */
  obj->origin = visible || stats ? mon->origin : ORIGIN_DROP_UNKNOWN;
  obj->origin_depth = convert_depth_to_origin(c->depth);
  obj->origin_race = mon->race;
  count++;
  drop_near(c, &obj, 0, grid, true, false);
 }
 return count;
}
/**
 * Drop monster carried items and generate treasure
 */
void drop_loot(struct chunk *c, struct monster *mon, struct loc grid,
      bool stats)
{
 int dump_item;
 struct object *obj = mon->held_obj;
 bool visible = monster_is_visible(mon) || monster_is_unique(mon);
 bool stair = square_isstairs(c, grid) || square_isshaft(c, grid);
 /* Stone creatures turn into rubble */
 if (rf_has(mon->race->flags, RF_STONE) && !stair) {
  square_set_feat(c, grid, FEAT_RUBBLE);
 }
 /* Drop objects being carried */
 while (obj) {
  struct object *next = obj->next;
  /* Object no longer held */
  obj->held_m_idx = 0;
  pile_excise(&mon->held_obj, obj);
  /* Change origin if monster is invisible, unless we're in stats mode */
  if (!visible && !stats)
   obj->origin = ORIGIN_DROP_UNKNOWN;
  drop_near(c, &obj, 0, grid, (c == cave), false);
  obj = next;
 }
 /* Forget objects */
 mon->held_obj = NULL;
 /* Drop some objects */
 dump_item = mon_create_drop(c, mon, grid, stats);
 /* Take note of any dropped treasure */
 if (visible && dump_item && stats) {
  lore_treasure(mon, dump_item);
 }
}
/**
 * Handles the "death" of a monster.
 *
 * Disperses treasures carried by the monster centered at the monster location.
 * Note that objects dropped may disappear in crowded rooms.
 *
 * Checks for "Quest" completion when a quest monster is killed.
 *
 * If `stats` is true, then we skip updating the monster memory. This is
 * used by stats-generation code, for efficiency.
 */
void monster_death(struct monster *mon, struct player *p, bool by_player,
        const char *note, bool stats)
{
 int32_t new_exp;
 struct monster_race *race = mon->race;
 struct monster_lore *lore = get_lore(mon->race);
 char m_name[80];
 char buf[80];
 int desc_mode = MDESC_DEFAULT | ((note) ? MDESC_COMMA : 0);
 int multiplier = 1;
 /* Assume normal death sound */
 int soundfx = MSG_KILL;
 /* Monster has fallen in a chasm */
 bool chasm = square_ischasm(cave, mon->grid) &&
  !rf_has(mon->race->flags, RF_FLYING);
 /* Extract monster name */
 monster_desc(m_name, sizeof(m_name), mon, desc_mode);
 /* Play a special sound if the monster was unique */
 if (rf_has(race->flags, RF_UNIQUE)) {
  /* Special message and flag setting for killing Morgoth */
  if (race->base == lookup_monster_base("Morgoth")) {
   soundfx = MSG_KILL_KING;
   p->morgoth_slain = true;
   msg("BUG: Morgoth has been defeated in combat.");
   msg("But this is not possible within the fates Illuvatar has decreed.");
   msg("Please post an 'ultimate bug-report' on http://angband.live/forums/ explaining how this happened.");
   msg("But for now, let's run with it, since it's undeniably impressive.");
   /* Display the ultimate bug text */
   event_signal_poem(EVENT_POEM, "ultimate_bug", 5, 15);
  } else {
   soundfx = MSG_KILL_UNIQUE;
  }
 }
 /* Death message */
 if (note) {
  if (strlen(note) <= 1) {
   /* Death by Spell attack - messages handled by project_m() */
  } else {
   /* Make sure to flush any monster messages first */
   notice_stuff(p);
   /* Death by Missile attack */
   my_strcap(m_name);
   msgt(soundfx, "%s%s", m_name, note);
  }
 } else {
  /* Make sure to flush any monster messages first */
  notice_stuff(p);
  if (!monster_is_visible(mon)) {
   /* Death by physical attack -- invisible monster
			 * You only get messages for unseen monsters if you kill them */
   if (by_player && (distance(mon->grid, p->grid) == 1)) {
    msgt(soundfx, "You have killed %s.", m_name);
   }
  } else if (monster_is_nonliving(mon)) {
   /* Death by Physical attack -- non-living monster */
   if (streq(race->base->name, "deathblade")) {
    /* Special message for deathblades */
    if (by_player) {
     msgt(soundfx, "You have subdued %s.", m_name);
    } else {
     my_strcap(m_name);
     msgt(soundfx, "%s has been subdued.", m_name);
    }
   } else {
    if (by_player) {
     msgt(soundfx, "You have destroyed %s.", m_name);
    } else {
     my_strcap(m_name);
     msgt(soundfx, "%s has been destroyed.", m_name);
    }
   }
  } else {
   /* Death by Physical attack -- living monster */
   if (by_player) {
    msgt(soundfx, "You have slain %s.", m_name);
   } else {
    my_strcap(m_name);
    msgt(soundfx, "%s has been slain.", m_name);
   }
  }
 }
 /* Give some experience for the kill */
    new_exp = adjusted_mon_exp(race, true);
    player_exp_gain(p, new_exp);
    p->kill_exp += new_exp;
 /* When the player kills a Unique, it stays dead */
 if (rf_has(race->flags, RF_UNIQUE)) {
  char unique_name[80];
  race->max_num = 0;
  /*
		 * This gets the correct name if we slay an invisible
		 * unique and don't have See Invisible.
		 */
  monster_desc(unique_name, sizeof(unique_name), mon, MDESC_DIED_FROM);
  /* Log the slaying of a unique */
  if (streq(race->base->name, "deathblade")) {
   strnfmt(buf, sizeof(buf), "Subdued %s", unique_name);
  } else if (monster_is_nonliving(mon)) {
   strnfmt(buf, sizeof(buf), "Destroyed %s", unique_name);
  } else {
   strnfmt(buf, sizeof(buf), "Killed %s", unique_name);
  }
  history_add(p, buf, HIST_SLAY_UNIQUE);
 }
 /* Count kills this life */
 if (lore->pkills < SHRT_MAX) lore->pkills++;
 /* Count kills in all lives */
 if (lore->tkills < SHRT_MAX) lore->tkills++;
    /* Since it was killed, it was definitely encountered */
    if (!mon->encountered) {
        new_exp = adjusted_mon_exp(mon->race, false);
        /* Gain experience for encounter */
        player_exp_gain(p, new_exp);
        p->encounter_exp += new_exp;
        /* Update stats */
        mon->encountered = true;
        lore->psights++;
        if (lore->tsights < SHRT_MAX) lore->tsights++;
    }
 /* Update lore and tracking */
 lore_update(mon->race, lore);
 monster_race_track(p->upkeep, mon->race);
 /* Lower the morale of similar monsters that can see the deed. */
 if (rf_has(race->flags, RF_ESCORT) || rf_has(race->flags, RF_ESCORTS)) {
  multiplier = 4;
 }
 scare_onlooking_friends(mon, -40 * multiplier);
 /* Generate treasure for eligible monsters */
 if (!chasm && !rf_has(mon->race->flags, RF_TERRITORIAL)) {
  drop_loot(cave, mon, mon->grid, false);
 }
 /* Update monster list window */
 p->upkeep->redraw |= PR_MONLIST;
 /* Delete the monster */
 delete_monster_idx(cave, mon->midx);
}
/**
 * Decreases a monster's hit points by `dam` and handle monster death.
 *
 * Hack -- we "delay" fear messages by passing around a "fear" flag.\\TODO??
 *
 * We announce monster death (using an optional "death message" (`note`)
 * if given, and a otherwise a generic killed/destroyed message).
 *
 * Returns true if the monster has been killed (and deleted).
 */
bool mon_take_hit(struct monster *mon, struct player *p, int dam,
      const char *note)
{
 /* Redraw (later) if needed */
 if (p->upkeep->health_who == mon)
  p->upkeep->redraw |= (PR_HEALTH);
 /* No damage, we're done */
 if (dam == 0) return false;
 /* Hurt it */
 mon->hp -= dam;
 if (mon->hp <= 0) {
  /* It is dead now */
  monster_death(mon, p, true, note, false);
  /* Monster is dead */
  return true;
 }
 /* If there was real damage dealt... */
 if (dam > 0) {
  /* Wake it up */
  make_alert(mon, dam);
  /* Recalculate desired minimum range */
  if (dam > 0) mon->min_range = 0;
 }
 /* Monster will always go active */
 mflag_on(mon->mflag, MFLAG_ACTIVE);
 /* Not dead yet */
 return false;
}
/**
 * Checks whether monsters on two separate coordinates are of the same type
 * (i.e. the same letter or share an RF3_ race flag)
 */
bool similar_monsters(struct monster *mon1, struct monster *mon2)
{
 bitflag mask[RF_SIZE];
 /* First check if there are two monsters */
 if (!mon1 || !mon2) return false;
 /* Monsters have the same base */
 if (mon1->race->base == mon2->race->base) return true;
 /* Monsters have the same race flag */
 create_mon_flag_mask(mask, RFT_RACE_N, RFT_MAX);
 rf_inter(mask, mon1->race->flags);
 if (rf_is_inter(mask, mon2->race->flags)) return true;
 /* Not the same */
 return false;
}
/**
 * Cause a temporary penalty to morale in monsters of the same type who can see
 * the  specified monster. (Used when it dies and for cruel blow).
 */
void scare_onlooking_friends(const struct monster *mon, int amount)
{
 int i;
 /* Scan monsters */
 for (i = 1; i < cave_monster_max(cave); i++) {
  struct monster *mon1 = cave_monster(cave, i);;
  struct monster_race *race = mon1->race;
  /* Skip dead monsters */
  if (!race) continue;
  /* Only consider alert monsters of the same type in line of sight */
  if ((mon1->alertness >= ALERTNESS_ALERT) &&
   !rf_has(race->flags, RF_NO_FEAR) &&
   similar_monsters((struct monster *) mon, mon1) &&
   los(cave, mon1->grid, mon->grid)) {
   /* Cause a temporary morale penalty */
   mon1->tmp_morale += amount;
  }
 }
 return;
}
/**
 * ------------------------------------------------------------------------
 * Monster inventory utilities
 * ------------------------------------------------------------------------ */
/**
 * Add the given object to the given monster's inventory.
 *
 * Currently always returns true - it is left as a bool rather than
 * void in case a limit on monster inventory size is proposed in future.
 */
bool monster_carry(struct chunk *c, struct monster *mon, struct object *obj)
{
 struct object *held_obj;
 /* Scan objects already being held for combination */
 for (held_obj = mon->held_obj; held_obj; held_obj = held_obj->next) {
  /* Check for combination */
  if (object_mergeable(held_obj, obj, OSTACK_MONSTER)) {
   /* Combine the items */
   object_absorb(held_obj, obj);
   /* Result */
   return true;
  }
 }
 /* Forget location */
 obj->grid = loc(0, 0);
 /* Link the object to the monster */
 obj->held_m_idx = mon->midx;
 /* Add the object to the monster's inventory */
 list_object(c, obj);
 if (obj->known) {
  obj->known->oidx = obj->oidx;
  player->cave->objects[obj->oidx] = obj->known;
 }
 pile_insert(&mon->held_obj, obj);
 /* Result */
 return true;
}
/**
 * \file obj-chest.c
 * \brief Encapsulation of chest-related functions
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 * Copyright (c) 2012 Peter Denison
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Chest traps are specified in the file chest_trap.txt.
 *
 * Chests are described by their pval as follows:
 * - pval of 0 is an empty chest
 * - pval of 1 is a locked chest with no traps
 * - pval > 1  is a trapped chest, with the pval serving as in index into
 *             the chest_trap_list[] array to determine which traps occur
 * - pval < 1  is a disarmed/unlocked chest; the disarming process is simply
 *             to negate the pval
 *
 * The chest pval also determines the difficulty of disarming the chest.
 * Currently the maximum difficulty is 60 (32 + 16 + 8 + 4); if more traps are
 * added to chest_trap.txt, the disarming calculation will need adjusting.
 */
struct chest_trap *chest_traps;
/**
 * Each chest has a certain set of traps, determined by pval
 * Each chest has a "pval" from 1 to the chest level (max 25)
 * If the "pval" is negative then the trap has been disarmed
 * The "pval" of a chest determines the quality of its treasure
 * Note that disarming a trap on a chest also removes the lock.
 */
const uint8_t chest_trap_list[] =
{
 0, /* 0 == empty */
 (CHEST_GAS_CONF),
 (CHEST_GAS_CONF),
 (CHEST_GAS_STUN),
 0,
 (CHEST_GAS_STUN),
 (CHEST_GAS_POISON),
 (CHEST_GAS_POISON),
 0,
 (CHEST_NEEDLE_ENTRANCE),
 (CHEST_NEEDLE_ENTRANCE),
 (CHEST_NEEDLE_HALLU),
 0,
 (CHEST_NEEDLE_HALLU),
 (CHEST_NEEDLE_LOSE_STR),
 (CHEST_NEEDLE_LOSE_STR),
 0,
 (CHEST_GAS_CONF | CHEST_NEEDLE_HALLU),
 (CHEST_GAS_CONF | CHEST_NEEDLE_HALLU),
 (CHEST_GAS_STUN | CHEST_NEEDLE_LOSE_STR),
 0,
 (CHEST_GAS_STUN | CHEST_NEEDLE_LOSE_STR),
 (CHEST_GAS_POISON | CHEST_NEEDLE_ENTRANCE),
 (CHEST_GAS_POISON | CHEST_NEEDLE_ENTRANCE),
 0,
 (CHEST_GAS_POISON | CHEST_NEEDLE_ENTRANCE), /* 25 == best */
};
/**
 * ------------------------------------------------------------------------
 * Parsing functions for chest_trap.txt and chest.txt
 * ------------------------------------------------------------------------ */
static enum parser_error parse_chest_trap_name(struct parser *p)
{
    const char *name = parser_getstr(p, "name");
    struct chest_trap *h = parser_priv(p);
    struct chest_trap *t = mem_zalloc(sizeof *t);
 /* Order the traps correctly and set the flag */
 if (h) {
  h->next = t;
  t->flag = h->flag ? h->flag * 2 : 1;
 } else {
  chest_traps = t;
 }
    t->name = string_make(name);
    parser_setpriv(p, t);
    return PARSE_ERROR_NONE;
}
static enum parser_error parse_chest_trap_effect(struct parser *p) {
    struct chest_trap *t = parser_priv(p);
 struct effect *effect;
 struct effect *new_effect = mem_zalloc(sizeof(*new_effect));
 if (!t)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 /* Go to the next vacant effect and set it to the new one  */
 if (t->effect) {
  effect = t->effect;
  while (effect->next)
   effect = effect->next;
  effect->next = new_effect;
 } else
  t->effect = new_effect;
 /* Fill in the detail */
 return grab_effect_data(p, new_effect);
}
static enum parser_error parse_chest_trap_dice(struct parser *p) {
 struct chest_trap *t = parser_priv(p);
 dice_t *dice = NULL;
 struct effect *effect = t->effect;
 const char *string = NULL;
 if (!t)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 /* If there is no effect, assume that this is human and not parser error. */
 if (effect == NULL)
  return PARSE_ERROR_NONE;
 while (effect->next) effect = effect->next;
 dice = dice_new();
 if (dice == NULL)
  return PARSE_ERROR_INVALID_DICE;
 string = parser_getstr(p, "dice");
 if (dice_parse_string(dice, string)) {
  effect->dice = dice;
 }
 else {
  dice_free(dice);
  return PARSE_ERROR_INVALID_DICE;
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_chest_trap_msg(struct parser *p) {
    struct chest_trap *t = parser_priv(p);
 if (!t)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
    t->msg = string_append(t->msg, parser_getstr(p, "text"));
    return PARSE_ERROR_NONE;
}
static enum parser_error parse_chest_trap_msg_save(struct parser *p) {
    struct chest_trap *t = parser_priv(p);
 if (!t)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
    t->msg_save = string_append(t->msg_save, parser_getstr(p, "text"));
    return PARSE_ERROR_NONE;
}
static enum parser_error parse_chest_trap_msg_bad(struct parser *p) {
    struct chest_trap *t = parser_priv(p);
 if (!t)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
    t->msg_bad = string_append(t->msg_bad, parser_getstr(p, "text"));
    return PARSE_ERROR_NONE;
}
static enum parser_error parse_chest_trap_msg_death(struct parser *p) {
    struct chest_trap *t = parser_priv(p);
 if (!t)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
    t->msg_death = string_append(t->msg_death, parser_getstr(p, "text"));
    return PARSE_ERROR_NONE;
}
struct parser *init_parse_chest_trap(void) {
    struct parser *p = parser_new();
    parser_setpriv(p, NULL);
    parser_reg(p, "name str name", parse_chest_trap_name);
 parser_reg(p, "effect sym eff ?sym type ?int radius ?int other", parse_chest_trap_effect);
 parser_reg(p, "dice str dice", parse_chest_trap_dice);
 parser_reg(p, "msg str text", parse_chest_trap_msg);
 parser_reg(p, "msg-save str text", parse_chest_trap_msg_save);
 parser_reg(p, "msg-bad str text", parse_chest_trap_msg_bad);
 parser_reg(p, "msg-death str text", parse_chest_trap_msg_death);
    return p;
}
static errr run_parse_chest_trap(struct parser *p) {
    return parse_file_quit_not_found(p, "chest_trap");
}
static errr finish_parse_chest_trap(struct parser *p) {
 parser_destroy(p);
 return 0;
}
static void cleanup_chest_trap(void)
{
 struct chest_trap *trap = chest_traps;
 while (trap) {
  struct chest_trap *old = trap;
  string_free(trap->name);
  string_free(trap->msg);
  string_free(trap->msg_save);
  string_free(trap->msg_bad);
  string_free(trap->msg_death);
  free_effect(trap->effect);
  trap = trap->next;
  mem_free(old);
 }
}
struct file_parser chest_trap_parser = {
    "chest_trap",
    init_parse_chest_trap,
    run_parse_chest_trap,
    finish_parse_chest_trap,
    cleanup_chest_trap
};
/**
 * ------------------------------------------------------------------------
 * Chest trap information
 * ------------------------------------------------------------------------ */
/**
 * The name of a chest trap
 */
const char *chest_trap_name(const struct object *obj)
{
 int16_t trap_value = obj->pval;
 /* Non-zero value means there either were or are still traps */
 if (trap_value < 0) {
  return (trap_value == -1) ? "unlocked" : "disarmed";
 } else if (trap_value > 0) {
  struct chest_trap *trap = chest_traps, *found = NULL;
  while (trap) {
   if (trap_value & trap->flag) {
    if (found) {
     return "multiple traps";
    }
    found = trap;
   }
   trap = trap->next;
  }
  if (found) {
   return found->name;
  }
 }
 return "empty";
}
/**
 * Determine if a chest is trapped
 */
bool is_trapped_chest(const struct object *obj)
{
 if (!tval_is_chest(obj))
  return false;
 /* Disarmed or opened chests are not trapped */
 if (obj->pval <= 0)
  return false;
 /* Some chests simply don't have traps */
 return (obj->pval == 1) ? false : true;
}
/**
 * Determine if a chest is locked or trapped
 */
bool is_locked_chest(const struct object *obj)
{
 if (!tval_is_chest(obj))
  return false;
 /* Disarmed or opened chests are not locked */
 return (obj->pval > 0);
}
/**
 * ------------------------------------------------------------------------
 * Chest trap actions
 * ------------------------------------------------------------------------ */
/**
 * Unlock a chest
 */
void unlock_chest(struct object *obj)
{
 obj->pval = (0 - obj->pval);
}
/**
 * Determine if a grid contains a chest matching the query type, and
 * return a pointer to the first such chest
 */
struct object *chest_check(const struct player *p, struct loc grid,
  enum chest_query check_type)
{
 struct object *obj;
 /* Scan all objects in the grid */
 for (obj = square_object(cave, grid); obj; obj = obj->next) {
  /* Ignore if requested */
  if (ignore_item_ok(p, obj)) continue;
  /* Check for chests */
  switch (check_type) {
  case CHEST_ANY:
   if (tval_is_chest(obj))
    return obj;
   break;
  case CHEST_OPENABLE:
   if (tval_is_chest(obj) && (obj->pval != 0))
    return obj;
   break;
  case CHEST_TRAPPED:
   if (is_trapped_chest(obj) && obj->known && obj->known->pval)
    return obj;
   break;
  }
 }
 /* No chest */
 return NULL;
}
/**
 * Return the number of grids holding a chests around (or under) the character.
 * If requested, count only trapped chests.
 */
int count_chests(struct loc *grid, enum chest_query check_type)
{
 int d, count;
 /* Count how many matches */
 count = 0;
 /* Check around (and under) the character */
 for (d = 0; d < 9; d++) {
  /* Extract adjacent (legal) location */
  struct loc grid1 = loc_sum(player->grid, ddgrid_ddd[d]);
  /* No (visible) chest is there */
  if (!chest_check(player, grid1, check_type)) continue;
  /* Count it */
  ++count;
  /* Remember the location of the last chest found */
  *grid = grid1;
 }
 /* All done */
 return count;
}
/**
 * Choose the theme for a chest
 */
static struct drop *choose_chest_contents(void)
{
 struct drop *theme;
 int pick, count = 0;
 /* Count the possible themes */
 for (theme = drops; theme; theme = theme->next) {
  if (theme->chest) count++;
 }
 /* Pick one at random, find it */
 pick = randint0(count);
 for (theme = drops; theme; theme = theme->next) {
  if (theme->chest) count--;
  if (count == pick) break;
 }
 assert(theme);
 return theme;
}
/**
 * Allocate objects upon opening a chest
 *
 * Disperse treasures from the given chest, centered at (x,y).
 *
 * Small chests get 2-3 objects, large chests get 4.
 *
 * Judgment of size and construction of chests is currently made from the name.
 */
static void chest_death(struct loc grid, struct object *chest)
{
 int number = 1, level;
 struct drop *theme;
 /* Zero pval means empty chest */
 if (!chest->pval)
  return;
 /* Determine how much to drop (see above) */
 if (strstr(chest->kind->name, "Small")) {
  number = rand_range(2, 3);
 } else if (strstr(chest->kind->name, "Large")) {
  number = 4;
 } else if (strstr(chest->kind->name, "present")) {
  number = 1;
 }
 /* Drop some objects (non-chests) */
 level = ABS(chest->pval);
 theme = choose_chest_contents();
 while (number > 0) {
  int quality = randint1(level);
  struct object *treasure;
  bool good = false, great = false;
  /* Determine quality */
  if (strstr(chest->kind->name, "steel")) {
   quality += 5;
  } else if (strstr(chest->kind->name, "jewelled")) {
   quality += 10;
  } else if (strstr(chest->kind->name, "present")) {
   quality += 20;
  }
  /* Decide if object is good, great or both */
  if (quality > 10) {
   if (quality <= 15) {
    good = true;
   } else if (quality <= 20) {
    great = true;
   } else {
    good = true;
    great = true;
   }
  }
  /* Sil sets a limit on number of tries; hoping that's not needed NRM */
  treasure = make_object(cave, level, good, great, theme);
  if (!treasure)
   continue;
  if (tval_is_chest(treasure)) {
   object_delete(cave, player->cave, &treasure);
   continue;
  }
  treasure->origin = ORIGIN_CHEST;
  treasure->origin_depth = chest->origin_depth;
  drop_near(cave, &treasure, 0, grid, true, false);
  number--;
 }
 /* Chest is now empty */
 chest->pval = 0;
 chest->known->pval = 0;
}
/**
 * Chests have traps too.
 */
static void chest_trap(struct object *obj)
{
 uint8_t flags;
 struct chest_trap *trap;
 bool ident = false;
 int old[TMD_MAX];
 /* Ignore disarmed chests */
 if (obj->pval <= 0) return;
 /* Record current timed effect status */
 memcpy(old, player->timed, TMD_MAX);
 /* Get the flags */
 assert(obj->pval < (int) N_ELEMENTS(chest_trap_list));
 flags = chest_trap_list[obj->pval];
 /* Apply trap effects */
 for (trap = chest_traps; trap; trap = trap->next) {
  if (flags & trap->flag) {
   bool save = false;
   if (trap->msg_save) {
    int difficulty = player->state.stat_use[STAT_DEX] * 2;
    if (skill_check(source_none(), 2, difficulty, source_player())
     <= 0) {
     save = true;
    }
   }
   if (save) {
    msg(trap->msg_save);
   } else {
    if (trap->msg) {
     msg(trap->msg);
    }
    if (trap->effect) {
     effect_do(trap->effect, source_chest_trap(trap), obj,
         &ident, false, DIR_NONE, NULL);
     /* Bit of a hack */
     if (trap->msg_bad) {
      if (player_timed_inc_happened(player, old, TMD_MAX)) {
       msg(trap->msg_bad);
      } else {
       msg("You resist the effects.");
      }
     }
    }
   }
   if (trap->destroy) {
    obj->pval = 0;
    break;
   }
  }
 }
}
/**
 * Attempt to open the given chest at the given location
 *
 * Assume there is no monster blocking the destination
 *
 * Returns true if repeated commands may continue
 */
bool do_cmd_open_chest(struct loc grid, struct object *obj)
{
 bool flag = true;
 bool more = false;
 /* Cause problems opening presents before Christmas day */
 if (strstr(obj->kind->name, "present")) {
  time_t c = time((time_t *)0);
  struct tm *tp = localtime(&c);
  if ((tp->tm_mon == 11) && (tp->tm_mday >= 20) && (tp->tm_mday < 25)) {
   if (get_check("Are you sure you wish to open your present before Christmas? ")) {
    msg("You have a very bad feeling about this.");
    player->cursed = true;
   } else {
    return false;
   }
  }
 }
 /* Attempt to unlock it */
 if (obj->pval > 0) {
  /* Get the score in favour (=perception) */
  int score = player->state.skill_use[SKILL_PERCEPTION];
  /* Determine trap power based on the chest pval (power is 1--7) */
  int power = 1 + (obj->pval / 4);
  /* Base difficulty is the lock power + 5 */
  int difficulty = power + 5;
  /* Assume locked, and thus not open */
  flag = false;
  /* Penalize some conditions */
  if (player->timed[TMD_BLIND] || no_light(player) ||
   player->timed[TMD_CONFUSED] || player->timed[TMD_IMAGE]) {
   difficulty += 5;
  }
  /* Success -- May still have traps */
  if (skill_check(source_player(), score, difficulty, source_none()) > 0){
   msg("You have picked the lock.");
   flag = true;
  } else {
   /* We may continue repeating */
   more = true;
   event_signal(EVENT_INPUT_FLUSH);
   msgt(MSG_LOCKPICK_FAIL, "You failed to pick the lock.");
  }
 }
 /* Allowed to open */
 if (flag) {
  /* Apply chest traps, if any and player is not trapsafe */
  chest_trap(obj);
  /* Let the Chest drop items */
  chest_death(grid, obj);
  /* Ignore chest if autoignore calls for it */
  player->upkeep->notice |= PN_IGNORE;
 }
 /* Empty chests were always ignored in ignore_item_okay so we
	 * might as well ignore it here
	 */
 if (obj->pval == 0)
  obj->known->notice |= OBJ_NOTICE_IGNORE;
 /* Redraw chest, to be on the safe side (it may have been ignored) */
 square_light_spot(cave, grid);
 /* Result */
 return (more);
}
/**
 * Attempt to disarm the chest at the given location
 * Assume there is no monster blocking the destination
 *
 * Returns true if repeated commands may continue
 */
bool do_cmd_disarm_chest(struct object *obj)
{
 int result;
 bool more = false;
 /* Get the score in favour (=perception) */
 int score = player->state.skill_use[SKILL_PERCEPTION];
 /* Determine trap power (= difficulty; power is 1--7) */
 int difficulty = 1 + (obj->pval / 4);
 /* Penalize some conditions */
 if (player->timed[TMD_BLIND] || no_light(player) ||
  player->timed[TMD_CONFUSED] || player->timed[TMD_IMAGE]) {
  difficulty += 5;
 }
 /* Perform the check */
 result = skill_check(source_player(), score, difficulty, source_none());
 /* Must find the trap first. */
 if (!obj->known->pval || ignore_item_ok(player, obj)) {
  msg("I don't see any traps.");
 } else if (!is_trapped_chest(obj)) {
  /* Already disarmed/unlocked or no traps */
  msg("The chest is not trapped.");
 } else if (result > 0) {
  /* Success */
  msgt(MSG_DISARM, "You have disarmed the chest.");
  obj->pval = (0 - obj->pval);
 } else if (result > -3) {
  /* Failure -- Keep trying */
  more = true;
  event_signal(EVENT_INPUT_FLUSH);
  msg("You failed to disarm the chest.");
 } else {
  /* Failure -- Set off the trap */
  msg("You set off a trap!");
  chest_trap(obj);
 }
 /* Result */
 return more;
}
/**
 * \file obj-desc.c
 * \brief Create object name descriptions
 *
 * Copyright (c) 1997 - 2007 Angband contributors
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
const char *inscrip_text[OBJ_PSEUDO_MAX] = {
 NULL,
 "average",
 "artefact, cursed",
 "special, cursed",
 "cursed",
 "special",
 "artefact",
 "uncursed",
};
/**
 * Puts the object base kind's name into buf.
 */
void object_base_name(char *buf, size_t max, int tval, bool plural)
{
 struct object_base *kb = &kb_info[tval];
 size_t end = 0;
 if (kb->name && kb->name[0])
  (void) obj_desc_name_format(buf, max, end, kb->name, NULL, plural);
}
/**
 * Puts a very stripped-down version of an object's name into buf.
 * If easy_know is true, then the IDed names are used, otherwise
 * flavours, scroll names, etc will be used.
 *
 * Just truncates if the buffer isn't big enough.
 */
void object_kind_name(char *buf, size_t max, const struct object_kind *kind,
       bool easy_know)
{
 /* If not aware, the plain flavour (e.g. Copper) will do. */
 if (!easy_know && !kind->aware && kind->flavor)
  my_strcpy(buf, kind->flavor->text, max);
 /* Use proper name (Healing, or whatever) */
 else
  (void) obj_desc_name_format(buf, max, 0, kind->name, NULL, false);
}
/**
 * A modifier string, put where '#' goes in the basename below.  The weird
 * games played with book names are to allow the non-essential part of the
 * name to be abbreviated when there is not much room to display.
 */
static const char *obj_desc_get_modstr(const struct object_kind *kind)
{
 if (tval_can_have_flavor_k(kind))
  return kind->flavor ? kind->flavor->text : "";
 return "";
}
/**
 * An object's basic name - a generic name for flavored objects (with the
 * actual name added later depending on awareness, the name from object.txt
 * for almost everything else, and a bit extra for books. 
 */
static const char *obj_desc_get_basename(const struct object *obj, bool aware,
  bool terse, uint32_t mode, const struct player *p)
{
 bool show_flavor = !terse && obj->kind->flavor;
 if (aware && p && !OPT(p, show_flavors)) show_flavor = false;
 /* Artifacts are special */
 if (obj->artifact && (aware || object_is_known_artifact(obj) || terse ||
        !obj->kind->flavor))
  return obj->kind->name;
 /* Analyze the object */
 switch (obj->tval)
 {
  case TV_NOTE:
  case TV_USELESS:
  case TV_METAL:
  case TV_FLASK:
  case TV_CHEST:
  case TV_ARROW:
  case TV_BOW:
  case TV_HAFTED:
  case TV_POLEARM:
  case TV_SWORD:
  case TV_DIGGING:
  case TV_BOOTS:
  case TV_GLOVES:
  case TV_CLOAK:
  case TV_CROWN:
  case TV_HELM:
  case TV_SHIELD:
  case TV_SOFT_ARMOR:
  case TV_MAIL:
  case TV_LIGHT:
  case TV_FOOD:
   return obj->kind->name;
  case TV_AMULET:
   return (show_flavor ? "& # Amulet~" : "& Amulet~");
  case TV_RING:
   return (show_flavor ? "& # Ring~" : "& Ring~");
  case TV_STAFF:
   return (show_flavor ? "& # Sta|ff|ves|" : "& Sta|ff|ves|");
  case TV_HORN:
   return (show_flavor ? "& # Horn~" : "& Horn~");
  case TV_POTION:
   return (show_flavor ? "& # Potion~" : "& Potion~");
  case TV_HERB:
   return (show_flavor ? "& # Herb~" : "& Herb~");
 }
 return "(nothing)";
}
/**
 * Start to description, indicating number/uniqueness (a, the, no more, 7, etc)
 */
static size_t obj_desc_name_prefix(char *buf, size_t max, size_t end,
  const struct object *obj, const char *basename,
  const char *modstr, bool terse, uint16_t number)
{
 if (number == 0) {
  strnfcat(buf, max, &end, "no more ");
 } else if (number > 1) {
  strnfcat(buf, max, &end, "%u ", number);
 } else if (object_is_known_artifact(obj)) {
  strnfcat(buf, max, &end, "the ");
 } else if (*basename == '&') {
  bool an = false;
  const char *lookahead = basename + 1;
  while (*lookahead == ' ') lookahead++;
  if (*lookahead == '#') {
   if (modstr && is_a_vowel(*modstr))
    an = true;
  } else if (is_a_vowel(*lookahead)) {
   an = true;
  }
  if (!terse) {
   if (an)
    strnfcat(buf, max, &end, "an ");
   else
    strnfcat(buf, max, &end, "a ");
  }
 }
 return end;
}
/**
 * Formats 'fmt' into 'buf', with the following formatting characters:
 *
 * '~' at the end of a word (e.g. "fridge~") will pluralise
 *
 * '|x|y|' will be output as 'x' if singular or 'y' if plural
 *    (e.g. "kni|fe|ves|")
 *
 * '#' will be replaced with 'modstr' (which may contain the pluralising
 * formats given above).
 */
size_t obj_desc_name_format(char *buf, size_t max, size_t end,
  const char *fmt, const char *modstr, bool pluralise)
{
 /* Copy the string */
 while (*fmt) {
  /* Skip */
  if (*fmt == '&') {
   while (*fmt == ' ' || *fmt == '&')
    fmt++;
   continue;
  } else if (*fmt == '~') {
   /* Pluralizer (regular English plurals) */
   char prev = *(fmt - 1);
   if (!pluralise) {
    fmt++;
    continue;
   }
   /* e.g. cutlass-e-s, torch-e-s, box-e-s */
   if (prev == 's' || prev == 'h' || prev == 'x')
    strnfcat(buf, max, &end, "es");
   else
    strnfcat(buf, max, &end, "s");
  } else if (*fmt == '|') {
   /* Special plurals 
			* e.g. kni|fe|ves|
			*          ^  ^  ^ */
   const char *singular = fmt + 1;
   const char *plural = strchr(singular, '|');
   const char *endmark = NULL;
   if (plural) {
    plural++;
    endmark = strchr(plural, '|');
   }
   if (!singular || !plural || !endmark) return end;
   if (!pluralise)
    strnfcat(buf, max, &end, "%.*s",
     (int) (plural - singular) - 1,
     singular);
   else
    strnfcat(buf, max, &end, "%.*s",
     (int) (endmark - plural), plural);
   fmt = endmark;
  } else if (*fmt == '#') {
   /* Add modstr, with pluralisation if relevant */
   end = obj_desc_name_format(buf, max, end, modstr, NULL, pluralise);
  }
  else
   buf[end++] = *fmt;
  fmt++;
 }
 buf[end] = 0;
 return end;
}
/**
 * Format object obj's name into 'buf'.
 */
static size_t obj_desc_name(char *buf, size_t max, size_t end,
  const struct object *obj, bool prefix, uint32_t mode,
  bool terse, const struct player *p)
{
 bool spoil = mode & ODESC_SPOIL ? true : false;
 uint16_t number = (mode & ODESC_ALTNUM) ?
  (mode & 0xFFFF0000) >> 16 : obj->number;
 /* Actual name for flavoured objects if aware, or spoiled */
 bool aware = object_flavor_is_aware(obj) || spoil;
 /* Pluralize if (not forced singular) and
	 * (not a known/visible artifact) and
	 * (not one in stack or forced plural) */
 bool plural = !(mode & ODESC_SINGULAR) &&
  !obj->artifact &&
  (number != 1 || (mode & ODESC_PLURAL));
 const char *basename = obj_desc_get_basename(obj, aware, terse,
  mode, p);
 const char *modstr = obj_desc_get_modstr(obj->kind);
 /* Quantity prefix */
 if (prefix)
  end = obj_desc_name_prefix(buf, max, end, obj, basename,
   modstr, terse, number);
 /* Base name */
 end = obj_desc_name_format(buf, max, end, basename, modstr, plural);
 /* Append extra names of various kinds */
 if (object_is_known_artifact(obj))
  strnfcat(buf, max, &end, " %s", obj->artifact->name);
 else if (obj->known->ego && !(mode & ODESC_NOEGO))
  strnfcat(buf, max, &end, " %s", obj->ego->name);
 else if (aware && !obj->artifact && obj->kind->flavor) {
  if (terse)
   strnfcat(buf, max, &end, " '%s'", obj->kind->name);
  else
   strnfcat(buf, max, &end, " of %s", obj->kind->name);
 }
 return end;
}
/**
 * Special descriptions for types of chest traps
 */
static size_t obj_desc_chest(const struct object *obj, char *buf, size_t max,
        size_t end)
{
 if (!tval_is_chest(obj)) return end;
 /* The chest is unopened, but we know nothing about its trap/lock */
 if (obj->pval && !obj->known->pval) return end;
 /* Describe the traps */
 strnfcat(buf, max, &end, " (%s)", chest_trap_name(obj));
 return end;
}
/**
 * Describe combat properties of an item - attack, damage dice, evasion,
 * protection dice
 */
static size_t obj_desc_combat(const struct object *obj, char *buf, size_t max,
  size_t end, uint32_t mode, const struct player *p)
{
 /* Handle special jewellery values */
 int att = obj->att == SPECIAL_VALUE ? 0 : obj->att;
 int evn = obj->evn == SPECIAL_VALUE ? 0 : obj->evn;
 int ds = obj->ds == SPECIAL_VALUE ? 0 : obj->ds;
 int ps = obj->ps == SPECIAL_VALUE ? 0 : obj->ps;
 /* Display damage dice for weapons */
 if (obj->kind && kf_has(obj->kind->kind_flags, KF_SHOW_DICE)) {
  ds += hand_and_a_half_bonus((struct player *) p, obj);
  strnfcat(buf, max, &end, " (%+d,%dd%d)", att, obj->dd, ds);
 } else if (tval_is_ammo(obj) && att) {
  /* Display attack for arrows if non-zero */
  strnfcat(buf, max, &end, " (%+d)", att);
 } else if (att) {
  /* Display attack if known and non-zero */
  strnfcat(buf, max, &end, " (%+d)", att);
 }
 /* Show evasion/protection info */
 if (obj->pd && ps) {
  strnfcat(buf, max, &end, " [%+d,%dd%d]", evn, obj->pd, ps);
 } else if (evn) {
  strnfcat(buf, max, &end, " [%+d]", evn);
 }
 return end;
}
/**
 * Describe remaining light for refuellable lights
 */
static size_t obj_desc_light(const struct object *obj, char *buf, size_t max,
        size_t end)
{
 /* Fuelled light sources get number of remaining turns appended */
 if (tval_is_light(obj) && !of_has(obj->flags, OF_NO_FUEL))
  strnfcat(buf, max, &end, " (%d turns)", obj->timeout);
 return end;
}
/**
 * Describe numerical modifiers to stats and other player qualities which
 * allow numerical bonuses - speed, stealth, etc
 */
static size_t obj_desc_mods(const struct object *obj, char *buf, size_t max,
       size_t end)
{
 int i, j, num_mods = 0;
 int mods[OBJ_MOD_MAX] = { 0 };
 /* Run through possible modifiers and store distinct ones */
 for (i = 0; i < OBJ_MOD_MAX; i++) {
  /* Check for known non-zero mods */
  if ((obj->modifiers[i] != 0) && (obj->modifiers[i] != SPECIAL_VALUE)) {
   /* If no mods stored yet, store and move on */
   if (!num_mods) {
    mods[num_mods++] = obj->modifiers[i];
    continue;
   }
   /* Run through the existing mods, quit on duplicates */
   for (j = 0; j < num_mods; j++)
    if (mods[j] == obj->modifiers[i]) break;
   /* Add another mod if needed */
   if (j == num_mods)
    mods[num_mods++] = obj->modifiers[i];
  }
 }
 if (!num_mods) return end;
 /* Print the modifiers */
 strnfcat(buf, max, &end, " <");
 for (j = 0; j < num_mods; j++) {
  if (j) strnfcat(buf, max, &end, ", ");
  strnfcat(buf, max, &end, "%+d", mods[j]);
 }
 strnfcat(buf, max, &end, ">");
 return end;
}
/**
 * Describe charges or charging status for re-usable items with magic effects
 */
static size_t obj_desc_charges(const struct object *obj, char *buf, size_t max,
  size_t end, uint32_t mode)
{
 bool aware = object_flavor_is_aware(obj);
 if (!tval_can_have_charges(obj)) return end;
 /* Wands and staffs have charges, others may be charging */
 if (aware || player_active_ability(player, "Channeling")) {
  strnfcat(buf, max, &end, " (%d charge%s)", obj->pval,
     PLURAL(obj->pval));
 } else if ((obj->used > 0) && !(obj->notice & OBJ_NOTICE_EMPTY)) {
  strnfcat(buf, max, &end, " (used %d time%s)", obj->used,
     PLURAL(obj->used));
 }
 return end;
}
/**
 * Add player-defined inscriptions or game-defined descriptions
 */
static size_t obj_desc_inscrip(const struct object *obj, char *buf,
  size_t max, size_t end, const struct player *p)
{
 const char *u[6] = { 0, 0, 0, 0, 0, 0 };
 int n = 0;
 /* Get inscription */
 if (obj->note)
  u[n++] = quark_str(obj->note);
 /* Use special inscription, if any */
 if (!object_flavor_is_aware(obj)) {
  if (tval_can_have_charges(obj) && (obj->pval == 0))
   u[n++] = "empty";
  if (object_flavor_was_tried(obj))
   u[n++] = "tried";
 }
 /* Note curses, use special inscription, if any */
 if (of_has(obj->known->flags, OF_CURSED)){
  u[n++] = "cursed";
 }
 /* Note ignore */
 if (p && ignore_item_ok(p, obj))
  u[n++] = "ignore";
 /* Note unknown properties */
 if (!object_runes_known(obj) && (obj->known->notice & OBJ_NOTICE_ASSESSED))
  u[n++] = "??";
 if (n) {
  int i;
  for (i = 0; i < n; i++) {
   if (i == 0)
    strnfcat(buf, max, &end, " {");
   strnfcat(buf, max, &end, "%s", u[i]);
   if (i < n - 1)
    strnfcat(buf, max, &end, ", ");
  }
  strnfcat(buf, max, &end, "}");
 }
 return end;
}
/**
 * Describes item `obj` into buffer `buf` of size `max`.
 *
 * \param buf is the buffer for the description.  Must have space for at least
 * max bytes.
 * \param max is the size of the buffer, in bytes.
 * \param obj is the object to describe.
 * \param mode must be a bitwise-or of zero or one more of the following:
 * ODESC_PREFIX prepends a 'the', 'a' or number
 * ODESC_BASE results in a base description.
 * ODESC_COMBAT will add to-hit, to-dam and AC info.
 * ODESC_EXTRA will add pval/charge/inscription/ignore info.
 * ODESC_PLURAL will pluralise regardless of the number in the stack.
 * ODESC_SPOIL treats the object as fully identified.
 * ODESC_CAPITAL capitalises the object name.
 * ODESC_TERSE causes a terse name to be used.
 * ODESC_NOEGO omits ego names.
 * ODESC_ALTNUM causes the high 16 bits of mode to be used as the number
 * of objects instead of using obj->number.  Note that using ODESC_ALTNUM
 * is not fully compatible with ODESC_EXTRA:  the display of number of rods
 * charging does not account for the alternate number.
 * \param p is the player whose knowledge is factored into the description.
 * If p is NULL, the description is for an omniscient observer.
 *
 * \returns The number of bytes used of the buffer.
 */
size_t object_desc(char *buf, size_t max, const struct object *obj,
  uint32_t mode, const struct player *p)
{
 bool prefix = mode & ODESC_PREFIX ? true : false;
 bool spoil = mode & ODESC_SPOIL ? true : false;
 bool terse = mode & ODESC_TERSE ? true : false;
 size_t end = 0;
 /* Simple description for null item */
 if (!obj || !obj->known)
  return strnfmt(buf, max, "(nothing)");
 /* Egos and kinds whose name we know are seen */
 if (obj->known->ego && !spoil)
  obj->ego->everseen = true;
 if (object_flavor_is_aware(obj) && !spoil)
  obj->kind->everseen = true;
 /** Construct the name **/
 /* Copy the base name to the buffer */
 end = obj_desc_name(buf, max, end, obj, prefix, mode, terse, p);
 /* Combat properties */
 if (mode & ODESC_COMBAT) {
  if (tval_is_chest(obj))
   end = obj_desc_chest(obj, buf, max, end);
  else if (tval_is_light(obj))
   end = obj_desc_light(obj, buf, max, end);
  end = obj_desc_combat(obj->known, buf, max, end, mode, p);
 }
 /* Modifiers, charges, flavour details, inscriptions */
 if (mode & ODESC_EXTRA) {
  end = obj_desc_mods(obj->known, buf, max, end);
  end = obj_desc_charges(obj, buf, max, end, mode);
  end = obj_desc_inscrip(obj, buf, max, end, p);
 }
 return end;
}
/**
 * \file obj-gear.c
 * \brief management of inventory, equipment and quiver
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 * Copyright (c) 2014 Nick McConnell
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
static const struct slot_info {
 int index;
 bool acid_vuln;
 bool name_in_desc;
 const char *mention;
 const char *describe;
} slot_table[] = {
/**
 * \file list-equip-slots.h
 * \brief types of slot for equipment
 *
 * Fields:
 * slot - The index name of the slot
 * acid_v - whether equipment in the slot needs checking for acid damage
 * name - whether the actual item name is mentioned when things happen to it
 * mention - description for when the slot is mentioned briefly
 * describe - description for when the slot is described at length
 */
/* slot				acid_v	name	mention			describe */
{ EQUIP_NONE, false, false, "", "" },
{ EQUIP_WEAPON, false, false, "Wielding", "attacking monsters with" },
{ EQUIP_BOW, false, false, "Shooting", "shooting missiles with" },
{ EQUIP_RING, false, true, "On %s", "wearing on your %s" },
{ EQUIP_AMULET, false, true, "Around %s", "wearing around your %s" },
{ EQUIP_LIGHT, false, false, "Light source", "using to light your way" },
{ EQUIP_BODY_ARMOR, true, true, "On %s", "wearing on your %s" },
{ EQUIP_CLOAK, true, true, "On %s", "wearing on your %s" },
{ EQUIP_SHIELD, true, true, "On %s", "wearing on your %s" },
{ EQUIP_HAT, true, true, "On %s", "wearing on your %s" },
{ EQUIP_GLOVES, true, true, "On %s", "wearing on your %s" },
{ EQUIP_BOOTS, true, true, "On %s", "wearing on your %s" },
{ EQUIP_QUIVER, true, true, "In quiver", "carrying in your %s" },

 { EQUIP_MAX, false, false, NULL, NULL }
};
/**
 * Return the slot number for a given name, or quit game
 */
int slot_by_name(struct player *p, const char *name)
{
 int i;
 /* Look for the correctly named slot */
 for (i = 0; i < p->body.count; i++) {
  if (streq(name, p->body.slots[i].name)) {
   break;
  }
 }
 assert(i < p->body.count);
 /* Index for that slot */
 return i;
}
/**
 * Gets a slot of the given type, preferentially empty unless full is true
 */
static int slot_by_type(struct player *p, int type, bool full)
{
 int i, fallback = p->body.count;
 /* Look for a correct slot type */
 for (i = 0; i < p->body.count; i++) {
  if (type == p->body.slots[i].type) {
   if (full) {
    /* Found a full slot */
    if (p->body.slots[i].obj != NULL) break;
   } else {
    /* Found an empty slot */
    if (p->body.slots[i].obj == NULL) break;
   }
   /* Not right for full/empty, but still the right type */
   if (fallback == p->body.count)
    fallback = i;
  }
 }
 /* Index for the best slot we found, or p->body.count if none found  */
 return (i != p->body.count) ? i : fallback;
}
/**
 * Indicate whether a slot is of a given type.
 *
 * \param p is the player to test; if NULL, will assume the default body plan.
 * \param slot is the slot index for the player.
 * \param type is one of the EQUIP_* constants from list-equip-slots.h.
 * \return true if the slot can hold that type; otherwise false
 */
bool slot_type_is(const struct player *p, int slot, int type)
{
 /* Assume default body if no player */
 struct player_body body = p ? p->body : bodies[0];
 return body.slots[slot].type == type ? true : false;
}
/**
 * Get the object in a specific slot (if any).  Quit if slot index is invalid.
 */
struct object *slot_object(struct player *p, int slot)
{
 /* Check bounds */
 assert(slot >= 0 && slot < p->body.count);
 /* Ensure a valid body */
 if (p->body.slots && p->body.slots[slot].obj) {
  return p->body.slots[slot].obj;
 }
 return NULL;
}
struct object *equipped_item_by_slot_name(struct player *p, const char *name)
{
 /* Ensure a valid body */
 if (p->body.slots) {
  return slot_object(p, slot_by_name(p, name));
 }
 return NULL;
}
int object_slot(struct player_body body, const struct object *obj)
{
 int i;
 for (i = 0; i < body.count; i++) {
  if (obj == body.slots[i].obj) {
   break;
  }
 }
 return i;
}
bool object_is_equipped(struct player_body body, const struct object *obj)
{
 /* The -2 is for quivers - hoping this is really that simple - NRM */
 return object_slot(body, obj) < body.count - 2;
}
bool object_is_carried(struct player *p, const struct object *obj)
{
 return pile_contains(p->gear, obj);
}
/**
 * Check if an object is in the quiver
 */
bool object_is_in_quiver(const struct player *p, const struct object *obj)
{
 struct player_body body = p->body;
 return (object_slot(body, obj) < body.count) &&
  !object_is_equipped(body, obj);
}
/**
 * Get the total number of objects in the pack or quiver that are like the
 * given object.
 *
 * \param player is the player whose inventory is used for the calculation.
 * \param obj is the template for the objects to look for.
 * \param ignore_inscrip if true, ignore the inscriptions when testing whether
 * an object is similar; otherwise, test the inscriptions as well.
 * \param first if not NULL, set to the first stack like obj (by ordering in
 * the quiver or pack with quiver taking precedence over pack; if the pack
 * and quiver haven't been computed, it will be the first non-equipped stack
 * in the gear).
 */
uint16_t object_pack_total(struct player *p, const struct object *obj,
  bool ignore_inscrip, struct object **first)
{
 uint16_t total = 0;
 char first_label = '\0';
 struct object *cursor;
 if (first) {
  *first = NULL;
 }
 for (cursor = p->gear; cursor; cursor = cursor->next) {
  bool like;
  if (cursor == obj) {
   /*
			 * object_similar() excludes cursor == obj so if
			 * obj is not equipped, account for it here.
			 */
   like = !object_is_equipped(p->body, obj);
  } else if (ignore_inscrip) {
   like = object_similar(obj, cursor, OSTACK_PACK);
  } else {
   like = object_stackable(obj, cursor, OSTACK_PACK);
  }
  if (like) {
   total += cursor->number;
   if (first) {
    char test_label = gear_to_label(p, cursor);
    if (!*first) {
     *first = cursor;
     first_label = test_label;
    } else {
     if (test_label >= 'a'
       && test_label <= 'z') {
      if (first_label == '\0'
        || (first_label >= 'a'
        && first_label <= 'z'
        && test_label < first_label)) {
       *first = cursor;
       first_label = test_label;
      }
     } else if (test_label >= '0'
       && test_label <= '9') {
      if (first_label == '\0'
        || (first_label >= 'a'
        && first_label <= 'z')
        || (first_label >= '0'
        && first_label <= '9'
        && test_label < first_label)) {
       *first = cursor;
       first_label = test_label;
      }
     }
    }
   }
  }
 }
 return total;
}
/**
 * Calculate the number of pack slots used by the current gear.
 */
int pack_slots_used(const struct player *p)
{
 const struct object *obj;
 int pack_slots = 0;
 for (obj = p->gear; obj; obj = obj->next) {
  /* Equipment doesn't count */
  if (!object_is_equipped(p->body, obj) && !object_is_in_quiver(p, obj)) {
   /* Count regular slots */
   pack_slots++;
  }
 }
 return pack_slots;
}
/**
 * Return a string mentioning how a given item is carried
 */
const char *equip_mention(struct player *p, int slot)
{
 int type = p->body.slots[slot].type;
 /* Heavy */
 if (slot_table[type].name_in_desc)
  return format(slot_table[type].mention, p->body.slots[slot].name);
 else
  return slot_table[type].mention;
}
/**
 * Return a string describing how a given item is being worn.
 * Currently, only used for items in the equipment, not inventory.
 */
const char *equip_describe(struct player *p, int slot)
{
 int type = p->body.slots[slot].type;
 /* Heavy */
 if (slot_table[type].name_in_desc)
  return format(slot_table[type].describe, p->body.slots[slot].name);
 else
  return slot_table[type].describe;
}
/**
 * Determine which equipment slot (if any) an item likes. The slot might (or
 * might not) be open, but it is a slot which the object could be equipped in.
 *
 * For items where multiple slots could work (e.g. rings), the function
 * will try to return an open slot if possible.
 */
int wield_slot(const struct object *obj)
{
 /* Slot for equipment */
 switch (obj->tval)
 {
  case TV_BOW: return slot_by_type(player, EQUIP_BOW, false);
  case TV_AMULET: return slot_by_type(player, EQUIP_AMULET, false);
  case TV_CLOAK: return slot_by_type(player, EQUIP_CLOAK, false);
  case TV_SHIELD: return slot_by_type(player, EQUIP_SHIELD, false);
  case TV_GLOVES: return slot_by_type(player, EQUIP_GLOVES, false);
  case TV_BOOTS: return slot_by_type(player, EQUIP_BOOTS, false);
  case TV_ARROW: return slot_by_type(player, EQUIP_QUIVER, false);
 }
 if (tval_is_melee_weapon(obj))
  return slot_by_type(player, EQUIP_WEAPON, false);
 else if (tval_is_ring(obj))
  return slot_by_type(player, EQUIP_RING, false);
 else if (tval_is_light(obj))
  return slot_by_type(player, EQUIP_LIGHT, false);
 else if (tval_is_body_armor(obj))
  return slot_by_type(player, EQUIP_BODY_ARMOR, false);
 else if (tval_is_head_armor(obj))
  return slot_by_type(player, EQUIP_HAT, false);
 /* No slot available */
 return -1;
}
/**
 * Acid has hit the player, attempt to affect some armor.
 *
 * Note that the "base armor" of an object never changes.
 * If any armor is damaged (or resists), the player takes less damage.
 */
bool minus_ac(struct player *p)
{
 int i, count = 0;
 struct object *obj = NULL;
 /* Avoid crash during monster power calculations */
 if (!p->gear) return false;
 /* Count the armor slots */
 for (i = 0; i < p->body.count; i++) {
  /* Ignore non-armor */
  if (slot_type_is(p, i, EQUIP_WEAPON)) continue;
  if (slot_type_is(p, i, EQUIP_BOW)) continue;
  if (slot_type_is(p, i, EQUIP_RING)) continue;
  if (slot_type_is(p, i, EQUIP_AMULET)) continue;
  if (slot_type_is(p, i, EQUIP_LIGHT)) continue;
  if (slot_type_is(p, i, EQUIP_QUIVER)) continue;
  /* Add */
  count++;
 }
 /* Pick one at random */
 for (i = p->body.count - 1; i >= 0; i--) {
  /* Ignore non-armor */
  if (slot_type_is(p, i, EQUIP_WEAPON)) continue;
  if (slot_type_is(p, i, EQUIP_BOW)) continue;
  if (slot_type_is(p, i, EQUIP_RING)) continue;
  if (slot_type_is(p, i, EQUIP_AMULET)) continue;
  if (slot_type_is(p, i, EQUIP_LIGHT)) continue;
  if (slot_type_is(p, i, EQUIP_QUIVER)) continue;
  if (one_in_(count--)) break;
 }
 /* Get the item */
 obj = slot_object(p, i);
 if (obj && slot_type_is(p, i, EQUIP_SHIELD) && tval_is_weapon(obj)) {
  obj = NULL;
 }
 /* Try to damage or destroy the item */
 if (obj) {
  char o_name[80];
  object_desc(o_name, sizeof(o_name), obj, ODESC_BASE, p);
  /* Object resists */
  if (obj->el_info[ELEM_ACID].flags & EL_INFO_IGNORE) {
   msg("Your %s is unaffected!", o_name);
  } else if ((obj->ps <= 0) && (obj->evn <= 0)) {
   bool none_left;
   struct object *destroyed = gear_object_for_use(p, obj, 1, false, &none_left);
   object_delete(p->cave, NULL, &destroyed->known);
   object_delete(cave, p->cave, &destroyed);
   msg("Your %s is destroyed!", o_name);
  } else {
   msg("Your %s is damaged!", o_name);
   /* Damage the item */
   if (obj->evn >= 0) {
    obj->evn--;
   } else {
    obj->ps--;
   }
   p->upkeep->update |= (PU_BONUS);
   p->upkeep->redraw |= (PR_EQUIP);
  }
  /* There was an effect */
  return true;
 } else {
  /* No damage or effect */
  return false;
 }
}
/**
 * Convert a gear object into a one character label.
 */
char gear_to_label(struct player *p, struct object *obj)
{
 /* Skip rogue-like cardinal direction movement keys. */
 const char labels[] =
   "abcdefgimnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
 int i;
 /* Equipment is easy */
 if (object_is_equipped(p->body, obj) || object_is_in_quiver(p, obj)) {
  return labels[equipped_item_slot(p->body, obj)];
 }
 /* Check the inventory */
 for (i = 0; i < z_info->pack_size; i++) {
  if (p->upkeep->inven[i] == obj) {
   return labels[i];
  }
 }
 return '\0';
}
/**
 * Remove an object from the gear list, leaving it unattached
 * \param obj the object being tested
 * \return whether an object was removed
 */
bool gear_excise_object(struct player *p, struct object *obj)
{
 int i;
 pile_excise(&p->gear_k, obj->known);
 pile_excise(&p->gear, obj);
 /* Change the weight */
 p->upkeep->total_weight -= (obj->number * obj->weight);
 /* Make sure it isn't still equipped */
 for (i = 0; i < p->body.count; i++) {
  if (slot_object(p, i) == obj) {
   p->body.slots[i].obj = NULL;
   p->upkeep->equip_cnt--;
  }
 }
 /* Update the gear */
 calc_inventory(p);
 /* Housekeeping */
 p->upkeep->update |= (PU_BONUS);
 p->upkeep->notice |= (PN_COMBINE);
 p->upkeep->redraw |= (PR_INVEN | PR_EQUIP);
 return true;
}
struct object *gear_last_item(struct player *p)
{
 return pile_last_item(p->gear);
}
void gear_insert_end(struct player *p, struct object *obj)
{
 pile_insert_end(&p->gear, obj);
 pile_insert_end(&p->gear_k, obj->known);
}
/**
 * Remove an amount of an object from the inventory or quiver, returning
 * a detached object which can be used.
 *
 * Optionally describe what remains.
 */
struct object *gear_object_for_use(struct player *p, struct object *obj,
 int num, bool message, bool *none_left)
{
 struct object *usable;
 struct object *first_remainder = NULL;
 char name[80];
 char label = gear_to_label(p, obj);
 bool artifact = (obj->known->artifact != NULL);
 /* Bounds check */
 num = MIN(num, obj->number);
 /* Split off a usable object if necessary */
 if (obj->number > num) {
  usable = object_split(obj, num);
  /* Change the weight */
  p->upkeep->total_weight -= (num * obj->weight);
  if (message) {
   uint16_t total;
   /*
			 * Don't show aggregate total in pack if equipped or
			 * if the description could have a number of charges
			 * or recharging notice specific to the stack (not
			 * aggregating those quantities so there would be
			 * confusion if aggregating the count).
			 */
   if (object_is_equipped(p->body, obj)
     || tval_can_have_charges(obj)
     || obj->timeout > 0) {
    total = obj->number;
   } else {
    total = object_pack_total(p, obj, false, &first_remainder);
    assert(total >= first_remainder->number);
    if (total == first_remainder->number) {
     first_remainder = NULL;
    }
   }
   object_desc(name, sizeof(name), obj,
    ODESC_PREFIX | ODESC_FULL | ODESC_ALTNUM |
    (total << 16), p);
  }
 } else {
  if (message) {
   if (artifact) {
    object_desc(name, sizeof(name), obj,
     ODESC_FULL | ODESC_SINGULAR, p);
   } else {
    uint16_t total;
    /*
				 * Use same logic as above for showing an
				 * aggregate total.
				 */
    if (object_is_equipped(p->body, obj)
      || tval_can_have_charges(obj)
      || obj->timeout > 0) {
     total = obj->number;
    } else {
     total = object_pack_total(p, obj,
      false, &first_remainder);
    }
    assert(total >= num);
    total -= num;
    if (!total || total <= first_remainder->number) {
     first_remainder = NULL;
    }
    object_desc(name, sizeof(name), obj,
     ODESC_PREFIX | ODESC_FULL |
     ODESC_ALTNUM | (total << 16), p);
   }
  }
  /* We're using the entire stack */
  usable = obj;
  gear_excise_object(p, usable);
  *none_left = true;
  /* Stop tracking item */
  if (tracked_object_is(p->upkeep, obj))
   track_object(p->upkeep, NULL);
  /* Inventory has changed, so disable repeat command */
  cmd_disable_repeat();
 }
 /* Housekeeping */
 p->upkeep->update |= (PU_BONUS);
 p->upkeep->notice |= (PN_COMBINE);
 p->upkeep->redraw |= (PR_INVEN | PR_EQUIP);
 /* Print a message if desired */
 if (message) {
  if (artifact) {
   msg("You no longer have the %s (%c).", name, label);
  } else if (first_remainder) {
   label = gear_to_label(p, first_remainder);
   msg("You have %s (1st %c).", name, label);
  } else {
   msg("You have %s (%c).", name, label);
  }
 }
 return usable;
}
/**
 * Handle curse checks and messaging for dropping, removing or throwing an
 * item that may be equipped and may be cursed.
 *
 * \param p is the player trying to drop, remove, or throw the object in
 * question.
 * \param obj is the object the player is trying to drop, remove, or throw.
 * \param return true if the object is equipped but can not be dropped, removed,
 * or thrown (it is cursed and the player has no ability to counteract the
 * stickiness).  Return false if the object can be dropped, removed, or thrown.
 */
bool handle_stickied_removal(struct player *p, struct object *obj)
{
  /* There's no problem and no messaging needed if the item is
		 * not equipped or is equipped but not cursed. */
 if (!object_is_equipped(player->body, obj) || !obj_is_cursed(obj)) {
  return false;
 }
 if (player_active_ability(player, "Curse Breaking")) {
  msg("With a great strength of will, you break the curse!");
  uncurse_object(obj);
  return false;
 }
 msg("You cannot bear to part with it.");
 return true;
}
/**
 * Calculate how much of an item is can be carried in the inventory or quiver.
 */
int inven_carry_num(const struct player *p, const struct object *obj)
{
 int max_weight = (weight_limit(p->state) * 3) / 2;
 int num_lim, num_to_quiver, num_left, i;
 /* Check how many can be carried without going over the weight limit. */
 if (p->upkeep->total_weight > max_weight) {
  return 0;
 }
 if (p->upkeep->total_weight + obj->weight * obj->number
   <= max_weight) {
  num_lim = obj->number;
 } else {
  num_lim = (max_weight - p->upkeep->total_weight) / obj->weight;
  if (!num_lim) {
   return 0;
  }
 }
 /* Absorb as many as we can in the quiver. */
 num_to_quiver = 0;
 for (i = 0; i < p->body.count; i++) {
  struct object *q_obj = p->body.slots[i].obj;
  int num_already = q_obj ? q_obj->number : 0;
  if (!slot_type_is(p, i, EQUIP_QUIVER)) continue;
  if (!tval_is_ammo(obj)) continue;
  if (!num_already || object_stackable(q_obj, obj, OSTACK_PACK)) {
   num_to_quiver += obj->kind->base->max_stack - num_already;
  }
 }
 /* The quiver will get everything, or the pack can hold what's left. */
 if (num_to_quiver >= num_lim
   || z_info->pack_size - pack_slots_used(p) > 0) {
  return num_lim;
 }
 /* See if we can add to a partially full inventory slot. */
 num_left = num_lim - num_to_quiver;
 for (i = 0; i < z_info->pack_size; i++) {
  struct object *inven_obj = p->upkeep->inven[i];
  if (inven_obj && object_stackable(inven_obj, obj, OSTACK_PACK)) {
   num_left -= inven_obj->kind->base->max_stack -
    inven_obj->number;
   if (num_left <= 0) break;
  }
 }
 /* Return the number we can absorb */
 return num_lim - MAX(num_left, 0);
}
/**
 * Check if we have space for some of an item in the pack.
 */
bool inven_carry_okay(const struct object *obj)
{
 return inven_carry_num(player, obj) > 0;
}
/**
 * Describe the charges on an item in the inventory.
 */
void inven_item_charges(struct object *obj)
{
 /* Require staff/wand */
 if (tval_can_have_charges(obj) && object_flavor_is_aware(obj)) {
  msg("You have %d charge%s remaining.",
    obj->pval,
    PLURAL(obj->pval));
 }
}
/**
 * Add an item to the players inventory.
 *
 * If the new item can combine with an existing item in the inventory,
 * it will do so, using object_mergeable() and object_absorb(), else,
 * the item will be placed into the first available gear array index.
 *
 * This function can be used to "over-fill" the player's pack, but only
 * once, and such an action must trigger the "overflow" code immediately.
 * Note that when the pack is being "over-filled", the new item must be
 * placed into the "overflow" slot, and the "overflow" must take place
 * before the pack is reordered, but (optionally) after the pack is
 * combined.  This may be tricky.  See "dungeon.c" for info.
 *
 * Note that this code removes any location information from the object once
 * it is placed into the inventory, but takes no responsibility for removing
 * the object from any other pile it was in.
 */
void inven_carry(struct player *p, struct object *obj, bool absorb,
     bool message)
{
 bool combining = false;
 /* Check for combining, if appropriate */
 if (absorb) {
  struct object *combine_item = NULL;
  struct object *gear_obj = p->gear;
  while ((combine_item == NULL) && (gear_obj != NULL)) {
   if (!object_is_equipped(p->body, gear_obj) &&
    object_mergeable(gear_obj, obj, OSTACK_PACK)) {
    combine_item = gear_obj;
   }
   gear_obj = gear_obj->next;
  }
  if (combine_item) {
   /* Increase the weight */
   p->upkeep->total_weight += (obj->number * obj->weight);
   /* Combine the items */
   object_absorb(combine_item->known, obj->known);
   obj->known = NULL;
   object_absorb(combine_item, obj);
   /* Ensure numbers are aligned (should not be necessary, but safe) */
   combine_item->known->number = combine_item->number;
   obj = combine_item;
   combining = true;
  }
 }
 /* We didn't manage the find an object to combine with */
 if (!combining) {
  /* Paranoia */
  assert(pack_slots_used(p) <= z_info->pack_size);
  gear_insert_end(p, obj);
  apply_autoinscription(p, obj);
  /* Remove cave object details */
  obj->held_m_idx = 0;
  obj->grid = loc(0, 0);
  obj->known->grid = loc(0, 0);
  /* Update the inventory */
  p->upkeep->total_weight += (obj->number * obj->weight);
  p->upkeep->notice |= (PN_COMBINE);
 }
 p->upkeep->update |= (PU_BONUS | PU_INVEN);
 p->upkeep->redraw |= (PR_INVEN);
 update_stuff(p);
 if (message) {
  char o_name[80];
  struct object *first;
  uint16_t total;
  char label;
  /*
		 * Show an aggregate total if the description doesn't have
		 * a charge/recharging notice that's specific to the stack.
		 */
  if (tval_can_have_charges(obj) || obj->timeout > 0) {
   total = obj->number;
   first = obj;
  } else {
   total = object_pack_total(p, obj, false, &first);
  }
  assert(first && total >= first->number);
  object_desc(o_name, sizeof(o_name), obj,
   ODESC_PREFIX | ODESC_FULL | ODESC_ALTNUM |
   (total << 16), p);
  label = gear_to_label(p, first);
  if (total > first->number) {
   msg("You have %s (1st %c).", o_name, label);
  } else {
   assert(first == obj);
   msg("You have %s (%c).", o_name, label);
  }
 }
 if (object_is_in_quiver(p, obj))
  sound(MSG_QUIVER);
}
/**
 * Wield or wear a single item from the pack or floor
 */
void inven_wield(struct object *obj, int slot)
{
 struct object *wielded, *old = player->body.slots[slot].obj;
 struct object *weapon = equipped_item_by_slot_name(player, "weapon");
 int shield_slot = slot_by_name(player, "arm");
 const char *fmt;
 char o_name[80];
 bool dummy = false;
 int num = tval_is_ammo(obj) ?
  ((object_is_carried(player, obj)) ?
   obj->number : inven_carry_num(player, obj)) : 1;
 struct ability *ability;
 /* Deal with wielding of shield or second weapon when already wielding a
	 * hand and a half weapon */
 bool less_effective = weapon && (slot == shield_slot)
  && of_has(weapon->flags, OF_HAND_AND_A_HALF) && !old;
 /* Increase equipment counter if empty slot */
 if (old == NULL)
  player->upkeep->equip_cnt++;
 /* Take a turn */
 player->upkeep->energy_use = z_info->move_energy;
 /* Store the action type */
 player->previous_action[0] = ACTION_MISC;
 /* It's either a gear object or a floor object */
 if (object_is_carried(player, obj)) {
  /* Split off a new object if necessary */
  if (obj->number > num) {
   wielded = gear_object_for_use(player, obj, num, false, &dummy);
   /* It's still carried; keep its weight in the total. */
   assert(wielded->number == num);
   player->upkeep->total_weight += wielded->weight * num;
   /* The new item needs new gear and known gear entries */
   wielded->next = obj->next;
   obj->next = wielded;
   wielded->prev = obj;
   if (wielded->next)
    (wielded->next)->prev = wielded;
   wielded->known->next = obj->known->next;
   obj->known->next = wielded->known;
   wielded->known->prev = obj->known;
   if (wielded->known->next)
    (wielded->known->next)->prev = wielded->known;
  } else {
   /* Just use the object directly */
   wielded = obj;
  }
 } else {
  /* Get a floor item and carry it */
  wielded = floor_object_for_use(player, obj, num, false, &dummy);
  inven_carry(player, wielded, false, false);
 }
 /* Wear the new stuff */
 player->body.slots[slot].obj = wielded;
 /* Deal with wielding of two-handed weapons when already using a shield */
 if (of_has(obj->flags, OF_TWO_HANDED) && slot_object(player, shield_slot)) {
  /* Take off shield */
  inven_takeoff(player->body.slots[shield_slot].obj);
 }
 /* Deal with wielding of shield or second weapon when already wielding
	 * a two handed weapon */
 if ((slot == shield_slot) && weapon &&
  of_has(weapon->flags, OF_TWO_HANDED)) {
  /* Stop wielding two handed weapon */
  inven_takeoff(weapon);
 }
 /* Do any ID-on-wield */
 object_learn_on_wield(player, wielded);
 /* Where is the item now */
 if (tval_is_melee_weapon(wielded))
  fmt = "You are wielding %s (%c).";
 else if (wielded->tval == TV_BOW)
  fmt = "You are shooting with %s (%c).";
 else if (tval_is_light(wielded))
  fmt = "Your light source is %s (%c).";
 else if (tval_is_ammo(wielded))
  fmt = "In your quiver you have %s (%c)";
 else
  fmt = "You are wearing %s (%c).";
 /* Describe the result */
 object_desc(o_name, sizeof(o_name), wielded, ODESC_PREFIX | ODESC_FULL,
    player);
 /* Message */
 msgt(MSG_WIELD, fmt, o_name, gear_to_label(player, wielded));
 /* Sticky flag gets a special mention */
 if (obj_is_cursed(wielded)) {
  /* Warn the player */
  msgt(MSG_CURSED, "You have a bad feeling about this...");
  of_on(obj->known->flags, OF_CURSED);
 }
 if (less_effective) {
  /* Describe it */
  object_desc(o_name, sizeof(o_name), weapon, ODESC_BASE, player);
  /* Message */
  msg("You are no longer able to wield your %s as effectively.", o_name);
 }
 /* Activate all of its new abilities */
 for (ability = wielded->abilities; ability; ability = ability->next) {
  if (!player_has_ability(player, ability)) {
   add_ability(&player->item_abilities, ability);
   activate_ability(&player->item_abilities, ability);
  }
 }
 /* See if we have to overflow the pack */
 combine_pack(player);
 pack_overflow(old);
 /* Recalculate bonuses, torch, mana, gear */
 player->upkeep->notice |= (PN_IGNORE);
 player->upkeep->update |= (PU_BONUS | PU_INVEN | PU_UPDATE_VIEW);
 player->upkeep->redraw |= (PR_INVEN | PR_EQUIP | PR_ARC | PR_ARMOR);
 player->upkeep->redraw |= (PR_MELEE | PR_STATS | PR_HP | PR_MANA |PR_SPEED);
 update_stuff(player);
 /* Disable repeats */
 cmd_disable_repeat();
}
/**
 * Take off a non-cursed equipment item
 *
 * Note that taking off an item when "full" may cause that item
 * to fall to the ground.
 *
 * Note also that this function does not try to combine the taken off item
 * with other inventory items - that must be done by the calling function.
 */
void inven_takeoff(struct object *obj)
{
 int slot = equipped_item_slot(player->body, obj);
 const char *act;
 char o_name[80];
 struct ability *ability;
 /* Paranoia */
 if (slot == player->body.count) return;
 /* Describe the object */
 object_desc(o_name, sizeof(o_name), obj, ODESC_PREFIX | ODESC_FULL,
  player);
 /* Describe removal by slot */
 if (slot_type_is(player, slot, EQUIP_WEAPON))
  act = "You were wielding";
 else if (slot_type_is(player, slot, EQUIP_BOW))
  act = "You were holding";
 else if (slot_type_is(player, slot, EQUIP_LIGHT))
  act = "You were holding";
 else
  act = "You were wearing";
 /* De-equip the object */
 player->body.slots[slot].obj = NULL;
 player->upkeep->equip_cnt--;
 /* Remove all of its abilities from the player */
 for (ability = obj->abilities; ability; ability = ability->next) {
  remove_ability(&player->item_abilities, ability);
 }
 player->upkeep->update |= (PU_BONUS | PU_INVEN | PU_UPDATE_VIEW);
 player->upkeep->notice |= (PN_IGNORE);
 update_stuff(player);
 /* Message */
 msgt(MSG_WIELD, "%s %s (%c).", act, o_name, gear_to_label(player, obj));
 return;
}
/**
 * Drop (some of) a non-cursed inventory/equipment item "near" the current
 * location
 *
 * There are two cases here - a single object or entire stack is being dropped,
 * or part of a stack is being split off and dropped
 */
void inven_drop(struct object *obj, int amt)
{
 struct object *dropped;
 bool none_left = false;
 bool equipped = false;
 bool quiver;
 char name[80];
 char label;
 /* Error check */
 if (amt <= 0)
  return;
 /* Check it is still held, in case there were two drop commands queued
	 * for this item.  This is in theory not ideal, but in practice should
	 * be safe. */
 if (!object_is_carried(player, obj))
  return;
 /* Get where the object is now */
 label = gear_to_label(player, obj);
 /* Is it in the quiver? */
 quiver = object_is_in_quiver(player, obj);
 /* Not too many */
 if (amt > obj->number) amt = obj->number;
 /* Take off equipment, don't combine */
 if (object_is_equipped(player->body, obj)) {
  equipped = true;
  inven_takeoff(obj);
 }
 /* Get the object */
 dropped = gear_object_for_use(player, obj, amt, false, &none_left);
 /* Describe the dropped object */
 object_desc(name, sizeof(name), dropped, ODESC_PREFIX | ODESC_FULL,
  player);
 /* Message */
 msg("You drop %s (%c).", name, label);
 /* Describe what's left */
 if (dropped->artifact) {
  object_desc(name, sizeof(name), dropped,
   ODESC_FULL | ODESC_SINGULAR, player);
  msg("You no longer have the %s (%c).", name, label);
 } else {
  struct object *first;
  struct object *desc_target;
  uint16_t total;
  /*
		 * Like gear_object_for_use(), don't show an aggregate total
		 * if it was equipped or the item has charges/recharging
		 * notice that is specific to the stack.
		 */
  if (equipped || tval_can_have_charges(obj) || obj->timeout > 0) {
   first = NULL;
   if (none_left) {
    total = 0;
    desc_target = dropped;
   } else {
    total = obj->number;
    desc_target = obj;
   }
  } else {
   total = object_pack_total(player, obj, false, &first);
   desc_target = (total) ? obj : dropped;
  }
  object_desc(name, sizeof(name), desc_target,
   ODESC_PREFIX | ODESC_FULL | ODESC_ALTNUM |
   (total << 16), player);
  if (!first) {
   msg("You have %s (%c).", name, label);
  } else {
   label = gear_to_label(player, first);
   if (total > first->number) {
    msg("You have %s (1st %c).", name, label);
   } else {
    msg("You have %s (%c).", name, label);
   }
  }
 }
 /* Drop it near the player */
 drop_near(cave, &dropped, 0, player->grid, false, true);
 /* Sound for quiver objects */
 if (quiver)
  sound(MSG_QUIVER);
 event_signal(EVENT_INVENTORY);
 event_signal(EVENT_EQUIPMENT);
}
/**
 * Destroy (some of) a non-cursed inventory/equipment item "near" the current
 * location
 *
 * There are two cases here - a single object or entire stack is being
 * destroyed, or part of a stack is being split off and destroyed
 */
bool inven_destroy(struct object *obj, int amt)
{
 struct object *destroyed;
 bool none_left = false;
 bool equipped = false;
 bool quiver;
 char name[80];
 char out_val[160];
 char label;
 int num = obj->number;
 /* Error check */
 if (amt <= 0)
  return false;
 /* Check it is still held, in case there were two drop commands queued
	 * for this item.  This is in theory not ideal, but in practice should
	 * be safe. */
 if (!object_is_carried(player, obj))
  return false;
 /* Get where the object is now */
 label = gear_to_label(player, obj);
 /* Is it in the quiver? */
 quiver = object_is_in_quiver(player, obj);
 /* Not too many */
 if (amt > obj->number) amt = obj->number;
 /* Describe the destroyed object */
 obj->number = amt;
 object_desc(name, sizeof(name), obj, ODESC_PREFIX | ODESC_FULL, player);
 obj->number = num;
 /* Check for known special items */
 strnfmt(out_val, sizeof(out_val), "Really destroy %s? ", name);
 if (!get_check(out_val)) return false;
 /* Take off equipment, don't combine */
 if (object_is_equipped(player->body, obj)) {
  equipped = true;
  inven_takeoff(obj);
 }
 /* Get the object */
 destroyed = gear_object_for_use(player, obj, amt, false, &none_left);
 /* Message */
 msg("You destroy %s (%c).", name, label);
 /* Describe what's left */
 if (destroyed->artifact) {
  object_desc(name, sizeof(name), destroyed,
   ODESC_FULL | ODESC_SINGULAR, player);
  msg("You no longer have the %s (%c).", name, label);
 } else {
  struct object *first;
  struct object *desc_target;
  uint16_t total;
  /*
		 * Like gear_object_for_use(), don't show an aggregate total
		 * if it was equipped or the item has charges/recharging
		 * notice that is specific to the stack.
		 */
  if (equipped || tval_can_have_charges(obj)) {
   first = NULL;
   if (none_left) {
    total = 0;
    desc_target = destroyed;
   } else {
    total = obj->number;
    desc_target = obj;
   }
  } else {
   total = object_pack_total(player, obj, false, &first);
   desc_target = (total) ? obj : destroyed;
  }
  object_desc(name, sizeof(name), desc_target,
   ODESC_PREFIX | ODESC_FULL | ODESC_ALTNUM |
   (total << 16), player);
  if (!first) {
   msg("You have %s (%c).", name, label);
  } else {
   label = gear_to_label(player, first);
   if (total > first->number) {
    msg("You have %s (1st %c).", name, label);
   } else {
    msg("You have %s (%c).", name, label);
   }
  }
 }
 /* Destroy it */
 object_delete(player->cave, NULL, &destroyed->known);
 object_delete(cave, player->cave, &destroyed);
 /* Sound for quiver objects */
 if (quiver)
  sound(MSG_QUIVER);
 event_signal(EVENT_INVENTORY);
 event_signal(EVENT_EQUIPMENT);
 return true;
}
/**
 * Return whether each stack of objects can be merged into two uneven stacks.
 */
static bool inven_can_stack_partial(const struct object *obj1,
         const struct object *obj2)
{
 if (!object_stackable(obj1, obj2, OSTACK_PACK)) {
  return false;
 }
 /* Verify the numbers are suitable for uneven stacks.  Want the
	 * leading stack, obj1, to have its count maximized. */
 if (obj1->number == obj1->kind->base->max_stack) {
  return false;
 }
 return true;
}
/**
 * Combine items in the pack, confirming no blank objects
 */
void combine_pack(struct player *p)
{
 struct object *obj1, *obj2, *prev;
 bool display_message = false;
 bool disable_repeat = false;
 /* Combine the pack (backwards) */
 obj1 = gear_last_item(p);
 while (obj1) {
  assert(obj1->kind);
  prev = obj1->prev;
  /* Scan the items above that item */
  for (obj2 = p->gear; obj2 && obj2 != obj1; obj2 = obj2->next) {
   assert(obj2->kind);
   /* Can we drop "obj1" onto "obj2"? */
   if (object_mergeable(obj2, obj1, OSTACK_PACK)) {
    /*
				 * The quiver slots do not count as equipped
				 * so may be merged with something else.
				 * Handle the side effects of that.
				 */
    int quiver1_slot =
     slot_by_name(p, "first quiver");
    struct object *quiver1_obj =
     slot_object(p, quiver1_slot);
    int quiver2_slot =
     slot_by_name(p, "second quiver");
    struct object *quiver2_obj =
     slot_object(p, quiver2_slot);
    if (obj1 == quiver1_obj) {
     if (obj2 == quiver2_obj) {
      /*
						 * Merging the two quiver slots.
						 * Prefer to keep the first
						 * occupied.
						 */
      p->body.slots[quiver1_slot].obj
       = quiver2_obj;
      p->body.slots[quiver2_slot].obj
       = NULL;
      --p->upkeep->equip_cnt;
     } else {
      /*
						 * Merging with a stack in the
						 * pack.  Put that stack in the
						 * quiver.
						 */
      p->body.slots[quiver1_slot].obj
       = obj2;
     }
    } else if (obj1 == quiver2_obj) {
     if (obj2 == quiver1_obj) {
      /*
						 * Merging the two quiver slots.
						 * Prefer to keep the first
						 * occupied.
						 */
      p->body.slots[quiver2_slot].obj
       = NULL;
      --p->upkeep->equip_cnt;
     } else {
      /*
						 * Merging with a stack in the
						 * pack.  Put that stack in the
						 * quiver.
						 */
      p->body.slots[quiver2_slot].obj
       = obj2;
     }
    }
    display_message = true;
    disable_repeat = true;
    object_absorb(obj2->known, obj1->known);
    obj1->known = NULL;
    object_absorb(obj2, obj1);
    /* Ensure numbers align (should not be necessary, but safer) */
    obj2->known->number = obj2->number;
    break;
   } else {
    if (inven_can_stack_partial(obj2, obj1)) {
     /* Don't display a message for this case:  shuffling items
					 * between stacks isn't interesting to the player. */
     object_absorb_partial(obj2->known, obj1->known);
     object_absorb_partial(obj2, obj1);
     /* Ensure numbers align (should not be
					 * necessary, but safer) */
     obj2->known->number = obj2->number;
     obj1->known->number = obj1->number;
     break;
    }
   }
  }
  obj1 = prev;
 }
 calc_inventory(p);
 /* Redraw gear */
 event_signal(EVENT_INVENTORY);
 event_signal(EVENT_EQUIPMENT);
 /* Message */
 if (display_message) {
  msg("You combine some items in your pack.");
  /*
		 * Stop "repeat last command" from working if a stack was
		 * completely combined with another.
		 */
  if (disable_repeat) cmd_disable_repeat();
 }
}
/**
 * Returns whether the pack is holding the maximum number of items.
 */
bool pack_is_full(void)
{
 return pack_slots_used(player) == z_info->pack_size;
}
/**
 * Returns whether the pack is holding the more than the maximum number of
 * items. If this is true, calling pack_overflow() will trigger a pack overflow.
 */
bool pack_is_overfull(void)
{
 return pack_slots_used(player) > z_info->pack_size;
}
/**
 * Overflow an item from the pack, if it is overfull.
 */
void pack_overflow(struct object *obj)
{
 int i;
 char o_name[80];
 if (!pack_is_overfull()) return;
 /* Disturbing */
 disturb(player, false);
 /* Warning */
 msg("Your pack overflows!");
 /* Get the last proper item */
 for (i = 1; i <= z_info->pack_size; i++)
  if (!player->upkeep->inven[i])
   break;
 /* Drop the last inventory item unless requested otherwise */
 if (!obj) {
  obj = player->upkeep->inven[i - 1];
 }
 /* Rule out weirdness (like pack full, but inventory empty) */
 assert(obj != NULL);
 /* Describe */
 object_desc(o_name, sizeof(o_name), obj, ODESC_PREFIX | ODESC_FULL,
  player);
 /* Message */
 msg("You drop %s.", o_name);
 /* Excise the object and drop it (carefully) near the player */
 gear_excise_object(player, obj);
 drop_near(cave, &obj, 0, player->grid, false, true);
 /* Describe */
 msg("You no longer have %s.", o_name);
 /* Notice, update, redraw */
 if (player->upkeep->notice) notice_stuff(player);
 if (player->upkeep->update) update_stuff(player);
 if (player->upkeep->redraw) redraw_stuff(player);
}
/**
 * Return true if the player has something in their inventory designed for
 * throwing.
 *
 * \param p is the player
 * \param show_msg should be set to true if a failure message should be
 * displayed.
 */
bool player_has_throwable(struct player *p, bool show_msg)
{
 struct object *thrown;
 int nthrow = scan_items(&thrown, 1, player, USE_INVEN, obj_is_throwing);
 if (nthrow <= 0) {
  if (show_msg) {
   msg("You don't have anything designed for throwing in your inventory.");
  }
  return false;
 }
 return true;
}
/**
 * Prerequisite function for command. See struct cmd_info in ui-input.h and
 * it's use in ui-game.c.
 */
bool player_has_throwable_prereq(void)
{
 return player_has_throwable(player, true);
}
/**
 * \file obj-ignore.c
 * \brief Item ignoring
 *
 * Copyright (c) 2007 David T. Blackston, Iain McFall, DarkGod, Jeff Greene,
 * David Vestal, Pete Mack, Andi Sidwell.
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
typedef struct
{
 ignore_type_t ignore_type;
 int tval;
 const char *identifier;
} quality_ignore_struct;
/**
 * Any entry here with an identifier should appear above the entry with the
 * same tval and no identifier
 */
static quality_ignore_struct quality_mapping[] =
{
 { ITYPE_SHARP, TV_SWORD, "" },
 { ITYPE_SHARP, TV_POLEARM, "" },
 { ITYPE_BLUNT, TV_HAFTED, "" },
 { ITYPE_BOW, TV_BOW, "Bow" },
 { ITYPE_ARROW, TV_ARROW, "" },
 { ITYPE_ROBE, TV_SOFT_ARMOR, "Robe" },
 { ITYPE_BODY_ARMOR, TV_MAIL, "" },
 { ITYPE_BODY_ARMOR, TV_SOFT_ARMOR, "" },
 { ITYPE_CLOAK, TV_CLOAK, "" },
 { ITYPE_SHIELD, TV_SHIELD, "" },
 { ITYPE_HEADGEAR, TV_HELM, "" },
 { ITYPE_HEADGEAR, TV_CROWN, "" },
 { ITYPE_HANDGEAR, TV_GLOVES, "" },
 { ITYPE_FEET, TV_BOOTS, "" },
 { ITYPE_DIGGER, TV_DIGGING, "" },
 { ITYPE_RING, TV_RING, "" },
 { ITYPE_AMULET, TV_AMULET, "" },
 { ITYPE_LIGHT, TV_LIGHT, "" },
};
quality_name_struct quality_choices[] =
{
/**
 * \file list-ignore-types.h
 * \brief types of object used for ignoring by quality or ego
 */
/* index					description */
{ ITYPE_NONE, "" },
{ ITYPE_SHARP, "Sharp Melee Weapons" },
{ ITYPE_BLUNT, "Blunt Melee Weapons" },
{ ITYPE_BOW, "Bows" },
{ ITYPE_ARROW, "Arrows" },
{ ITYPE_ROBE, "Robes" },
{ ITYPE_BODY_ARMOR, "Body Armor" },
{ ITYPE_CLOAK, "Cloaks" },
{ ITYPE_SHIELD, "Shields" },
{ ITYPE_HEADGEAR, "Headgear" },
{ ITYPE_HANDGEAR, "Handgear" },
{ ITYPE_FEET, "Footgear" },
{ ITYPE_DIGGER, "Diggers" },
{ ITYPE_RING, "Rings" },
{ ITYPE_AMULET, "Amulets" },
{ ITYPE_LIGHT, "Lights" },

};
/**
 * The names for the various kinds of quality
 */
quality_name_struct quality_values[IGNORE_MAX] =
{
 { IGNORE_NONE, "no ignore" },
 { IGNORE_BAD, "bad" },
 { IGNORE_AVERAGE, "average" },
 { IGNORE_GOOD, "good" },
 { IGNORE_ALL, "non-artifact" },
};
uint8_t ignore_level[ITYPE_MAX];
const size_t ignore_size = ITYPE_MAX;
bool **ego_ignore_types;
/* Hackish - ego_ignore_types should be initialised with arrays */
static int num_ego_types;
/**
 * Initialise the ignore package 
 */
static void init_ignore(void)
{
 int i;
 num_ego_types = z_info->e_max;
 ego_ignore_types = mem_zalloc(z_info->e_max * sizeof(bool*));
 for (i = 0; i < z_info->e_max; i++)
  ego_ignore_types[i] = mem_zalloc(ITYPE_MAX * sizeof(bool));
}
/**
 * Clean up the ignore package
 */
static void cleanup_ignore(void)
{
 int i;
 for (i = 0; i < num_ego_types; i++)
  mem_free(ego_ignore_types[i]);
 mem_free(ego_ignore_types);
}
/**
 * Reset the player's ignore choices for a new game.
 */
void ignore_birth_init(void)
{
 int i, j;
 /* Reset ignore bits */
 for (i = 0; i < z_info->k_max; i++)
  k_info[i].ignore = false;
 /* Clear the ignore bytes */
 for (i = ITYPE_NONE; i < ITYPE_MAX; i++)
  ignore_level[i] = IGNORE_NONE;
 /* Clear ego ignore */
 for (i = 0; i < z_info->e_max; i++)
  for (j = ITYPE_NONE; j < ITYPE_MAX; j++)
   ego_ignore_types[i][j] = 0;
}
/**
 * ------------------------------------------------------------------------
 * Autoinscription stuff
 * ------------------------------------------------------------------------ */
/**
 * Make or extend a rune autoinscription
 */
static void rune_add_autoinscription(struct object *obj, int i)
{
 char current_note[80] = "";
 /* No autoinscription, or already there, don't bother */
 if (!rune_note(i)) return;
 if (obj->note && strstr(quark_str(obj->note), quark_str(rune_note(i))))
  return;
 /* Extend any current note */
 if (obj->note)
  my_strcpy(current_note, quark_str(obj->note), sizeof(current_note));
 my_strcat(current_note, quark_str(rune_note(i)), sizeof(current_note));
 /* Add the inscription */
 obj->note = quark_add(current_note);
}
/**
 * Put a rune autoinscription on all available objects
 */
void rune_autoinscribe(struct player *p, int i)
{
 struct object *obj;
 /* Check the player knows the rune */
 if (!player_knows_rune(p, i)) {
  return;
 }
 /* Autoinscribe each object on the ground */
 if (cave)
  for (obj = square_object(cave, p->grid); obj; obj = obj->next)
   if (object_has_rune(obj, i))
    rune_add_autoinscription(obj, i);
 /* Autoinscribe each object in the inventory */
 for (obj = p->gear; obj; obj = obj->next)
  if (object_has_rune(obj, i))
   rune_add_autoinscription(obj, i);
}
/**
 * Put all appropriate rune autoinscriptions on an object
 */
static void runes_autoinscribe(struct player *p, struct object *obj)
{
 int i, rune_max = max_runes();
 for (i = 0; i < rune_max; i++)
  if (object_has_rune(obj, i) && player_knows_rune(p, i))
   rune_add_autoinscription(obj, i);
}
/**
 * Return an object kind autoinscription
 */
const char *get_autoinscription(struct object_kind *kind, bool aware)
{
 if (!kind)
  return NULL;
 else if (aware)
  return quark_str(kind->note_aware);
 else
  return quark_str(kind->note_unaware);
}
/**
 * Put an autoinscription on an object
 */
int apply_autoinscription(struct player *p, struct object *obj)
{
 char o_name[80];
 bool aware = obj->kind->aware;
 const char *note = obj ? get_autoinscription(obj->kind, aware) : NULL;
 /*
	 * Remove unaware inscription if aware and the aware inscription
	 * differs from the unaware one.
	 */
 if (aware && quark_str(obj->note) && quark_str(obj->kind->note_unaware)
   && streq(quark_str(obj->note),
   quark_str(obj->kind->note_unaware)) && (!note
   || !streq(quark_str(obj->note), note)))
  obj->note = 0;
 /* Make rune autoinscription go first, for now */
 runes_autoinscribe(p, obj);
 /* No note - don't inscribe */
 if (!note)
  return 0;
 /* Don't re-inscribe if it's already inscribed */
 if (obj->note)
  return 0;
 /* Don't inscribe unless the player is carrying it */
 if (!object_is_carried(p, obj))
  return 0;
 /* Don't inscribe if ignored */
 if (ignore_item_ok(p, obj))
  return 0;
 /* Get an object description */
 object_desc(o_name, sizeof(o_name), obj, ODESC_PREFIX | ODESC_FULL, p);
 if (note[0] != 0)
  obj->note = quark_add(note);
 else
  obj->note = 0;
 msg("You autoinscribe %s.", o_name);
 return 1;
}
/**
 * Deregister an object kind autoinscription
 */
int remove_autoinscription(int16_t kind)
{
 struct object_kind *k = objkind_byid(kind);
 if (!k)
  return 0;
 /* Unaware */
 if (!k->aware) {
  if (!k->note_unaware) {
   return 0;
  } else {
   k->note_unaware = 0;
   return 1;
  }
 }
 /* Aware */
 if (!k->note_aware)
  return 0;
 k->note_aware = 0;
 return 1;
}
/**
 * Register an object kind autoinscription
 */
int add_autoinscription(int16_t kind, const char *inscription, bool aware)
{
 struct object_kind *k = objkind_byid(kind);
 if (!k)
  return 0;
 if (!inscription)
  return remove_autoinscription(kind);
 if (aware)
  k->note_aware = quark_add(inscription);
 else
  k->note_unaware = quark_add(inscription);
 return 1;
}
/**
 * Put an autoinscription on all objects on the floor beneath the player
 */
void autoinscribe_ground(struct player *p)
{
 struct object *obj;
 /* Autoinscribe each object in the pile */
 for (obj = square_object(cave, p->grid); obj; obj = obj->next)
  apply_autoinscription(p, obj);
}
/**
 * Put an autoinscription on all the player's carried objects
 */
void autoinscribe_pack(struct player *p)
{
 struct object *obj;
 /* Autoinscribe each object in the inventory */
 for (obj = p->gear; obj; obj = obj->next)
  apply_autoinscription(p, obj);
}
/**
 * ------------------------------------------------------------------------
 * Ignore code
 * ------------------------------------------------------------------------ */
/**
 * Ignore the flavor of an object
 */
void object_ignore_flavor_of(const struct object *obj)
{
 if (object_flavor_is_aware(obj))
  obj->kind->ignore |= IGNORE_IF_AWARE;
 else
  obj->kind->ignore |= IGNORE_IF_UNAWARE;
}
/**
 * Find the ignore type of the object, or ITYPE_MAX if none
 */
ignore_type_t ignore_type_of(const struct object *obj)
{
 size_t i;
 /* Find the appropriate ignore group */
 for (i = 0; i < N_ELEMENTS(quality_mapping); i++) {
  if (quality_mapping[i].tval == obj->tval) {
   /* If there's an identifier, it must match */
   if (quality_mapping[i].identifier[0]) {
    if (!strstr(obj->kind->name, quality_mapping[i].identifier))
     continue;
   }
   /* Otherwise we're fine */
   return quality_mapping[i].ignore_type;
  }
 }
 return ITYPE_MAX;
}
/**
 * Find whether an ignore type is valid for a given ego item
 */
bool ego_has_ignore_type(struct ego_item *ego, ignore_type_t itype)
{
 struct poss_item *poss;
 /* Go through all the possible items */
 for (poss = ego->poss_items; poss; poss = poss->next) {
  size_t i;
  struct object_kind *kind = &k_info[poss->kidx];
  /* Check the appropriate ignore group */
  for (i = 0; i < N_ELEMENTS(quality_mapping); i++)
   if ((quality_mapping[i].tval == kind->tval) &&
    (quality_mapping[i].ignore_type == itype) &&
    strstr(kind->name, quality_mapping[i].identifier))
    return true;
 }
 return false;
}
/**
 * Small helper function to see how an object trait compares to the one
 * in its base type.
 *
 * If the base type provides a positive bonus, we'll use that. Otherwise, we'll
 * use zero (players don't consider an item with a positive bonus to be bad
 * even if the base kind has a higher positive bonus).
 */
static int cmp_object_trait(int bonus, int base)
{
 int amt = base;
 if (amt > 0) amt = 0;
 return CMP(bonus, amt);
}
/**
 * Small helper function to see if an item seems good, bad or average based on
 * to_h, to_d and to_a.
 *
 * The sign of the return value announces if the object is bad (negative),
 * good (positive) or average (zero).
 */
static int is_object_good(const struct object *obj)
{
 int good = 0;
 good += cmp_object_trait(obj->att, obj->kind->att);
 good += cmp_object_trait(obj->dd, obj->kind->dd);
 good += cmp_object_trait(obj->ds, obj->kind->ds);
 good += cmp_object_trait(obj->evn, obj->kind->evn);
 good += cmp_object_trait(obj->pd, obj->kind->pd);
 good += cmp_object_trait(obj->ps, obj->kind->ps);
 return good;
}
/**
 * Determine the ignore level of an object
 *
 * The main point is when the value is undetermined given current info,
 * return the maximum possible value.
 */
uint8_t ignore_level_of(const struct object *obj)
{
 uint8_t value = 0;
 /* Now just do bad, average, good, ego */
 if (object_runes_known(obj)) {
  int isgood = is_object_good(obj);
  /* Values for items not egos or artifacts, may be updated */
  if (isgood > 0) {
   value = IGNORE_GOOD;
  } else if (isgood < 0) {
   value = IGNORE_BAD;
  } else {
   value = IGNORE_AVERAGE;
  }
  if (obj->ego)
   value = IGNORE_ALL;
  else if (obj->artifact)
   value = IGNORE_MAX;
 } else {
  if ((obj->known->notice & OBJ_NOTICE_ASSESSED) && !obj->artifact)
   value = IGNORE_ALL;
  else
   value = IGNORE_MAX;
 }
 return value;
}
/**
 * Remove any ignoring of a particular flavor
 */
void kind_ignore_clear(struct object_kind *kind)
{
 kind->ignore = 0;
 player->upkeep->notice |= PN_IGNORE;
}
void ego_ignore(struct object *obj)
{
 assert(obj->ego);
 ego_ignore_types[obj->ego->eidx][ignore_type_of(obj)] = true;
 player->upkeep->notice |= PN_IGNORE;
}
void ego_ignore_clear(struct object *obj)
{
 assert(obj->ego);
 ego_ignore_types[obj->ego->eidx][ignore_type_of(obj)] = false;
 player->upkeep->notice |= PN_IGNORE;
}
void ego_ignore_toggle(int e_idx, int itype)
{
 ego_ignore_types[e_idx][itype] = !ego_ignore_types[e_idx][itype];
 player->upkeep->notice |= PN_IGNORE;
}
bool ego_is_ignored(int e_idx, int itype)
{
 return ego_ignore_types[e_idx][itype];
}
bool kind_is_ignored_aware(const struct object_kind *kind)
{
 return (kind->ignore & IGNORE_IF_AWARE) ? true : false;
}
bool kind_is_ignored_unaware(const struct object_kind *kind)
{
 return (kind->ignore & IGNORE_IF_UNAWARE) ? true : false;
}
void kind_ignore_when_aware(struct object_kind *kind)
{
 kind->ignore |= IGNORE_IF_AWARE;
 player->upkeep->notice |= PN_IGNORE;
}
void kind_ignore_when_unaware(struct object_kind *kind)
{
 kind->ignore |= IGNORE_IF_UNAWARE;
 player->upkeep->notice |= PN_IGNORE;
}
/**
 * Determines if an object is already ignored.
 */
bool object_is_ignored(const struct object *obj)
{
 uint8_t type;
 /* Objects that aren't yet known can't be ignored */
 if (!obj->known)
  return false;
 /* Do ignore individual objects that marked ignore */
 if (obj->known->notice & OBJ_NOTICE_IGNORE)
  return true;
 /* Don't ignore artifacts unless marked to be ignored */
 if (obj->artifact ||
  check_for_inscrip(obj, "!k") || check_for_inscrip(obj, "!*"))
  return false;
 /* Do ignoring by kind */
 if (object_flavor_is_aware(obj) ?
   kind_is_ignored_aware(obj->kind) :
   kind_is_ignored_unaware(obj->kind))
  return true;
 type = ignore_type_of(obj);
 if (type == ITYPE_MAX)
  return false;
 /* Ignore ego items if known */
 if (obj->known->ego && ego_is_ignored(obj->ego->eidx,type))
  return true;
 /* Ignore items known not to be artifacts */
 if ((obj->known->notice & OBJ_NOTICE_ASSESSED) && !obj->artifact &&
  ignore_level[type] == IGNORE_ALL)
  return true;
 /* Get result based on the feeling and the ignore_level */
 if (ignore_level_of(obj) <= ignore_level[type])
  return true;
 else
  return false;
}
/**
 * Determines if an object is eligible for ignoring.
 */
bool ignore_item_ok(const struct player *p, const struct object *obj)
{
 if (p->unignoring)
  return false;
 return object_is_ignored(obj);
}
/**
 * Determines if the known version of an object is eligible for ignoring.
 *
 * This function should only be called on known version of items which have a
 * (real or imaginary) listed base item in the current level
 */
bool ignore_known_item_ok(const struct player *p, const struct object *obj)
{
 struct object *base_obj = cave->objects[obj->oidx];
 if (p->unignoring)
  return false;
 /* Get the real object and check its ignore properties */
 assert(base_obj);
 return object_is_ignored(base_obj);
}
/**
 * Drop all {ignore}able items.
 */
void ignore_drop(struct player *p)
{
 struct object *obj;
 /* Scan through the slots backwards */
 for (obj = gear_last_item(p); obj; obj = obj->prev) {
  /* Skip non-objects and unignoreable objects */
  assert(obj->kind);
  if (!ignore_item_ok(p, obj)) continue;
  /* Check for !d (no drop) inscription */
  if (!check_for_inscrip(obj, "!d") && !check_for_inscrip(obj, "!*")) {
   struct command *drop_cmd;
   /* Confirm the drop if the item is equipped. */
   if (object_is_equipped(p->body, obj)) {
    if (!verify_object("Really take off and drop", obj, p)) {
     /* Hack - inscribe the item with !d to prevent repeated
					 * confirmations. */
     const char *inscription = quark_str(obj->note);
     if (inscription == NULL) {
      obj->note = quark_add("!d");
     } else {
      char buffer[1024];
      my_strcpy(buffer, inscription, sizeof(buffer));
      my_strcat(buffer, "!d", sizeof(buffer));
      obj->note = quark_add(buffer);
     }
     continue;
    }
   }
   /* We're allowed to drop it. */
   p->upkeep->dropping = true;
   cmdq_push(CMD_DROP);
   drop_cmd = cmdq_peek();
   assert(drop_cmd);
   cmd_set_arg_item(drop_cmd, "item", obj);
   cmd_set_arg_number(drop_cmd, "quantity",
    obj->number);
   /*
			 * This drop is a side effect:  whatever
			 * command triggered it will be the target
			 * for CMD_REPEAT rather than repeating the
			 * drop.
			 */
   drop_cmd->is_background_command = true;
  }
 }
 /* Update the gear */
 p->upkeep->update |= (PU_INVEN);
 /* Combine/reorder the pack */
 p->upkeep->notice |= (PN_COMBINE);
}
/**
 * Return the name of an ignore type.
 */
const char *ignore_name_for_type(ignore_type_t type)
{
 size_t i;
 for (i = ITYPE_NONE + 1; i < ITYPE_MAX; i++) {
  if (quality_choices[i].enum_val == type)
   return quality_choices[i].name;
 }
 return "unknown";
}
struct init_module ignore_module = {
 .name = "ignore",
 .init = init_ignore,
 .cleanup = cleanup_ignore
};
/**
 * \file obj-info.c
 * \brief Object description code.
 *
 * Copyright (c) 2010 Andi Sidwell
 * Copyright (c) 2004 Robert Ruehlmann
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Describes the number of blows possible for given stat bonuses
 */
struct blow_info {
 int str_plus;
 int dex_plus;
 int centiblows;
};
/**
 * ------------------------------------------------------------------------
 * Data tables
 * ------------------------------------------------------------------------ */
static const struct origin_type {
 int type;
 int args;
 const char *desc;
} origins[] = {
/**
 * \file list-origins.h
 * \brief List of object origins
 */
{ ORIGIN_NONE, -1, "" },
{ ORIGIN_FLOOR, 1, "Found lying on the floor %s" },
{ ORIGIN_CHEST, 1, "Taken from a chest found %s" },
{ ORIGIN_SPECIAL, 1, "Found lying on the floor of a special room %s" },
{ ORIGIN_PIT, 1, "Found lying on the floor in a pit %s" },
{ ORIGIN_VAULT, 1, "Found lying on the floor in a vault %s" },
{ ORIGIN_LABYRINTH, 1, "Found lying on the floor of a labyrinth %s" },
{ ORIGIN_CAVERN, 1, "Found lying on the floor of a cavern %s" },
{ ORIGIN_RUBBLE, 1, "Found under some rubble %s" },
{ ORIGIN_MIXED, -1, "" }, /* stack with mixed origins */
{ ORIGIN_DROP, 2, "Dropped by %s %s" }, /* normal monster drops */
{ ORIGIN_DROP_SPECIAL, 2, "Dropped by %s %s" }, /* from monsters in special rooms */
{ ORIGIN_DROP_PIT, 2, "Dropped by %s %s" }, /* from monsters in pits/nests */
{ ORIGIN_DROP_VAULT, 2, "Dropped by %s %s" }, /* from monsters in vaults */
{ ORIGIN_STATS, -1, "" }, /* ^ only the above are considered by main-stats */
{ ORIGIN_ACQUIRE, 1, "Conjured forth by magic %s" },
{ ORIGIN_STORE, 0, "Bought from a store" },
{ ORIGIN_STOLEN, -1, "" },
{ ORIGIN_BIRTH, 0, "An inheritance from your family" },
{ ORIGIN_CHEAT, 0, "Created by debug option" },
{ ORIGIN_DROP_BREED, 2, "Dropped by %s %s" }, /* from breeders */
{ ORIGIN_DROP_SUMMON, 2, "Dropped by %s %s" }, /* from combat summons */
{ ORIGIN_DROP_UNKNOWN, 1, "Dropped by an unknown monster %s" },
{ ORIGIN_DROP_POLY, 2, "Dropped by %s %s" }, /* from polymorphees */
{ ORIGIN_DROP_MIMIC, 2, "Dropped by %s %s" }, /* from mimics */
{ ORIGIN_DROP_WIZARD, 2, "Dropped by %s %s" }, /* from wizard mode summons */

};
/**
 * ------------------------------------------------------------------------
 * List-writing utility code
 * ------------------------------------------------------------------------ */
/**
 * Given an array of strings, as so:
 *  { "intelligence", "fish", "lens", "prime", "number" },
 *
 * ... output a list like "intelligence, fish, lens, prime, number.\n".
 */
static void info_out_list(textblock *tb, const char *list[], size_t count)
{
 size_t i;
 for (i = 0; i < count; i++) {
  textblock_append(tb, "%s", list[i]);
  if (i != (count - 1)) textblock_append(tb, ", ");
 }
 textblock_append(tb, ".\n");
}
/**
 * Fills recepticle with all the elements that correspond to the given `list`.
 */
static size_t element_info_collect(const bool list[], const char *recepticle[])
{
 int i, count = 0;
 for (i = 0; i < ELEM_MAX; i++) {
  if (list[i])
   recepticle[count++] = projections[i].name;
 }
 return count;
}
/**
 * ------------------------------------------------------------------------
 * Code that makes use of the data tables to describe aspects of an 
 * object's information
 * ------------------------------------------------------------------------ */
/**
 * Describe stat modifications.
 */
static bool describe_stats(textblock *tb, const struct object *obj,
         oinfo_detail_t mode)
{
 size_t count = 0, i;
 bool detail = false;
 /* Don't give exact plusses for faked ego items as each real one will
	 * be different */
 bool suppress_details = mode & (OINFO_EGO | OINFO_FAKE) ? true : false;
 /* Fact of but not size of mods is known for egos and flavoured items
	 * the player is aware of */
 bool known_effect = false;
 if (obj->known->ego)
  known_effect = true;
 if (tval_can_have_flavor_k(obj->kind) && object_flavor_is_aware(obj)) {
  known_effect = true;
 }
 /* See what we've got */
 for (i = 0; i < OBJ_MOD_MAX; i++) {
  if (obj->modifiers[i]) {
   count++;
   detail = true;
  }
 }
 if (!count)
  return false;
 for (i = 0; i < OBJ_MOD_MAX; i++) {
  const char *desc = lookup_obj_property(OBJ_PROPERTY_MOD, i)->name;
  int val = obj->known->modifiers[i];
  if (!val) continue;
  /* Actual object */
  if (detail && !suppress_details) {
   int attr = (val > 0) ? COLOUR_L_GREEN : COLOUR_RED;
   textblock_append_c(tb, attr, "%+i %s.\n", val, desc);
  } else if (known_effect) {
   /* Ego type or jewellery description */
   textblock_append(tb, "Affects your %s\n", desc);
  }
 }
 return true;
}
/**
 * Describe immunities, resistances and vulnerabilities granted by an object.
 */
static bool describe_elements(textblock *tb,
         const struct element_info el_info[])
{
 const char *r_descs[ELEM_MAX];
 const char *v_descs[ELEM_MAX];
 size_t i, count;
 bool list[ELEM_MAX], prev = false;
 /* Resistances */
 for (i = 0; i < ELEM_MAX; i++)
  list[i] = (el_info[i].res_level == 1);
 count = element_info_collect(list, r_descs);
 if (count) {
  textblock_append(tb, "Provides resistance to ");
  info_out_list(tb, r_descs, count);
  prev = true;
 }
 /* Vulnerabilities */
 for (i = 0; i < ELEM_MAX; i++)
  list[i] = (el_info[i].res_level == -1);
 count = element_info_collect(list, v_descs);
 if (count) {
  textblock_append(tb, "Makes you vulnerable to ");
  info_out_list(tb, v_descs, count);
  prev = true;
 }
 return prev;
}
/**
 * Describe protections granted by an object.
 */
static bool describe_protects(textblock *tb, const bitflag flags[OF_SIZE])
{
 const char *p_descs[OF_MAX];
 int i, count = 0;
 /* Protections */
 for (i = 1; i < OF_MAX; i++) {
  struct obj_property *prop = lookup_obj_property(OBJ_PROPERTY_FLAG, i);
  if (!prop || (prop->subtype != OFT_PROT)) continue;
  if (of_has(flags, prop->index)) {
   p_descs[count++] = prop->desc;
  }
 }
 if (!count)
  return false;
 textblock_append(tb, "Provides protection from ");
 info_out_list(tb, p_descs, count);
 return true;
}
/**
 * Describe elements an object ignores.
 */
static bool describe_ignores(textblock *tb, const struct element_info el_info[])
{
 const char *descs[ELEM_MAX];
 size_t i, count;
 bool list[ELEM_MAX];
 for (i = 0; i < ELEM_MAX; i++)
  list[i] = (el_info[i].flags & EL_INFO_IGNORE);
 count = element_info_collect(list, descs);
 if (!count)
  return false;
 textblock_append(tb, "Cannot be harmed by ");
 info_out_list(tb, descs, count);
 return true;
}
/**
 * Describe elements that damage or destroy an object.
 */
static bool describe_hates(textblock *tb, const struct element_info el_info[])
{
 const char *descs[ELEM_MAX];
 size_t i, count = 0;
 bool list[ELEM_MAX];
 for (i = 0; i < ELEM_MAX; i++)
  list[i] = (el_info[i].flags & EL_INFO_HATES);
 count = element_info_collect(list, descs);
 if (!count)
  return false;
 textblock_append(tb, "Can be destroyed by ");
 info_out_list(tb, descs, count);
 return true;
}
/**
 * Describe stat sustains.
 */
static bool describe_sustains(textblock *tb, const bitflag flags[OF_SIZE])
{
 const char *descs[STAT_MAX];
 int i, count = 0;
 for (i = 0; i < STAT_MAX; i++) {
  struct obj_property *prop = lookup_obj_property(OBJ_PROPERTY_STAT, i);
  if (of_has(flags, sustain_flag(prop->index)))
   descs[count++] = prop->name;
 }
 if (!count)
  return false;
 textblock_append(tb, "Sustains ");
 info_out_list(tb, descs, count);
 return true;
}
/**
 * Describe miscellaneous powers.
 */
static bool describe_misc_magic(textblock *tb, const bitflag flags[OF_SIZE])
{
 int i;
 bool printed = false;
 for (i = 1; i < OF_MAX; i++) {
  struct obj_property *prop = lookup_obj_property(OBJ_PROPERTY_FLAG, i);
  if (!prop || prop->subtype == OFT_PROT) continue;
  if (of_has(flags, prop->index) && prop->desc &&
    !contains_only_spaces(prop->desc)) {
   textblock_append(tb, "%s.  ", prop->desc);
   printed = true;
  }
 }
 if (printed)
  textblock_append(tb, "\n");
 return printed;
}
/**
 * Describe abilities granted by an object.
 */
static bool describe_abilities(textblock *tb, const struct object *obj,
  oinfo_detail_t mode)
{
 const char *name[8];
 int ac = 0;
 struct ability *ability;
 bool known, known_kind, known_ego;
 /* Count its abilities.  If we're neither spoiling nor smithing, only
	 * include known abilities or those known from the kind or ego. */
 known = (mode & OINFO_SPOIL) || (mode & OINFO_SMITH);
 known_kind = obj->kind && obj->kind->aware;
 known_ego = obj->ego && obj->ego->aware;
 for (ability = obj->abilities; ability; ability = ability->next) {
  if (!known
   && (!known_kind || !locate_ability(obj->kind->abilities, ability))
   && (!known_ego || !locate_ability(obj->ego->abilities, ability))
   && (!locate_ability(obj->known->abilities, ability))) {
   continue;
  }
  assert(ac < (int)N_ELEMENTS(name));
  name[ac++] = ability->name;
 }
 /* Describe */
 if (ac) {
  /* Output intro */
  if (ac == 1) {
   textblock_append(tb, "It grants you the ability: ");
  } else {
   textblock_append(tb, "It grants you the abilities: ");
  }
  /* Output list */
  info_out_list(tb, name, ac);
  /* It granted abilities */
  return true;
 }
 /* No abilities granted */
 return false;
}
/**
 * Describe attributes of bows and arrows.
 */
static bool describe_archery(textblock *tb, const struct object *obj)
{
 if (tval_is_launcher(obj)) {
  textblock_append(tb, "It can shoot arrows %d squares (with "
   "your current strength).", archery_range(obj));
  textblock_append(tb, "\n");
  return true;
 }
 if (tval_is_ammo(obj)) {
  struct object *bow = equipped_item_by_slot_name(player, "shooting");
  if (bow) {
   if (obj->number == 1) {
    textblock_append(tb, "It can be shot %d "
     "squares (with your current strength "
     "and bow).", archery_range(bow));
   } else {
    textblock_append(tb, "They can be shot %d "
     "squares (with your current strength "
     "and bow).", archery_range(bow));
   }
  } else {
   if (obj->number == 1) {
    textblock_append(tb, "It can be shot by a bow.");
   } else {
    textblock_append(tb, "They can be shot by a bow.");
   }
  }
  textblock_append(tb, "\n");
  return true;
 }
 /* Not archery related */
 return false;
}
/**
 * Describe attributes of throwing weapons.
 */
static bool describe_throwing(textblock *tb, const struct object *obj)
{
 if (obj_is_throwing(obj)) {
  textblock_append(tb, "It can be thrown effectively (%d "
   "squares with your current strength).",
   throwing_range(obj));
  textblock_append(tb, "\n");
  return true;
 }
 return false;
}
/**
 * Describe slays and brands on weapons
 */
static bool describe_slays(textblock *tb, const struct object *obj,
  oinfo_detail_t mode)
{
 int i, count = 0;
 bool known = (mode & OINFO_SPOIL) || (mode & OINFO_SMITH);
 const bool *s = known ? obj->slays : obj->known->slays;
 if (!s) return false;
 /* Count its slays.  If we're neither spoiling nor smithing, only
	 * include known slays or those known from the kind or ego. */
 known = (mode & OINFO_SPOIL) || (mode & OINFO_SMITH);
 for (i = 1; i < z_info->slay_max; i++) {
  if (s[i]) {
   count++;
  }
 }
 if (!count) return false;
 if (tval_is_weapon(obj) || tval_is_fuel(obj))
  textblock_append(tb, "Slays ");
 else
  textblock_append(tb, "It causes your melee attacks to slay ");
 assert(count >= 1);
 for (i = 1; i < z_info->slay_max; i++) {
  if (!s[i]) continue;
  textblock_append(tb, "%s", slays[i].name);
  if (count > 1)
   textblock_append(tb, ", ");
  else
   textblock_append(tb, ".\n");
  count--;
 }
 return true;
}
/**
 * Describe slays and brands on weapons
 */
static bool describe_brands(textblock *tb, const struct object *obj,
  oinfo_detail_t mode)
{
 int i, count = 0;
 bool known = (mode & OINFO_SPOIL) || (mode & OINFO_SMITH);
 bool *b = known ? obj->brands : obj->known->brands;
 if (!b) return false;
 /* Count its brands.  If we're neither spoiling nor smithing, only
	 * include known brands or those known from the kind or ego. */
 for (i = 1; i < z_info->brand_max; i++) {
  if (b[i]) {
   count++;
  }
 }
 if (!count) return false;
 if (tval_is_weapon(obj) || tval_is_fuel(obj))
  textblock_append(tb, "Branded with ");
 else
  textblock_append(tb, "It brands your melee attacks with ");
 assert(count >= 1);
 for (i = 1; i < z_info->brand_max; i++) {
  if (!b[i]) continue;
  textblock_append(tb, "%s", brands[i].name);
  if (count > 1)
   textblock_append(tb, ", ");
  else
   textblock_append(tb, ".\n");
  count--;
 }
 return true;
}
/**
 * Get the object flags the player should know about for the given object/
 * viewing mode combination.
 */
static void get_known_flags(const struct object *obj, const oinfo_detail_t mode,
       bitflag flags[OF_SIZE])
{
 /* Grab the object flags */
 if ((mode & OINFO_EGO) || (mode & OINFO_SPOIL)
   || (mode & OINFO_SMITH)) {
  object_flags(obj, flags);
 } else {
  object_flags_known(obj, flags);
 }
 /* Don't include base flags when terse */
 if (mode & OINFO_TERSE) {
  of_diff(flags, obj->kind->base->flags);
 }
}
/**
 * Get the object element info the player should know about for the given
 * object/viewing mode combination.
 */
static void get_known_elements(const struct object *obj,
          const oinfo_detail_t mode,
          struct element_info el_info[])
{
 size_t i;
 /* Grab the element info */
 for (i = 0; i < ELEM_MAX; i++) {
  /* Report fake egos or known element info */
  if (player->obj_k->el_info[i].res_level || (mode & OINFO_SPOIL)
    || (mode & OINFO_SMITH))
   el_info[i].res_level = obj->known->el_info[i].res_level;
  else
   el_info[i].res_level = 0;
  el_info[i].flags = obj->known->el_info[i].flags;
  /* Ignoring an element: */
  if (obj->el_info[i].flags & EL_INFO_IGNORE) {
   /* If the object is usually destroyed, mention the ignoring; */
   if (obj->el_info[i].flags & EL_INFO_HATES)
    el_info[i].flags &= ~(EL_INFO_HATES);
   /* Otherwise, don't say anything */
   else
    el_info[i].flags &= ~(EL_INFO_IGNORE);
  }
  /* Don't include hates flag when terse */
  if (mode & OINFO_TERSE)
   el_info[i].flags &= ~(EL_INFO_HATES);
 }
}
/**
 * Gives the known light-sourcey characteristics of the given object.
 *
 * Fills in the intensity of the light in `intensity`, whether it uses fuel and
 * how many turns light it can refuel in similar items.
 *
 * Return false if the object is not known to be a light source (which 
 * includes it not actually being a light source).
 */
static bool obj_known_light(const struct object *obj, oinfo_detail_t mode,
  const bitflag flags[OF_SIZE], int *intensity, bool *uses_fuel,
  int *refuel_turns)
{
 bool no_fuel;
 bool is_light = tval_is_light(obj);
 if (!is_light)
  return false;
 /*
	 * Work out intensity; smithing can use pval for the special bonus so
	 * look at the kind's pval for the radius in that case
	 */
 *intensity = (mode & OINFO_SMITH) ? obj->kind->pval : obj->pval;
 if (of_has(flags, OF_LIGHT)) {
  ++*intensity;
 }
 /* Prevent unidentified objects (especially artifact lights) from showing
	 * bad intensity and refueling info. */
 if (*intensity == 0)
  return false;
 no_fuel = of_has(flags, OF_NO_FUEL) ? true : false;
 if (no_fuel || obj->artifact) {
  *uses_fuel = false;
 } else {
  *uses_fuel = true;
 }
 if (is_light && of_has(flags, OF_TAKES_FUEL)) {
  *refuel_turns = z_info->fuel_lamp;
 } else {
  *refuel_turns = 0;
 }
 return true;
}
/**
 * Describe things that look like lights.
 */
static bool describe_light(textblock *tb, const struct object *obj,
  oinfo_detail_t mode, const bitflag flags[OF_SIZE])
{
 int intensity = 0;
 bool uses_fuel = false;
 int refuel_turns = 0;
 bool terse = mode & OINFO_TERSE ? true : false;
 if (!obj_known_light(obj, mode, flags, &intensity, &uses_fuel, &refuel_turns))
  return false;
 if (tval_is_light(obj)) {
  textblock_append(tb, "Intensity ");
  textblock_append_c(tb, COLOUR_L_GREEN, "%d", intensity);
  textblock_append(tb, " light.");
  if (!obj->artifact && !uses_fuel)
   textblock_append(tb, "  No fuel required.");
  if (!terse) {
   if (refuel_turns)
    textblock_append(tb, "  Refills other lanterns up to %d turns of fuel.", refuel_turns);
  }
  textblock_append(tb, "\n");
 }
 return true;
}
/**
 * Describe an item's origin
 */
static bool describe_origin(textblock *tb, const struct object *obj, bool terse)
{
 char loot_spot[80];
 char name[80];
 int origin;
 const char *dropper = NULL;
 const char *article;
 bool unique = false;
 bool comma = false;
 /* Only give this info in chardumps if wieldable */
 if (terse && !obj_can_wear(obj))
  return false;
 /* Set the origin */
 origin = obj->origin;
 /* Name the place of origin */
 if (obj->origin_depth)
  strnfmt(loot_spot, sizeof(loot_spot), "at %d feet",
          obj->origin_depth * 50);
 else
  my_strcpy(loot_spot, "on the surface", sizeof(loot_spot));
 /* Name the monster of origin */
 if (obj->origin_race) {
  dropper = obj->origin_race->name;
  if (rf_has(obj->origin_race->flags, RF_UNIQUE)) {
   unique = true;
  }
  if (rf_has(obj->origin_race->flags, RF_NAME_COMMA)) {
   comma = true;
  }
 } else {
  dropper = "monster lost to history";
 }
 article = is_a_vowel(dropper[0]) ? "an " : "a ";
 if (unique)
  my_strcpy(name, dropper, sizeof(name));
 else {
  my_strcpy(name, article, sizeof(name));
  my_strcat(name, dropper, sizeof(name));
 }
 if (comma) {
  my_strcat(name, ",", sizeof(name));
 }
 /* Print an appropriate description */
 switch (origins[origin].args)
 {
  case -1: return false;
  case 0: textblock_append(tb, "%s", origins[origin].desc); break;
  case 1: textblock_append(tb, origins[origin].desc, loot_spot);
    break;
  case 2:
   textblock_append(tb, origins[origin].desc, name, loot_spot);
   break;
 }
 textblock_append(tb, "\n\n");
 return true;
}
/**
 * Print an item's flavour text.
 *
 * \param tb is the textblock to which we are adding.
 * \param obj is the object we are describing.
 * \param ego is whether we're describing an ego template (as opposed to a
 * real object)
 */
static void describe_flavor_text(textblock *tb, const struct object *obj,
         bool ego, bool smith)
{
 /* Display the known artifact or object description */
 if (obj->artifact && obj->artifact->text) {
  textblock_append(tb, "%s\n\n", obj->artifact->text);
 } else if (obj->kind->tval == TV_NOTE
   && streq(obj->kind->name, "tutorial note")) {
  /*
		 * Tutorial notes don't have a static description
		 * available in obj->kind->text.  Use
		 * tutorial_expand_message() instead.
		 */
  textblock *note_tb = tutorial_expand_message(obj->pval);
  textblock_append_textblock(tb, note_tb);
  textblock_free(note_tb);
 } else if (object_flavor_is_aware(obj) || ego || smith) {
  bool did_desc = false;
  if (!ego && obj->kind->text) {
   textblock_append(tb, "%s", obj->kind->text);
   did_desc = true;
  }
  /* Display an additional ego-item description */
  if ((ego || (obj->ego != NULL)) && obj->ego->text) {
   if (did_desc) textblock_append(tb, "  ");
   textblock_append(tb, "%s\n\n", obj->ego->text);
  } else if (did_desc) {
   textblock_append(tb, "\n\n");
  }
 }
}
/**
 * ------------------------------------------------------------------------
 * Output code
 * ------------------------------------------------------------------------ */
/**
 * Output object information
 */
static textblock *object_info_out(const struct object *obj, int mode)
{
 bitflag flags[OF_SIZE];
 struct element_info el_info[ELEM_MAX];
 bool something = false;
 bool terse = mode & OINFO_TERSE ? true : false;
 bool subjective = mode & OINFO_SUBJ ? true : false;
 bool ego = mode & OINFO_EGO ? true : false;
 bool smith = mode & OINFO_SMITH ? true : false;
 textblock *tb = textblock_new();
 assert(obj->known);
 /* Unaware objects get simple descriptions */
 if (obj->kind != obj->known->kind) {
  textblock_append(tb, "\n\nYou do not know what this is.\n");
  return tb;
 }
 /* Grab the object flags */
 get_known_flags(obj, mode, flags);
 /* Grab the element info */
 get_known_elements(obj, mode, el_info);
 if (subjective) describe_origin(tb, obj, terse);
 if (!terse) describe_flavor_text(tb, obj, ego, smith);
 if (!object_runes_known(obj) && (obj->known->notice & OBJ_NOTICE_ASSESSED)
  && !tval_is_useable(obj)) {
  textblock_append(tb, "You do not know the full extent of this item's powers.\n");
  something = true;
 }
 if (describe_stats(tb, obj, mode)) something = true;
 if (describe_slays(tb, obj, mode)) something = true;
 if (describe_brands(tb, obj, mode)) something = true;
 if (describe_elements(tb, el_info)) something = true;
 if (describe_protects(tb, flags)) something = true;
 if (describe_sustains(tb, flags)) something = true;
 if (describe_misc_magic(tb, flags)) something = true;
 if (describe_abilities(tb, obj, mode)) something = true;
 if (describe_archery(tb, obj)) something = true;
 if (describe_throwing(tb, obj)) something = true;
 if (describe_light(tb, obj, mode, flags)) something = true;
 if (describe_ignores(tb, el_info)) something = true;
 if (describe_hates(tb, el_info)) something = true;
 if (something) textblock_append(tb, "\n");
 /* Don't append anything in terse (for chararacter dump) */
 if (!something && !terse && !smith && !object_effect(obj))
  textblock_append(tb, "\n\nThis item does not seem to possess any special abilities.");
 return tb;
}
/**
 * Provide information on an item, including how it would affect the current
 * player's state.
 *
 * returns true if anything is printed.
 */
textblock *object_info(const struct object *obj, oinfo_detail_t mode)
{
 mode |= OINFO_SUBJ;
 return object_info_out(obj, mode);
}
/**
 * Provide information on an ego-item type
 */
textblock *object_info_ego(struct ego_item *ego)
{
 struct object_kind *kind = NULL;
 struct object obj = OBJECT_NULL;
 size_t i;
 textblock *result;
 for (i = 0; i < z_info->k_max; i++) {
  kind = &k_info[i];
  if (!kind->name)
   continue;
  if (i == ego->poss_items->kidx)
   break;
 }
 obj.kind = kind;
 obj.tval = kind->tval;
 obj.sval = kind->sval;
 obj.ego = ego;
 ego_apply_magic(&obj, 0);
 result = object_info_out(&obj, OINFO_NONE | OINFO_EGO);
 object_wipe(&obj);
 return result;
}
/**
 * Provide information on an item suitable for writing to the character dump
 * - keep it brief.
 */
void object_info_chardump(ang_file *f, const struct object *obj, int indent,
        int wrap)
{
 textblock *tb = object_info_out(obj, OINFO_TERSE | OINFO_SUBJ);
 textblock_to_file(tb, f, indent, wrap);
 textblock_free(tb);
}
/**
 * Provide spoiler information on an item.
 *
 * Practically, this means that we should not print anything which relies upon
 * the player's current state, since that is not suitable for spoiler material.
 */
void object_info_spoil(ang_file *f, const struct object *obj, int wrap)
{
 textblock *tb = object_info_out(obj, OINFO_SPOIL);
 textblock_to_file(tb, f, 0, wrap);
 textblock_free(tb);
}
/**
 * \file obj-init.c
 * \brief Various game initialization routines
 *
 * Copyright (c) 1997 Ben Harrison
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 *
 * This file is used to initialize various variables and arrays for objects
 * in the Angband game.
 *
 * Several of the arrays for Angband are built from data files in the
 * "lib/gamedata" directory.
 */
static const char *obj_mods[] = {
/**
 * \file src/list-stats.h
 * \brief player stats
 *
 * Changing stat order or making new ones will break savefiles. Stats
 * below start from 0 on line 14, so a stat's sequence number is its line
 * number minus 14.
 *
 * Each stat has a matching sustain in src/list-object-flags.h, which should
 * be at the same index in that file as the stat in this file.
 *
 * Stat properties are defined in lib/gamedata/object_property.txt
 */
"STR",
"DEX",
"CON",
"GRA",
/**
 * \file src/list-skills.h
 * \brief player skills
 *
 * Changing skill order or making new ones will break savefiles. Skills
 * below start from 0 on line 11, so a skill's sequence number is its line
 * number minus 11.
 *
 * Skill properties are not defined in lib/gamedata/object_property.txt
 */
"MELEE",
"ARCHERY",
"EVASION",
"STEALTH",
"PERCEPTION",
"WILL",
"SMITHING",
"SONG",
/**
 * \file list-object-modifiers.h
 * \brief object modifiers (plusses and minuses) for all objects
 *
 * Changing modifier order will break savefiles. Modifiers below start from
 * 13 on line 12 (stats and skills count as modifiers, and are included from
 * list-stats.h and list-skills.h), so a modifier's sequence number is its line
 * number plus 1.
 *
 * Modifier properties are defined in lib/gamedata/object_property.txt
 */
"DAMAGE_SIDES",
"TUNNEL",

 NULL
};
static const char *kind_flags[] = {
/**
 * \file list-kind-flags.h
 * \brief object kind flags
 *
 * These are flags that go on object kinds, egos and artifacts, but not on
 * individual objects.
 *
 * Flags below start from 1 on line 13, so a flag's sequence number is
 * its line number minus 12.
 */
/* symbol			message */
"NONE",
"INSTA_ART",
"QUEST_ART",
"SMITH_ART",
"GOOD",
"SHOW_DICE",
"EASY_KNOW",
"MAX",

 NULL
};
static const char *element_names[] = {
/**
 * \file list-elements.h
 * \brief Elements used in spells and other attacks.
 */
"ACID",
"FIRE",
"COLD",
"POIS",
"DARK",

 NULL
};
static bool grab_element_flag(struct element_info *info, const char *flag_name)
{
 char *under = strchr(flag_name, '_');
 size_t i;
 if (!under) {
  return false;
 }
 /* Ignore or hate */
 for (i = 0; i < ELEM_MAX; i++) {
  if (streq(under + 1, element_names[i])) {
   if (!strncmp(flag_name, "IGNORE", under - flag_name)) {
    info[i].flags |= EL_INFO_IGNORE;
    return true;
   }
   if (!strncmp(flag_name, "HATES", under - flag_name)) {
    info[i].flags |= EL_INFO_HATES;
    return true;
   }
  }
 }
 return false;
}
static enum parser_error write_dummy_object_record(struct artifact *art, const char *name)
{
 struct object_kind *temp, *dummy;
 int i;
 char mod_name[100];
 /* Extend by 1 and realloc */
 z_info->k_max += 1;
 temp = mem_realloc(k_info, (z_info->k_max + 1) * sizeof(*temp));
 /* Copy if no errors */
 if (!temp) {
  return PARSE_ERROR_INTERNAL;
 }
 k_info = temp;
 /* Use the (second) last entry for the dummy */
 dummy = &k_info[z_info->k_max - 1];
 memset(dummy, 0, sizeof(*dummy));
 /* Copy the tval, base and level */
 dummy->tval = art->tval;
 dummy->base = &kb_info[dummy->tval];
 /* Make the name and index */
 strnfmt(mod_name, sizeof(mod_name), "& %s~", name);
 dummy->name = string_make(mod_name);
 dummy->kidx = z_info->k_max - 1;
 dummy->level = art->level;
 /* Increase the sval count for this tval, set the new one to the max */
 for (i = 0; i < TV_MAX; i++) {
  if (kb_info[i].tval == dummy->tval) {
   kb_info[i].num_svals++;
   dummy->sval = kb_info[i].num_svals;
   break;
  }
 }
 if (i == TV_MAX) return PARSE_ERROR_INTERNAL;
 /* Copy the sval to the artifact info */
 art->sval = dummy->sval;
 /* Give the object default colours (these should be overwritten) */
 dummy->d_char = '*';
 dummy->d_attr = COLOUR_RED;
 art->d_attr = dummy->d_attr;
 /* Inherit the flags and element information of the tval */
 of_copy(dummy->flags, kb_info[i].flags);
 kf_copy(dummy->kind_flags, kb_info[i].kind_flags);
 (void)memcpy(dummy->el_info, kb_info[i].el_info,
  sizeof(dummy->el_info[0]) * ELEM_MAX);
 /* Register this as an INSTA_ART object */
 kf_on(dummy->kind_flags, KF_INSTA_ART);
 return PARSE_ERROR_NONE;
}
/**
 * ------------------------------------------------------------------------
 * Initialize projections
 * ------------------------------------------------------------------------ */
static enum parser_error parse_projection_code(struct parser *p) {
 const char *code = parser_getstr(p, "code");
 struct projection *h = parser_priv(p);
 int index = h ? h->index + 1 : 0;
 struct projection *projection = mem_zalloc(sizeof *projection);
 parser_setpriv(p, projection);
 projection->next = h;
 projection->index = index;
 if ((index < ELEM_MAX) && !streq(code, element_names[index])) {
  return PARSE_ERROR_ELEMENT_NAME_MISMATCH;
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_projection_name(struct parser *p) {
 const char *name = parser_getstr(p, "name");
 struct projection *projection = parser_priv(p);
 if (!projection) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 string_free(projection->name);
 projection->name = string_make(name);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_projection_type(struct parser *p) {
 const char *type = parser_getstr(p, "type");
 struct projection *projection = parser_priv(p);
 if (!projection) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 string_free(projection->type);
 projection->type = string_make(type);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_projection_desc(struct parser *p) {
 const char *desc = parser_getstr(p, "desc");
 struct projection *projection = parser_priv(p);
 if (!projection) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 string_free(projection->desc);
 projection->desc = string_make(desc);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_projection_player_desc(struct parser *p) {
 const char *desc = parser_getstr(p, "desc");
 struct projection *projection = parser_priv(p);
 if (!projection) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 string_free(projection->player_desc);
 projection->player_desc = string_make(desc);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_projection_blind_desc(struct parser *p) {
 const char *desc = parser_getstr(p, "desc");
 struct projection *projection = parser_priv(p);
 if (!projection) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 string_free(projection->blind_desc);
 projection->blind_desc = string_make(desc);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_projection_message_type(struct parser *p)
{
 int msg_index;
 const char *type;
 struct projection *projection = parser_priv(p);
 if (!projection) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 type = parser_getsym(p, "type");
 msg_index = message_lookup_by_name(type);
 if (msg_index < 0) {
  return PARSE_ERROR_INVALID_MESSAGE;
 }
 projection->msgt = msg_index;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_projection_damaging(struct parser *p) {
 int damaging = parser_getuint(p, "answer");
 struct projection *projection = parser_priv(p);
 if (!projection) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 projection->damaging = (damaging == 1) ? true : false;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_projection_evade(struct parser *p) {
 int evade = parser_getuint(p, "answer");
 struct projection *projection = parser_priv(p);
 if (!projection) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 projection->evade = (evade == 1) ? true : false;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_projection_obvious(struct parser *p) {
 int obvious = parser_getuint(p, "answer");
 struct projection *projection = parser_priv(p);
 if (!projection) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 projection->obvious = (obvious == 1) ? true : false;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_projection_wake(struct parser *p) {
 int wake = parser_getuint(p, "answer");
 struct projection *projection = parser_priv(p);
 if (!projection) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 projection->wake = (wake == 1) ? true : false;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_projection_color(struct parser *p) {
 struct projection *projection = parser_priv(p);
 const char *color;
 if (!projection) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 color = parser_getsym(p, "color");
 if (strlen(color) > 1) {
  projection->color = color_text_to_attr(color);
 } else {
  projection->color = color_char_to_attr(color[0]);
 }
 return PARSE_ERROR_NONE;
}
static struct parser *init_parse_projection(void) {
 struct parser *p = parser_new();
 parser_setpriv(p, NULL);
 parser_reg(p, "code str code", parse_projection_code);
 parser_reg(p, "name str name", parse_projection_name);
 parser_reg(p, "type str type", parse_projection_type);
 parser_reg(p, "desc str desc", parse_projection_desc);
 parser_reg(p, "player-desc str desc", parse_projection_player_desc);
 parser_reg(p, "blind-desc str desc", parse_projection_blind_desc);
 parser_reg(p, "msgt sym type", parse_projection_message_type);
 parser_reg(p, "damaging uint answer", parse_projection_damaging);
 parser_reg(p, "evade uint answer", parse_projection_evade);
 parser_reg(p, "obvious uint answer", parse_projection_obvious);
 parser_reg(p, "wake uint answer", parse_projection_wake);
 parser_reg(p, "color sym color", parse_projection_color);
 return p;
}
static errr run_parse_projection(struct parser *p) {
 return parse_file_quit_not_found(p, "projection");
}
static errr finish_parse_projection(struct parser *p) {
 struct projection *projection, *next = NULL;
 int element_count = 0, count = 0;
 /* Count the entries */
 z_info->projection_max = 0;
 projection = parser_priv(p);
 while (projection) {
  z_info->projection_max++;
  if (projection->type && streq(projection->type, "element")) {
   element_count++;
  }
  projection = projection->next;
 }
 if (element_count + 1 < (int) N_ELEMENTS(element_names)) {
  quit_fmt("Too few elements in projection.txt!");
 } else if (element_count + 1 > (int) N_ELEMENTS(element_names)) {
  quit_fmt("Too many elements in projection.txt!");
 }
 /* Allocate the direct access list and copy the data to it */
 projections = mem_zalloc((z_info->projection_max) * sizeof(*projection));
 count = z_info->projection_max - 1;
 for (projection = parser_priv(p); projection; projection = next, count--) {
  memcpy(&projections[count], projection, sizeof(*projection));
  next = projection->next;
  mem_free(projection);
 }
 parser_destroy(p);
 return 0;
}
static void cleanup_projection(void)
{
 int idx;
 for (idx = 0; idx < z_info->projection_max; idx++) {
  string_free(projections[idx].name);
  string_free(projections[idx].type);
  string_free(projections[idx].desc);
  string_free(projections[idx].player_desc);
  string_free(projections[idx].blind_desc);
 }
 mem_free(projections);
}
struct file_parser projection_parser = {
 "projection",
 init_parse_projection,
 run_parse_projection,
 finish_parse_projection,
 cleanup_projection
};
/**
 * ------------------------------------------------------------------------
 * Initialize object bases
 * ------------------------------------------------------------------------ */
struct kb_parsedata {
 struct object_base defaults;
 struct object_base *kb;
};
static enum parser_error parse_object_base_defaults(struct parser *p) {
 const char *label;
 int value;
 struct kb_parsedata *d = parser_priv(p);
 assert(d);
 label = parser_getsym(p, "label");
 value = parser_getint(p, "value");
 if (streq(label, "break-chance")) {
  d->defaults.break_perc = value;
 } else if (streq(label, "max-stack")) {
  d->defaults.max_stack = value;
 } else {
  return PARSE_ERROR_UNDEFINED_DIRECTIVE;
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_object_base_name(struct parser *p) {
 struct object_base *kb;
 struct kb_parsedata *d = parser_priv(p);
 assert(d);
 kb = mem_alloc(sizeof *kb);
 memcpy(kb, &d->defaults, sizeof(*kb));
 kb->next = d->kb;
 d->kb = kb;
 kb->tval = tval_find_idx(parser_getsym(p, "tval"));
 if (kb->tval == -1) {
  return PARSE_ERROR_UNRECOGNISED_TVAL;
 }
 if (parser_hasval(p, "name")) {
  kb->name = string_make(parser_getstr(p, "name"));
 }
 kb->num_svals = 0;
 kb->smith_slays = mem_zalloc(z_info->slay_max * sizeof(*(kb->smith_slays)));
 kb->smith_brands = mem_zalloc(z_info->brand_max *
          sizeof(*(kb->smith_brands)));
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_object_base_graphics(struct parser *p) {
 struct object_base *kb;
 const char *color;
 struct kb_parsedata *d = parser_priv(p);
 assert(d);
 kb = d->kb;
 if (!kb) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 color = parser_getsym(p, "color");
 if (strlen(color) > 1) {
  kb->attr = color_text_to_attr(color);
 } else {
  kb->attr = color_char_to_attr(color[0]);
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_object_base_break(struct parser *p) {
 struct object_base *kb;
 struct kb_parsedata *d = parser_priv(p);
 assert(d);
 kb = d->kb;
 if (!kb) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 kb->break_perc = parser_getint(p, "breakage");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_object_base_max_stack(struct parser *p) {
 struct kb_parsedata *d = parser_priv(p);
 struct object_base *kb;
 assert(d);
 kb = d->kb;
 if (!kb) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 kb->max_stack = parser_getint(p, "size");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_object_base_smith_attack(struct parser *p) {
 struct object_base *kb;
 struct kb_parsedata *d = parser_priv(p);
 assert(d);
 kb = d->kb;
 if (!kb) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 kb->smith_attack_valid = true;
 kb->smith_attack_artistry = parser_getint(p, "artistry");
 kb->smith_attack_artefact = parser_getint(p, "artefact");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_object_base_flags(struct parser *p) {
 struct object_base *kb;
 char *s, *t;
 struct kb_parsedata *d = parser_priv(p);
 assert(d);
 kb = d->kb;
 if (!kb) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 s = string_make(parser_getstr(p, "flags"));
 t = strtok(s, " |");
 while (t) {
  bool found = false;
  if (!grab_flag(kb->flags, OF_SIZE, obj_flags, t)) {
   found = true;
  }
  if (!grab_flag(kb->kind_flags, KF_SIZE, kind_flags, t)) {
   found = true;
  }
  if (grab_element_flag(kb->el_info, t)) {
   found = true;
  }
  if (!found) {
   break;
  }
  t = strtok(NULL, " |");
 }
 string_free(s);
 return t ? PARSE_ERROR_INVALID_FLAG : PARSE_ERROR_NONE;
}
static enum parser_error parse_object_base_smith_values(struct parser *p) {
 struct object_base *kb;
 char *s, *t;
 struct kb_parsedata *d = parser_priv(p);
 assert(d);
 kb = d->kb;
 if (!kb) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 s = string_make(parser_getstr(p, "values"));
 t = strtok(s, " |");
 while (t) {
  int value = 0;
  int index = 0;
  bool found = false;
  if (!grab_index_and_int(&value, &index, obj_mods, "", t)) {
   found = true;
   kb->smith_modifiers[index] = value;
  }
  if (!grab_index_and_int(&value, &index, element_names, "RES_", t)) {
   found = true;
   /* Both resistance and vulnerability allowed is stored as 2 */
   if (kb->smith_el_info[index].res_level == 0) {
    kb->smith_el_info[index].res_level = value;
   } else {
    kb->smith_el_info[index].res_level = 2;
   }
  }
  if (!found) {
   break;
  }
  t = strtok(NULL, " |");
 }
 string_free(s);
 return t ? PARSE_ERROR_INVALID_VALUE : PARSE_ERROR_NONE;
}
static enum parser_error parse_object_base_smith_flags(struct parser *p) {
 struct object_base *kb;
 char *s, *t;
 struct kb_parsedata *d = parser_priv(p);
 assert(d);
 kb = d->kb;
 if (!kb) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 s = string_make(parser_getstr(p, "flags"));
 t = strtok(s, " |");
 while (t) {
  bool found = false;
  if (!grab_flag(kb->smith_flags, OF_SIZE, obj_flags, t)) {
   found = true;
  }
  if (grab_element_flag(kb->smith_el_info, t)) {
   found = true;
  }
  if (!found) {
   break;
  }
  t = strtok(NULL, " |");
 }
 string_free(s);
 return t ? PARSE_ERROR_INVALID_FLAG : PARSE_ERROR_NONE;
}
static enum parser_error parse_object_base_smith_slay(struct parser *p) {
 struct object_base *kb;
 const char *s;
 int i;
 struct kb_parsedata *d = parser_priv(p);
 assert(d);
 kb = d->kb;
 if (!kb) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 s = parser_getstr(p, "code");
 for (i = 1; i < z_info->slay_max; i++) {
  if (streq(s, slays[i].code)) break;
 }
 if (i == z_info->slay_max) {
  return PARSE_ERROR_UNRECOGNISED_SLAY;
 }
 if (!kb->smith_slays) {
  kb->smith_slays = mem_zalloc(z_info->slay_max * sizeof(bool));
 }
 kb->smith_slays[i] = true;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_object_base_smith_brand(struct parser *p) {
 struct object_base *kb;
 const char *s;
 int i;
 struct kb_parsedata *d = parser_priv(p);
 assert(d);
 kb = d->kb;
 if (!kb) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 s = parser_getstr(p, "code");
 for (i = 1; i < z_info->brand_max; i++) {
  if (streq(s, brands[i].code)) break;
 }
 if (i == z_info->brand_max) {
  return PARSE_ERROR_UNRECOGNISED_BRAND;
 }
 if (!kb->smith_brands) {
  kb->smith_brands = mem_zalloc(z_info->brand_max * sizeof(bool));
 }
 kb->smith_brands[i] = true;
 return PARSE_ERROR_NONE;
}
struct parser *init_parse_object_base(void) {
 struct parser *p = parser_new();
 struct kb_parsedata *d = mem_zalloc(sizeof(*d));
 parser_setpriv(p, d);
 parser_reg(p, "default sym label int value", parse_object_base_defaults);
 parser_reg(p, "name sym tval ?str name", parse_object_base_name);
 parser_reg(p, "graphics sym color", parse_object_base_graphics);
 parser_reg(p, "break int breakage", parse_object_base_break);
 parser_reg(p, "max-stack int size", parse_object_base_max_stack);
 parser_reg(p, "smith-attack int artistry int artefact",
      parse_object_base_smith_attack);
 parser_reg(p, "flags str flags", parse_object_base_flags);
 parser_reg(p, "smith-values str values", parse_object_base_smith_values);
 parser_reg(p, "smith-flags str flags", parse_object_base_smith_flags);
 parser_reg(p, "slay str code", parse_object_base_smith_slay);
 parser_reg(p, "brand str code", parse_object_base_smith_brand);
 return p;
}
static errr run_parse_object_base(struct parser *p) {
 return parse_file_quit_not_found(p, "object_base");
}
static errr finish_parse_object_base(struct parser *p) {
 struct object_base *kb;
 struct object_base *next = NULL;
 struct kb_parsedata *d = parser_priv(p);
 assert(d);
 kb_info = mem_zalloc(TV_MAX * sizeof(*kb_info));
 for (kb = d->kb; kb; kb = next) {
  if (kb->tval < TV_MAX && kb->tval >= 0) {
   memcpy(&kb_info[kb->tval], kb, sizeof(*kb));
  } else {
   string_free(kb->name);
  }
  next = kb->next;
  mem_free(kb);
 }
 mem_free(d);
 parser_destroy(p);
 return 0;
}
static void cleanup_object_base(void)
{
 int idx;
 for (idx = 0; idx < TV_MAX; idx++) {
  string_free(kb_info[idx].name);
  mem_free(kb_info[idx].smith_slays);
  mem_free(kb_info[idx].smith_brands);
 }
 mem_free(kb_info);
}
struct file_parser object_base_parser = {
 "object_base",
 init_parse_object_base,
 run_parse_object_base,
 finish_parse_object_base,
 cleanup_object_base
};
/**
 * ------------------------------------------------------------------------
 * Initialize object slays
 * ------------------------------------------------------------------------ */
static enum parser_error parse_slay_code(struct parser *p) {
 const char *code = parser_getstr(p, "code");
 struct slay *h = parser_priv(p);
 struct slay *slay = mem_zalloc(sizeof *slay);
 slay->next = h;
 parser_setpriv(p, slay);
 slay->code = string_make(code);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_slay_name(struct parser *p) {
 const char *name = parser_getstr(p, "name");
 struct slay *slay = parser_priv(p);
 if (!slay) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 string_free(slay->name);
 slay->name = string_make(name);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_slay_race_flag(struct parser *p) {
 int flag;
 struct slay *slay = parser_priv(p);
 if (!slay) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 flag = lookup_flag(mon_race_flags, parser_getsym(p, "flag"));
 if (flag == FLAG_END) {
  return PARSE_ERROR_INVALID_FLAG;
 }
 slay->race_flag = flag;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_slay_dice(struct parser *p) {
 struct slay *slay = parser_priv(p);
 if (!slay) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 slay->dice = parser_getuint(p, "dice");
 return PARSE_ERROR_NONE;
}
static struct parser *init_parse_slay(void) {
 struct parser *p = parser_new();
 parser_setpriv(p, NULL);
 parser_reg(p, "code str code", parse_slay_code);
 parser_reg(p, "name str name", parse_slay_name);
 parser_reg(p, "race-flag sym flag", parse_slay_race_flag);
 parser_reg(p, "dice uint dice", parse_slay_dice);
 return p;
}
static errr run_parse_slay(struct parser *p) {
 return parse_file_quit_not_found(p, "slay");
}
static errr finish_parse_slay(struct parser *p) {
 struct slay *slay, *next = NULL;
 int count = 1;
 errr result = PARSE_ERROR_NONE;
 /* Count the entries */
 z_info->slay_max = 0;
 slay = parser_priv(p);
 while (slay) {
  if (z_info->slay_max >= 254) {
   result = PARSE_ERROR_TOO_MANY_ENTRIES;
   break;
  }
  z_info->slay_max++;
  slay = slay->next;
 }
 /* Allocate the direct access list and copy the data to it */
 slays = mem_zalloc((z_info->slay_max + 1) * sizeof(*slay));
 for (slay = parser_priv(p); slay; slay = next, count++) {
  next = slay->next;
  if (count <= z_info->slay_max) {
   memcpy(&slays[count], slay, sizeof(*slay));
   slays[count].next = NULL;
  }
  mem_free(slay);
 }
 z_info->slay_max += 1;
 parser_destroy(p);
 return result;
}
static void cleanup_slay(void)
{
 int idx;
 for (idx = 0; idx < z_info->slay_max; idx++) {
  string_free(slays[idx].code);
  string_free(slays[idx].name);
 }
 mem_free(slays);
}
struct file_parser slay_parser = {
 "slay",
 init_parse_slay,
 run_parse_slay,
 finish_parse_slay,
 cleanup_slay
};
/**
 * ------------------------------------------------------------------------
 * Initialize object brands
 * ------------------------------------------------------------------------ */
static enum parser_error parse_brand_code(struct parser *p) {
 const char *code = parser_getstr(p, "code");
 struct brand *h = parser_priv(p);
 struct brand *brand = mem_zalloc(sizeof *brand);
 brand->next = h;
 parser_setpriv(p, brand);
 brand->code = string_make(code);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_brand_name(struct parser *p) {
 const char *name = parser_getstr(p, "name");
 struct brand *brand = parser_priv(p);
 if (!brand) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 string_free(brand->name);
 brand->name = string_make(name);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_brand_desc(struct parser *p) {
 const char *desc = parser_getstr(p, "desc");
 struct brand *brand = parser_priv(p);
 if (!brand) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 string_free(brand->desc);
 brand->desc = string_make(desc);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_brand_dice(struct parser *p) {
 struct brand *brand = parser_priv(p);
 if (!brand) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 brand->dice = parser_getuint(p, "dice");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_brand_vuln_dice(struct parser *p) {
 struct brand *brand = parser_priv(p);
 if (!brand) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 brand->vuln_dice = parser_getuint(p, "dice");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_brand_resist_flag(struct parser *p) {
 int flag;
 struct brand *brand = parser_priv(p);
 if (!brand) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 flag = lookup_flag(mon_race_flags, parser_getsym(p, "flag"));
 if (flag == FLAG_END) {
  return PARSE_ERROR_INVALID_FLAG;
 }
 brand->resist_flag = flag;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_brand_vuln_flag(struct parser *p) {
 int flag;
 struct brand *brand = parser_priv(p);
 if (!brand) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 flag = lookup_flag(mon_race_flags, parser_getsym(p, "flag"));
 if (flag == FLAG_END) {
  return PARSE_ERROR_INVALID_FLAG;
 }
 brand->vuln_flag = flag;
 return PARSE_ERROR_NONE;
}
static struct parser *init_parse_brand(void) {
 struct parser *p = parser_new();
 parser_setpriv(p, NULL);
 parser_reg(p, "code str code", parse_brand_code);
 parser_reg(p, "name str name", parse_brand_name);
 parser_reg(p, "desc str desc", parse_brand_desc);
 parser_reg(p, "dice uint dice", parse_brand_dice);
 parser_reg(p, "vuln-dice uint dice", parse_brand_vuln_dice);
 parser_reg(p, "resist-flag sym flag", parse_brand_resist_flag);
 parser_reg(p, "vuln-flag sym flag", parse_brand_vuln_flag);
 return p;
}
static errr run_parse_brand(struct parser *p) {
 return parse_file_quit_not_found(p, "brand");
}
static errr finish_parse_brand(struct parser *p) {
 struct brand *brand, *next = NULL;
 int count = 1;
 errr result = PARSE_ERROR_NONE;
 /* Count the entries */
 z_info->brand_max = 0;
 brand = parser_priv(p);
 while (brand) {
  if (z_info->brand_max >= 254) {
   result = PARSE_ERROR_TOO_MANY_ENTRIES;
   break;
  }
  z_info->brand_max++;
  brand = brand->next;
 }
 /* Allocate the direct access list and copy the data to it */
 brands = mem_zalloc((z_info->brand_max + 1) * sizeof(*brand));
 for (brand = parser_priv(p); brand; brand = next, count++) {
  next = brand->next;
  if (count <= z_info->brand_max) {
   memcpy(&brands[count], brand, sizeof(*brand));
   brands[count].next = NULL;
  }
  mem_free(brand);
 }
 z_info->brand_max += 1;
 parser_destroy(p);
 return result;
}
static void cleanup_brand(void)
{
 int idx;
 for (idx = 0; idx < z_info->brand_max; idx++) {
  string_free(brands[idx].code);
  string_free(brands[idx].name);
  string_free(brands[idx].desc);
 }
 mem_free(brands);
}
struct file_parser brand_parser = {
 "brand",
 init_parse_brand,
 run_parse_brand,
 finish_parse_brand,
 cleanup_brand
};
/**
 * ------------------------------------------------------------------------
 * Initialize objects
 * ------------------------------------------------------------------------ */
/* Generic object kinds */
struct object_kind *unknown_item_kind;
struct object_kind *pile_kind;
static enum parser_error parse_object_name(struct parser *p) {
 const char *name = parser_getstr(p, "name");
 struct object_kind *h = parser_priv(p);
 struct object_kind *k = mem_zalloc(sizeof *k);
 k->next = h;
 parser_setpriv(p, k);
 k->name = string_make(name);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_object_graphics(struct parser *p) {
 wchar_t glyph = parser_getchar(p, "glyph");
 const char *color = parser_getsym(p, "color");
 struct object_kind *k = parser_priv(p);
 if (!k) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 k->d_char = glyph;
 if (strlen(color) > 1) {
  k->d_attr = color_text_to_attr(color);
 } else {
  k->d_attr = color_char_to_attr(color[0]);
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_object_type(struct parser *p) {
 struct object_kind *k = parser_priv(p);
 int tval;
 if (!k) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 tval = tval_find_idx(parser_getsym(p, "tval"));
 if (tval < 0) {
  return PARSE_ERROR_UNRECOGNISED_TVAL;
 }
 k->tval = tval;
 k->base = &kb_info[k->tval];
 k->base->num_svals++;
 k->sval = k->base->num_svals;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_object_pval(struct parser *p) {
 struct object_kind *k = parser_priv(p);
 if (!k) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 k->pval = parser_getint(p, "pval");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_object_level(struct parser *p) {
 struct object_kind *k = parser_priv(p);
 if (!k) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 k->level = parser_getint(p, "level");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_object_weight(struct parser *p) {
 struct object_kind *k = parser_priv(p);
 if (!k) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 k->weight = parser_getint(p, "weight");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_object_cost(struct parser *p) {
 struct object_kind *k = parser_priv(p);
 if (!k) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 k->cost = parser_getint(p, "cost");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_object_attack(struct parser *p) {
 struct object_kind *k = parser_priv(p);
 struct random hd;
 if (!k) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 k->att = parser_getint(p, "att");
 hd = parser_getrand(p, "hd");
 k->dd = hd.dice;
 k->ds = hd.sides;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_object_defence(struct parser *p) {
 struct object_kind *k = parser_priv(p);
 struct random hd;
 if (!k) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 k->evn = parser_getint(p, "evn");
 hd = parser_getrand(p, "hd");
 k->pd = hd.dice;
 k->ps = hd.sides;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_object_alloc(struct parser *p) {
 struct object_kind *k = parser_priv(p);
 struct allocation *a;
 if (!k) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 /* Go to the last valid allocation, then allocate a new one */
 a = k->alloc;
 if (!a) {
  k->alloc = mem_zalloc(sizeof(struct allocation));
  a = k->alloc;
 } else {
  while (a->next)
   a = a->next;
  a->next = mem_zalloc(sizeof(struct allocation));
  a = a->next;
 }
 /* Now read the data */
 a->locale = parser_getuint(p, "locale");
 a->chance = parser_getuint(p, "chance");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_object_flags(struct parser *p) {
 struct object_kind *k = parser_priv(p);
 char *s, *t;
 if (!k) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 s = string_make(parser_getstr(p, "flags"));
 t = strtok(s, " |");
 while (t) {
  bool found = false;
  if (!grab_flag(k->flags, OF_SIZE, obj_flags, t)) {
   found = true;
  }
  if (!grab_flag(k->kind_flags, KF_SIZE, kind_flags, t)) {
   found = true;
  }
  if (grab_element_flag(k->el_info, t)) {
   found = true;
  }
  if (!found) {
   break;
  }
  t = strtok(NULL, " |");
 }
 string_free(s);
 return t ? PARSE_ERROR_INVALID_FLAG : PARSE_ERROR_NONE;
}
static enum parser_error parse_object_charges(struct parser *p) {
 struct object_kind *k = parser_priv(p);
 if (!k) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 k->charge = parser_getrand(p, "charges");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_object_effect(struct parser *p) {
 struct object_kind *k = parser_priv(p);
 struct effect *effect, *new_effect;
 if (!k) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 /* Go to the next vacant effect and set it to the new one  */
 new_effect = mem_zalloc(sizeof(*new_effect));
 if (k->effect) {
  effect = k->effect;
  while (effect->next) effect = effect->next;
  effect->next = new_effect;
 } else {
  k->effect = new_effect;
 }
 /* Fill in the detail */
 return grab_effect_data(p, new_effect);
}
static enum parser_error parse_object_dice(struct parser *p) {
 struct object_kind *k = parser_priv(p);
 dice_t *dice;
 struct effect *effect;
 const char *string;
 if (!k) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 /* If there is no effect, assume that this is human and not parser error. */
 effect = k->effect;
 if (effect == NULL) {
  return PARSE_ERROR_NONE;
 }
 while (effect->next) effect = effect->next;
 dice = dice_new();
 if (dice == NULL) {
  return PARSE_ERROR_INVALID_DICE;
 }
 string = parser_getstr(p, "dice");
 if (dice_parse_string(dice, string)) {
  dice_free(effect->dice);
  effect->dice = dice;
 } else {
  dice_free(dice);
  return PARSE_ERROR_INVALID_DICE;
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_object_expr(struct parser *p) {
 struct object_kind *k = parser_priv(p);
 struct effect *effect;
 expression_t *expression;
 expression_base_value_f function;
 const char *name;
 const char *base;
 const char *expr;
 enum parser_error result;
 if (!k) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 /* If there is no effect, assume that this is human and not parser error. */
 effect = k->effect;
 if (effect == NULL) {
  return PARSE_ERROR_NONE;
 }
 while (effect->next) effect = effect->next;
 /* If there are no dice, assume that this is human and not parser error. */
 if (effect->dice == NULL) {
  return PARSE_ERROR_NONE;
 }
 name = parser_getsym(p, "name");
 base = parser_getsym(p, "base");
 expr = parser_getstr(p, "expr");
 expression = expression_new();
 if (expression == NULL) {
  return PARSE_ERROR_INVALID_EXPRESSION;
 }
 function = effect_value_base_by_name(base);
 expression_set_base_value(expression, function);
 if (expression_add_operations_string(expression, expr) < 0) {
  result = PARSE_ERROR_BAD_EXPRESSION_STRING;
 } else if (dice_bind_expression(effect->dice, name, expression) < 0) {
  result = PARSE_ERROR_UNBOUND_EXPRESSION;
 } else {
  result = PARSE_ERROR_NONE;
 }
 /* The dice object makes a deep copy of the expression, so we can free it */
 expression_free(expression);
 return result;
}
static enum parser_error parse_object_thrown_effect(struct parser *p) {
 struct object_kind *k = parser_priv(p);
 struct effect *effect, *new_effect;
 if (!k) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 /* Go to the next vacant effect and set it to the new one  */
 new_effect = mem_zalloc(sizeof(*new_effect));
 if (k->thrown_effect) {
  effect = k->thrown_effect;
  while (effect->next) effect = effect->next;
  effect->next = new_effect;
 } else {
  k->thrown_effect = new_effect;
 }
 /* Fill in the detail */
 return grab_effect_data(p, new_effect);
}
static enum parser_error parse_object_thrown_effect_dice(struct parser *p) {
 struct object_kind *k = parser_priv(p);
 dice_t *dice;
 struct effect *effect;
 const char *string;
 if (!k) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 /* If there is no effect, assume that this is human and not parser error. */
 effect = k->thrown_effect;
 if (effect == NULL) {
  return PARSE_ERROR_NONE;
 }
 while (effect->next) effect = effect->next;
 dice = dice_new();
 if (dice == NULL) {
  return PARSE_ERROR_INVALID_DICE;
 }
 string = parser_getstr(p, "dice");
 if (dice_parse_string(dice, string)) {
  dice_free(effect->dice);
  effect->dice = dice;
 } else {
  dice_free(dice);
  return PARSE_ERROR_INVALID_DICE;
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_object_thrown_effect_expr(struct parser *p) {
 struct object_kind *k = parser_priv(p);
 struct effect *effect;
 expression_t *expression;
 expression_base_value_f function;
 const char *name;
 const char *base;
 const char *expr;
 enum parser_error result;
 if (!k) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 /* If there is no effect, assume that this is human and not parser error. */
 effect = k->thrown_effect;
 if (effect == NULL) {
  return PARSE_ERROR_NONE;
 }
 while (effect->next) effect = effect->next;
 /* If there are no dice, assume that this is human and not parser error. */
 if (effect->dice == NULL) {
  return PARSE_ERROR_NONE;
 }
 name = parser_getsym(p, "name");
 base = parser_getsym(p, "base");
 expr = parser_getstr(p, "expr");
 expression = expression_new();
 if (expression == NULL) {
  return PARSE_ERROR_INVALID_EXPRESSION;
 }
 function = effect_value_base_by_name(base);
 expression_set_base_value(expression, function);
 if (expression_add_operations_string(expression, expr) < 0) {
  result = PARSE_ERROR_BAD_EXPRESSION_STRING;
 } else if (dice_bind_expression(effect->dice, name, expression) < 0) {
  result = PARSE_ERROR_UNBOUND_EXPRESSION;
 } else {
  result = PARSE_ERROR_NONE;
 }
 /* The dice object makes a deep copy of the expression, so we can free it */
 expression_free(expression);
 return result;
}
static enum parser_error parse_object_msg(struct parser *p) {
 struct object_kind *k = parser_priv(p);
 if (!k) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 k->effect_msg = string_append(k->effect_msg, parser_getstr(p, "text"));
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_object_desc(struct parser *p) {
 struct object_kind *k = parser_priv(p);
 if (!k) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 k->text = string_append(k->text, parser_getstr(p, "text"));
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_object_values(struct parser *p) {
 struct object_kind *k = parser_priv(p);
 char *s, *t;
 if (!k) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 s = string_make(parser_getstr(p, "values"));
 t = strtok(s, " |");
 while (t) {
  int value = 0;
  int index = 0;
  bool found = false;
  if (!grab_rand_value(k->modifiers, obj_mods, t)) {
   found = true;
  }
  if (!grab_index_and_int(&value, &index, element_names, "RES_", t)) {
   found = true;
   k->el_info[index].res_level = value;
  }
  if (!found) {
   break;
  }
  t = strtok(NULL, " |");
 }
 string_free(s);
 return t ? PARSE_ERROR_INVALID_VALUE : PARSE_ERROR_NONE;
}
static enum parser_error parse_object_slay(struct parser *p) {
 struct object_kind *k = parser_priv(p);
 const char *s = parser_getstr(p, "code");
 int i;
 if (!k) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 for (i = 1; i < z_info->slay_max; i++) {
  if (streq(s, slays[i].code)) break;
 }
 if (i == z_info->slay_max) {
  return PARSE_ERROR_UNRECOGNISED_SLAY;
 }
 if (!k->slays) {
  k->slays = mem_zalloc(z_info->slay_max * sizeof(bool));
 }
 k->slays[i] = true;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_object_brand(struct parser *p) {
 struct object_kind *k = parser_priv(p);
 const char *s = parser_getstr(p, "code");
 int i;
 if (!k) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 for (i = 1; i < z_info->brand_max; i++) {
  if (streq(s, brands[i].code)) break;
 }
 if (i == z_info->brand_max) {
  return PARSE_ERROR_UNRECOGNISED_BRAND;
 }
 if (!k->brands) {
  k->brands = mem_zalloc(z_info->brand_max * sizeof(bool));
 }
 k->brands[i] = true;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_object_special(struct parser *p) {
 struct object_kind *k = parser_priv(p);
 const char *dice_string = parser_getsym(p, "value");
 dice_t *dice;
 if (!k) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 dice = dice_new();
 if (!dice_parse_string(dice, dice_string)) {
  dice_free(dice);
  return PARSE_ERROR_NOT_RANDOM;
 }
 dice_random_value(dice, &k->special1);
 if (parser_hasval(p, "min")) {
  k->special2 = parser_getint(p, "min");
 }
 dice_free(dice);
 return PARSE_ERROR_NONE;
}
struct parser *init_parse_object(void) {
 struct parser *p = parser_new();
 parser_setpriv(p, NULL);
 parser_reg(p, "name str name", parse_object_name);
 parser_reg(p, "type sym tval", parse_object_type);
 parser_reg(p, "pval int pval", parse_object_pval);
 parser_reg(p, "graphics char glyph sym color", parse_object_graphics);
 parser_reg(p, "depth int level", parse_object_level);
 parser_reg(p, "weight int weight", parse_object_weight);
 parser_reg(p, "cost int cost", parse_object_cost);
 parser_reg(p, "alloc uint locale uint chance", parse_object_alloc);
 parser_reg(p, "attack int att rand hd", parse_object_attack);
 parser_reg(p, "defence int evn rand hd", parse_object_defence);
 parser_reg(p, "flags str flags", parse_object_flags);
 parser_reg(p, "charges rand charges", parse_object_charges);
 parser_reg(p, "effect sym eff ?sym type ?int radius ?int other", parse_object_effect);
 parser_reg(p, "dice str dice", parse_object_dice);
 parser_reg(p, "expr sym name sym base str expr", parse_object_expr);
 parser_reg(p, "thrown-effect sym eff ?sym type ?int radius ?int other",
      parse_object_thrown_effect);
 parser_reg(p, "thrown-dice str dice", parse_object_thrown_effect_dice);
 parser_reg(p, "thrown-expr sym name sym base str expr",
      parse_object_thrown_effect_expr);
 parser_reg(p, "msg str text", parse_object_msg);
 parser_reg(p, "values str values", parse_object_values);
 parser_reg(p, "desc str text", parse_object_desc);
 parser_reg(p, "slay str code", parse_object_slay);
 parser_reg(p, "brand str code", parse_object_brand);
 parser_reg(p, "special sym value ?int min", parse_object_special);
 return p;
}
static errr run_parse_object(struct parser *p) {
 return parse_file_quit_not_found(p, "object");
}
static errr finish_parse_object(struct parser *p) {
 struct object_kind *k, *next = NULL;
 int kidx;
 /* scan the list for the max id and max number of allocations */
 z_info->k_max = 0;
 z_info->obj_alloc_max = 0;
 k = parser_priv(p);
 while (k) {
  int max_alloc = 0;
  struct allocation *a = k->alloc;
  z_info->k_max++;
  while (a) {
   a = a->next;
   max_alloc++;
  }
  if (max_alloc > z_info->obj_alloc_max)
   z_info->obj_alloc_max = max_alloc;
  k = k->next;
 }
 /* allocate the direct access list and copy the data to it */
 k_info = mem_zalloc((z_info->k_max + 1) * sizeof(*k));
 kidx = z_info->k_max - 1;
 for (k = parser_priv(p); k; k = next, kidx--) {
  struct allocation *a_new;
  assert(kidx >= 0);
  memcpy(&k_info[kidx], k, sizeof(*k));
  k_info[kidx].kidx = kidx;
  /* Add base kind flags to kind kind flags */
  kf_union(k_info[kidx].kind_flags, kb_info[k->tval].kind_flags);
  next = k->next;
  if (kidx < z_info->k_max - 1) {
   k_info[kidx].next = &k_info[kidx + 1];
  } else {
   k_info[kidx].next = NULL;
  }
  /* Allocation */
  a_new = mem_zalloc(z_info->obj_alloc_max * sizeof(*a_new));
  if (k->alloc) {
   struct allocation *a_temp, *a_old = k->alloc;
   int i;
   /* Allocate space and copy */
   for (i = 0; i < z_info->obj_alloc_max; i++) {
    memcpy(&a_new[i], a_old, sizeof(*a_old));
    a_old = a_old->next;
    if (!a_old) break;
   }
   /* Make next point correctly */
   for (i = 0; i < z_info->obj_alloc_max; i++)
    if (a_new[i].next)
     a_new[i].next = &a_new[i + 1];
   /* Tidy up */
   a_old = k->alloc;
   a_temp = a_old;
   while (a_temp) {
    a_temp = a_old->next;
    mem_free(a_old);
    a_old = a_temp;
   }
  }
  k_info[kidx].alloc = a_new;
  mem_free(k);
 }
 z_info->k_max += 1;
 z_info->ordinary_kind_max = z_info->k_max;
 parser_destroy(p);
 return 0;
}
static void cleanup_object(void)
{
 int idx;
 for (idx = 0; idx < z_info->k_max; idx++) {
  struct object_kind *kind = &k_info[idx];
  string_free(kind->name);
  string_free(kind->text);
  string_free(kind->effect_msg);
  mem_free(kind->brands);
  mem_free(kind->slays);
  release_ability_list(kind->abilities);
  free_effect(kind->effect);
  free_effect(kind->thrown_effect);
  mem_free(kind->alloc);
 }
 mem_free(k_info);
}
struct file_parser object_parser = {
 "object",
 init_parse_object,
 run_parse_object,
 finish_parse_object,
 cleanup_object
};
/**
 * ------------------------------------------------------------------------
 * Initialize drop types
 * ------------------------------------------------------------------------ */
static enum parser_error parse_drop_name(struct parser *p) {
 const char *name = parser_getstr(p, "name");
 struct drop *h = parser_priv(p);
 struct drop *d = mem_zalloc(sizeof *d);
 d->next = h;
 parser_setpriv(p, d);
 d->name = string_make(name);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_drop_chest(struct parser *p) {
 struct drop *d = parser_priv(p);
 int chest;
 if (!d) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 chest = parser_getuint(p, "chest");
 d->chest = (chest == 1) ? true : false;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_drop_base(struct parser *p) {
 struct poss_item *poss;
 int i;
 int tval = tval_find_idx(parser_getsym(p, "tval"));
 bool found_one_kind = false;
 struct drop *d = parser_priv(p);
 if (!d) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 if (tval < 0) {
  return PARSE_ERROR_UNRECOGNISED_TVAL;
 }
 /* Find all the right object kinds */
 for (i = 0; i < z_info->k_max; i++) {
  if (k_info[i].tval != tval) continue;
  poss = mem_zalloc(sizeof(struct poss_item));
  poss->kidx = i;
  poss->next = d->poss;
  d->poss = poss;
  found_one_kind = true;
 }
 return (!found_one_kind) ?
  PARSE_ERROR_NO_KIND_FOR_DROP_TYPE : PARSE_ERROR_NONE;
}
static enum parser_error parse_drop_not_base(struct parser *p) {
 struct poss_item *imposs;
 int i;
 int tval = tval_find_idx(parser_getsym(p, "tval"));
 bool found_one_kind = false;
 struct drop *d = parser_priv(p);
 if (!d) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 if (tval < 0) {
  return PARSE_ERROR_UNRECOGNISED_TVAL;
 }
 /* Find all the right object kinds */
 for (i = 0; i < z_info->k_max; i++) {
  if (k_info[i].tval != tval) continue;
  imposs = mem_zalloc(sizeof(struct poss_item));
  imposs->kidx = i;
  imposs->next = d->imposs;
  d->imposs = imposs;
  found_one_kind = true;
 }
 return (!found_one_kind) ?
  PARSE_ERROR_NO_KIND_FOR_DROP_TYPE : PARSE_ERROR_NONE;
}
static enum parser_error parse_drop_item(struct parser *p) {
 struct poss_item *poss;
 int tval = tval_find_idx(parser_getsym(p, "tval"));
 int sval = lookup_sval(tval, parser_getsym(p, "sval"));
 int kidx;
 struct drop *d = parser_priv(p);
 if (!d) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 if (tval < 0) {
  return PARSE_ERROR_UNRECOGNISED_TVAL;
 }
 if (sval < 0) {
  return PARSE_ERROR_UNRECOGNISED_SVAL;
 }
 kidx = lookup_kind(tval, sval)->kidx;
 if (kidx < 0) {
  return PARSE_ERROR_INVALID_ITEM_NUMBER;
 }
 poss = mem_zalloc(sizeof(struct poss_item));
 poss->kidx = kidx;
 poss->next = d->poss;
 d->poss = poss;
 return PARSE_ERROR_NONE;
}
static struct parser *init_parse_drop(void) {
 struct parser *p = parser_new();
 parser_setpriv(p, NULL);
 parser_reg(p, "name str name", parse_drop_name);
 parser_reg(p, "chest uint chest", parse_drop_chest);
 parser_reg(p, "base sym tval", parse_drop_base);
 parser_reg(p, "not-base sym tval", parse_drop_not_base);
 parser_reg(p, "item sym tval sym sval", parse_drop_item);
 return p;
}
static errr run_parse_drop(struct parser *p) {
 return parse_file_quit_not_found(p, "drop");
}
static errr finish_parse_drop(struct parser *p) {
 struct drop *d, *n;
 int idx;
 /* Scan the list for the max id */
 z_info->drop_max = 0;
 d = parser_priv(p);
 while (d) {
  z_info->drop_max++;
  d = d->next;
 }
 /* Allocate the direct access list and copy the data to it */
 drops = mem_zalloc((z_info->drop_max + 1) * sizeof(*d));
 idx = z_info->drop_max - 1;
 for (d = parser_priv(p); d; d = n, idx--) {
  assert(idx >= 0);
  memcpy(&drops[idx], d, sizeof(*d));
  drops[idx].idx = idx;
  n = d->next;
  if (idx < z_info->drop_max - 1) {
   drops[idx].next = &drops[idx + 1];
  } else {
   drops[idx].next = NULL;
  }
  mem_free(d);
 }
 z_info->drop_max += 1;
 parser_destroy(p);
 return 0;
}
static void cleanup_drop(void)
{
 int idx;
 for (idx = 0; idx < z_info->drop_max; idx++) {
  struct drop *drop = &drops[idx];
  struct poss_item *poss;
  string_free(drop->name);
  poss = drop->poss;
  while (poss) {
   struct poss_item *next = poss->next;
   mem_free(poss);
   poss = next;
  }
  poss = drop->imposs;
  while (poss) {
   struct poss_item *next = poss->next;
   mem_free(poss);
   poss = next;
  }
 }
 mem_free(drops);
}
struct file_parser drop_parser = {
 "drop",
 init_parse_drop,
 run_parse_drop,
 finish_parse_drop,
 cleanup_drop
};
/**
 * ------------------------------------------------------------------------
 * Initialize ego items
 * ------------------------------------------------------------------------ */
static enum parser_error parse_ego_name(struct parser *p) {
 const char *name = parser_getstr(p, "name");
 struct ego_item *h = parser_priv(p);
 struct ego_item *e = mem_zalloc(sizeof *e);
 e->next = h;
 parser_setpriv(p, e);
 e->name = string_make(name);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_ego_alloc(struct parser *p) {
 struct ego_item *e = parser_priv(p);
 const char *tmp = parser_getstr(p, "minmax");
 int amin, amax;
 if (!e) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 e->rarity = parser_getint(p, "common");
 if (grab_int_range(&amin, &amax, tmp, "to")) {
  return PARSE_ERROR_INVALID_ALLOCATION;
 }
 if (amin > 255 || amax > 255 || amin < 0 || amax < 0) {
  return PARSE_ERROR_OUT_OF_BOUNDS;
 }
 e->level = amin;
 e->alloc_max = amax;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_ego_cost(struct parser *p) {
 struct ego_item *e = parser_priv(p);
 if (!e) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 e->cost = parser_getint(p, "cost");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_ego_max_attack(struct parser *p) {
 struct ego_item *e = parser_priv(p);
 if (!e) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 e->att = parser_getuint(p, "att");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_ego_dam_dice(struct parser *p) {
 struct ego_item *e = parser_priv(p);
 if (!e) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 e->dd = parser_getuint(p, "dice");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_ego_dam_sides(struct parser *p) {
 struct ego_item *e = parser_priv(p);
 if (!e) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 e->ds = parser_getuint(p, "sides");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_ego_max_evasion(struct parser *p) {
 struct ego_item *e = parser_priv(p);
 if (!e) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 e->evn = parser_getuint(p, "evn");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_ego_prot_dice(struct parser *p) {
 struct ego_item *e = parser_priv(p);
 if (!e) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 e->pd = parser_getuint(p, "dice");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_ego_prot_sides(struct parser *p) {
 struct ego_item *e = parser_priv(p);
 if (!e) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 e->ps = parser_getuint(p, "sides");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_ego_max_pval(struct parser *p) {
 struct ego_item *e = parser_priv(p);
 if (!e) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 e->pval = parser_getuint(p, "pval");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_ego_type(struct parser *p) {
 struct poss_item *poss;
 int i;
 int tval = tval_find_idx(parser_getsym(p, "tval"));
 bool found_one_kind = false;
 struct ego_item *e = parser_priv(p);
 if (!e) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 if (tval < 0) {
  return PARSE_ERROR_UNRECOGNISED_TVAL;
 }
 /* Find all the right object kinds */
 for (i = 0; i < z_info->k_max; i++) {
  if (k_info[i].tval != tval) continue;
  poss = mem_zalloc(sizeof(struct poss_item));
  poss->kidx = i;
  poss->next = e->poss_items;
  e->poss_items = poss;
  found_one_kind = true;
 }
 if (!found_one_kind) {
  return PARSE_ERROR_NO_KIND_FOR_EGO_TYPE;
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_ego_item(struct parser *p) {
 struct poss_item *poss;
 int tval = tval_find_idx(parser_getsym(p, "tval"));
 int sval = lookup_sval(tval, parser_getsym(p, "sval"));
 struct ego_item *e = parser_priv(p);
 if (!e) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 if (tval < 0) {
  return PARSE_ERROR_UNRECOGNISED_TVAL;
 }
 if (sval < 0) {
  return PARSE_ERROR_UNRECOGNISED_SVAL;
 }
 poss = mem_zalloc(sizeof(struct poss_item));
 poss->kidx = lookup_kind(tval, sval)->kidx;
 poss->next = e->poss_items;
 e->poss_items = poss;
 return (poss->kidx <= 0) ?
  PARSE_ERROR_INVALID_ITEM_NUMBER : PARSE_ERROR_NONE;
}
static enum parser_error parse_ego_flags(struct parser *p) {
 struct ego_item *e = parser_priv(p);
 char *flags;
 char *t;
 if (!e) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 if (!parser_hasval(p, "flags")) {
  return PARSE_ERROR_NONE;
 }
 flags = string_make(parser_getstr(p, "flags"));
 t = strtok(flags, " |");
 while (t) {
  bool found = false;
  if (!grab_flag(e->flags, OF_SIZE, obj_flags, t)) {
   found = true;
  }
  if (!grab_flag(e->kind_flags, KF_SIZE, kind_flags, t)) {
   found = true;
  }
  if (grab_element_flag(e->el_info, t)) {
   found = true;
  }
  if (!found) {
   break;
  }
  t = strtok(NULL, " |");
 }
 string_free(flags);
 return t ? PARSE_ERROR_INVALID_FLAG : PARSE_ERROR_NONE;
}
static enum parser_error parse_ego_values(struct parser *p) {
 struct ego_item *e = parser_priv(p);
 char *s, *t;
 if (!e) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 if (!parser_hasval(p, "values")) {
  return PARSE_ERROR_MISSING_FIELD;
 }
 s = string_make(parser_getstr(p, "values"));
 t = strtok(s, " |");
 while (t) {
  bool found = false;
  int value = 0;
  int index = 0;
  if (!grab_int_value(e->modifiers, obj_mods, t)) {
   found = true;
  }
  if (!grab_index_and_int(&value, &index, element_names, "RES_", t)) {
   found = true;
   e->el_info[index].res_level = value;
  }
  if (!found) {
   break;
  }
  t = strtok(NULL, " |");
 }
 string_free(s);
 return t ? PARSE_ERROR_INVALID_VALUE : PARSE_ERROR_NONE;
}
static enum parser_error parse_ego_slay(struct parser *p) {
 struct ego_item *e = parser_priv(p);
 const char *s = parser_getstr(p, "code");
 int i;
 if (!e) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 for (i = 1; i < z_info->slay_max; i++) {
  if (streq(s, slays[i].code)) break;
 }
 if (i == z_info->slay_max) {
  return PARSE_ERROR_UNRECOGNISED_SLAY;
 }
 if (!e->slays) {
  e->slays = mem_zalloc(z_info->slay_max * sizeof(bool));
 }
 e->slays[i] = true;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_ego_brand(struct parser *p) {
 struct ego_item *e = parser_priv(p);
 const char *s = parser_getstr(p, "code");
 int i;
 if (!e) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 for (i = 1; i < z_info->brand_max; i++) {
  if (streq(s, brands[i].code)) break;
 }
 if (i == z_info->brand_max)
  return PARSE_ERROR_UNRECOGNISED_BRAND;
 if (!e->brands) {
  e->brands = mem_zalloc(z_info->brand_max * sizeof(bool));
 }
 e->brands[i] = true;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_ego_ability(struct parser *p) {
 struct ego_item *e = parser_priv(p);
 int skill = lookup_skill(parser_getsym(p, "skill"));
 struct ability *a, *n;
 if (!e) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 if (skill < 0) {
  return PARSE_ERROR_INVALID_SKILL;
 }
 a = lookup_ability(skill, parser_getsym(p, "ability"));
 if (!a) {
  return PARSE_ERROR_INVALID_ABILITY;
 }
 n = mem_zalloc(sizeof(*n));
 memcpy(n, a, sizeof(*n));
 n->next = e->abilities;
 e->abilities = n;
 return PARSE_ERROR_NONE;
}
struct parser *init_parse_ego(void) {
 struct parser *p = parser_new();
 parser_setpriv(p, NULL);
 parser_reg(p, "name str name", parse_ego_name);
 parser_reg(p, "alloc int common str minmax", parse_ego_alloc);
 parser_reg(p, "cost int cost", parse_ego_cost);
 parser_reg(p, "max-attack uint att", parse_ego_max_attack);
 parser_reg(p, "dam-dice uint dice", parse_ego_dam_dice);
 parser_reg(p, "dam-sides uint sides", parse_ego_dam_sides);
 parser_reg(p, "max-evasion uint evn", parse_ego_max_evasion);
 parser_reg(p, "prot-dice uint dice", parse_ego_prot_dice);
 parser_reg(p, "prot-sides uint sides", parse_ego_prot_sides);
 parser_reg(p, "max-pval uint pval", parse_ego_max_pval);
 parser_reg(p, "type sym tval", parse_ego_type);
 parser_reg(p, "item sym tval sym sval", parse_ego_item);
 parser_reg(p, "flags ?str flags", parse_ego_flags);
 parser_reg(p, "values str values", parse_ego_values);
 parser_reg(p, "slay str code", parse_ego_slay);
 parser_reg(p, "brand str code", parse_ego_brand);
 parser_reg(p, "ability sym skill sym ability", parse_ego_ability);
 return p;
}
static errr run_parse_ego(struct parser *p) {
 return parse_file_quit_not_found(p, "special");
}
static errr finish_parse_ego(struct parser *p) {
 struct ego_item *e, *n;
 int eidx;
 /* Scan the list for the max id */
 z_info->e_max = 0;
 e = parser_priv(p);
 while (e) {
  z_info->e_max++;
  e = e->next;
 }
 /* Allocate the direct access list and copy the data to it */
 e_info = mem_zalloc((z_info->e_max + 1) * sizeof(*e));
 eidx = z_info->e_max - 1;
 for (e = parser_priv(p); e; e = n, eidx--) {
  assert(eidx >= 0);
  memcpy(&e_info[eidx], e, sizeof(*e));
  e_info[eidx].eidx = eidx;
  n = e->next;
  if (eidx < z_info->e_max - 1) {
   e_info[eidx].next = &e_info[eidx + 1];
  } else {
   e_info[eidx].next = NULL;
  }
  mem_free(e);
 }
 z_info->e_max += 1;
 parser_destroy(p);
 return 0;
}
static void cleanup_ego(void)
{
 int idx;
 for (idx = 0; idx < z_info->e_max; idx++) {
  struct ego_item *ego = &e_info[idx];
  struct poss_item *poss;
  string_free(ego->name);
  mem_free(ego->brands);
  mem_free(ego->slays);
  release_ability_list(ego->abilities);
  poss = ego->poss_items;
  while (poss) {
   struct poss_item *next = poss->next;
   mem_free(poss);
   poss = next;
  }
 }
 mem_free(e_info);
}
struct file_parser ego_parser = {
 "ego_item",
 init_parse_ego,
 run_parse_ego,
 finish_parse_ego,
 cleanup_ego
};
/**
 * ------------------------------------------------------------------------
 * Initialize artifacts
 * ------------------------------------------------------------------------ */
static enum parser_error parse_artifact_name(struct parser *p) {
 size_t i;
 const char *name = parser_getstr(p, "name");
 struct artifact *h = parser_priv(p);
 struct artifact *a = mem_zalloc(sizeof *a);
 a->next = h;
 parser_setpriv(p, a);
 a->name = string_make(name);
 /* Ignore all base elements */
 for (i = ELEM_BASE_MIN; i < ELEM_HIGH_MIN; i++) {
  a->el_info[i].flags |= EL_INFO_IGNORE;
 }
 /* Signal that the color has not been set */
 a->d_attr = 255;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_artifact_base_object(struct parser *p) {
 struct artifact *a = parser_priv(p);
 int tval, sval;
 const char *sval_name;
 if (!a) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 tval = tval_find_idx(parser_getsym(p, "tval"));
 if (tval < 0) {
  return PARSE_ERROR_UNRECOGNISED_TVAL;
 }
 a->tval = tval;
 sval_name = parser_getsym(p, "sval");
 sval = lookup_sval(a->tval, sval_name);
 if (sval < 0) {
  return write_dummy_object_record(a, sval_name);
 }
 a->sval = sval;
 /* Use the base object's display color unless overridden. */
 if (a->d_attr == 255) {
  a->d_attr = lookup_kind(a->tval, a->sval)->d_attr;
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_artifact_color(struct parser *p) {
 const char *color = parser_getsym(p, "color");
 struct artifact *a = parser_priv(p);
 struct object_kind *k;
 if (!a) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 if (strlen(color) > 1) {
  a->d_attr = color_text_to_attr(color);
 } else {
  a->d_attr = color_char_to_attr(color[0]);
 }
 k = lookup_kind(a->tval, a->sval);
 assert(k);
 if (kf_has(k->kind_flags, KF_INSTA_ART)) {
  /* Align the color of the kind with that of the artifact. */
  k->d_attr = a->d_attr;
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_artifact_graphics(struct parser *p) {
 wchar_t glyph = parser_getchar(p, "glyph");
 const char *color = parser_getsym(p, "color");
 struct artifact *a = parser_priv(p);
 struct object_kind *k;
 if (!a) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 k = lookup_kind(a->tval, a->sval);
 assert(k);
 if (!kf_has(k->kind_flags, KF_INSTA_ART)) {
  return PARSE_ERROR_NOT_SPECIAL_ARTIFACT;
 }
 k->d_char = glyph;
 if (strlen(color) > 1) {
  k->d_attr = color_text_to_attr(color);
 } else {
  k->d_attr = color_char_to_attr(color[0]);
 }
 a->d_attr = k->d_attr;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_artifact_pval(struct parser *p) {
 struct artifact *a = parser_priv(p);
 if (!a) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 a->pval = parser_getint(p, "pval");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_artifact_level(struct parser *p) {
 struct artifact *a = parser_priv(p);
 if (!a) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 a->level = parser_getint(p, "level");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_artifact_rarity(struct parser *p) {
 struct artifact *a = parser_priv(p);
 if (!a) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 a->rarity = parser_getint(p, "rarity");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_artifact_weight(struct parser *p) {
 struct artifact *a = parser_priv(p);
 struct object_kind *k;
 if (!a) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 k = lookup_kind(a->tval, a->sval);
 assert(k);
 a->weight = parser_getint(p, "weight");
 /* Set kind weight for special artifacts */
 if (k->kidx >= z_info->ordinary_kind_max) {
  k->weight = a->weight;
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_artifact_cost(struct parser *p) {
 struct artifact *a = parser_priv(p);
 struct object_kind *k;
 if (!a) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 k = lookup_kind(a->tval, a->sval);
 assert(k);
 a->cost = parser_getint(p, "cost");
 /* Set kind cost for special artifacts */
 if (k->kidx >= z_info->ordinary_kind_max) {
  k->cost = a->cost;
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_artifact_attack(struct parser *p) {
 struct artifact *a = parser_priv(p);
 struct random d;
 if (!a) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 a->att = parser_getint(p, "att");
 d = parser_getrand(p, "dice");
 a->dd = d.dice;
 a->ds = d.sides;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_artifact_defence(struct parser *p) {
 struct artifact *a = parser_priv(p);
 struct random d;
 if (!a) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 a->evn = parser_getint(p, "evn");
 d = parser_getrand(p, "dice");
 a->pd = d.dice;
 a->ps = d.sides;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_artifact_flags(struct parser *p) {
 struct artifact *a = parser_priv(p);
 char *s, *t;
 if (!a) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 if (!parser_hasval(p, "flags")) {
  return PARSE_ERROR_NONE;
 }
 s = string_make(parser_getstr(p, "flags"));
 t = strtok(s, " |");
 while (t) {
  bool found = false;
  if (!grab_flag(a->flags, OF_SIZE, obj_flags, t)) {
   found = true;
  }
  if (grab_element_flag(a->el_info, t)) {
   found = true;
  }
  if (!found) {
   break;
  }
  t = strtok(NULL, " |");
 }
 string_free(s);
 return t ? PARSE_ERROR_INVALID_FLAG : PARSE_ERROR_NONE;
}
static enum parser_error parse_artifact_values(struct parser *p) {
 struct artifact *a = parser_priv(p);
 char *s, *t;
 if (!a) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 s = string_make(parser_getstr(p, "values"));
 t = strtok(s, " |");
 while (t) {
  bool found = false;
  int value = 0;
  int index = 0;
  if (!grab_int_value(a->modifiers, obj_mods, t)) {
   found = true;
  }
  if (!grab_index_and_int(&value, &index, element_names, "RES_", t)) {
   found = true;
   a->el_info[index].res_level = value;
  }
  if (!found) {
   break;
  }
  t = strtok(NULL, " |");
 }
 string_free(s);
 return t ? PARSE_ERROR_INVALID_VALUE : PARSE_ERROR_NONE;
}
static enum parser_error parse_artifact_desc(struct parser *p) {
 struct artifact *a = parser_priv(p);
 if (!a) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 a->text = string_append(a->text, parser_getstr(p, "text"));
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_artifact_slay(struct parser *p) {
 struct artifact *a = parser_priv(p);
 const char *s = parser_getstr(p, "code");
 int i;
 if (!a) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 for (i = 1; i < z_info->slay_max; i++) {
  if (streq(s, slays[i].code)) break;
 }
 if (i == z_info->slay_max) {
  return PARSE_ERROR_UNRECOGNISED_SLAY;
 }
 if (!a->slays) {
  a->slays = mem_zalloc(z_info->slay_max * sizeof(bool));
 }
 a->slays[i] = true;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_artifact_brand(struct parser *p) {
 struct artifact *a = parser_priv(p);
 const char *s = parser_getstr(p, "code");
 int i;
 if (!a) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 for (i = 1; i < z_info->brand_max; i++) {
  if (streq(s, brands[i].code)) break;
 }
 if (i == z_info->brand_max) {
  return PARSE_ERROR_UNRECOGNISED_BRAND;
 }
 if (!a->brands) {
  a->brands = mem_zalloc(z_info->brand_max * sizeof(bool));
 }
 a->brands[i] = true;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_artifact_ability(struct parser *p) {
 struct artifact *a = parser_priv(p);
 int skill;
 struct ability *b, *n;
 if (!a) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 skill = lookup_skill(parser_getsym(p, "skill"));
 if (skill < 0) {
  return PARSE_ERROR_INVALID_SKILL;
 }
 b = lookup_ability(skill, parser_getsym(p, "ability"));
 if (!b) {
  return PARSE_ERROR_INVALID_ABILITY;
 }
 n = mem_zalloc(sizeof(*n));
 memcpy(n, b, sizeof(*n));
 n->next = a->abilities;
 a->abilities = n;
 return PARSE_ERROR_NONE;
}
struct parser *init_parse_artifact(void) {
 struct parser *p = parser_new();
 parser_setpriv(p, NULL);
 parser_reg(p, "name str name", parse_artifact_name);
 parser_reg(p, "base-object sym tval sym sval", parse_artifact_base_object);
 parser_reg(p, "color sym color", parse_artifact_color);
 parser_reg(p, "graphics char glyph sym color", parse_artifact_graphics);
 parser_reg(p, "pval int pval", parse_artifact_pval);
 parser_reg(p, "depth int level", parse_artifact_level);
 parser_reg(p, "rarity int rarity", parse_artifact_rarity);
 parser_reg(p, "weight int weight", parse_artifact_weight);
 parser_reg(p, "cost int cost", parse_artifact_cost);
 parser_reg(p, "attack int att rand dice", parse_artifact_attack);
 parser_reg(p, "defence int evn rand dice", parse_artifact_defence);
 parser_reg(p, "flags ?str flags", parse_artifact_flags);
 parser_reg(p, "values str values", parse_artifact_values);
 parser_reg(p, "desc str text", parse_artifact_desc);
 parser_reg(p, "slay str code", parse_artifact_slay);
 parser_reg(p, "brand str code", parse_artifact_brand);
 parser_reg(p, "ability sym skill sym ability", parse_artifact_ability);
 return p;
}
static errr run_parse_artifact(struct parser *p) {
 return parse_file_quit_not_found(p, "artefact");
}
static errr finish_parse_artifact(struct parser *p) {
 struct artifact *a, *n;
 int none, aidx;
 /* Scan the list for the max id */
 z_info->a_max = 0;
 a = parser_priv(p);
 while (a) {
  z_info->a_max++;
  a = a->next;
 }
 /* Allocate the direct access list and copy the data to it */
 a_info = mem_zalloc((z_info->a_max + 1) * sizeof(*a));
 aup_info = mem_zalloc((z_info->a_max + 1) * sizeof(*aup_info));
 aidx = z_info->a_max;
 for (a = parser_priv(p); a; a = n, aidx--) {
  assert(aidx > 0);
  memcpy(&a_info[aidx], a, sizeof(*a));
  a_info[aidx].aidx = aidx;
  if (a_info[aidx].d_attr == 255) {
   /*
			 * The color was not set (no base object set).  Use zero
			 * as the color index.
			 */
   a_info[aidx].d_attr = 0;
  }
  n = a->next;
  a_info[aidx].next = (aidx < z_info->a_max) ?
   &a_info[aidx + 1] : NULL;
  mem_free(a);
  aup_info[aidx].aidx = aidx;
 }
 z_info->a_max += 1;
 /* Now we're done with object kinds, deal with object-like things */
 none = tval_find_idx("none");
 pile_kind = lookup_kind(none, lookup_sval(none, "<pile>"));
 parser_destroy(p);
 return 0;
}
static void cleanup_artifact(void)
{
 int idx;
 for (idx = 0; idx < z_info->a_max; idx++) {
  struct artifact *art = &a_info[idx];
  string_free(art->name);
  string_free(art->text);
  mem_free(art->brands);
  mem_free(art->slays);
  release_ability_list(art->abilities);
 }
 mem_free(a_info);
 mem_free(aup_info);
}
struct file_parser artifact_parser = {
 "artefact",
 init_parse_artifact,
 run_parse_artifact,
 finish_parse_artifact,
 cleanup_artifact
};
/**
 * ------------------------------------------------------------------------
 * Initialize self-made artifacts
 * This mostly uses the artifact functions
 * ------------------------------------------------------------------------ */
static errr run_parse_randart(struct parser *p) {
 return parse_file_quit_not_found(p, "randart");
}
static errr finish_parse_randart(struct parser *p) {
 struct artifact *a, *n;
 int aidx;
 int old_max = z_info->a_max, new_max = z_info->a_max;
 /* Scan the list for the max id */
 a = parser_priv(p);
 while (a) {
  ++new_max;
  a = a->next;
 }
 /* Skip using an artifact index of zero. */
 if (!old_max && new_max) {
  ++new_max;
 }
 /* Artifact indices have to fit in a uint16_t. */
 if (new_max > 65535) {
  plog_fmt("Too many artifacts (%d) after reading the "
   "randart file!", new_max);
  return PARSE_ERROR_TOO_MANY_ENTRIES;
 }
 /* Re-allocate the direct access list and copy the data to it */
 a_info = mem_realloc(a_info, new_max * sizeof(*a));
 aup_info = mem_realloc(aup_info, new_max * sizeof(*aup_info));
 if (!old_max && new_max) {
  memset(&a_info[0], 0, sizeof(a_info[0]));
  memset(&aup_info[0], 0, sizeof(aup_info[0]));
 }
 aidx = new_max - 1;
 for (a = parser_priv(p); a; a = n, aidx--) {
  assert(aidx >= old_max);
  memcpy(&a_info[aidx], a, sizeof(*a));
  a_info[aidx].aidx = aidx;
  n = a->next;
  a_info[aidx].next = (aidx < z_info->a_max) ?
   &a_info[aidx + 1] : NULL;
  mem_free(a);
  aup_info[aidx].aidx = aidx;
  aup_info[aidx].created = false;
  aup_info[aidx].seen = false;
  aup_info[aidx].everseen = false;
 }
 z_info->a_max = new_max;
 parser_destroy(p);
 return 0;
}
struct file_parser randart_parser = {
 "randart",
 init_parse_artifact,
 run_parse_randart,
 finish_parse_randart,
 cleanup_artifact
};
/**
 * ------------------------------------------------------------------------
 * Initialize object properties
 * ------------------------------------------------------------------------ */
static enum parser_error parse_object_property_name(struct parser *p) {
 const char *name = parser_getstr(p, "name");
 struct obj_property *h = parser_priv(p);
 struct obj_property *prop = mem_zalloc(sizeof *prop);
 prop->next = h;
 parser_setpriv(p, prop);
 prop->name = string_make(name);
 prop->smith_cat = SMITH_CAT_MAX;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_object_property_type(struct parser *p) {
 struct obj_property *prop = parser_priv(p);
 const char *name = parser_getstr(p, "type");
 if (!prop) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 if (streq(name, "stat")) {
  prop->type = OBJ_PROPERTY_STAT;
 } else if (streq(name, "skill")) {
  prop->type = OBJ_PROPERTY_SKILL;
 } else if (streq(name, "mod")) {
  prop->type = OBJ_PROPERTY_MOD;
 } else if (streq(name, "flag")) {
  prop->type = OBJ_PROPERTY_FLAG;
 } else if (streq(name, "slay")) {
  prop->type = OBJ_PROPERTY_SLAY;
 } else if (streq(name, "brand")) {
  prop->type = OBJ_PROPERTY_BRAND;
 } else if (streq(name, "ignore")) {
  prop->type = OBJ_PROPERTY_IGNORE;
 } else if (streq(name, "resistance")) {
  prop->type = OBJ_PROPERTY_RESIST;
 } else if (streq(name, "vulnerability")) {
  prop->type = OBJ_PROPERTY_VULN;
 } else {
  return PARSE_ERROR_INVALID_PROPERTY;
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_object_property_subtype(struct parser *p) {
 struct obj_property *prop = parser_priv(p);
 const char *name = parser_getstr(p, "subtype");
 if (!prop) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 if (streq(name, "sustain")) {
  prop->subtype = OFT_SUST;
 } else if (streq(name, "protection")) {
  prop->subtype = OFT_PROT;
 } else if (streq(name, "misc ability")) {
  prop->subtype = OFT_MISC;
 } else if (streq(name, "basic")) {
  prop->subtype = OFT_BASIC;
 } else if (streq(name, "melee")) {
  prop->subtype = OFT_MELEE;
 } else if (streq(name, "bad")) {
  prop->subtype = OFT_BAD;
 } else {
  return PARSE_ERROR_INVALID_SUBTYPE;
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_object_property_id_type(struct parser *p) {
 struct obj_property *prop = parser_priv(p);
 const char *name = parser_getstr(p, "id");
 if (!prop) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 if (streq(name, "on effect")) {
  prop->id_type = OFID_NORMAL;
 } else if (streq(name, "timed")) {
  prop->id_type = OFID_TIMED;
 } else if (streq(name, "on wield")) {
  prop->id_type = OFID_WIELD;
 } else {
  return PARSE_ERROR_INVALID_ID_TYPE;
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_object_property_code(struct parser *p) {
 struct obj_property *prop = parser_priv(p);
 const char *code = parser_getstr(p, "code");
 int index = -1;
 if (!prop) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 if (!prop->type) {
  return PARSE_ERROR_MISSING_OBJ_PROP_TYPE;
 }
 if (prop->type == OBJ_PROPERTY_STAT) {
  index = code_index_in_array(obj_mods, code);
 } else if (prop->type == OBJ_PROPERTY_SKILL) {
  index = code_index_in_array(obj_mods, code);
 } else if (prop->type == OBJ_PROPERTY_MOD) {
  index = code_index_in_array(obj_mods, code);
 } else if (prop->type == OBJ_PROPERTY_FLAG) {
  index = code_index_in_array(obj_flags, code);
 } else if (prop->type == OBJ_PROPERTY_SLAY) {
  index = lookup_slay(code);
 } else if (prop->type == OBJ_PROPERTY_BRAND) {
  index = lookup_brand(code);
 } else if (prop->type == OBJ_PROPERTY_IGNORE) {
  index = code_index_in_array(element_names, code);
 } else if (prop->type == OBJ_PROPERTY_RESIST) {
  index = code_index_in_array(element_names, code);
 } else if (prop->type == OBJ_PROPERTY_VULN) {
  index = code_index_in_array(element_names, code);
 }
 if (index >= 0) {
  prop->index = index;
 } else {
  return PARSE_ERROR_INVALID_OBJ_PROP_CODE;
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_object_property_smith_cat(struct parser *p) {
 struct obj_property *prop = parser_priv(p);
 const char *name = parser_getstr(p, "type");
 if (!prop) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 if (streq(name, "stat")) {
  prop->smith_cat = SMITH_CAT_STAT;
 } else if (streq(name, "sustain")) {
  prop->smith_cat = SMITH_CAT_SUSTAIN;
 } else if (streq(name, "skill")) {
  prop->smith_cat = SMITH_CAT_SKILL;
 } else if (streq(name, "melee")) {
  prop->smith_cat = SMITH_CAT_MELEE;
 } else if (streq(name, "slay")) {
  prop->smith_cat = SMITH_CAT_SLAY;
 } else if (streq(name, "resist")) {
  prop->smith_cat = SMITH_CAT_RESIST;
 } else if (streq(name, "curse")) {
  prop->smith_cat = SMITH_CAT_CURSE;
 } else if (streq(name, "misc")) {
  prop->smith_cat = SMITH_CAT_MISC;
 } else {
  return PARSE_ERROR_INVALID_SMITHING_CATEGORY;
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_object_property_smith_diff(struct parser *p) {
 struct obj_property *prop = parser_priv(p);
 if (!prop) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 prop->smith_diff = parser_getint(p, "difficulty");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_object_property_smith_cost(struct parser *p) {
 struct obj_property *prop = parser_priv(p);
 const char *name = parser_getsym(p, "type");
 if (!prop) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 if (streq(name, "STR")) {
  prop->smith_cost_type = SMITH_COST_STR;
 } else if (streq(name, "DEX")) {
  prop->smith_cost_type = SMITH_COST_DEX;
 } else if (streq(name, "CON")) {
  prop->smith_cost_type = SMITH_COST_CON;
 } else if (streq(name, "GRA")) {
  prop->smith_cost_type = SMITH_COST_GRA;
 } else if (streq(name, "EXP")) {
  prop->smith_cost_type = SMITH_COST_EXP;
 } else {
  return PARSE_ERROR_INVALID_SMITHING_COST_TYPE;
 }
 prop->smith_cost = parser_getint(p, "cost");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_object_property_smith_exclude_base(struct parser *p) {
 struct obj_property *prop = parser_priv(p);
 const char *yesno = parser_getstr(p, "yesno");
 if (!prop) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 if (streq(yesno, "yes")) {
  prop->smith_exclude_base = true;
 } else if (streq(yesno, "no")) {
  prop->smith_exclude_base = false;
 } else {
  return PARSE_ERROR_INVALID_OPTION;
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_object_property_adjective(struct parser *p) {
 struct obj_property *prop = parser_priv(p);
 const char *adj = parser_getstr(p, "adj");
 if (!prop) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 string_free(prop->adjective);
 prop->adjective = string_make(adj);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_object_property_neg_adj(struct parser *p) {
 struct obj_property *prop = parser_priv(p);
 const char *adj = parser_getstr(p, "neg_adj");
 if (!prop) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 string_free(prop->neg_adj);
 prop->neg_adj = string_make(adj);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_object_property_msg(struct parser *p) {
 struct obj_property *prop = parser_priv(p);
 const char *msg = parser_getstr(p, "msg");
 if (!prop) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 string_free(prop->msg);
 prop->msg = string_make(msg);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_object_property_slay_msg(struct parser *p) {
 struct obj_property *prop = parser_priv(p);
 const char *msg = parser_getstr(p, "msg");
 if (!prop) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 string_free(prop->slay_msg);
 prop->slay_msg = string_make(msg);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_object_property_desc(struct parser *p) {
 struct obj_property *prop = parser_priv(p);
 const char *desc = parser_getstr(p, "desc");
 if (!prop) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 string_free(prop->desc);
 prop->desc = string_make(desc);
 return PARSE_ERROR_NONE;
}
static struct parser *init_parse_object_property(void) {
 struct parser *p = parser_new();
 parser_setpriv(p, NULL);
 parser_reg(p, "name str name", parse_object_property_name);
 parser_reg(p, "code str code", parse_object_property_code);
 parser_reg(p, "smith-cat str type", parse_object_property_smith_cat);
 parser_reg(p, "smith-difficulty int difficulty",
      parse_object_property_smith_diff);
 parser_reg(p, "smith-cost sym type int cost",
      parse_object_property_smith_cost);
 parser_reg(p, "smith-exclude-base str yesno",
      parse_object_property_smith_exclude_base);
 parser_reg(p, "type str type", parse_object_property_type);
 parser_reg(p, "subtype str subtype", parse_object_property_subtype);
 parser_reg(p, "id-type str id", parse_object_property_id_type);
 parser_reg(p, "adjective str adj", parse_object_property_adjective);
 parser_reg(p, "neg-adjective str neg_adj", parse_object_property_neg_adj);
 parser_reg(p, "msg str msg", parse_object_property_msg);
 parser_reg(p, "slay-msg str msg", parse_object_property_slay_msg);
 parser_reg(p, "desc str desc", parse_object_property_desc);
 return p;
}
static errr run_parse_object_property(struct parser *p) {
 return parse_file_quit_not_found(p, "object_property");
}
static errr finish_parse_object_property(struct parser *p) {
 struct obj_property *prop, *n;
 int idx;
 /* Scan the list for the max id */
 z_info->property_max = 0;
 prop = parser_priv(p);
 while (prop) {
  z_info->property_max++;
  prop = prop->next;
 }
 /* Allocate the direct access list and copy the data to it */
 obj_properties = mem_zalloc((z_info->property_max + 1) * sizeof(*prop));
 idx = z_info->property_max;
 for (prop = parser_priv(p); prop; prop = n, idx--) {
  assert(idx > 0);
  memcpy(&obj_properties[idx], prop, sizeof(*prop));
  n = prop->next;
  mem_free(prop);
 }
 z_info->property_max += 1;
 parser_destroy(p);
 return 0;
}
static void cleanup_object_property(void)
{
 int idx;
 for (idx = 0; idx < z_info->property_max; idx++) {
  struct obj_property *prop = &obj_properties[idx];
  string_free(prop->name);
  string_free(prop->adjective);
  string_free(prop->neg_adj);
  string_free(prop->slay_msg);
  string_free(prop->msg);
  string_free(prop->desc);
 }
 mem_free(obj_properties);
}
struct file_parser object_property_parser = {
 "object_property",
 init_parse_object_property,
 run_parse_object_property,
 finish_parse_object_property,
 cleanup_object_property
};
/**
 * \file obj-knowledge.c
 * \brief Object knowledge
 *
 * Copyright (c) 2016 Nick McConnell
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Overview
 * ========
 * This file deals with the new "rune-based ID" system.  This system operates
 * as follows:
 * - struct player has an object struct attached to it (obj_k) which contains
 *   the player's knowledge of object properties (runes)
 * - whenever the player learns a rune, 
 *   - if it's an object flag, that flag is set in obj_k
 *   - if it's an integer value, that value in obj_k is set to 1
 *   - if it's element info, the res_level value is set to 1
 *   - if it's a brand, a brand is added to obj_k with the relevant element
 *   - if it's a slay, a slay is added to obj_k with the right race flag or name
 * - every object has a known version which is filled in with details as the
 *   player learns them
 * - whenever the player learns a rune, that knowledge is applied to the known
 *   version of every object that the player has picked up or walked over
 */
/**
 * ------------------------------------------------------------------------
 * Object knowledge data
 * This section covers initialisation, access and cleanup of rune data
 * ------------------------------------------------------------------------ */
static size_t rune_max;
static struct rune *rune_list;
/**
 * Initialise the rune module
 */
static void init_rune(void)
{
 int i, j, count;
 /* Count runes */
 count = 0;
 for (i = 1; i < OF_MAX; i++) {
  struct obj_property *prop = lookup_obj_property(OBJ_PROPERTY_FLAG, i);
  if (prop->subtype == OFT_NONE) continue;
  if (prop->subtype == OFT_BASIC) continue;
  count++;
 }
 for (i = 0; i < OBJ_MOD_MAX; i++) {
  count++;
 }
 for (i = 0; i < ELEM_MAX; i++) {
  count++;
 }
 /* Note brand runes cover all brands with the same name */
 for (i = 1; i < z_info->brand_max; i++) {
  bool counted = false;
  if (brands[i].name) {
   for (j = 1; j < i; j++) {
    if (streq(brands[i].name, brands[j].name)) {
     counted = true;
    }
   }
   if (!counted) {
    count++;
   }
  }
 }
 /* Note slay runes cover all slays with the same flag/base */
 for (i = 1; i < z_info->slay_max; i++) {
  bool counted = false;
  if (slays[i].name) {
   for (j = 1; j < i; j++) {
    if (same_monsters_slain(i, j)) {
     counted = true;
    }
   }
   if (!counted) {
    count++;
   }
  }
 }
 /* Now allocate and fill the rune list */
 rune_max = count;
 rune_list = mem_zalloc(rune_max * sizeof(struct rune));
 count = 0;
 for (i = 0; i < OBJ_MOD_MAX; i++) {
  struct obj_property *prop = lookup_obj_property(OBJ_PROPERTY_MOD, i);
  rune_list[count++] = (struct rune) { RUNE_VAR_MOD, i, 0, prop->name };
 }
 for (i = 0; i < ELEM_MAX; i++) {
  rune_list[count++] = (struct rune) { RUNE_VAR_RESIST, i, 0, projections[i].name };
 }
 for (i = 1; i < z_info->brand_max; i++) {
  bool counted = false;
  if (brands[i].name) {
   for (j = 1; j < i; j++) {
    if (streq(brands[i].name, brands[j].name)) {
     counted = true;
    }
   }
   if (!counted) {
    rune_list[count++] =
     (struct rune) { RUNE_VAR_BRAND, i, 0, brands[i].name };
   }
  }
 }
 for (i = 1; i < z_info->slay_max; i++) {
  bool counted = false;
  if (slays[i].name) {
   for (j = 1; j < i; j++) {
    if (same_monsters_slain(i, j)) {
     counted = true;
    }
   }
   if (!counted) {
    rune_list[count++] =
     (struct rune) { RUNE_VAR_SLAY, i, 0, slays[i].name };
   }
  }
 }
 for (i = 1; i < OF_MAX; i++) {
  struct obj_property *prop = lookup_obj_property(OBJ_PROPERTY_FLAG, i);
  if (prop->subtype == OFT_NONE) continue;
  if (prop->subtype == OFT_BASIC) continue;
  rune_list[count++] = (struct rune)
   { RUNE_VAR_FLAG, i, 0, prop->name };
 }
}
/**
 * Get a rune by variety and index
 */
static int rune_index(size_t variety, int index)
{
 size_t i;
 /* Look for the rune */
 for (i = 0; i < rune_max; i++)
  if ((rune_list[i].variety == variety) && (rune_list[i].index == index))
   return i;
 /* Can't find it */
 return -1;
}
/**
 * Cleanup the rune module
 */
static void cleanup_rune(void)
{
 mem_free(rune_list);
}
struct init_module rune_module = {
 .name = "rune",
 .init = init_rune,
 .cleanup = cleanup_rune
};
/**
 * ------------------------------------------------------------------------
 * Rune knowledge functions
 * These functions provide details about the rune list for use in 
 * player knowledge screens
 * ------------------------------------------------------------------------ */
/**
 * The number of runes
 */
int max_runes(void)
{
 return rune_max;
}
/**
 * The variety of a rune
 */
enum rune_variety rune_variety(size_t i)
{
 return rune_list[i].variety;
}
/**
 * Reports if the player knows a given rune
 *
 * \param p is the player
 * \param i is the rune's number in the rune list
 */
bool player_knows_rune(struct player *p, size_t i)
{
 struct rune *r = &rune_list[i];
 switch (r->variety) {
  /* Mod runes */
  case RUNE_VAR_MOD: {
   if (p->obj_k->modifiers[r->index])
    return true;
   break;
  }
  /* Element runes */
  case RUNE_VAR_RESIST: {
   if (p->obj_k->el_info[r->index].res_level)
    return true;
   break;
  }
  /* Brand runes */
  case RUNE_VAR_BRAND: {
   assert(r->index < z_info->brand_max);
   if (p->obj_k->brands[r->index]) {
    return true;
   }
   break;
  }
  /* Slay runes */
  case RUNE_VAR_SLAY: {
   assert(r->index < z_info->slay_max);
   if (p->obj_k->slays[r->index]) {
    return true;
   }
   break;
  }
  /* Flag runes */
  case RUNE_VAR_FLAG: {
   if (of_has(p->obj_k->flags, r->index))
    return true;
   break;
  }
  default: {
   break;
  }
 }
 return false;
}
/**
 * The name of a rune
 */
const char *rune_name(size_t i)
{
 struct rune *r = &rune_list[i];
 if (r->variety == RUNE_VAR_BRAND)
  return format("%s brand", r->name);
 else if (r->variety == RUNE_VAR_SLAY)
  return format("slay %s", r->name);
 else if (r->variety == RUNE_VAR_RESIST)
  return format("resist %s", r->name);
 else
  return format("%s", r->name);
 return NULL;
}
/**
 * The description of a rune
 */
const char *rune_desc(size_t i)
{
 struct rune *r = &rune_list[i];
 switch (r->variety) {
  /* Mod runes */
  case RUNE_VAR_MOD: {
   return format("Object gives the player a magical bonus to %s.",
        r->name);
   break;
  }
  /* Element runes */
  case RUNE_VAR_RESIST: {
   return format("Object affects the player's resistance to %s.",
        r->name);
   break;
  }
  /* Brand runes */
  case RUNE_VAR_BRAND: {
   return format("Object brands the player's attacks with %s.",
        r->name);
   break;
  }
  /* Slay runes */
  case RUNE_VAR_SLAY: {
   return format("Object makes the player's attacks against %s more powerful.", r->name);
   break;
  }
  /* Flag runes */
  case RUNE_VAR_FLAG: {
   return format("Object gives the player the property of %s.",
        r->name);
   break;
  }
  default: {
   break;
  }
 }
 return NULL;
}
/**
 * The autoinscription index (if any) of a rune
 */
quark_t rune_note(size_t i)
{
 return rune_list[i].note;
}
/**
 * Set an autoinscription on a rune
 */
void rune_set_note(size_t i, const char *inscription)
{
 struct rune *r = &rune_list[i];
 if (!inscription)
  r->note = 0;
 else
  r->note = quark_add(inscription);
}
/**
 * ------------------------------------------------------------------------
 * Object knowledge predicates
 * These functions tell how much the player knows about an object
 * ------------------------------------------------------------------------ */
/**
 * Check if a flag is known to the player
 *
 * \param p is the player
 * \param f is the flag index
 */
bool player_knows_flag(struct player *p, int f)
{
 return of_has(p->obj_k->flags, f);
}
/**
 * Check if a brand is known to the player
 *
 * \param p is the player
 * \param i is the brand index
 */
bool player_knows_brand(struct player *p, int i)
{
 return p->obj_k->brands[i];
}
/**
 * Check if a slay is known to the player
 *
 * \param p is the player
 * \param i is the slay index
 */
bool player_knows_slay(struct player *p, int i)
{
 return p->obj_k->slays[i];
}
/**
 * Check if an ego item type is known to the player
 *
 * \param p is the player
 * \param ego is the ego item type
 * \param obj may be NULL to test whether the player knows the ego in general;
 *     if obj is not NULL, the test is for whether the ego is know for that
 *     specific object (allows for the ego to be known for the object in the
 *     case where an ego has range of at least two values, including zero, for
 *     a modifier, the player doesn't know that modifier,  and the object has
 *     zero for that modifier)
 */
bool player_knows_ego(struct player *p, struct ego_item *ego)
{
 int i;
 if (!ego) return false;
 /* All flags known */
 if (!of_is_subset(p->obj_k->flags, ego->flags)) return false;
 /* All modifiers known */
 for (i = 0; i < OBJ_MOD_MAX; i++) {
  if ((ABS(ego->modifiers[i]) > 0) && !p->obj_k->modifiers[i]) {
    return false;
  }
 }
 /* All elements known */
 for (i = 0; i < ELEM_MAX; i++)
  if (ego->el_info[i].res_level && !p->obj_k->el_info[i].res_level)
   return false;
 /* All brands known */
 for (i = 1; i < z_info->brand_max; i++) {
  if (ego->brands && ego->brands[i] && !player_knows_brand(p, i)) {
   return false;
  }
 }
 /* All slays known */
 for (i = 1; i < z_info->slay_max; i++) {
  if (ego->slays && ego->slays[i] && !player_knows_slay(p, i)) {
   return false;
  }
 }
 return true;
}
/**
 * Checks whether the object is known to be an artifact
 *
 * \param obj is the object
 */
bool object_is_known_artifact(const struct object *obj)
{
 if (!obj->known) return false;
 return obj->known->artifact ? true : false;
}
/**
 * Check if an object has a rune
 *
 * \param obj is the object
 * \param rune_no is the rune's number in the rune list
 */
bool object_has_rune(const struct object *obj, int rune_no)
{
 struct rune *r = &rune_list[rune_no];
 switch (r->variety) {
  /* Mod runes */
  case RUNE_VAR_MOD: {
   if (obj->modifiers[r->index] != 0)
    return true;
   break;
  }
  /* Element runes */
  case RUNE_VAR_RESIST: {
   if (obj->el_info[r->index].res_level != 0)
    return true;
   break;
  }
  /* Brand runes */
  case RUNE_VAR_BRAND: {
   if (obj->brands) {
    int i;
    for (i = 0; i < z_info->brand_max; i++) {
     if (obj->brands[i] && streq(brands[i].name, r->name)) {
      return true;
     }
    }
   }
   break;
  }
  /* Slay runes */
  case RUNE_VAR_SLAY: {
   if (obj->slays) {
    int i;
    for (i = 0; i < z_info->slay_max; i++) {
     if (obj->slays[i] && same_monsters_slain(r->index, i)) {
      return true;
     }
    }
   }
   break;
  }
  /* Flag runes */
  case RUNE_VAR_FLAG: {
   if (of_has(obj->flags, r->index))
    return true;
   break;
  }
  default: break;
 }
 return false;
}
/**
 * Check if all the runes on an object are known to the player
 *
 * \param obj is the object
 */
bool object_runes_known(const struct object *obj)
{
 int i;
 /* No known object */
 if (!obj->known) return false;
 /* Not all modifiers known */
 for (i = 0; i < OBJ_MOD_MAX; i++)
  if (obj->modifiers[i] != obj->known->modifiers[i])
   return false;
 /* Not all elements known */
 for (i = 0; i < ELEM_MAX; i++)
  if ((obj->el_info[i].res_level != 0) &&
   (obj->known->el_info[i].res_level == 0))
   return false;
 /* Not all brands known */
 if (obj->brands) {
  if (!obj->known->brands)
   return false;
  for (i = 0; i < z_info->brand_max; i++) {
   if (obj->brands[i] && !obj->known->brands[i]) {
    return false;
   }
  }
 }
 /* Not all slays known */
 if (obj->slays) {
  if (!obj->known->slays)
   return false;
  for (i = 0; i < z_info->slay_max; i++) {
   if (obj->slays[i] && !obj->known->slays[i]) {
    return false;
   }
  }
 }
 /* Not all flags known */
 if (!of_is_subset(obj->known->flags, obj->flags)) return false;
 return true;
}
/**
 * Checks whether a player knows whether an object has a given flag
 *
 * \param p is the player
 * \param obj is the object
 * \param flag is the flag
 */
bool object_flag_is_known(const struct player *p, const struct object *obj,
 int flag)
{
 /* Object runes known means OK */
 if (object_runes_known(obj)) return true;
 /* Player knows the flag means OK */
 if (of_has(p->obj_k->flags, flag)) return true;
 /* Object has had a chance to display the flag means OK */
 if (of_has(obj->known->flags, flag)) return true;
 return false;
}
/**
 * Checks whether a player knows the given element properties of an object
 *
 * \param p is the player
 * \param obj is the object
 * \param element is the element
 */
bool object_element_is_known(const struct player *p, const struct object *obj,
 int element)
{
 if (element < 0 || element >= ELEM_MAX) return false;
 /* Object runes known means OK */
 if (object_runes_known(obj)) return true;
 /* Player knows the element means OK */
 if (p->obj_k->el_info[element].res_level) return true;
 /* Object has been exposed to the element means OK */
 if (obj->known->el_info[element].res_level) return true;
 return false;
}
/**
 * ------------------------------------------------------------------------
 * Object knowledge propagators
 * These functions transfer player knowledge to objects
 * ------------------------------------------------------------------------ */
/**
 * Sets the basic details on a known object
 */
void object_set_base_known(struct player *p, struct object *obj)
{
 assert(obj->known);
 obj->known->kind = obj->kind;
 obj->known->tval = obj->tval;
 obj->known->sval = obj->sval;
 obj->known->weight = obj->weight;
 obj->known->number = obj->number;
 /* Dice, attack and evasion */
 if (!obj->known->dd) {
  obj->known->dd = obj->kind->dd * p->obj_k->dd;
 }
 if (!obj->known->ds) {
  obj->known->ds = obj->kind->ds * p->obj_k->ds;
 }
 if (!obj->known->pd) {
  obj->known->pd = obj->kind->pd * p->obj_k->pd;
 }
 if (!obj->known->ps) {
  obj->known->ps = obj->kind->ps * p->obj_k->ps;
 }
 if (!obj->known->att) {
  obj->known->att = obj->kind->att * p->obj_k->att;
 }
 if (!obj->known->evn) {
  obj->known->evn = obj->kind->evn * p->obj_k->evn;
 }
 /* Aware flavours and unflavored non-wearables get info now */
 if ((obj->kind->aware && obj->kind->flavor) ||
  (!tval_is_wearable(obj) && !obj->kind->flavor)) {
  obj->known->pval = obj->pval;
 }
}
/**
 * Gain knowledge based on seeing an object on the floor
 */
void object_see(struct player *p, struct object *obj)
{
 struct object *known_obj = p->cave->objects[obj->oidx];
 struct loc grid = obj->grid;
 /* Make new known objects, fully know sensed ones, relocate old ones */
 if (known_obj == NULL) {
  /* Make a new one */
  struct object *new_obj;
  assert(! obj->known);
  new_obj = object_new();
  obj->known = new_obj;
  new_obj->kind = obj->kind;
  new_obj->tval = obj->tval;
  new_obj->sval = obj->sval;
  new_obj->number = obj->number;
  /* List the known object */
  p->cave->objects[obj->oidx] = new_obj;
  new_obj->oidx = obj->oidx;
  /* If monster held, we're done */
  if (obj->held_m_idx) return;
  /* Attach it to the current floor pile */
  new_obj->grid = grid;
  pile_insert_end(&p->cave->squares[grid.y][grid.x].obj, new_obj);
 } else {
  struct loc old = known_obj->grid;
  /* Make sure knowledge is correct */
  assert(known_obj == obj->known);
  known_obj->kind = obj->kind;
  known_obj->tval = obj->tval;
  known_obj->sval = obj->sval;
  known_obj->number = obj->number;
  /* If monster held, we're done */
  if (obj->held_m_idx) return;
  /* Attach it to the current floor pile if necessary */
  if (! square_holds_object(p->cave, grid, known_obj)) {
   /* Detach from any old pile */
   if (!loc_is_zero(old) && square_holds_object(p->cave, old, known_obj)) {
    square_excise_object(p->cave, old, known_obj);
   }
   known_obj->grid = grid;
   pile_insert_end(&p->cave->squares[grid.y][grid.x].obj, known_obj);
  }
 }
}
/**
 * Gain knowledge based on being an the same square as an object
 */
void object_touch(struct player *p, struct object *obj)
{
 /* Automatically notice artifacts, mark as assessed */
 obj->known->artifact = obj->artifact;
 obj->known->notice |= OBJ_NOTICE_ASSESSED;
 /* Apply known properties to the object */
 player_know_object(p, obj);
 /* Log artifacts if found */
 if (obj->artifact && !is_artifact_seen(obj->artifact)) {
  const struct artifact *art = obj->artifact;
  int new_exp = 100;
  /* Mark */
  mark_artifact_seen(art, true);
  /* Gain experience for identification */
  player_exp_gain(p, new_exp);
  p->ident_exp += new_exp;
  /* Record in the history */
  history_find_artifact(p, art);
 }
}
/**
 * Transfer player object knowledge to an object
 *
 * \param p is the player
 * \param obj is the object
 */
void player_know_object(struct player *p, struct object *obj)
{
 int i, flag;
 bool seen = true;
 /* Unseen or only sensed objects don't get any ID */
 if (!obj) return;
 if (!obj->known) return;
 if (obj->kind != obj->known->kind) return;
 /* Distant objects just get base properties */
 if (obj->kind && !(obj->known->notice & OBJ_NOTICE_ASSESSED)) {
  object_set_base_known(p, obj);
  return;
 }
 /* Know flavored objects with Item Lore */
 if (player_active_ability(p, "Item Lore")) {
  object_flavor_aware(p, obj);
 }
 /* Know worn objects with Lore-Master */
 if (player_active_ability(p, "Lore-Master")) {
  while (!object_runes_known(obj)) {
   object_learn_unknown_rune(p, obj);
  }
 }
 /* Get the combat properties, and the pval for anything but chests */
 obj->known->dd = obj->dd * p->obj_k->dd;
 obj->known->ds = obj->ds * p->obj_k->ds;
 obj->known->pd = obj->pd * p->obj_k->pd;
 obj->known->ps = obj->ps * p->obj_k->ps;
 obj->known->att = obj->att * p->obj_k->att;
 obj->known->evn = obj->evn * p->obj_k->evn;
 if (!tval_is_chest(obj))
  obj->known->pval = obj->pval;
 /* Set modifiers */
 for (i = 0; i < OBJ_MOD_MAX; i++) {
  if (p->obj_k->modifiers[i]) {
   obj->known->modifiers[i] = obj->modifiers[i];
  } else {
   obj->known->modifiers[i] = 0;
  }
 }
 /* Set elements */
 for (i = 0; i < ELEM_MAX; i++) {
  if (p->obj_k->el_info[i].res_level == 1) {
   obj->known->el_info[i].res_level = obj->el_info[i].res_level;
   obj->known->el_info[i].flags = obj->el_info[i].flags;
  } else {
   obj->known->el_info[i].res_level = 0;
   obj->known->el_info[i].flags = 0;
  }
 }
 /* Set object flags */
 of_wipe(obj->known->flags);
 for (flag = of_next(p->obj_k->flags, FLAG_START); flag != FLAG_END;
   flag = of_next(p->obj_k->flags, flag + 1)) {
  if (of_has(obj->flags, flag)) {
   of_on(obj->known->flags, flag);
  }
 }
 /* Set brands */
 if (obj->brands) {
  bool known_brand = false;
  for (i = 1; i < z_info->brand_max; i++) {
   if (player_knows_brand(p, i) && obj->brands[i]) {
    if (!obj->known->brands) {
     obj->known->brands = mem_zalloc(
      z_info->brand_max *
      sizeof(bool));
    }
    obj->known->brands[i] = true;
    known_brand = true;
   } else if (obj->known->brands) {
    obj->known->brands[i] = false;
   }
  }
  if (!known_brand && obj->known->brands) {
   mem_free(obj->known->brands);
   obj->known->brands = NULL;
  }
 }
 /* Set slays */
 if (obj->slays) {
  bool known_slay = false;
  for (i = 1; i < z_info->slay_max; i++) {
   if (player_knows_slay(p, i) && obj->slays[i]) {
    if (!obj->known->slays) {
     obj->known->slays = mem_zalloc(
      z_info->slay_max *
      sizeof(bool));
    }
    obj->known->slays[i] = true;
    known_slay = true;
   } else if (obj->known->slays) {
    obj->known->slays[i] = false;
   }
  }
  if (!known_slay && obj->known->slays) {
   mem_free(obj->known->slays);
   obj->known->slays = NULL;
  }
 }
 /* Set ego type, jewellery type if known */
 if (player_knows_ego(p, obj->ego)) {
  seen = obj->ego->everseen;
  obj->known->ego = obj->ego;
 } else {
  obj->known->ego = NULL;
 }
 if (tval_is_jewelry(obj)) {
  if (object_runes_known(obj)) {
   seen = (obj->artifact) ? true : obj->kind->everseen;
   object_flavor_aware(p, obj);
  }
 } else if (obj->kind->kidx >= z_info->ordinary_kind_max) {
  /*
		 * Become aware if it is a special artifact that isn't
		 * jewelry.
		 */
  seen = true;
  object_flavor_aware(p, obj);
 }
 /* Report on new stuff */
 if (!seen) {
  char o_name[80];
  /* Describe the object if it's available */
  if (object_is_carried(p, obj)) {
   object_desc(o_name, sizeof(o_name), obj,
    ODESC_PREFIX | ODESC_FULL, p);
   msg("You have %s (%c).", o_name, gear_to_label(p, obj));
  } else if (cave && square_holds_object(cave, p->grid, obj)) {
   object_desc(o_name, sizeof(o_name), obj,
    ODESC_PREFIX | ODESC_FULL, p);
   msg("On the ground: %s.", o_name);
  }
 }
 /* Fully known objects have their known element and flag info set to 
	 * match the actual info, rather than showing what elements and flags
	 * the would be displaying if they had them */
 if (object_runes_known(obj)) {
  for (i = 0; i < ELEM_MAX; i++) {
   obj->known->el_info[i].res_level = obj->el_info[i].res_level;
   obj->known->el_info[i].flags = obj->el_info[i].flags;
  }
  of_wipe(obj->known->flags);
  of_copy(obj->known->flags, obj->flags);
 }
}
/**
 * Propagate player knowledge of objects to all objects
 *
 * \param p is the player
 */
void update_player_object_knowledge(struct player *p)
{
 int i;
 struct object *obj;
 /* Level objects */
 if (cave)
  for (i = 0; i < cave->obj_max; i++)
   player_know_object(p, cave->objects[i]);
 /* Player objects */
 for (obj = p->gear; obj; obj = obj->next)
  player_know_object(p, obj);
 /* Update */
 if (cave)
  autoinscribe_ground(p);
 autoinscribe_pack(p);
 event_signal(EVENT_INVENTORY);
 event_signal(EVENT_EQUIPMENT);
}
/**
 * ------------------------------------------------------------------------
 * Object knowledge learners
 * These functions are for increasing player knowledge of object properties
 * ------------------------------------------------------------------------ */
/**
 * Learn a given rune
 *
 * \param p is the player
 * \param i is the rune index
 * \param message is whether or not to print a message
 */
static void player_learn_rune(struct player *p, size_t i, bool message)
{
 struct rune *r = &rune_list[i];
 bool learned = false;
 switch (r->variety) {
  /* Mod runes */
  case RUNE_VAR_MOD: {
   if (!p->obj_k->modifiers[r->index]) {
    p->obj_k->modifiers[r->index] = 1;
    learned = true;
   }
   break;
  }
  /* Element runes */
  case RUNE_VAR_RESIST: {
   if (!p->obj_k->el_info[r->index].res_level) {
    p->obj_k->el_info[r->index].res_level = 1;
    learned = true;
   }
   break;
  }
  /* Brand runes */
  case RUNE_VAR_BRAND: {
   assert(r->index < z_info->brand_max);
   /* If the brand was unknown, add it to known brands */
   if (!player_knows_brand(p, r->index)) {
    int j;
    for (j = 1; j < z_info->brand_max; j++) {
     /* Check base and race flag */
     if (streq(brands[r->index].name, brands[j].name)) {
      p->obj_k->brands[j] = true;
      learned = true;
     }
    }
   }
   break;
  }
  /* Slay runes */
  case RUNE_VAR_SLAY: {
   assert(r->index < z_info->slay_max);
   /* If the slay was unknown, add it to known slays */
   if (!player_knows_slay(p, r->index)) {
    int j;
    for (j = 1; j < z_info->slay_max; j++) {
     /* Check base and race flag */
     if (same_monsters_slain(r->index, j)) {
      p->obj_k->slays[j] = true;
      learned = true;
     }
    }
   }
   break;
  }
  /* Flag runes */
  case RUNE_VAR_FLAG: {
   if (of_on(p->obj_k->flags, r->index))
    learned = true;
   break;
  }
  default: {
   learned = false;
   break;
  }
 }
 /* Nothing learned */
 if (!learned) return;
 /* Give a message */
 if (message)
  msgt(MSG_RUNE, "You have learned the property of %s.", rune_name(i));
 /* Update knowledge */
 update_player_object_knowledge(p);
}
/**
 * Learn a flag
 */
void player_learn_flag(struct player *p, int flag)
{
 player_learn_rune(p, rune_index(RUNE_VAR_FLAG, flag), true);
 update_player_object_knowledge(p);
}
/**
 * Learn a slay.
 */
void player_learn_slay(struct player *p, int index)
{
 /* Learn about the slay */
 if (!player_knows_slay(p, index)) {
  int i;
  /* Find the rune index */
  for (i = 1; i < z_info->slay_max; i++) {
   if (same_monsters_slain(i, index)) {
    break;
   }
  }
  assert(i < z_info->slay_max);
  /* Learn the rune */
  player_learn_rune(p, rune_index(RUNE_VAR_SLAY, i), true);
  update_player_object_knowledge(p);
 }
}
/**
 * Learn a brand.
 */
void player_learn_brand(struct player *p, int index)
{
 /* Learn about the brand */
 if (!player_knows_brand(p, index)) {
  int i;
  /* Find the rune index */
  for (i = 1; i < z_info->brand_max; i++) {
   if (streq(brands[i].name, brands[index].name)) {
    break;
   }
  }
  assert(i < z_info->brand_max);
  /* Learn the rune */
  player_learn_rune(p, rune_index(RUNE_VAR_BRAND, i), true);
  update_player_object_knowledge(p);
 }
}
/**
 * Learn absolutely everything
 *
 * \param p is the player
 */
void player_learn_all_runes(struct player *p)
{
 size_t i;
 for (i = 0; i < rune_max; i++)
  player_learn_rune(p, i, false);
}
/**
 * ------------------------------------------------------------------------
 * Functions for learning from the behaviour of indvidual objects
 * ------------------------------------------------------------------------ */
/**
 * Print a message when an object modifier is identified by use.
 *
 * \param obj is the object 
 * \param mod is the modifier being noticed
 */
static void mod_message(struct object *obj, int mod)
{
 /* Special messages for individual properties */
 switch (mod) {
  case OBJ_MOD_STR:
   if (obj->modifiers[OBJ_MOD_STR] > 0)
    msg("You feel stronger.");
   else if (obj->modifiers[OBJ_MOD_STR] < 0)
    msg("You feel less strong");
   break;
  case OBJ_MOD_DEX:
   if (obj->modifiers[OBJ_MOD_DEX] > 0)
    msg("You feel more agile.");
   else if (obj->modifiers[OBJ_MOD_DEX] < 0)
    msg("You feel less agile.");
   break;
  case OBJ_MOD_CON:
   if (obj->modifiers[OBJ_MOD_CON] > 0)
    msg("You feel mmore resilient.");
   else if (obj->modifiers[OBJ_MOD_CON] < 0)
    msg("You feel less resilient.");
   break;
  case OBJ_MOD_GRA:
   if (obj->modifiers[OBJ_MOD_GRA] > 0)
    msg("You feel more attuned to the world.");
   else if (obj->modifiers[OBJ_MOD_GRA] < 0)
    msg("You feel less attuned to the world.");
   break;
  case OBJ_MOD_MELEE:
   if (obj->modifiers[OBJ_MOD_MELEE] > 0)
    msg("You feel more in control of your weapon.");
   else if (obj->modifiers[OBJ_MOD_MELEE] < 0)
    msg("You feel less in control of your weapon.");
   break;
  case OBJ_MOD_ARCHERY:
   if (obj->modifiers[OBJ_MOD_ARCHERY] > 0)
    msg("You feel more accurate at archery.");
   else if (obj->modifiers[OBJ_MOD_ARCHERY] < 0)
    msg("You feel less accurate at archery.");
   break;
  case OBJ_MOD_STEALTH:
   if (obj->modifiers[OBJ_MOD_STEALTH] > 0)
    msg("Your movements become quieter.");
   else if (obj->modifiers[OBJ_MOD_STEALTH] < 0)
    msg("Your movements become less quiet.");
   break;
  case OBJ_MOD_PERCEPTION:
   if (obj->modifiers[OBJ_MOD_PERCEPTION] > 0)
    msg("You feel more perceptive.");
   else if (obj->modifiers[OBJ_MOD_PERCEPTION] < 0)
    msg("You feel less perceptive.");
   break;
  case OBJ_MOD_WILL:
   if (obj->modifiers[OBJ_MOD_WILL] > 0)
    msg("You feel more firm of will.");
   else if (obj->modifiers[OBJ_MOD_WILL] < 0)
    msg("You feel less firm of will.");
   break;
  case OBJ_MOD_SMITHING:
   if (obj->modifiers[OBJ_MOD_SMITHING] > 0)
    msg("You feel a desire to craft things with your hands.");
   else if (obj->modifiers[OBJ_MOD_SMITHING] < 0)
    msg("You feel less able to craft things.");
   break;
  case OBJ_MOD_SONG:
   if (obj->modifiers[OBJ_MOD_SONG] > 0)
    msg("You are filled with inspiration.");
   else if (obj->modifiers[OBJ_MOD_SONG] < 0)
    msg("You feel a loss of inspiration.");
   break;
  case OBJ_MOD_DAMAGE_SIDES:
   if (obj->modifiers[OBJ_MOD_DAMAGE_SIDES] > 0)
    msg("You feel more forceful in melee.");
   else if (obj->modifiers[OBJ_MOD_DAMAGE_SIDES] < 0)
    msg("You feel less forceful in melee.");
   break;
  default:
   break;
 }
}
/**
 * Get a random unknown rune from an object
 *
 * \param p is the player
 * \param obj is the object
 * \return the index into the rune list, or -1 for no unknown runes
 */
static int object_find_unknown_rune(struct player *p, struct object *obj)
{
 size_t i, num = 0;
 int *poss_runes;
 int chosen = -1;
 if (object_runes_known(obj)) return -1;
 poss_runes = mem_zalloc(rune_max * sizeof(int));
 for (i = 0; i < rune_max; i++)
  if (object_has_rune(obj, i) && !player_knows_rune(p, i))
   poss_runes[num++] = i;
 /* Grab a random rune from among the unknowns  */
 if (num) {
  chosen = poss_runes[randint0(num)];
 }
 mem_free(poss_runes);
 return chosen;
}
/**
 * Learn a random unknown rune from an object
 *
 * \param p is the player
 * \param obj is the object
 */
void object_learn_unknown_rune(struct player *p, struct object *obj)
{
 /* Get a random unknown rune from the object */
 int i = object_find_unknown_rune(p, obj);
 /* No unknown runes */
 if (i < 0) {
  obj->known->notice |= OBJ_NOTICE_ASSESSED;
  player_know_object(player, obj);
  return;
 }
 /* Learn the rune */
 player_learn_rune(p, i, true);
}
/**
 * Learn object properties that become obvious on wielding or wearing
 *
 * \param p is the player
 * \param obj is the wielded object
 */
void object_learn_on_wield(struct player *p, struct object *obj)
{
 bitflag f[OF_SIZE], obvious_mask[OF_SIZE];
 int i, flag;
 char o_name[80];
 assert(obj->known);
 object_desc(o_name, sizeof(o_name), obj, ODESC_BASE, p);
 /* Check the worn flag */
 if (obj->known->notice & OBJ_NOTICE_WORN) {
  return;
 } else {
  obj->known->notice |= OBJ_NOTICE_WORN;
 }
 /* Worn means tried (for flavored wearables) */
 object_flavor_tried(obj);
 /* Get the obvious object flags */
 create_obj_flag_mask(obvious_mask, true, OFID_WIELD, OFT_MAX);
 /* Make sustains obvious for items with that stat bonus */
 for (i = 0; i < STAT_MAX; i++) {
  int sust = sustain_flag(i);
  if (obj->modifiers[i]) {
   of_on(obvious_mask, sust);
  }
 }
 /* Learn about obvious, previously unknown flags */
 object_flags(obj, f);
 of_inter(f, obvious_mask);
 for (flag = of_next(f, FLAG_START); flag != FLAG_END;
   flag = of_next(f, flag + 1)) {
  if (!of_has(p->obj_k->flags, flag)) {
   if (p->upkeep->playing) {
    flag_message(flag, o_name);
   }
   player_learn_rune(p, rune_index(RUNE_VAR_FLAG, flag), true);
  }
 }
 /* Learn all modifiers */
 for (i = 0; i < OBJ_MOD_MAX; i++) {
  if (obj->modifiers[i] && !p->obj_k->modifiers[i]) {
   if (p->upkeep->playing) {
    mod_message(obj, i);
   }
   player_learn_rune(p, rune_index(RUNE_VAR_MOD, i), true);
  }
 }
 /* Learn abilities from special item types */
 if (obj->ego && obj->ego->abilities) {
  struct ability *ability = obj->ego->abilities;
  while (ability) {
   msg("You have gained the ability '%s'.", ability->name);
   ability = ability->next;
  }
 }
 /* Learn abilities from artefacts */
 if (obj->artifact && obj->artifact->abilities) {
  struct ability *ability = obj->artifact->abilities;
  while (ability) {
   msg("You have gained the ability '%s'.", ability->name);
   ability = ability->next;
  }
 }
}
/**
 * ------------------------------------------------------------------------
 * Functions for learning about equipment properties
 * These functions are for gaining object knowledge from the behaviour of
 * the player's equipment or shape
 * ------------------------------------------------------------------------ */
/**
 * Learn a given object flag on wielded items.
 *
 * \param p is the player
 * \param flag is the flag to notice
 */
void equip_learn_flag(struct player *p, int flag)
{
 int i;
 bitflag f[OF_SIZE];
 of_wipe(f);
 of_on(f, flag);
 /* No flag */
 if (!flag) return;
 /* All wielded items eligible */
 for (i = 0; i < p->body.count; i++) {
  struct object *obj = slot_object(p, i);
  if (!obj) continue;
  assert(obj->known);
  /* Does the object have the flag? */
  if (of_has(obj->flags, flag)) {
   if (!of_has(p->obj_k->flags, flag)) {
    char o_name[80];
    object_desc(o_name, sizeof(o_name), obj,
     ODESC_BASE, p);
    flag_message(flag, o_name);
    player_learn_rune(p, rune_index(RUNE_VAR_FLAG, flag), true);
   }
  } else if (!object_runes_known(obj)) {
   /* Objects not fully known yet get marked as having had a chance
			 * to display the flag */
   of_on(obj->known->flags, flag);
  }
 }
}
/**
 * Learn the elemental resistance properties on wielded items.
 *
 * \param p is the player
 * \param element is the element to notice
 */
void equip_learn_element(struct player *p, int element)
{
 int i;
 /* Invalid element or element already known */
 if (element < 0 || element >= ELEM_MAX) return;
 if (p->obj_k->el_info[element].res_level == 1) return;
 /* All wielded items eligible */
 for (i = 0; i < p->body.count; i++) {
  struct object *obj = slot_object(p, i);
  if (!obj) continue;
  assert(obj->known);
  /* Does the object affect the player's resistance to the element? */
  if (obj->el_info[element].res_level != 0) {
   char o_name[80];
   object_desc(o_name, sizeof(o_name), obj, ODESC_BASE, p);
   /* Message */
   msg("Your %s glows.", o_name);
   /* Learn the element properties */
   player_learn_rune(p, rune_index(RUNE_VAR_RESIST, element), true);
  } else if (!object_runes_known(obj)) {
   /* Objects not fully known yet get marked as having had a chance
			 * to display the element */
   obj->known->el_info[element].res_level = 1;
   obj->known->el_info[element].flags = obj->el_info[element].flags;
  }
 }
}
/**
 * Learn things that would be noticed in time.
 *
 * \param p is the player
 */
void equip_learn_after_time(struct player *p)
{
 int i, flag;
 bitflag f[OF_SIZE], timed_mask[OF_SIZE];
 /* Get the timed flags */
 create_obj_flag_mask(timed_mask, true, OFID_TIMED, OFT_MAX);
 /* Get the unknown timed flags, and return if there are none */
 object_flags(p->obj_k, f);
 of_negate(f);
 of_inter(timed_mask, f);
 if (of_is_empty(timed_mask)) return;
 /* All wielded items eligible */
 for (i = 0; i < p->body.count; i++) {
  char o_name[80];
  struct object *obj = slot_object(p, i);
  if (!obj) continue;
  assert(obj->known);
  object_desc(o_name, sizeof(o_name), obj, ODESC_BASE, p);
  /* Get the unknown timed flags for this object */
  object_flags(obj, f);
  of_inter(f, timed_mask);
  /* Attempt to learn every flag */
  for (flag = of_next(f, FLAG_START); flag != FLAG_END;
    flag = of_next(f, flag + 1)) {
   if (!of_has(p->obj_k->flags, flag)) {
    flag_message(flag, o_name);
   }
   player_learn_rune(p, rune_index(RUNE_VAR_FLAG, flag), true);
  }
  if (!object_runes_known(obj)) {
   /* Objects not fully known yet get marked as having had a chance
			 * to display all the timed flags */
   of_union(obj->known->flags, timed_mask);
  }
 }
}
/**
 * ------------------------------------------------------------------------
 * Object kind functions
 * These deal with knowledge of an object's kind
 * ------------------------------------------------------------------------ */
/**
 * Checks whether an object counts as "known" due to EASY_KNOW status
 *
 * \param obj is the object
 */
bool easy_know(const struct object *obj)
{
 assert(obj->kind);
 if (obj->kind->aware && kf_has(obj->kind->kind_flags, KF_EASY_KNOW))
  return true;
 else
  return false;
}
/**
 * Checks whether the player is aware of the object's flavour
 *
 * \param obj is the object
 */
bool object_flavor_is_aware(const struct object *obj)
{
 assert(obj->kind);
 return obj->kind->aware;
}
/**
 * Checks whether the player has tried to use other objects of the same kind
 *
 * \param obj is the object
 */
bool object_flavor_was_tried(const struct object *obj)
{
 assert(obj->kind);
 return obj->kind->tried;
}
/**
 * Mark an object's flavour as as one the player is aware of.
 *
 * \param p is the player becoming aware of the flavor
 * \param obj is the object whose flavour should be marked as aware
 */
void object_flavor_aware(struct player *p, struct object *obj)
{
 int y, x;
 int new_exp = 100;
 if (obj->kind->aware) return;
 obj->kind->aware = true;
 /* Quit if no dungeon yet */
 if (!cave) return;
 /* Gain experience for identification */
 player_exp_gain(p, new_exp);
 p->ident_exp += new_exp;
 update_player_object_knowledge(p);
 p->upkeep->notice |= PN_IGNORE;
 /* Some objects change tile on awareness, so update display for all
	 * floor objects of this kind */
 for (y = 1; y < cave->height; y++) {
  for (x = 1; x < cave->width; x++) {
   bool light = false;
   const struct object *floor_obj;
   struct loc grid = loc(x, y);
   for (floor_obj = square_object(cave, grid); floor_obj;
     floor_obj = floor_obj->next)
    if (floor_obj->kind == obj->kind) {
     light = true;
     break;
    }
   if (light) square_light_spot(cave, grid);
  }
 }
}
/**
 * Mark an object's flavour as tried.
 *
 * \param obj is the object whose flavour should be marked
 */
void object_flavor_tried(struct object *obj)
{
 assert(obj);
 assert(obj->kind);
 /* Don't mark artifacts as tried */
 if (obj->kind->kidx >= z_info->ordinary_kind_max) {
  return;
 }
 obj->kind->tried = true;
}
/**
 * ------------------------------------------------------------------------
 * Object value
 * ------------------------------------------------------------------------ */
/**
 * Return the "value" of an "unknown" item
 * Make a guess at the value of non-aware items
 */
static int object_value_base(const struct object *obj)
{
 int value = 0;
 struct object_kind *kind = obj->kind;
 /* Use template cost for aware objects */
 if (object_flavor_is_aware(obj)) {
  /* Give credit for hit bonus */
  value += (obj->att - kind->att) * 100;
  /* Give credit for evasion bonus */
  value += (obj->evn - kind->evn) * 100;
  /* Give credit for sides bonus */
  value += (obj->ps - kind->ps) * obj->pd * 100;
  /* Give credit for dice bonus */
  value += (obj->pd - kind->pd) * obj->ps * 100;
  /* Give credit for sides bonus */
  value += (obj->ds - kind->ds) * 100;
  /* Give credit for dice bonus */
  value += (obj->dd - kind->dd) * obj->ds * 100;
  /* Arrows are worth less since they are perishable */
  if (tval_is_ammo(obj)) value /= 10;
  /* Add in the base cost from the template */
  value += kind->cost;
 } else {
  /* Analyze the type */
  switch (obj->tval) {
   /* Un-aware Food */
   case TV_FOOD: return 5;
   /* Un-aware Potions */
   case TV_POTION: return 20;
   /* Un-aware Staffs */
   case TV_STAFF: return 70;
   /* Un-aware Rods */
   case TV_HORN: return 90;
   /* Un-aware Rings */
   case TV_RING: return 45;
   /* Un-aware Amulets */
   case TV_AMULET: return 45;
  }
 }
 return value;
}
/**
 * Return the "real" price of a "known" item, not including discounts.
 *
 * Wand and staffs get cost for each charge.
 *
 * Armor is worth an extra 100 gold per bonus point to armor class.
 *
 * Weapons are worth an extra 100 gold per bonus point (AC,TH,TD).
 *
 * Missiles are only worth 5 gold per bonus point, since they
 * usually appear in groups of 20, and we want the player to get
 * the same amount of cash for any "equivalent" item.  Note that
 * missiles never have any of the "pval" flags, and in fact, they
 * only have a few of the available flags, primarily of the "slay"
 * and "brand" and "ignore" variety.
 *
 * Weapons with negative hit+damage bonuses are worthless.
 *
 * Every wearable item with a "pval" bonus is worth extra (see below).
 */
static int object_value_real(const struct object *obj)
{
 int value, i;
 struct object_kind *kind = obj->kind;
 /* Hack -- "worthless" items */
 if (!kind->cost) return 0;
 /* Base cost */
 value = kind->cost;
 /* Artefact */
 if (obj->known->artifact) {
  const struct artifact *art = obj->artifact;
  /* Hack -- "worthless" artefacts */
  if (!art->cost) return 0;
  /* Hack -- Use the artefact cost instead */
  value = art->cost;
 } else if (obj->known->ego) {
  /* Ego-Item */
  struct ego_item *ego = obj->ego;
  /* Hack -- "worthless" special items */
  if (!ego->cost) return 0;
  /* Hack -- Reward the special item with a bonus */
  value += ego->cost;
 }
 /* Analyze modifiers and speed */
 switch (obj->tval) {
  case TV_ARROW:
  case TV_BOW:
  case TV_DIGGING:
  case TV_HAFTED:
  case TV_POLEARM:
  case TV_SWORD:
  case TV_BOOTS:
  case TV_GLOVES:
  case TV_HELM:
  case TV_CROWN:
  case TV_SHIELD:
  case TV_CLOAK:
  case TV_SOFT_ARMOR:
  case TV_MAIL:
  case TV_LIGHT:
  case TV_AMULET:
  case TV_RING: {
   for (i = 0; i < OBJ_MOD_MAX; i++) {
    if (i < STAT_MAX) {
     value += (obj->known->modifiers[i] * 300);
    } else if (i < SKILL_MAX) {
     if (obj->known->modifiers[i] < 0) {
      return 0;
     } else {
      value += (obj->known->modifiers[i] * 100);
     }
    } else if (i == OBJ_MOD_TUNNEL) {
     if (obj->known->modifiers[i] < 0) {
      return 0;
     } else {
      value += (obj->known->modifiers[i] * 50);
     }
    }
   }
   /* Give credit for speed bonus */
   if (of_has(obj->known->flags, OF_SPEED)) value += 1000;
   break;
  }
 }
 /* Analyze the item */
 switch (obj->tval) {
  /* Staffs */
  case TV_STAFF:
  {
   /* Pay extra for charges, depending on standard number of
			 * charges.  Handle new-style wands correctly.
			 */
   value += ((value / 20) * (obj->known->pval / obj->known->number));
   /* Done */
   break;
  }
  /* Rings/Amulets */
  case TV_RING:
  case TV_AMULET: {
   /* Hack -- negative bonuses are bad */
   if (obj->known->att < 0) return 0;
   if (obj->known->evn < 0) return 0;
   /* Give credit for bonuses */
   value += ((obj->known->att + obj->known->evn + obj->known->ps)
       * 100);
   /* Done */
   break;
  }
  /* Armor */
  case TV_BOOTS:
  case TV_GLOVES:
  case TV_CLOAK:
  case TV_CROWN:
  case TV_HELM:
  case TV_SHIELD:
  case TV_SOFT_ARMOR:
  case TV_MAIL: {
   /* Give credit for hit bonus */
   value += ((obj->known->att - kind->att) * 100);
   /* Give credit for evasion bonus */
   value += ((obj->known->evn - kind->evn) * 100);
   /* Give credit for sides bonus */
   value += ((obj->known->ps - kind->ps) * obj->pd * 50);
   /* Give credit for dice bonus */
   value += ((obj->known->pd - kind->pd) * obj->ps * 50);
   /* Done */
   break;
  }
  /* Bows/Weapons */
  case TV_BOW:
  case TV_DIGGING:
  case TV_HAFTED:
  case TV_SWORD:
  case TV_POLEARM: {
   /* Give credit for hit bonus */
   value += ((obj->known->att - kind->att) * 100);
   /* Give credit for evasion bonus */
   value += ((obj->known->evn - kind->evn) * 100);
   /* Give credit for sides bonus */
   value += ((obj->known->ds - kind->ds) * obj->known->dd * 51);
   /* Give credit for dice bonus */
   value += ((obj->known->dd - kind->dd) * obj->known->ds * 51);
   /* Done */
   break;
  }
  /* Arrows */
  case TV_ARROW: {
   /* Give credit for hit bonus */
   value += ((obj->known->att - kind->att) * 10);
   /* Done */
   break;
  }
 }
 /* No negative value */
 if (value < 0) value = 0;
 /* Return the value */
 return value;
}
/**
 * Return the price of an item including plusses (and charges).
 *
 * This function returns the "value" of the given item (qty one).
 *
 * Never notice "unknown" bonuses or properties, including "curses",
 * since that would give the player information he did not have.
 */
int object_value(const struct object *obj)
{
 int value;
 /* Known items acquire the actual value, unknown items the base value */
 if (obj->known) {
  /* Real value (see above) */
  value = object_value_real(obj);
 } else {
  /* Base value (see above) */
  value = object_value_base(obj);
 }
 /* Return the final value */
 return value;
}
/**
 * \file obj-list.c
 * \brief Object list construction.
 *
 * Copyright (c) 1997-2007 Ben Harrison, James E. Wilson, Robert A. Koeneke
 * Copyright (c) 2013 Ben Semmler
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Allocate a new object list.
 */
object_list_t *object_list_new(void)
{
 object_list_t *list = mem_zalloc(sizeof(object_list_t));
 size_t size = MAX_ITEMLIST;
 if (list == NULL)
  return NULL;
 list->entries = mem_zalloc(size * sizeof(object_list_entry_t));
 if (list->entries == NULL) {
  mem_free(list);
  return NULL;
 }
 list->entries_size = size;
 return list;
}
/**
 * Free an object list.
 */
void object_list_free(object_list_t *list)
{
 if (list == NULL)
  return;
 if (list->entries != NULL) {
  mem_free(list->entries);
  list->entries = NULL;
 }
 mem_free(list);
}
/**
 * Share object list instance.
 */
static object_list_t *object_list_subwindow = NULL;
/**
 * Initialize the object list module.
 */
void object_list_init(void)
{
 object_list_subwindow = NULL;
}
/**
 * Tear down the object list module.
 */
void object_list_finalize(void)
{
 object_list_free(object_list_subwindow);
}
/**
 * Return a common object list instance.
 */
object_list_t *object_list_shared_instance(void)
{
 if (object_list_subwindow == NULL) {
  object_list_subwindow = object_list_new();
 }
 return object_list_subwindow;
}
/**
 * Return true if the list needs to be updated. Usually this is each turn.
 */
static bool object_list_needs_update(const object_list_t *list)
{
 if (list == NULL || list->entries == NULL)
  return false;
 /* For now, always update when requested. */
 return true;
}
/**
 * Zero out the contents of an object list.
 */
void object_list_reset(object_list_t *list)
{
 if (list == NULL || list->entries == NULL)
  return;
 if (!object_list_needs_update(list))
  return;
 memset(list->entries, 0, list->entries_size * sizeof(object_list_entry_t));
 memset(list->total_entries, 0, OBJECT_LIST_SECTION_MAX * sizeof(uint16_t));
 memset(list->total_objects, 0, OBJECT_LIST_SECTION_MAX * sizeof(uint16_t));
 list->distinct_entries = 0;
 list->creation_turn = 0;
 list->sorted = false;
}
/**
 * Return true if the object should be omitted from the object list.
 */
static bool object_list_should_ignore_object(const struct player *p,
  const struct object *obj)
{
 assert(obj->kind);
 if (ignore_known_item_ok(p, obj))
  return true;
 return false;
}
/**
 * Collect object information from the current cave.
 */
void object_list_collect(object_list_t *list)
{
 int i;
 struct loc pgrid = player->grid;
 if (list == NULL || list->entries == NULL)
  return;
 if (!object_list_needs_update(list))
  return;
 /* Scan each object in the dungeon. */
 for (i = 1; i < player->cave->obj_max; i++) {
  object_list_entry_t *entry = NULL;
  int entry_index;
  int current_distance;
  int entry_distance;
  struct loc grid;
  int field;
  bool los = false;
  struct object *obj = player->cave->objects[i];
  /* Skip unfilled entries, unknown objects and monster-held objects */
  if (!obj) continue;
  if (loc_is_zero(obj->grid)) {
   continue;
  } else {
   grid = obj->grid;
  }
  /* Determine which section of the list the object entry is in */
  los = projectable(cave, pgrid, grid, PROJECT_NONE) ||
   loc_eq(grid, pgrid);
  field = (los) ? OBJECT_LIST_SECTION_LOS : OBJECT_LIST_SECTION_NO_LOS;
  if (object_list_should_ignore_object(player, obj)) continue;
  /* Find or add a list entry. */
  for (entry_index = 0; entry_index < (int)list->entries_size;
    entry_index++) {
   int j;
   struct object *list_obj = list->entries[entry_index].object;
   if (list_obj == NULL) {
    /* We found an empty slot, so add this object here. */
    list->entries[entry_index].object = obj;
    for (j = 0; j < OBJECT_LIST_SECTION_MAX; j++)
     list->entries[entry_index].count[j] = 0;
    list->entries[entry_index].dy = grid.y - pgrid.y;
    list->entries[entry_index].dx = grid.x - pgrid.x;
    entry = &list->entries[entry_index];
    break;
   }
  }
  if (entry == NULL)
   return;
  /* We only know the number of objects we've actually seen */
  if (obj->kind == cave->objects[obj->oidx]->kind)
   entry->count[field] += obj->number;
  else
   entry->count[field] = 1;
  /* Store the distance to the object in the stack that is
		 * closest to the player. */
  current_distance = (grid.y - pgrid.y) * (grid.y - pgrid.y) +
   (grid.x - pgrid.x) * (grid.x - pgrid.x);
  entry_distance = entry->dy * entry->dy + entry->dx * entry->dx;
  if (current_distance < entry_distance) {
   entry->dy = grid.y - pgrid.y;
   entry->dx = grid.x - pgrid.x;
  }
 }
 /* Collect totals for easier calculations of the list. */
 for (i = 0; i < (int)list->entries_size; i++) {
  if (list->entries[i].object == NULL)
   continue;
  if (list->entries[i].count[OBJECT_LIST_SECTION_LOS] > 0)
   list->total_entries[OBJECT_LIST_SECTION_LOS]++;
  if (list->entries[i].count[OBJECT_LIST_SECTION_NO_LOS] > 0)
   list->total_entries[OBJECT_LIST_SECTION_NO_LOS]++;
  list->total_objects[OBJECT_LIST_SECTION_LOS] +=
   list->entries[i].count[OBJECT_LIST_SECTION_LOS];
  list->total_objects[OBJECT_LIST_SECTION_NO_LOS] +=
   list->entries[i].count[OBJECT_LIST_SECTION_NO_LOS];
  list->distinct_entries++;
 }
 list->creation_turn = turn;
 list->sorted = false;
}
/**
 * Object distance comparator: nearest to farthest.
 */
static int object_list_distance_compare(const void *a, const void *b)
{
 const object_list_entry_t *ae = (object_list_entry_t *)a;
 const object_list_entry_t *be = (object_list_entry_t *)b;
 int a_distance = ae->dy * ae->dy + ae->dx * ae->dx;
 int b_distance = be->dy * be->dy + be->dx * be->dx;
 if (a_distance < b_distance)
  return -1;
 else if (a_distance > b_distance)
  return 1;
 return 0;
}
/**
 * Standard comparison function for the object list. Uses compare_items().
 */
int object_list_standard_compare(const void *a, const void *b)
{
 int result;
 const struct object *ao = cave->objects[(((object_list_entry_t *)a)->object)->oidx];
 const struct object *bo = cave->objects[(((object_list_entry_t *)b)->object)->oidx];
 /* If this happens, something might be wrong in the collect function. */
 if (ao == NULL || bo == NULL)
  return 1;
 result = compare_items(ao, bo);
 /* If the objects are equivalent, sort nearest to farthest. */
 if (result == 0)
  result = object_list_distance_compare(a, b);
 return result;
}
/**
 * Sort the object list with the given sort function.
 */
void object_list_sort(object_list_t *list,
       int (*compare)(const void *, const void *))
{
 size_t elements;
 if (list == NULL || list->entries == NULL)
  return;
 if (list->sorted)
  return;
 elements = list->distinct_entries;
 if (elements <= 1)
  return;
 sort(list->entries, elements, sizeof(list->entries[0]), compare);
 list->sorted = true;
}
/**
 * Return an attribute to display a particular list entry with.
 *
 * \param entry is the object list entry to display.
 * \return a term attribute for the object entry.
 */
int object_list_entry_line_attribute(const object_list_entry_t *entry)
{
 int attr;
 struct object *base_obj;
 if (entry == NULL || entry->object == NULL || entry->object->kind == NULL)
  return COLOUR_WHITE;
 base_obj = cave->objects[entry->object->oidx];
 if (base_obj->known->artifact)
  /* known artifact */
  attr = COLOUR_VIOLET;
 else if (!object_flavor_is_aware(base_obj))
  /* unaware of kind */
  attr = COLOUR_L_RED;
 else if (base_obj->kind->cost == 0)
  /* worthless */
  attr = COLOUR_SLATE;
 else
  /* default */
  attr = COLOUR_WHITE;
 return attr;
}
/**
 * Format the object name so that the prefix is right aligned to a common
 * column.
 *
 * This uses the default logic of object_desc() in order to handle flavors,
 * artifacts, vowels and so on. It was easier to do this and then use strtok()
 * to break it up than to do anything else.
 *
 * \param entry is the object list entry that has a name to be formatted.
 * \param line_buffer is the buffer to format into.
 * \param size is the size of line_buffer.
 */
void object_list_format_name(const object_list_entry_t *entry,
        char *line_buffer, size_t size)
{
 char name[80];
 const char *chunk;
 char *source;
 bool has_singular_prefix;
 bool los = false;
 int field;
 struct loc pgrid = player->grid;
 struct object *base_obj;
 struct loc grid;
 bool object_is_recognized_artifact;
 if (entry == NULL || entry->object == NULL || entry->object->kind == NULL)
  return;
 base_obj = cave->objects[entry->object->oidx];
 grid = entry->object->grid;
 object_is_recognized_artifact = object_is_known_artifact(base_obj);
 /* Hack - these don't have a prefix when there is only one, so just pad
	 * with a space. */
 switch (entry->object->kind->tval) {
  case TV_SOFT_ARMOR:
   if (object_is_recognized_artifact)
    has_singular_prefix = true;
   else if (base_obj->kind->sval == lookup_sval(TV_SOFT_ARMOR, "Robe"))
    has_singular_prefix = true;
   else
    has_singular_prefix = false;
   break;
  case TV_MAIL:
   if (object_is_recognized_artifact)
    has_singular_prefix = true;
   else
    has_singular_prefix = false;
   break;
  default:
   has_singular_prefix = true;
   break;
 }
 if (entry->object->kind != base_obj->kind)
  has_singular_prefix = true;
 /* Work out if the object is in view */
 los = projectable(cave, pgrid, grid, PROJECT_NONE) || loc_eq(grid, pgrid);
 field = los ? OBJECT_LIST_SECTION_LOS : OBJECT_LIST_SECTION_NO_LOS;
 /*
	 * Pass the accumulated number via object_desc()'s ODESC_ALTNUM
	 * mechanism:  it's in the high 16 bits of the mode.
	 */
 object_desc(name, sizeof(name), base_obj, ODESC_PREFIX | ODESC_FULL |
  ODESC_ALTNUM | (entry->count[field] << 16), player);
 /* The source string for strtok() needs to be set properly, depending on
	 * when we use it. */
 if (!has_singular_prefix && entry->count[field] == 1) {
  chunk = " ";
  source = name;
 }
 else {
  chunk = strtok(name, " ");
  source = NULL;
 }
 /* Right alight the prefix and clip. */
 strnfmt(line_buffer, size, "%3.3s ", chunk);
 /* Get the rest of the name and clip it to fit the max width. */
 chunk = strtok(source, "\0");
 my_strcat(line_buffer, chunk, size);
}
/**
 * \file obj-make.c
 * \brief Object generation functions.
 *
 * Copyright (c) 1987-2007 Angband contributors
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * ------------------------------------------------------------------------
 * Object kind allocation
 *
 * Object kind allocation is done using an allocation table (see alloc.h).
 * This table is sorted by depth.  Each line of the table contains the
 * object kind index, the object kind level, and three probabilities:
 * - prob1 is the base probability of the kind, calculated from object.txt.
 * - prob2 is calculated by get_obj_num_prep(), which decides whether an
 *         object is appropriate based on drop type; prob2 is always either
 *         prob1 or 0.
 * - prob3 is calculated by get_obj_num(), which checks whether universal
 *         restrictions apply (for example, aretfacts can only appear
 *         once); prob3 is always either prob2 or 0.
 * ------------------------------------------------------------------------ */
static int16_t alloc_kind_size = 0;
static struct alloc_entry *alloc_kind_table;
static int16_t alloc_ego_size = 0;
static struct alloc_entry *alloc_ego_table;
struct drop *drops;
/**
 * Initialize object allocation info
 */
static void alloc_init_objects(void) {
 int i;
 struct allocation *allocation;
 struct object_kind *kind;
 struct alloc_entry *table;
 int16_t *num = mem_zalloc(z_info->max_depth * sizeof(int16_t));
 int16_t *already_counted =
  mem_zalloc(z_info->max_depth * sizeof(int16_t));
 /* Size of "alloc_kind_table" */
 alloc_kind_size = 0;
 /* Scan the objects */
 for (i = 1; i < z_info->k_max - 1; i++) {
  /* Get the i'th kind */
  kind = &k_info[i];
  /* Scan allocation entries */
  allocation = kind->alloc;
  while (allocation) {
   /* Count the entries */
   alloc_kind_size++;
   /* Group by level */
   num[allocation->locale]++;
   allocation = allocation->next;
  }
 }
 /* Calculate the cumultive level totals */
 for (i = 1; i < z_info->max_depth; i++) {
  /* Group by level */
  num[i] += num[i - 1];
 }
 /* Allocate the alloc_kind_table */
 alloc_kind_table = mem_zalloc_alt(alloc_kind_size *
           sizeof(struct alloc_entry));
 /* Get the table entry */
 table = alloc_kind_table;
 /* Scan the objects */
 for (i = 1; i < z_info->k_max - 1; i++) {
  /* Get the i'th kind */
  kind = &k_info[i];
  /* Scan allocation entries */
  allocation = kind->alloc;
  while (allocation) {
   int p, lev, prev_lev_count, kind_index;
   /* Extract the base level */
   lev = allocation->locale;
   /* Extract the base probability */
   p = allocation->chance ? (100 / allocation->chance) : 0;
   /* Skip entries preceding this locale */
   prev_lev_count = (lev > 0) ? num[lev - 1] : 0;
   /* Skip entries already counted for this level */
   kind_index = prev_lev_count + already_counted[lev];
   /* Load the entry */
   table[kind_index].index = i;
   table[kind_index].level = lev;
   table[kind_index].prob1 = p;
   table[kind_index].prob2 = p;
   table[kind_index].prob3 = p;
   /* Another entry complete for this locale */
   already_counted[lev]++;
   allocation = allocation->next;
  }
 }
 mem_free(already_counted);
 mem_free(num);
}
/**
 * Initialize ego-item allocation info
 *
 * The ego allocation probabilities table (alloc_ego_table) is sorted in
 * order of minimum depth.  Precisely why, I'm not sure!  But that is what
 * the code below is doing with the arrays 'num' and 'level_total'. -AS
 */
static void alloc_init_egos(void) {
 int *num = mem_zalloc((z_info->max_obj_depth + 1) * sizeof(int));
 int *level_total = mem_zalloc((z_info->max_obj_depth + 1) * sizeof(int));
 int i;
 for (i = 0; i < z_info->e_max; i++) {
  struct ego_item *ego = &e_info[i];
  if (ego->rarity) {
   /* Count the entries */
   alloc_ego_size++;
   /* Group by level */
   num[ego->level]++;
  }
 }
 /* Collect the level indexes */
 for (i = 1; i < z_info->max_obj_depth; i++)
  num[i] += num[i - 1];
 /* Allocate the alloc_ego_table */
 alloc_ego_table = mem_zalloc(alloc_ego_size * sizeof(struct alloc_entry));
 /* Scan the ego-items */
 for (i = 0; i < z_info->e_max; i++) {
  struct ego_item *ego = &e_info[i];
  /* Count valid pairs */
  if (ego->rarity) {
   int min_level = ego->level;
   /* Skip entries preceding our locale */
   int y = (min_level > 0) ? num[min_level - 1] : 0;
   /* Skip previous entries at this locale */
   int z = y + level_total[min_level];
   /* Load the entry */
   alloc_ego_table[z].index = i;
   alloc_ego_table[z].level = min_level; /* Unused */
   alloc_ego_table[z].prob1 = ego->rarity;
   alloc_ego_table[z].prob2 = ego->rarity;
   alloc_ego_table[z].prob3 = ego->rarity;
   /* Another entry complete for this locale */
   level_total[min_level]++;
  }
 }
 mem_free(level_total);
 mem_free(num);
}
static void init_obj_make(void) {
 alloc_init_objects();
 alloc_init_egos();
}
static void cleanup_obj_make(void) {
 mem_free(alloc_ego_table);
 mem_free_alt(alloc_kind_table);
}
/**
 * ------------------------------------------------------------------------
 * Make an ego item
 * ------------------------------------------------------------------------ */
/**
 * Select an ego-item that fits the object's tval and sval.
 */
static struct ego_item *ego_find_random(struct object *obj, int level,
          bool only_good)
{
 int i;
 long total = 0L;
 struct alloc_entry *table = alloc_ego_table;
 /* Go through all possible ego items and find ones which fit this item */
 for (i = 0; i < alloc_ego_size; i++) {
  struct ego_item *ego = &e_info[table[i].index];
  struct poss_item *poss;
  /* Reset any previous probability of this type being picked */
  table[i].prob3 = 0;
  /* Objects are sorted by depth */
  if (table[i].level > level) continue;
  /* Some special items can't be generated too deep */
  if ((ego->alloc_max > 0) && (player->depth > ego->alloc_max)) continue;
  /* If we force fine/special, don't create cursed */
  if (only_good && of_has(ego->flags, OF_CURSED)) continue;
  /* If we force fine/special, don't create useless */
  if (only_good && (ego->cost == 0)) continue;
  /* Test if this is a legal special item type for this object */
  for (poss = ego->poss_items; poss; poss = poss->next)
   if (poss->kidx == obj->kind->kidx) {
    table[i].prob3 = table[i].prob2;
    break;
   }
  /* Total */
  total += table[i].prob3;
 }
 if (total) {
  long value = randint0(total);
  for (i = 0; i < alloc_ego_size; i++) {
   /* Found the entry */
   if (value < table[i].prob3) {
    return &e_info[table[i].index];
   } else {
    /* Decrement */
    value = value - table[i].prob3;
   }
  }
 }
 return NULL;
}
/**
 * Apply generation magic to an ego-item.
 */
void ego_apply_magic(struct object *obj, bool smithing)
{
 int i;
 struct ego_item *ego = obj->ego;
 struct ability *ability = ego->abilities;
 /* Add the abilities */
 while (ability) {
  add_ability(&obj->abilities, ability);
  ability = ability->next;
 }
 /* Bonuses apply differently for smithed objects */
 if (smithing) {
  bool flip_sign;
  /* Apply extra ego bonuses */
  if (ego->att) obj->att += 1;
  if (ego->evn) obj->evn += 1;
  if (ego->dd) obj->dd += 1;
  if (ego->ds) obj->ds += 1;
  if (ego->pd) obj->pd += 1;
  if (ego->ps) obj->ps += 1;
  obj->pval = extract_kind_pval(obj->kind, AVERAGE, &flip_sign);
  if (ego->pval > 0) {
   obj->pval += (of_has(ego->flags, OF_CURSED)) ? -1 : 1;
  }
  /*
		 * Mark any modifiers that are changed by the ego or can be
		 * non-zero in the base object with a non-zero value so that
		 * smithing knows which modifiers must change when the special
		 * bonus is changed.  The value used will be negative when
		 * smithing should set that modifier to the value of the
		 * special bonus with its sign flipped.
		 */
  for (i = 0; i < OBJ_MOD_MAX; i++) {
   int min_m = randcalc(obj->kind->modifiers[i],
    0, MINIMISE);
   int max_m = randcalc(obj->kind->modifiers[i],
    z_info->dun_depth, MAXIMISE);
   if (min_m == SPECIAL_VALUE) {
    min_m = randcalc(obj->kind->special1,
     0, MINIMISE);
    if (!min_m && obj->kind->special2) {
     min_m = obj->kind->special2;
    }
   }
   if (max_m == SPECIAL_VALUE) {
    max_m = randcalc(obj->kind->special1,
     z_info->dun_depth, MAXIMISE);
    if (!max_m && obj->kind->special2) {
     max_m = obj->kind->special2;
    }
   }
   if (min_m || max_m) {
    if (min_m >= 0) {
     obj->modifiers[i] = MAX(1, obj->pval);
    } else if (max_m > 0) {
     if (obj->pval) {
      obj->modifiers[i] =
       (max_m >= -min_m) ?
       obj->pval : -obj->pval;
     } else {
      obj->modifiers[i] =
       (max_m >= -min_m) ?
       1 : -1;
     }
    } else {
     obj->modifiers[i] = MIN(-1, -obj->pval);
    }
    if (flip_sign) {
     obj->modifiers[i] *= -1;
    }
   } else if (ego->modifiers[i]) {
    obj->modifiers[i] = (ego->modifiers[i] > 0) ?
     MAX(1, obj->pval) :
     MIN(-1, -obj->pval);
    if (flip_sign) {
     obj->modifiers[i] *= -1;
    }
   }
  }
 } else {
  /* Apply extra ego bonuses */
  if (ego->att) obj->att += randint1(ego->att);
  if (ego->evn) obj->evn += randint1(ego->evn);
  if (ego->dd) obj->dd += randint1(ego->dd);
  if (ego->ds) obj->ds += randint1(ego->ds);
  if (ego->pd) obj->pd += randint1(ego->pd);
  if (ego->ps) obj->ps += randint1(ego->ps);
  /*
		 * Change any modifiers that could be non-zero in the kind
		 * or are affected by the ego.  Note that if the kind allows
		 * a range of values for a modifier that variation will
		 * be suppressed by applying an ego that adjusts modifiers.
		 * That is to mimic Sil's behavior where all non-zero modifiers
		 * are either -pval or +pval where pval is what Sil stores in
		 * the object's pval field.
		 */
  if (ego->pval > 0) {
   bool flip_sign;
   int pval = extract_kind_pval(obj->kind, AVERAGE,
    &flip_sign);
   if (of_has(ego->flags, OF_CURSED)) {
    pval -= randint1(ego->pval);
   } else {
    pval += randint1(ego->pval);
   }
   for (i = 0; i < OBJ_MOD_MAX; i++) {
    int min_m = randcalc(obj->kind->modifiers[i],
     0, MINIMISE);
    int max_m = randcalc(obj->kind->modifiers[i],
     z_info->dun_depth, MAXIMISE);
    if (min_m == SPECIAL_VALUE) {
     min_m = randcalc(obj->kind->special1,
      0, MINIMISE);
     if (!min_m && obj->kind->special2) {
      min_m = obj->kind->special2;
     }
    }
    if (max_m == SPECIAL_VALUE) {
     max_m = randcalc(obj->kind->special1,
      z_info->dun_depth, MAXIMISE);
     if (!max_m && obj->kind->special2) {
      max_m = obj->kind->special2;
     }
    }
    if (min_m || max_m) {
     if (min_m >= 0) {
      obj->modifiers[i] = pval;
     } else if (max_m > 0) {
      obj->modifiers[i] =
       (max_m >= -min_m) ?
       pval : -pval;
     } else {
      obj->modifiers[i] = -pval;
     }
     if (flip_sign) {
      obj->modifiers[i] *= -1;
     }
    } else if (ego->modifiers[i]) {
     obj->modifiers[i] = (ego->modifiers[i]
      > 0) ? pval : -pval;
     if (flip_sign) {
      obj->modifiers[i] *= -1;
     }
    }
   }
  }
 }
 /* Apply flags */
 of_union(obj->flags, ego->flags);
 /* Add slays, brands and curses */
 copy_slays(&obj->slays, ego->slays);
 copy_brands(&obj->brands, ego->brands);
 /* Add resists */
 for (i = 0; i < ELEM_MAX; i++) {
  /* Use the larger of ego resist level if it's notable */
  if (ego->el_info[i].res_level != 0) {
   obj->el_info[i].res_level = ego->el_info[i].res_level;
  }
  /* Union of flags so as to know when ignoring is notable */
  obj->el_info[i].flags |= ego->el_info[i].flags;
 }
}
/**
 * Try to find an ego-item for an object, setting obj->ego if successful and
 * applying various bonuses.
 */
static bool make_special_item(struct object *obj, int level, bool only_good)
{
 /* Cannot further improve artifacts or ego items */
 if (obj->artifact || obj->ego) return false;
 /* Occasionally boost the generation level of an item */
 if (level > 0 && one_in_(z_info->great_ego)) {
  /* Usually choose a deeper depth, weighted towards the current depth */
  if (level < z_info->dun_depth) {
   int level1 = rand_range(level + 1, z_info->dun_depth);
   int level2 = rand_range(level + 1, z_info->dun_depth);
   level = MIN(level1, level2);
  } else {
   level++;
  }
  /* Ensure valid allocation level */
  if (level >= z_info->max_obj_depth)
   level = z_info->max_obj_depth - 1;
 }
 /* Try to get a legal ego type for this item */
 obj->ego = ego_find_random(obj, level, only_good);
 /* Actually apply the ego template to the item */
 if (obj->ego) {
  ego_apply_magic(obj, false);
  return true;
 }
 return false;
}
/**
 * ------------------------------------------------------------------------
 * Make an artifact
 * ------------------------------------------------------------------------ */
/**
 * Copy artifact data to a normal object.
 */
void copy_artifact_data(struct object *obj, const struct artifact *art)
{
 int i;
 struct ability *ability = art->abilities;
 /* Extract the data */
 for (i = 0; i < OBJ_MOD_MAX; i++)
  obj->modifiers[i] = art->modifiers[i];
 obj->att = art->att;
 obj->dd = art->dd;
 obj->ds = art->ds;
 obj->evn = art->evn;
 obj->pd = art->pd;
 obj->ps = art->ps;
 obj->weight = art->weight;
 obj->pval = art->pval;
 /* Add the abilities */
 while (ability) {
  add_ability(&obj->abilities, ability);
  ability = ability->next;
 }
 of_union(obj->flags, art->flags);
 copy_slays(&obj->slays, art->slays);
 copy_brands(&obj->brands, art->brands);
 for (i = 0; i < ELEM_MAX; i++) {
  /* Use any non-zero artifact resist level */
  if (art->el_info[i].res_level != 0) {
   obj->el_info[i].res_level = art->el_info[i].res_level;
  }
  /* Union of flags so as to know when ignoring is notable */
  obj->el_info[i].flags |= art->el_info[i].flags;
 }
}
/**
 * As artefacts are generated, there is an increasing chance to fail to make
 * the next one
 */
static bool too_many_artefacts(void)
{
 int i;
 for (i = 0; i < player->num_artefacts; i++) {
  if (percent_chance(10)) return true;
 }
 return false;
}
/**
 * Mega-Hack -- Attempt to create one of the "Special Objects".
 *
 * We are only called from "make_object()"
 *
 * Note -- see "make_artifact()" and "apply_magic()".
 *
 * We *prefer* to create the special artifacts in order, but this is
 * normally outweighed by the "rarity" rolls for those artifacts.
 */
static struct object *make_artifact_special(int level)
{
 int i;
 struct object *new_obj;
 /* No artifacts, do nothing */
 if (OPT(player, birth_no_artifacts)) return NULL;
 /* As more artefacts are generated, the chance for another decreases */
 if (too_many_artefacts()) return NULL;
 /* Check the special artifacts */
 for (i = 0; i < z_info->a_max; ++i) {
  const struct artifact *art = &a_info[i];
  struct object_kind *kind = lookup_kind(art->tval, art->sval);
  /* Skip "empty" artifacts */
  if (!art->name) continue;
  /* Make sure the kind was found */
  if (!kind) continue;
  /* Skip non-special artifacts */
  if (!kf_has(kind->kind_flags, KF_INSTA_ART)) continue;
  /* Skip specified artifacts */
  if (of_has(art->flags, OF_NO_RANDOM)) continue;
  /* Cannot make an artifact twice */
  if (is_artifact_created(art)) continue;
  /* Enforce minimum "depth" (loosely) */
  if (art->level > level) {
   /* Get the "out-of-depth factor" */
   int d = (art->level - level) * 2;
   /* Roll for out-of-depth creation */
   if (randint0(d) != 0) continue;
  }
  /* Artifact "rarity roll" */
  if (!one_in_(art->rarity)) continue;
  /* Assign the template */
  new_obj = object_new();
  object_prep(new_obj, kind, art->level, RANDOMISE);
  /* Mark the item as an artifact */
  new_obj->artifact = art;
  /* Copy across all the data from the artifact struct */
  copy_artifact_data(new_obj, art);
  /* Mark the artifact as "created" */
  mark_artifact_created(art, true);
  /* Success */
  return new_obj;
 }
 /* Failure */
 return NULL;
}
/**
 * Attempt to change an object into an artifact.  If the object is already
 * set to be an artifact, use that, or otherwise use a suitable randomly-
 * selected artifact.
 *
 * This routine should only be called by "apply_magic()"
 *
 * Note -- see "make_artifact_special()" and "apply_magic()"
 */
static bool make_artifact(struct object *obj, int lev)
{
 int i;
 /* Make sure birth no artifacts isn't set */
 if (OPT(player, birth_no_artifacts)) return false;
 /* As more artefacts are generated, the chance for another decreases */
 if (too_many_artefacts()) return false;
 /* Check the artifact list (skip the "specials") */
 for (i = 0; !obj->artifact && i < z_info->a_max; i++) {
  const struct artifact *art = &a_info[i];
  struct object_kind *kind = lookup_kind(art->tval, art->sval);
  /* Skip "empty" items */
  if (!art->name) continue;
  /* Make sure the kind was found */
  if (!kind) continue;
  /* Skip special artifacts */
  if (kf_has(kind->kind_flags, KF_INSTA_ART)) continue;
  /* Skip specified artifacts */
  if (of_has(art->flags, OF_NO_RANDOM)) continue;
  /* Cannot make an artifact twice */
  if (is_artifact_created(art)) continue;
  /* Must have the correct fields */
  if (art->tval != obj->tval) continue;
  if (art->sval != obj->sval) continue;
  /* XXX XXX Enforce minimum "depth" (loosely) */
  if (art->level > lev) {
   /* Get the "out-of-depth factor" */
   int d = (art->level - lev) * 2;
   /* Roll for out-of-depth creation */
   if (randint0(d) != 0) continue;
  }
  /* We must make the "rarity roll" */
  if (!one_in_(art->rarity)) continue;
  /* Mark the item as an artifact */
  obj->artifact = art;
  /* Paranoia -- no "plural" artifacts */
  obj->number = 1;
 }
 if (obj->artifact) {
  copy_artifact_data(obj, obj->artifact);
  mark_artifact_created(obj->artifact, true);
  return true;
 }
 return false;
}
/**
 * Create a fake artifact directly from a blank object
 *
 * This function is used for describing artifacts, and for creating them for
 * debugging.
 *
 * Since this is now in no way marked as fake, we must make sure this function
 * is never used to create an actual game object
 */
bool make_fake_artifact(struct object *obj, const struct artifact *artifact)
{
 struct object_kind *kind;
 /* Don't bother with empty artifacts */
 if (!artifact->tval) return false;
 /* Get the "kind" index */
 kind = lookup_kind(artifact->tval, artifact->sval);
 if (!kind) return false;
 /* Create the artifact */
 object_prep(obj, kind, 0, MAXIMISE);
 obj->artifact = artifact;
 copy_artifact_data(obj, artifact);
 return (true);
}
/**
 * ------------------------------------------------------------------------
 * Apply magic to an item
 * ------------------------------------------------------------------------ */
/**
 * Apply magic to a weapon.
 */
static void apply_magic_weapon(struct object *obj, int level)
{
 bool boost_dam = false;
 bool boost_att = false;
 /* Arrows can only have increased attack value */
 if (tval_is_ammo(obj)) {
  obj->att += 3;
  return;
 } else {
  /* Small chance of boosting both */
  if (percent_chance(level)) {
   boost_dam = true;
   boost_att = true;
  } else if (one_in_(2)) {
   /* Otherwise 50/50 chance of dam or att */
   boost_dam = true;
  } else {
   boost_att = true;
  }
 }
 if (boost_dam) {
  obj->ds++;
 }
 if (boost_att) {
  obj->att++;
 }
}
/**
 * Apply magic to armour
 */
static void apply_magic_armour(struct object *obj, int level)
{
 bool boost_prot = false;
 bool boost_other = false;
 /* For cloaks and robes and filthy rags go for evasion only */
 if (tval_is_cloak(obj) ||
  (tval_is_body_armor(obj) &&
   (obj->sval == lookup_sval(TV_SOFT_ARMOR, "Robe") ||
    obj->sval == lookup_sval(TV_SOFT_ARMOR, "Filthy Rag")))) {
  boost_other = true;
 } else if ((obj->att >= 0) && (obj->evn >= 0)) {
  /* Otherwise if there are no penalties to fix, go for protection only */
  boost_prot = true;
 } else {
  /* Small chance of boosting both */
  if (percent_chance(level)) {
   boost_prot = true;
   boost_other = true;
  } else if (one_in_(2)) {
   /* Otherwise 50/50 chance of dam or att */
   boost_prot = true;
  } else {
   boost_other = true;
  }
 }
 if (boost_other) {
  if ((obj->att < 0) && (obj->evn < 0)) {
   if (one_in_(2)) obj->evn++;
   else obj->att++;
  } else if (obj->att < 0) {
   obj->att++;
  } else {
   obj->evn++;
  }
 }
 if (boost_prot) {
  obj->ps++;
 }
}
/**
 * Complete the "creation" of an object by applying "magic" to the item
 *
 * This includes not only rolling for random bonuses, but also putting the
 * finishing touches on special items and artefacts, giving charges to wands and
 * staffs, giving fuel to lites, and placing traps on chests.
 *
 * In particular, note that "Instant Artefacts", if "created" by an external
 * routine, must pass through this function to complete the actual creation.
 *
 * The base chance of the item being "fine" increases with the "level"
 * parameter, which is usually derived from the dungeon level, being equal
 * to (level)%.
 * The chance that the object will be "special" (special item or artefact), 
 * is also (level)%.
 * If "good" is true, then the object is guaranteed to be either "fine" or
 * "special". 
 * If "great" is true, then the object is guaranteed to be both "fine" and
 * "special".
 *
 * If "okay" is true, and the object is going to be "special", then there is
 * a chance that an artefact will be created.  This is true even if both the
 * "good" and "great" arguments are false.  Objects which have both "good" and
 * "great" flags get three extra "attempts" to become an artefact.
 *
 * Note that in the above we are using the new terminology of 'fine' and
 * 'special' where Vanilla Angband used 'good' and 'great'. A big change is
 * that these are now independent: you can have ego items that don't have
 * extra mundane bonuses (+att, +evn, +sides...)
 */
void apply_magic(struct object *obj, int lev, bool allow_artifacts, bool good,
     bool great)
{
 int i;
 bool fine = false;
 bool special = false;
 /* Maximum "level" for various things */
 lev = MIN(lev, z_info->max_depth - 1);
 /* Roll for "fine" */
 if (percent_chance(lev * 2)) fine = true;
 /* Roll for "special" */
 if (percent_chance(lev * 2)) special = true;
 /* Guarantee "fine" or "special" for "good" drops */
 if (good) {
  if (one_in_(2)) {
   fine = true;
  } else {
   special = true;
  }
 }
 /* Guarantee "fine" and "special" for "great" drops */
 if (great) {
  fine = true;
  special = true;
 }
 /* Roll for artifact creation */
 if (allow_artifacts) {
  int rolls = 0;
  /* Get 2 rolls if special */
  if (special) rolls = 2;
  /* Get 8 rolls if good and great are both set */
  if (good && great) rolls = 8;
  /* Roll for artifacts if allowed */
  for (i = 0; i < rolls; i++) {
   if (make_artifact(obj, lev)) return;
  }
 }
 /* Apply magic */
 if (tval_is_held_weapon(obj)) {
  /* Special treatment for deathblades */
  int sval = lookup_sval(TV_SWORD, "Deathblade");
  if (obj->kind == lookup_kind(TV_SWORD, sval)) {
   while (one_in_(2)) obj->att++;
  } else {
   /* Deal with special items */
   if (special && !make_special_item(obj, lev, good || great)) {
    fine = true;
   }
   /* Deal with fine items */
   if (fine) {
    apply_magic_weapon(obj, lev);
   }
   /* Deal with throwing items */
   if (of_has(obj->flags, OF_THROWING)) {
    /* Throwing items always have typical weight for stacking */
    obj->weight = obj->kind->weight;
    /* And often come in multiples */
    if (one_in_(2)) {
     obj->number = rand_range(2, 5);
    }
   }
  }
 } else if (tval_is_ammo(obj)) {
  /* Note that arrows can't be both fine and special */
  if (special) {
   (void) make_special_item(obj, lev, good || great);
   if (obj->number > 1) obj->number /= 2;
  } else if (fine) {
   apply_magic_weapon(obj, lev);
   if (obj->number > 1) obj->number /= 2;
  }
 } else if (tval_is_armor(obj)) {
  /* Deal with special items */
  if (special && !make_special_item(obj, lev, good || great)) {
   fine = true;
  }
  /* Deal with fine items */
  if (fine) {
   apply_magic_armour(obj, lev);
  }
 } else if (tval_is_jewelry(obj)) {
  /* For jewellery, some negative values mean cursed and broken */
  if ((obj->att < 0) || (obj->evn < 0)) {
   of_on(obj->flags, OF_CURSED);
  }
  for (i = 0; i < OBJ_MOD_MAX; i++) {
   if (obj->modifiers[i] < 0) {
    of_on(obj->flags, OF_CURSED);
   }
  }
 } else if (tval_is_light(obj)) {
  if (special) {
   (void) make_special_item(obj, lev, good || great);
  }
 } else if (tval_is_chest(obj)) {
  /* Set chest level */
  obj->pval = lev;
  if (fine) obj->pval += 2;
  if (special) obj->pval += 2;
  obj->pval = MAX(1, MIN(obj->pval, 25));
 }
}
/**
 * ------------------------------------------------------------------------
 * Generate a random object
 * ------------------------------------------------------------------------ */
/**
 * Evaluate the special value of an object kind.
 *
 * Special values are a stored random value for the case where the kind
 * almost always just needs an integer.
 */
static int eval_special_value(struct object_kind *kind, int lev)
{
 int val = randcalc(kind->special1, lev, RANDOMISE);
 if (!val && (kind->special2 != 0)) {
  val = kind->special2;
 }
 return val;
}
/**
 * Wipe an object clean and make it a standard object of the specified kind.
 */
void object_prep(struct object *obj, struct object_kind *k, int lev,
     aspect rand_aspect)
{
 int i;
 struct ability *ability = k->abilities;
 /* Clean slate */
 memset(obj, 0, sizeof(*obj));
 /* Assign the kind and copy across data */
 obj->kind = k;
 obj->image_kind = &k_info[randint0(z_info->k_max)];
 obj->tval = k->tval;
 obj->sval = k->sval;
 if (k->att == SPECIAL_VALUE) {
  obj->att = eval_special_value(k, lev);
 } else {
  obj->att = k->att;
 }
 obj->dd = k->dd;
 obj->ds = k->ds;
 if (k->evn == SPECIAL_VALUE) {
  obj->evn = eval_special_value(k, lev);
 } else {
  obj->evn = k->evn;
 }
 obj->pd = k->pd;
 if (k->ps == SPECIAL_VALUE) {
  obj->ps = eval_special_value(k, lev);
 } else {
  obj->ps = k->ps;
 }
 /* Exact weight for most items, approximate weight for weapons and armour */
 if ((tval_is_weapon(obj) || tval_is_armor(obj)) && !tval_is_ammo(obj)) {
  obj->weight = k->weight;
  switch (rand_aspect) {
   case EXTREMIFY:
   case MINIMISE: {
    while (obj->weight * 2 > k->weight * 3) obj->weight -= 5;
    break;
   }
   case AVERAGE: {
    break;
   }
   case MAXIMISE: {
    while (obj->weight * 3 < k->weight * 2) obj->weight += 5;
    break;
   }
   case RANDOMISE: {
    obj->weight = Rand_normal(k->weight, k->weight / 6 + 1);
    /* Round to the nearest multiple of 0.5 lb */
    obj->weight = (obj->weight * 2 + 9) / 10;
    obj->weight *= 5;
    /* Restrict weight to within [2/3, 3/2] of the standard */
    while (obj->weight * 3 < k->weight * 2) obj->weight += 5;
    while (obj->weight * 2 > k->weight * 3) obj->weight -= 5;
    break;
   }
   default: {
    obj->weight = k->weight;
   }
  }
 } else {
  obj->weight = k->weight;
 }
 /* Default number */
 obj->number = 1;
 /* Copy flags */
 of_copy(obj->flags, k->base->flags);
 of_copy(obj->flags, k->flags);
 /* Assign charges (staves only) */
 if (tval_can_have_charges(obj))
  obj->pval = randcalc(k->charge, lev, rand_aspect);
 /* Default fuel, light */
 if (tval_is_light(obj)) {
  if (of_has(obj->flags, OF_BURNS_OUT)) {
   if (one_in_(3) && character_generated) {
    obj->timeout = rand_range(500, z_info->default_torch);
   } else {
    obj->timeout = z_info->default_torch;
   }
  } else if (of_has(obj->flags, OF_TAKES_FUEL)) {
   if (one_in_(3)) {
    obj->timeout = rand_range(500, z_info->default_lamp);
   } else {
    obj->timeout = z_info->default_lamp;
   }
  }
  obj->pval = k->pval;
 }
 /* Assign pval for oil */
 if (tval_is_fuel(obj))
  obj->pval = k->pval;
 /* Assign modifiers */
 for (i = 0; i < OBJ_MOD_MAX; i++) {
  obj->modifiers[i] = randcalc(k->modifiers[i], lev, rand_aspect);
  if (obj->modifiers[i] == SPECIAL_VALUE) {
   obj->modifiers[i] = eval_special_value(k, lev);
  }
 }
 /* Default slays, brands and curses */
 copy_slays(&obj->slays, k->slays);
 copy_brands(&obj->brands, k->brands);
 /* Default resists */
 for (i = 0; i < ELEM_MAX; i++) {
  obj->el_info[i].res_level = k->el_info[i].res_level;
  obj->el_info[i].flags = k->el_info[i].flags;
  obj->el_info[i].flags |= k->base->el_info[i].flags;
 }
 /* Add the abilities */
 while (ability) {
  add_ability(&obj->abilities, ability);
  ability = ability->next;
 }
}
/**
 * Lookup a drop type by name.
 * This function fails gracefully; if the drop type is incorrect, it returns
 * NULL, which means no drop restrictions will be enforced.
 */
struct drop *lookup_drop(const char *name)
{
 int i;
 for (i = 0; i < z_info->drop_max; i++) {
  struct drop *drop = &drops[i];
  if (streq(name, drop->name)) return drop;
 }
 return NULL;
}
/**
 * Verify a drop type
 */
static bool drop_is(struct drop *drop, const char *name)
{
 return streq(name, drop->name);
}
/**
 * Apply a drop restriction to the object allocation table.
 * This way, we can use get_obj_num() to get a level-appropriate object of
 * the specified drop type.
 */
static void get_obj_num_prep(struct drop *drop)
{
 int i;
 /* Scan the allocation table */
 for (i = 0; i < alloc_kind_size; i++) {
  struct alloc_entry *entry = &alloc_kind_table[i];
  /* Check the restriction, if any */
  if (drop) {
   struct poss_item *item;
   if (drop->poss) {
    /*
				 * Unless determined otherwise, this object is
				 * not included.
				 */
    entry->prob2 = 0;
    item = drop->poss;
    while (item) {
     if ((int) item->kidx == entry->index) {
      /* Accept this object */
      entry->prob2 = entry->prob1;
      break;
     }
     item = item->next;
    }
   } else if (drop->imposs) {
    /*
				 * Unless determined otherwise, this object is
				 * included.
				 */
    entry->prob2 = entry->prob1;
    item = drop->imposs;
    while (item) {
     if ((int) item->kidx == entry->index) {
      /* Do not use this object */
      entry->prob2 = 0;
      break;
     }
     item = item->next;
    }
   } else {
    quit("Invalid object drop type!");
   }
  } else {
   /* Accept this object */
   entry->prob2 = entry->prob1;
  }
 }
}
/**
 * Choose an object kind given a dungeon level to choose it for.
 */
struct object_kind *get_obj_num(int level)
{
 int i, j, p;
 long total = 0, value;
 struct alloc_entry *table = alloc_kind_table;
 /* Occasional level boost */
 if ((level > 0) && one_in_(z_info->great_obj)) {
  /* Mostly choose a deeper depth, weighted towards the current depth */
  if (level < z_info->max_depth) {
   int x = rand_range(level + 1, z_info->max_depth);
   int y = rand_range(level + 1, z_info->max_depth);
   level = MIN(x, y);
  } else {
   /* But if it was already very deep, just increment it */
   level++;
  }
 }
 /* Paranoia */
 level = MIN(level, z_info->max_obj_depth);
 level = MAX(level, 0);
 /* Process probabilities */
 for (i = 0; i < alloc_kind_size; i++) {
  /* Objects are sorted by depth */
  if (table[i].level > level) break;
  /* Default */
  table[i].prob3 = 0;
  /* Accept */
  table[i].prob3 = table[i].prob2;
  /* Total */
  total += table[i].prob3;
 }
 /* No legal objects */
 if (total <= 0) return NULL;
 /* Pick an object */
 value = randint0(total);
 /* Find the object */
 for (i = 0; i < alloc_kind_size; i++) {
  /* Found the entry */
  if (value < table[i].prob3) break;
  /* Decrement */
  value = value - table[i].prob3;
 }
 /* Power boost */
 p = randint0(100);
 /* Try for a "better" object once (50%) or twice (10%) */
 if (p < 60) {
  /* Save old */
  j = i;
  /* Pick an object */
  value = randint0(total);
  /* Find the object */
  for (i = 0; i < alloc_kind_size; i++) {
   /* Found the entry */
   if (value < table[i].prob3) break;
   /* Decrement */
   value = value - table[i].prob3;
  }
  /* Keep the "best" one */
  if (table[i].level < table[j].level) i = j;
 }
 /* Try for a "better" object twice (10%) */
 if (p < 10) {
  /* Save old */
  j = i;
  /* Pick a object */
  value = randint0(total);
  /* Find the object */
  for (i = 0; i < alloc_kind_size; i++) {
   /* Found the entry */
   if (value < table[i].prob3) break;
   /* Decrement */
   value = value - table[i].prob3;
  }
  /* Keep the "best" one */
  if (table[i].level < table[j].level) i = j;
 }
 /* Result */
 return &k_info[table[i].index];
}
/**
 * Attempt to make an object
 *
 * \param c is the current dungeon level.
 * \param lev is the creation level of the object (not necessarily == depth).
 * \param good is whether the object is to be good
 * \param great is whether the object is to be great
 * \param drop constrains the type of object created or may be NULL to have no
 * constraint on the object type
 *
 * \return a pointer to the newly allocated object, or NULL on failure.
 */
struct object *make_object(struct chunk *c, int lev, bool good, bool great,
  struct drop *drop)
{
 struct object_kind *kind = NULL;
 struct object *new_obj;
 /* Base level for the object */
 int base = good || great ? lev + 3 : lev;
 /* Chance of "special object" */
 int prob = ((good || great) ? 10 : 1000);
 /* Better chance to check special artefacts if there is a jewellery theme */
 if (drop && drop_is(drop, "jewellery")) prob /= 2;
 /* Try to make a special artifact */
 if (one_in_(prob)) {
  new_obj = make_artifact_special(lev);
  if (new_obj) return new_obj;
 }
 /* Prepare allocation table if needed */
 if (drop) {
  get_obj_num_prep(drop);
 } else if (great) {
  get_obj_num_prep(lookup_drop("great"));
 } else if (good) {
  get_obj_num_prep(lookup_drop("good"));
 }
 /* Try to choose an object kind */
 kind = get_obj_num(base);
 /* Clear the object restriction */
 if (drop || good || great) {
  get_obj_num_prep(NULL);
 }
 /* Handle failure */
 if (!kind) return NULL;
 /* Make the object, prep it and apply magic */
 new_obj = object_new();
 object_prep(new_obj, kind, lev, RANDOMISE);
 /* Generate multiple items */
 if (tval_is_ammo(new_obj)) {
  if (one_in_(3)) {
   new_obj->number = damroll(4, 6);
  } else {
   /* 3/6 chance of 12, 2/6 chance of 24, 1/6 chance of 36 */
   new_obj->number = 12;
   if (one_in_(2)) {
    new_obj->number += 12;
    if (one_in_(3)) {
     new_obj->number += 12;
    }
   }
  }
 } else if (tval_is_metal(new_obj)) {
  new_obj->number = damroll(2, 40);
 }
 /* Apply magic */
 apply_magic(new_obj, lev, true, good, great);
 return new_obj;
}
/**
 * Map NarSil's modifier values to Sil's pval.
 *
 * \param kind is the kind of object to be queried.
 * \param rand_aspect controls whether a starting (rand_aspect == AVERAGE),
 * minimum (rand_aspect == MINIMISE) or maximum (rand_aspect == MAXIMISE) pval
 * is desired.  If rand_aspect is not AVERAGE, MINIMISE, or MAXIMISE, the
 * result will be the same as if rand_aspect was equal to AVERAGE.
 * \param flip_sign_out will, if not NULL, be dereferenced and set to true or
 * false.  That value can be used by the caller in this fashion to determine
 * whether to substitute -pval or pval for a modifier that can be non-zero:
 *     if (modifier's minimum possible value != 0 || modifier's maximum
 *             possible value != 0) {
 *         if (modifier's minimum possible value >= 0) {
 *             modifier's current value = pval;
 *         } else if (modifier's maximum possible value > 0) {
 *             if (modifier's maximum possible value >= -1 * modifier's
 *                     minimum possible value) {
 *                 modifier's current value = pval;
 *             } else {
 *                 modifier's current value = -pval;
 *             }
 *         } else {
 *             modifier's current value = -pval;
 *         }
 *         if (*flip_sign_out) {
 *             modifier's current value *= -1;
 *         }
 *     }
 *
 * NarSil allows different non-zero values for the modifiers.  For Sil, those
 * enchantments are either -pval or +pval where pval is the value that Sil
 * stores in the object's pval field.  This function looks through a kind's
 * modifiers and extracts something appropriate to use as the value for
 * that single value.
 *
 * If a kind is to be used in smithing or with specials that affect modifiers,
 * it will work better if it has only one non-zero modifier or all the non-zero
 * modifiers will take the same value ignoring the sign.  Some accommodations
 * are made for modifiers with a range of values, but those will work better
 * if there is a single such modifier or all such modifiers have the same
 * range up to flipping the signs on the bounds of the range.
 */
int extract_kind_pval(const struct object_kind *kind, aspect rand_aspect,
  bool *flip_sign_out)
{
 int pval_l = 0, pval_s = 0, pval_h = 0, i;
 bool all_zero = true, all_mixed_signs = true, all_negative = true,
  all_mixed_more_neg = true, flip_sign;
 for (i = 0; i < OBJ_MOD_MAX; ++i) {
  int min_m = randcalc(kind->modifiers[i], 0, MINIMISE);
  int max_m = randcalc(kind->modifiers[i], z_info->dun_depth,
   MAXIMISE);
  if (min_m == SPECIAL_VALUE) {
   min_m = randcalc(kind->special1, 0, MINIMISE);
   if (!min_m && kind->special2) {
    min_m = kind->special2;
   }
  }
  if (max_m == SPECIAL_VALUE) {
   max_m = randcalc(kind->special1, z_info->dun_depth,
    MAXIMISE);
   if (!max_m && kind->special2) {
    max_m = kind->special2;
   }
  }
  if (min_m || max_m) {
   int this_l, this_s, this_h;
   assert(max_m >= min_m);
   if (min_m >= 0) {
    all_negative = false;
    all_mixed_signs = false;
    this_l = min_m;
    this_s = MAX(1, min_m);
    this_h = max_m;
   } else if (max_m > 0) {
    all_negative = false;
    this_s = 1;
    /*
				 * Flip the sign as necessary so the reported
				 * range has a positive part at least as big
				 * as the negative part.
				 */
    if (max_m >= -min_m) {
     all_mixed_more_neg = false;
     this_l = min_m;
     this_h = max_m;
    } else {
     this_l = -max_m;
     this_h = -min_m;
    }
   } else {
    all_mixed_signs = false;
    this_l = -max_m;
    this_s = MAX(1, -max_m);
    this_h = -min_m;
   }
   if (all_zero) {
    all_zero = false;
    pval_l = this_l;
    pval_s = this_s;
    pval_h = this_h;
   } else {
    if (all_mixed_signs) {
     assert(pval_s == 1 && this_s == 1);
     /*
					 * If the ranges are not compatible,
					 * use the part common to both.
					 */
     if (pval_h != this_h ||
       pval_l != this_l) {
      if (pval_h > this_h) {
       pval_h = this_h;
      }
      if (pval_l < this_l) {
       pval_l = this_l;
      }
     }
    } else {
     if (pval_h > this_h) {
      pval_h = this_h;
     }
     if (pval_s > this_s) {
      pval_s = this_s;
     }
     if (this_l >= 0 && pval_l > this_l) {
      pval_l = this_l;
     }
    }
   }
  }
 }
 /*
	 * If all the non-zero modifiers are negative or all have ranges that
	 * span zero and those ranges all have more negative values than
	 * positive ones, flip signs since that works better with a cursed
	 * special:  such a special subtracts from the pval if it adjusts the
	 * modifiers.
	 */
 flip_sign = !all_zero && (all_negative
  || (all_mixed_signs && all_mixed_more_neg));
 if (flip_sign_out) {
  *flip_sign_out = flip_sign;
 }
 if (rand_aspect == MINIMISE) {
  return (flip_sign) ? -pval_h : pval_l;
 }
 if (rand_aspect == MAXIMISE) {
  return (flip_sign) ? -pval_l : pval_h;
 }
 return (flip_sign) ? -pval_s : pval_s;
}
struct init_module obj_make_module = {
 .name = "object/obj-make",
 .init = init_obj_make,
 .cleanup = cleanup_obj_make
};
/**
 * \file obj-pile.c
 * \brief Deal with piles of objects
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/* #define LIST_DEBUG */
static struct object *fail_pile;
static struct object *fail_object;
static bool fail_prev;
static bool fail_next;
static const char *fail_file;
static int fail_line;
static void write_pile(ang_file *fff)
{
 file_putf(fff, "Pile integrity failure at %s:%d\n\n", fail_file, fail_line);
 file_putf(fff, "Guilty object\n=============\n");
 if (fail_object && fail_object->kind) {
  file_putf(fff, "Name: %s\n", fail_object->kind->name);
  if (fail_prev) {
   file_putf(fff, "Previous: ");
   if (fail_object->prev && fail_object->prev->kind) {
    file_putf(fff, "%s\n", fail_object->prev->kind->name);
   } else {
    file_putf(fff, "bad object\n");
   }
  }
  if (fail_next) {
   file_putf(fff, "Next: ");
   if (fail_object->next && fail_object->next->kind) {
    file_putf(fff, "%s\n", fail_object->next->kind->name);
   } else {
    file_putf(fff, "bad object\n");
   }
  }
  file_putf(fff, "\n");
 }
 if (fail_pile) {
  file_putf(fff, "Guilty pile\n=============\n");
  while (fail_pile) {
   if (fail_pile->kind) {
    file_putf(fff, "Name: %s\n", fail_pile->kind->name);
   } else {
    file_putf(fff, "bad object\n");
   }
   fail_pile = fail_pile->next;
  }
 }
}
/**
 * Quit on getting an object pile error, writing a diagnosis file
 */
static void pile_integrity_fail(struct object *pile, struct object *obj,
 const char *file, int line)
{
 char path[1024];
 /* Set the pile info to write out */
 fail_pile = pile;
 fail_object = obj;
 fail_prev = (obj->prev != NULL);
 fail_next = (obj->next != NULL);
 fail_file = file;
 fail_line = line;
 /* Write to the user directory */
 path_build(path, sizeof(path), ANGBAND_DIR_USER, "pile_error.txt");
 if (text_lines_to_file(path, write_pile)) {
  quit_fmt("Failed to create file %s.new", path);
 }
 quit_fmt("Pile integrity failure, details written to %s", path);
}
/**
 * Check the integrity of a linked - make sure it's not circular and that each
 * entry in the chain has consistent next and prev pointers.
 */
static void pile_check_integrity(const char *op, struct object *pile,
 struct object *hilight)
{
 struct object *obj = pile;
 struct object *prev = NULL;
 /* Check prev<->next chain */
 while (obj) {
  if (obj->prev != prev) {
   pile_integrity_fail(pile, obj, "<stdin>", 53618);
  }
  prev = obj;
  obj = obj->next;
 };
 /* Check for circularity */
 for (obj = pile; obj; obj = obj->next) {
  struct object *check;
  for (check = obj->next; check; check = check->next) {
   if (check->next == obj) {
    pile_integrity_fail(pile, check, "<stdin>", 53629);
   }
  }
 }
}
/**
 * Insert 'obj' into the pile 'pile'.
 *
 * 'obj' must not already be in any other lists.
 */
void pile_insert(struct object **pile, struct object *obj)
{
 if (obj->prev || obj->next) {
  pile_integrity_fail(NULL, obj, "<stdin>", 53643);
 }
 if (*pile) {
  obj->next = *pile;
  (*pile)->prev = obj;
 }
 *pile = obj;
 pile_check_integrity("insert", *pile, obj);
}
/**
 * Insert 'obj' at the end of pile 'pile'.
 *
 * Unlike pile_insert(), obj can be the beginning of a new list of objects.
 */
void pile_insert_end(struct object **pile, struct object *obj)
{
 if (obj->prev) {
  pile_integrity_fail(NULL, obj, "<stdin>", 53664);
 }
 if (*pile) {
  struct object *end = pile_last_item(*pile);
  end->next = obj;
  obj->prev = end;
 } else {
  *pile = obj;
 }
 pile_check_integrity("insert_end", *pile, obj);
}
/**
 * Remove object 'obj' from pile 'pile'.
 */
void pile_excise(struct object **pile, struct object *obj)
{
 struct object *prev = obj->prev;
 struct object *next = obj->next;
 if (!pile_contains(*pile, obj)) {
  pile_integrity_fail(*pile, obj, "<stdin>", 53688);
 }
 pile_check_integrity("excise [pre]", *pile, obj);
 /* Special case: unlink top object */
 if (*pile == obj) {
  if (prev) {
   pile_integrity_fail(*pile, obj, "<stdin>", 53695);
  }
  *pile = next;
 } else {
  if (obj->prev == NULL) {
   pile_integrity_fail(*pile, obj, "<stdin>", 53701);
  }
  /* Otherwise unlink from the previous */
  prev->next = next;
  obj->prev = NULL;
 }
 /* And then unlink from the next */
 if (next) {
  next->prev = prev;
  obj->next = NULL;
 }
 pile_check_integrity("excise [post]", *pile, NULL);
}
/**
 * Return the last item in pile 'pile'.
 */
struct object *pile_last_item(struct object *const pile)
{
 struct object *obj = pile;
 pile_check_integrity("last_item", pile, NULL);
 /* No pile at all */
 if (!pile)
  return NULL;
 /* Run along the list, stopping just before the end */
 while (obj->next)
  obj = obj->next;
 return obj;
}
/**
 * Check if pile 'pile' contains object 'obj'.
 */
bool pile_contains(const struct object *top, const struct object *obj)
{
 const struct object *pile_obj = top;
 while (pile_obj) {
  if (obj == pile_obj)
   return true;
  pile_obj = pile_obj->next;
 }
 return false;
}
/**
 * Create a new object and return it
 */
struct object *object_new(void)
{
 return mem_zalloc(sizeof(struct object));
}
/**
 * Free up an object
 *
 * This doesn't affect any game state outside of the object itself
 */
void object_free(struct object *obj)
{
 mem_free(obj->slays);
 mem_free(obj->brands);
 release_ability_list(obj->abilities);
 mem_free(obj);
}
/**
 * Delete an object and free its memory, and set its pointer to NULL
 * \param c is the chunk the object belongs to (usually)
 * \param p_c is the corresponding known chunk (eg player->cave if c is cave)
 * \param obj_address is the address of the struct object* to be deleted
 */
void object_delete(struct chunk *c, struct chunk *p_c,
       struct object **obj_address)
{
 struct object *obj = *obj_address;
 struct object *prev = obj->prev;
 struct object *next = obj->next;
 /* Check any next and previous objects */
 if (next) {
  if (prev) {
   prev->next = next;
   next->prev = prev;
  } else {
   next->prev = NULL;
  }
 } else if (prev) {
  prev->next = NULL;
 }
 /* If we're tracking the object, stop */
 if (player && player->upkeep && obj == player->upkeep->object)
  player->upkeep->object = NULL;
 /* Orphan rather than actually delete if we still have a known object */
 if (c && p_c && obj->oidx && (obj == c->objects[obj->oidx]) &&
  p_c->objects[obj->oidx]) {
  obj->grid = loc(0, 0);
  obj->prev = NULL;
  obj->next = NULL;
  obj->held_m_idx = 0;
  /* Object is now purely imaginary to the player */
  obj->known->notice |= OBJ_NOTICE_IMAGINED;
  return;
 }
 /* Remove from any lists */
 if (p_c && p_c->objects && obj->oidx && (obj == p_c->objects[obj->oidx]))
  p_c->objects[obj->oidx] = NULL;
 if (c && c->objects && obj->oidx && (obj == c->objects[obj->oidx]))
  c->objects[obj->oidx] = NULL;
 object_free(obj);
 *obj_address = NULL;
}
/**
 * Free an entire object pile
 * \param c is the chunk holding the pile; should be NULL for piles held by
 * players or stores.
 * \param obj is the pointer to the start of the pile to excise.
 */
void object_pile_free(struct chunk *c, struct chunk *p_c, struct object *obj)
{
 struct object *current = obj, *next;
 while (current) {
  next = current->next;
  object_delete(c, p_c, &current);
  current = next;
 }
}
/**
 * Determine if, ignoring any inscriptions, one item like obj1 can be stacked
 * with one item like obj2.
 *
 * See "object_absorb()" for the actual "absorption" code.
 *
 * If permitted, we allow weapons/armor to stack, if "known".
 *
 * Missiles will combine if both stacks have the same "known" status.
 * This is done to make unidentified stacks of missiles useful.
 *
 * Food, potions, scrolls, and "easy know" items always stack.
 *
 * Chests, and activatable items, except rods, never stack (for various
 * reasons).
 */
bool object_similar(const struct object *obj1, const struct object *obj2,
       object_stack_t mode)
{
 int i;
 /* Equipment items don't stack */
 if (object_is_equipped(player->body, obj1))
  return false;
 if (object_is_equipped(player->body, obj2))
  return false;
 /* If either item is unknown, do not stack */
 if (mode & OSTACK_LIST && obj1->kind != obj1->known->kind) return false;
 if (mode & OSTACK_LIST && obj2->kind != obj2->known->kind) return false;
 /* Hack -- identical items cannot be stacked */
 if (obj1 == obj2) return false;
 /* Require identical object kinds */
 if (obj1->kind != obj2->kind) return false;
 /* Different flags don't stack */
 if (!of_is_equal(obj1->flags, obj2->flags)) return false;
 /* Different elements don't stack */
 for (i = 0; i < ELEM_MAX; i++) {
  if (obj1->el_info[i].res_level != obj2->el_info[i].res_level)
   return false;
  if ((obj1->el_info[i].flags & (EL_INFO_HATES | EL_INFO_IGNORE)) !=
   (obj2->el_info[i].flags & (EL_INFO_HATES | EL_INFO_IGNORE)))
   return false;
 }
 /* Artifacts never stack */
 if (obj1->artifact || obj2->artifact) return false;
 /* Analyze the items */
 if (tval_is_chest(obj1) || tval_is_note(obj1)) {
  /* Chests and notes never stack */
  return false;
 } else if (tval_is_edible(obj1) || tval_is_potion(obj1) ||
      tval_is_horn(obj1)) {
  /* Food, potions, scrolls and rods all stack nicely,
		   since the kinds are identical, either both will be
		   aware or both will be unaware */
 } else if (tval_can_have_charges(obj1)) {
  /* Staves never stack */
  return false;
 } else if (tval_is_weapon(obj1) || tval_is_armor(obj1) ||
      tval_is_jewelry(obj1) || tval_is_light(obj1)) {
  bool obj1_is_known = object_runes_known(obj1);
  bool obj2_is_known = object_runes_known(obj2);
  /* Require identical values */
  if (obj1->weight != obj2->weight) return false;
  if (obj1->att != obj2->att) return false;
  if (obj1->dd != obj2->dd) return false;
  if (obj1->ds != obj2->ds) return false;
  if (obj1->evn != obj2->evn) return false;
  if (obj1->pd != obj2->pd) return false;
  if (obj1->ps != obj2->ps) return false;
  /* Require all identical modifiers */
  for (i = 0; i < OBJ_MOD_MAX; i++)
   if (obj1->modifiers[i] != obj2->modifiers[i])
    return (false);
  /* Require identical ego-item types */
  if (obj1->ego != obj2->ego) return false;
  /* Hack - Never stack recharging wearables ... */
  if ((obj1->timeout || obj2->timeout) &&
   !tval_is_light(obj1)) return false;
  /* ... and lights must have same amount of fuel */
  else if ((obj1->timeout != obj2->timeout) &&
     tval_is_light(obj1)) return false;
  /* Prevent unIDd items stacking with IDd items in the object list */
  if (mode & OSTACK_LIST && (obj1_is_known != obj2_is_known))
   return false;
 } else {
  /* Anything else probably okay */
 }
 /* They must be similar enough */
 return true;
}
/**
 * Determine if one item like obj1 can be stacked with one item like obj2
 * (i.e. identical to object_similar() except for the inscription check).
 */
bool object_stackable(const struct object *obj1, const struct object *obj2,
       object_stack_t mode)
{
 if (object_similar(obj1, obj2, mode)) {
  /* Require compatible inscriptions */
  return !obj1->note || !obj2->note || obj1->note == obj2->note;
 }
 return false;
}
/**
 * Return whether each stack of objects can be merged into one stack.
 */
bool object_mergeable(const struct object *obj1, const struct object *obj2,
     object_stack_t mode)
{
 int total = obj1->number + obj2->number;
 /* Check against stacking limit - except in stores which absorb anyway */
 if (total > obj1->kind->base->max_stack) {
  return false;
 }
 return object_stackable(obj1, obj2, mode);
}
/**
 * Combine the origins of two objects
 */
void object_origin_combine(struct object *obj1, const struct object *obj2)
{
 if (obj1->origin_race != obj2->origin_race) {
  bool uniq1 = (obj1->origin_race
   && rf_has(obj1->origin_race->flags, RF_UNIQUE));
  bool uniq2 = (obj2->origin_race
   && rf_has(obj2->origin_race->flags, RF_UNIQUE));
  if (uniq1 && !uniq2) {
   /* Favour keeping record for a unique */
   ;
  } else if (uniq2 && !uniq1) {
   /* Favour keeping record for a unique */
   obj1->origin = obj2->origin;
   obj1->origin_depth = obj2->origin_depth;
   obj1->origin_race = obj2->origin_race;
  } else {
   /* Different monsters, neither or both unique, mixed origin */
   obj1->origin = ORIGIN_MIXED;
  }
 } else if (obj1->origin != obj2->origin
   || obj1->origin_depth != obj2->origin_depth) {
  obj1->origin = ORIGIN_MIXED;
 }
}
/**
 * Allow one item to "absorb" another, assuming they are similar.
 *
 * The blending of the "note" field assumes that either (1) one has an
 * inscription and the other does not, or (2) neither has an inscription.
 * In both these cases, we can simply use the existing note, unless the
 * blending object has a note, in which case we use that note.
 *
* These assumptions are enforced by the "object_mergeable()" code.
 */
static void object_absorb_merge(struct object *obj1, const struct object *obj2)
{
 int total;
 /* First object gains any extra knowledge from second */
 obj1->notice |= obj2->notice;
 /* Merge inscriptions */
 if (obj2->note)
  obj1->note = obj2->note;
 /* Combine pvals for staves */
 if (tval_can_have_charges(obj1)) {
  total = obj1->pval + obj2->pval;
  obj1->pval = total >= MAX_PVAL ? MAX_PVAL : total;
 }
 /* Combine origin data as best we can */
 object_origin_combine(obj1, obj2);
}
/**
 * Merge a smaller stack into a larger stack, leaving two uneven stacks.
 * \param obj1 Is the first of the stacks to combine.  When the stacking
 * limits (from mode1 and mode2) are the same, this stack will be larger
 * when the function returns.
 * \param obj2 Is the second of the stacks to combine.
 */
void object_absorb_partial(struct object *obj1, struct object *obj2)
{
 int smallest = MIN(obj1->number, obj2->number);
 int largest = MAX(obj1->number, obj2->number);
 int newsz1, newsz2;
 int difference = obj1->kind->base->max_stack - largest;
 newsz1 = largest + difference;
 newsz2 = smallest - difference;
 obj1->number = newsz1;
 obj2->number = newsz2;
 object_absorb_merge(obj1, obj2);
}
/**
 * Merge two stacks into one stack.
 */
void object_absorb(struct object *obj1, struct object *obj2)
{
 struct object *known = obj2->known;
 int total = obj1->number + obj2->number;
 /* Add together the item counts */
 obj1->number = MIN(total, obj1->kind->base->max_stack);
 object_absorb_merge(obj1, obj2);
 if (known) {
  if (!loc_is_zero(known->grid)) {
   square_excise_object(player->cave, known->grid, known);
  }
  delist_object(player->cave, known);
  object_delete(player->cave, NULL, &known);
 }
 object_delete(cave, player->cave, &obj2);
}
/**
 * Wipe an object clean.
 */
void object_wipe(struct object *obj)
{
 /* Free slays and brands */
 mem_free(obj->slays);
 mem_free(obj->brands);
 release_ability_list(obj->abilities);
 /* Wipe the structure */
 memset(obj, 0, sizeof(*obj));
}
/**
 * Prepare an object based on an existing object
 */
void object_copy(struct object *dest, const struct object *src)
{
 /* Copy the structure */
 memcpy(dest, src, sizeof(struct object));
 if (src->slays) {
  dest->slays = mem_zalloc(z_info->slay_max * sizeof(bool));
  memcpy(dest->slays, src->slays, z_info->slay_max * sizeof(bool));
 }
 if (src->brands) {
  dest->brands = mem_zalloc(z_info->brand_max * sizeof(bool));
  memcpy(dest->brands, src->brands, z_info->brand_max * sizeof(bool));
 }
 if (src->abilities) {
  dest->abilities = copy_ability_list(src->abilities);
 }
 /* Detach from any pile */
 dest->prev = NULL;
 dest->next = NULL;
}
/**
 * Prepare an object `dst` representing `amt` objects,  based on an existing
 * object `src` representing at least `amt` objects.
 *
 * Takes care of the charge redistribution concerns of stacked items.
 */
void object_copy_amt(struct object *dest, struct object *src, int amt)
{
 /* Get a copy of the object */
 object_copy(dest, src);
 /* Modify quantity */
 dest->number = amt;
 dest->note = src->note;
 /*
	 * If the item has charges/timeouts, set them to the correct level
	 * too. We split off the same amount as distribute_charges.
	 */
 if (tval_can_have_charges(src))
  dest->pval = src->pval * amt / src->number;
}
/**
 * Split off 'amt' items from 'src' and return.
 *
 * Where object_copy_amt() makes `amt` new objects, this function leaves the
 * total number unchanged; otherwise the two functions are similar.
 *
 * This function should only be used when amt < src->number
 */
struct object *object_split(struct object *src, int amt)
{
 struct object *dest = object_new(), *dest_known;
 /* Get a copy of the object */
 object_copy(dest, src);
 /* Do we need a new known object? */
 if (src->known) {
  /* Ensure numbers are aligned (should not be necessary, but safer) */
  src->known->number = src->number;
  /* Make the new object */
  dest_known = object_new();
  object_copy(dest_known, src->known);
  dest->known = dest_known;
 }
 /* Check legality */
 assert(src->number > amt);
 /* Distribute charges of wands, staves, or rods */
 distribute_charges(src, dest, amt);
 if (src->known)
  distribute_charges(src->known, dest->known, amt);
 /* Modify quantity */
 dest->number = amt;
 src->number -= amt;
 if (src->note)
  dest->note = src->note;
 if (src->known) {
  dest->known->number = dest->number;
  src->known->number = src->number;
  dest->known->note = src->known->note;
 }
 /* Remove any index */
 if (dest->known)
  dest->known->oidx = 0;
 dest->oidx = 0;
 return dest;
}
/**
 * Remove an amount of an object from the floor, returning a detached object
 * which can be used - it is assumed that the object is being manipulated by
 * given player and is on that player's grid.
 *
 * Optionally describe what remains.
 */
struct object *floor_object_for_use(struct player *p, struct object *obj,
 int num, bool message, bool *none_left)
{
 struct object *usable;
 char name[80];
 /* Bounds check */
 num = MIN(num, obj->number);
 /* Split off a usable object if necessary */
 if (obj->number > num) {
  usable = object_split(obj, num);
 } else {
  usable = obj;
  square_excise_object(p->cave, usable->grid, usable->known);
  delist_object(p->cave, usable->known);
  square_excise_object(cave, usable->grid, usable);
  delist_object(cave, usable);
  *none_left = true;
  /* Stop tracking item */
  if (tracked_object_is(p->upkeep, obj))
   track_object(p->upkeep, NULL);
  /* The pile is gone, so disable repeat command */
  cmd_disable_repeat();
 }
 /* Object no longer has a location */
 usable->known->grid = loc(0, 0);
 usable->grid = loc(0, 0);
 /* Print a message if requested and there is anything left */
 if (message) {
  if (usable == obj)
   obj->number = 0;
  /* Get a description */
  object_desc(name, sizeof(name), obj, ODESC_PREFIX | ODESC_FULL, p);
  if (usable == obj)
   obj->number = num;
  /* Print a message */
  msg("You see %s.", name);
 }
 return usable;
}
/**
 * Destroy an item on the floor
 */
bool floor_destroy(struct object *obj, int amt)
{
 bool none_left;
 char name[80];
 char out_val[160];
 int num = obj->number;
 struct object *destroyed;
 /* Describe the destroyed object */
 obj->number = amt;
 object_desc(name, sizeof(name), obj, ODESC_PREFIX | ODESC_FULL, player);
 obj->number = num;
 /* Check for known special items */
 strnfmt(out_val, sizeof(out_val), "Really destroy %s? ", name);
 if (!get_check(out_val)) {
  return false;
 }
 /* Get the object */
 destroyed = floor_object_for_use(player, obj, amt, true, &none_left);
 /* Message */
 msg("You destroy %s.", name);
 /* Destroy it */
 if (destroyed->known) {
  struct object *known = destroyed->known;
  if (!loc_is_zero(known->grid))
   square_excise_object(player->cave, known->grid, known);
  delist_object(player->cave, known);
  object_delete(player->cave, NULL, &known);
 }
 delist_object(cave, destroyed);
 object_delete(cave, player->cave, &destroyed);
 return true;
}
/**
 * Find and return the oldest object on the given grid marked as "ignore".
 */
static struct object *floor_get_oldest_ignored(const struct player *p,
  struct chunk *c, struct loc grid)
{
 struct object *obj, *ignore = NULL;
 for (obj = square_object(c, grid); obj; obj = obj->next)
  if (ignore_item_ok(p, obj))
   ignore = obj;
 return ignore;
}
/**
 * Let the floor carry an object, deleting old ignored items if necessary.
 * The calling function must deal with the dropped object on failure.
 *
 * Optionally put the object at the top or bottom of the pile
 */
bool floor_carry(struct chunk *c, struct loc grid, struct object *drop,
     bool *note)
{
 int n = 0;
 struct object *obj, *ignore = floor_get_oldest_ignored(player, c, grid);
 /* Fail if the square can't hold objects */
 if (!square_isobjectholding(c, grid))
  return false;
 /* Scan objects in that grid for combination */
 for (obj = square_object(c, grid); obj; obj = obj->next) {
  /* Check for combination */
  if (object_mergeable(obj, drop, OSTACK_FLOOR)) {
   /* Combine the items */
   object_absorb(obj, drop);
   /* Note the pile */
   if (square_isview(c, grid)) {
    square_note_spot(c, grid);
   }
   /* Don't mention if ignored */
   if (ignore_item_ok(player, obj)) {
    *note = false;
   }
   /* Result */
   return true;
  }
  /* Count objects */
  n++;
 }
 /* The stack is already too large */
 if (n >= z_info->floor_size) {
  /* Delete the oldest ignored object */
  if (ignore) {
   struct chunk *p_c = (c == cave) ? player->cave : NULL;
   square_excise_object(c, grid, ignore);
   delist_object(c, ignore);
   object_delete(c, p_c, &ignore);
  } else {
   return false;
  }
 }
 /* Location */
 drop->grid = grid;
 /* Forget monster */
 drop->held_m_idx = 0;
 /* Link to the first object in the pile */
 pile_insert(&c->squares[grid.y][grid.x].obj, drop);
 /* Record in the level list */
 list_object(c, drop);
 /* If there's a known version, put it in the player's view of the
	 * cave but at an unknown location.  square_note_spot() will move
	 * it to the correct place if seen. */
 if (drop->known) {
  drop->known->oidx = drop->oidx;
  drop->known->held_m_idx = 0;
  drop->known->grid = loc(0, 0);
  player->cave->objects[drop->oidx] = drop->known;
 }
 /* Redraw */
 square_note_spot(c, grid);
 square_light_spot(c, grid);
 /* Don't mention if ignored */
 if (ignore_item_ok(player, drop)) {
  *note = false;
 }
 /* Result */
 return true;
}
/**
 * Delete an object when the floor fails to carry it, and attempt to remove
 * it from the object list
 */
static void floor_carry_fail(struct chunk *c, struct object *drop, bool broke)
{
 struct object *known = drop->known;
 /* Delete completely */
 if (known) {
  char o_name[80];
  const char *verb = broke ?
   VERB_AGREEMENT(drop->number, "breaks", "break") :
   VERB_AGREEMENT(drop->number, "disappears", "disappear");
  object_desc(o_name, sizeof(o_name), drop, ODESC_BASE, player);
  msg("The %s %s.", o_name, verb);
  if (!loc_is_zero(known->grid))
   square_excise_object(player->cave, known->grid, known);
  delist_object(player->cave, known);
  object_delete(player->cave, NULL, &known);
 }
 delist_object(c, drop);
 object_delete(c, player->cave, &drop);
}
/**
 * Find a grid near the given one for an object to fall on
 *
 * We check several locations to see if we can find a location at which
 * the object can combine, stack, or be placed.  Artifacts will try very
 * hard to be placed, including "teleporting" to a useful grid if needed.
 *
 * If prefer_pile is true, does not apply a penalty for putting different types
 * items in the same grid.
 *
 * If no appropriate grid is found, the given grid is unchanged
 */
static void drop_find_grid(const struct player *p, struct chunk *c,
  struct object *drop, bool prefer_pile, struct loc *grid)
{
 int best_score = -1;
 struct loc start = *grid;
 struct loc best = start;
 int i, dy, dx;
 struct object *obj;
 /* Scan local grids */
 for (dy = -3; dy <= 3; dy++) {
  for (dx = -3; dx <= 3; dx++) {
   bool combine = false;
   int dist = (dy * dy) + (dx * dx);
   struct loc try = loc_sum(start, loc(dx, dy));
   int num_shown = 0;
   int num_ignored = 0;
   int score;
   /* Lots of reasons to say no */
   if ((dist > 10) ||
    !square_in_bounds_fully(c, try) ||
    !los(c, start, try) ||
    !square_isfloor(c, try) ||
    square_istrap(c, try))
    continue;
   /* Analyse the grid for carrying the new object */
   for (obj = square_object(c, try); obj; obj = obj->next){
    /* Check for possible combination */
    if (object_mergeable(obj, drop, OSTACK_FLOOR))
     combine = true;
    /* Count objects */
    if (!ignore_item_ok(p, obj))
     num_shown++;
    else
     num_ignored++;
   }
   if (!combine)
    num_shown++;
   /* Disallow if the stack size is too big */
   if ((num_shown + num_ignored) > z_info->floor_size &&
    !floor_get_oldest_ignored(p, c, try))
    continue;
   /* Score the location based on how close and how full the grid is */
   score = 1000 -
    (dist + (prefer_pile ? 0 : num_shown * 5));
   if ((score < best_score) || ((score == best_score) && one_in_(2)))
    continue;
   best_score = score;
   best = try;
  }
 }
 /* Return if we have a score, otherwise fail or try harder for artifacts */
 if (best_score >= 0) {
  *grid = best;
  return;
 } else if (!drop->artifact) {
  return;
 }
 for (i = 0; i < 2000; i++) {
  /* Start bouncing from grid to grid, stopping if we find an empty one */
  if (i < 1000) {
   best = rand_loc(best, 1, 1);
   /* Keep in bounds. */
   best.x = MAX(0, MIN(best.x, c->width - 1));
   best.y = MAX(0, MIN(best.y, c->height - 1));
  } else {
   /* Now go to purely random locations */
   best = loc(randint0(c->width), randint0(c->height));
  }
  if (square_canputitem(c, best)) {
   *grid = best;
   return;
  }
 }
}
/**
 * Let an object fall to the ground at or near a location.
 *
 * The initial location is assumed to be "square_in_bounds_fully(cave, )".
 *
 * This function takes a parameter "chance".  This is the percentage
 * chance that the item will "disappear" instead of drop.  If the object
 * has been thrown, then this is the chance of disappearance on contact.
 *
 * This function will produce a description of a drop event under the player
 * when "verbose" is true.
 *
 * If "prefer_pile" is true, the penalty for putting different types of items
 * in the same square is not applied.
 *
 * The calling function needs to deal with the consequences of the dropped
 * object being destroyed or absorbed into an existing pile.
 */
void drop_near(struct chunk *c, struct object **dropped, int chance,
      struct loc grid, bool verbose, bool prefer_pile)
{
 char o_name[80];
 struct loc best = grid;
 bool dont_ignore = verbose && !ignore_item_ok(player, *dropped);
 /* Describe object */
 object_desc(o_name, sizeof(o_name), *dropped, ODESC_BASE, player);
 /* Handle normal breakage */
 if (!((*dropped)->artifact) && (randint0(100) < chance)) {
  floor_carry_fail(c, *dropped, true);
  return;
 }
 /* Find the best grid and drop the item, destroying if there's no space */
 drop_find_grid(player, c, *dropped, prefer_pile, &best);
 if (floor_carry(c, best, *dropped, &dont_ignore)) {
  if (dont_ignore && (square(c, best)->mon < 0)) {
   sound(MSG_DROP);
   msg("You feel something roll beneath your feet.");
  }
 } else {
  floor_carry_fail(c, *dropped, false);
 }
}
/**
 * This will push objects off a square.
 *
 * The methodology is to load all objects on the square into a queue. Replace
 * the previous square with a type that does not allow for objects. Drop the
 * objects. Last, put the square back to its original type.
 */
void push_object(struct loc grid)
{
 /* Save the original terrain feature */
 struct feature *feat_old = square_feat(cave, grid);
 struct object *obj = square_object(cave, grid);
 struct queue *queue = q_new(z_info->floor_size);
 struct trap *trap = square_trap(cave, grid);
 /* Push all objects on the square, stripped of pile info, into the queue */
 while (obj) {
  struct object *next = obj->next;
  /* In case the object is known, make a copy to work with
		 * and try to delete the original which will orphan it to
		 * serve as a placeholder for the known version. */
  struct object *newobj = object_new();
  object_copy(newobj, obj);
  newobj->oidx = 0;
  newobj->grid = loc(0, 0);
  if (newobj->known) {
   newobj->known = object_new();
   object_copy(newobj->known, obj->known);
   newobj->known->oidx = 0;
   newobj->known->grid = loc(0, 0);
  }
  q_push_ptr(queue, newobj);
  delist_object(cave, obj);
  object_delete(cave, player->cave, &obj);
  /* Next object */
  obj = next;
 }
 /* Disassociate the objects from the square */
 square_set_obj(cave, grid, NULL);
 /* Set feature to an open door */
 square_force_floor(cave, grid);
 square_add_door(cave, grid, false);
 /* Drop objects back onto the floor */
 while (q_len(queue) > 0) {
  /* Take object from the queue */
  obj = q_pop_ptr(queue);
  /* Drop the object */
  drop_near(cave, &obj, 0, grid, false, false);
 }
 /* Reset cave feature, remove trap if needed */
 square_set_feat(cave, grid, feat_old->fidx);
 if (trap && !square_istrappable(cave, grid)) {
  square_destroy_trap(cave, grid);
 }
 q_free(queue);
}
/**
 * Describe the charges on an item on the floor.
 */
void floor_item_charges(struct object *obj)
{
 /* Require staff/wand */
 if (!tval_can_have_charges(obj)) return;
 /* Require known item */
 if (!object_flavor_is_aware(obj)) return;
 /* Print a message */
 msg("There %s %d charge%s remaining.", (obj->pval != 1) ? "are" : "is",
      obj->pval, (obj->pval != 1) ? "s" : "");
}
/**
 * Get a list of the objects at the player's location.
 *
 * Return the number of objects acquired.
 */
int scan_floor(struct object **items, int max_size, struct player *p,
  object_floor_t mode, item_tester tester)
{
 struct object *obj;
 int num = 0;
 /* Sanity */
 if (!square_in_bounds(cave, p->grid)) return 0;
 /* Scan all objects in the grid */
 for (obj = square_object(cave, p->grid); obj; obj = obj->next) {
  /* Enforce limit */
  if (num >= max_size) break;
  /* Item tester */
  if ((mode & OFLOOR_TEST) && !object_test(tester, obj)) continue;
  /* Sensed or known */
  if ((mode & OFLOOR_SENSE) && (!obj->known)) continue;
  /* Visible */
  if ((mode & OFLOOR_VISIBLE) && ignore_item_ok(p, obj)) continue;
  /* Accept this item */
  items[num++] = obj;
  /* Only one */
  if (mode & OFLOOR_TOP) break;
 }
 return num;
}
/**
 * Get a list of the known objects at the given location.
 *
 * Return the number of objects acquired.
 */
int scan_distant_floor(struct object **items, int max_size, struct player *p,
  struct loc grid)
{
 struct object *obj;
 int num = 0;
 /* Sanity */
 if (!square_in_bounds(p->cave, grid)) return 0;
 /* Scan all objects in the grid */
 for (obj = square_object(p->cave, grid); obj; obj = obj->next) {
  /* Enforce limit */
  if (num >= max_size) break;
  /* Known */
  if (obj->kind == unknown_item_kind) continue;
  /* Visible */
  if (ignore_known_item_ok(p, obj)) continue;
  /* Accept this item's base object */
  items[num++] = cave->objects[obj->oidx];
 }
 return num;
}
/**
 * Get a list of "valid" objects.
 *
 * Fills item_list[] with items that are "okay" as defined by the
 * provided tester function, etc.  mode determines what combination of
 * inventory, equipment, quiver and player's floor location should be used
 * when drawing up the list.
 *
 * Returns the number of items placed into the list.
 *
 * Maximum space that can be used is
 * z_info->pack_size + player->body.count + z_info->floor_size,
 * though practically speaking much smaller numbers are likely.
 */
int scan_items(struct object **item_list, size_t item_max, struct player *p,
  int mode, item_tester tester)
{
 bool use_inven = ((mode & USE_INVEN) ? true : false);
 bool use_equip = ((mode & USE_EQUIP) ? true : false);
 bool use_floor = ((mode & USE_FLOOR) ? true : false);
 int floor_max = z_info->floor_size;
 struct object **floor_list = mem_zalloc(floor_max * sizeof(struct object *));
 int floor_num;
 int i;
 size_t item_num = 0;
 if (use_inven)
  for (i = 0; i < z_info->pack_size && item_num < item_max; i++) {
   if (object_test(tester, p->upkeep->inven[i]))
    item_list[item_num++] = p->upkeep->inven[i];
  }
 if (use_equip)
  for (i = 0; i < p->body.count && item_num < item_max; i++) {
   if (object_test(tester, slot_object(p, i)))
    item_list[item_num++] = slot_object(p, i);
  }
 /* Scan all objects in the grid */
 if (use_floor) {
  floor_num = scan_floor(floor_list, floor_max, p,
   OFLOOR_TEST| OFLOOR_SENSE | OFLOOR_VISIBLE, tester);
  for (i = 0; i < floor_num && item_num < item_max; i++)
   item_list[item_num++] = floor_list[i];
 }
 mem_free(floor_list);
 return item_num;
}
/**
 * Check if the given item is available for the player to use.
 */
bool item_is_available(struct object *obj)
{
 if (object_is_carried(player, obj)) return true;
 if (cave && square_holds_object(cave, player->grid, obj))
  return true;
 return false;
}
/**
 * \file obj-properties.c
 * \brief functions to deal with object properties
 *
 * Copyright (c) 2014 Chris Carr, Nick McConnell
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
struct obj_property *obj_properties;
struct obj_property *lookup_obj_property(int type, int index)
{
 struct obj_property *prop;
 int i;
 /* Find the right property */
 for (i = 0; i < z_info->property_max; i++) {
  prop = &obj_properties[i];
  if ((prop->type == type) && (prop->index == index)) {
   return prop;
  }
  /* Special case - stats and skills count as mods */
  if ((type == OBJ_PROPERTY_MOD) &&
   ((prop->type == OBJ_PROPERTY_STAT) ||
    (prop->type == OBJ_PROPERTY_SKILL)) &&
   (prop->index == index)) {
   return prop;
  }
 }
 return NULL;
}
/**
 * Create a "mask" of object flags of a specific type or ID threshold.
 *
 * \param f is the flag array we're filling
 * \param id is whether we're masking by ID level
 * \param ... is the list of flags or ID types we're looking for
 *
 * N.B. OFT_MAX must be the last item in the ... list
 */
void create_obj_flag_mask(bitflag *f, int id, ...)
{
 int i, j;
 va_list args;
 of_wipe(f);
 va_start(args, id);
 /* Process each type in the va_args */
    for (i = va_arg(args, int); i != OFT_MAX; i = va_arg(args, int)) {
  for (j = 1; j < z_info->property_max; j++) {
   struct obj_property *prop = &obj_properties[j];
   if (prop->type != OBJ_PROPERTY_FLAG) continue;
   if ((id && prop->id_type == i) || (!id && prop->subtype == i)) {
    of_on(f, prop->index);
   }
  }
 }
 va_end(args);
 return;
}
void insert_name(char *buf, size_t size, char *msg, char *name)
{
 const char *next;
 const char *s;
 const char *tag;
 const char *in_cursor;
 size_t end = 0;
 in_cursor = msg;
 next = strchr(in_cursor, '{');
 while (next) {
  /* Copy the text leading up to this { */
  strnfcat(buf, 1024, &end, "%.*s", (int) (next - in_cursor),
   in_cursor);
  s = next + 1;
  while (*s && isalpha((unsigned char) *s)) s++;
  /* Valid tag */
  if (*s == '}') {
   /* Start the tag after the { */
   tag = next + 1;
   in_cursor = s + 1;
   if (strncmp(tag, "name", 4) == 0) {
    strnfcat(buf, 1024, &end, "%s", name);
   }
  } else {
   /* An invalid tag, skip it */
   in_cursor = next + 1;
  }
  next = strchr(in_cursor, '{');
 }
 strnfcat(buf, 1024, &end, "%s", in_cursor);
}
/**
 * Print a message when an object flag is identified by use.
 *
 * \param flag is the flag being noticed
 * \param name is the object (or monster) name 
 */
void flag_message(int flag, char *name)
{
 struct obj_property *prop = lookup_obj_property(OBJ_PROPERTY_FLAG, flag);
 char buf[1024] = "\0";
 /* See if we have a message */
 if (!prop->msg) return;
 /* Insert */
 insert_name(buf, 1024, prop->msg, name);
 msg("%s", buf);
}
/**
 * Return a string when an object flag is identified by use.
 * Note that this makes a string which must be freed.
 *
 * \param flag is the flag being noticed
 * \param name is the object (or monster) name 
 */
bool flag_slay_message(int flag, char *name, char *message, int len)
{
 struct obj_property *prop = lookup_obj_property(OBJ_PROPERTY_FLAG, flag);
 char buf[1024] = "\0";
 /* See if we have a message */
 if (!prop->slay_msg) return false;
 /* Insert */
 insert_name(buf, 1024, prop->slay_msg, name);
 my_strcpy(message, buf, len);
 return true;
}
/**
 * Print a message when an object element property is identified by use.
 *
 * \param elem is the element being noticed
 * \param name is the object name 
 * \param vuln is whether it is a vulnerability being noticed
 */
void element_message(int elem, char *name, bool vuln)
{
 struct obj_property *prop = lookup_obj_property(OBJ_PROPERTY_RESIST, elem);
 char buf[1024] = "\0";
 /* Vulnerability */
 if (vuln) prop = lookup_obj_property(OBJ_PROPERTY_VULN, elem);
 /* See if we have a message */
 if (!prop->msg) return;
 /* Insert */
 insert_name(buf, 1024, prop->msg, name);
 msg("%s", buf);
}
/**
 * Return the sustain flag of a given stat.
 */
int sustain_flag(int stat)
{
 if (stat < 0 || stat >= STAT_MAX) return -1;
 return stat + 1;
}
/**
 * \file obj-slays.c
 * \brief Functions for manipulating slays/brands
 *
 * Copyright (c) 2010 Chris Carr and Peter Denison
 * Copyright (c) 2014 Nick McConnell
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
struct slay *slays;
struct brand *brands;
int lookup_slay(const char *code)
{
 int i;
 for (i = 1; i < z_info->slay_max; i++) {
  if (streq(slays[i].code, code)) return i;
 }
 return -1;
}
int lookup_brand(const char *code)
{
 int i;
 for (i = 1; i < z_info->brand_max; i++) {
  if (streq(brands[i].code, code)) return i;
 }
 return -1;
}
/**
 * Check if two slays affect the same set of monsters
 */
bool same_monsters_slain(int slay1, int slay2)
{
 if (slays[slay1].race_flag != slays[slay2].race_flag) return false;
 return true;
}
/**
 * Add all the slays from one structure to another
 *
 * \param dest the address the slays are going to
 * \param source the slays being copied
 */
void copy_slays(bool **dest, bool *source)
{
 int i, j;
 /* Check structures */
 if (!source) return;
 if (!(*dest)) {
  *dest = mem_zalloc(z_info->slay_max * sizeof(bool));
 }
 /* Copy */
 for (i = 0; i < z_info->slay_max; i++) {
  (*dest)[i] |= source[i];
 }
 /* Check for duplicates */
 for (i = 0; i < z_info->slay_max; i++) {
  for (j = 0; j < i; j++) {
   if ((*dest)[i] && (*dest)[j] && same_monsters_slain(i, j)) {
    (*dest)[j] = false;
   }
  }
 }
}
/**
 * Add all the brands from one structure to another
 *
 * \param dest the address the brands are going to
 * \param source the brands being copied
 */
void copy_brands(bool **dest, bool *source)
{
 int i, j;
 /* Check structures */
 if (!source) return;
 if (!(*dest))
  *dest = mem_zalloc(z_info->brand_max * sizeof(bool));
 /* Copy */
 for (i = 0; i < z_info->brand_max; i++)
  (*dest)[i] |= source[i];
 /* Check for duplicates */
 for (i = 0; i < z_info->brand_max; i++) {
  for (j = 0; j < i; j++) {
   if ((*dest)[i] && (*dest)[j] &&
    streq(brands[i].name, brands[j].name)) {
    (*dest)[j] = false;
   }
  }
 }
}
/**
 * Count a set of brands
 * \param brands The brands to count.
 */
int brand_count(const bool *brands_on)
{
 int i, count = 0;
 /* Count the brands */
 for (i = 0; i < z_info->brand_max; i++) {
  if (brands_on[i]) {
   count++;
  }
 }
 return count;
}
/**
 * Count a set of slays
 * \param slays The slays to count.
 */
int slay_count(const bool *slays_on)
{
 int i, count = 0;
 /* Count the slays */
 for (i = 0; i < z_info->slay_max; i++) {
  if (slays_on[i]) {
   count++;
  }
 }
 return count;
}
/**
 * React to slays which hurt a monster
 * 
 * \param slay is the slay we're testing for effectiveness
 * \param mon is the monster we're testing for being slain
 */
bool react_to_slay(struct slay *slay, const struct monster *mon)
{
 if (!slay->name) return false;
 if (!mon->race) return false;
 /* Check the race flag */
 if (rf_has(mon->race->flags, slay->race_flag))
  return true;
 return false;
}
/**
 * Extract the bonus dice from a given object hitting a given monster.
 *
 * \param player is the player performing the attack
 * \param obj is the object being used to attack
 * \param mon is the monster being attacked
 */
int slay_bonus(struct player *p, struct object *obj, const struct monster *mon,
      int *slay, int *brand)
{
 int i, dice = 0;
 bool scare = false;
 struct monster_lore *lore = get_lore(mon->race);
 if (!obj) return dice;
 /* Brands */
 for (i = 1; i < z_info->brand_max; i++) {
  struct brand *b = &brands[i];
  /* Is the object branded? */
  if (!obj->brands || !obj->brands[i]) continue;
  /* Is the monster vulnerable? */
  if (!rf_has(mon->race->flags, b->resist_flag)) {
   dice += b->dice;
   if (b->vuln_flag && rf_has(mon->race->flags, b->vuln_flag)) {
    dice += b->vuln_dice;
    scare = true;
   }
   *brand = i;
  } else {
   rf_on(lore->flags, b->resist_flag);
  }
 }
 /* Slays */
 for (i = 1; i < z_info->slay_max; i++) {
  struct slay *s = &slays[i];
  /* Does the object slay? */
  if (!obj->slays || !obj->slays[i]) continue;
  /* Is the monster vulnerable? */
  if (react_to_slay(s, mon)) {
   dice += s->dice;
   scare = true;
   *slay = i;
  } else {
   rf_on(lore->flags, s->race_flag);
  }
 }
 if (scare) {
  scare_onlooking_friends(mon, -20);
 }
 return dice;
}
/**
 * Print a message when a brand is identified by use.
 *
 * \param brand is the brand being noticed
 * \param name is the monster name 
 */
static bool brand_message(struct brand *brand, const struct monster *mon)
{
 char buf[1024] = "\0";
 char m_name[80];
 /* Extract monster name (or "it") */
 monster_desc(m_name, sizeof(m_name), mon, MDESC_TARG);
 /* See if we have a message */
 if (!brand->desc) return false;
 /* Insert */
 insert_name(buf, 1024, brand->desc, m_name);
 msg("%s", buf);
 return true;
}
/**
 * Help learn_brand_slay_{melee,launch,throw}().
 *
 * \param p is the player learning from the experience.
 * \param obj1 is an object directly involved in the attack.
 * \param obj2 is an auxiliary object (i.e. a launcher) involved in the attack.
 * \param mon is the monster being attacked.
 * \param allow_off is whether to include brands or slays from equipment that
 * isn't a weapon or launcher.
 * \param allow_temp is whether to include temporary brands or slays.
 */
static void learn_brand_slay_helper(struct player *p, struct object *obj1,
  struct object *obj2, const struct monster *mon)
{
 struct monster_lore *lore = get_lore(mon->race);
 int i;
 /* Handle brands. */
 for (i = 1; i < z_info->brand_max; i++) {
  struct brand *b;
  bool learn = false;
  /* Check the objects directly involved. */
  if (obj1 && obj1->brands && obj1->brands[i]) {
   learn = true;
  }
  if (obj2 && obj2->brands && obj2->brands[i]) {
   learn = true;
  }
  if (!learn) continue;
  b = &brands[i];
  if (!b->resist_flag || !rf_has(mon->race->flags, b->resist_flag)) {
   /* Learn the brand */
   if (!player_knows_brand(p, i)) {
    player_learn_brand(p, i);
    brand_message(b, mon);
   }
   /* Learn about the monster. */
   if (b->resist_flag) {
    lore_learn_flag_if_visible(lore, mon,
     b->resist_flag);
   }
   if (b->vuln_flag) {
    lore_learn_flag_if_visible(lore, mon,
     b->vuln_flag);
   }
  } else if (player_knows_brand(p, i)) {
   /* Learn about the monster. */
   lore_learn_flag_if_visible(lore, mon, b->resist_flag);
  }
 }
 /* Handle slays. */
 for (i = 1; i < z_info->slay_max; ++i) {
  struct slay *s;
  bool learn = false;
  /* Check the objects directly involved. */
  if (obj1 && obj1->slays && obj1->slays[i]) {
   learn = true;
  }
  if (obj2 && obj2->slays && obj2->slays[i]) {
   learn = true;
  }
  if (!learn) {
   continue;
  }
  s = &slays[i];
  if (react_to_slay(s, mon)) {
   /* Learn about the monster. */
   lore_learn_flag_if_visible(lore, mon, s->race_flag);
   if (monster_is_visible(mon)) {
    /* Learn the slay */
    if (!player_knows_slay(p, i)) {
     char o_name[80];
     object_desc(o_name, sizeof(o_name), obj1, ODESC_BASE, p);
     msg("Your %s strikes truly.", o_name);
     player_learn_slay(p, i);
    }
   }
  } else if (player_knows_slay(p, i)) {
   /* Learn about unaffected monsters. */
   lore_learn_flag_if_visible(lore, mon, s->race_flag);
  }
 }
}
/**
 * Learn about object and monster properties related to slays and brands from
 * a melee attack.
 *
 * \param p is the player learning from the experience.
 * \param weapon is the equipped weapon used in the attack; this is a parameter
 * to allow for the possibility of dual-wielding or body types with multiple
 * equipped weapons.  May be NULL for an unarmed attack.
 * \param mon is the monster being attacked.
 */
void learn_brand_slay_from_melee(struct player *p, struct object *weapon,
  const struct monster *mon)
{
 learn_brand_slay_helper(p, weapon, NULL, mon);
}
/**
 * Learn about object and monster properties related to slays and brands
 * from a ranged attack with a missile launcher.
 *
 * \param p is the player learning from the experience.
 * \param missile is the missile used in the attack.  Must not be NULL.
 * \param launcher is the launcher used in the attack; this is a parameter
 * to allow for body types with multiple equipped launchers.  Must not be NULL.
 * \param mon is the monster being attacked.
 */
void learn_brand_slay_from_launch(struct player *p, struct object *missile,
  struct object *launcher, const struct monster *mon)
{
 assert(missile && launcher);
 learn_brand_slay_helper(p, missile, launcher, mon);
}
/**
 * Learn about object and monster properties related to slays and brands
 * from a ranged attack with a thrown object.
 *
 * \param p is the player learning from the experience.
 * \param missile is the missile used in the attack.  Must not be NULL.
 * \param launcher is the launcher used in the attack; this is a parameter
 * to allow for body types with multiple equipped launchers.
 * \param mon is the monster being attacked.
 */
void learn_brand_slay_from_throw(struct player *p, struct object *missile,
  const struct monster *mon)
{
 assert(missile);
 learn_brand_slay_helper(p, missile, NULL, mon);
}
/**
 * \file obj-smith.c
 * \brief Smithing of objects
 *
 * Copyright (c) 1997 Ben Harrison
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 *
 */
/**
 * A list of tvals and their textual names and smithing categories
 */
const struct smithing_tval_desc smithing_tvals[MAX_SMITHING_TVALS] =
{
/**
 * \file list-smith-types.h
 * \brief List of smithing categories
 */
/* code_name, string_name */
{ SMITH_TYPE_WEAPON, TV_ARROW, "Arrows" },
{ SMITH_TYPE_WEAPON, TV_BOW, "Bow" },
{ SMITH_TYPE_WEAPON, TV_DIGGING, "Digger" },
{ SMITH_TYPE_WEAPON, TV_HAFTED, "Blunt Weapon" },
{ SMITH_TYPE_WEAPON, TV_POLEARM, "Axe or Polearm" },
{ SMITH_TYPE_WEAPON, TV_SWORD, "Sword" },
{ SMITH_TYPE_ARMOUR, TV_BOOTS, "Boots" },
{ SMITH_TYPE_ARMOUR, TV_GLOVES, "Gloves" },
{ SMITH_TYPE_ARMOUR, TV_HELM, "Helm" },
{ SMITH_TYPE_ARMOUR, TV_CROWN, "Crown" },
{ SMITH_TYPE_ARMOUR, TV_SHIELD, "Shield" },
{ SMITH_TYPE_ARMOUR, TV_CLOAK, "Cloak" },
{ SMITH_TYPE_ARMOUR, TV_SOFT_ARMOR, "Soft Armour" },
{ SMITH_TYPE_ARMOUR, TV_MAIL, "Mail" },
{ SMITH_TYPE_JEWELRY, TV_LIGHT, "Light" },
{ SMITH_TYPE_JEWELRY, TV_AMULET, "Amulet" },
{ SMITH_TYPE_JEWELRY, TV_RING, "Ring" },
{ SMITH_TYPE_JEWELRY, TV_HORN, "Horn" },

};
/**
 * ------------------------------------------------------------------------
 * Helper functions used mainly in the numbers menu
 * ------------------------------------------------------------------------ */
/**
 * Determines whether the attack bonus of an item is eligible for modification.
 */
int att_valid(struct object *obj)
{
 struct object_base *base = obj->kind->base;
 struct object_kind *kind;
 if (base->smith_attack_valid) return true;
 /* Rings are a special case */
 if (strstr(base->name, "Ring")) {
  kind = lookup_kind(base->tval, lookup_sval(base->tval, "Accuracy"));
  if (kind == obj->kind) return true;
  if (obj->artifact) return true;
 }
 return false;
}
/**
 * Determines the maximum legal attack bonus for an item.
 */
int att_max(struct object *obj, bool assume_artistry)
{
 struct object_base *base = obj->kind->base;
 struct object_kind *kind = obj->kind;
 struct ego_item *ego = obj->ego;
 int att = kind->att;
 bool artistry = assume_artistry ||
  player_active_ability(player, "Artistry");
 if (artistry) att += base->smith_attack_artistry;
 if (!tval_is_weapon(obj)) att = MIN(0, att);
 if (ego) att += ego->att;
 if (obj->artifact) att += base->smith_attack_artefact;
 /* Rings are a special case */
 if (strstr(base->name, "Ring")) {
  kind = lookup_kind(base->tval, lookup_sval(base->tval, "Accuracy"));
  if (kind == obj->kind) att = 4;
  if (obj->artifact) att = 4;
 }
 return att;
}
/**
 * Determines the minimum legal attack bonus for an item.
 */
int att_min(struct object *obj)
{
 struct object_base *base = obj->kind->base;
 struct object_kind *kind = obj->kind;
 struct ego_item *ego = obj->ego;
 int att = kind->att;
 if (ego && (ego->att > 0)) att += 1;
 /* Rings are a special case */
 if (strstr(base->name, "Ring")) {
  kind = lookup_kind(base->tval, lookup_sval(base->tval, "Accuracy"));
  if (kind == obj->kind) att = 1;;
 }
 return att;
}
/**
 * Determines whether the damage sides of an item is eligible for modification.
 */
int ds_valid(struct object *obj)
{
 return tval_is_melee_weapon(obj) || tval_is_launcher(obj);
}
/**
 * Determines the maximum legal damage sides for an item.
 */
int ds_max(struct object *obj, bool assume_artistry)
{
 struct object_kind *kind = obj->kind;
 struct ego_item *ego = obj->ego;
 int ds = kind->ds;
    bool artistry = assume_artistry ||
  player_active_ability(player, "Artistry");
 if (artistry) ds += 1;
 if (ego) ds += ego->ds;
 if (obj->artifact) ds += 2;
 return ds;
}
/**
 * Determines the minimum legal damage sides for an item.
 */
int ds_min(struct object *obj)
{
 struct object_kind *kind = obj->kind;
 struct ego_item *ego = obj->ego;
 int ds = kind->ds;
 if (ds_valid(obj) && ego && (ego->ds > 0)) ds += 1;
 return ds;
}
/**
 * Determines whether the evasion bonus of an item is eligible for modification.
 */
int evn_valid(struct object *obj)
{
 struct object_base *base = obj->kind->base;
 struct object_kind *kind;
 if (tval_is_armor(obj)) return true;
 if (tval_is_melee_weapon(obj) && !tval_is_digger(obj)) return true;
 /* Rings are a special case */
 if (strstr(base->name, "Ring")) {
  kind = lookup_kind(base->tval, lookup_sval(base->tval, "Evasion"));
  if (kind == obj->kind) return true;
  if (obj->artifact) return true;
 }
 return false;
}
/**
 * Determines the maximum legal evasion bonus for an item.
 */
int evn_max(struct object *obj, bool assume_artistry)
{
 struct object_kind *kind = obj->kind;
 struct object_base *base = kind->base;
 struct ego_item *ego = obj->ego;
 int evn = kind->evn;
    bool artistry = assume_artistry ||
  player_active_ability(player, "Artistry");
 if (tval_is_armor(obj) && artistry) evn += 1;
 if (ego) evn += ego->evn;
 if (obj->artifact) evn += 1;
 /* Rings are a special case */
 if (strstr(base->name, "Ring")) {
  kind = lookup_kind(base->tval, lookup_sval(base->tval, "Evasion"));
  if (kind == obj->kind) evn = 4;
  if (obj->artifact) evn = 4;
 }
 return evn;
}
/**
 * Determines the minimum legal evasion bonus for an item.
 */
int evn_min(struct object *obj)
{
 struct object_kind *kind = obj->kind;
 struct object_base *base = kind->base;
 struct ego_item *ego = obj->ego;
 int evn = kind->evn;
 if (ego && (ego->evn > 0)) evn += 1;
 /* Rings are a special case */
 if (strstr(base->name, "Ring")) {
  kind = lookup_kind(base->tval, lookup_sval(base->tval, "Evasion"));
  if (kind == obj->kind) evn = 1;
 }
 return evn;
}
/**
 * Determines whether the protection sides of an item is eligible for
 * modification.
 */
int ps_valid(struct object *obj)
{
 struct object_base *base = obj->kind->base;
 struct object_kind *kind;
 if (tval_is_armor(obj)) return true;
 /* Rings are a special case */
 if (strstr(base->name, "Ring")) {
  kind = lookup_kind(base->tval, lookup_sval(base->tval, "Protection"));
  if (kind == obj->kind) return true;
  if (obj->artifact) return true;
 }
 return false;
}
/**
 * Determines the maximum legal protection sides for an item.
 */
int ps_max(struct object *obj, bool assume_artistry)
{
 struct object_kind *kind = obj->kind;
 struct object_base *base = kind->base;
 struct ego_item *ego = obj->ego;
 int ps = kind->ps;
    bool artistry = assume_artistry ||
  player_active_ability(player, "Artistry");
 if (artistry) ps += 1;
 /* Cloaks, robes and filthy rags cannot get extra protection sides */
 if (strstr(base->name, "Cloak")) ps = 0;
 if (strstr(base->name, "Soft Armor")) {
  if (kind == lookup_kind(base->tval,
        lookup_sval(base->tval, "Filthy Rag"))) ps = 0;
  if (kind == lookup_kind(base->tval,
        lookup_sval(base->tval, "Robe"))) ps = 0;
 }
 if (ego) ps += ego->ps;
 if (obj->artifact) ps += 2;
 /* Rings are a special case */
 if (strstr(base->name, "Ring")) {
  kind = lookup_kind(base->tval, lookup_sval(base->tval, "Protection"));
  if (kind == obj->kind) ps = 3;
  if (obj->artifact) ps = 3;
 }
 return ps;
}
/**
 * Determines the minimum legal protection sides for an item.
 */
int ps_min(struct object *obj)
{
 struct object_kind *kind = obj->kind;
 struct object_base *base = kind->base;
 struct ego_item *ego = obj->ego;
 int ps = kind->ps;
 if (ego && (ego->ps > 0)) ps += 1;
 /* Rings are a special case */
 if (strstr(base->name, "Ring")) {
  kind = lookup_kind(base->tval, lookup_sval(base->tval, "Protection"));
  if (kind == obj->kind) ps = 1;
 }
 return ps;
}
/**
 * Determines whether the pval of an item is eligible for modification.
 */
int pval_valid(struct object *obj)
{
 int i;
 for (i = 0; i < OBJ_MOD_MAX; i++) {
  if (obj->modifiers[i] != 0) return true;
 }
 return (obj->pval != 0);
}
/**
 * Determines the default (starting) pval for an item.
 */
int pval_default(struct object *obj)
{
 int pval = extract_kind_pval(obj->kind, AVERAGE, NULL);
 if (obj->ego && obj->ego->pval > 0) {
  pval += obj_is_cursed(obj) ? -1 : 1;
 }
 return pval;
}
/**
 * Determines the maximum legal pval for an item.
 */
int pval_max(struct object *obj)
{
 int pval = extract_kind_pval(obj->kind, MAXIMISE, NULL);
 /* Artefacts have pvals that are mostly unlimited  */
 if (obj->artifact) {
  pval += 4;
 } else if (tval_is_jewelry(obj)) {
  /* Non-artefact rings and amulets have a maximum pval of 4 */
  pval = 4;
 }
 /* Special items have limited pvals */
 if (obj->ego) {
  if (obj_is_cursed(obj)) {
   if (obj->ego->pval > 0) pval -= 1;
  } else {
   pval += obj->ego->pval;
  }
 }
 return pval;
}
/**
 * Determines the minimum legal pval for an item.
 */
int pval_min(struct object *obj)
{
 int pval = extract_kind_pval(obj->kind, MINIMISE, NULL);
 /* Artefacts have pvals that are mostly unlimited  */
 if (obj->artifact) {
  pval -= 4;
 } else if (tval_is_jewelry(obj)) {
  /* Non-artefact rings and amulets have a maximum pval of 4 */
  pval = -4;
 }
 /* Special items have limited pvals */
 if (obj->ego) {
  if (obj_is_cursed(obj)) {
   if (obj->ego->pval > 0) pval -= obj->ego->pval;
  } else if (obj->ego->pval > 0) {
   pval += 1;
  }
 }
 return pval;
}
/**
 * Determines whether the weight of an item is eligible for modification.
 */
int wgt_valid(struct object *obj)
{
 switch (obj->tval) {
  case TV_ARROW:
  case TV_RING:
  case TV_AMULET:
  case TV_LIGHT:
  case TV_HORN: {
   return false;
  }
 }
 return true;
}
/**
 * Determines the maximum legal weight for an item.
 */
int wgt_max(struct object *obj)
{
 return obj->kind->weight * 2;
}
/**
 * Determines the minimum legal weight for an item.
 */
int wgt_min(struct object *obj)
{
    return ((obj->kind->weight + 9) / 10) * 5;
}
/**
 * Actually modifies the numbers on an item.
 */
void modify_numbers(struct object *obj, int choice, int *pval)
{
 switch (choice) {
  case SMITH_NUM_INC_ATT: {
   if (tval_is_ammo(obj) && !obj->artifact) {
    obj->att += 3;
   } else {
    obj->att++;
   }
   break;
  }
  case SMITH_NUM_DEC_ATT: {
   if (tval_is_ammo(obj) && !obj->artifact) {
    obj->att -= 3;
   } else {
    obj->att--;
   }
   break;
  }
  case SMITH_NUM_INC_DS: obj->ds++; break;
  case SMITH_NUM_DEC_DS: obj->ds--; break;
  case SMITH_NUM_INC_EVN: obj->evn++; break;
  case SMITH_NUM_DEC_EVN: obj->evn--; break;
  case SMITH_NUM_INC_PS: obj->ps++; break;
  case SMITH_NUM_DEC_PS: obj->ps--; break;
  case SMITH_NUM_INC_PVAL: {
   //if (*pval == -1) {
   //	*pval = 1;
   //} else {
    (*pval)++;
    //}
   break;
  }
  case SMITH_NUM_DEC_PVAL: {
   //if (*pval == 1) {
   //	*pval = -1;
   //} else {
    (*pval)--;
    //}
   break;
  }
  case SMITH_NUM_INC_WGT: obj->weight += 5; break;
  case SMITH_NUM_DEC_WGT: obj->weight -= 5; break;
 }
 return;
}
/**
 * ------------------------------------------------------------------------
 * Handling of mithril
 * ------------------------------------------------------------------------ */
bool object_is_mithril(const struct object *obj)
{
 return of_has(obj->flags, OF_MITHRIL);
}
bool melt_mithril_item(struct player *p, struct object *obj)
{
 struct object_kind *mithril_kind = lookup_kind(TV_METAL,
  lookup_sval(TV_METAL, "Piece of Mithril"));
 /*
	 * Weights in [1, max_stack] need zero slots, weights in
	 * [max_stack + 1, 2 * max_stack] need one slot, ...
	 */
 int slots_needed = (obj->weight - 1) / mithril_kind->base->max_stack;
 int empty_slots = z_info->pack_size - pack_slots_used(p);
 /* Equipment needs an extra slot */
 if (object_is_equipped(p->body, obj)) slots_needed++;
 /*
	 * The melted item generates zero or more stacks of max_stack pieces
	 * and one stack with between one piece and max_stack pieces.  If
	 * there is already mithril in the pack, that last stack may combine
	 * with it.  Then, one less slot is needed.
	 */
 if (slots_needed > 0) {
  int remainder = obj->weight % mithril_kind->base->max_stack;
  if (remainder) {
   struct object *gear_obj;
   for (gear_obj = p->gear; gear_obj;
     gear_obj = gear_obj->next) {
    if (gear_obj->tval == mithril_kind->tval
      && gear_obj->sval
      == mithril_kind->sval
      && gear_obj->number + remainder
      <= mithril_kind->base->max_stack
      && !object_is_equipped(p->body,
      gear_obj)) {
     --slots_needed;
     break;
    }
   }
  }
 }
 if (empty_slots < slots_needed) {
  msg("You do not have enough room in your pack.");
  if (slots_needed - empty_slots == 1) {
   msg("You must free up another slot.");
  } else {
   msg("You must free up %d more slots.", slots_needed - empty_slots);
  }
  return false;
 }
 if (get_check("Are you sure you wish to melt this item down? ")) {
  struct object *new = object_new();
  struct object *new_k = object_new();
  /* Remember the total pieces of mithril generated. */
  int16_t pieces_remaining = obj->weight;
  /* Prepare the base object for the mithril */
  object_prep(new, mithril_kind, p->depth, RANDOMISE);
  /* Stop tracking item */
  if (tracked_object_is(p->upkeep, obj))
   track_object(p->upkeep, NULL);
  /* Delete */
  gear_excise_object(p, obj);
  assert(obj->known);
  object_delete(p->cave, NULL, &obj->known);
  object_delete(cave, p->cave, &obj);
  /* Inventory has changed, so disable repeat command */
  cmd_disable_repeat();
  /* Give the mithril to the player, breaking it up if there's too much */
  while (pieces_remaining > new->kind->base->max_stack) {
   struct object *new2 = object_new();
   struct object *new2_k = object_new();
   /* Decrease the main stack */
   pieces_remaining -= new->kind->base->max_stack;
   /* Prepare the base object for the mithril */
   object_prep(new2, mithril_kind, 0, MINIMISE);
   /* Increase the new stack */
   new2->number = new->kind->base->max_stack;
   /* Set up the player's version of the mithril */
   object_copy(new2_k, new2);
   new2->known = new2_k;
   object_touch(p, new2);
   /* Give it to the player */
   inven_carry(p, new2, true, false);
  }
  /* Now give the last stack of mithril to the player */
  new->number = (uint8_t)pieces_remaining;
  object_copy(new_k, new);
  new->known = new_k;
  object_touch(p, new);
  inven_carry(p, new, true, false);
  return true;
 }
 return false;
}
int mithril_items_carried(struct player *p)
{
 int number = 0;
 struct object *obj;
 for (obj = p->gear; obj; obj = obj->next) {
  if (of_has(obj->flags, OF_MITHRIL)) {
   number++;
  }
 }
 return number;
}
int mithril_carried(struct player *p)
{
 int weight = 0;
 struct object *obj;
  struct object_kind *kind = lookup_kind(TV_METAL,
              lookup_sval(TV_METAL,
                 "Piece of Mithril"));
 for (obj = p->gear; obj; obj = obj->next) {
  if (obj->kind == kind) {
   weight += obj->number;
  }
 }
 return weight;
}
static void use_mithril(struct player *p, int cost)
{
 struct object *obj = p->gear;
 struct object_kind *kind = lookup_kind(TV_METAL,
  lookup_sval(TV_METAL, "Piece of Mithril"));
 int to_go = cost;
 while (obj && to_go) {
  if (obj->kind == kind) {
   int amount = MIN(to_go, obj->number);
   bool none_left = false;
   struct object *src = obj, *used;
   obj = obj->next;
   used = gear_object_for_use(p, src, amount, true,
    &none_left);
   assert(used->known);
   object_delete(p->cave, NULL, &used->known);
   object_delete(cave, p->cave, &used);
   to_go -= amount;
  } else {
   obj = obj->next;
  }
 }
}
/**
 * ------------------------------------------------------------------------
 * Difficulty and cost routines
 * ------------------------------------------------------------------------ */
/**
 * Determines the difficulty modifier for pvals.
 *
 * The marginal difficulty of increasing a pval increases by 1 each time,
 * if the base is up to 5, by 2 each time if the base is 6--10, and so on.
 */
static void dif_mod(int value, int positive_base, int *dif_inc)
{
 int mod = 1 + ((positive_base - 1) / 5);
 /* Deal with positive values in a triangular number influenced way */
 if (value > 0) {
  *dif_inc += positive_base * value + mod * (value * (value - 1) / 2);
 }
}
/**
 * Adjust smithing cost for a given object property
 */
static void adjust_smithing_cost(int diff, struct obj_property *prop, struct smithing_cost *smithing_cost)
{
 if (diff <= 0) return;
 switch (prop->smith_cost_type) {
  case SMITH_COST_STR: smithing_cost->stat[STAT_STR] += diff * prop->smith_cost; break;
  case SMITH_COST_DEX: smithing_cost->stat[STAT_DEX] += diff * prop->smith_cost; break;
  case SMITH_COST_CON: smithing_cost->stat[STAT_CON] += diff * prop->smith_cost; break;
  case SMITH_COST_GRA: smithing_cost->stat[STAT_GRA] += diff * prop->smith_cost; break;
  case SMITH_COST_EXP: smithing_cost->exp += diff * prop->smith_cost; break;
 }
}
/**
 * Determines the difficulty of a given object.
 */
int object_difficulty(struct object *obj, struct smithing_cost *smithing_cost)
{
 struct object_kind *kind = obj->kind;
 int att = (kind->att == SPECIAL_VALUE) ? 0 : kind->att;
 int evn = (kind->evn == SPECIAL_VALUE) ? 0 : kind->evn;
 int ps = (kind->ps == SPECIAL_VALUE) ? 0 : kind->ps;
 bitflag flags[OF_MAX];
 int dif_inc = 0, dif_dec = 0;
 int i, weight_factor, diff, new, base;
 int smith_brands = 0;
 struct ability *ability = obj->abilities;
 int dif_mult = 100;
 int drain = player->state.skill_use[SKILL_SMITHING] +
  square_forge_bonus(cave, player->grid);
 int cat = 0;
 /*
	 * Jewelry gets special treatment: namely no exclusion of base item
	 * properties from difficulty and cost.
	 */
 bool jewelry = tval_is_jewelry(obj);
 /* Reset smithing costs */
 smithing_cost->stat[STAT_STR] = 0;
 smithing_cost->stat[STAT_DEX] = 0;
 smithing_cost->stat[STAT_CON] = 0;
 smithing_cost->stat[STAT_GRA] = 0;
 smithing_cost->exp = 0;
 smithing_cost->mithril = 0;
 smithing_cost->uses = 1;
 smithing_cost->drain = 0;
    smithing_cost->weaponsmith = 0;
    smithing_cost->armoursmith = 0;
    smithing_cost->jeweller = 0;
    smithing_cost->enchantment = 0;
    smithing_cost->artistry = 0;
    smithing_cost->artifice = 0;
 of_copy(flags, obj->flags);
   /* Special rules for horns */
    if (tval_is_horn(obj)) {
        dif_inc += kind->level;
  if (strstr(obj->kind->name, "Terror")) {
   smithing_cost->stat[STAT_GRA] += 1;
  } else if (strstr(obj->kind->name, "Thunder")) {
   smithing_cost->stat[STAT_DEX] += 1;
  } else if (strstr(obj->kind->name, "Force")) {
   smithing_cost->stat[STAT_STR] += 1;
  } else if (strstr(obj->kind->name, "Blasting")) {
   smithing_cost->stat[STAT_CON] += 1;
  }
 } else if (!jewelry) {
  dif_inc += kind->level / 2;
 }
 /* Unusual weight */
    if (obj->weight == 0) {
  weight_factor = 1100;
 } else if (obj->weight > kind->weight) {
  weight_factor = 100 * obj->weight / kind->weight;
 } else {
  weight_factor = 100 * kind->weight / obj->weight;
 }
 dif_inc += (weight_factor - 100) / 10;
 /* Attack bonus */
 diff = obj->att - att;
 /* Special costs for attack bonus for arrows (half difficulty modifier) */
 if (tval_is_ammo(obj) && (diff > 0)) {
  int old_dif_inc = dif_inc;
  dif_mod(diff, 5, &dif_inc);
  dif_inc = (dif_inc - old_dif_inc) / 2;
 } else {
  /* Normal costs for other items */
  dif_mod(diff, 5, &dif_inc);
 }
 /* Evasion bonus */
 diff = obj->evn - evn;
 dif_mod(diff, 5, &dif_inc);
 /* Damage bonus */
 diff = (obj->ds - kind->ds);
 dif_mod(diff, 8 + obj->dd, &dif_inc);
 /* Protection bonus */
 base = (ps > 0) ? ((ps + 1) * kind->pd) : 0;
 new = (obj->ps > 0) ? ((obj->ps + 1) * obj->pd) : 0;
 diff = new - base;
 dif_mod(diff, 4, &dif_inc);
 /* Object properties */
 for (i = 1; i < z_info->property_max; i++) {
  struct obj_property *prop = &obj_properties[i];
  switch (prop->type) {
   case OBJ_PROPERTY_STAT:
   case OBJ_PROPERTY_SKILL:
   case OBJ_PROPERTY_MOD: {
    diff = obj->modifiers[prop->index];
    if (!jewelry && prop->smith_exclude_base) {
     diff -= randcalc(
      obj->kind->modifiers[prop->index],
      0, AVERAGE);
    }
    if (diff != 0) {
     dif_mod(diff, prop->smith_diff, &dif_inc);
     adjust_smithing_cost(diff, prop, smithing_cost);
    }
    break;
   }
   case OBJ_PROPERTY_FLAG: {
    if (of_has(flags, prop->index)
      && (jewelry
      || !prop->smith_exclude_base
      || !of_has(kind->flags, prop->index))) {
     if (prop->smith_diff > 0) {
      dif_inc += prop->smith_diff;
      adjust_smithing_cost(1, prop, smithing_cost);
     } else if (prop->smith_diff < 0) {
      dif_dec -= prop->smith_diff;
     }
    }
    break;
   }
   case OBJ_PROPERTY_RESIST: {
    if (obj->el_info[prop->index].res_level == 1
      && (jewelry
      || !prop->smith_exclude_base
      || kind->el_info[prop->index].res_level == 0)) {
     dif_inc += prop->smith_diff;
     adjust_smithing_cost(1, prop, smithing_cost);
    }
    break;
   }
   case OBJ_PROPERTY_SLAY: {
    if (obj->slays && obj->slays[prop->index]
      && (jewelry
      || !prop->smith_exclude_base
      || !(kind->slays
      && kind->slays[prop->index]))) {
     dif_inc += prop->smith_diff;
    }
    break;
   }
   case OBJ_PROPERTY_BRAND: {
    if (obj->brands && obj->brands[prop->index]
      && (jewelry
      || !prop->smith_exclude_base
      || !(kind->brands
      && kind->brands[prop->index]))) {
     dif_inc += prop->smith_diff;
     adjust_smithing_cost(1, prop, smithing_cost);
     smith_brands++;
    }
    break;
   }
  }
 }
 /* Extra difficulty for multiple brands */
 if (smith_brands > 1) {
  dif_inc += (smith_brands - 1) * 20;
 }
 /* Abilities */
 while (ability) {
  dif_inc += 5 + ability->level / 2;
  smithing_cost->exp += 500;
  ability = ability->next;
 }
 /* Mithril */
 if (of_has(kind->flags, OF_MITHRIL)) {
  smithing_cost->mithril += obj->weight;
 }
 /* Penalty for being an artefact */
 if (obj->artifact) {
  smithing_cost->uses += 2;
 }
 /* Cap the difficulty reduction at 8 */
 dif_dec = MIN(dif_dec, 8);
 /* Set the overall difficulty */
 diff = dif_inc - dif_dec;
 /* Increased difficulties for minor slots */
 if (tval_is_ring(obj) || tval_is_light(obj) || tval_is_cloak(obj) ||
  tval_is_gloves(obj) || tval_is_boots(obj) || tval_is_ammo(obj)) {
  dif_mult += 20;
 }
 /* Decreased difficulties for easily enchatable items */
 if (of_has(kind->flags, OF_ENCHANTABLE)) {
  dif_mult -= 20;
 }
 /* Apply the difficulty multiplier */
 diff = diff * dif_mult / 100;
    /* Artefact arrows are much easier */
    if (tval_is_ammo(obj) && (obj->number == 1)) diff /= 2;
 /* Deal with masterpiece */
 if ((diff > drain) && player_active_ability(player, "Masterpiece")) {
  smithing_cost->drain += diff - drain;
 }
    /* Determine which additional smithing abilities would be required */
    for (i = 0; i < MAX_SMITHING_TVALS; i++) {
        if (smithing_tvals[i].tval == obj->tval) {
   cat = smithing_tvals[i].category;
  }
 }
    if ((cat == SMITH_TYPE_WEAPON) &&
  !player_active_ability(player, "Weaponsmith")) {
  smithing_cost->weaponsmith = 1;
    }
    if ((cat == SMITH_TYPE_ARMOUR) &&
  !player_active_ability(player, "Armoursmith")) {
  smithing_cost->armoursmith = 1;
    }
    if ((cat == SMITH_TYPE_JEWELRY)
  && !player_active_ability(player, "Jeweller")) {
  smithing_cost->jeweller = 1;
    }
    if (obj->artifact && !player_active_ability(player, "Artifice")) {
  smithing_cost->artifice = 1;
    }
    if (obj->ego && !player_active_ability(player, "Enchantment")) {
  smithing_cost->enchantment = 1;
    }
    if ((att_valid(obj) && (obj->att > att_max(obj, false))) ||
  (ds_valid(obj) && (obj->ds > ds_max(obj, false))) ||
  (evn_valid(obj) && (obj->evn > evn_max(obj, false))) ||
  (ps_valid(obj) && (obj->ps > ps_max(obj, false)))) {
  smithing_cost->artistry = 1;
    }
 return diff;
}
/**
 * Determines whether an item is too difficult to make.
 */
static int too_difficult(struct object *obj)
{
 struct smithing_cost dummy;
 int dif = object_difficulty(obj, &dummy);
 int ability = player->state.skill_use[SKILL_SMITHING] +
  square_forge_bonus(cave, player->grid);
 if (player_active_ability(player, "Masterpiece")) {
  ability += player->skill_base[SKILL_SMITHING];
 }
 return ability < dif;
}
/**
 * Checks whether a stat is great enough to accommodate a given cost
 */
static bool check_stat_drain(struct player *p, int stat, int cost)
{
 int usable_stat = p->stat_base[stat] + p->stat_drain[stat];
 if (cost <= 0) return true;
 return usable_stat - cost >= -5;
}
/**
 * Checks whether you can pay the costs in terms of ability points and
 * experience needed to make the object.
 */
bool smith_affordable(struct object *obj, struct smithing_cost *smithing_cost)
{
 int stat;
 /* Can't afford non-existent items */
 if (!obj->kind) return false;
 /* Check difficulty */
 if (too_difficult(obj)) return false;
 /* Check stat costs */
 for (stat = 0; stat < STAT_MAX; stat++) {
  if (!check_stat_drain(player, stat, smithing_cost->stat[stat])) {
   return false;
  }
 }
 /* Check XP cost */
 if (smithing_cost->exp > player->new_exp) return false;
 /* Check mithril */
 if ((smithing_cost->mithril > 0) &&
  (smithing_cost->mithril > mithril_carried(player))) {
  return false;
 }
 /* Check forge uses */
 if (square_forge_uses(cave, player->grid) < smithing_cost->uses) {
  return false;
    }
 /* Check abilities */
    if (smithing_cost->weaponsmith || smithing_cost->armoursmith ||
  smithing_cost->jeweller || smithing_cost->enchantment ||
  smithing_cost->artistry || smithing_cost->artifice) {
  return false;
 }
 return true;
}
/**
 * Pay the costs in terms of ability points and experience needed to smith
 * the current object.
 */
static void smith_pay_costs(struct smithing_cost *smithing_cost)
{
 int stat;
 /* Charge */
 for (stat = 0; stat < STAT_MAX; stat++) {
  if (smithing_cost->stat[stat] > 0) {
   player->stat_drain[stat] -= smithing_cost->stat[stat];
  }
 }
 /* Charge */
 if (smithing_cost->exp > 0) {
  player->new_exp -= smithing_cost->exp;
 }
 /* Charge */
 if (smithing_cost->mithril > 0) {
  use_mithril(player, smithing_cost->mithril);
 }
 /* Charge */
 if (smithing_cost->uses > 0) {
  int uses = square_forge_uses(cave, player->grid);
  assert(uses >= smithing_cost->uses);
  square_set_forge(cave, player->grid, uses - smithing_cost->uses);
 }
 /* Charge */
 if (smithing_cost->drain > 0) {
  player->skill_base[SKILL_SMITHING] -= smithing_cost->drain;
 }
 /* Calculate the bonuses */
 player->upkeep->update |= (PU_BONUS);
 /* Set the redraw flag for everything */
 player->upkeep->redraw |= (PR_EXP | PR_BASIC);
}
/**
 * ------------------------------------------------------------------------
 * Object creation routines
 * ------------------------------------------------------------------------ */
/**
 * Set modifiers or other values for base object to 1 where needed
 */
static void set_base_values(struct object *obj)
{
 int i;
 if (obj->kind->att == SPECIAL_VALUE) {
  obj->att = 1;
 }
 if (obj->kind->evn == SPECIAL_VALUE) {
  obj->evn = 1;
 }
 if (obj->kind->ps == SPECIAL_VALUE) {
  obj->ps = 1;
 }
 for (i = 0; i < OBJ_MOD_MAX; i++) {
  /* Hackish calculations needed here */
  if ((obj->kind->modifiers[i].base == SPECIAL_VALUE) ||
   (obj->kind->modifiers[i].m_bonus)) {
   obj->modifiers[i] = 1;
   obj->pval = 1;
  }
 }
}
/**
 * Creates the base object (not in the dungeon, but just as a work in progress).
 */
void create_base_object(struct object_kind *kind, struct object *obj)
{
 /* Wipe the object */
 memset(obj, 0, sizeof(*obj));
 /* Prepare the item */
 object_prep(obj, kind, 0, AVERAGE);
 /* Set the pval to 1 if needed (and evasion/accuracy for rings) */
 set_base_values(obj);
 if (tval_is_light(obj)) {
  /*
		 * While smithing, use pval for the special bonus rather than
		 * light radius; restore it when finalizing the smithed item
		 */
  obj->pval = 0;
  /* Lanterns are empty */
  if (of_has(obj->flags, OF_TAKES_FUEL)) {
   obj->timeout = 0;
  }
 }
 /* Create arrows by the two dozen */
 if (tval_is_ammo(obj)) {
  obj->number = 24;
 }
}
/**
 * Set an object to the specified special type
 */
void create_special(struct object *obj, struct ego_item *ego)
{
 /* Recreate base object */
 struct object_kind *kind = obj->kind;
 if (obj->slays) mem_free(obj->slays);
 if (obj->brands) mem_free(obj->brands);
 if (obj->abilities) {
  release_ability_list(obj->abilities);
 }
 create_base_object(kind, obj);
 /* Set its 'special' type to reflect the chosen type */
 obj->ego = ego;
 /* Make it into that special type */
 ego_apply_magic(obj, true);
}
/**
 * Copy artifact fields from a_src to a_dst
 */
void artefact_copy(struct artifact *a_dst, struct artifact *a_src)
{
 mem_free(a_dst->slays);
 mem_free(a_dst->brands);
 release_ability_list(a_dst->abilities);
 /* Copy the structure */
 memcpy(a_dst, a_src, sizeof(struct artifact));
 a_dst->next = NULL;
 a_dst->slays = NULL;
 a_dst->brands = NULL;
 a_dst->abilities = NULL;
 if (a_src->slays) {
  a_dst->slays = mem_zalloc(z_info->slay_max * sizeof(bool));
  memcpy(a_dst->slays, a_src->slays, z_info->slay_max * sizeof(bool));
 }
 if (a_src->brands) {
  a_dst->brands = mem_zalloc(z_info->brand_max * sizeof(bool));
  memcpy(a_dst->brands, a_src->brands, z_info->brand_max * sizeof(bool));
 }
 if (a_src->abilities) {
  a_dst->abilities = copy_ability_list(a_src->abilities);
 }
}
/**
 * Fills in the details on an artefact type from an object.
 */
void add_artefact_details(struct artifact *art, struct object *obj)
{
 int i;
 struct smithing_cost dummy;
 /* Skip using an artifact index of zero. */
 art->aidx = (z_info->a_max) ? z_info->a_max : 1;
 art->tval = obj->tval;
 art->sval = obj->sval;
 art->pval = obj->pval;
 art->att = obj->att;
 art->evn = obj->evn;
 art->dd = obj->dd;
 art->ds = obj->ds;
 art->pd = obj->pd;
 art->ps = obj->ps;
 art->weight = obj->weight;
 of_union(art->flags, obj->flags);
 for (i = 0; i < OBJ_MOD_MAX; i++) {
  art->modifiers[i] = obj->modifiers[i];
 }
 for (i = 0; i < ELEM_MAX; i++) {
  art->el_info[i].res_level = obj->el_info[i].res_level;
  art->el_info[i].flags = obj->el_info[i].flags;
 }
 copy_slays(&art->slays, obj->slays);
 copy_brands(&art->brands, obj->brands);
 if (obj->abilities) {
  struct ability *ability = obj->abilities;
  while (ability) {
   add_ability(&art->abilities, ability);
   ability = ability->next;
  }
 }
 art->level = object_difficulty(obj, &dummy);
 art->rarity = 10;
}
/**
 * Does the given object type support the given property type?
 */
bool applicable_property(struct obj_property *prop, struct object *obj)
{
 struct object_base *base = obj->kind->base;
 bool valid = false;
 int idx = prop ? prop->index : -1;
 char name[80];
 assert(idx >= 0);
 switch (prop->type) {
  case OBJ_PROPERTY_STAT:
  case OBJ_PROPERTY_SKILL:
  case OBJ_PROPERTY_MOD: {
   if (base->smith_modifiers[idx] != 0) valid = true;
   break;
  }
  case OBJ_PROPERTY_FLAG: {
   if (of_has(base->smith_flags, idx)) valid = true;
   break;
  }
  case OBJ_PROPERTY_RESIST: {
   if (base->smith_el_info[idx].res_level >= 1) valid = true;
   break;
  }
  case OBJ_PROPERTY_VULN: {
   if ((base->smith_el_info[idx].res_level == -1) ||
    (base->smith_el_info[idx].res_level == 2))
    valid = true;
   break;
  }
  case OBJ_PROPERTY_SLAY: {
   if (base->smith_slays && (base->smith_slays[idx]))
    valid = true;
   break;
  }
  case OBJ_PROPERTY_BRAND: {
   if (base->smith_brands && (base->smith_brands[idx]))
    valid = true;
   break;
  }
 }
 /* Smithing is OK for War Hammers */
 object_short_name(name, sizeof(name), obj->kind->name);
 if (streq(name, "War Hammer") && (prop->type == OBJ_PROPERTY_SKILL) &&
  (idx == OBJ_MOD_SMITHING)) {
  valid = true;
 }
 return valid;
}
/**
 * Reports if a given property is already on an artefact.
 */
bool object_has_property(struct obj_property *prop, struct object *obj,
       bool negative)
{
 int idx = prop ? prop->index : -1;
 assert(idx >= 0);
 switch (prop->type) {
  case OBJ_PROPERTY_STAT: {
   return negative ? obj->modifiers[idx] < 0 : obj->modifiers[idx] > 0;
   break;
  }
  case OBJ_PROPERTY_SKILL:
  case OBJ_PROPERTY_MOD: {
   return obj->modifiers[idx] != 0;
   break;
  }
  case OBJ_PROPERTY_FLAG: {
   return of_has(obj->flags, idx);
   break;
  }
  case OBJ_PROPERTY_RESIST: {
   return obj->el_info[idx].res_level == 1;
   break;
  }
  case OBJ_PROPERTY_VULN: {
   return obj->el_info[idx].res_level == -1;
   break;
  }
  case OBJ_PROPERTY_SLAY: {
   return (obj->slays != NULL) && (obj->slays[idx] == true);
   break;
  }
  case OBJ_PROPERTY_BRAND: {
   return (obj->brands != NULL) && (obj->brands[idx] == true);
   break;
  }
 }
 return false;
}
/**
 * Adds a given property to an artefact.
 */
void add_object_property(struct obj_property *prop, struct object *obj,
         bool negative)
{
 int idx = prop ? prop->index : -1;
 assert(idx >= 0);
 switch (prop->type) {
  case OBJ_PROPERTY_STAT:
  case OBJ_PROPERTY_SKILL:
  case OBJ_PROPERTY_MOD: {
   obj->modifiers[idx] = negative ? -1 : 1;
   break;
  }
  case OBJ_PROPERTY_FLAG: {
   of_on(obj->flags, idx);
   break;
  }
  case OBJ_PROPERTY_RESIST: {
   obj->el_info[idx].res_level = 1;
   break;
  }
  case OBJ_PROPERTY_VULN: {
   obj->el_info[idx].res_level = -1;
   break;
  }
  case OBJ_PROPERTY_SLAY: {
   if (!obj->slays) {
    obj->slays = mem_zalloc(z_info->slay_max * sizeof(bool));
   }
   obj->slays[idx] = true;
   break;
  }
  case OBJ_PROPERTY_BRAND: {
   if (!obj->brands) {
    obj->brands = mem_zalloc(z_info->brand_max * sizeof(bool));
   }
   obj->brands[idx] = true;
   break;
  }
 }
}
/**
 * Removes a given property from an artefact.
 */
void remove_object_property(struct obj_property *prop, struct object *obj)
{
 int idx = prop ? prop->index : -1;
 int min_m, max_m;
 assert(idx >= 0);
 switch (prop->type) {
  case OBJ_PROPERTY_STAT:
  case OBJ_PROPERTY_SKILL:
  case OBJ_PROPERTY_MOD: {
   /*
			 * If the object's kind allows for a non-zero modifier,
			 * removing the property will not prevent adjustment
			 * of the modifier:  it will still fluctuate with the
			 * value set for the special bonus.
			 */
   min_m = randcalc(obj->kind->modifiers[idx],
    0, MINIMISE);
   max_m = randcalc(obj->kind->modifiers[idx],
    z_info->dun_depth, MAXIMISE);
   if (min_m == SPECIAL_VALUE) {
    min_m = randcalc(obj->kind->special1,
     0, MINIMISE);
    if (!min_m && obj->kind->special2) {
     min_m = obj->kind->special2;
    }
   }
   if (max_m == SPECIAL_VALUE) {
    max_m = randcalc(obj->kind->special1,
     z_info->dun_depth, MAXIMISE);
    if (!max_m && obj->kind->special2) {
     max_m = obj->kind->special2;
    }
   }
   if (min_m || max_m) {
    bool flip_sign;
    if (min_m >= 0) {
     obj->modifiers[idx] = 1;
    } else if (max_m > 0) {
     obj->modifiers[idx] =
      (max_m >= -min_m) ? 1 : -1;
    } else {
     obj->modifiers[idx] = -1;
    }
    (void)extract_kind_pval(obj->kind, AVERAGE,
     &flip_sign);
    if (flip_sign) {
     obj->modifiers[idx] *= -1;
    }
   } else {
    obj->modifiers[idx] = 0;
   }
   break;
  }
  case OBJ_PROPERTY_FLAG: {
   of_off(obj->flags, idx);
   break;
  }
  case OBJ_PROPERTY_RESIST:
  case OBJ_PROPERTY_VULN: {
   obj->el_info[idx].res_level = 0;
   break;
  }
  case OBJ_PROPERTY_SLAY: {
   obj->slays[idx] = false;
   for (idx = 0; idx < z_info->slay_max; idx++) {
    if (obj->slays[idx]) break;
   }
   if (idx == z_info->slay_max) {
    mem_free(obj->slays);
    obj->slays = NULL;
   }
   break;
  }
  case OBJ_PROPERTY_BRAND: {
   obj->brands[idx] = false;
   for (idx = 0; idx < z_info->brand_max; idx++) {
    if (obj->brands[idx]) break;
   }
   if (idx == z_info->brand_max) {
    mem_free(obj->brands);
    obj->brands = NULL;
   }
   break;
  }
 }
}
/**
 * Actually create the item.
 */
static void create_smithing_item(struct object *obj, struct smithing_cost *cost)
{
 struct object *created = object_new();
 char o_name[80];
 player->smithing_leftover = 0;
 msg("You complete your work.");
 /* Pay the ability/experience costs of smithing */
 smith_pay_costs(cost);
 /* If making an artefact, copy its attributes into the proper place in
	 * the a_info array (noting aidx has already been set) */
 if (obj->artifact) {
  uint16_t aidx = (z_info->a_max) ? z_info->a_max : 1;
  assert(aidx == obj->artifact->aidx);
  z_info->a_max = aidx + 1;
  a_info = mem_realloc(a_info, z_info->a_max * sizeof(struct artifact));
  aup_info = mem_realloc(aup_info, z_info->a_max * sizeof(*aup_info));
  if (aidx == 1) {
   memset(&a_info[0], 0, sizeof(a_info[0]));
   memset(&aup_info[0], 0, sizeof(aup_info[0]));
  }
  memset(&a_info[aidx], 0, sizeof(a_info[aidx]));
  artefact_copy(&a_info[aidx], (struct artifact *) obj->artifact);
  a_info[aidx].name = string_make(a_info[aidx].name);
  player->self_made_arts++;
  /* Set update info by hand */
  aup_info[aidx].aidx = aidx;
  aup_info[aidx].created = true;
  aup_info[aidx].seen = true;
  aup_info[aidx].everseen = true;
  /*
		 * Point the object at the permanent artifact record rather
		 * than what is used when smithing.
		 */
  obj->artifact = &a_info[aidx];
  if (obj->known) {
   obj->known->artifact = obj->artifact;
  }
 }
 /*
	 * Create the object; since lights use pval for the radius, reset
	 * that to what the kind has
	 */
 object_copy(created, obj);
 created->known = object_new();
 if (obj->known) {
  object_copy(created->known, obj->known);
 } else {
  object_set_base_known(player, created->known);
 }
 if (tval_is_light(created)) {
  created->pval = created->kind->pval;
  if (obj->known) {
   created->known->pval = created->kind->pval;
  }
 }
 /* Identify the object */
 object_touch(player, created);
 object_flavor_aware(player, created);
 while (!object_runes_known(created)) {
  object_learn_unknown_rune(player, created);
 }
 /* Create description */
 object_desc(o_name, sizeof(o_name), created, ODESC_COMBAT | ODESC_EXTRA,
    player);
 /* Record the object creation */
 history_add(player, format("Made %s  %d.%d lb", o_name,
          (created->weight * created->number) / 10,
          (created->weight * created->number) % 10),
    HIST_OBJECT_SMITHED);
 /* Carry the forged item */
 inven_carry(player, created, false, true);
}
/**
 * Start or resume smithing an item.
 */
static void start_smithing(struct player *p, int turns)
{
 /* Flag that we are in the middle of smithing */
 p->upkeep->smithing = true;
 /* Set repeats */
 cmd_set_repeat(turns);
 /* Recalculate bonuses */
 p->upkeep->update |= (PU_BONUS);
 /* Redraw the state */
 p->upkeep->redraw |= (PR_STATE);
 /* Handle stuff */
 handle_stuff(p);
}
/**
 * Start or continue smithing an item.
 */
void do_cmd_smith_aux(bool flush)
{
 bool forge = square_isforge(cave, player->grid);
 bool useless = (square_forge_uses(cave, player->grid) == 0);
 struct object *obj;
 int turns = 0;
 struct smithing_cost cost;
 /* Are we just starting? */
 if (!player->upkeep->smithing) {
  /* Check for actual usability, or warn of exploration mode */
  if (forge && useless) {
   msg("The resources of this forge are exhausted.");
   msg("You will be able to browse options but not make new things.");
  }
  /* Go to the smithing menu */
  obj = smith_object(&cost);
  /* If it was just a test run, leave now */
  if (!obj) return;
  /* Allow the resumption of interrupted smithing */
  if (player->smithing_leftover > 0) {
   turns = player->smithing_leftover;
  } else {
   /* Get the number of turns required */
   turns = MAX(10, object_difficulty(obj, &cost) * 10);
   /* Also set the smithing leftover counter
			 * (to allow you to resume if interrupted) */
   player->smithing_leftover = turns;
   /* Display a message */
   msg("You begin your work.");
  }
  /* Cancel stealth mode */
  player->stealth_mode = STEALTH_MODE_OFF;
  /* If called from a different command, substitute the correct one */
  if (flush) {
   cmdq_push(CMD_SMITH);
   cmdq_pop(CTX_GAME);
  }
  start_smithing(player, turns);
 }
 /* Take a turn */
 player->upkeep->energy_use = z_info->move_energy;
 /* Finish */
 if (cmd_get_nrepeats() == 1) {
  obj = smith_object(&cost);
  create_smithing_item(obj, &cost);
  player->upkeep->smithing = false;
 }
 /* Redraw the state if requested */
 handle_stuff(player);
}
/**
 * Start or continue smithing an item.
 */
void do_cmd_smith(struct command *cmd)
{
 do_cmd_smith_aux(false);
}
/**
 * \file obj-tval.c
 * \brief Wrapper functions for tvals.
 *
 * Copyright (c) 2014 Ben Semmler
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
bool tval_is_staff(const struct object *obj)
{
 return obj->tval == TV_STAFF;
}
bool tval_is_note(const struct object *obj)
{
 return obj->tval == TV_NOTE;
}
bool tval_is_horn(const struct object *obj)
{
 return obj->tval == TV_HORN;
}
bool tval_is_potion(const struct object *obj)
{
 return obj->tval == TV_POTION;
}
bool tval_is_food(const struct object *obj)
{
 return obj->tval == TV_FOOD;
}
bool tval_is_food_k(const struct object_kind *kind)
{
 return kind->tval == TV_FOOD;
}
bool tval_is_herb(const struct object *obj)
{
 return obj->tval == TV_HERB;
}
bool tval_is_herb_k(const struct object_kind *kind)
{
 return kind->tval == TV_HERB;
}
bool tval_is_light(const struct object *obj)
{
 return obj->tval == TV_LIGHT;
}
bool tval_is_light_k(const struct object_kind *kind)
{
 return kind->tval == TV_LIGHT;
}
bool tval_is_ring(const struct object *obj)
{
 return obj->tval == TV_RING;
}
bool tval_is_chest(const struct object *obj)
{
 return obj->tval == TV_CHEST;
}
bool tval_is_metal(const struct object *obj)
{
 return obj->tval == TV_METAL;
}
bool tval_is_fuel(const struct object *obj)
{
 return obj->tval == TV_FLASK;
}
bool tval_is_digger(const struct object *obj)
{
 return obj->tval == TV_DIGGING;
}
bool tval_can_have_nourishment(const struct object *obj)
{
 return obj->tval == TV_FOOD || obj->tval == TV_POTION ||
   obj->tval == TV_HERB;
}
bool tval_can_have_charges(const struct object *obj)
{
 return obj->tval == TV_STAFF;
}
bool tval_is_cloak(const struct object *obj)
{
 return obj->tval == TV_CLOAK;
}
bool tval_is_gloves(const struct object *obj)
{
 return obj->tval == TV_GLOVES;
}
bool tval_is_boots(const struct object *obj)
{
 return obj->tval == TV_BOOTS;
}
bool tval_is_sword(const struct object *obj)
{
 return obj->tval == TV_SWORD;
}
bool tval_is_shield(const struct object *obj)
{
 return obj->tval == TV_SHIELD;
}
bool tval_is_body_armor(const struct object *obj)
{
 switch (obj->tval) {
  case TV_SOFT_ARMOR:
  case TV_MAIL:
   return true;
  default:
   return false;
 }
}
bool tval_is_head_armor(const struct object *obj)
{
 return obj->tval == TV_HELM || obj->tval == TV_CROWN;
}
bool tval_is_ammo(const struct object *obj)
{
 switch (obj->tval) {
  case TV_ARROW:
   return true;
  default:
   return false;
 }
}
bool tval_is_sharp(const struct object *obj)
{
 switch (obj->tval) {
  case TV_ARROW:
  case TV_SWORD:
  case TV_POLEARM:
   return true;
  default:
   return false;
 }
}
bool tval_is_launcher(const struct object *obj)
{
 return obj->tval == TV_BOW;
}
bool tval_is_useable(const struct object *obj)
{
 switch (obj->tval) {
  case TV_LIGHT:
  case TV_ARROW:
  case TV_HORN:
  case TV_STAFF:
  case TV_POTION:
  case TV_FOOD:
  case TV_HERB:
   return true;
  default:
   return false;
 }
}
bool tval_is_jewelry(const struct object *obj)
{
 return obj->tval == TV_RING || obj->tval == TV_AMULET;
}
bool tval_is_weapon(const struct object *obj)
{
 switch (obj->tval) {
  case TV_SWORD:
  case TV_HAFTED:
  case TV_POLEARM:
  case TV_DIGGING:
  case TV_BOW:
  case TV_ARROW:
   return true;
  default:
   return false;
 }
}
bool tval_is_armor(const struct object *obj)
{
 switch (obj->tval) {
  case TV_MAIL:
  case TV_SOFT_ARMOR:
  case TV_SHIELD:
  case TV_CLOAK:
  case TV_CROWN:
  case TV_HELM:
  case TV_BOOTS:
  case TV_GLOVES:
   return true;
  default:
   return false;
 }
}
bool tval_is_melee_weapon(const struct object *obj)
{
 switch (obj->tval) {
  case TV_SWORD:
  case TV_HAFTED:
  case TV_POLEARM:
  case TV_DIGGING:
   return true;
  default:
   return false;
 }
}
bool tval_is_held_weapon(const struct object *obj)
{
 switch (obj->tval) {
  case TV_BOW:
  case TV_SWORD:
  case TV_HAFTED:
  case TV_POLEARM:
  case TV_DIGGING:
   return true;
  default:
   return false;
 }
}
bool tval_has_variable_power(const struct object *obj)
{
 switch (obj->tval) {
  case TV_ARROW:
  case TV_BOW:
  case TV_DIGGING:
  case TV_HAFTED:
  case TV_POLEARM:
  case TV_SWORD:
  case TV_BOOTS:
  case TV_GLOVES:
  case TV_HELM:
  case TV_CROWN:
  case TV_SHIELD:
  case TV_CLOAK:
  case TV_SOFT_ARMOR:
  case TV_MAIL:
  case TV_LIGHT:
  case TV_AMULET:
  case TV_RING:
   return true;
  default:
   return false;
 }
}
bool tval_is_wearable(const struct object *obj)
{
 switch (obj->tval) {
  case TV_BOW:
  case TV_DIGGING:
  case TV_HAFTED:
  case TV_POLEARM:
  case TV_SWORD:
  case TV_BOOTS:
  case TV_GLOVES:
  case TV_HELM:
  case TV_CROWN:
  case TV_SHIELD:
  case TV_CLOAK:
  case TV_SOFT_ARMOR:
  case TV_MAIL:
  case TV_LIGHT:
  case TV_AMULET:
  case TV_RING:
   return true;
  default:
   return false;
 }
}
bool tval_is_edible(const struct object *obj)
{
 switch (obj->tval) {
  case TV_FOOD:
  case TV_HERB:
   return true;
  default:
   return false;
 }
}
bool tval_can_have_flavor_k(const struct object_kind *kind)
{
 switch (kind->tval) {
  case TV_AMULET:
  case TV_RING:
  case TV_STAFF:
  case TV_HORN:
  case TV_POTION:
  case TV_HERB:
   return true;
  default:
   return false;
 }
}
/**
 * List of { tval, name } pairs.
 */
static const grouper tval_names[] =
{
/**
 * \file list-tvals.h
 * \brief List of object base types
 */
/* code_name, string_name */
{ TV_NULL, "none" },
{ TV_NOTE, "note" },
{ TV_USELESS, "skeleton" },
{ TV_METAL, "metal" },
{ TV_CHEST, "chest" },
{ TV_ARROW, "arrow" },
{ TV_BOW, "bow" },
{ TV_DIGGING, "digger" },
{ TV_HAFTED, "hafted" },
{ TV_POLEARM, "polearm" },
{ TV_SWORD, "sword" },
{ TV_BOOTS, "boots" },
{ TV_GLOVES, "gloves" },
{ TV_HELM, "helm" },
{ TV_CROWN, "crown" },
{ TV_SHIELD, "shield" },
{ TV_CLOAK, "cloak" },
{ TV_SOFT_ARMOR, "soft armor" },
{ TV_MAIL, "mail" },
{ TV_LIGHT, "light" },
{ TV_AMULET, "amulet" },
{ TV_RING, "ring" },
{ TV_STAFF, "staff" },
{ TV_HORN, "horn" },
{ TV_POTION, "potion" },
{ TV_FLASK, "flask" },
{ TV_FOOD, "food" },
{ TV_HERB, "herb" },
{ TV_EASTER, "easter" },

};
/**
 * Small hack to allow both spellings of armor
 */
static char *de_armour(const char *name)
{
 char newname[40];
 char *armour;
 my_strcpy(newname, name, sizeof(newname));
 armour = strstr(newname, "armour");
 if (armour)
  my_strcpy(armour + 4, "r", 2);
 return string_make(newname);
}
/**
 * Returns the numeric equivalent tval of the textual tval `name`.
 */
int tval_find_idx(const char *name)
{
 size_t i;
 char *mod_name, *pe;
 unsigned long r = strtoul(name, &pe, 10);
 if (pe != name) {
  return (contains_only_spaces(pe) && r < TV_MAX) ? (int)r : -1;
 }
 mod_name = de_armour(name);
 for (i = 0; i < N_ELEMENTS(tval_names); i++) {
  if (!my_stricmp(mod_name, tval_names[i].name)) {
   string_free(mod_name);
   return tval_names[i].tval;
  }
 }
 string_free(mod_name);
 return -1;
}
/**
 * Returns the textual equivalent tval of the numeric tval `name`.
 */
const char *tval_find_name(int tval)
{
 size_t i = 0;
 for (i = 0; i < N_ELEMENTS(tval_names); i++)
 {
  if (tval == tval_names[i].tval)
   return tval_names[i].name;
 }
 return "unknown";
}
/**
 * Counts the svals (from object.txt) of a given non-null tval
 */
int tval_sval_count(const char *name)
{
 size_t i, num = 0;
 int tval = tval_find_idx(name);
 if (tval < 0) return 0;
 for (i = 0; i < z_info->k_max; i++) {
  struct object_kind *kind = &k_info[i];
  if (!kind->tval) continue;
  if (kind->tval != tval) continue;
  num++;
 }
 return num;
}
/**
 * Lists up to max_size svals (from object.txt) of a given non-null tval
 * Assumes list has allocated space for at least max_size elements
 */
int tval_sval_list(const char *name, int *list, int max_size)
{
 size_t i;
 int num = 0;
 int tval = tval_find_idx(name);
 if (tval < 0) return 0;
 for (i = 0; i < z_info->k_max; i++) {
  struct object_kind *kind = &k_info[i];
  if (!kind->tval) continue;
  if (kind->tval != tval) continue;
  if (num >= max_size) break;
  list[num++] = kind->sval;
 }
 return num;
}
/**
 * \file obj-util.c
 * \brief Object utilities
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
struct object_base *kb_info;
struct object_kind *k_info;
struct artifact *a_info;
struct artifact_upkeep *aup_info;
struct ego_item *e_info;
struct flavor *flavors;
static void flavor_assign_fixed(void)
{
 int i;
 struct flavor *f;
 for (f = flavors; f; f = f->next) {
  if (f->sval == SV_UNKNOWN)
   continue;
  for (i = 0; i < z_info->k_max; i++) {
   struct object_kind *k = &k_info[i];
   if (k->tval == f->tval && k->sval == f->sval)
    k->flavor = f;
  }
 }
}
static void flavor_assign_random(uint8_t tval)
{
 int i;
 int flavor_count = 0;
 int choice;
 struct flavor *f;
 /* Count the random flavors for the given tval */
 for (f = flavors; f; f = f->next)
  if (f->tval == tval && f->sval == SV_UNKNOWN)
   flavor_count++;
 for (i = 0; i < z_info->k_max; i++) {
  if (k_info[i].tval != tval || k_info[i].flavor)
   continue;
  if (!flavor_count)
   quit_fmt("Not enough flavors for tval %d.", tval);
  choice = randint0(flavor_count);
  for (f = flavors; f; f = f->next) {
   if (f->tval != tval || f->sval != SV_UNKNOWN)
    continue;
   if (choice == 0) {
    k_info[i].flavor = f;
    f->sval = k_info[i].sval;
    flavor_count--;
    break;
   }
   choice--;
  }
 }
}
/**
 * Prepare the "variable" part of the "k_info" array.
 *
 * The "color"/"metal"/"type" of an item is its "flavor".
 * For the most part, flavors are assigned randomly each game.
 *
 * Initialize descriptions for the "colored" objects, including:
 * Rings, Amulets, Staffs, Wands, Rods, Mushrooms, Potions, Scrolls.
 *
 * Scroll titles are always between 6 and 14 letters long.  This is
 * ensured because every title is composed of whole words, where every
 * word is from 2 to 8 letters long, and that no scroll is finished
 * until it attempts to grow beyond 15 letters.  The first time this
 * can happen is when the current title has 6 letters and the new word
 * has 8 letters, which would result in a 6 letter scroll title.
 *
 * Hack -- make sure everything stays the same for each saved game
 * This is accomplished by the use of a saved "random seed", as in
 * "town_gen()".  Since no other functions are called while the special
 * seed is in effect, so this function is pretty "safe".
 */
void flavor_init(void)
{
 int i;
 /* Hack -- Use the "simple" RNG */
 Rand_quick = true;
 /* Hack -- Induce consistant flavors */
 Rand_value = seed_flavor;
 /* Scrub all flavors and re-parse for new players */
 if (turn == 1) {
  struct flavor *f;
  for (i = 0; i < z_info->k_max; i++) {
   k_info[i].flavor = NULL;
  }
  for (f = flavors; f; f = f->next) {
   f->sval = SV_UNKNOWN;
  }
  cleanup_parser(&flavor_parser);
  run_parser(&flavor_parser);
 }
 flavor_assign_fixed();
 flavor_assign_random(TV_RING);
 flavor_assign_random(TV_AMULET);
 flavor_assign_random(TV_STAFF);
 flavor_assign_random(TV_HORN);
 flavor_assign_random(TV_HERB);
 flavor_assign_random(TV_POTION);
 /* Hack -- Use the "complex" RNG */
 Rand_quick = false;
 /* Analyze every object */
 for (i = 0; i < z_info->k_max; i++) {
  struct object_kind *kind = &k_info[i];
  /* Skip "empty" objects */
  if (!kind->name) continue;
  /* No flavor yields aware */
  if (!kind->flavor) kind->aware = true;
 }
}
/**
 * Set all flavors as aware
 */
void flavor_set_all_aware(void)
{
 int i;
 /* Analyze every object */
 for (i = 0; i < z_info->k_max; i++) {
  struct object_kind *kind = &k_info[i];
  /* Skip empty objects */
  if (!kind->name) continue;
  /* Flavor yields aware */
  if (kind->flavor) kind->aware = true;
 }
}
/**
 * Obtain the flags for an item
 */
void object_flags(const struct object *obj, bitflag flags[OF_SIZE])
{
 of_wipe(flags);
 if (!obj) return;
 of_copy(flags, obj->flags);
}
/**
 * Obtain the flags for an item which are known to the player
 */
void object_flags_known(const struct object *obj, bitflag flags[OF_SIZE])
{
 object_flags(obj, flags);
 of_inter(flags, obj->known->flags);
 if (!obj->kind) {
  return;
 }
 if (object_flavor_is_aware(obj)) {
  of_union(flags, obj->kind->flags);
 }
 if (obj->ego && easy_know(obj)) {
  of_union(flags, obj->ego->flags);
 }
}
/**
 * Apply a tester function, skipping all non-objects and gold
 */
bool object_test(item_tester tester, const struct object *obj)
{
 /* Require object */
 if (!obj) return false;
 /* Pass without a tester, or tail-call the tester if it exists */
 return !tester || tester(obj);
}
/**
 * Looks if "inscrip" is present on the given object.
 */
unsigned check_for_inscrip(const struct object *obj, const char *inscrip)
{
 unsigned i = 0;
 const char *s;
 if (!obj->note) return 0;
 s = quark_str(obj->note);
 /* Needing this implies there are bad instances of obj->note around,
	 * but I haven't been able to track down their origins - NRM */
 if (!s) return 0;
 do {
  s = strstr(s, inscrip);
  if (!s) break;
  i++;
  s++;
 } while (s);
 return i;
}
/**
 * Looks if "inscrip" immediately followed by a decimal integer without a
 * leading sign character is present on the given object.  Returns the number
 * of times such an inscription occurs and, if that value is at least one,
 * sets *ival to the value of the integer that followed the first such
 * inscription.
 */
unsigned check_for_inscrip_with_int(const struct object *obj, const char *inscrip, int* ival)
{
 unsigned i = 0;
 size_t inlen = strlen(inscrip);
 const char *s;
 if (!obj->note) return 0;
 s = quark_str(obj->note);
 /* Needing this implies there are bad instances of obj->note around,
	 * but I haven't been able to track down their origins - NRM */
 if (!s) return 0;
 do {
  s = strstr(s, inscrip);
  if (!s) break;
  if (isdigit(s[inlen])) {
   if (i == 0) {
    long inarg = strtol(s + inlen, 0, 10);
    *ival = (inarg < INT_MAX) ? (int) inarg : INT_MAX;
   }
   i++;
  }
  s++;
 } while (s);
 return i;
}
/*** Object kind lookup functions ***/
/**
 * Return the object kind with the given `tval` and `sval`, or NULL.
 */
struct object_kind *lookup_kind(int tval, int sval)
{
 int k;
 /* Look for it */
 for (k = 0; k < z_info->k_max; k++) {
  struct object_kind *kind = &k_info[k];
  if (kind->tval == tval && kind->sval == sval)
   return kind;
 }
 /* Failure */
 msg("No object: %d:%d (%s)", tval, sval, tval_find_name(tval));
 return NULL;
}
/**
 * Return the object kind that should be used as the basis for any smithed
 * artifact belonging to the given tval.  If there is no such kind -
 * indicating smithed artifacts should use a standard kind from that tval -
 * return NULL.
 */
struct object_kind *lookup_selfmade_kind(int tval)
{
 int k;
 for (k = 0; k < z_info->k_max; k++) {
  struct object_kind *kind = &k_info[k];
  if (kind->tval == tval
    && kf_has(kind->kind_flags, KF_SMITH_ART)) {
   return kind;
  }
 }
 return NULL;
}
struct object_kind *objkind_byid(int kidx) {
 if (kidx < 0 || kidx >= z_info->k_max)
  return NULL;
 return &k_info[kidx];
}
/*** Textual<->numeric conversion ***/
/**
 * Return the a_idx of the artifact with the given name
 */
const struct artifact *lookup_artifact_name(const char *name)
{
 int i;
 int a_idx = -1;
 /* Look for it */
 for (i = 0; i < z_info->a_max; i++) {
  const struct artifact *art = &a_info[i];
  /* Test for equality */
  if (art->name && streq(name, art->name))
   return art;
  /* Test for close matches */
  if (strlen(name) >= 3 && art->name && my_stristr(art->name, name)
   && a_idx == -1)
   a_idx = i;
 }
 /* Return our best match */
 return a_idx > 0 ? &a_info[a_idx] : NULL;
}
/**
 * \param name ego type name
 * \param tval object tval
 * \param sval object sval
 * \return eidx of the ego item type
 */
struct ego_item *lookup_ego_item(const char *name, int tval, int sval)
{
 int i;
 /* Look for it */
 for (i = 0; i < z_info->e_max; i++) {
  struct ego_item *ego = &e_info[i];
  struct poss_item *poss_item = ego->poss_items;
  /* Reject nameless and wrong names */
  if (!ego->name) continue;
  if (!streq(name, ego->name)) continue;
  /* Check tval and sval */
  while (poss_item) {
   struct object_kind *kind = lookup_kind(tval, sval);
   if (kind->kidx == poss_item->kidx) {
    return ego;
   }
   poss_item = poss_item->next;
  }
 }
 return NULL;
}
/**
 * Return the numeric sval of the object kind with the given `tval` and
 * name `name`.
 */
int lookup_sval(int tval, const char *name)
{
 int k;
 char *pe;
 unsigned long r = strtoul(name, &pe, 10);
 if (pe != name) {
  return (contains_only_spaces(pe) && r < INT_MAX) ? (int)r : -1;
 }
 /* Look for it */
 for (k = 0; k < z_info->k_max; k++) {
  struct object_kind *kind = &k_info[k];
  char cmp_name[1024];
  if (!kind || !kind->name || kind->tval != tval) continue;
  obj_desc_name_format(cmp_name, sizeof cmp_name, 0, kind->name, 0,
        false);
  /* Found a match */
  if (!my_stricmp(cmp_name, name)) return kind->sval;
 }
 return -1;
}
void object_short_name(char *buf, size_t max, const char *name)
{
 size_t j, k;
 /* Copy across the name, stripping modifiers & and ~) */
 size_t len = strlen(name);
 for (j = 0, k = 0; j < len && k < max - 1; j++) {
  if (j == 0 && name[0] == '&' && name[1] == ' ')
   j += 2;
  if (name[j] == '~')
   continue;
  buf[k++] = name[j];
 }
 buf[k] = 0;
}
/**
 * Sort comparator for objects using only tval and sval.
 * -1 if o1 should be first
 *  1 if o2 should be first
 *  0 if it doesn't matter
 */
static int compare_types(const struct object *o1, const struct object *o2)
{
 if (o1->tval == o2->tval)
  return CMP(o1->sval, o2->sval);
 else
  return CMP(o1->tval, o2->tval);
}
/**
 * Sort comparator for objects
 * -1 if o1 should be first
 *  1 if o2 should be first
 *  0 if it doesn't matter
 *
 * The sort order is designed with the "list items" command in mind.
 */
int compare_items(const struct object *o1, const struct object *o2)
{
 /* known artifacts will sort first */
 if (o1->artifact && o2->artifact)
  return compare_types(o1, o2);
 if (o1->artifact) return -1;
 if (o2->artifact) return 1;
 /* unknown objects will sort next */
 if (!object_flavor_is_aware(o1) && !object_flavor_is_aware(o2))
  return compare_types(o1, o2);
 if (!object_flavor_is_aware(o1)) return -1;
 if (!object_flavor_is_aware(o2)) return 1;
 /* if only one of them is worthless, the other comes first */
 if (o1->kind->cost == 0 && o2->kind->cost != 0) return 1;
 if (o1->kind->cost != 0 && o2->kind->cost == 0) return -1;
 /* otherwise, just compare tvals and svals */
 /* NOTE: arguably there could be a better order than this */
 return compare_types(o1, o2);
}
/**
 * Convert a depth from a chunk or player to a value appropriate for an
 * object's origin.
 *
 * \param depth is the value to convert.
 *
 * Necessary since savefiles use 16-bit type to record the depth of a player
 * or chunk and uint8_t to record the origin depth.
 */
uint8_t convert_depth_to_origin(int depth)
{
 if (depth < 0) return 0;
 if (depth > 255) return 255;
 return (uint8_t) depth;
}
/**
 * Calculate the digging score for a digging implement
 */
int obj_digging_score(const struct object *obj)
{
 int base = 0;
 if (!obj) return 0;
 if (of_has(obj->flags, OF_DIG_1)) base = 1;
 if (of_has(obj->flags, OF_DIG_2)) base = 2;
 return base + obj->modifiers[OBJ_MOD_TUNNEL];
}
/**
 * Determine if an object is a digging implement
 */
bool obj_can_dig(const struct object *obj)
{
 return obj_digging_score(obj) > 0;
}
/**
 * Determine if an object has charges
 */
bool obj_has_charges(const struct object *obj)
{
 if (!tval_can_have_charges(obj)) return false;
 if (obj->pval <= 0) return false;
 return true;
}
/**
 * Check if an object can be used to refuel other objects.
 */
bool obj_can_refuel(const struct object *obj)
{
 const struct object *light = equipped_item_by_slot_name(player, "light");
 /* Player must be carrying a light which needs fuel */
 if (!light || of_has(light->flags, OF_NO_FUEL)) return false;
 /* A lantern can be refueled from a flask or another lantern */
 if (of_has(light->flags, OF_TAKES_FUEL)) {
  if (tval_is_fuel(obj)) {
   return true;
  } else if (tval_is_light(obj) && of_has(obj->flags, OF_TAKES_FUEL) &&
       obj->timeout > 0) {
   return true;
  }
 }
 /* A torch can be refueled from another torch */
 if (of_has(light->flags, OF_BURNS_OUT)) {
  if (tval_is_light(obj) && of_has(obj->flags, OF_BURNS_OUT) &&
       obj->timeout > 0) {
   return true;
  }
 }
 return false;
}
/* Can only take off cursed items in special circumstances */
bool obj_can_takeoff(const struct object *obj)
{
 return !obj_has_flag(obj, OF_CURSED)
  || player_active_ability(player, "Curse Breaking");
}
/*
 * Can only throw an item that is not equipped or the equipped weapon if it
 * can be taken off.
 *
 * Note: that is Angband's behavior; Sil 1.3 allows other equippped items to
 * be thrown if they can be taken off.
 */
bool obj_can_throw(const struct object *obj)
{
 return !object_is_equipped(player->body, obj)
  || (tval_is_melee_weapon(obj) && obj_can_takeoff(obj));
}
/* Can only put on wieldable items */
bool obj_can_wear(const struct object *obj)
{
 return (wield_slot(obj) >= 0);
}
/* Can only fire an item with the right tval */
bool obj_can_fire(const struct object *obj)
{
 return obj->tval == player->state.ammo_tval;
}
/**
 * Determine if an object is designed for throwing
 */
bool obj_is_throwing(const struct object *obj)
{
 return of_has(obj->flags, OF_THROWING);
}
bool obj_is_cursed(const struct object *obj)
{
 return of_has(obj->flags, OF_CURSED);
}
bool obj_is_broken(const struct object *obj)
{
 return (object_value(obj) <= 0);
}
/* Can has inscrip pls */
bool obj_has_inscrip(const struct object *obj)
{
 return (obj->note ? true : false);
}
bool obj_has_flag(const struct object *obj, int flag)
{
 /* Check the object's own flags */
 if (of_has(obj->flags, flag)) {
  return true;
 }
 return false;
}
bool obj_is_useable(const struct object *obj)
{
 if (tval_is_useable(obj))
  return true;
 if (object_effect(obj))
  return true;
 /*
	 * Could do further testing to see if the equipped object, if any, can
	 * be removed, but for items (like rings) that can go in more than one
	 * slot there are extra complications to the logic (using wield_slot()
	 * and slot_object() is not sufficient if all the appropriate slots
	 * are full and the slot from wield_slot() has a cursed item but
	 * another appropriate slot has an uncursed item).
	 */
 if (tval_is_wearable(obj) && !object_is_equipped(player->body, obj))
  return true;
 if (obj_can_refuel(obj))
  return true;
 if (tval_is_ammo(obj))
  return obj->tval == player->state.ammo_tval;
 return false;
}
bool obj_nourishes(const struct object *obj)
{
 struct effect *effect = obj->kind->effect;
 if (!effect) return false;
 while (effect) {
  if (effect->index == EF_NOURISH && effect->dice) {
   random_value rv;
   (void) dice_roll(effect->dice, &rv);
   if (rv.base > 0) {
    return true;
   }
  }
  effect = effect->next;
 }
 return false;
}
/*** Generic utility functions ***/
/**
 * Return an object's effect.
 */
struct effect *object_effect(const struct object *obj)
{
 if (obj->kind->effect)
  return obj->kind->effect;
 else
  return NULL;
}
/**
 * Does the given object need to be aimed?
 */
bool obj_needs_aim(const struct object *obj)
{
 const struct effect *effect = object_effect(obj);
 /* If the effect needs aiming, or if the object type needs
	   aiming, this object needs aiming. */
 return effect_aim(effect) || tval_is_ammo(obj);
}
/**
 * Can the given object be aimed vertically?
 */
bool obj_allows_vertical_aim(const struct object *obj)
{
 const struct effect *effect = object_effect(obj);
 while (effect) {
  if (effect->index == EF_TERRAIN_BEAM && effect->other == 1) {
   return true;
  }
  effect = effect->next;
 }
 return false;
}
/**
 * Distribute charges of rods, staves, or wands.
 *
 * \param source is the source item
 * \param dest is the target item, must be of the same type as source
 * \param amt is the number of items that are transfered
 */
void distribute_charges(struct object *source, struct object *dest, int amt)
{
 /*
	 * Hack -- If rods, staves, or wands are dropped, the total maximum
	 * timeout or charges need to be allocated between the two stacks.
	 * If all the items are being dropped, it makes for a neater message
	 * to leave the original stack's pval alone. -LM-
	 */
 if (tval_can_have_charges(source)) {
  dest->pval = source->pval * amt / source->number;
  if (amt < source->number)
   source->pval -= dest->pval;
 }
}
/**
 * Removes the curse from an object.
 */
void uncurse_object(struct object *obj)
{
 /* Uncurse it */
 if (!of_off(obj->flags, OF_CURSED)) {
  msg("Attempt to uncurse non-cursed object - please report this bug");
 }
 of_off(obj->known->flags, OF_CURSED);
 player->upkeep->notice |= (PN_COMBINE);
 player->upkeep->update |= (PU_BONUS);
 player->upkeep->redraw |= (PR_EQUIP | PR_INVEN);
}
/**
 * Verify the choice of an item.
 *
 * The item can be negative to mean "item on floor".
 */
bool verify_object(const char *prompt, const struct object *obj,
  const struct player *p)
{
 char o_name[80];
 char out_val[160];
 /* Describe */
 object_desc(o_name, sizeof(o_name), obj, ODESC_PREFIX | ODESC_FULL, p);
 /* Prompt */
 strnfmt(out_val, sizeof(out_val), "%s %s? ", prompt, o_name);
 /* Query */
 return (get_check(out_val));
}
typedef enum {
 MSG_TAG_NONE,
 MSG_TAG_NAME,
 MSG_TAG_KIND,
 MSG_TAG_VERB,
 MSG_TAG_VERB_IS
} msg_tag_t;
static msg_tag_t msg_tag_lookup(const char *tag)
{
 if (strncmp(tag, "name", 4) == 0) {
  return MSG_TAG_NAME;
 } else if (strncmp(tag, "kind", 4) == 0) {
  return MSG_TAG_KIND;
 } else if (strncmp(tag, "s", 1) == 0) {
  return MSG_TAG_VERB;
 } else if (strncmp(tag, "is", 2) == 0) {
  return MSG_TAG_VERB_IS;
 } else {
  return MSG_TAG_NONE;
 }
}
/**
 * Print a message from a string, customised to include details about an object
 */
void print_custom_message(const struct object *obj, const char *string,
  int msg_type, const struct player *p)
{
 char buf[1024] = "\0";
 const char *next;
 const char *s;
 const char *tag;
 size_t end = 0;
 /* Not always a string */
 if (!string) return;
 next = strchr(string, '{');
 while (next) {
  /* Copy the text leading up to this { */
  strnfcat(buf, 1024, &end, "%.*s", (int) (next - string),
   string);
  s = next + 1;
  while (*s && isalpha((unsigned char) *s)) s++;
  /* Valid tag */
  if (*s == '}') {
   /* Start the tag after the { */
   tag = next + 1;
   string = s + 1;
   switch(msg_tag_lookup(tag)) {
   case MSG_TAG_NAME:
    if (obj) {
     end += object_desc(buf, 1024, obj,
      ODESC_PREFIX | ODESC_BASE, p);
    } else {
     strnfcat(buf, 1024, &end, "hands");
    }
    break;
   case MSG_TAG_KIND:
    if (obj) {
     object_kind_name(&buf[end], 1024 - end, obj->kind, true);
     end += strlen(&buf[end]);
    } else {
     strnfcat(buf, 1024, &end, "hands");
    }
    break;
   case MSG_TAG_VERB:
    if (obj && obj->number == 1) {
     strnfcat(buf, 1024, &end, "s");
    }
    break;
   case MSG_TAG_VERB_IS:
    if ((!obj) || (obj->number > 1)) {
     strnfcat(buf, 1024, &end, "are");
    } else {
     strnfcat(buf, 1024, &end, "is");
    }
   default:
    break;
   }
  } else
   /* An invalid tag, skip it */
   string = next + 1;
  next = strchr(string, '{');
 }
 strnfcat(buf, 1024, &end, "%s", string);
 msgt(msg_type, "%s", buf);
}
/**
 * Return if the given artifact has been created.
 */
bool is_artifact_created(const struct artifact *art)
{
 assert(art->aidx == aup_info[art->aidx].aidx);
 return aup_info[art->aidx].created;
}
/**
 * Return if the given artifact has been seen.
 */
bool is_artifact_seen(const struct artifact *art)
{
 assert(art->aidx == aup_info[art->aidx].aidx);
 return aup_info[art->aidx].seen;
}
/**
 * Return if the given artifact has ever been seen.
 */
bool is_artifact_everseen(const struct artifact *art)
{
 assert(art->aidx == aup_info[art->aidx].aidx);
 return aup_info[art->aidx].everseen;
}
/**
 * Set whether the given artifact has been created or not.
 */
void mark_artifact_created(const struct artifact *art, bool created)
{
 assert(art->aidx == aup_info[art->aidx].aidx);
 aup_info[art->aidx].created = created;
}
/**
 * Set whether the given artifact has been created or not.
 */
void mark_artifact_seen(const struct artifact *art, bool seen)
{
 assert(art->aidx == aup_info[art->aidx].aidx);
 aup_info[art->aidx].seen = seen;
}
/**
 * Set whether the given artifact has been seen or not.
 */
void mark_artifact_everseen(const struct artifact *art, bool seen)
{
 assert(art->aidx == aup_info[art->aidx].aidx);
 aup_info[art->aidx].everseen = seen;
}
/**
 * Write ability lines for a set of abilities.
 */
static void write_abilities(ang_file *fff, const struct ability *abils)
{
 struct ability *ability = (struct ability *) abils;
 static const char *skill_names[] = {
/**
 * \file src/list-skills.h
 * \brief player skills
 *
 * Changing skill order or making new ones will break savefiles. Skills
 * below start from 0 on line 11, so a skill's sequence number is its line
 * number minus 11.
 *
 * Skill properties are not defined in lib/gamedata/object_property.txt
 */
"Melee",
"Archery",
"Evasion",
"Stealth",
"Perception",
"Will",
"Smithing",
"Song",

  ""
 };
 /* Write abilities */
 while (ability) {
  file_putf(fff, "ability:");
  file_putf(fff, "%s:", skill_names[ability->skill]);
  file_putf(fff, "%s\n", ability->name);
  ability = ability->next;
 }
}
/**
 * Write an artifact data file
 */
void write_self_made_artefact_entries(ang_file *fff)
{
 int i;
 static const char *obj_flags[] = {
  "NONE",
/**
 * \file list-object-flags.h
 * \brief object flags for all objects
 *
 * Changing flag order will break savefiles. Flags
 * below start from 1 on line 17, so a flag's sequence number is its line
 * number minus 16.
 *
 * Each sustain flag (SUST_*) has a matching stat in src/list-stats.h,
 * which should be at the same index in that file as the sustain in this file.
 *
 * The second argument to OF is the label used in the debugging commands
 * object flag display.  At most the first five characters are used.
 *
 * Flag properties are defined in lib/gamedata/object_property.txt
 */
"SUST_STR",
"SUST_DEX",
"SUST_CON",
"SUST_GRA",
"PROT_FEAR",
"PROT_BLIND",
"PROT_CONF",
"PROT_STUN",
"PROT_HALLU",
"SLOW_DIGEST",
"REGEN",
"SEE_INVIS",
"FREE_ACT",
"RADIANCE",
"LIGHT",
"SPEED",
"SHARPNESS",
"SHARPNESS2",
"VAMPIRIC",
"BURNS_OUT",
"TAKES_FUEL",
"NO_FUEL",
"COWARDICE",
"HUNGER",
"DARKNESS",
"DANGER",
"HAUNTED",
"AGGRAVATE",
"CURSED",
"DIG_1",
"DIG_2",
"THROWING",
"INDESTRUCTIBLE",
"NO_SMITHING",
"NO_RANDOM",
"MITHRIL",
"AXE",
"POLEARM",
"ENCHANTABLE",
"HAND_AND_A_HALF",
"TWO_HANDED",
"MAX",

  NULL
 };
 /* Write individual entries */
 for (i = z_info->a_max - player->self_made_arts; i < z_info->a_max; i++) {
  const struct artifact *art = &a_info[i];
  char name[120] = "";
  struct object_kind *kind = lookup_kind(art->tval, art->sval);
  int j;
  /* Ignore non-existent artifacts */
  if (!art->name) continue;
  /* Output description */
  file_putf(fff, "# %s\n", art->text);
  /* Output name */
  file_putf(fff, "name:%s\n", art->name);
  /* Output tval and sval */
  object_short_name(name, sizeof name, kind->name);
  file_putf(fff, "base-object:%s:%s\n", tval_find_name(art->tval), name);
  /* Output graphics if necessary */
  if (kind->kidx >= z_info->ordinary_kind_max) {
   const char *attr = attr_to_text(kind->d_attr);
   file_putf(fff, "graphics:%c:%s\n", kind->d_char, attr);
  }
  /* Output pval, level, weight and cost */
  file_putf(fff, "pval:%d\n", art->pval);
  file_putf(fff, "depth:%d\n", art->level);
  file_putf(fff, "rarity:%d\n", art->rarity);
  file_putf(fff, "weight:%d\n", art->weight);
  file_putf(fff, "cost:%d\n", art->cost);
  /* Output combat power */
  file_putf(fff, "attack:%d:%dd%d\n", art->att, art->dd, art->ds);
  file_putf(fff, "defence:%d:%dd%d\n", art->evn, art->pd, art->ps);
  /* Output flags */
  write_flags(fff, "flags:", art->flags, OF_SIZE, obj_flags);
  /* Output modifiers */
  write_mods(fff, art->modifiers);
  /* Output resists, immunities and vulnerabilities */
  write_elements(fff, art->el_info);
  /* Output slays */
  if (art->slays) {
   for (j = 1; j < z_info->slay_max; j++) {
    if (art->slays[j]) {
     file_putf(fff, "slay:%s\n", slays[j].code);
    }
   }
  }
  /* Output brands */
  if (art->brands) {
   for (j = 1; j < z_info->brand_max; j++) {
    if (art->brands[j]) {
     file_putf(fff, "brand:%s\n", brands[j].code);
    }
   }
  }
  /* Output abilities */
  write_abilities(fff, art->abilities);
  file_putf(fff, "\n");
 }
}
/**
 * \file option.c
 * \brief Options table and definitions.
 *
 * Copyright (c) 1997 Ben Harrison
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Option screen interface
 */
int option_page[OPT_PAGE_MAX][OPT_PAGE_PER] = { {0} };
static struct option_entry {
 const char *name;
 const char *description;
 int type;
 bool normal;
} options[OPT_MAX] = {
/**
 * \file list-options.h
 * \brief options
 *
 * Currently, if there are more than 21 of any option type, the later ones
 * will be ignored
 * Cheat options need to be followed by corresponding score options
 */
/* name                   description
type     normal */
{ "none", "", OP_SPECIAL, false },
{ "hjkl_movement", "Move with hjkl etc. (^ for underlying keys)", OP_INTERFACE, false },
{ "use_sound", "Use sound", OP_INTERFACE, false },
{ "quick_messages", "Dismiss '-more-', 'y/n' prompts with any key", OP_INTERFACE, true },
{ "angband_keyset", "Use a keyset more closely based on Angband", OP_INTERFACE, false },
{ "stop_singing_on_rest", "Stop singing when you use the rest command", OP_INTERFACE, true },
{ "forgo_attacking_unwary", "Forgo bonus attacks on non-alert enemies", OP_INTERFACE, true },
{ "beep", "Audible beep (on errors/warnings)", OP_INTERFACE, false },
{ "highlight_player", "Highlight the player with the cursor", OP_INTERFACE, false },
{ "highlight_target", "Highlight the target with the cursor", OP_INTERFACE, true },
{ "highlight_unwary", "Highlight sleeping and unwary creatures", OP_INTERFACE, true },
{ "solid_walls", "Show walls as solid blocks", OP_INTERFACE, true },
{ "hybrid_walls", "Show walls with shaded background", OP_INTERFACE, false },
{ "animate_flicker", "Color: Shimmer multi-colored things", OP_INTERFACE, false },
{ "center_player", "Center map continuously", OP_INTERFACE, false },
{ "run_avoid_center", "Avoid centering while running", OP_INTERFACE, false },
{ "auto_more", "Automatically clear '-more-' prompts", OP_INTERFACE, false },
{ "mouse_movement", "Allow mouse clicks to move the player", OP_INTERFACE, true },
{ "display_hits", "Display a mark when something gets hit", OP_INTERFACE, true },
{ "pickup_always", "Always pickup items", OP_INTERFACE, false },
{ "pickup_inven", "Always pickup items matching inventory", OP_INTERFACE, false },
{ "show_flavors", "Show flavors in object descriptions", OP_INTERFACE, false },
{ "cheat_peek", "Debug: Peek into object creation", OP_CHEAT, false },
{ "score_peek", "Score: Peek into object creation", OP_SCORE, false },
{ "cheat_hear", "Debug: Peek into monster creation", OP_CHEAT, false },
{ "score_hear", "Score: Peek into monster creation", OP_SCORE, false },
{ "cheat_room", "Debug: Peek into dungeon creation", OP_CHEAT, false },
{ "score_room", "Score: Peek into dungeon creation", OP_SCORE, false },
{ "cheat_xtra", "Debug: Peek into something else", OP_CHEAT, false },
{ "score_xtra", "Score: Peek into something else", OP_SCORE, false },
{ "cheat_know", "Debug: Know complete monster info", OP_CHEAT, false },
{ "score_know", "Score: Know complete monster info", OP_SCORE, false },
{ "cheat_live", "Debug: Allow player to avoid death", OP_CHEAT, false },
{ "score_live", "Score: Allow player to avoid death", OP_SCORE, false },
{ "cheat_monsters", "Debug: Continually display all monsters", OP_CHEAT, false },
{ "score_monsters", "Score: Continually display all monsters", OP_SCORE, false },
{ "cheat_noise", "Debug: Continually display noise levels", OP_CHEAT, false },
{ "score_noise", "Score: Continually display noise levels", OP_SCORE, false },
{ "cheat_scent", "Debug: Continually display scent levels", OP_CHEAT, false },
{ "score_scent", "Score: Continually display scent levels", OP_SCORE, false },
{ "cheat_light", "Debug: Continually display light levels", OP_CHEAT, false },
{ "score_light", "Score: Continually display light levels", OP_SCORE, false },
{ "cheat_skill_rolls", "Debug: Show all skill rolls", OP_CHEAT, false },
{ "score_skill_rolls", "Score: Show all skill rolls", OP_SCORE, false },
{ "cheat_timestop", "Debug: Don't allow monsters to move", OP_CHEAT, false },
{ "score_timestop", "Score: Don't allow monsters to move", OP_SCORE, false },
{ "birth_discon_stairs", "Disconnected stairs", OP_BIRTH, false },
{ "birth_force_descend", "Force player descent (never make up stairs)", OP_BIRTH, false },
{ "birth_no_artifacts", "Restrict creation of artifacts", OP_BIRTH, false },

};
/**
 * Given the option type, return a short name in all lower case.
 */
const char *option_type_name(int page)
{
 const char *result;
 switch (page) {
 case OP_INTERFACE:
  result = "interface";
  break;
 case OP_BIRTH:
  result = "birth";
  break;
 case OP_CHEAT:
  result = "cheat";
  break;
 case OP_SCORE:
  result = "score";
  break;
 case OP_SPECIAL:
  result = "special";
  break;
 default:
  result = "unknown";
  break;
 }
 return result;
}
/**
 * Given an option index, return its name
 */
const char *option_name(int opt)
{
 if (opt >= OPT_MAX) return NULL;
 return options[opt].name;
}
/**
 * Given an option index, return its description
 */
const char *option_desc(int opt)
{
 if (opt >= OPT_MAX) return NULL;
 return options[opt].description;
}
/**
 * Determine the type of option (score, birth etc)
 */
int option_type(int opt)
{
 if (opt >= OPT_MAX)
  return 0;
 return options[opt].type;
}
static bool option_is_cheat(int opt)
{
 return (option_type(opt) == OP_CHEAT);
}
/**
 * Set an option, return true if successful
 */
bool option_set(const char *name, int val)
{
 size_t opt;
 /* Try normal options first */
 for (opt = 0; opt < OPT_MAX; opt++) {
  if (!options[opt].name || !streq(options[opt].name, name))
   continue;
  player->opts.opt[opt] = val ? true : false;
  if (val && option_is_cheat(opt))
   player->opts.opt[opt + 1] = true;
  return true;
 }
 return false;
}
/**
 * Clear cheat options
 */
void options_init_cheat(void)
{
 int i;
 for (i = 0; i < OPT_MAX; i++) {
  if (option_is_cheat(i)) {
   player->opts.opt[i] = false;
   player->opts.opt[i + 1] = false;
  }
 }
}
/**
 * Set player default options
 */
void options_init_defaults(struct player_options *opts)
{
 /* Set defaults */
 int opt;
 for (opt = 0; opt < OPT_MAX; opt++)
  (*opts).opt[opt] = options[opt].normal;
 /* Override with the player's customizations. */
 options_restore_custom(opts, OP_BIRTH);
 options_restore_custom(opts, OP_INTERFACE);
 /* 40ms for the delay factor */
 (*opts).delay_factor = 40;
 /* 30% of HP */
 (*opts).hitpoint_warn = 3;
}
/**
 * Record the options of type, page, for later recall.
 *
 * Return true if successful.  Return false if the operation failed.
 */
bool options_save_custom(struct player_options *opts, int page)
{
 const char *page_name = option_type_name(page);
 bool success = true;
 char path[1024], file_name[80];
 ang_file *f;
 strnfmt(file_name, sizeof(file_name), "customized_%s_options.txt",
  page_name);
 path_build(path, sizeof(path), ANGBAND_DIR_USER, file_name);
 f = file_open(path, MODE_WRITE, FTYPE_TEXT);
 if (f) {
  int opt;
  if (!file_putf(f, "# These are customized defaults for the %s options.\n", page_name)) {
   success = false;
  }
  if (!file_put(f, "# All lines begin with \"option:\" followed by the internal option name.\n")) {
   success = false;
  }
  if (!file_put(f, "# After the name is a colon followed by yes or no for the option's state.\n")) {
   success = false;
  }
  for (opt = 0; opt < OPT_MAX; opt++) {
   if (options[opt].type == page) {
    if (!file_putf(f, "# %s\n",
       options[opt].description)) {
     success = false;
    }
    if (!file_putf(f, "option:%s:%s\n",
      options[opt].name,
      ((*opts).opt[opt]) ? "yes" : "no")) {
     success = false;
    }
   }
  }
  if (!file_close(f)) {
   success = false;
  }
 } else {
  success = false;
 }
 return success;
}
/**
 * Reset the options of type, page, to the customized defaults.
 *
 * Return true if successful.  That includes the case where no customized
 * defaults are available.  When that happens, the options are reset to the
 * maintainer's defaults.  Return false if the customized defaults are
 * present but unreadable.
 */
bool options_restore_custom(struct player_options *opts, int page)
{
 const char *page_name = option_type_name(page);
 char path[1024], buf[1024], file_name[80];
 ang_file *f;
 int linenum;
 strnfmt(file_name, sizeof(file_name), "customized_%s_options.txt",
  page_name);
 path_build(path, sizeof(path), ANGBAND_DIR_USER, file_name);
 if (!file_exists(path)) {
  options_restore_maintainer(opts, page);
  return true;
 }
 /*
	 * Could use run_parser(), but that exits the application if
	 * there are syntax errors.  Therefore, use our own parsing.
	 */
 f = file_open(path, MODE_READ, FTYPE_TEXT);
 if (!f) {
  return false;
 }
 linenum = 1;
 while (file_getl(f, buf, sizeof(buf))) {
  char *sub = strstr(buf, "option:"), *com;
  int opt;
  if (!sub) {
   /*
			 * If it isn't an option, it should be a comment or
			 * whitespace.
			 */
   sub = strchr(buf, '#');
   if (sub) {
    *sub = '\0';
   }
   if (!contains_only_spaces(buf)) {
    msg("Line %d of the customized %s options is "
     "not parseable.", linenum, page_name);
   }
   ++linenum;
   continue;
  }
  *sub = '\0';
  /* Ignore if the "option:" is embedded in a comment. */
  com = strchr(buf, '#');
  if (com) {
   *com = '\0';
   if (!contains_only_spaces(buf)) {
    msg("Line %d of the customized %s options is "
     "not parseable.", linenum, page_name);
   }
   ++linenum;
   continue;
  }
  if (!contains_only_spaces(buf)) {
   msg("Line %d of the customized %s options is not "
     "parseable.", linenum, page_name);
   ++linenum;
   continue;
  }
  /* Try to find the option. */
  sub += 7;
  opt = 0;
  while (1) {
   size_t lname;
   if (opt >= OPT_MAX) {
    msg("Unrecognized option at line %d of the "
     "customized %s options.", linenum,
     page_name);
    break;
   }
   if (options[opt].type != page || !options[opt].name) {
    ++opt;
    continue;
   }
   lname = strlen(options[opt].name);
   if (strncmp(options[opt].name, sub, lname) == 0
     && sub[lname] == ':') {
    if (strncmp("yes", sub + lname + 1, 3) == 0
      && contains_only_spaces(sub + lname + 4)) {
     (*opts).opt[opt] = true;
    } else if (strncmp("no", sub + lname + 1, 2) == 0
      && contains_only_spaces(sub + lname + 3)) {
     (*opts).opt[opt] = false;
    } else {
     msg("Value at line %d of the "
      "customized %s options is not "
      "yes or no.", linenum,
      page_name);
    }
    break;
   }
   ++opt;
  }
  ++linenum;
 }
 if (!file_close(f)) {
  return false;
 }
 return true;
}
/**
 * Reset the options of type, page, to the maintainer's defaults.
 */
void options_restore_maintainer(struct player_options *opts, int page)
{
 int opt;
 for (opt = 0; opt < OPT_MAX; opt++)
  if (options[opt].type == page) {
   (*opts).opt[opt] = options[opt].normal;
  }
}
/**
 * List all challenge options at the start of the game
 */
void options_list_challenge(void)
{
 int opt;
 for (opt = 0; opt < OPT_MAX; opt++) {
  if ((options[opt].type == OP_BIRTH) && (player->opts.opt[opt] == true)){
   history_add(player, format("Challenge: %s", option_desc(opt)),
      HIST_CHALLENGE_OPTS);
  }
 }
}
/**
 * Initialise options package
 */
void init_options(void)
{
 int opt, page;
 /* Allocate options to pages */
 for (page = 0; page < OPT_PAGE_MAX; page++) {
  int page_opts = 0;
  for (opt = 0; opt < OPT_MAX; opt++) {
   if ((options[opt].type == page) && (page_opts < OPT_PAGE_PER))
    option_page[page][page_opts++] = opt;
  }
  while (page_opts < OPT_PAGE_PER)
   option_page[page][page_opts++] = OPT_none;
 }
}
struct init_module options_module = {
 .name = "options",
 .init = init_options,
 .cleanup = NULL
};
/**
 * \file parser.c
 * \brief Info file parser.
 *
 * Copyright (c) 2011 elly+angband@leptoquark.net
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * A parser has a list of hooks (which are run across new lines given to
 * parser_parse()) and a list of the set of named values for the current line.
 * Each hook has a list of specs, which are essentially named formal parameters;
 * when we run a particular hook across a line, each spec in the hook is
 * assigned a value.
 */
enum {
 PARSE_T_NONE = 0,
 PARSE_T_INT = 2,
 PARSE_T_SYM = 4,
 PARSE_T_STR = 6,
 PARSE_T_RAND = 8,
 PARSE_T_UINT = 10,
 PARSE_T_CHAR = 12,
 PARSE_T_OPT = 0x00000001
};
struct parser_spec {
 struct parser_spec *next;
 int type;
 const char *name;
};
struct parser_value {
 struct parser_spec spec;
 union {
  wchar_t cval;
  int ival;
  unsigned int uval;
  char *sval;
  random_value rval;
 } u;
};
struct parser_hook {
 struct parser_hook *next;
 enum parser_error (*func)(struct parser *p);
 char *dir;
 struct parser_spec *fhead;
 struct parser_spec *ftail;
};
struct parser {
 enum parser_error error;
 unsigned int lineno;
 unsigned int colno;
 char errmsg[1024];
 struct parser_hook *hooks;
 struct parser_value *fhead;
 struct parser_value *ftail;
 void *priv;
};
/**
 * Allocates a new parser.
 */
struct parser *parser_new(void) {
 struct parser *p = mem_zalloc(sizeof *p);
 return p;
}
static struct parser_hook *findhook(struct parser *p, const char *dir) {
 struct parser_hook *h = p->hooks;
 while (h) {
  if (streq(h->dir, dir))
   break;
  h = h->next;
 }
 return h;
}
static void parser_freeold(struct parser *p) {
 struct parser_value *v;
 while (p->fhead) {
  int t = p->fhead->spec.type & ~PARSE_T_OPT;
  v = (struct parser_value *)p->fhead->spec.next;
  if (t == PARSE_T_SYM || t == PARSE_T_STR)
   mem_free(p->fhead->u.sval);
  mem_free(p->fhead);
  p->fhead = v;
 }
}
static bool parse_random(const char *str, random_value *bonus) {
 bool negative = false;
 /* base, number of dice, sides, and bonus */
 int values[4] = { 0, 0, 0, 0 };
 int i = 0, min_i = 1;
 /* Entire value may be negated */
 if (str[0] == '-') {
  negative = true;
  ++str;
 }
 while (1) {
  if (*str == 'd') {
   if (i > 2) {
    return false;
   }
   if (i < 2) {
    i = 2;
    /*
				 * 'd' with no preceding number implies one die.
				 */
    values[1] = 1;
   }
   min_i = 3;
   ++str;
  } else if (*str == 'M') {
   if (i == 2) {
    return false;
   }
   i = 3;
   min_i = 4;
   ++str;
  } else {
   char *pe;
   unsigned long uv = strtoul(str, &pe, 10);
   if (pe == str) {
    /*
				 * Trailing garbage or not enough values are
				 * not accepted.
				 */
    if (!contains_only_spaces(str) || i < min_i) {
     return false;
    }
    break;
   } else if (uv > INT_MAX || *str == '+') {
    return false;
   }
   str = pe;
   if (i == 0) {
    if (*str == 'd') {
     i = 1;
    } else if (*str == '+') {
     ++str;
     min_i = 3;
    } else {
     if (!contains_only_spaces(pe)) {
      return false;
     }
     values[0] = (int)uv;
     break;
    }
   } else if (i == 4) {
    return false;
   }
   values[i] = (int)uv;
   ++i;
  }
 }
 /* Assign the values */
 bonus->base = values[0];
 bonus->dice = values[1];
 bonus->sides = values[2];
 bonus->m_bonus = values[3];
 /*
	 * Handle negation (the random components are always positive, so the
	 * base must be adjusted as necessary).
	 */
 if (negative) {
  bonus->base *= -1;
  bonus->base -= bonus->m_bonus;
  bonus->base -= bonus->dice * (bonus->sides + 1);
 }
 return true;
}
/**
 * Parses the provided line.
 *
 * This runs the first parser hook registered with `p` that matches `line`.
 */
enum parser_error parser_parse(struct parser *p, const char *line) {
 char *cline;
 char *tok;
 struct parser_hook *h;
 struct parser_spec *s;
 struct parser_value *v;
 char *sp = NULL;
 assert(p);
 assert(line);
 parser_freeold(p);
 p->lineno++;
 p->colno = 1;
 p->fhead = NULL;
 p->ftail = NULL;
 /* Ignore empty lines and comments. */
 while (*line && (isspace(*line)))
  line++;
 if (!*line || *line == '#')
  return PARSE_ERROR_NONE;
 cline = string_make(line);
 tok = strtok(cline, ":");
 if (!tok) {
  mem_free(cline);
  p->error = PARSE_ERROR_MISSING_FIELD;
  return PARSE_ERROR_MISSING_FIELD;
 }
 h = findhook(p, tok);
 if (!h) {
  my_strcpy(p->errmsg, tok, sizeof(p->errmsg));
  p->error = PARSE_ERROR_UNDEFINED_DIRECTIVE;
  mem_free(cline);
  return PARSE_ERROR_UNDEFINED_DIRECTIVE;
 }
 /* There's a little bit of trickiness here to account for optional
	 * types. The optional flag has a bit assigned to it in the spec's type
	 * tag; we compute a temporary type for the spec with that flag removed
	 * and use that instead. */
 for (s = h->fhead; s; s = s->next) {
  int t = s->type & ~PARSE_T_OPT;
  p->colno++;
  /* These types are tokenized on ':'; strings are not tokenized
		 * at all (i.e., they consume the remainder of the line) */
  if (t == PARSE_T_INT || t == PARSE_T_SYM || t == PARSE_T_RAND ||
   t == PARSE_T_UINT) {
   tok = strtok(sp, ":");
   sp = NULL;
  } else if (t == PARSE_T_CHAR) {
   tok = strtok(sp, "");
   if (tok)
    sp = tok + 2;
  } else {
   tok = strtok(sp, "");
   sp = NULL;
  }
  if (!tok) {
   if (!(s->type & PARSE_T_OPT)) {
    my_strcpy(p->errmsg, s->name, sizeof(p->errmsg));
    p->error = PARSE_ERROR_MISSING_FIELD;
    mem_free(cline);
    return PARSE_ERROR_MISSING_FIELD;
   }
   break;
  }
  /* Allocate a value node. */
  v = mem_alloc(sizeof *v);
  v->spec.next = NULL;
  v->spec.type = s->type;
  v->spec.name = s->name;
  /* Parse out its value. */
  if (t == PARSE_T_INT) {
   char *z = NULL;
   v->u.ival = strtol(tok, &z, 0);
   if (z == tok) {
    mem_free(v);
    mem_free(cline);
    my_strcpy(p->errmsg, s->name, sizeof(p->errmsg));
    p->error = PARSE_ERROR_NOT_NUMBER;
    return PARSE_ERROR_NOT_NUMBER;
   }
  } else if (t == PARSE_T_UINT) {
   char *z = NULL;
   v->u.uval = strtoul(tok, &z, 0);
   if (z == tok || *tok == '-') {
    mem_free(v);
    mem_free(cline);
    my_strcpy(p->errmsg, s->name, sizeof(p->errmsg));
    p->error = PARSE_ERROR_NOT_NUMBER;
    return PARSE_ERROR_NOT_NUMBER;
   }
  } else if (t == PARSE_T_CHAR) {
   text_mbstowcs(&v->u.cval, tok, 1);
  } else if (t == PARSE_T_SYM || t == PARSE_T_STR) {
   v->u.sval = string_make(tok);
  } else if (t == PARSE_T_RAND) {
   if (!parse_random(tok, &v->u.rval)) {
    mem_free(v);
    mem_free(cline);
    my_strcpy(p->errmsg, s->name, sizeof(p->errmsg));
    p->error = PARSE_ERROR_NOT_RANDOM;
    return PARSE_ERROR_NOT_RANDOM;
   }
  }
  /* Link it into the value list. */
  if (!p->fhead)
   p->fhead = v;
  else
   p->ftail->spec.next = &v->spec;
  p->ftail = v;
 }
 mem_free(cline);
 p->error = h->func(p);
 return p->error;
}
/**
 * Gets parser's private data.
 */
void *parser_priv(struct parser *p) {
 return p->priv;
}
/**
 * Sets parser's private data.
 *
 * This is commonly used to store context for stateful parsing.
 */
void parser_setpriv(struct parser *p, void *v) {
 p->priv = v;
}
static int parse_type(const char *s) {
 int rv = 0;
 if (s[0] == '?') {
  rv |= PARSE_T_OPT;
  s++;
 }
 if (streq(s, "int"))
  return PARSE_T_INT | rv;
 if (streq(s, "sym"))
  return PARSE_T_SYM | rv;
 if (streq(s, "str"))
  return PARSE_T_STR | rv;
 if (streq(s, "rand"))
  return PARSE_T_RAND | rv;
 if (streq(s, "uint"))
  return PARSE_T_UINT | rv;
 if (streq(s, "char"))
  return PARSE_T_CHAR | rv;
 return PARSE_T_NONE;
}
static void clean_specs(struct parser_hook *h) {
 struct parser_spec *s;
 mem_free(h->dir);
 while (h->fhead) {
  s = h->fhead;
  h->fhead = h->fhead->next;
  mem_free((void*)s->name);
  mem_free(s);
 }
}
/**
 * Destroys a parser.
 */
void parser_destroy(struct parser *p) {
 struct parser_hook *h;
 parser_freeold(p);
 while (p->hooks) {
  h = p->hooks->next;
  clean_specs(p->hooks);
  mem_free(p->hooks);
  p->hooks = h;
 }
 mem_free(p);
}
static errr parse_specs(struct parser_hook *h, char *fmt) {
 char *name ;
 char *stype = NULL;
 int type;
 struct parser_spec *s;
 assert(h);
 assert(fmt);
 name = strtok(fmt, " ");
 if (!name)
  return -EINVAL;
 h->dir = string_make(name);
 h->fhead = NULL;
 h->ftail = NULL;
 while (name) {
  /* Lack of a type is legal; that means we're at the end of the line. */
  stype = strtok(NULL, " ");
  if (!stype)
   break;
  /* Lack of a name, on the other hand... */
  name = strtok(NULL, " ");
  if (!name) {
   clean_specs(h);
   return -EINVAL;
  }
  /* Grab a type, check to see if we have a mandatory type
		 * following an optional type. */
  type = parse_type(stype);
  if (type == PARSE_T_NONE) {
   clean_specs(h);
   return -EINVAL;
  }
  if (!(type & PARSE_T_OPT) && h->ftail &&
   (h->ftail->type & PARSE_T_OPT)) {
   clean_specs(h);
   return -EINVAL;
  }
  if (h->ftail && ((h->ftail->type & ~PARSE_T_OPT) == PARSE_T_STR)) {
   clean_specs(h);
   return -EINVAL;
  }
  /* Save this spec. */
  s = mem_alloc(sizeof *s);
  s->type = type;
  s->name = string_make(name);
  s->next = NULL;
  if (h->fhead)
   h->ftail->next = s;
  else
   h->fhead = s;
  h->ftail = s;
 }
 return 0;
}
/**
 * Registers a parser hook.
 *
 * Hooks have the following format:
 *   <fmt>  ::= <name> [<type> <name>]* [?<type> <name>]*
 *   <type> ::= int | str | sym | rand | char
 * The first <name> is called the directive for this hook. Any other hooks with
 * the same directive are superseded by this hook. It is an error for a
 * mandatory field to follow an optional field. It is an error for any field to
 * follow a field of type `str`, since `str` fields are not delimited and will
 * consume the entire rest of the line.
 */
errr parser_reg(struct parser *p, const char *fmt,
                enum parser_error (*func)(struct parser *p)) {
 errr r;
 char *cfmt;
 struct parser_hook *h;
 assert(p);
 assert(fmt);
 assert(func);
 h = mem_alloc(sizeof *h);
 cfmt = string_make(fmt);
 h->next = p->hooks;
 h->func = func;
 r = parse_specs(h, cfmt);
 if (r)
 {
  mem_free(h);
  mem_free(cfmt);
  return r;
 }
 p->hooks = h;
 mem_free(cfmt);
 return 0;
}
/**
 * A placeholder parse hook indicating a value is ignored
 */
enum parser_error ignored(struct parser *p) {
 return PARSE_ERROR_NONE;
}
/**
 * Returns whether the parser has a value named `name`.
 *
 * Used to test for presence of optional values.
 */
bool parser_hasval(struct parser *p, const char *name) {
 struct parser_value *v;
 for (v = p->fhead; v; v = (struct parser_value *)v->spec.next) {
  if (streq(v->spec.name, name))
   return true;
 }
 return false;
}
static struct parser_value *parser_getval(struct parser *p, const char *name) {
 struct parser_value *v;
 for (v = p->fhead; v; v = (struct parser_value *)v->spec.next) {
  if (streq(v->spec.name, name)) {
   return v;
  }
 }
 quit_fmt("parser_getval error: name is %s\n", name);
 return 0; /* Needed to avoid Windows compiler warning */
}
/**
 * Returns the symbol named `name`. This symbol must exist.
 */
const char *parser_getsym(struct parser *p, const char *name) {
 struct parser_value *v = parser_getval(p, name);
 assert((v->spec.type & ~PARSE_T_OPT) == PARSE_T_SYM);
 return v->u.sval;
}
/**
 * Returns the integer named `name`. This symbol must exist.
 */
int parser_getint(struct parser *p, const char *name) {
 struct parser_value *v = parser_getval(p, name);
 assert((v->spec.type & ~PARSE_T_OPT) == PARSE_T_INT);
 return v->u.ival;
}
/**
 * Returns the unsigned integer named `name`. This symbol must exist.
 */
unsigned int parser_getuint(struct parser *p, const char *name) {
 struct parser_value *v = parser_getval(p, name);
 assert((v->spec.type & ~PARSE_T_OPT) == PARSE_T_UINT);
 return v->u.uval;
}
/**
 * Returns the string named `name`. This symbol must exist.
 */
const char *parser_getstr(struct parser *p, const char *name) {
 struct parser_value *v = parser_getval(p, name);
 assert((v->spec.type & ~PARSE_T_OPT) == PARSE_T_STR);
 return v->u.sval;
}
/**
 * Returns the random value named `name`. This symbol must exist.
 */
struct random parser_getrand(struct parser *p, const char *name) {
 struct parser_value *v = parser_getval(p, name);
 assert((v->spec.type & ~PARSE_T_OPT) == PARSE_T_RAND);
 return v->u.rval;
}
/**
 * Returns the character named `name`. This symbol must exist.
 */
wchar_t parser_getchar(struct parser *p, const char *name) {
 struct parser_value *v = parser_getval(p, name);
 assert((v->spec.type & ~PARSE_T_OPT) == PARSE_T_CHAR);
 return v->u.cval;
}
/**
 * Fills the provided struct with the parser's state, if any. Returns true if
 * the parser is in an error state, and false otherwise.
 */
int parser_getstate(struct parser *p, struct parser_state *s) {
 s->error = p->error;
 s->line = p->lineno;
 s->col = p->colno;
 s->msg = p->errmsg;
 return s->error != PARSE_ERROR_NONE;
}
/**
 * Sets the parser's detailed error description and field number.
 */
void parser_setstate(struct parser *p, unsigned int col, const char *msg) {
 p->colno = col;
 my_strcpy(p->errmsg, msg, sizeof(p->errmsg));
}
/**
 * \file player-abilities.c 
 * \brief Player abilities
 *
 * Copyright (c) 1997-2020 Ben Harrison, James E. Wilson, Robert A. Koeneke,
 * Nick McConnell
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
struct ability *abilities;
/**
 * ------------------------------------------------------------------------
 * Initialize abilities
 * ------------------------------------------------------------------------ */
/* Temporary list to store prerequisite details; 199 should be enough */
static struct {
 uint8_t skill;
 const char *name;
} prereq_list[100];
static unsigned int prereq_num = 1;
static unsigned int skill_index;
static enum parser_error parse_ability_skill(struct parser *p) {
 const char *name = parser_getstr(p, "name");
 int index = lookup_skill(name);
 if (index < 0)
  return PARSE_ERROR_UNRECOGNISED_SKILL;
 skill_index = (unsigned int) index;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_ability_name(struct parser *p) {
 const char *name = parser_getstr(p, "name");
 struct ability *last = parser_priv(p);
 struct ability *a = mem_zalloc(sizeof *a);
 if (last) {
  last->next = a;
 } else {
  abilities = a;
 }
 parser_setpriv(p, a);
 a->name = string_make(name);
 a->skill = skill_index;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_ability_level(struct parser *p) {
 struct ability *a = parser_priv(p);
 if (!a)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 a->level = parser_getint(p, "level");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_ability_prereq(struct parser *p) {
 int skill = lookup_skill(parser_getsym(p, "skill"));
 const char *name = parser_getsym(p, "ability");
 struct ability *a = parser_priv(p);
 int i;
 if (!a)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 if (skill < 0)
  return PARSE_ERROR_INVALID_SKILL;
 /* Store the prereq details locally */
 prereq_list[prereq_num].skill = skill;
 prereq_list[prereq_num].name = string_make(name);
 /* Store the index in the struct */
 for (i = 0; i < MAX_PREREQS; i++) {
  if (!a->prereq_index[i]) break;
 }
 if (i == MAX_PREREQS)
  return PARSE_ERROR_TOO_MANY_ABILITY_PREREQS;
 a->prereq_index[i] = prereq_num;
 prereq_num++;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_ability_type(struct parser *p) {
 struct poss_item *poss;
 int i;
 int tval = tval_find_idx(parser_getstr(p, "tval"));
 bool found_one_kind = false;
 struct ability *a = parser_priv(p);
 if (!a)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 if (tval < 0)
  return PARSE_ERROR_UNRECOGNISED_TVAL;
 /* Find all the right object kinds */
 for (i = 0; i < z_info->k_max; i++) {
  if (k_info[i].tval != tval) continue;
  poss = mem_zalloc(sizeof(struct poss_item));
  poss->kidx = i;
  poss->next = a->poss_items;
  a->poss_items = poss;
  found_one_kind = true;
 }
 if (!found_one_kind)
  return PARSE_ERROR_NO_KIND_FOR_ABILITY;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_ability_item(struct parser *p) {
 struct poss_item *poss;
 int tval = tval_find_idx(parser_getsym(p, "tval"));
 int sval = lookup_sval(tval, parser_getsym(p, "sval"));
 struct ability *a = parser_priv(p);
 if (!a)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 if (tval < 0)
  return PARSE_ERROR_UNRECOGNISED_TVAL;
 if (sval < 0)
  return PARSE_ERROR_UNRECOGNISED_SVAL;
 poss = mem_zalloc(sizeof(struct poss_item));
 poss->kidx = lookup_kind(tval, sval)->kidx;
 poss->next = a->poss_items;
 a->poss_items = poss;
 if (poss->kidx <= 0)
  return PARSE_ERROR_INVALID_ITEM_NUMBER;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_ability_desc(struct parser *p) {
 struct ability *a = parser_priv(p);
 if (!a)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 a->desc = string_append(a->desc, parser_getstr(p, "desc"));
 return PARSE_ERROR_NONE;
}
static struct parser *init_parse_ability(void) {
 struct parser *p = parser_new();
 parser_setpriv(p, NULL);
 prereq_num = 1;
 parser_reg(p, "skill str name", parse_ability_skill);
 parser_reg(p, "name str name", parse_ability_name);
 parser_reg(p, "level int level", parse_ability_level);
 parser_reg(p, "prerequisite sym skill sym ability", parse_ability_prereq);
 parser_reg(p, "type str tval", parse_ability_type);
 parser_reg(p, "item sym tval sym sval", parse_ability_item);
 parser_reg(p, "desc str desc", parse_ability_desc);
 return p;
}
static errr run_parse_ability(struct parser *p) {
 return parse_file_quit_not_found(p, "ability");
}
static errr finish_parse_ability(struct parser *p) {
 struct ability *a;
 /* Fill in prerequisite abilities */
 for (a = abilities; a; a = a->next) {
  int i = 0;
  while (a->prereq_index[i]) {
   int idx = a->prereq_index[i];
   struct ability *pre = mem_zalloc(sizeof *pre);
   struct ability *stored = lookup_ability(prereq_list[idx].skill,
             prereq_list[idx].name);
   if (!stored)
    return PARSE_ERROR_INVALID_ABILITY;
   memcpy(pre, stored, sizeof(*pre));
   pre->next = a->prerequisites;
   a->prerequisites = pre;
   i++;
  }
 }
 /* Done with prereq_list so release the resources allocated for it. */
 while (prereq_num > 1) {
  --prereq_num;
  string_free((char*)prereq_list[prereq_num].name);
  prereq_list[prereq_num].name = NULL;
 }
 parser_destroy(p);
 return 0;
}
static void cleanup_ability(void)
{
 struct ability *a = abilities;
 while (a) {
  struct ability *a_next = a->next;
  struct ability *pre = a->prerequisites;
  struct poss_item *poss = a->poss_items;
  while (poss) {
   struct poss_item *poss_next = poss->next;
   mem_free(poss);
   poss = poss_next;
  }
  while (pre) {
   struct ability *pre_next = pre->next;
   mem_free(pre);
   pre = pre_next;
  }
  string_free(a->name);
  string_free(a->desc);
  mem_free(a);
  a = a_next;
 }
}
struct file_parser ability_parser = {
 "ability",
 init_parse_ability,
 run_parse_ability,
 finish_parse_ability,
 cleanup_ability
};
/**
 * ------------------------------------------------------------------------
 * Ability utilities
 * ------------------------------------------------------------------------ */
/**
 * Find an ability given its name and skill
 */
struct ability *lookup_ability(int skill, const char *name)
{
 struct ability *ability = abilities;
 if (skill < 0) {
  msg("Invalid skill index passed to lookup_ability()!");
  return NULL;
 }
 while (ability) {
  if ((ability->skill == skill) && streq(ability->name, name)) {
   return ability;
  }
  ability = ability->next;
 }
 //msg("Could not find %s %s ability!", skill_names[skill], name);
 return NULL;
}
/**
 * Counts the abilities for a given skill in a set.
 * If the skill is SKILL_MAX, count all abilities.
 */
static int count_abilities(struct ability *ability, int skill)
{
 int count = 0;
 assert(0 <= skill && skill <= SKILL_MAX);
 while (ability) {
  if ((skill == SKILL_MAX) || (skill == ability->skill)) {
   count++;
  }
  ability = ability->next;
 }
 return count;
}
static bool ability_is_active(const struct ability *ability)
{
 return ability->active;
}
static int test_ability(const char *name, struct ability *test,
      ability_predicate pred)
{
 int skill, count = 0;
 bool found = false;
 if (!test) return 0;
 /* Look in every skill for an ability with the right name */
 for (skill = 0; skill < SKILL_MAX; skill++) {
  struct ability *ability = lookup_ability(skill, name);
  if (ability) {
   struct ability *thisa = test;
   /* Note that we have found an ability of that name */
   found = true;
   /* See if the provided ability list contains the named one... */
   while (thisa) {
    if (streq(thisa->name, name) && (thisa->skill == skill)) {
     /* ...and if so, if it satisfies any required condition */
     if (!pred || (pred && pred(thisa))) {
      count++;
     }
    }
    thisa = thisa->next;
   }
  }
 }
 if (!found) {
  assert(0);
 }
 return count;
}
/**
 * Does the given object type support the given ability type?
 */
bool applicable_ability(struct ability *ability, struct object *obj)
{
 struct poss_item *poss = ability->poss_items;
 for (poss = ability->poss_items; poss; poss = poss->next) {
  if (poss->kidx == obj->kind->kidx) return true;
 }
 /* Throwing Mastery is OK for throwing items */
 if (of_has(obj->flags, OF_THROWING) && (ability->skill == SKILL_MELEE) &&
  streq(ability->name, "Throwing Mastery")) {
  return true;
 }
 return false;
}
/**
 * Reports if a given ability is already in a set of abilities.
 */
struct ability *locate_ability(struct ability *ability, struct ability *test)
{
 /* Look for the right one */
 while (ability) {
  if ((ability->skill == test->skill) &&
   streq(ability->name, test->name)) break;
  ability = ability->next;
 }
 return ability;
}
/**
 * Adds a given ability to a set of abilities.
 */
void add_ability(struct ability **set, struct ability *add)
{
 struct ability *new;
 /* Check if we have it already */
 new = *set;
 if (locate_ability(new, add)) return;
 /* Not found, add the new one */
 new = mem_zalloc(sizeof(*new));
 memcpy(new, add, sizeof(*new));
 new->next = *set;
 *set = new;
}
/**
 * Activates a given ability in a set of abilities.
 */
void activate_ability(struct ability **set, struct ability *activate)
{
 struct ability *ability;
 for (ability = *set; ability; ability = ability->next) {
  if (streq(ability->name, activate->name)) {
   ability->active = true;
   break;
  }
 }
}
/**
 * Removes a given ability from a set of abilities.
 */
void remove_ability(struct ability **ability, struct ability *remove)
{
 struct ability *current = *ability, *prev = NULL, *next = NULL;
 /* Look for the ability to remove */
 while (current) {
  next = current->next;
  if ((current->skill == remove->skill) &&
   streq(current->name, remove->name)) {
   break;
  }
  prev = current;
  current = next;
 }
 /* Excise the ability if we have it */
 if (current) {
  if (prev) {
   /* We're removing an ability from the middle or end of the list */
   prev->next = next;
  } else {
   /* We're removing the head ability and replacing it with the next */
   *ability = next;
  }
  mem_free(current);
 }
}
bool player_has_ability(struct player *p, struct ability *ability)
{
 if (!ability) return false;
 if (locate_ability(p->abilities, ability)) return true;
 if (locate_ability(p->item_abilities, ability)) return true;
 return false;
}
int player_active_ability(struct player *p, const char *name)
{
 int count;
 if (!p) return 0;
 count = test_ability(name, p->abilities, ability_is_active);
 count += test_ability(name, p->item_abilities, ability_is_active);
 return count;
}
bool player_has_prereq_abilities(struct player *p, struct ability *ability)
{
 struct ability *prereqs = ability->prerequisites;
 if (prereqs) {
  while (prereqs) {
   struct ability *possessed = p->abilities;
   while (possessed) {
    if (streq(possessed->name, prereqs->name) &&
     (possessed->skill == prereqs->skill)) {
     return true;
    }
    possessed = possessed->next;
   }
   prereqs = prereqs->next;
  }
  return false;
 }
 return true;
}
/**
 * Ability cost is based on race and class affinity for the relevant skill,
 * the number of abilities already gained from that skill.
 */
int player_ability_cost(struct player *p, struct ability *ability)
{
 int skill = ability->skill;
 int num = count_abilities(p->abilities, skill);
 int cost = (num + 1) * z_info->ability_cost;
 int affinity = p->race->skill_adj[skill] + p->house->skill_adj[skill];
 cost -= affinity * z_info->ability_cost;
 return MAX(0, cost);
}
bool player_can_gain_ability(struct player *p, struct ability *ability)
{
 return player_ability_cost(p, ability) <= p->new_exp;
}
bool player_gain_ability(struct player *p, struct ability *ability)
{
 struct ability *new;
 int cost = player_ability_cost(p, ability);
 if (cost > p->new_exp) {
  msg("You do not have enough experience to acquire this ability.");
  return false;
 }
 if (!get_check("Are you sure you wish to gain this ability? ")) {
  return false;
 }
 p->new_exp -= cost;
 add_ability(&p->abilities, ability);
 new = locate_ability(p->abilities, ability);
 new->active = true;
 /*
	 * For some abilities, updating the bonuses is necessary; for some it
	 * is not.  Having that indicated in ability.txt seems like overkill
	 * to avoid an update_bonuses() call.
	 */
 p->upkeep->update |= (PU_BONUS);
 p->upkeep->redraw |= (PR_EXP);
 return true;
}
/**
 * Release a linked list of abilities where each entry in the list is a
 * shallow copy, except for the next field, of an entry in the global abilities
 * list.
 *
 * \param head points to the first entry in the list.
 */
void release_ability_list(struct ability *head)
{
 while (head) {
  struct ability *tgt = head;
  head = head->next;
  mem_free(tgt);
 }
}
/**
 * Copy a linked list of abilities where each entry in the list is a
 * shallow copy, except for the next field, of an entry in the global abilities
 * list.
 *
 * \param head points to the first entry in the list.
 * \return the pointer to the first entry in the copied list.
 */
struct ability *copy_ability_list(const struct ability *head)
{
 struct ability *dest_head, *dest_tail;
 if (!head) {
  return NULL;
 }
 dest_head = mem_alloc(sizeof(*dest_head));
 memcpy(dest_head, head, sizeof(*dest_head));
 dest_tail = dest_head;
 while (head->next) {
  head = head->next;
  dest_tail->next = mem_alloc(sizeof(*(dest_tail->next)));
  dest_tail = dest_tail->next;
  memcpy(dest_tail, head, sizeof(*dest_tail));
 }
 dest_tail->next = NULL;
 return dest_head;
}
/**
 * \file player-attack.c
 * \brief Attacks (both throwing and melee) by the player
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * ------------------------------------------------------------------------
 * Ability-based attack functions
 * ------------------------------------------------------------------------ */
/**
 *  Determines whether an attack is a charge attack
 */
static bool valid_charge(struct player *p, struct loc grid, int attack_type)
{
 int d, i;
 int delta_y = grid.y - p->grid.y;
 int delta_x = grid.x - p->grid.x;
 if (player_active_ability(p, "Charge") && (p->state.speed > 1) &&
     ((attack_type == ATT_MAIN) || (attack_type == ATT_FLANKING) ||
   (attack_type == ATT_CONTROLLED_RETREAT))) {
  /* Try all three directions */
  for (i = -1; i <= 1; i++) {
   d = cycle[chome[dir_from_delta(delta_y, delta_x)] + i];
   if (p->previous_action[1] == d) {
    return true;
   }
  }
 }
 return false;
}
/**
 * Attacks a new monster with 'follow through' if applicable
 */
static void possible_follow_through(struct player *p, struct loc grid,
         int attack_type)
{
 int d, i;
 struct loc new_grid;
 int delta_y = grid.y - p->grid.y;
 int delta_x = grid.x - p->grid.x;
 if (player_active_ability(p, "Follow-Through") && !p->timed[TMD_CONFUSED] &&
  ((attack_type == ATT_MAIN) || (attack_type == ATT_FLANKING) ||
   (attack_type == ATT_CONTROLLED_RETREAT) ||
   (attack_type == ATT_FOLLOW_THROUGH))) {
        /* Look through adjacent squares in an anticlockwise direction */
        for (i = 1; i < 8; i++) {
   struct monster *mon;
            d = cycle[chome[dir_from_delta(delta_y, delta_x)] + i];
            new_grid = loc_sum(p->grid, ddgrid[d]);
   mon = square_monster(cave, new_grid);
            if (mon && monster_is_visible(mon) &&
    (!OPT(p, forgo_attacking_unwary) ||
     (mon->alertness >= ALERTNESS_ALERT))) {
                    msg("You continue your attack!");
                    py_attack_real(p, new_grid, ATT_FOLLOW_THROUGH);
                    return;
   }
  }
 }
}
/**
 * Cruel blow ability
 */
static void py_cruel_blow(int crit_bonus_dice, struct monster *mon)
{
 char m_name[80];
 if (player_active_ability(player, "Cruel Blow")) {
  /* Must be a damaging critical hit */
  if (crit_bonus_dice <= 0) return;
  /* Monster must not resist */
  if (rf_has(mon->race->flags, RF_RES_CRIT)) return;
  monster_desc(m_name, sizeof(m_name), mon, MDESC_TARG);
  if (skill_check(source_player(), crit_bonus_dice * 4,
      monster_skill(mon, SKILL_WILL),
      source_monster(mon->midx)) > 0) {
   msg("%s reels in pain!", m_name);
   /* Confuse the monster (if possible)
			 * The +1 is needed as a turn of this wears off immediately */
   mon_inc_timed(mon, MON_TMD_CONF, crit_bonus_dice + 1, 0);
   /* Cause a temporary morale penalty */
   scare_onlooking_friends(mon, -20);
  }
 }
}
/**
 * ------------------------------------------------------------------------
 * Attack calculations
 * ------------------------------------------------------------------------ */
/**
 * Determines the protection percentage
 */
int prt_after_sharpness(struct player *p, const struct object *obj, int *flag)
{
 int protection = 100;
 struct song *sharp = lookup_song("Sharpness");
 if (!obj) return 0;
 /* Sharpness */
 if (of_has(obj->flags, OF_SHARPNESS)) {
  *flag = OF_SHARPNESS;
  protection = 50;
 }
 /* Sharpness 2 */
 if (of_has(obj->flags, OF_SHARPNESS2)) {
  *flag = OF_SHARPNESS2;
  protection = 0;
 }
 /* Song of sharpness */
 if (player_is_singing(p, sharp)) {
  if (tval_is_sharp(obj)) {
   protection -= song_bonus(p, p->state.skill_use[SKILL_SONG], sharp);
  }
 }
 return MAX(protection, 0);
}
void attack_punctuation(char *punctuation, size_t len, int net_dam,
      int crit_bonus_dice)
{
 if (net_dam == 0) {
  my_strcpy(punctuation, "...", len);
 } else if (crit_bonus_dice <= 0) {
  my_strcpy(punctuation, ".", len);
 } else {
  size_t i;
  for (i = 0; (i < (size_t) crit_bonus_dice) && (i < len - 1); i++) {
   punctuation[i] = '!';
  }
  punctuation[i] = '\0';
 }
}
/**
 * ------------------------------------------------------------------------
 * Melee attack
 * ------------------------------------------------------------------------ */
/**
 * A whirlwind attack is possible
 */
static bool whirlwind_possible(struct player *p)
{
 int d, dir;
 struct loc grid;
 if (p->timed[TMD_RAGE]) return true;
 if (!player_active_ability(p, "Whirlwind Attack")) {
  return false;
 }
 /* Check adjacent squares for impassable squares */
  for (d = 0; d < 8; d++) {
   dir = cycle[d];
   grid = loc_sum(p->grid, ddgrid[dir]);
   if (square_iswall(cave, grid)) {
    return false;
   }
  }
 return true;
}
/**
 * A whirlwind attack
 */
static void whirlwind(struct player *p, struct loc grid)
{
 int i, dir, dir0;
 bool clockwise = one_in_(2);
 /* Message only for rage (too annoying otherwise) */
 if (p->timed[TMD_RAGE]) {
  msg("You strike out at everything around you!");
 }
 dir = dir_from_delta(grid.y - p->grid.y, grid.x - p->grid.x);
 /* Extract cycle index */
 dir0 = chome[dir];
 /* Attack the adjacent squares in sequence */
 for (i = 0; i < 8; i++) {
  struct loc adj_grid;
  struct monster *mon;
  if (clockwise) {
   dir = cycle[dir0 + i];
  } else {
   dir = cycle[dir0 - i];
  }
  adj_grid = loc_sum(p->grid, ddgrid[dir]);
  mon = square_monster(cave, adj_grid);
  if (mon) {
   if (p->timed[TMD_RAGE]) {
    py_attack_real(p, adj_grid, ATT_RAGE);
   } else if ((i == 0) || !OPT(p, forgo_attacking_unwary) ||
        (mon->alertness >= ALERTNESS_ALERT)) {
    py_attack_real(p, adj_grid, ATT_WHIRLWIND);
   }
  }
 }
}
/**
 * Attack the monster at the given location with a single blow.
 */
void py_attack_real(struct player *p, struct loc grid, int attack_type)
{
 /* Information about the target of the attack */
 struct monster *mon = square_monster(cave, grid);
 struct monster_race *race = mon ? mon->race : NULL;
 char m_name[80];
 char name[80];
 /* The weapon used */
 struct object *obj = equipped_item_by_slot_name(p, "weapon");
 /* Information about the attack */
 int blows = 1;
 int num = 0;
 int attack_mod = 0, total_attack_mod = 0, total_evasion_mod = 0;
 int hit_result = 0;
 int dam = 0, prt = 0;
 int net_dam = 0;
 int prt_percent = 100;
 int stealth_bonus = 0;
 int mdd, mds;
    bool monster_riposte = false;
    bool abort_attack = false;
 bool charge = false;
 bool rapid_attack = false;
 char verb[20];
 char punct[20];
 int weight;
 const struct artifact *crown = lookup_artifact_name("of Morgoth");
 /* Default to punching */
 my_strcpy(verb, "punch", sizeof(verb));
 /* Extract monster name (or "it") */
 monster_desc(m_name, sizeof(m_name), mon, MDESC_TARG);
 /* Auto-Recall and track if possible and visible */
 if (monster_is_visible(mon)) {
  monster_race_track(p->upkeep, mon->race);
  health_track(p->upkeep, mon);
 }
 /* Handle player fear (only for invisible monsters) */
 if (p->timed[TMD_AFRAID]) {
  msgt(MSG_AFRAID, "You are too afraid to attack %s!", m_name);
  return;
 }
    /* Inscribing an object with "!a" produces prompts to confirm that you wish
	 * to attack with it; idea from MarvinPA */
    if (obj && check_for_inscrip(obj, "!a") && !p->truce) {
  if (!get_check("Are you sure you wish to attack? ")) {
   abort_attack = true;
  }
    }
  /* Warning about breaking the truce */
 if (p->truce && !get_check("Are you sure you wish to attack? ")) {
        abort_attack = true;
 }
    /* Warn about fighting with fists */
    if (!obj && !get_check("Are you sure you wish to attack with no weapon? ")){
        abort_attack = true;
    }
    /* Warn about fighting with shovel */
 if (obj) {
  object_short_name(name, sizeof(name), obj->kind->name);
  if (tval_is_digger(obj) && streq(name, "Shovel") &&
   !get_check("Are you sure you wish to attack with your shovel? ")) {
   abort_attack = true;
  }
    }
    /* Cancel the attack if needed */
    if (abort_attack) {
        if (!p->attacked) {
            /* Reset the action type */
            p->previous_action[0] = ACTION_NOTHING;
            /* Don't take a turn */
            p->upkeep->energy_use = 0;
        }
        /* Done */
        return;
    }
 if (obj) {
  /* Handle normal weapon */
  weight = obj->weight;
  my_strcpy(verb, "hit", sizeof(verb));
 } else {
  /* Fighting with fists is equivalent to a 4 lb weapon for the purpose
		 * of criticals */
  weight = 0;
 }
 mdd = p->state.mdd;
 mds = p->state.mds;
 /* Determine the base for the attack_mod */
 attack_mod = p->state.skill_use[SKILL_MELEE];
 /* Monsters might notice */
 p->attacked = true;
 /* Determine the number of attacks */
 if (player_active_ability(p, "Rapid Attack")) {
  blows++;
  rapid_attack = true;
 }
 if (p->state.mds2 > 0) {
  blows++;
 }
 /* Attack types that take place in the opponents' turns only allow a
	 * single attack */
 if ((attack_type != ATT_MAIN) && (attack_type != ATT_FLANKING) &&
  (attack_type != ATT_CONTROLLED_RETREAT)) {
  blows = 1;
  /* Undo strength adjustment to the attack (if any) */
  mds = total_mds(p, &p->state, obj, 0);
  /* Undo the dexterity adjustment to the attack (if any) */
  if (rapid_attack) {
   rapid_attack = false;
   attack_mod += 3;
  }
 }
 /* Attack once for each legal blow */
 while (num++ < blows) {
  bool do_knock_back = false;
  bool knocked = false;
  bool off_hand_blow = false;
  /* If the previous blow was a charge, undo the charge effects for
		 * later blows */
  if (charge) {
   charge = false;
   attack_mod -= 3;
   mds = p->state.mds;
  }
  /* Adjust for off-hand weapon if it is being used */
  if ((num == blows) && (num != 1) && (p->state.mds2 > 0)) {
   off_hand_blow = true;
   rapid_attack = false;
   attack_mod += p->state.offhand_mel_mod;
   mdd = p->state.mdd2;
   mds = p->state.mds2;
   obj = equipped_item_by_slot_name(p, "arm");
   weight = obj->weight;
  }
  /* +3 Str/Dex on first blow when charging */
  if ((num == 1) && valid_charge(p, grid, attack_type)) {
   int str_adjustment = 3;
   if (rapid_attack) str_adjustment -= 3;
   charge = true;
   attack_mod += 3;
   /* Undo strength adjustment to the attack (if any) */
   mds = total_mds(p, &p->state, obj, str_adjustment);
  }
  /* Reward melee attacks on sleeping monsters by characters with the
		 * asssassination ability (only when a main, flanking, or controlled
		 * retreat attack, and not charging) */
  if (((attack_type == ATT_MAIN) || (attack_type == ATT_FLANKING) ||
    (attack_type == ATT_CONTROLLED_RETREAT)) && !charge) {
   stealth_bonus = stealth_melee_bonus(mon);
  }
  /* Determine the player's attack score after all modifiers */
  total_attack_mod = total_player_attack(p, mon,
              attack_mod + stealth_bonus);
  /* Determine the monster's evasion score after all modifiers */
  total_evasion_mod = total_monster_evasion(p, mon, false);
  /* Test for hit */
  hit_result = hit_roll(total_attack_mod, total_evasion_mod,
         source_player(), source_monster(mon->midx), true);
  /* If the attack connects... */
  if (hit_result > 0) {
   int crit_bonus_dice = 0, slay_bonus_dice = 0, total_dice = 0;
   int effective_strength = p->state.stat_use[STAT_STR];
   bool fatal_blow = false;
   bool living = monster_is_living(mon);
   int slay = 0, brand = 0, flag = 0;
   /* Mark the monster as attacked */
   mflag_on(mon->mflag, MFLAG_HIT_BY_MELEE);
   /* Mark the monster as charged */
   if (charge) mflag_on(mon->mflag, MFLAG_CHARGED);
   /* Calculate the damage */
   crit_bonus_dice = crit_bonus(p, hit_result, weight, race,
           SKILL_MELEE, false);
   slay_bonus_dice = slay_bonus(p, obj, mon, &slay, &brand);
   total_dice = mdd + slay_bonus_dice + crit_bonus_dice;
   dam = damroll(total_dice, mds);
   prt = damroll(race->pd, race->ps);
   prt_percent = prt_after_sharpness(p, obj, &flag);
   prt = (prt * prt_percent) / 100;
   /* No negative damage */
   net_dam = MAX(dam - prt, 0);
   /* Determine the punctuation for the attack ("...", ".", "!" etc) */
   attack_punctuation(punct, sizeof(punct), net_dam, crit_bonus_dice);
   /* Special message for visible unalert creatures */
   if (stealth_bonus) {
    msgt(MSG_HIT, "You stealthily attack %s%s", m_name,
      punct);
   } else if (charge) {
     msgt(MSG_HIT, "You charge %s%s", m_name, punct);
   } else {
    msgt(MSG_HIT, "You hit %s%s", m_name, punct);
   }
   event_signal_combat_damage(EVENT_COMBAT_DAMAGE, total_dice, mds,
            dam, race->pd, race->ps, prt,
            prt_percent, PROJ_HURT, true);
   /* Determine the player's score for knocking an opponent backwards
			 * if they have the ability */
            /* First calculate their strength including modifiers for this
			 * attack */
            effective_strength = p->state.stat_use[STAT_STR];
   if (charge) effective_strength += 3;
   if (rapid_attack) effective_strength -= 3;
   if (off_hand_blow) effective_strength -= 3;
            /* Cap the value by the weapon weight */
   if (effective_strength > weight / 10) {
    effective_strength = weight / 10;
   } else if ((effective_strength < 0) &&
        (-effective_strength > weight / 10)) {
    effective_strength = -(weight / 10);
            }
            /* Give an extra +2 bonus for using a weapon two-handed */
            if (two_handed_melee(p)) {
    effective_strength += 2;
   }
   /* Check whether the effect triggers */
   if (player_active_ability(p, "Knock Back") &&
    (attack_type != ATT_OPPORTUNIST) &&
    !rf_has(race->flags, RF_NEVER_MOVE) &&
       (skill_check(source_player(), effective_strength * 2,
        monster_stat(mon, STAT_CON) * 2,
        source_monster(mon->midx)) > 0)) {
    do_knock_back = true;
   }
   /* If a slay, brand or flag was noticed, learn it */
   if (slay || brand) {
    learn_brand_slay_from_melee(p, obj, mon);
   }
   if (flag && !player_knows_flag(p, flag)) {
    char o_name[80];
    char desc[80];
    object_desc(o_name, sizeof(o_name), obj, ODESC_BASE, p);
    if (flag_slay_message(flag, m_name, desc, strlen(desc))) {
     msg("Your %s %s.", o_name, desc);
    }
    player_learn_flag(p, flag);
   }
   /* Damage, check for death */
   fatal_blow = mon_take_hit(mon, p, net_dam, NULL);
   /* Display depending on whether knock back triggered */
   if (do_knock_back) {
    event_signal_hit(EVENT_HIT, net_dam, PROJ_SOUND, fatal_blow,
         grid);
   } else {
    event_signal_hit(EVENT_HIT, net_dam, PROJ_HURT, fatal_blow,
         grid);
   }
   /* Deal with killing blows */
   if (fatal_blow) {
    /* Heal with a vampiric weapon */
    if (obj && of_has(obj->flags, OF_VAMPIRIC) && living) {
     if (p->chp < p->mhp) {
      effect_simple(EF_HEAL_HP, source_player(), "m7", 0, 0,
           0, NULL);
      if (!player_knows_flag(p, OF_VAMPIRIC)) {
       char o_name[80];
       char desc[80];
       object_desc(o_name, sizeof(o_name), obj,
          ODESC_BASE, p);
       if (flag_slay_message(OF_VAMPIRIC, m_name, desc,
              strlen(desc))) {
        msg("Your %s %s.", o_name, desc);
       }
       player_learn_flag(p, OF_VAMPIRIC);
      }
     }
    }
    /* Gain wrath if singing song of slaying */
    if (player_is_singing(p, lookup_song("Slaying"))) {
     p->wrath += 100;
     p->upkeep->update |= PU_BONUS;
     p->upkeep->redraw |= PR_SONG;
    }
    /* Deal with 'follow_through' ability */
    possible_follow_through(p, grid, attack_type);
    /* Stop attacking */
    break;
   } else {
    /* deal with knock back ability if it triggered */
    if (do_knock_back) {
                    knocked = knock_back(p->grid, grid);
     }
    /* Morgoth drops his iron crown if he is hit for 10 or more
				 * net damage twice */
    if (rf_has(mon->race->flags, RF_QUESTOR) &&
     !is_artifact_created(crown)) {
     if (net_dam >= 10) {
      if (p->morgoth_hits == 0) {
       msg("The force of your blow knocks the Iron Crown off balance.");
       p->morgoth_hits++;
      } else if (p->morgoth_hits == 1) {
       drop_iron_crown(mon, "You knock his crown from off his brow, and it falls to the ground nearby.");
       p->morgoth_hits++;
      }
     }
    }
    if (net_dam) {
     py_cruel_blow(crit_bonus_dice, mon);
    }
   }
  } else {
   /* Player misses */
   msgt(MSG_MISS, "You miss %s.", m_name);
   /* Occasional warning about fighting from within a pit */
   if (square_ispit(cave, p->grid) && one_in_(3)) {
    msg("(It is very hard to dodge or attack from within a pit.)");
   }
   /* Occasional warning about fighting from within a web */
   if (square_iswebbed(cave, p->grid) && one_in_(3)) {
    msg("(It is very hard to dodge or attack from within a web.)");
   }
   /*
			 * Allow for ripostes - treats attack as a weapon
			 * weighing 2 pounds per damage die
			 */
   if (rf_has(race->flags, RF_RIPOSTE) &&
     !monster_riposte &&
     !mon->m_timed[MON_TMD_CONF] &&
     (mon->stance != STANCE_FLEEING) &&
     !mon->skip_this_turn &&
     !mon->skip_next_turn &&
     (hit_result <= -10 - (2 * race->blow[0].dice.dice))) {
    /* Remember that the monster can do this */
    if (monster_is_visible(mon)) {
     struct monster_lore *lore =
      get_lore(mon->race);
     rf_on(lore->flags, RF_RIPOSTE);
    }
    msg("%s ripostes!", m_name);
    make_attack_normal(mon, p);
    monster_riposte = true;
   }
  }
  /* Alert the monster, even if no damage was done or the player missed */
  make_alert(mon, 0);
  /* Stop attacking if you displace the creature */
  if (knocked) break;
 }
 /* Break the truce if creatures see */
 break_truce(p, false);
}
/**
 * Attack the monster at the given location
 */
void py_attack(struct player *p, struct loc grid, int attack_type)
{
 /* Store the action type */
 p->previous_action[0] = ACTION_MISC;
 if (whirlwind_possible(p) && (adj_mon_count(p->grid) > 1) &&
  !p->timed[TMD_AFRAID]) {
  whirlwind(p, grid);
 } else {
  py_attack_real(p, grid, attack_type);
 }
}
/**
 * ------------------------------------------------------------------------
 * Ranged attacks
 * ------------------------------------------------------------------------ */
/**
 * Returns percent chance of an object breaking after throwing or shooting.
 *
 * Artifacts will never break.
 *
 * Beyond that, each item kind has a percent chance to break (0-100). When the
 * object hits its target this chance is used.
 *
 * When an object misses it also has a chance to break. This is determined by
 * squaring the normaly breakage probability. So an item that breaks 100% of
 * the time on hit will also break 100% of the time on a miss, whereas a 50%
 * hit-breakage chance gives a 25% miss-breakage chance, and a 10% hit breakage
 * chance gives a 1% miss-breakage chance.
 */
int breakage_chance(const struct object *obj, bool hit_wall) {
 int perc = obj->kind->base->break_perc;
 if (obj->artifact) return 0;
 if (tval_is_light(obj)) {
  /* Jewels don't break */
  if (of_has(obj->flags, OF_NO_FUEL)) {
   if (obj->pval == 1) {
    /* Lesser Jewel */
    perc = 0;
   } else if (obj->pval == 7) {
    /* Silmaril */
    perc = 0;
   }
  }
 } else if (tval_is_ammo(obj)) {
  if (player_active_ability(player, "Careful Shot")) perc /= 2;
  if (player_active_ability(player, "Flaming Arrows")) perc = 100;
 } else if ((perc != 100) &&
      player_active_ability(player, "Throwing Mastery")) {
  perc = 0;
 }
 /* Double breakage chance if it hit a wall */
 if (hit_wall) {
  perc *= 2;
  perc = MIN(perc, 100);
 }
 /* Unless they hit a wall, items designed for throwing won't break */
 if (of_has(obj->flags, OF_THROWING)) {
  if (hit_wall) {
   perc /= 4;
  } else {
   perc = 0;
  }
 }
 return perc;
}
/**
 * Maximum shooting range with a given bow
 */
int archery_range(const struct object *bow)
{
 int range;
 range = (bow->dd * total_ads(player, &player->state, bow, false) * 3) / 2;
 return MIN(range, z_info->max_range);
}
/**
 * Maximum throwing range with a given object
 */
int throwing_range(const struct object *obj)
{
 /* The divisor is the weight + 2lb */
 int div = obj->weight + 20;
 int range = (weight_limit(player->state) / 5) / div;
 /* Min distance of 1 */
 if (range < 1) range = 1;
 return MIN(range, z_info->max_range);
}
/**
 * Determines if a bow shoots radiant arrows and lights the current grid if so
 */
static bool do_radiance(struct player *p, struct loc grid) {
 /* Nothing to do */
 if (square_isglow(cave, grid)) return false;
 /* Give it light */
 sqinfo_on(square(cave, grid)->info, SQUARE_GLOW);
 /* Remember the grid */
 sqinfo_on(square(cave, grid)->info, SQUARE_MARK);
 /* Fully update the visuals */
 p->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
 /* Update stuff */
 update_stuff(p);
 return true;
}
/**
 * Handle special effects of throwing certain potions
 */
static bool thrown_potion_effects(struct player *p, struct object *obj,
  bool *is_dead, struct monster *mon)
{
 struct loc grid = mon->grid;
 bool ident = false;
 bool used = true;
 bool aware = object_flavor_is_aware(obj);
 /* Hold the monster name */
 char m_name[80];
 char m_poss[80];
 /* Get the monster name*/
 monster_desc(m_name, sizeof(m_name), mon, MDESC_DEFAULT);
 /* Get the monster possessive ("his"/"her"/"its") */
 monster_desc(m_poss, sizeof(m_poss), mon, MDESC_PRO_VIS | MDESC_POSS);
 /* Do the effect, if any */
 if (obj->kind->thrown_effect) {
  used = effect_do(obj->kind->thrown_effect,
       source_monster(mon->midx),
       obj,
       &ident,
       aware,
       DIR_NONE,
       NULL);
 } else {
  used = false;
 }
 /* Monster is now dead, skip messages below*/
 if (!square_monster(cave, grid)) {
  *is_dead = true;
 }
 /* Inform them of the potion, mark it as known */
 if (ident && !aware) {
  char o_name[80];
  /* Identify it fully */
  object_flavor_aware(p, obj);
  /* Description */
  object_desc(o_name, sizeof(o_name), obj,
   ODESC_PREFIX | ODESC_FULL | ODESC_ALTNUM | (1 << 16),
   p);
  /* Describe the potion */
  msg("You threw %s.", o_name);
  /* Combine / Reorder the pack (later) */
  p->upkeep->notice |= (PN_COMBINE);
  /* Window stuff */
  p->upkeep->redraw |= (PR_INVEN | PR_EQUIP);
 }
 /* Redraw if necessary*/
 if (used) p->upkeep->redraw |= (PR_HEALTH);
 /* Handle stuff */
 handle_stuff(p);
 return used;
}
/**
 * Give all adjacent, alert, non-mindless opponents (except one whose
 * coordinates are supplied) a free attack on the player.
 */
void attacks_of_opportunity(struct player *p, struct loc safe)
{
    int i;
    int start = randint0(8);
 int opportunity_attacks = 0;
    /* Look for adjacent monsters */
    for (i = start; i < 8 + start; i++) {
        struct loc grid = loc_sum(p->grid, ddgrid_ddd[i % 8]);
  struct monster *mon = square_monster(cave, grid);
        /* Check Bounds */
        if (!square_in_bounds(cave, grid)) continue;
        /* 'Point blank archery' avoids attacks of opportunity from the monster
		 * shot at */
        if (player_active_ability(p, "Point Blank Archery") &&
   loc_eq(safe, grid)) {
   continue;
        }
        /* If it is occupied by a monster */
        if (mon) {
            /* The monster must be alert, not confused, and not mindless */
            if ((mon->alertness >= ALERTNESS_ALERT) &&
    !mon->m_timed[MON_TMD_CONF] &&
    (mon->stance != STANCE_FLEEING) &&
    !rf_has(mon->race->flags, RF_MINDLESS) &&
    !mon->skip_next_turn && !mon->skip_this_turn) {
                opportunity_attacks++;
                if (opportunity_attacks == 1) {
                    msg("You provoke attacks of opportunity from adjacent enemies!");
                }
                make_attack_normal(mon, p);
            }
        }
    }
    return;
}
/**
 * Helper function used with ranged_helper by do_cmd_fire.
 */
static struct attack_result make_ranged_shot(struct player *p,
            struct object *ammo,
            struct monster *mon,
            bool undo_rapid,
            bool attack_penalty, bool one_shot)
{
 struct attack_result result = {0, 0, 0, false};
 struct object *bow = equipped_item_by_slot_name(p, "shooting");
 struct monster_race *race = mon->race;
 int attack_mod = p->state.skill_use[SKILL_ARCHERY] + ammo->att;
 int total_attack_mod, total_evasion_mod;
 int prt_percent;
 int slay_bonus_dice;
 int total_dd, total_ds;
 int dam, prt;
 int arrow_slay = 0, arrow_brand = 0, arrow_flag = 0;
 int bow_slay = 0, bow_brand = 0;
 char m_name[80];
 /* Remove the rapid fire penalty to attack if necessary */
 if (undo_rapid) {
  attack_mod += 3;
 }
 /* Determine the player's attack score after all modifiers */
 total_attack_mod = total_player_attack(p, mon, attack_mod);
 if (attack_penalty) {
  total_attack_mod = 0;
 }
 /* Determine the monster's evasion after all modifiers */
 total_evasion_mod = total_monster_evasion(p, mon, true);
 /* Did we hit it */
 result.hit = hit_roll(total_attack_mod, total_evasion_mod,
        source_player(), source_monster(mon->midx), true);
 if (result.hit <= 0) {
  return result;
 }
 /* Handle sharpness (which can change 'hit' message) */
 prt_percent = prt_after_sharpness(p, ammo, &arrow_flag);
 if (percent_chance(100 - prt_percent)) {
  result.pierce = true;
 }
 /* Add 'critical hit' dice based on bow weight */
 result.crit_dice = crit_bonus(p, result.hit, bow->weight, race,
          SKILL_ARCHERY, false);
 /* Add slay (or brand) dice based on both arrow and bow */
 slay_bonus_dice = slay_bonus(p, ammo, mon, &arrow_slay, &arrow_brand);
 slay_bonus_dice += slay_bonus(p, bow, mon, &bow_slay, &bow_brand);
 /* Bonus for flaming arrows */
 if (player_active_ability(p, "Flaming Arrows")) {
  struct monster_lore *lore = get_lore(race);
  /* Notice immunity */
  if (rf_has(race->flags, RF_RES_FIRE)) {
   if (monster_is_visible(mon)) {
    rf_on(lore->flags, RF_RES_FIRE);
   }
  } else {
   /* Otherwise, take the damage */
   slay_bonus_dice += 1;
   /* Extra bonus against vulnerable creatures */
   if (rf_has(race->flags, RF_HURT_FIRE)) {
    slay_bonus_dice += 1;
    /* Memorize the effects */
    rf_on(lore->flags, RF_RES_FIRE);
    /* Cause a temporary morale penalty */
    scare_onlooking_friends(mon, -20);
   }
  }
 }
 /* Calculate the damage done */
 total_dd = bow->dd + result.crit_dice + slay_bonus_dice;
 /* Note that this is recalculated in case the player has rapid shots but
	 * only one arrow */
 total_ds = MAX(total_ads(p, &p->state, bow, one_shot), 0);
 /* Calculate damage */
 dam = damroll(total_dd, total_ds);
 prt = damroll(race->pd, race->ps);
 prt = (prt * prt_percent) / 100;
 result.dmg = MAX(0, dam - prt);
 /* Monster description */
 monster_desc(m_name, sizeof(m_name), mon, MDESC_DEFAULT);
 /* If a slay, brand or flag was noticed, then identify the weapon */
 if (bow_slay || bow_brand || arrow_slay || arrow_brand) {
  learn_brand_slay_from_launch(p, ammo, bow, mon);
 }
 if (arrow_flag) {
  char o_name[80];
  char desc[80];
  object_desc(o_name, sizeof(o_name), ammo, ODESC_BASE, p);
  if (flag_slay_message(arrow_flag, m_name, desc, strlen(desc))) {
   msg("Your %s %s.", o_name, desc);
  }
  player_learn_flag(p, arrow_flag);
 }
 event_signal_combat_damage(EVENT_COMBAT_DAMAGE, total_dd, total_ds,
          result.dmg, race->pd, race->ps, prt, prt_percent,
          PROJ_HURT, false);
 return result;
}
/**
 * Helper function used with ranged_helper by do_cmd_throw.
 */
static struct attack_result make_ranged_throw(struct player *p,
             struct object *obj,
             struct monster *mon,
             bool undo_rapid,
             bool attack_penalty,
             bool one_shot)
{
 struct attack_result result = {0, 0, 0, false};
 struct object *weapon = equipped_item_by_slot_name(p, "weapon");
 struct monster_race *race = mon->race;
 int attack_mod = p->state.skill_use[SKILL_MELEE] + obj->att;
 int total_attack_mod, total_evasion_mod;
 int prt_percent;
 int slay_bonus_dice;
 int total_dd, total_ds;
 int dam, prt;
 int slay = 0, brand = 0, flag = 0;
 /* Subtract the melee weapon's bonus (as we had already accounted for it) */
 if (weapon) {
  attack_mod -= weapon->att;
  attack_mod -= blade_bonus(p, weapon);
  attack_mod -= axe_bonus(p, weapon);
  attack_mod -= polearm_bonus(p, weapon);
 }
 /* Weapons that are not good for throwing are much less accurate */
 if (!of_has(obj->flags, OF_THROWING)) {
  attack_mod -= 5;
 }
 /* Give people their weapon affinity bonuses if the weapon is thrown */
 attack_mod += blade_bonus(p, obj);
 attack_mod += axe_bonus(p, obj);
 attack_mod += polearm_bonus(p, obj);
 /* Bonus for throwing proficiency ability */
 if (player_active_ability(p, "Throwing Mastery")) attack_mod += 5;
 /* Determine the player's attack score after all modifiers */
 total_attack_mod = total_player_attack(p, mon, attack_mod);
 if (attack_penalty) {
  total_attack_mod = 0;
 }
 /* Determine the monster's evasion after all modifiers */
 total_evasion_mod = total_monster_evasion(p, mon, false);
 /* Did we hit it */
 result.hit = hit_roll(total_attack_mod, total_evasion_mod,
        source_player(), source_monster(mon->midx), true);
 if (result.hit <= 0) {
  return result;
 }
 /* Handle sharpness */
 prt_percent = prt_after_sharpness(p, obj, &flag);
 /* Add 'critical hit' dice based on bow weight */
 result.crit_dice = crit_bonus(p, result.hit, obj->weight, mon->race,
          SKILL_MELEE, false);
 /* Add slay (or brand) dice based on both arrow and bow */
 slay_bonus_dice = slay_bonus(p, obj, mon, &slay, &brand);
 /* Calculate the damage done */
 total_dd = obj->dd + result.crit_dice + slay_bonus_dice;
 total_ds = MAX(total_mds(p, &p->state, obj, 0), 0);
 /* Penalise items that aren't made to be thrown */
 if (!of_has(obj->flags, OF_THROWING)) total_ds /= 2;
 /* Calculate damage */
 dam = damroll(total_dd, total_ds);
 prt = damroll(race->pd, race->ps);
 prt = (prt * prt_percent) / 100;
 result.dmg = MAX(0, dam - prt);
 /* If a slay, brand or flag was noticed, then identify the weapon */
 if (slay || brand) {
  learn_brand_slay_from_throw(p, obj, mon);
 }
 if (flag) {
  char m_name[80];
  char o_name[80];
  char desc[80];
  monster_desc(m_name, sizeof(m_name), mon, MDESC_DEFAULT);
  object_desc(o_name, sizeof(o_name), obj, ODESC_BASE, p);
  if (flag_slay_message(flag, m_name, desc, strlen(desc))) {
   msg("Your %s %s.", o_name, desc);
  }
  player_learn_flag(p, flag);
 }
 event_signal_combat_damage(EVENT_COMBAT_DAMAGE, total_dd, total_ds,
          result.dmg, race->pd, race->ps, prt, prt_percent,
          PROJ_HURT, false);
 return result;
}
/**
 * This is a helper function used by do_cmd_throw and do_cmd_fire.
 *
 * It abstracts out the projectile path, display code, identify and clean up
 * logic, while using the 'attack' parameter to do work particular to each
 * kind of attack.
 */
static void ranged_helper(struct player *p, struct object *obj, int dir,
        int range, int shots, bool archery, bool radiance)
{
 int i;
 ranged_attack attack;
 int path_n;
 struct loc path_g[256];
 /* Start at the player */
 struct loc grid = p->grid;
 /* Predict the "target" location */
 struct loc target = loc_sum(grid, loc(99 * ddx[dir], 99 * ddy[dir]));
 struct loc first = loc(0, 0);
 bool none_left = false;
 bool noticed_radiance = false;
 bool targets_remaining = false;
 bool rapid_fire = player_active_ability(p, "Rapid Fire");
 bool hit_body = false;
 bool is_potion;
 struct object *bow = equipped_item_by_slot_name(p, "shooting");
 struct object *missile;
 int shot;
 const struct artifact *crown = lookup_artifact_name("of Morgoth");
 /* Check for target validity */
 if ((dir == DIR_TARGET) && target_okay(range)) {
  target_get(&target);
 }
 /* Handle player fear */
 if (p->timed[TMD_AFRAID]) {
  /* Message */
  msg("You are too afraid to aim properly!");
  /* Done */
  return;
 }
 /* Sound */
 sound(MSG_SHOOT);
 /* Set the attack type and other specifics */
 if (archery) {
  attack = make_ranged_shot;
  if (rapid_fire && obj->number > 1) {
   shots = 2;
  }
 } else {
  attack = make_ranged_throw;
 }
 /*
	 * Remember if the missile is a potion (need that after the missile
	 * may have been destroyed).
	 */
 is_potion = tval_is_potion(obj);
 /* Actually "fire" the object */
 p->upkeep->energy_use = z_info->move_energy;
 /* Store the action type */
 p->previous_action[0] = ACTION_MISC;
 /* Calculate the path */
 path_n = project_path(cave, path_g, range, grid, &target, 0);
 /* Hack -- Handle stuff */
 handle_stuff(p);
 /* If the bow has 'radiance', then light the starting square */
 noticed_radiance = radiance && do_radiance(p, grid);
 for (shot = 0; shot < shots; shot++) {
  bool hit_wall = false;
  bool ghost_arrow = false;
  int missed_monsters = 0;
  struct loc final_grid = (path_n > 0) ?
   path_g[path_n - 1] : p->grid;
  /* Abort any later shot(s) if there is no target on the trajectory */
  if ((shot > 0) && !targets_remaining) break;
  targets_remaining = false;
  /* Project along the path */
  for (i = 0; i < path_n; ++i) {
   struct monster *mon = NULL;
   bool see = square_isseen(cave, path_g[i]);
   /* Stop before hitting walls */
   if (!square_isprojectable(cave, path_g[i])) {
    /* If the arrow hasn't already stopped, do some things... */
    if (!ghost_arrow) {
     hit_wall = true;
     final_grid = grid;
     /* Only do visuals if the player can "see" the missile */
     if (panel_contains(grid.y, grid.x)) {
      bool sees[1] = { square_isview(cave, grid) };
      int dist[1] = { 0 };
      struct loc blast_grid[1] = { grid };
      event_signal_blast(EVENT_EXPLOSION, PROJ_ARROW, 1, dist,
             true, sees, blast_grid, grid);
     }
    }
    break;
   }
   /* Advance */
   grid = path_g[i];
   /* Check for monster */
   mon = square_monster(cave, grid);
   /* After an arrow has stopped, keep looking along the path, but
			 * don't attempt to hit creatures, or display graphics etc */
   if (ghost_arrow) {
    if (mon && (!OPT(p, forgo_attacking_unwary) ||
       (mon->alertness >= ALERTNESS_ALERT))) {
     targets_remaining = true;
    }
    continue;
   }
   /* If the bow has 'radiance', light the square being passed over */
   noticed_radiance = radiance && do_radiance(p, grid);
   /* Tell the UI to display the missile */
   event_signal_missile(EVENT_MISSILE, obj, see, grid.y, grid.x);
   /* Try the attack on the monster if any */
   if (mon) {
    bool potion_effect = false;
    bool attack_penalty = false;
    int visible = monster_is_visible(mon);
    const char *note_dies = monster_is_nonliving(mon) ?
     " is destroyed." : " dies.";
    struct attack_result result;
    int pdam = 0;
                /* Record the grid of the first monster in line of fire */
    first = grid;
    /* Monsters might notice */
    p->attacked = true;
    /* Modifications for shots that go past the target or strike
				 * things before the target... */
    if ((dir == DIR_TARGET) && target_okay(range)) {
     /* If there is a specific target and this is not it, then
					 * massively penalise */
     if (!loc_eq(grid, target)) {
      attack_penalty = true;
     }
    } else if (missed_monsters > 0) {
     /* If it is just a shot in a direction and has already
					 * missed something, then massively penalise */
     attack_penalty = true;
    } else {
     /* If it is a shot in a direction and this is the first
					 * monster */
     if (monster_is_visible(mon)) {
      monster_race_track(p->upkeep, mon->race);
      health_track(p->upkeep, mon);
      target_set_monster(mon);
     }
    }
    /* Perform the attack */
    result = attack(p, obj, mon, rapid_fire, attack_penalty,
        shots == 1);
    if (result.hit > 0) {
     char o_name[80];
     bool fatal_blow = false;
     /* Note the collision */
     hit_body = true;
     /* Mark the monster as attacked by the player */
     mflag_on(mon->mflag, MFLAG_HIT_BY_RANGED);
     /* Describe the object (have up-to-date knowledge now) */
     object_desc(o_name, sizeof(o_name), obj,
        ODESC_FULL | ODESC_SINGULAR, p);
     if (!visible) {
      /* Invisible monster */
      msgt(MSG_SHOOT_HIT, "The %s finds a mark.", o_name);
     } else {
      char m_name[80];
      char punct[20];
      /* Determine the punctuation for the attack
						 * ("...", ".", "!" etc) */
      attack_punctuation(punct, sizeof(punct), result.dmg,
             result.crit_dice);
      monster_desc(m_name, sizeof(m_name), mon, MDESC_OBJE);
      if (result.pierce) {
       msgt(MSG_SHOOT_HIT, "The %s pierces %s%s", o_name,
         m_name, punct);
      } else {
       msgt(MSG_SHOOT_HIT, "The %s hits %s%s", o_name,
         m_name, punct);
      }
     }
     /* Special effects sometimes reveal the kind of potion*/
     if (is_potion) {
      /* Record monster hit points*/
      pdam = mon->hp;
      msg("The bottle breaks.");
      /* Returns true if damage has already been handled */
      potion_effect = thrown_potion_effects(
       p, obj, &fatal_blow, mon);
      /* Check the change in monster hp*/
      pdam -= mon->hp;
      /* Monster could have been healed*/
      if (pdam < 0) pdam = 0;
     }
     /* Hit the monster, unless there's a potion effect */
     if (!potion_effect) {
      fatal_blow = mon_take_hit(mon, p, result.dmg,
              note_dies);
      event_signal_hit(EVENT_HIT, result.dmg, PROJ_HURT,
           fatal_blow, grid);
      /* If this was the killing shot */
      if (fatal_blow) {
       /* Gain wrath if singing song of slaying */
       if (player_is_singing(p, lookup_song("Slaying"))) {
        p->wrath += 100;
        p->upkeep->update |= PU_BONUS;
        p->upkeep->redraw |= PR_SONG;
       }
      }
     }
     if (!fatal_blow) {
      /* If it is still alive, then there is at least
						 * one target left on the trajectory*/
      targets_remaining = true;
      /* Alert the monster, even if no damage was done
						 * (if damage was done, then it was alerted by
						 * mon_take_hit() ) */
      if (result.dmg == 0) {
       make_alert(mon, 0);
      }
      /* Morgoth drops his iron crown if he is hit for 10 or
						 * more net damage twice */
      if (rf_has(mon->race->flags, RF_QUESTOR) &&
       !is_artifact_created(crown)) {
       if (result.dmg >= 10) {
        if (p->morgoth_hits == 0) {
         msg("The force of your %s knocks the Iron Crown off balance.", archery ? "shot" : "blow");
         p->morgoth_hits++;
        } else if (player->morgoth_hits == 1) {
         drop_iron_crown(mon, "You knock his crown from off his brow, and it falls to the ground nearby.");
         p->morgoth_hits++;
        }
       }
      }
      /* Message if applicable */
      if ((!potion_effect || (pdam > 0)) && !monster_is_visible(mon)) {
       message_pain(mon, pdam ? pdam : result.dmg);
      }
      /* Deal with crippling shot ability */
      if (archery
       && player_active_ability(p, "Crippling Shot")
       && (result.crit_dice >= 1) && (result.dmg > 0)
       && !rf_has(mon->race->flags, RF_RES_CRIT)) {
       if (skill_check(source_player(),
           result.crit_dice * 4,
           monster_skill(mon, SKILL_WILL),
           source_monster(mon->midx)) > 0) {
        msg("Your shot cripples %^s!", mon);
        /* Slow the monster - the +1 is needed as a
								 * turn of this wears off immediately */
        mon_inc_timed(mon, result.crit_dice + 1,
             MON_TMD_SLOW, false);
       }
      }
     }
     /* Stop looking if a monster was hit but not pierced */
     if (!result.pierce) {
      /* Continue checking trajectory, but without effect */
      ghost_arrow = true;
      /* Record resting place of arrow */
      final_grid = grid;
     }
    } else {
     /* There is at least one target left on the trajectory */
     targets_remaining = true;
    }
    /* We have missed a target, but could still hit something
				 * (with a penalty) */
    missed_monsters++;
   }
  }
  if (bow && !of_has(bow->known->flags, OF_RADIANCE) && noticed_radiance){
   char o_full_name[80];
   char o_short_name[80];
   object_desc(o_short_name, sizeof(o_short_name), obj, ODESC_BASE, p);
   player_learn_flag(p, OF_RADIANCE);
   object_desc(o_full_name, sizeof(o_full_name), obj,
    ODESC_PREFIX | ODESC_FULL | ODESC_ALTNUM |
    (1 << 16), p);
   msg("The arrow leaves behind a trail of light!");
   msg("You recognize your %s to be %s", o_short_name, o_full_name);
  }
  /* Break the truce if creatures see */
  break_truce(p, false);
  /* Get the missile */
  if (object_is_carried(p, obj)) {
   missile = gear_object_for_use(p, obj, 1, true, &none_left);
  } else {
   missile = floor_object_for_use(p, obj, 1, true, &none_left);
  }
  /* Set to auto-pickup */
  missile->notice |= OBJ_NOTICE_PICKUP;
  /* Drop (or break) near that location */
  drop_near(cave, &missile, breakage_chance(missile, hit_wall),
      final_grid, true, false);
 }
 /* Need to print this message even if the potion missed */
 if (!hit_body && is_potion) {
  msg("The bottle breaks.");
 }
 /* Have to set this here as well, just in case... */
 p->attacked = true;
    /* Provoke attacks of opportunity */
 if (archery) {
  if (player_active_ability(p, "Point Blank Archery")) {
   attacks_of_opportunity(p, first);
  } else {
   attacks_of_opportunity(p, loc(0, 0));
  }
 }
}
/**
 * Fire an object from the quiver, pack or floor at a target.
 */
void do_cmd_fire(struct command *cmd) {
 int dir, range;
 int shots = 1;
 struct object *bow = equipped_item_by_slot_name(player, "shooting");
 struct object *obj;
 bool radiance;
 /* Require a usable launcher */
 if (!bow || !player->state.ammo_tval) {
  msg("You have nothing to fire with.");
  return;
 }
 /* Get arguments */
 if (cmd_get_item(cmd, "item", &obj,
   /* Prompt */ "Fire which ammunition?",
   /* Error  */ "You have no suitable ammunition to fire.",
   /* Filter */ obj_can_fire,
   /* Choice */ USE_EQUIP)
  != CMD_OK)
  return;
 /* Check the item being fired is usable by the player. */
 if (!item_is_available(obj)) {
  msg("That item is not within your reach.");
  return;
 }
 /* Check the ammo can be used with the launcher */
 if (obj->tval != player->state.ammo_tval) {
  msg("That ammo cannot be fired by your current weapon.");
  return;
 }
 range = archery_range(bow);
 if (cmd_get_target(cmd, "target", &dir, range, false) == CMD_OK) {
  player_confuse_dir(player, &dir, false);
  if (player->timed[TMD_AFRAID]) {
   msgt(MSG_AFRAID, "You are too afraid to aim properly!");
   return;
  }
 } else {
  return;
 }
 /* Determine if the bow has 'radiance' */
 radiance = of_has(bow->flags, OF_RADIANCE);
 ranged_helper(player, obj, dir, range, shots, true, radiance);
}
/**
 * Throw an object from the quiver, pack, floor, or, in limited circumstances,
 * the equipment.
 */
void do_cmd_throw(struct command *cmd) {
 int dir;
 int shots = 1;
 int range;
 struct object *obj;
 /*
	 * Get arguments.  Never default to showing the equipment as the first
	 * list (since throwing the equipped weapon leaves that slot empty will
	 * have to choose another source anyways).
	 */
 if (player->upkeep->command_wrk == USE_EQUIP)
  player->upkeep->command_wrk = USE_INVEN;
 if (cmd_get_item(cmd, "item", &obj,
   /* Prompt */ "Throw which item?",
   /* Error  */ "You have nothing to throw.",
   /* Filter */ obj_can_throw,
   /* Choice */ USE_EQUIP | USE_QUIVER | USE_INVEN | USE_FLOOR | SHOW_THROWING)
  != CMD_OK)
  return;
 range = throwing_range(obj);
 if (cmd_get_target(cmd, "target", &dir, range, false) == CMD_OK) {
  player_confuse_dir(player, &dir, false);
  if (player->timed[TMD_AFRAID]) {
   msgt(MSG_AFRAID, "You are too afraid to aim properly!");
   return;
  }
 } else {
  return;
 }
 if (object_is_equipped(player->body, obj)) {
  assert(obj_can_takeoff(obj) && tval_is_melee_weapon(obj));
  if (handle_stickied_removal(player, obj)) {
   return;
  }
  inven_takeoff(obj);
 }
 ranged_helper(player, obj, dir, range, shots, false, false);
}
/**
 * Front-end command which fires from the first quiver.
 */
void do_cmd_fire_quiver1(void) {
 struct object *bow = equipped_item_by_slot_name(player, "shooting");
 struct object *ammo = equipped_item_by_slot_name(player, "first quiver");
 /* Require a usable launcher */
 if (!bow || !player->state.ammo_tval) {
  msg("You have nothing to fire with.");
  return;
 }
 /* Require usable ammo */
 if (!ammo) {
  msg("You have no ammunition in the first quiver to fire.");
  return;
 }
 if (ammo->tval != player->state.ammo_tval) {
  msg("The ammunition in the first quiver is not compatible with your launcher.");
  return;
 }
 /* Fire! */
 cmdq_push(CMD_FIRE);
 cmd_set_arg_item(cmdq_peek(), "item", ammo);
}
/**
 * Front-end command which fires from the second quiver.
 */
void do_cmd_fire_quiver2(void) {
 struct object *bow = equipped_item_by_slot_name(player, "shooting");
 struct object *ammo = equipped_item_by_slot_name(player, "second quiver");
 /* Require a usable launcher */
 if (!bow || !player->state.ammo_tval) {
  msg("You have nothing to fire with.");
  return;
 }
 /* Require usable ammo */
 if (!ammo) {
  msg("You have no ammunition in the second quiver to fire.");
  return;
 }
 if (ammo->tval != player->state.ammo_tval) {
  msg("The ammunition in the second quiver is not compatible with your launcher.");
  return;
 }
 /* Fire! */
 cmdq_push(CMD_FIRE);
 cmd_set_arg_item(cmdq_peek(), "item", ammo);
}
/**
 * Front-end command which fires at the nearest target with default ammo.
 */
void do_cmd_fire_at_nearest(void) {
 int dir = DIR_TARGET;
 struct object *ammo = NULL;
 struct object *bow = equipped_item_by_slot_name(player, "shooting");
 struct object *ammo1 = equipped_item_by_slot_name(player, "first quiver");
 struct object *ammo2 = equipped_item_by_slot_name(player, "second quiver");
 /* Require a usable launcher */
 if (!bow || !player->state.ammo_tval) {
  msg("You have nothing to fire with.");
  return;
 }
 /* Find first eligible ammo in the quiver */
 if (ammo1) {
  ammo = ammo1;
 } else if (ammo2) {
  ammo = ammo2;
 }
 /* Require usable ammo */
 if (!ammo) {
  msg("You have no ammunition in the quiver to fire.");
  return;
 }
 /* Require foe */
 if (!target_set_closest((TARGET_KILL | TARGET_QUIET), NULL)) return;
 /* Fire! */
 cmdq_push(CMD_FIRE);
 cmd_set_arg_item(cmdq_peek(), "item", ammo);
 cmd_set_arg_target(cmdq_peek(), "target", dir);
}
/**
 * Front-end command for "automatic" throwing
 *
 * Throws the first item in the inventory that is designed for throwing at the
 * current target, if set and in range, or the nearest monster that is in
 * range.
 */
void do_cmd_automatic_throw(void) {
 struct object *thrown;
 int nthrow = scan_items(&thrown, 1, player, USE_INVEN, obj_is_throwing);
 int range;
 if (nthrow <= 0) {
  msg("You don't have anything designed for throwing in your inventory.");
  return;
 }
 range = throwing_range(thrown);
 assert(range > 0);
 if (!target_okay(range)) {
  /*
		 * Get the nearest monster in range.  Could use
		 * target_set_closest(), but that would have the drawback of
		 * clearing the current target if there is nothing in range.
		 */
  struct point_set *targets = target_get_monsters(
   TARGET_KILL | TARGET_QUIET, NULL, false);
  struct monster *target = NULL;
  int target_range = range + 1;
  int ntgt = point_set_size(targets), i = 0;
  while (1) {
   if (i >= ntgt) {
    point_set_dispose(targets);
    if (!target) {
     msg("No clear target for automatic throwing.");
     return;
    }
    target_set_monster(target);
    health_track(player->upkeep, target);
    break;
   }
   if (distance(player->grid, targets->pts[i])
     < target_range) {
    target = square_monster(cave, targets->pts[i]);
    assert(target);
   }
   ++i;
  }
 }
 /* Throw! */
 cmdq_push(CMD_THROW);
 cmd_set_arg_item(cmdq_peek(), "item", thrown);
 cmd_set_arg_target(cmdq_peek(), "target", DIR_TARGET);
}
/**
 * \file player-birth.c
 * \brief Character creation
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Overview
 * ========
 * This file contains the game-mechanical part of the birth process.
 * To follow the code, start at player_birth towards the bottom of
 * the file - that is the only external entry point to the functions
 * defined here.
 *
 * Player (in the Angband sense of character) birth is modelled as a
 * a series of commands from the UI to the game to manipulate the
 * character and corresponding events to inform the UI of the outcomes
 * of these changes.
 *
 * The current aim of this section is that after any birth command
 * is carried out, the character should be left in a playable state.
 * In particular, this means that if a savefile is supplied, the
 * character will be set up according to the "quickstart" rules until
 * another race or house is chosen, or until the stats are reset by
 * the UI.
 *
 * Once the UI signals that the player is happy with the character, the
 * game does housekeeping to ensure the character is ready to start the
 * game (clearing the history log, making sure options are set, etc)
 * before returning control to the game proper.
 */
/* These functions are defined at the end of the file */
static int roman_to_int(const char *roman);
static int int_to_roman(int n, char *roman, size_t bufsize);
/**
 * Forward declare
 */
typedef struct birther birther;
/**
 * A structure to hold "rolled" information, and any
 * other useful state for the birth process.
 */
struct birther
{
 const struct player_race *race;
 const struct player_house *house;
 const struct player_sex *sex;
 int16_t age;
 int16_t wt;
 int16_t ht;
 int16_t stat[STAT_MAX];
 char *history;
 char name[PLAYER_NAME_LEN];
};
/**
 * ------------------------------------------------------------------------
 * All of these should be in some kind of 'birth state' struct somewhere else
 * ------------------------------------------------------------------------ */
static int stats[STAT_MAX];
static int points_spent[STAT_MAX];
static int points_inc[STAT_MAX];
static int points_left;
static bool quickstart_allowed;
/**
 * The last character displayed, to allow the user to flick between two.
 * We rely on prev.age being zero to determine whether there is a stored
 * character or not, so initialise it here.
 */
static birther prev;
/**
 * If quickstart is allowed, we store the old character in this,
 * to allow for it to be reloaded if we step back that far in the
 * birth process.
 */
static birther quickstart_prev;
/**
 * Save the current birth data into the supplied 'player'.
 */
static void save_birth_data(birther *tosave)
{
 int i;
 /* Save the data */
 tosave->race = player->race;
 tosave->house = player->house;
 tosave->sex = player->sex;
 tosave->age = player->age;
 tosave->wt = player->wt_birth;
 tosave->ht = player->ht_birth;
 /* Save the stats */
 for (i = 0; i < STAT_MAX; i++)
  tosave->stat[i] = player->stat_base[i] -
   (player->race->stat_adj[i] + player->house->stat_adj[i]);
 if (tosave->history) {
  string_free(tosave->history);
 }
 tosave->history = player->history;
 player->history = NULL;
 my_strcpy(tosave->name, player->full_name, sizeof(tosave->name));
}
/**
 * Load stored player data from 'player' as the current birth data,
 * optionally placing the current data in 'prev_player' (if 'prev_player'
 * is non-NULL).
 *
 * It is perfectly legal to specify the same "birther" for both 'player'
 * and 'prev_player'.
 */
static void load_birth_data(birther *saved, birther *prev_player)
{
 int i;
     /* The initialisation is just paranoia - structure assignment is
        (perhaps) not strictly defined to work with uninitialised parts
        of structures. */
 birther temp;
 memset(&temp, 0, sizeof(birther));
 /* Save the current data if we'll need it later */
 if (prev_player)
  save_birth_data(&temp);
 /* Load previous data */
 player->race = saved->race;
 player->house = saved->house;
 player->sex = saved->sex;
 player->age = saved->age;
 player->wt = player->wt_birth = saved->wt;
 player->ht = player->ht_birth = saved->ht;
 /* Load previous stats */
 for (i = 0; i < STAT_MAX; i++) {
  player->stat_base[i] = saved->stat[i];
 }
 if (player->history) {
  string_free(player->history);
 }
 player->history = string_make(saved->history);
 my_strcpy(player->full_name, saved->name, sizeof(player->full_name));
 /* Save the current data if the caller is interested in it. */
 if (prev_player) {
  if (prev_player->history) {
   string_free(prev_player->history);
  }
  *prev_player = temp;
 }
}
static void get_bonuses(struct player *p)
{
 /* Calculate the bonuses and hitpoints */
 p->upkeep->update |= (PU_BONUS | PU_HP);
 /* Update stuff */
 update_stuff(p);
 /* Fully healed */
 p->chp = p->mhp;
 /* Fully rested */
 calc_voice(p, true);
 p->csp = p->msp;
}
/**
 * Get the racial history, and social class, using the "history charts".
 */
char *get_history(struct history_chart *chart, struct player *p)
{
 struct history_entry *entry;
 char *res = NULL;
 while (chart) {
  int roll = randint1(100);
  for (entry = chart->entries; entry; entry = entry->next)
   if (roll <= entry->roll)
    break;
  assert(entry);
  res = string_append(res, entry->text);
  /* Hack for Noldor houses */
  if (strstr(entry->text, "house of") && streq(p->race->name, "Noldor")) {
   res = string_append(res, " ");
   res = string_append(res, p->house->short_name);
   res = string_append(res, ".");
  }
  chart = entry->succ;
 }
 return res;
}
/**
 * Computes character's age, height, and weight
 */
void get_ahw(struct player *p)
{
 /* Calculate the age */
 p->age = p->race->b_age + randint1(p->race->m_age);
 /* Calculate the height/weight */
 p->ht = p->ht_birth = Rand_normal(p->race->base_hgt, p->race->mod_hgt);
 p->wt = p->wt_birth = Rand_normal(p->race->base_wgt, p->race->mod_wgt);
}
/**
 * Creates the player's body
 */
static void player_embody(struct player *p)
{
 char buf[80];
 int i;
 assert(p->race);
 memcpy(&p->body, &bodies[p->race->body], sizeof(p->body));
 my_strcpy(buf, bodies[p->race->body].name, sizeof(buf));
 p->body.name = string_make(buf);
 p->body.slots = mem_zalloc(p->body.count * sizeof(struct equip_slot));
 for (i = 0; i < p->body.count; i++) {
  p->body.slots[i].type = bodies[p->race->body].slots[i].type;
  my_strcpy(buf, bodies[p->race->body].slots[i].name, sizeof(buf));
  p->body.slots[i].name = string_make(buf);
 }
}
void player_init(struct player *p)
{
 int i;
 struct player_options opts_save = p->opts;
 player_cleanup_members(p);
 /* Wipe the player */
 memset(p, 0, sizeof(struct player));
 /* Start with no artifacts made yet */
 for (i = 0; z_info && i < z_info->a_max; i++) {
  mark_artifact_created(&a_info[i], false);
  mark_artifact_seen(&a_info[i], false);
 }
 for (i = 1; z_info && i < z_info->k_max; i++) {
  struct object_kind *kind = &k_info[i];
  kind->tried = false;
  kind->aware = false;
 }
 for (i = 1; z_info && i < z_info->r_max; i++) {
  struct monster_race *race = &r_info[i];
  struct monster_lore *lore = get_lore(race);
  race->cur_num = 0;
  race->max_num = 100;
  if (rf_has(race->flags, RF_UNIQUE))
   race->max_num = 1;
  lore->pkills = 0;
  lore->psights = 0;
 }
 p->upkeep = mem_zalloc(sizeof(struct player_upkeep));
 p->upkeep->inven = mem_zalloc((z_info->pack_size + 1) *
          sizeof(struct object *));
 p->timed = mem_zalloc(TMD_MAX * sizeof(int16_t));
 p->vaults = mem_zalloc(z_info->v_max * sizeof(int16_t));
 p->obj_k = mem_zalloc(sizeof(struct object));
 p->obj_k->brands = mem_zalloc(z_info->brand_max * sizeof(bool));
 p->obj_k->slays = mem_zalloc(z_info->slay_max * sizeof(bool));
 /* Options should persist */
 p->opts = opts_save;
 /* First turn. */
 turn = 1;
 /* Default to the first race/house/sex in the edit file */
 p->race = races;
 p->house = houses;
 p->sex = sexes;
}
/**
 * Try to wield everything wieldable in the inventory.
 */
void wield_all(struct player *p)
{
 struct object *obj, *new_pile = NULL, *new_known_pile = NULL;
 int slot;
 /* Scan through the slots */
 for (obj = p->gear; obj; obj = obj->next) {
  struct object *obj_temp;
  /* Skip non-objects */
  assert(obj);
  /* Make sure we can wield it */
  slot = wield_slot(obj);
  if (slot < 0 || slot >= p->body.count)
   continue;
  obj_temp = slot_object(p, slot);
  if (obj_temp)
   continue;
  /* Split if necessary */
  if ((obj->number > 1) && !tval_is_ammo(obj)) {
   /* All but one go to the new object */
   struct object *new = object_split(obj, obj->number - 1);
   /* Add to the pile of new objects to carry */
   pile_insert(&new_pile, new);
   pile_insert(&new_known_pile, new->known);
  }
  /* Wear the new stuff */
  p->body.slots[slot].obj = obj;
  object_learn_on_wield(p, obj);
  /* Increment the equip counter by hand */
  p->upkeep->equip_cnt++;
 }
 /* Now add the unwielded split objects to the gear */
 if (new_pile) {
  pile_insert_end(&p->gear, new_pile);
  pile_insert_end(&p->gear_k, new_known_pile);
 }
 return;
}
/**
 * Initialize the global player as if the full birth process happened.
 * \param nrace Is the name of the race to use.  It may be NULL to use *races.
 * \param nhouse Is the name of the house to use.  It may be NULL to use
 * *housees.
 * \param nplayer Is the name to use for the player.  It may be NULL.
 * \return The return value will be true if the full birth process will be
 * successful.  It will be false if the process failed.  One reason for that
 * would be that the requested race or house could not be found.
 * Requires a prior call to init_angband().  Intended for use by test cases
 * or stub front ends that need a fully initialized player.
 */
bool player_make_simple(const char *nrace, const char *nhouse, const char *nsex,
 const char* nplayer)
{
 int ir = 0, ih = 0, is = 0;
 if (nrace) {
  const struct player_race *rc = races;
  int nr = 0;
  while (1) {
   if (!rc) return false;
   if (streq(rc->name, nrace)) break;
   rc = rc->next;
   ++ir;
   ++nr;
  }
  while (rc) {
   rc = rc->next;
   ++nr;
  }
  ir = nr - ir - 1;
 }
 if (nhouse) {
  const struct player_house *hc = houses;
  int nh = 0;
  while (1) {
   if (!hc) return false;
   if (streq(hc->name, nhouse)) break;
   hc = hc->next;
   ++ih;
   ++nh;
  }
  while (hc) {
   hc = hc->next;
   ++nh;
  }
  ih = nh - ih - 1;
 }
 if (nsex) {
  const struct player_sex *sc = sexes;
  int ns = 0;
  while (1) {
   if (!sc) return false;
   if (streq(sc->name, nsex)) break;
   sc = sc->next;
   ++is;
   ++ns;
  }
  while (sc) {
   sc = sc->next;
   ++ns;
  }
  is = ns - is - 1;
 }
 cmdq_push(CMD_BIRTH_INIT);
 cmdq_push(CMD_BIRTH_RESET);
 cmdq_push(CMD_CHOOSE_RACE);
 cmd_set_arg_choice(cmdq_peek(), "choice", ir);
 cmdq_push(CMD_CHOOSE_HOUSE);
 cmd_set_arg_choice(cmdq_peek(), "choice", ih);
 cmdq_push(CMD_CHOOSE_SEX);
 cmd_set_arg_choice(cmdq_peek(), "choice", is);
 cmdq_push(CMD_NAME_CHOICE);
 cmd_set_arg_string(cmdq_peek(), "name",
  (nplayer == NULL) ? "Simple" : nplayer);
 cmdq_push(CMD_ACCEPT_CHARACTER);
 cmdq_execute(CTX_BIRTH);
 return true;
}
/**
 * Init players with some belongings
 *
 * Having an item identifies it and makes the player "aware" of its purpose.
 */
static void player_outfit(struct player *p)
{
 int i;
 const struct start_item *si;
 struct object *obj, *known_obj;
 /* Currently carrying nothing */
 p->upkeep->total_weight = 0;
 /* Give the player obvious object knowledge */
 p->obj_k->dd = 1;
 p->obj_k->ds = 1;
 p->obj_k->pd = 1;
 p->obj_k->ps = 1;
 p->obj_k->att = 1;
 p->obj_k->evn = 1;
 for (i = 1; i < OF_MAX; i++) {
  struct obj_property *prop = lookup_obj_property(OBJ_PROPERTY_FLAG, i);
  if (prop->subtype == OFT_BASIC) of_on(p->obj_k->flags, i);
 }
 /* Give the player starting equipment */
 for (si = p->race->start_items; si; si = si->next) {
  int num = rand_range(si->min, si->max);
  struct object_kind *kind = lookup_kind(si->tval, si->sval);
  assert(kind);
  /* Prepare a new item */
  obj = object_new();
  object_prep(obj, kind, 0, MINIMISE);
  obj->number = num;
  obj->origin = ORIGIN_BIRTH;
  known_obj = object_new();
  obj->known = known_obj;
  object_set_base_known(p, obj);
  object_flavor_aware(p, obj);
  obj->known->pval = obj->pval;
  obj->known->notice |= OBJ_NOTICE_ASSESSED;
  /* Carry the item */
  inven_carry(p, obj, true, false);
  kind->everseen = true;
 }
 /* Now try wielding everything */
 wield_all(p);
}
/**
 * Cost of each "point" of a stat.
 */
static const int birth_stat_costs[11] = { -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6};
static void recalculate_stats(int *stats_local_local)
{
 int i;
 /* Variable stat maxes */
 for (i = 0; i < STAT_MAX; i++) {
  player->stat_base[i] = stats_local_local[i];
 }
 /* Update bonuses, hp, etc. */
 get_bonuses(player);
 /* Tell the UI about all this stuff that's changed. */
 event_signal(EVENT_HP);
 event_signal(EVENT_STATS);
}
static void reset_stats(int stats_local[STAT_MAX],
      int points_spent_local[STAT_MAX],
      int points_inc_local[STAT_MAX],
      int *points_left_local, bool update_display)
{
 int i;
 /* Calculate and signal initial stats and points totals. */
 *points_left_local = 13;
 for (i = 0; i < STAT_MAX; i++) {
  /* Initial stats are set to the race/house values and costs are zero */
  stats_local[i] = 0;
  points_spent_local[i] = 0;
  points_inc_local[i] = birth_stat_costs[stats_local[i] + 4 + 1];
 }
 /* Use the new "birth stat" values to work out the "other"
	   stat values (i.e. after modifiers) and tell the UI things have 
	   changed. */
 if (update_display) {
  recalculate_stats(stats_local);
  event_signal_birthpoints(points_spent_local, points_inc_local,
         *points_left_local);
 }
}
static bool buy_stat(int choice, int stats_local[STAT_MAX],
      int points_spent_local[STAT_MAX],
      int points_inc_local[STAT_MAX],
      int *points_left_local, bool update_display)
{
 /* Must be a valid stat to be adjusted */
 if (!(choice >= STAT_MAX || choice < 0)) {
  /* Get the cost of buying the extra point (beyond what
		   it has already cost to get this far). */
  int stat_cost = birth_stat_costs[stats_local[choice] + 4 + 1];
  assert(stat_cost == points_inc_local[choice]);
  if (stat_cost <= *points_left_local) {
   stats_local[choice]++;
   points_spent_local[choice] += stat_cost;
   points_inc_local[choice] =
    birth_stat_costs[stats_local[choice] + 4 + 1];
   *points_left_local -= stat_cost;
   if (update_display) {
    /* Tell the UI the new points situation. */
    event_signal_birthpoints(points_spent_local,
     points_inc_local, *points_left_local);
    /* Recalculate everything that's changed because
				   the stat has changed, and inform the UI. */
    recalculate_stats(stats_local);
   }
   return true;
  }
 }
 /* Didn't adjust stat. */
 return false;
}
static bool sell_stat(int choice, int stats_local[STAT_MAX],
       int points_spent_local[STAT_MAX],
       int points_inc_local[STAT_MAX],
       int *points_left_local, bool update_display)
{
 /* Must be a valid stat, and we can't "sell" stats below 0. */
 if (!(choice >= STAT_MAX || choice < 0) && (stats_local[choice] > 0)) {
  int stat_cost = birth_stat_costs[stats_local[choice] + 4];
  stats_local[choice]--;
  points_spent_local[choice] -= stat_cost;
  points_inc_local[choice] =
   birth_stat_costs[stats_local[choice] + 4 + 1];
  *points_left_local += stat_cost;
  if (update_display) {
   /* Tell the UI the new points situation. */
   event_signal_birthpoints(points_spent_local,
    points_inc_local, *points_left_local);
   /* Recalculate everything that's changed because
			   the stat has changed, and inform the UI. */
   recalculate_stats(stats_local);
  }
  return true;
 }
 /* Didn't adjust stat. */
 return false;
}
/**
 * Add race and house stat points to what we've chosen.
 */
static void finalise_stats(struct player *p)
{
 int i;
 for (i = 0; i < STAT_MAX; i++) {
  p->stat_base[i] += p->race->stat_adj[i] + p->house->stat_adj[i];
 }
}
/**
 * This fleshes out a full player based on the choices currently made,
 * and so is called whenever things like race or house are chosen.
 */
void player_generate(struct player *p, const struct player_race *r,
      const struct player_house *h, const struct player_sex *s,
      bool old_history)
{
 if (!h)
  h = p->house;
 if (!r)
  r = p->race;
 if (!s)
  s = p->sex;
 p->house = h;
 p->race = r;
 p->sex = s;
 if (!p->house) {
  p->house = player_house_from_count(0);
 }
 /* Initial experience */
 p->exp = p->new_exp = z_info->start_exp;
 /* Initial hitpoints etc */
 get_bonuses(p);
 /* Roll for age/height/weight */
 get_ahw(p);
 /* Always start with a well fed player */
 p->timed[TMD_FOOD] = PY_FOOD_FULL - 1;
 if (!old_history) {
  if (p->history) {
   string_free(p->history);
  }
  p->history = get_history(p->race->history, p);
 }
}
/**
 * Reset everything back to how it would be on loading the game.
 */
static void do_birth_reset(bool use_quickstart, birther *quickstart_prev_local)
{
 /* If there's quickstart data, we use it to set default
	   character choices. */
 if (use_quickstart && quickstart_prev_local)
  load_birth_data(quickstart_prev_local, NULL);
 player_generate(player, NULL, NULL, NULL,
     use_quickstart && quickstart_prev_local);
 player->depth = 1;
 /* Update stats with bonuses, etc. */
 get_bonuses(player);
}
void do_cmd_birth_init(struct command *cmd)
{
 char *buf;
 /* The dungeon is not ready */
 character_dungeon = false;
 /*
	 * If there's a quickstart character, store it for later use.
	 * If not, default to whatever the first of the choices is.
	 */
 if (player->ht_birth) {
  int i, total_stat_cost = 0;
  bool stats_ok = true;
  /* Handle incrementing name suffix */
  buf = find_roman_suffix_start(player->full_name);
  if (buf) {
   /* Try to increment the roman suffix */
   int success = int_to_roman(
    roman_to_int(buf) + 1,
    buf,
    sizeof(player->full_name) - (buf - (char *)&player->full_name));
   if (!success) {
    msg("Sorry, could not deal with suffix");
   }
  }
  /* Sanity check stats */
  for (i = 0; i < STAT_MAX; i++) {
   int stat = player->stat_base[i];
   /* This stat is too expensive, must be debug altered */
   if (stat > 6) {
    stats_ok = false;
    break;
   }
   /* Check if the total cost is too much */
   while (stat) {
    total_stat_cost += birth_stat_costs[4 + 1 + stat];
    if (total_stat_cost > 13) {
     stats_ok = false;
     break;
    }
   }
   if (!stats_ok) break;
  }
  if (stats_ok) {
   save_birth_data(&quickstart_prev);
   quickstart_allowed = true;
  }
 } else {
  player_generate(player, player_id2race(0), player_house_from_count(0),
      player_id2sex(0), false);
  quickstart_allowed = false;
 }
 /* We're ready to start the birth process */
 event_signal_flag(EVENT_ENTER_BIRTH, quickstart_allowed);
}
void do_cmd_birth_reset(struct command *cmd)
{
 player_init(player);
 reset_stats(stats, points_spent, points_inc, &points_left, false);
 init_skills(true, false);
 do_birth_reset(quickstart_allowed, &quickstart_prev);
}
void do_cmd_choose_race(struct command *cmd)
{
 int choice;
 cmd_get_arg_choice(cmd, "choice", &choice);
 player_generate(player, player_id2race(choice), NULL, NULL, false);
 init_skills(true, true);
}
void do_cmd_choose_house(struct command *cmd)
{
 int choice;
 cmd_get_arg_choice(cmd, "choice", &choice);
 player_generate(player, NULL, player_house_from_count(choice), NULL, false);
 init_skills(true, true);
}
void do_cmd_choose_sex(struct command *cmd)
{
 int choice;
 cmd_get_arg_choice(cmd, "choice", &choice);
 player_generate(player, NULL, NULL, player_id2sex(choice), false);
 init_skills(true, true);
}
void do_cmd_buy_stat(struct command *cmd)
{
 /* .choice is the stat to sell */
 int choice;
 cmd_get_arg_choice(cmd, "choice", &choice);
 buy_stat(choice, stats, points_spent, points_inc, &points_left, true);
}
void do_cmd_sell_stat(struct command *cmd)
{
 /* .choice is the stat to sell */
 int choice;
 cmd_get_arg_choice(cmd, "choice", &choice);
 sell_stat(choice, stats, points_spent, points_inc, &points_left, true);
}
void do_cmd_reset_stats(struct command *cmd)
{
 reset_stats(stats, points_spent, points_inc, &points_left, true);
}
void do_cmd_refresh_stats(struct command *cmd)
{
 event_signal_birthpoints(points_spent, points_inc, points_left);
}
void do_cmd_choose_name(struct command *cmd)
{
 const char *str;
 cmd_get_arg_string(cmd, "name", &str);
 /* Set player name */
 my_strcpy(player->full_name, str, sizeof(player->full_name));
}
void do_cmd_choose_history(struct command *cmd)
{
 const char *str;
 /* Forget the old history */
 if (player->history)
  string_free(player->history);
 /* Get the new history */
 cmd_get_arg_string(cmd, "history", &str);
 player->history = string_make(str);
}
void do_cmd_accept_character(struct command *cmd)
{
 options_init_cheat();
 ignore_birth_init();
 /* Clear old messages, add new starting message */
 history_clear(player);
 history_add(player, "Began the quest to recover a Silmaril.", HIST_PLAYER_BIRTH);
 /* Note player birth in the message recall */
 message_add(" ", MSG_GENERIC);
 message_add("  ", MSG_GENERIC);
 message_add("====================", MSG_GENERIC);
 message_add("  ", MSG_GENERIC);
 message_add(" ", MSG_GENERIC);
 /* Embody */
 player_embody(player);
 /* Record final starting stats and skills */
 finalise_stats(player);
 finalise_skills();
 /* Hack - player knows the tunneling rune. */
 player->obj_k->modifiers[OBJ_MOD_TUNNEL] = 1;
 /* This is actually just a label for the file of self-made artefacts */
 seed_randart = randint0(0x10000000);
 /* Seed for flavors */
 seed_flavor = randint0(0x10000000);
 flavor_init();
 /* Outfit the player, if they can sell the stuff */
 player_outfit(player);
 /* Stop the player being quite so dead */
 player->is_dead = false;
 /* Character is now "complete" */
 character_generated = true;
 player->upkeep->playing = true;
 /* Disable repeat command, so we don't try to be born again */
 cmd_disable_repeat();
 /* No longer need the cached history. */
 string_free(prev.history);
 prev.history = NULL;
 string_free(quickstart_prev.history);
 quickstart_prev.history = NULL;
 /* Now we're really done.. */
 event_signal(EVENT_LEAVE_BIRTH);
}
/**
 * ------------------------------------------------------------------------
 * Roman numeral functions, for dynastic successions
 * ------------------------------------------------------------------------ */
/**
 * Find the start of a possible Roman numerals suffix by going back from the
 * end of the string to a space, then checking that all the remaining chars
 * are valid Roman numerals.
 * 
 * Return the start position, or NULL if there isn't a valid suffix. 
 */
char *find_roman_suffix_start(const char *buf)
{
 const char *start = strrchr(buf, ' ');
 const char *p;
 if (start) {
  start++;
  p = start;
  while (*p) {
   if (*p != 'I' && *p != 'V' && *p != 'X' && *p != 'L' &&
       *p != 'C' && *p != 'D' && *p != 'M') {
    start = NULL;
    break;
   }
   ++p;
  }
 }
 return (char *)start;
}
/**
 * Converts an arabic numeral (int) to a roman numeral (char *).
 *
 * An arabic numeral is accepted in parameter `n`, and the corresponding
 * upper-case roman numeral is placed in the parameter `roman`.  The
 * length of the buffer must be passed in the `bufsize` parameter.  When
 * there is insufficient room in the buffer, or a roman numeral does not
 * exist (e.g. non-positive integers) a value of 0 is returned and the
 * `roman` buffer will be the empty string.  On success, a value of 1 is
 * returned and the zero-terminated roman numeral is placed in the
 * parameter `roman`.
 */
static int int_to_roman(int n, char *roman, size_t bufsize)
{
 /* Roman symbols */
 char roman_symbol_labels[13][3] =
  {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX",
   "V", "IV", "I"};
 int roman_symbol_values[13] =
  {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
 /* Clear the roman numeral buffer */
 roman[0] = '\0';
 /* Roman numerals have no zero or negative numbers */
 if (n < 1)
  return 0;
 /* Build the roman numeral in the buffer */
 while (n > 0) {
  int i = 0;
  /* Find the largest possible roman symbol */
  while (n < roman_symbol_values[i])
   i++;
  /* No room in buffer, so abort */
  if (strlen(roman) + strlen(roman_symbol_labels[i]) + 1
   > bufsize)
   break;
  /* Add the roman symbol to the buffer */
  my_strcat(roman, roman_symbol_labels[i], bufsize);
  /* Decrease the value of the arabic numeral */
  n -= roman_symbol_values[i];
 }
 /* Ran out of space and aborted */
 if (n > 0) {
  /* Clean up and return */
  roman[0] = '\0';
  return 0;
 }
 return 1;
}
/**
 * Converts a roman numeral (char *) to an arabic numeral (int).
 *
 * The null-terminated roman numeral is accepted in the `roman`
 * parameter and the corresponding integer arabic numeral is returned.
 * Only upper-case values are considered. When the `roman` parameter
 * is empty or does not resemble a roman numeral, a value of -1 is
 * returned.
 *
 * XXX This function will parse certain non-sense strings as roman
 *     numerals, such as IVXCCCVIII
 */
static int roman_to_int(const char *roman)
{
 size_t i;
 int n = 0;
 char *p;
 char roman_token_chr1[] = "MDCLXVI";
 const char *roman_token_chr2[] = {0, 0, "DM", 0, "LC", 0, "VX"};
 int roman_token_vals[7][3] = {{1000},
                               {500},
                               {100, 400, 900},
                               {50},
                               {10, 40, 90},
                               {5},
                               {1, 4, 9}};
 if (strlen(roman) == 0)
  return -1;
 /* Check each character for a roman token, and look ahead to the
	   character after this one to check for subtraction */
 for (i = 0; i < strlen(roman); i++) {
  char c1, c2;
  int c1i, c2i;
  /* Get the first and second chars of the next roman token */
  c1 = roman[i];
  c2 = roman[i + 1];
  /* Find the index for the first character */
  p = strchr(roman_token_chr1, c1);
  if (p)
   c1i = p - roman_token_chr1;
  else
   return -1;
  /* Find the index for the second character */
  c2i = 0;
  if (roman_token_chr2[c1i] && c2) {
   p = strchr(roman_token_chr2[c1i], c2);
   if (p) {
    c2i = (p - roman_token_chr2[c1i]) + 1;
    /* Two-digit token, so skip a char on the next pass */
    i++;
   }
  }
  /* Increase the arabic numeral */
  n += roman_token_vals[c1i][c2i];
 }
 return n;
}
/**
 * \file player-calcs.c
 * \brief Player status calculation, signalling ui events based on 
 *	status changes.
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 * Copyright (c) 2014 Nick McConnell
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * ------------------------------------------------------------------------
 * Melee calculations
 * ------------------------------------------------------------------------ */
/**
 * Determines the total melee damage dice (before criticals and slays)
 */
static uint8_t total_mdd(struct player *p, const struct object *obj)
{
 uint8_t dd;
 /* If no weapon is wielded, use 1d1 */
 if (!obj) {
  dd = 1;
 } else {
  /* Otherwise use the weapon dice */
  dd = obj->dd;
 }
 /* Add the modifiers */
 dd += p->state.to_mdd;
 return dd;
}
/**
 * Determines the total melee damage sides (from strength and to_mds)
 * Does include strength and weight modifiers
 *
 * Includes factors for strength and weight, but not bonuses from ring of
 * damage etc
 */
uint8_t total_mds(struct player *p, struct player_state *state,
      const struct object *obj, int str_adjustment)
{
 uint8_t mds;
 int int_mds; /* to allow negative values in the intermediate stages */
 int str_to_mds;
 int divisor;
 str_to_mds = state->stat_use[STAT_STR] + str_adjustment;
 /* If no weapon, use 1d1 and don't limit strength bonus */
 if (!obj) {
  int_mds = 1;
  int_mds += str_to_mds;
 } else {
  /* If a weapon is being assessed, use its dice and limit bonus */
  int_mds = obj->ds;
  if (two_handed_melee(p)) {
   divisor = 10;
   /* Bonus for 'hand and a half' weapons like the bastard sword
			 * when used with two hands */
   int_mds += hand_and_a_half_bonus(p, obj);
  } else {
   divisor = 10;
  }
  /* Apply the Momentum ability */
  if (player_active_ability(p, "Momentum")) {
   divisor /= 2;
  }
  /* Limit the strength sides bonus by weapon weight */
  if ((str_to_mds > 0) && (str_to_mds > (obj->weight / divisor))) {
   int_mds += obj->weight / divisor;
  } else if ((str_to_mds < 0) && (str_to_mds < -(obj->weight / divisor))){
   int_mds += -(obj->weight / divisor);
  } else {
   int_mds += str_to_mds;
  }
 }
 /* Add generic damage bonus */
 int_mds += state->to_mds;
 /* Bonus for users of 'mighty blows' ability */
 if (player_active_ability(p, "Power")) {
  int_mds += 1;
 }
 /* Make sure the total is non-negative */
 mds = (int_mds < 0) ? 0 : int_mds;
 return mds;
}
/**
 * Bonus for 'hand and a half' weapons like the bastard sword when wielded
 * with two hands
 */
int hand_and_a_half_bonus(struct player *p, const struct object *obj)
{
 if (p && obj && obj->kind && of_has(obj->kind->flags, OF_HAND_AND_A_HALF) &&
  (equipped_item_by_slot_name(p, "weapon") == obj) &&
     (equipped_item_by_slot_name(p, "arm") == NULL)) {
  return 2;
 }
 return 0;
}
/**
 * Two handed melee weapon (including bastard sword used two handed)
 */
bool two_handed_melee(struct player *p)
{
 struct object *obj = equipped_item_by_slot_name(p, "weapon");
 if (!obj) return false;
 if (of_has(obj->kind->flags, OF_TWO_HANDED) ||
  hand_and_a_half_bonus(p, obj)) {
  return true;
 }
 return false;
}
/**
 * Bonus for certain races/houses (elves) using blades
 */
int blade_bonus(struct player *p, const struct object *obj)
{
 if (player_has(p, PF_BLADE_PROFICIENCY) && (tval_is_sword(obj))) {
  return 1;
 }
 return 0;
}
/**
 * Bonus for certain races/houses (dwarves) using axes
 */
int axe_bonus(struct player *p, const struct object *obj)
{
 if (player_has(p, PF_AXE_PROFICIENCY) && of_has(obj->kind->flags, OF_AXE)) {
  return 1;
 }
 return 0;
}
/**
 * Bonus for people with polearm affinity
 */
int polearm_bonus(struct player *p, const struct object *obj)
{
 if (player_active_ability(p, "Polearm Mastery") &&
  of_has(obj->kind->flags, OF_POLEARM)) {
  return 1;
 }
 return 0;
}
/**
 * Determines the total damage side for archery
 * based on the weight of the bow, strength, and the sides of the bow
 */
uint8_t total_ads(struct player *p, struct player_state *state,
      const struct object *obj, bool single_shot)
{
 uint8_t ads;
 int int_ads; /* to allow negative values in the intermediate stages */
 int str_to_ads;
 str_to_ads = state->stat_use[STAT_STR];
 if (player_active_ability(p, "Rapid Fire") && !single_shot) {
  str_to_ads -= 3;
 }
 int_ads = obj->ds;
 /* Limit the strength sides bonus by bow weight */
 if ((str_to_ads > 0) && (str_to_ads > (obj->weight / 10))) {
  int_ads += obj->weight / 10;
 } else if ((str_to_ads < 0) && (str_to_ads < -(obj->weight / 10))) {
  int_ads += -(obj->weight / 10);
 } else {
  int_ads += str_to_ads;
 }
 /* Add archery damage bonus */
 int_ads += state->to_ads;
 /* Make sure the total is non-negative */
 ads = (int_ads < 0) ? 0 : int_ads;
 return ads;
}
/**
 * ------------------------------------------------------------------------
 * 
 * ------------------------------------------------------------------------ */
/**
 * Decide which object comes earlier in the standard inventory listing,
 * defaulting to the first if nothing separates them.
 *
 * \return whether to replace the original object with the new one
 */
static bool earlier_object(struct object *orig, struct object *new)
{
 /* Check we have actual objects */
 if (!new) return false;
 if (!orig) return true;
 /* Usable ammo is before other ammo */
 if (tval_is_ammo(orig) && tval_is_ammo(new)) {
  /* First favour usable ammo */
  if ((player->state.ammo_tval == orig->tval) &&
   (player->state.ammo_tval != new->tval))
   return false;
  if ((player->state.ammo_tval != orig->tval) &&
   (player->state.ammo_tval == new->tval))
   return true;
 }
 /* Objects sort by decreasing type */
 if (orig->tval > new->tval) return false;
 if (orig->tval < new->tval) return true;
 /* Non-aware (flavored) items always come last (default to orig) */
 if (!object_flavor_is_aware(new)) return false;
 if (!object_flavor_is_aware(orig)) return true;
 /* Objects sort by increasing sval */
 if (orig->sval < new->sval) return false;
 if (orig->sval > new->sval) return true;
 /* Unaware objects always come last (default to orig) */
 if (new->kind->flavor && !object_flavor_is_aware(new)) return false;
 if (orig->kind->flavor && !object_flavor_is_aware(orig)) return true;
 /* Lights sort by decreasing fuel */
 if (tval_is_light(orig)) {
  if (orig->pval > new->pval) return false;
  if (orig->pval < new->pval) return true;
 }
 /* Objects sort by decreasing value, except ammo */
 if (tval_is_ammo(orig)) {
  if (object_value(orig) < object_value(new))
   return false;
  if (object_value(orig) > object_value(new))
   return true;
 } else {
  if (object_value(orig) > object_value(new))
   return false;
  if (object_value(orig) < object_value(new))
   return true;
 }
 /* No preference */
 return false;
}
int equipped_item_slot(struct player_body body, struct object *item)
{
 int i;
 if (item == NULL) return body.count;
 /* Look for an equipment slot with this item */
 for (i = 0; i < body.count; i++)
  if (item == body.slots[i].obj) break;
 /* Correct slot, or body.count if not equipped */
 return i;
}
/**
 * Put the player's inventory and quiver into easily accessible arrays.  The
 * pack may be overfull by one item
 */
void calc_inventory(struct player *p)//TODO make two quivers (= quiver slots?)
{
 int old_inven_cnt = p->upkeep->inven_cnt;
 int n_max = 1 + z_info->pack_size + p->body.count;
 struct object **old_pack = mem_zalloc(z_info->pack_size
  * sizeof(*old_pack));
 bool *assigned = mem_alloc(n_max * sizeof(*assigned));
 struct object *current;
 int i, j;
 /*
	 * Equipped items are already taken care of.  Only the others need
	 * to be tested for assignment to the pack.
	 */
 for (current = p->gear, j = 0; current; current = current->next, ++j) {
  assert(j < n_max);
  assigned[j] = object_is_equipped(p->body, current)
   || object_is_in_quiver(p, current);
 }
 for (; j < n_max; ++j) {
  assigned[j] = false;
 }
 /* Copy the current pack */
 for (i = 0; i < z_info->pack_size; i++) {
  old_pack[i] = p->upkeep->inven[i];
 }
 /* Prepare to fill the inventory */
 p->upkeep->inven_cnt = 0;
 for (i = 0; i <= z_info->pack_size; i++) {
  struct object *first = NULL;
  int jfirst = -1;
  /* Find the object that should go there. */
  j = 0;
  current = p->gear;
  while (1) {
   if (!current) break;
   assert(j < n_max);
   /* Consider it if it hasn't already been handled. */
   if (!assigned[j]) {
    /* Choose the first in order. */
    if (earlier_object(first, current)) {
     first = current;
     jfirst = j;
    }
   }
   current = current->next;
   ++j;
  }
  /* Allocate */
  p->upkeep->inven[i] = first;
  if (first) {
   ++p->upkeep->inven_cnt;
   assigned[jfirst] = true;
  }
 }
 /* Note reordering */
 if (character_dungeon && p->upkeep->inven_cnt == old_inven_cnt) {
  for (i = 0; i < z_info->pack_size; i++) {
   if (old_pack[i] && p->upkeep->inven[i] != old_pack[i]
    && !object_is_equipped(p->body, old_pack[i])
    && !object_is_in_quiver(p, old_pack[i])) {
    msg("You re-arrange your pack.");
    break;
   }
  }
 }
 mem_free(assigned);
 mem_free(old_pack);
}
/**
 * Calculate maximum voice.  You do not need to know any songs.
 *
 * This function induces status messages.
 */
void calc_voice(struct player *p, bool update)
{
 int i, msp, tmp;
 /* Get voice value -  20 + a compounding 20% bonus per point of gra */
 tmp = 20 * 100;
 if (p->state.stat_use[STAT_GRA] >= 0) {
  for (i = 0; i < p->state.stat_use[STAT_GRA]; i++) {
   tmp = tmp * 12 / 10;
  }
 } else {
  for (i = 0; i < -(p->state.stat_use[STAT_GRA]); i++) {
   tmp = tmp * 10 / 12;
  }
 }
 msp = tmp / 100;
 /* Return if no updates */
 if (!update) return;
 /* Maximum voice has changed */
 if (p->msp != msp) {
  i = 100;
  /* Get percentage of maximum sp */
  if (p->msp) i = ((100 * p->csp) / p->msp);
  /* Save new limit */
  p->msp = msp;
  /* Update current sp */
  p->csp = ((i * p->msp) / 100) + (((i * p->msp) % 100 >= 50) ? 1 : 0);
  /* Enforce new limit */
  if (p->csp >= msp) {
   p->csp = msp;
  }
  /* Display mana later */
  p->upkeep->redraw |= (PR_MANA);
 }
}
/**
 * Calculate the players (maximal) hit points
 *
 * Adjust current hitpoints if necessary
 */
static void calc_hitpoints(struct player *p)
{
 int i, mhp, tmp;
 /* Get voice value -  20 + a compounding 20% bonus per point of con */
 tmp = 20 * 100;
 if (p->state.stat_use[STAT_CON] >= 0) {
  for (i = 0; i < p->state.stat_use[STAT_CON]; i++) {
   tmp = tmp * 12 / 10;
  }
 } else {
  for (i = 0; i < -(p->state.stat_use[STAT_CON]); i++) {
   tmp = tmp * 10 / 12;
  }
 }
 mhp = tmp / 100;
 /* Maximum hitpoints has changed */
 if (p->mhp != mhp) {
  i = 100;
  /* Get percentage of maximum hp */
  if (p->mhp) i = ((100 * p->chp) / p->mhp);
  /* Save new limit */
  p->mhp = mhp;
  /* Update current hp */
  p->chp = ((i * p->mhp) / 100) + (((i * p->mhp) % 100 >= 50) ? 1 : 0);
  /* Enforce new limit */
  if (p->chp >= mhp) {
   p->chp = mhp;
  }
  /* Display mana later */
  p->upkeep->redraw |= (PR_HP);
 }
}
/**
 * Determine the radius of possibly flickering lights
 */
static int light_up_to(struct object *obj)
{
 int radius = obj->pval;
 /* Some lights flicker */
 if (of_has(obj->flags, OF_DARKNESS)) {
  while ((radius > -2) && one_in_(3)) {
   radius--;
  }
 } else if (obj->timeout < 100) {
  while ((radius > 0) && one_in_(3)) {
   radius--;
  }
 }
 return radius;
}
/**
 * Determines how much an enemy in a given location should make the sword glow
 */
static int hate_level(struct loc grid, int multiplier)
{
 int dist;
 /* Check distance of monster from player (by noise) */
 dist = MAX(flow_dist(cave->monster_noise, grid), 1);
 /* Determine the danger level */
 return (50 * multiplier) / dist;
}
/**
 * Determine whether a melee weapon is glowing in response to nearby enemies
 *
 * \param obj is the object to test; for most purposes you will want to use
 * the base object and not the player's version of it.
 * \param near affects the line of sight check.  If there's a grid in the
 * player's line of sight that is in the square centered on the object with
 * side length near + 1, then the glowing effect, if any, will be visible.
 * near must be non-negative.
 */
bool weapon_glows(struct object *obj, int near)
{
 int i, total_hate = 0;
 struct loc grid, obj_grid;
 if (!character_dungeon) return false;
 /* Must be a melee weapon with slays */
 if (!tval_is_melee_weapon(obj) || !obj->slays) return false;
 /* Use the player's position where needed */
 obj_grid = loc_is_zero(obj->grid) ? player->grid : obj->grid;
 /* Out of LOS objects don't glow (or it can't be seen) */
 assert(near >= 0);
 grid.x = obj_grid.x - near;
 grid.y = obj_grid.y - near;
 while (1) {
  if (square_in_bounds(cave, grid) && square_isview(cave, grid)) {
   break;
  }
  ++grid.x;
  if (grid.x > obj_grid.x + near) {
   ++grid.y;
   if (grid.y > obj_grid.y + 1) {
    return false;
   }
   grid.x = obj_grid.x - near;
  }
 }
 /* Create a 'flow' around the object */
 cave->monster_noise.centre = obj_grid;
 update_flow(cave, &cave->monster_noise, NULL);
 /* Add up the total of creatures vulnerable to the weapon's slays */
 for (i = 1; i < cave_monster_max(cave); i++) {
  bool target = false;
  int j, multiplier = 1;
  struct monster *mon = cave_monster(cave, i);
  struct monster_race *race = mon->race;
  /* Paranoia -- Skip dead monsters */
  if (!race) continue;
  /* Determine if a slay is applicable */
  for (j = 0; j < z_info->slay_max; j++) {
   if (obj->slays[j] &&
    rf_has(race->flags, slays[j].race_flag)) {
    target = true;
    break;
   }
  }
  /* Skip inapplicable monsters */
  if (!target) continue;
  /* Increase the effect for uniques */
  if (rf_has(race->flags, RF_UNIQUE)) multiplier *= 2;
  /* Increase the effect for individually occuring creatures */
  if (!monster_has_friends(mon)) multiplier *= 2;
  /* Add up the 'hate' */
  total_hate += hate_level(mon->grid, multiplier);
 }
 /* Add a similar effect for very nearby webs for spider slaying weapons */
 for (i = 0; i < z_info->slay_max; i++) {
  if (slays[i].race_flag == RF_SPIDER) break;
 }
 if (i < z_info->slay_max && obj->slays[i]) {
  for (grid.y = obj_grid.y - 2; grid.y <= obj_grid.y + 2; grid.y++) {
   for (grid.x = obj_grid.x - 2; grid.x <= obj_grid.x + 2; grid.x++) {
    if (square_in_bounds(cave, grid) &&
     square_iswebbed(cave, grid)) {
     /* Add up the 'hate' */
     total_hate += hate_level(grid, 1);
    }
   }
  }
 }
 return total_hate >= 15;
}
/**
 * Calculate and set the current light radius.
 *
 * The light radius will be the total of all lights carried.
 */
void calc_light(struct player *p)
{
 int i;
 int new_light = 0;
 struct object *main_weapon = equipped_item_by_slot_name(player, "weapon");
 struct object *second_weapon = equipped_item_by_slot_name(player, "arm");
 struct song *trees = lookup_song("the Trees");
 /* Assume no light */
 new_light = 0;
 /* Examine all wielded objects */
 for (i = 0; i < p->body.count; i++) {
  struct object *obj = slot_object(p, i);
  /* Skip empty slots */
  if (!obj) continue;
  /* Does this item glow? */
  if (of_has(obj->flags, OF_LIGHT)) new_light++;
  /* Does this item create darkness? */
  if (of_has(obj->flags, OF_DARKNESS)) new_light--;
  /* Examine actual lights */
  if (tval_is_light(obj)) {
   /* Some items provide permanent, bright, light */
   if (of_has(obj->flags, OF_NO_FUEL)) {
    new_light += obj->pval;
   } else if (obj->timeout > 0) {
    /* Torches or lanterns (with fuel) provide some light */
    new_light += light_up_to(obj);
   }
  }
 }
 /* Increase radius when the player's weapon glows */
 if (main_weapon && weapon_glows(main_weapon, 0)) new_light++;
 if (second_weapon && weapon_glows(second_weapon, 0)) new_light++;
 /* Player is darkened */
 if (p->timed[TMD_DARKENED] && (new_light > 0)) new_light--;
 /* Smithing brightens the room a bit */
 if (p->upkeep->smithing) new_light += 2;
 /* Song of the Trees */
 if (player_is_singing(p, trees)) {
  new_light += song_bonus(p, p->state.skill_use[SKILL_SONG], trees);
 }
 /* Update the light radius and visuals if necessary */
 if (p->upkeep->cur_light != new_light) {
  p->upkeep->cur_light = new_light;
  p->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
 }
 return;
}
/**
 * Computes current weight limit in tenths of pounds.
 *
 * 100 pounds + a compounding 20% bonus per point of str
 */
int weight_limit(struct player_state state)
{
 int i;
 int limit = 1000;
 int str = state.stat_use[STAT_STR];
 if (str >= 0) {
  for (i = 0; i < str; i++) {
   limit = limit * 12 / 10;
  }
 } else {
  for (i = 0; i < -str; i++) {
   limit = limit * 10 / 12;
  }
 }
 /* Return the result */
 return limit;
}
/**
 * Computes weight remaining before burdened.
 */
int weight_remaining(struct player *p)
{
 return weight_limit(p->state) - p->upkeep->total_weight;
}
/**
 * Calculate the players current "state", taking into account
 * not only race/class intrinsics, but also objects being worn
 * and temporary spell effects.
 *
 * See also calc_mana() and calc_hitpoints().
 *
 * Take note of the new "speed code", in particular, a very strong
 * player will start slowing down as soon as he reaches 150 pounds,
 * but not until he reaches 450 pounds will he be half as fast as
 * a normal kobold.  This both hurts and helps the player, hurts
 * because in the old days a player could just avoid 300 pounds,
 * and helps because now carrying 300 pounds is not very painful.
 *
 * The "weapon" and "bow" do *not* add to the bonuses to hit or to
 * damage, since that would affect non-combat things.  These values
 * are actually added in later, at the appropriate place.
 *
 * If known_only is true, calc_bonuses() will only use the known
 * information of objects; thus it returns what the player _knows_
 * the character state to be.
 */
void calc_bonuses(struct player *p, struct player_state *state, bool known_only,
      bool update)
{
 int i, j;
 struct object *launcher = equipped_item_by_slot_name(p, "shooting");
 struct object *weapon = equipped_item_by_slot_name(p, "weapon");
 struct object *off = equipped_item_by_slot_name(p, "arm");
 bitflag f[OF_SIZE];
 int armour_weight = 0;
 struct song *song;
 /* Remove off-hand weapons if you cannot wield them */
 if (!player_active_ability(p, "Two Weapon Fighting") &&
  off && tval_is_weapon(off)) {
  msg("You can no longer wield both weapons.");
  inven_takeoff(off);
 }
 /* Reset */
 memset(state, 0, sizeof *state);
 /* Set various defaults */
 state->speed = 2;
 state->el_info[ELEM_FIRE].res_level = 1;
 state->el_info[ELEM_COLD].res_level = 1;
 state->el_info[ELEM_POIS].res_level = 1;
 /* Extract race/house skill info */
 for (i = 0; i < SKILL_MAX; i++) {
  state->skill_misc_mod[i] = p->race->skill_adj[i]
   + p->house->skill_adj[i];
 }
 /* Base pflags */
 pf_copy(state->pflags, p->race->pflags);
 /* Analyze equipment */
 for (i = 0; i < p->body.count; i++) {
  struct object *obj = slot_object(p, i);
  if (obj) {
   /* Extract the item flags */
   if (known_only) {
    object_flags_known(obj, f);
   } else {
    object_flags(obj, f);
   }
   /* Apply the item flags */
   for (j = 0; j < OF_MAX; j++) {
    if (of_has(f, j)) {
     state->flags[j]++;
    }
   }
   /* Apply modifiers */
   for (j = 0; j < STAT_MAX; j++) {
    state->stat_equip_mod[j] += obj->modifiers[j];
   }
   for (j = 0; j < SKILL_MAX; j++) {
    state->skill_equip_mod[j] += obj->modifiers[STAT_MAX + j];
    if (j == SKILL_EVASION) {
     state->skill_equip_mod[j] += obj->evn;
    }
   }
   if (obj->modifiers[OBJ_MOD_DAMAGE_SIDES]) {
    state->to_mds += obj->modifiers[OBJ_MOD_DAMAGE_SIDES];
    state->to_ads += obj->modifiers[OBJ_MOD_DAMAGE_SIDES];
   }
   /* Apply element info */
   for (j = 0; j < ELEM_MAX; j++) {
    if (!known_only || obj->known->el_info[j].res_level) {
     state->el_info[j].res_level += obj->el_info[j].res_level;
    }
   }
   /* Add up the armour weight */
   if (tval_is_armor(obj)) {
    armour_weight += obj->weight;
   }
   /* Do not apply weapon to-hit bonuses yet */
   if (tval_is_weapon(obj)) continue;
   /* Apply the bonus to hit */
   state->skill_equip_mod[SKILL_MELEE] += obj->att;
   state->skill_equip_mod[SKILL_ARCHERY] += obj->att;
  }
 }
 /* Parrying grants extra bonus for weapon evasion */
 if (weapon && player_active_ability(p, "Parry")) {
  state->skill_equip_mod[SKILL_EVASION] += weapon->evn;
 }
 /* Deal with vulnerabilities and dark resistance */
 for (i = 0; i < ELEM_MAX; i++) {
  /* Represent overall vulnerabilities as negatives of the normal range */
  if (state->el_info[i].res_level < 1) {
   state->el_info[i].res_level -= 2;
  }
  /* Dark resistance depends only on the brightness of the player grid */
  if ((i == ELEM_DARK) && character_dungeon) {
   state->el_info[i].res_level = square_light(cave, p->grid);
  }
 }
 /* Ability stat boosts */
 state->stat_misc_mod[STAT_STR] += player_active_ability(p, "Strength");
 state->stat_misc_mod[STAT_DEX] += player_active_ability(p, "Dexterity");
 state->stat_misc_mod[STAT_CON] += player_active_ability(p, "Constitution");
 state->stat_misc_mod[STAT_GRA] += player_active_ability(p, "Grace");
 if (player_active_ability(p, "Strength in Adversity")) {
  /* If <= 50% health, give a bonus to strength and grace */
  if (health_level(p->chp, p->mhp) <= HEALTH_BADLY_WOUNDED) {
   state->stat_misc_mod[STAT_STR]++;
   state->stat_misc_mod[STAT_GRA]++;
  }
  /* If <= 25% health, give an extra bonus */
  if (health_level(p->chp, p->mhp) <= HEALTH_ALMOST_DEAD) {
   state->stat_misc_mod[STAT_STR]++;
   state->stat_misc_mod[STAT_GRA]++;
  }
 }
 /* Ability skill modifications */
 if (player_active_ability(p, "Rapid Attack")) {
  state->skill_misc_mod[SKILL_MELEE] -= 3;
 }
 if (player_active_ability(p, "Rapid Fire")) {
  state->skill_misc_mod[SKILL_ARCHERY] -= 3;
 }
 if (player_active_ability(p, "Poison Resistance")) {
  state->el_info[ELEM_POIS].res_level += 1;
 }
 /* Timed effects */
 if (player_timed_grade_eq(p, TMD_STUN, "Heavy Stun")) {
  for (i = 0; i < SKILL_MAX; i++) {
   state->skill_misc_mod[i] -= 4;
  }
 } else if (player_timed_grade_eq(p, TMD_STUN, "Stun")) {
  for (i = 0; i < SKILL_MAX; i++) {
   state->skill_misc_mod[i] -= 2;
  }
 }
 if (player_timed_grade_eq(p, TMD_FOOD, "Weak")) {
  state->stat_misc_mod[STAT_STR] -= 1;
 }
 if (p->timed[TMD_RAGE]) {
  state->stat_misc_mod[STAT_STR] += 1;
  state->stat_misc_mod[STAT_DEX] -= 1;
  state->stat_misc_mod[STAT_CON] += 1;
  state->stat_misc_mod[STAT_GRA] -= 1;
 }
 if (p->timed[TMD_STR]) {
  state->stat_misc_mod[STAT_STR] += 3;
  state->flags[OF_SUST_STR] += 1;
 }
 if (p->timed[TMD_DEX]) {
  state->stat_misc_mod[STAT_DEX] += 3;
  state->flags[OF_SUST_DEX] += 1;
 }
 if (p->timed[TMD_CON]) {
  state->stat_misc_mod[STAT_CON] += 3;
  state->flags[OF_SUST_CON] += 1;
 }
 if (p->timed[TMD_GRA]) {
  state->stat_misc_mod[STAT_GRA] += 3;
  state->flags[OF_SUST_GRA] += 1;
 }
 if (p->timed[TMD_FAST]) {
  state->speed += 1;
 }
 if (p->timed[TMD_SLOW]) {
  state->speed -= 1;
 }
 if (p->timed[TMD_SINVIS]) {
  state->flags[OF_SEE_INVIS] += 1;
  state->flags[OF_PROT_BLIND] += 1;
  state->flags[OF_PROT_HALLU] += 1;
 }
 /* Decrease food consumption with 'mind over body' ability */
 if (player_active_ability(p, "Mind Over Body")) {
  state->flags[OF_HUNGER] -= 1;
 }
 /* Protect from confusion, stunning, hallucinaton with 'clarity' ability */
 if (player_active_ability(p, "Clarity")) {
  state->flags[OF_PROT_CONF] += 1;
  state->flags[OF_PROT_STUN] += 1;
  state->flags[OF_PROT_HALLU] += 1;
 }
 /* Calculate stats */
 for (i = 0; i < STAT_MAX; i++) {
  state->stat_use[i] = p->stat_base[i] + state->stat_equip_mod[i]
   + p->stat_drain[i] + state->stat_misc_mod[i];
  /* Hack for correct calculations during pre-birth */
  if (!p->body.name) {
   state->stat_use[i] += p->race->stat_adj[i]
    + p->house->stat_adj[i];
  }
  /* Cap to -9 and 20 */
  state->stat_use[i] = MIN(state->stat_use[i], BASE_STAT_MAX);
  state->stat_use[i] = MAX(state->stat_use[i], BASE_STAT_MIN);
 }
 /* Analyze weight */
 j = p->upkeep->total_weight;
 i = weight_limit(*state);
 if (j > i) state->speed -= 1;
 state->speed += state->flags[OF_SPEED];
 /* Stealth slows the player down (unless they are passing) */
 if (p->stealth_mode) {
  if (p->previous_action[0] != ACTION_STAND) state->speed -= 1;
      state->skill_misc_mod[SKILL_STEALTH] += z_info->stealth_bonus;
 }
    /* Sprinting speeds the player up */
 if (player_is_sprinting(p)) {
  state->speed += 1;
 }
 /* Speed must lie between 1 and 3 */
 state->speed = MIN(3, MAX(1, state->speed));
 /* Increase food consumption if regenerating */
 if (state->flags[OF_REGEN]) state->flags[OF_HUNGER] += 1;
 /* Armour weight (not inventory weight) reduces stealth
	 * by 1 point per 10 pounds (rounding down) */
 state->skill_equip_mod[SKILL_STEALTH] -= armour_weight / 100;
 /* Penalise stealth based on song(s) being sung */
 state->skill_misc_mod[SKILL_STEALTH] -= player_song_noise(p);
 /*** Modify skills by ability scores ***/
 state->skill_stat_mod[SKILL_MELEE] = state->stat_use[STAT_DEX];
 state->skill_stat_mod[SKILL_ARCHERY] = state->stat_use[STAT_DEX];
 state->skill_stat_mod[SKILL_EVASION] = state->stat_use[STAT_DEX];
 state->skill_stat_mod[SKILL_STEALTH] = state->stat_use[STAT_DEX];
 state->skill_stat_mod[SKILL_PERCEPTION] = state->stat_use[STAT_GRA];
 state->skill_stat_mod[SKILL_WILL] = state->stat_use[STAT_GRA];
 state->skill_stat_mod[SKILL_SMITHING] = state->stat_use[STAT_GRA];
 state->skill_stat_mod[SKILL_SONG] = state->stat_use[STAT_GRA];
 /* Finalise song skill first as it modifies some other skills... */
 state->skill_use[SKILL_SONG] = p->skill_base[SKILL_SONG]
  + state->skill_equip_mod[SKILL_SONG]
  + state->skill_stat_mod[SKILL_SONG]
  + state->skill_misc_mod[SKILL_SONG];
 /* Apply song effects that modify skills */
 song = lookup_song("Slaying");
 if (player_is_singing(p, song)) {
  int pskill = state->skill_use[SKILL_SONG];
  state->skill_misc_mod[SKILL_MELEE] += song_bonus(p, pskill, song);
  state->skill_misc_mod[SKILL_ARCHERY] += song_bonus(p, pskill, song);
 }
 song = lookup_song("Aule");
 if (player_is_singing(p, song)) {
  int pskill = state->skill_use[SKILL_SONG];
  state->skill_misc_mod[SKILL_SMITHING] += song_bonus(p, pskill, song);
 }
 song = lookup_song("Staying");
 if (player_is_singing(p, song)) {
  int pskill = state->skill_use[SKILL_SONG];
  state->skill_misc_mod[SKILL_WILL] += song_bonus(p, pskill, song);
 }
 song = lookup_song("Freedom");
 if (player_is_singing(p, song)) {
  state->flags[OF_FREE_ACT] += 1;
 }
 /* Analyze launcher */
 if (launcher) {
  state->skill_equip_mod[SKILL_ARCHERY] += launcher->att;
  state->ammo_tval = TV_ARROW;
  state->add = launcher->dd;
  state->ads = total_ads(p, state, launcher, false);
 }
 /* Analyze weapon */
 if (weapon) {
  /* Add the weapon's attack mod */
  state->skill_equip_mod[SKILL_MELEE] += weapon->att;
  /* Attack bonuses for matched weapon types */
  state->skill_misc_mod[SKILL_MELEE] += blade_bonus(p, weapon)
   + axe_bonus(p, weapon) + polearm_bonus(p, weapon);
 }
 /* Deal with the 'Versatility' ability */
 if (player_active_ability(p, "Versatility") &&
  (p->skill_base[SKILL_ARCHERY] > p->skill_base[SKILL_MELEE])) {
  state->skill_misc_mod[SKILL_MELEE] +=
   (p->skill_base[SKILL_ARCHERY] - p->skill_base[SKILL_MELEE]) / 2;
 }
 /* Generate melee dice/sides from weapon, to_mdd, to_mds, strength */
 state->mdd = total_mdd(p, weapon);
 state->mds = total_mds(p, state, weapon,
         player_active_ability(p, "Rapid Attack") ? -3 : 0);
 /* Determine the off-hand melee score, damage and sides */
 if (player_active_ability(p, "Two Weapon Fighting") &&
  off && tval_is_weapon(off)) {
  /* Remove main-hand specific bonuses */
  if (weapon) {
   state->offhand_mel_mod -= weapon->att
    + blade_bonus(p, weapon)
    + axe_bonus(p, weapon)
    + polearm_bonus(p, weapon);
  }
  if (player_active_ability(p, "Rapid Attack")) {
   state->offhand_mel_mod += 3;
  }
  /* Add off-hand specific bonuses */
  state->offhand_mel_mod += off->att + blade_bonus(p, off)
   + axe_bonus(p, off) + polearm_bonus(p, off) - 3;
  state->mdd2 = total_mdd(p, off);
  state->mds2 = total_mds(p, state, off, -3);
 }
 /* Entrancement or being knocked out sets total evasion score to -5 */
 if (p->timed[TMD_ENTRANCED] ||
  player_timed_grade_eq(p, TMD_STUN, "Knocked Out")) {
  state->skill_misc_mod[SKILL_EVASION] = -5
   - (p->skill_base[SKILL_EVASION]
      + state->skill_equip_mod[SKILL_EVASION]
      + state->skill_stat_mod[SKILL_EVASION]);
 }
 /* Finalise the non-song skills */
 for (i = 0; i < SKILL_SONG; i++) {
  state->skill_use[i] = p->skill_base[i] + state->skill_equip_mod[i]
   + state->skill_stat_mod[i] + state->skill_misc_mod[i];
 }
 /* Compute bounds for the protection roll */
 state->p_min = protection_roll(p, PROJ_HURT, true, MINIMISE);
 state->p_max = protection_roll(p, PROJ_HURT, true, MINIMISE);
 return;
}
/**
 * Calculate bonuses, and print various things on changes.
 */
static void update_bonuses(struct player *p)
{
 int i;
 struct player_state state = p->state;
 struct player_state known_state = p->known_state;
 /* ------------------------------------
	 * Calculate bonuses
	 * ------------------------------------ */
 calc_bonuses(p, &state, false, true);
 calc_bonuses(p, &known_state, true, true);
 /* ------------------------------------
	 * Notice changes
	 * ------------------------------------ */
 /* Analyze stats */
 for (i = 0; i < STAT_MAX; i++) {
  /* Notice changes */
  if (state.stat_use[i] != p->state.stat_use[i]) {
   /* Redisplay the stats later */
   p->upkeep->redraw |= (PR_STATS);
   /* Change in CON affects Hitpoints */
   if (i == STAT_CON)
    p->upkeep->update |= (PU_HP);
   /* Change in GRA affects voice */
   if (i == STAT_GRA)
    p->upkeep->update |= (PU_MANA);
  }
 }
 /* Hack -- See Invis Change */
 if (state.flags[OF_SEE_INVIS] != p->state.flags[OF_SEE_INVIS])
  /* Update monster visibility */
  p->upkeep->update |= (PU_MONSTERS);
 /* Redraw speed (if needed) */
 if (state.speed != p->state.speed)
  p->upkeep->redraw |= (PR_SPEED);
    /* Always redraw terrain */
    p->upkeep->redraw |= (PR_TERRAIN);
 /* Redraw melee (if needed) */
 if ((state.skill_use[SKILL_MELEE] != p->state.skill_use[SKILL_MELEE]) ||
  (state.mdd != p->state.mdd) || (state.mds != p->state.mds) ||
  (state.mdd2 != p->state.mdd2) || (state.mds2 != p->state.mds2)) {
  /* Redraw */
  p->upkeep->redraw |= (PR_MELEE);
 }
 /* Redraw archery (if needed) */
 if ((state.skill_use[SKILL_ARCHERY] != p->state.skill_use[SKILL_ARCHERY])
  || (state.add != p->state.add) || (state.ads != p->state.ads)) {
  /* Redraw */
  p->upkeep->redraw |= (PR_ARC);
 }
 /* Redraw armor (if needed) */
 if (state.skill_use[SKILL_EVASION] != p->state.skill_use[SKILL_EVASION]
   || state.p_min != p->state.p_min
   || state.p_max != p->state.p_max) {
  /* Redraw */
  p->upkeep->redraw |= (PR_ARMOR);
 }
 memcpy(&p->state, &state, sizeof(state));
 memcpy(&p->known_state, &known_state, sizeof(known_state));
 /* Propagate knowledge */
 update_player_object_knowledge(p);
}
/**
 * ------------------------------------------------------------------------
 * Monster and object tracking functions
 * ------------------------------------------------------------------------ */
/**
 * Track the given monster
 */
void health_track(struct player_upkeep *upkeep, struct monster *mon)
{
 upkeep->health_who = mon;
 upkeep->redraw |= PR_HEALTH;
}
/**
 * Track the given monster race
 */
void monster_race_track(struct player_upkeep *upkeep, struct monster_race *race)
{
 /* Don't track when hallucinating or raging */
 if (player->timed[TMD_IMAGE] || player->timed[TMD_RAGE]) return;
 /* Save this monster ID */
 upkeep->monster_race = race;
 /* Window stuff */
 upkeep->redraw |= (PR_MONSTER);
}
/**
 * Track the given object
 */
void track_object(struct player_upkeep *upkeep, struct object *obj)
{
 upkeep->object = obj;
 upkeep->object_kind = NULL;
 upkeep->redraw |= (PR_OBJECT);
}
/**
 * Track the given object kind
 */
void track_object_kind(struct player_upkeep *upkeep, struct object_kind *kind)
{
 upkeep->object = NULL;
 upkeep->object_kind = kind;
 upkeep->redraw |= (PR_OBJECT);
}
/**
 * Cancel all object tracking
 */
void track_object_cancel(struct player_upkeep *upkeep)
{
 upkeep->object = NULL;
 upkeep->object_kind = NULL;
 upkeep->redraw |= (PR_OBJECT);
}
/**
 * Is the given item tracked?
 */
bool tracked_object_is(struct player_upkeep *upkeep, struct object *obj)
{
 return (upkeep->object == obj);
}
/**
 * ------------------------------------------------------------------------
 * Generic "deal with" functions
 * ------------------------------------------------------------------------ */
/**
 * Handle "player->upkeep->notice"
 */
void notice_stuff(struct player *p)
{
 /* Notice stuff */
 if (!p->upkeep->notice) return;
 /* Deal with ignore stuff */
 if (p->upkeep->notice & PN_IGNORE) {
  p->upkeep->notice &= ~(PN_IGNORE);
  ignore_drop(p);
 }
 /* Combine the pack */
 if (p->upkeep->notice & PN_COMBINE) {
  p->upkeep->notice &= ~(PN_COMBINE);
  combine_pack(p);
 }
 /* Dump the monster messages */
 if (p->upkeep->notice & PN_MON_MESSAGE) {
  p->upkeep->notice &= ~(PN_MON_MESSAGE);
  /* Make sure this comes after all of the monster messages */
  show_monster_messages();
 }
}
/**
 * Handle "player->upkeep->update"
 */
void update_stuff(struct player *p)
{
 /* Update stuff */
 if (!p->upkeep->update) return;
 if (p->upkeep->update & (PU_INVEN)) {
  p->upkeep->update &= ~(PU_INVEN);
  calc_inventory(p);
 }
 if (p->upkeep->update & (PU_BONUS)) {
  p->upkeep->update &= ~(PU_BONUS);
  update_bonuses(p);
 }
 if (p->upkeep->update & (PU_TORCH)) {
  p->upkeep->update &= ~(PU_TORCH);
  calc_light(p);
 }
 if (p->upkeep->update & (PU_HP)) {
  p->upkeep->update &= ~(PU_HP);
  calc_hitpoints(p);
 }
 if (p->upkeep->update & (PU_MANA)) {
  p->upkeep->update &= ~(PU_MANA);
  calc_voice(p, true);
 }
 /* Character is not ready yet, no map updates */
 if (!character_generated) return;
 /* Map is not shown, no map updates */
 if (!map_is_visible()) return;
 if (p->upkeep->update & (PU_UPDATE_VIEW)) {
  p->upkeep->update &= ~(PU_UPDATE_VIEW);
  update_view(cave, p);
 }
 if (p->upkeep->update & (PU_DISTANCE)) {
  p->upkeep->update &= ~(PU_DISTANCE);
  p->upkeep->update &= ~(PU_MONSTERS);
  update_monsters(true);
 }
 if (p->upkeep->update & (PU_MONSTERS)) {
  p->upkeep->update &= ~(PU_MONSTERS);
  update_monsters(false);
 }
 if (p->upkeep->update & (PU_PANEL)) {
  p->upkeep->update &= ~(PU_PANEL);
  event_signal(EVENT_PLAYERMOVED);
 }
}
struct flag_event_trigger
{
 uint32_t flag;
 game_event_type event;
};
/**
 * Events triggered by the various flags.
 */
static const struct flag_event_trigger redraw_events[] =
{
 { PR_MISC, EVENT_NAME },
 { PR_EXP, EVENT_EXPERIENCE },
 { PR_STATS, EVENT_STATS },
 { PR_ARMOR, EVENT_ARMOR },
 { PR_HP, EVENT_HP },
 { PR_MANA, EVENT_MANA },
 { PR_SONG, EVENT_SONG },
 { PR_MELEE, EVENT_MELEE },
 { PR_ARC, EVENT_ARCHERY },
 { PR_HEALTH, EVENT_MONSTERHEALTH },
 { PR_DEPTH, EVENT_DUNGEONLEVEL },
 { PR_SPEED, EVENT_PLAYERSPEED },
 { PR_STATE, EVENT_STATE },
 { PR_STATUS, EVENT_STATUS },
 { PR_LIGHT, EVENT_LIGHT },
 { PR_INVEN, EVENT_INVENTORY },
 { PR_EQUIP, EVENT_EQUIPMENT },
 { PR_MONLIST, EVENT_MONSTERLIST },
 { PR_ITEMLIST, EVENT_ITEMLIST },
 { PR_MONSTER, EVENT_MONSTERTARGET },
 { PR_OBJECT, EVENT_OBJECTTARGET },
 { PR_MESSAGE, EVENT_MESSAGE },
 { PR_COMBAT, EVENT_COMBAT_DISPLAY },
};
/**
 * Handle "player->upkeep->redraw"
 */
void redraw_stuff(struct player *p)
{
 size_t i;
 uint32_t redraw = p->upkeep->redraw;
 /* Redraw stuff */
 if (!redraw) return;
 /* Character is not ready yet, no screen updates */
 if (!character_generated) return;
 /* Map is not shown, subwindow updates only */
 if (!map_is_visible())
  redraw &= PR_SUBWINDOW;
 /* Hack - rarely update while resting or running, makes it over quicker */
 if (((player_resting_count(p) % 100) || (p->upkeep->running % 100))
  && !(redraw & (PR_MESSAGE | PR_MAP)))
  return;
 /* For each listed flag, send the appropriate signal to the UI */
 for (i = 0; i < N_ELEMENTS(redraw_events); i++) {
  const struct flag_event_trigger *hnd = &redraw_events[i];
  if (redraw & hnd->flag)
   event_signal(hnd->event);
 }
 /* Then the ones that require parameters to be supplied. */
 if (redraw & PR_MAP) {
  /* Mark the whole map to be redrawn */
  event_signal_point(EVENT_MAP, -1, -1);
 }
 p->upkeep->redraw &= ~redraw;
 /* Map is not shown, subwindow updates only */
 if (!map_is_visible()) return;
 /*
	 * Do any plotting, etc. delayed from earlier - this set of updates
	 * is over.
	 */
 event_signal(EVENT_END);
}
/**
 * Handle "player->upkeep->update" and "player->upkeep->redraw"
 */
void handle_stuff(struct player *p)
{
 if (p->upkeep->update) update_stuff(p);
 if (p->upkeep->redraw) redraw_stuff(p);
}
/**
 * \file player-history.c
 * \brief Character auto-history creation, management, and display
 *
 * Copyright (c) 2007 J.D. White
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Memory allocation constants.
 */
/**
 * Initialise an empty history list.
 */
static void history_init(struct player_history *h)
{
 h->next = 0;
 h->length = 20;
 h->entries = mem_zalloc(h->length * sizeof(*h->entries));
}
/**
 * Increase the history array size.
 */
static void history_realloc(struct player_history *h)
{
 h->length += 20;
 h->entries = mem_realloc(h->entries,
   h->length * sizeof *h->entries);
}
/**
 * Clear any existing history.
 */
void history_clear(struct player *p)
{
 struct player_history *h = &p->hist;
 if (h->entries) {
  mem_free(h->entries);
  h->entries = NULL;
 }
 h->next = 0;
 h->length = 0;
}
/**
 * Add an entry with text `text` to the history list, with type `type`
 * ("HIST_xxx" in player-history.h), and artifact number `id` (0 for
 * everything else).
 *
 * Return true on success.
 */
bool history_add_full(struct player *p,
  bitflag *type,
  int aidx,
  int dlev,
  int turnno,
  const char *text)
{
 struct player_history *h = &p->hist;
 /* Allocate or expand the history list if needed */
 if (!h->entries)
  history_init(h);
 else if (h->next == h->length)
  history_realloc(h);
 /* Add entry */
 hist_copy(h->entries[h->next].type, type);
 h->entries[h->next].dlev = dlev;
 h->entries[h->next].a_idx = aidx;
 h->entries[h->next].turn = turnno;
 my_strcpy(h->entries[h->next].event,
   text,
   sizeof(h->entries[h->next].event));
 h->next++;
 return true;
}
/**
 * Add an entry to the history ledger with specified bitflags.
 */
static bool history_add_with_flags(struct player *p,
  const char *text,
  bitflag flags[HIST_SIZE],
  const struct artifact *artifact)
{
 return history_add_full(p,
  flags,
  artifact ? artifact->aidx : 0,
  p->depth,
  p->turn,
  text);
}
/**
 * Adds an entry to the history ledger.
 */
bool history_add(struct player *p, const char *text, int type)
{
 bitflag flags[HIST_SIZE];
 hist_wipe(flags);
 hist_on(flags, type);
 return history_add_with_flags(p, text, flags, NULL);
}
/**
 * Returns true if the artifact is KNOWN in the history log.
 */
bool history_is_artifact_known(struct player *p, const struct artifact *artifact)
{
 struct player_history *h = &p->hist;
 size_t i = h->next;
 assert(artifact);
 while (i--) {
  if (hist_has(h->entries[i].type, HIST_ARTIFACT_KNOWN) &&
    h->entries[i].a_idx == artifact->aidx)
   return true;
 }
 return false;
}
/**
 * Mark artifact as known.
 */
static bool history_mark_artifact_known(struct player_history *h,
  const struct artifact *artifact)
{
 assert(artifact);
 size_t i = h->next;
 while (i--) {
  if (h->entries[i].a_idx == artifact->aidx) {
   hist_off(h->entries[i].type, HIST_ARTIFACT_UNKNOWN);
   hist_on(h->entries[i].type, HIST_ARTIFACT_KNOWN);
   return true;
  }
 }
 return false;
}
/**
 * Mark artifact as lost.
 */
static bool history_mark_artifact_lost(struct player_history *h,
  const struct artifact *artifact)
{
 assert(artifact);
 size_t i = h->next;
 while (i--) {
  if (h->entries[i].a_idx == artifact->aidx) {
   hist_on(h->entries[i].type, HIST_ARTIFACT_LOST);
   return true;
  }
 }
 return false;
}
/**
 * Utility function for history_add_artifact(): get artifact name
 */
static void get_artifact_name(char *buf, size_t len, const struct artifact *artifact)
{
 struct object body = OBJECT_NULL;
 struct object known_body = OBJECT_NULL;
 struct object *fake = &body;
 struct object *known_obj = &known_body;
 /* Make fake artifact for description purposes */
 make_fake_artifact(fake, artifact);
 fake->known = known_obj;
 object_copy(known_obj, fake);
 object_desc(buf, len, fake, ODESC_PREFIX | ODESC_BASE | ODESC_SPOIL,
  NULL);
 object_wipe(known_obj);
 object_wipe(fake);
}
/**
 * Add an artifact to the history log.
 *
 * Call this to add an artifact to the history list or make the history
 * entry visible.
 */
void history_find_artifact(struct player *p, const struct artifact *artifact)
{
 assert(artifact != NULL);
 /* Try revealing any existing artifact, otherwise log it */
 if (!history_mark_artifact_known(&p->hist, artifact)) {
  char o_name[80];
  char text[80];
  get_artifact_name(o_name, sizeof(o_name), artifact);
  strnfmt(text, sizeof(text), "Found %s", o_name);
  bitflag flags[HIST_SIZE];
  hist_wipe(flags);
  hist_on(flags, HIST_ARTIFACT_KNOWN);
  history_add_with_flags(p, text, flags, artifact);
 }
}
/**
 * Mark artifact number `id` as lost forever.
 */
void history_lose_artifact(struct player *p, const struct artifact *artifact)
{
 assert(artifact != NULL);
 /* Try to mark it as lost if it's already in history */
 if (!history_mark_artifact_lost(&p->hist, artifact)) {
  /* Otherwise add a new entry */
  char o_name[80];
  char text[80];
  get_artifact_name(o_name, sizeof(o_name), artifact);
  strnfmt(text, sizeof(text), "Missed %s", o_name);
  bitflag flags[HIST_SIZE];
  hist_wipe(flags);
  hist_on(flags, HIST_ARTIFACT_UNKNOWN);
  hist_on(flags, HIST_ARTIFACT_LOST);
  history_add_with_flags(p, text, flags, artifact);
 }
}
/**
 * Convert all ARTIFACT_UNKNOWN history items to HIST_ARTIFACT_KNOWN.
 * Use only after player retirement/death for the final character dump.
 */
void history_unmask_unknown(struct player *p)
{
 struct player_history *h = &p->hist;
 size_t i = h->next;
 while (i--) {
  if (hist_has(h->entries[i].type, HIST_ARTIFACT_UNKNOWN)) {
   hist_off(h->entries[i].type, HIST_ARTIFACT_UNKNOWN);
   hist_on(h->entries[i].type, HIST_ARTIFACT_KNOWN);
  }
 }
}
/**
 * Present a copy of the history fot UI use
 */
size_t history_get_list(struct player *p, struct history_info **list)
{
 struct player_history *h = &p->hist;
 *list = h->entries;
 return h->next;
}
/**
 * \file player-path.c
 * \brief Pathfinding and running code.
 *
 * Copyright (c) 1988 Christopher J Stuart (running code)
 * Copyright (c) 2004-2007 Christophe Cavalaria, Leon Marrick (pathfinding)
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * ------------------------------------------------------------------------
 * Pathfinding code
 * ------------------------------------------------------------------------ */
/**
 * Maximum size around the player to consider in the pathfinder
 */
/**
 * Maximum distance to consider in the pathfinder
 */
/**
 * Bounds of the search rectangle
 */
static struct loc top_left, bottom_right;
/**
 * Array of distances from the player
 */
static int path_distance[100][100];
/**
 * Pathfinding results
 */
static int path_step_dir[500];
static int path_step_idx;
/**
 * Determine whether a grid is OK for the pathfinder to check
 */
static bool is_valid_pf(struct player *p, struct loc grid)
{
 /* Unvisited means allowed */
 if (!square_isknown(p->cave, grid)) return true;
 /* No trapped squares */
 if (square_isvisibletrap(p->cave, grid)) {
  return false;
 }
 /* All remaining passable terrain is okay. */
 if (square_ispassable(p->cave, grid)) {
  return true;
 }
 /* Some impassable terrain can be traversed fairly easily by modifying
	 * the terrain so allow those kinds. */
 if (square_iscloseddoor(p->cave, grid) || square_isrubble(p->cave, grid)) {
  return true;
 }
 /* Reject all other impassable terrain. */
 return false;
}
/**
 * Get pathfinding region
 */
static void get_pathfind_region(void)
{
 top_left.x = MAX(player->grid.x - 100 / 2, 0);
 top_left.y = MAX(player->grid.y - 100 / 2, 0);
 bottom_right.x = MIN(player->grid.x + 100 / 2 - 1, cave->width);
 bottom_right.y = MIN(player->grid.y + 100 / 2 - 1, cave->height);
}
/**
 * Get the path distance info for a grid
 */
static int path_dist(struct loc grid)
{
 return path_distance[grid.y - top_left.y][grid.x - top_left.x];
}
/**
 * Set the path distance info for a grid
 */
static void set_path_dist(struct loc grid, int dist)
{
 assert(grid.y >= top_left.y);
 assert(grid.x >= top_left.x);
 assert(grid.y < bottom_right.y);
 assert(grid.x < bottom_right.x);
 path_distance[grid.y - top_left.y][grid.x - top_left.x] = dist;
}
/**
 * Initialize terrain information
 */
static void path_dist_info_init(void)
{
 struct loc grid;
 /* Set distance of all grids in the region to -1 */
 for (grid.y = 0; grid.y < 100; grid.y++)
  for (grid.x = 0; grid.x < 100; grid.x++)
   path_distance[grid.y][grid.x] = -1;
 /* Set distance of valid grids to MAX_PF_LENGTH */
 for (grid.y = top_left.y; grid.y < bottom_right.y; grid.y++)
  for (grid.x = top_left.x; grid.x < bottom_right.x; grid.x++)
   if (is_valid_pf(player, grid))
    set_path_dist(grid, 500);
 /* Set distance of the player's grid to 0 */
 set_path_dist(player->grid, 0);
}
/**
 * Try to find a path from the player's grid
 * \param grid the target grid
 */
static bool set_up_path_distances(struct loc grid)
{
 int i;
 struct point_set *reached;
 /* Initialize the pathfinding region */
 get_pathfind_region();
 path_dist_info_init();
 /* Check bounds */
 if ((grid.x >= top_left.x) && (grid.x < bottom_right.x) &&
  (grid.y >= top_left.y) && (grid.y < bottom_right.y)) {
  if ((square(cave, grid)->mon > 0) &&
   monster_is_visible(square_monster(cave, grid))) {
   set_path_dist(grid, 500);
  }
 } else {
  bell();
  return false;
 }
 /* Add the player's grid to the set of marked grids */
 reached = point_set_new(100 * 100);
 add_to_point_set(reached, player->grid);
 /* Add the neighbours of any marked grid in the area */
 for (i = 0; i < reached->n; i++) {
  int k, cur_distance = path_dist(reached->pts[i]) + 1;
  for (k = 0; k < 8; k++) {
   struct loc next = loc_sum(reached->pts[i], ddgrid_ddd[k]);
   /* Enforce length and area bounds */
   if ((next.y < top_left.y) ||
    (next.y >= bottom_right.y) ||
    (next.x < top_left.x) ||
    (next.x >= bottom_right.x) ||
    (path_dist(next) <= cur_distance) ||
    (path_dist(next) > 500)) {
    continue;
   }
   /* Add the grid */
   set_path_dist(next, cur_distance);
   add_to_point_set(reached, next);
  }
 }
 /* Grid distances have been recorded, so we can get rid of the point set */
 point_set_dispose(reached);
 /* Failure to find a path */
 if (path_dist(grid) == -1 || path_dist(grid) == 500) {
  bell();
  return false;
 }
 /* Found a path */
 return true;
}
/**
 * Fill the array of path step directions
 * \param grid the target grid
 */
bool find_path(struct loc grid)
{
 struct loc new = grid;
 /* Attempt to find a path if necessary */
 if (loc_eq(new, player->grid)) return false;
 if (!set_up_path_distances(grid)) return false;
 /* Now travel along the path, backwards */
 path_step_idx = 0;
 while (!loc_eq(new, player->grid)) {
  int k, next_distance = path_dist(new) - 1;
  /* Find the next step */
  for (k = 0; k < 8; k++) {
   struct loc next = loc_sum(new, ddgrid_ddd[k]);
   if (next.y < top_left.y || next.y >= bottom_right.y
     || next.x < top_left.x
     || next.x >= bottom_right.x) {
    continue;
   }
   if (path_dist(next) == next_distance)
    break;
  }
  /* Check we haven't exceeded path length */
  if (path_step_idx >= 500) return false;
  /* Record the opposite of the backward direction */
  path_step_dir[path_step_idx++] = 10 - ddd[k];
  new = loc_sum(new, ddgrid_ddd[k]);
 }
 /* Reduce to the actual number of steps */
 path_step_idx--;
 assert(path_step_idx >= 0);
 return true;
}
/**
 * Compute the direction (in the angband 123456789 sense) from a point to a
 * point. We decide to use diagonals if dx and dy are within a factor of two of
 * each other; otherwise we choose a cardinal direction.
 */
int pathfind_direction_to(struct loc from, struct loc to)
{
 int adx = ABS(to.x - from.x);
 int ady = ABS(to.y - from.y);
 int dx = to.x - from.x;
 int dy = to.y - from.y;
 if (dx == 0 && dy == 0)
  return DIR_NONE;
 if (dx >= 0 && dy >= 0) {
  if (adx < ady * 2 && ady < adx * 2) return DIR_SE;
  else if (adx > ady) return DIR_E;
  else return DIR_S;
 } else if (dx > 0 && dy < 0) {
  if (adx < ady * 2 && ady < adx * 2) return DIR_NE;
  else if (adx > ady) return DIR_E;
  else return DIR_N;
 } else if (dx < 0 && dy > 0) {
  if (adx < ady * 2 && ady < adx * 2) return DIR_SW;
  else if (adx > ady) return DIR_W;
  else return DIR_S;
 } else if (dx <= 0 && dy <= 0) {
  if (adx < ady * 2 && ady < adx * 2) return DIR_NW;
  else if (adx > ady) return DIR_W;
  else return DIR_N;
 }
 assert(0);
 return DIR_UNKNOWN;
}
/**
 * ------------------------------------------------------------------------
 * Running code
 * ------------------------------------------------------------------------ */
/**
 * Basically, once you start running, you keep moving until something
 * interesting happens.  In an enclosed space, you run straight, but
 * you follow corners as needed (i.e. hallways).  In an open space,
 * you run straight, but you stop before entering an enclosed space
 * (i.e. a room with a doorway).  In a semi-open space (with walls on
 * one side only), you run straight, but you stop before entering an
 * enclosed space or an open space (i.e. running along side a wall).
 *
 * All discussions below refer to what the player can see, that is,
 * an unknown wall is just like a normal floor.  This means that we
 * must be careful when dealing with "illegal" grids.
 *
 * No assumptions are made about the layout of the dungeon, so this
 * algorithm works in hallways, rooms, town, destroyed areas, etc.
 *
 * In the diagrams below, the player has just arrived in the grid
 * marked as '@', and he has just come from a grid marked as 'o',
 * and he is about to enter the grid marked as 'x'.
 *
 * Running while confused is not allowed, and so running into a wall
 * is only possible when the wall is not seen by the player.  This
 * will take a turn and stop the running.
 *
 * Several conditions are tracked by the running variables.
 *
 *   run_open_area (in the open on at least one side)
 *   run_break_left (wall on the left, stop if it opens)
 *   run_break_right (wall on the right, stop if it opens)
 *
 * When running begins, these conditions are initialized by examining
 * the grids adjacent to the requested destination grid (marked 'x'),
 * two on each side (marked 'L' and 'R').  If either one of the two
 * grids on a given side is a wall, then that side is considered to
 * be "closed".  Both sides enclosed yields a hallway.
 *
 *    LL                     @L
 *    @x      (normal)       RxL   (diagonal)
 *    RR      (east)          R    (south-east)
 *
 * In the diagram below, in which the player is running east along a
 * hallway, he will stop as indicated before attempting to enter the
 * intersection (marked 'x').  Starting a new run in any direction
 * will begin a new hallway run.
 *
 * #.#
 * ##.##
 * o@x..
 * ##.##
 * #.#
 *
 * Note that a minor hack is inserted to make the angled corridor
 * entry (with one side blocked near and the other side blocked
 * further away from the runner) work correctly. The runner moves
 * diagonally, but then saves the previous direction as being
 * straight into the gap. Otherwise, the tail end of the other
 * entry would be perceived as an alternative on the next move.
 *
 * In the diagram below, the player is running east down a hallway,
 * and will stop in the grid (marked '1') before the intersection.
 * Continuing the run to the south-east would result in a long run
 * stopping at the end of the hallway (marked '2').
 *
 * ##################
 * o@x       1
 * ########### ######
 * #2          #
 * #############
 *
 * After each step, the surroundings are examined to determine if
 * the running should stop, and to determine if the running should
 * change direction.  We examine the new current player location
 * (at which the runner has just arrived) and the direction from
 * which the runner is considered to have come.
 *
 * Moving one grid in some direction places you adjacent to three
 * or five new grids (for straight and diagonal moves respectively)
 * to which you were not previously adjacent (marked as '!').
 *
 *   ...!              ...
 *   .o@!  (normal)    .o.!  (diagonal)
 *   ...!  (east)      ..@!  (south east)
 *                      !!!
 *
 * If any of the newly adjacent grids are "interesting" (monsters,
 * objects, some terrain features) then running stops.
 *
 * If any of the newly adjacent grids seem to be open, and you are
 * looking for a break on that side, then running stops.
 *
 * If any of the newly adjacent grids do not seem to be open, and
 * you are in an open area, and the non-open side was previously
 * entirely open, then running stops.
 *
 * If you are in a hallway, then the algorithm must determine if
 * the running should continue, turn, or stop.  If only one of the
 * newly adjacent grids appears to be open, then running continues
 * in that direction, turning if necessary.  If there are more than
 * two possible choices, then running stops.  If there are exactly
 * two possible choices, separated by a grid which does not seem
 * to be open, then running stops.  Otherwise, as shown below, the
 * player has probably reached a "corner".
 *
 *    ###             o##
 *    o@x  (normal)   #@!   (diagonal)
 *    ##!  (east)     ##x   (south east)
 *
 * In this situation, there will be two newly adjacent open grids,
 * one touching the player on a diagonal, and one directly adjacent.
 * We must consider the two "option" grids further out (marked '?').
 * We assign "option" to the straight-on grid, and "option2" to the
 * diagonal grid.
 *
 *    ###s
 *    o@x?   (may be incorrect diagram!)
 *    ##!?
 *
 * If both "option" grids are closed, then there is no reason to enter
 * the corner, and so we can cut the corner, by moving into the other
 * grid (diagonally).  If we choose not to cut the corner, then we may
 * go straight, but we pretend that we got there by moving diagonally.
 * Below, we avoid the obvious grid (marked 'x') and cut the corner
 * instead (marked 'n').
 *
 *    ###:               o##
 *    o@x#   (normal)    #@n    (maybe?)
 *    ##n#   (east)      ##x#
 *                       ####
 *
 * If one of the "option" grids is open, then we may have a choice, so
 * we check to see whether it is a potential corner or an intersection
 * (or room entrance).  If the grid two spaces straight ahead, and the
 * space marked with 's' are both open, then it is a potential corner
 * and we enter it if requested.  Otherwise, we stop, because it is
 * not a corner, and is instead an intersection or a room entrance.
 *
 *    ###
 *    o@x
 *    ##!#
 *
 * I do not think this documentation is correct.
 */
static int run_cur_dir; /* Direction we are running */
static int run_old_dir; /* Direction we came from */
static bool run_open_area; /* Looking for an open area */
static bool run_break_right; /* Looking for a break (right) */
static bool run_break_left; /* Looking for a break (left) */
/**
 * Hack -- Check for a "known wall" (see below)
 */
static bool see_wall(int dir, struct loc grid)
{
 /* Get the new location */
 grid = loc_sum(grid, ddgrid[dir]);
 /* Illegal grids are not known walls XXX XXX XXX */
 if (!square_in_bounds(cave, grid)) return false;
 /* Webs are enough like walls */
 if (square_iswebbed(cave, grid)) return true;
 /* Non-wall grids are not known walls */
 if (!square_seemslikewall(cave, grid)) return false;
 /* Unknown walls are not known walls */
 if (!square_isknown(cave, grid)) return false;
 /* Default */
 return true;
}
/**
 * Initialize the running algorithm for a new direction.
 *
 * Diagonal Corridor -- allow diaginal entry into corridors.
 *
 * Blunt Corridor -- If there is a wall two spaces ahead and
 * we seem to be in a corridor, then force a turn into the side
 * corridor, must be moving straight into a corridor here. (?)
 *
 * Diagonal Corridor    Blunt Corridor (?)
 *       # #                  #
 *       #x#                 @x#
 *       @p.                  p
 */
static void run_init(int dir)
{
 int i;
 struct loc grid;
 bool deepleft, deepright;
 bool shortleft, shortright;
 /* Mark that we're starting a run */
 player->upkeep->running_firststep = true;
 /* Save the direction */
 run_cur_dir = dir;
 /* Assume running straight */
 run_old_dir = dir;
 /* Assume looking for open area */
 run_open_area = true;
 /* Assume not looking for breaks */
 run_break_right = false;
 run_break_left = false;
 /* Assume no nearby walls */
 deepleft = deepright = false;
 shortright = shortleft = false;
 /* Find the destination grid */
 grid = loc_sum(player->grid, ddgrid[dir]);
 /* Extract cycle index */
 i = chome[dir];
 /* Check for nearby or distant wall */
 if (see_wall(cycle[i + 1], player->grid)) {
  /* Wall diagonally left of player's current grid */
  run_break_left = true;
  shortleft = true;
 } else if (see_wall(cycle[i + 1], grid)) {
  /* Wall diagonally left of the grid the player is stepping to */
  run_break_left = true;
  deepleft = true;
 }
 /* Check for nearby or distant wall */
 if (see_wall(cycle[i - 1], player->grid)) {
  /* Wall diagonally right of player's current grid */
  run_break_right = true;
  shortright = true;
 } else if (see_wall(cycle[i - 1], grid)) {
  /* Wall diagonally right of the grid the player is stepping to */
  run_break_right = true;
  deepright = true;
 }
 /* Looking for a break */
 if (run_break_left && run_break_right) {
  /* Not looking for open area */
  run_open_area = false;
  /* Check angled or blunt corridor entry for diagonal directions */
  if (dir & 0x01) {
   if (deepleft && !deepright)
    run_old_dir = cycle[i - 1];
   else if (deepright && !deepleft)
    run_old_dir = cycle[i + 1];
  } else if (see_wall(cycle[i], player->grid)) {
   if (shortleft && !shortright)
    run_old_dir = cycle[i - 2];
   else if (shortright && !shortleft)
    run_old_dir = cycle[i + 2];
  }
 }
}
/**
 * Update the current "run" path
 *
 * Return true if the running should be stopped
 */
static bool run_test(const struct player *p)
{
 int prev_dir;
 int new_dir;
 struct loc grid;
 int i, max, inv;
 int option, option2;
 /* No options yet */
 option = 0;
 option2 = 0;
 /* Where we came from */
 prev_dir = run_old_dir;
 /* Range of newly adjacent grids - 5 for diagonals, 3 for cardinals */
 max = (prev_dir & 0x01) + 1;
 /* Look at every newly adjacent square. */
 for (i = -max; i <= max; i++) {
  struct object *obj;
  /* New direction */
  new_dir = cycle[chome[prev_dir] + i];
  /* New location */
  grid = loc_sum(p->grid, ddgrid[new_dir]);
  /* Visible monsters abort running */
  if (square(cave, grid)->mon > 0) {
   struct monster *mon = square_monster(cave, grid);
   if (monster_is_visible(mon)) {
    return true;
   }
  }
  /* Visible traps abort running */
  if (square_isvisibletrap(cave, grid)) {
   return true;
  }
  /* Visible objects abort running */
  for (obj = square_object(cave, grid); obj; obj = obj->next)
   /* Visible object */
   if (obj->known && !ignore_item_ok(p, obj)) return true;
  /* Assume unknown */
  inv = true;
  /* Check memorized grids */
  if (square_isknown(cave, grid)) {
   bool notice = square_isinteresting(p->cave, grid);
   /* Interesting feature */
   if (notice) return true;
   /* The grid is "visible" */
   inv = false;
  }
  /* Analyze unknown grids and floors */
  if (inv || square_ispassable(cave, grid)) {
   /* Looking for open area */
   if (run_open_area) {
    /* Nothing */
   } else if (!option) {
    /* The first new direction. */
    option = new_dir;
   } else if (option2) {
    /* Three new directions. Stop running. */
    return true;
   } else if (option != cycle[chome[prev_dir] + i - 1]) {
    /* Two non-adjacent new directions.  Stop running. */
    return true;
   } else if (new_dir & 0x01) {
    /* Two new (adjacent) directions (case 1) */
    option2 = new_dir;
   } else {
    /* Two new (adjacent) directions (case 2) */
    option2 = option;
    option = new_dir;
   }
  } else { /* Obstacle, while looking for open area */
   if (run_open_area) {
    if (i < 0) {
     /* Break to the right */
     run_break_right = true;
    } else if (i > 0) {
     /* Break to the left */
     run_break_left = true;
    }
   }
  }
 }
 /* Look at every soon to be newly adjacent square. */
 for (i = -max; i <= max; i++) {
  /* New direction */
  new_dir = cycle[chome[prev_dir] + i];
  /* New location */
  grid = loc_sum(p->grid,
        loc_sum(ddgrid[prev_dir], ddgrid[new_dir]));
  /* HACK: Ugh. Sometimes we come up with illegal bounds. This will
		 * treat the symptom but not the disease. */
  if (!square_in_bounds(cave, grid)) continue;
  /* Obvious monsters abort running */
  if (square(cave, grid)->mon > 0) {
   struct monster *mon = square_monster(cave, grid);
   if (monster_is_visible(mon))
    return true;
  }
 }
 /* Looking for open area */
 if (run_open_area) {
  /* Hack -- look again */
  for (i = -max; i < 0; i++) {
   new_dir = cycle[chome[prev_dir] + i];
   grid = loc_sum(p->grid, ddgrid[new_dir]);
   /* Unknown grid or non-wall */
   if (!square_isknown(cave, grid) || square_ispassable(cave, grid)) {
    /* Looking to break right */
    if (run_break_right) {
     return true;
    }
   } else { /* Obstacle */
    /* Looking to break left */
    if (run_break_left) {
     return true;
    }
   }
  }
  /* Hack -- look again */
  for (i = max; i > 0; i--) {
   new_dir = cycle[chome[prev_dir] + i];
   grid = loc_sum(p->grid, ddgrid[new_dir]);
   /* Unknown grid or non-wall */
   if (!square_isknown(cave, grid) || square_ispassable(cave, grid)) {
    /* Looking to break left */
    if (run_break_left) {
     return true;
    }
   } else { /* Obstacle */
    /* Looking to break right */
    if (run_break_right) {
     return true;
    }
   }
  }
 } else { /* Not looking for open area */
  /* No options */
  if (!option) {
   return true;
  } else if (!option2) { /* One option */
   /* Primary option */
   run_cur_dir = option;
   /* No other options */
   run_old_dir = option;
  } else { /* Two options, examining corners */
   /* Primary option */
   run_cur_dir = option;
   /* Hack -- allow curving */
   run_old_dir = option2;
  }
 }
 /* About to hit a known wall, stop */
  if (see_wall(run_cur_dir, p->grid))
  return true;
 /* Failure */
 return false;
}
/**
 * Take one step along the current "run" path
 *
 * Called with a real direction to begin a new run, and with zero
 * to continue a run in progress.
 */
void run_step(int dir)
{
 bool disarm = true;
 /* Start or continue run */
 if (dir) {
  /* Initialize */
  run_init(dir);
  /* Hack -- Set the run counter if no count given */
  if (player->upkeep->running == 0)
   player->upkeep->running = 9999;
  /* Calculate torch radius */
  player->upkeep->update |= (PU_TORCH);
 } else {
  /* Continue running */
  if (!player->upkeep->running_withpathfind) {
   /* Update regular running */
   if (run_test(player)) {
    /* Disturb */
    disturb(player, false);
    return;
   }
  } else if (path_step_idx < 0) {
   /* Pathfinding, and the path is finished */
   disturb(player, false);
   player->upkeep->running_withpathfind = false;
   return;
  } else {
   struct loc grid = loc_sum(player->grid,
           ddgrid[path_step_dir[path_step_idx]]);
   if (path_step_idx == 0) {
    /* Known wall */
    if (square_isknown(cave, grid) &&
     !square_ispassable(cave, grid)) {
     disturb(player, false);
     player->upkeep->running_withpathfind = false;
     return;
    }
   } else if (path_step_idx > 0) {
    struct object *obj;
    /* If the player has computed a path that is going to end up
				 * in a wall, we notice this and convert to a normal run. This
				 * allows us to click on unknown areas to explore the map.
				 *
				 * We have to look ahead two, otherwise we don't know which is
				 * the last direction moved and don't initialise the run
				 * properly. */
    grid = loc_sum(player->grid,
          ddgrid[path_step_dir[path_step_idx]]);
    /* Known wall */
    if (square_isknown(cave, grid) &&
     !square_ispassable(player->cave, grid)) {
     disturb(player, false);
     player->upkeep->running_withpathfind = false;
     return;
    }
    /* Visible monsters abort running */
    if (square(cave, grid)->mon > 0) {
     struct monster *mon = square_monster(cave, grid);
     /* Visible monster */
     if (monster_is_visible(mon)) {
      disturb(player, false);
      player->upkeep->running_withpathfind = false;
      return;
     }
    }
    /* Visible objects abort running */
    for (obj = square_object(player->cave, grid); obj;
      obj = obj->next) {
     /* Visible object */
     if (obj->known && !ignore_item_ok(player, obj)) {
      disturb(player, false);
      player->upkeep->running_withpathfind = false;
      return;
     }
    }
    /* Get step after */
    grid = loc_sum(grid, ddgrid[path_step_dir[path_step_idx - 1]]);
    /* Known wall, so run the direction we were going */
    if (square_isknown(cave, grid) &&
     !square_ispassable(cave, grid)) {
     player->upkeep->running_withpathfind = false;
     run_init(path_step_dir[path_step_idx]);
    }
   }
   /* Now actually run the step if we're still going */
   run_cur_dir = path_step_dir[path_step_idx--];
  }
 }
 /* Take time */
 player->upkeep->energy_use = z_info->move_energy;
 /* Move the player; running straight into a trap == trying to disarm */
 move_player(run_cur_dir, dir && disarm ? true : false);
 /* Check if the player is escaping */
 if (!square_in_bounds_fully(cave, player->grid)) {
  /* Deal with leaving the map */
  do_cmd_escape();
  return;
 }
 /* Decrease counter if it hasn't been cancelled */
 /* occurs after movement so that using p->u->running as flag works */
 if (player->upkeep->running) {
  player->upkeep->running--;
 } else if (!player->upkeep->running_withpathfind)
  return;
 /* Prepare the next step */
 if (player->upkeep->running) {
  cmdq_push(CMD_RUN);
  if (player->upkeep->running_withpathfind) {
   /* Running is a side effect of pathfinding. */
   cmdq_peek()->is_background_command = true;
  }
  cmd_set_arg_direction(cmdq_peek(), "direction", 0);
 }
}
/**
 * \file player-quest.c
 * \brief All throne room-related code
 *
 * Copyright (c) 2013 Angband developers
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Makes Morgoth drop his Iron Crown with an appropriate message.
 */
void drop_iron_crown(struct monster *mon, const char *message)
{
 int i;
 struct loc grid;
 struct monster_race *race = mon->race;
 const struct artifact *crown = lookup_artifact_name("of Morgoth");
 bool note;
 if (!is_artifact_created(crown)) {
  struct object *obj;
  struct object_kind *kind;
  msg(message);
  /* Choose a nearby location, but not his own square */
  find_nearby_grid(cave, &grid, mon->grid, 1, 1);
  for (i = 0; i < 1000; i++) {
   find_nearby_grid(cave, &grid, mon->grid, 1, 1);
   if (!loc_eq(grid, mon->grid) && square_isfloor(cave, grid)) break;
  }
  /* Allocate by hand, prep, apply magic */
  obj = mem_zalloc(sizeof(*obj));
  kind = lookup_kind(crown->tval, crown->sval);
  object_prep(obj, kind, z_info->dun_depth, RANDOMISE);
  obj->artifact = crown;
  copy_artifact_data(obj, obj->artifact);
  mark_artifact_created(crown, true);
  /* Set origin details */
  obj->origin = ORIGIN_DROP;
  obj->origin_depth = convert_depth_to_origin(cave->depth);
  obj->origin_race = race;
  obj->number = 1;
  /* Drop it there */
  floor_carry(cave, grid, obj, &note);
  /* Lower Morgoth's protection, remove his light source, increase his
		 * will and perception */
  race->pd -= 1;
  race->light = 0;
  race->wil += 5;
  race->per += 5;
 }
}
/**
 * Shatter the player's wielded weapon.
 */
void shatter_weapon(struct player *p, int silnum)
{
 int i;
 struct object *weapon = equipped_item_by_slot_name(p, "weapon");
 struct object *destroyed;
 char w_name[80];
 bool dummy = false;
 p->crown_shatter = true;
 /* Get the basic name of the object */
 object_desc(w_name, sizeof(w_name), weapon, false, 0);
 if (silnum == 2) {
  msg("You strive to free a second Silmaril, but it is not fated to be.");
 } else {
  msg("You strive to free a third Silmaril, but it is not fated to be.");
 }
 msg("As you strike the crown, your %s shatters into innumerable pieces.",
  w_name);
 /* Make more noise */
 p->stealth_score -= 5;
 destroyed = gear_object_for_use(player, weapon, 1, false, &dummy);
 object_delete(p->cave, NULL, &destroyed->known);
 object_delete(cave, p->cave, &destroyed);
 /* Process monsters */
 for (i = 1; i < cave_monster_max(cave); i++) {
  struct monster *mon = cave_monster(cave, i);
  /* If Morgoth, then anger him */
  if (rf_has(mon->race->flags, RF_QUESTOR)) {
   if ((mon->cdis <= 5) && los(cave, p->grid, mon->grid)) {
    msg("A shard strikes Morgoth upon his cheek.");
    set_alertness(mon, ALERTNESS_VERY_ALERT);
   }
  }
 }
}
/**
 * Break the truce in Morgoth's throne room
 */
void break_truce(struct player *p, bool obvious)
{
 int i;
 struct monster *mon = NULL;
 char m_name[80];
 if (p->truce) {
  /* Scan all other monsters */
  for (i = cave_monster_max(cave) - 1; i >= 1; i--) {
   /* Access the monster */
   mon = cave_monster(cave, i);
   /* Ignore dead monsters */
   if (!mon->race) continue;
   /* Ignore monsters out of line of sight */
   if (!los(cave, mon->grid, p->grid)) continue;
   /* Ignore unalert monsters */
   if (mon->alertness < ALERTNESS_ALERT) continue;
   /* Get the monster name (using 'something' for hidden creatures) */
   monster_desc(m_name, sizeof(m_name), mon, MDESC_STANDARD);
   p->truce = false;
  }
  if (obvious) p->truce = false;
  if (!p->truce) {
   if (!obvious) {
    msg("%s lets out a cry! The tension is broken.", m_name);
    /* Make a lot of noise */
    cave->monster_noise.centre = mon->grid;
    update_flow(cave, &cave->monster_noise, NULL);
    monsters_hear(false, false, -10);
   } else {
    msg("The tension is broken.");
   }
   /* Scan all other monsters */
   for (i = cave_monster_max(cave) - 1; i >= 1; i--) {
    /* Access the monster */
    mon = cave_monster(cave, i);
    /* Ignore dead monsters */
    if (!mon->race) continue;
    /* Mark minimum desired range for recalculation */
    mon->min_range = 0;
   }
  }
 }
}
/**
 * Check whether to break the truce in Morgoth's throne room
 */
void check_truce(struct player *p)
{
 int d;
 /* Check around the character */
 for (d = 0; d < 8; d++) {
  struct loc grid = loc_sum(p->grid, ddgrid_ddd[d]);
  struct monster *mon = square_monster(cave, grid);
  if (mon && (mon->race == lookup_monster("Morgoth, Lord of Darkness"))
   && (mon->alertness >= ALERTNESS_ALERT)) {
   msg("With a voice as of rolling thunder, Morgoth, Lord of Darkness, speaks:");
   msg("'You dare challenge me in mine own hall? Now is your death upon you!'");
   /* Break the truce (always) */
   break_truce(p, true);
   return;
  }
 }
}
/**
 * Wake up all monsters, and speed up "los" monsters.
 */
void wake_all_monsters(struct player *p)
{
 int i;
 /* Aggravate everyone */
 for (i = 1; i < cave_monster_max(cave); i++) {
  struct monster *mon = cave_monster(cave, i);
  /* Paranoia -- Skip dead monsters */
  if (!mon->race) continue;
  /* Alert it */
  set_alertness(mon, MAX(mon->alertness, ALERTNESS_VERY_ALERT));
  /* Possibly update the monster health bar*/
  if (p->upkeep->health_who == mon) p->upkeep->redraw |= (PR_HEALTH);
 }
}
void prise_silmaril(struct player *p)
{
 struct object *obj, *weapon;
 const char *freed_msg = NULL;
 bool freed = false;
 int net_dam = 0;
 int hit_result = 0;
 int pd = 0;
 int noise = 0;
 int mds = p->state.mds;
 int attack_mod = p->state.skill_use[SKILL_MELEE];
 struct monster_race *race = lookup_monster("Morgoth, Lord of Darkness");
 /* The Crown is on the ground */
 obj = square_object(cave, p->grid);
 switch (obj->pval) {
  case 3: {
   pd = 15;
   noise = 5;
   freed_msg = "You have freed a Silmaril!";
   break;
  }
  case 2: {
   pd = 25;
   noise = 10;
   if (p->crown_shatter) {
    freed_msg = "The fates be damned! You free a second Silmaril.";
   } else {
    freed_msg = "You free a second Silmaril.";
   }
   break;
  }
  case 1: {
   pd = 30;
   noise = 15;
   freed_msg = "You free the final Silmaril. You have a very bad feeling about this.";
   msg("Looking into the hallowed light of the final Silmaril, you are filled with a strange dread.");
   if (!get_check("Are you sure you wish to proceed? ")) return;
   break;
  }
 }
 /* Get the weapon */
 weapon = equipped_item_by_slot_name(p, "weapon");
 /* Undo rapid attack penalties */
 if (player_active_ability(p, "Rapid Attack")) {
  /* Undo strength adjustment to the attack */
  mds = total_mds(p, &p->state, weapon, 0);
  /* Undo the dexterity adjustment to the attack */
  attack_mod += 3;
 }
 /* Test for hit */
 hit_result = hit_roll(attack_mod, 0, source_player(), source_none(), true);
 /* Make some noise */
 p->stealth_score -= noise;
 /* Determine damage */
 if (hit_result > 0) {
  int dummy;
  int crit_bonus_dice = crit_bonus(p, hit_result, weapon->weight, race,
           SKILL_MELEE, false);
  int dam = damroll(p->state.mdd + crit_bonus_dice, mds);
  int prt = damroll(pd, 4);
  int prt_percent = prt_after_sharpness(p, weapon, &dummy);
  prt = (prt * prt_percent) / 100;
  net_dam = MAX(dam - prt, 0);
  event_signal_combat_damage(EVENT_COMBAT_DAMAGE,
           p->state.mdd + crit_bonus_dice, mds, dam,
           pd, 4, prt, prt_percent, PROJ_HURT, true);
 }
 /* If you succeed in prising out a Silmaril... */
 if (net_dam > 0) {
  freed = true;
  switch (obj->pval) {
   case 3: {
    break;
   }
   case 2: {
    if (!p->crown_shatter && one_in_(2)) {
     shatter_weapon(p, 2);
     freed = false;
    }
    break;
   }
   case 1: {
    if (!p->crown_shatter) {
     shatter_weapon(p, 3);
     freed = false;
    } else {
     p->cursed = true;
    }
    break;
   }
  }
  if (freed) {
   struct object *sil = object_new();
   struct object_kind *kind = lookup_kind(TV_LIGHT,
               lookup_sval(TV_LIGHT, "Silmaril"));
   /* Crown has one less silmaril */
   obj->pval--;
   /* Report success */
   msg(freed_msg);
   /* Make Silmaril */
   object_prep(sil, kind, z_info->dun_depth, RANDOMISE);
   /* Get it */
   inven_carry(p, sil, true, true);
   /* Break the truce (always) */
   break_truce(p, true);
   /* Add a note to the notes file */
   history_add(p, "Cut a Silmaril from Morgoth's crown.",
      HIST_SILMARIL);
  }
 } else {
  /* If you fail to prise out a Silmaril... */
  msg("Try though you might, you were unable to free a Silmaril.");
  msg("Perhaps you should try again or use a different weapon.");
  if (pd == 15) {
   msg("(The combat rolls window shows what is happening.)");
  }
  /* Break the truce if creatures see */
  break_truce(p, false);
 }
 /* Check for taking of final Silmaril */
 if ((pd == 30) && freed) {
  msg("Until you escape you must now roll twice for every skill check, taking the worse result each time.");
  msg("You hear a cry of veangance echo through the iron hells.");
  wake_all_monsters(p);
 }
}
/**
 * Counts the player's silmarils
 */
int silmarils_possessed(struct player *p)
{
 int silmarils = 0;
 struct object *obj;
 for (obj = p->gear; obj; obj = obj->next) {
  if (tval_is_light(obj) && of_has(obj->flags, OF_NO_FUEL) &&
   (obj->pval == 7)) {
   silmarils += obj->number;
  }
  if (obj->artifact && streq(obj->kind->name, "Massive Iron Crown")) {
   silmarils += obj->pval;
  }
 }
 return silmarils;
}
/**
 * \file player-skills.c
 * \brief Player skill allocation
 *
 * Copyright (c) 1997 - 2023 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
static int skills[SKILL_MAX];
static int old_skills[SKILL_MAX];
static int exp_spent[SKILL_MAX];
static int exp_inc[SKILL_MAX];
static int exp_left;
static int old_exp_left;
/**
 * Skill point costs.
 *
 * The nth skill point costs (100 * n) experience points
 */
static int skill_cost(int base, int points)
{
 int total_cost = (points + base) * (points + base + 1) / 2;
 int prev_cost = (base) * (base + 1) / 2;
 return ((total_cost - prev_cost) * 100);
}
static void recalculate_skills(void)
{
 int i;
 /* Variable skill maxes */
 for (i = 0; i < SKILL_MAX; i++) {
  player->skill_base[i] = skills[i];
 }
 player->new_exp = exp_left;
 /* Update bonuses etc. */
 player->upkeep->update |= (PU_BONUS);
 update_stuff(player);
 /* Tell the UI about all this stuff that's changed. */
 event_signal(EVENT_SKILLS);
 event_signal(EVENT_EXP_CHANGE);
}
/**
 * Set allocated skill points to zero.
 */
void init_skills(bool start, bool reset)
{
 int i;
 /* Calculate and signal initial skills, points and experience totals. */
 old_exp_left = exp_left = player->new_exp;
 for (i = 0; i < SKILL_MAX; i++) {
  /* Initial skills are the current values and costs are zero */
  old_skills[i] = start ? 0 : (reset ? player->skill_base[i] :
          skills[i] - player->skill_base[i]);
  skills[i] = start ? 0 : player->skill_base[i];
  exp_spent[i] = reset ? 0 : skill_cost(old_skills[i], skills[i] - old_skills[i]);
  exp_inc[i] = skill_cost(skills[i], 1);
 }
 /* Use the new base skill values to work out the skill values after
	 * modifiers) and tell the UI things have changed if necessary. */
 if (!start || reset) {
  recalculate_skills();
  event_signal_skillpoints(exp_spent, exp_inc, exp_left);
 }
}
/**
 * Set remembered skill points to what we've chosen.
 */
void finalise_skills(void)
{
 int i;
 for (i = 0; i < SKILL_MAX; i++) {
  old_skills[i] = skills[i];
 }
 old_exp_left = exp_left;
}
/**
 * Reset the allocated skill points for this buy to zero.
 */
static void reset_skills(void)
{
 int i;
 /* Calculate and signal initial skills, points and experience totals. */
 exp_left = old_exp_left;
 for (i = 0; i < SKILL_MAX; i++) {
  /* Initial skills are the current values and costs are zero */
  skills[i] = old_skills[i];
  exp_spent[i] = 0;
  exp_inc[i] = skill_cost(skills[i], 1);
 }
 /* Use the new base skill values to work out the skill values after
	 * modifiers) and tell the UI things have changed. */
 recalculate_skills();
 event_signal_skillpoints(exp_spent, exp_inc, exp_left);
}
static bool buy_skill(int choice)
{
 /* Must be a valid skill to be adjusted */
 if (!(choice >= SKILL_MAX || choice < 0)) {
  /* Get the cost of buying the extra point (beyond what
		   it has already cost to get this far). */
  int cost = skill_cost(skills[choice], 1);
  assert(cost == exp_inc[choice]);
  if (cost <= exp_left) {
   skills[choice]++;
   exp_spent[choice] += cost;
   exp_inc[choice] = skill_cost(skills[choice], 1);
   exp_left -= cost;
   /* Tell the UI the new points situation. */
   event_signal_skillpoints(exp_spent, exp_inc, exp_left);
   /* Recalculate everything that's changed because
			   the skill has changed, and inform the UI. */
   recalculate_skills();
   return true;
  }
 }
 /* Didn't adjust skill. */
 return false;
}
static bool sell_skill(int choice)
{
 /* Must be a valid skill, and we can't "sell" skills below current value. */
 if (!(choice >= SKILL_MAX || choice < 0) && (exp_spent[choice] > 0)) {
  int cost = skill_cost(skills[choice] - 1, 1);
  skills[choice]--;
  exp_spent[choice] -= cost;
  exp_inc[choice] = skill_cost(skills[choice], 1);
  exp_left += cost;
  /* Tell the UI the new points situation. */
  event_signal_skillpoints(exp_spent, exp_inc, exp_left);
  /* Recalculate everything that's changed because
		   the skill has changed, and inform the UI. */
  recalculate_skills();
  return true;
 }
 /* Didn't adjust skill. */
 return false;
}
void do_cmd_buy_skill(struct command *cmd)
{
 /* .choice is the skill to sell */
 int choice;
 cmd_get_arg_choice(cmd, "choice", &choice);
 buy_skill(choice);
}
void do_cmd_sell_skill(struct command *cmd)
{
 /* .choice is the skill to sell */
 int choice;
 cmd_get_arg_choice(cmd, "choice", &choice);
 sell_skill(choice);
}
void do_cmd_reset_skills(struct command *cmd)
{
 reset_skills();
}
void do_cmd_refresh_skills(struct command *cmd)
{
 event_signal_skillpoints(exp_spent, exp_inc, exp_left);
}
/**
 * \file player-timed.c
 * \brief Timed effects handling
 *
 * Copyright (c) 1997 Ben Harrison
 * Copyright (c) 2007 Andi Sidwell
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
int PY_FOOD_MAX;
int PY_FOOD_FULL;
int PY_FOOD_ALERT;
int PY_FOOD_WEAK;
int PY_FOOD_STARVE;
/**
 * ------------------------------------------------------------------------
 * Parsing functions for player_timed.txt
 * ------------------------------------------------------------------------ */
struct timed_effect_data timed_effects[TMD_MAX] = {
/**
 * \file list-player-timed.h
 * \brief timed player properties
 *
 * Fields:
 * symbol - the effect name
 * flag_redraw - the things to be redrawn when the effect is set
 * flag_update - the things to be updated when the effect is set
 */
/* symbol		flag_redraw						flag_update */
{ "FAST", PR_STATUS, PU_BONUS, 0, NULL, NULL, NULL, NULL, 0, 0, NULL, NULL, NULL, { 0 }, 0, false, false },
{ "SLOW", PR_STATUS, PU_BONUS, 0, NULL, NULL, NULL, NULL, 0, 0, NULL, NULL, NULL, { 0 }, 0, false, false },
{ "BLIND", PR_MAP, PU_UPDATE_VIEW | PU_MONSTERS, 0, NULL, NULL, NULL, NULL, 0, 0, NULL, NULL, NULL, { 0 }, 0, false, false },
{ "ENTRANCED", PR_STATUS, PU_BONUS, 0, NULL, NULL, NULL, NULL, 0, 0, NULL, NULL, NULL, { 0 }, 0, false, false },
{ "CONFUSED", PR_STATUS, PU_BONUS, 0, NULL, NULL, NULL, NULL, 0, 0, NULL, NULL, NULL, { 0 }, 0, false, false },
{ "AFRAID", PR_STATUS, PU_BONUS, 0, NULL, NULL, NULL, NULL, 0, 0, NULL, NULL, NULL, { 0 }, 0, false, false },
{ "IMAGE", PR_MAP | PR_MONLIST | PR_ITEMLIST, PU_BONUS, 0, NULL, NULL, NULL, NULL, 0, 0, NULL, NULL, NULL, { 0 }, 0, false, false },
{ "POISONED", PR_STATUS, PU_BONUS, 0, NULL, NULL, NULL, NULL, 0, 0, NULL, NULL, NULL, { 0 }, 0, false, false },
{ "CUT", PR_STATUS, PU_BONUS, 0, NULL, NULL, NULL, NULL, 0, 0, NULL, NULL, NULL, { 0 }, 0, false, false },
{ "STUN", PR_STATUS, PU_BONUS, 0, NULL, NULL, NULL, NULL, 0, 0, NULL, NULL, NULL, { 0 }, 0, false, false },
{ "FOOD", PR_STATUS, PU_BONUS, 0, NULL, NULL, NULL, NULL, 0, 0, NULL, NULL, NULL, { 0 }, 0, false, false },
{ "DARKENED", PR_STATUS, PU_BONUS, 0, NULL, NULL, NULL, NULL, 0, 0, NULL, NULL, NULL, { 0 }, 0, false, false },
{ "RAGE", PR_STATUS, PU_BONUS, 0, NULL, NULL, NULL, NULL, 0, 0, NULL, NULL, NULL, { 0 }, 0, false, false },
{ "STR", PR_STATUS, PU_BONUS, 0, NULL, NULL, NULL, NULL, 0, 0, NULL, NULL, NULL, { 0 }, 0, false, false },
{ "DEX", PR_STATUS, PU_BONUS, 0, NULL, NULL, NULL, NULL, 0, 0, NULL, NULL, NULL, { 0 }, 0, false, false },
{ "CON", PR_STATUS, PU_BONUS, 0, NULL, NULL, NULL, NULL, 0, 0, NULL, NULL, NULL, { 0 }, 0, false, false },
{ "GRA", PR_STATUS, PU_BONUS, 0, NULL, NULL, NULL, NULL, 0, 0, NULL, NULL, NULL, { 0 }, 0, false, false },
{ "SINVIS", PR_STATUS, PU_BONUS | PU_MONSTERS, 0, NULL, NULL, NULL, NULL, 0, 0, NULL, NULL, NULL, { 0 }, 0, false, false },
{ "OPP_FIRE", PR_STATUS, PU_BONUS, 0, NULL, NULL, NULL, NULL, 0, 0, NULL, NULL, NULL, { 0 }, 0, false, false },
{ "OPP_COLD", PR_STATUS, PU_BONUS, 0, NULL, NULL, NULL, NULL, 0, 0, NULL, NULL, NULL, { 0 }, 0, false, false },
{ "OPP_POIS", PR_STATUS, PU_BONUS, 0, NULL, NULL, NULL, NULL, 0, 0, NULL, NULL, NULL, { 0 }, 0, false, false },

};
int timed_name_to_idx(const char *name)
{
    for (size_t i = 0; i < N_ELEMENTS(timed_effects); i++) {
        if (my_stricmp(name, timed_effects[i].name) == 0) {
            return i;
        }
    }
    return -1;
}
/**
 * List of timed effect names
 */
static const char *list_timed_effect_names[] = {
/**
 * \file list-player-timed.h
 * \brief timed player properties
 *
 * Fields:
 * symbol - the effect name
 * flag_redraw - the things to be redrawn when the effect is set
 * flag_update - the things to be updated when the effect is set
 */
/* symbol		flag_redraw						flag_update */
"FAST",
"SLOW",
"BLIND",
"ENTRANCED",
"CONFUSED",
"AFRAID",
"IMAGE",
"POISONED",
"CUT",
"STUN",
"FOOD",
"DARKENED",
"RAGE",
"STR",
"DEX",
"CON",
"GRA",
"SINVIS",
"OPP_FIRE",
"OPP_COLD",
"OPP_POIS",

 "MAX",
};
static enum parser_error parse_player_timed_name(struct parser *p)
{
 const char *name = parser_getstr(p, "name");
 int index;
 if (grab_name("timed effect",
   name,
   list_timed_effect_names,
   N_ELEMENTS(list_timed_effect_names),
   &index)) {
  /* XXX not a desctiptive error */
  return PARSE_ERROR_INVALID_SPELL_NAME;
 }
 struct timed_effect_data *t = &timed_effects[index];
 t->index = index;
 t->fail = -1;
 parser_setpriv(p, t);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_player_timed_desc(struct parser *p)
{
 struct timed_effect_data *t = parser_priv(p);
 if (!t) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 t->desc = string_append(t->desc, parser_getstr(p, "text"));
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_player_timed_end_message(struct parser *p)
{
 struct timed_effect_data *t = parser_priv(p);
 if (!t) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 t->on_end = string_append(t->on_end, parser_getstr(p, "text"));
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_player_timed_increase_message(struct parser *p)
{
 struct timed_effect_data *t = parser_priv(p);
 if (!t) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 t->on_increase = string_append(t->on_increase, parser_getstr(p, "text"));
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_player_timed_decrease_message(struct parser *p)
{
 struct timed_effect_data *t = parser_priv(p);
 if (!t) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 t->on_decrease = string_append(t->on_decrease, parser_getstr(p, "text"));
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_player_timed_change_increase(struct parser *p)
{
 struct timed_effect_data *t = parser_priv(p);
 struct timed_change *current;
 if (!t) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 /* Make a zero change structure if there isn't one */
 current = t->increase;
 if (!current) {
  t->increase = mem_zalloc(sizeof(struct timed_change));
  current = t->increase;
 } else {
  /* Move to the highest change so far */
  while (current->next) {
   current = current->next;
  }
  current->next = mem_zalloc(sizeof(struct timed_change));
  current = current->next;
 }
 current->max = parser_getint(p, "max");
 current->msg = string_append(current->msg, parser_getsym(p, "msg"));
 if (parser_hasval(p, "inc_msg")) {
  current->inc_msg = string_append(current->inc_msg,
           parser_getsym(p, "inc_msg"));
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_player_timed_change_decrease(struct parser *p)
{
 struct timed_effect_data *t = parser_priv(p);
 if (!t) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 t->decrease.max = parser_getint(p, "max");
 string_free(t->decrease.msg);
 t->decrease.msg = string_make(parser_getsym(p, "msg"));
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_player_timed_message_type(struct parser *p)
{
 struct timed_effect_data *t = parser_priv(p);
 if (!t) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 t->msgt = message_lookup_by_name(parser_getsym(p, "type"));
 return t->msgt < 0 ?
  PARSE_ERROR_INVALID_MESSAGE : PARSE_ERROR_NONE;
}
static enum parser_error parse_player_timed_fail(struct parser *p)
{
 struct timed_effect_data *t = parser_priv(p);
 const char *name = parser_getstr(p, "flag");
 int flag = lookup_flag(obj_flags, name);
 if (!t) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 if (flag == FLAG_END) {
  return PARSE_ERROR_INVALID_FLAG;
 }
 t->fail = flag;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_player_timed_grade(struct parser *p)
{
 struct timed_effect_data *t = parser_priv(p);
 const char *color = parser_getsym(p, "color");
 struct timed_grade *current, *l;
 int attr = 0;
 if (!t) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 /* Make a zero grade structure if there isn't one */
 current = t->grade;
 if (!current) {
  t->grade = mem_zalloc(sizeof(struct timed_grade));
  current = t->grade;
 }
 /* Move to the highest grade so far */
 while (current->next) {
  current = current->next;
 }
 /* Add the new one */
 l = mem_zalloc(sizeof(*l));
 current->next = l;
 l->grade = current->grade + 1;
 if (strlen(color) > 1) {
  attr = color_text_to_attr(color);
 } else {
  attr = color_char_to_attr(color[0]);
 }
 if (attr < 0)
  return PARSE_ERROR_INVALID_COLOR;
 l->color = attr;
 l->max = parser_getint(p, "max");
 l->name = string_make(parser_getsym(p, "name"));
 /* Name may be a dummy (eg hunger)*/
 if (strlen(l->name) == 1) {
  string_free(l->name);
  l->name = NULL;
 }
 l->up_msg = string_make(parser_getsym(p, "up_msg"));
 /* Message may be a dummy */
 if (strlen(l->up_msg) == 1) {
  string_free(l->up_msg);
  l->up_msg = NULL;
 }
 if (parser_hasval(p, "down_msg")) {
  l->down_msg = string_make(parser_getsym(p, "down_msg"));
 }
 /* Set food constants and deal with percentages */
 if (streq(t->name, "FOOD")) {
  if (l->name) {
   if (streq(l->name, "Starving")) {
    PY_FOOD_STARVE = l->max;
   } else if (streq(l->name, "Weak")) {
    PY_FOOD_WEAK = l->max;
   } else if (streq(l->name, "Hungry")) {
    PY_FOOD_ALERT = l->max;
   } else if (streq(l->name, "Fed")) {
    PY_FOOD_FULL = l->max;
   } else if (streq(l->name, "Full")) {
    PY_FOOD_MAX = l->max;
   }
  }
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_player_timed_change_grade(struct parser *p)
{
 struct timed_effect_data *t = parser_priv(p);
 const char *color = parser_getsym(p, "color");
 int grade_max = parser_getint(p, "max");
 struct timed_change_grade *current, *l;
 int attr;
 if (!t) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 /*
	 * The maximum should be greater than zero so it does not interfere
	 * with the implicit "off" grade.  Because the player's timed array
	 * has int16_t elements, ensure that the maximum is compatible with
	 * that.
	 */
 if (grade_max <= 0 || grade_max > 32767) {
  return PARSE_ERROR_INVALID_VALUE;
 }
 /* Make a zero grade structure if there isn't one */
 current = t->c_grade;
 if (!current) {
  t->c_grade = mem_zalloc(sizeof(struct timed_change_grade));
  current = t->c_grade;
 }
 /* Move to the highest grade so far */
 while (current->next) {
  current = current->next;
 }
 /* Add the new one */
 l = mem_zalloc(sizeof(*l));
 current->next = l;
 l->c_grade = current->c_grade + 1;
 if (strlen(color) > 1) {
  attr = color_text_to_attr(color);
 } else {
  attr = color_char_to_attr(color[0]);
 }
 if (attr < 0) {
  return PARSE_ERROR_INVALID_COLOR;
 }
 l->color = attr;
 l->max = grade_max;
 l->digits = parser_getint(p, "digits");
 l->name = string_make(parser_getsym(p, "name"));
 /* Name may be a dummy (eg hunger)*/
 if (strlen(l->name) == 1) {
  string_free(l->name);
  l->name = NULL;
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_player_timed_resist(struct parser *p)
{
 struct timed_effect_data *t = parser_priv(p);
 const char *name = parser_getsym(p, "elem");
 int idx = (name) ? proj_name_to_idx(name) : -1;
 if (!t) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 if (idx < 0 || idx >= ELEM_MAX) return PARSE_ERROR_INVALID_VALUE;
 t->temp_resist = idx;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_player_timed_este(struct parser *p)
{
 struct timed_effect_data *t = parser_priv(p);
 if (!t) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 t->este = parser_getuint(p, "value") ? true : false;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_player_timed_save(struct parser *p)
{
 struct timed_effect_data *t = parser_priv(p);
 if (!t) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 t->save = parser_getuint(p, "value") ? true : false;
 return PARSE_ERROR_NONE;
}
static struct parser *init_parse_player_timed(void)
{
 struct parser *p = parser_new();
 parser_setpriv(p, NULL);
 parser_reg(p, "name str name", parse_player_timed_name);
 parser_reg(p, "desc str text", parse_player_timed_desc);
 parser_reg(p, "on-end str text", parse_player_timed_end_message);
 parser_reg(p, "on-increase str text", parse_player_timed_increase_message);
 parser_reg(p, "on-decrease str text", parse_player_timed_decrease_message);
 parser_reg(p, "change-inc int max sym msg ?sym inc_msg",
      parse_player_timed_change_increase);
 parser_reg(p, "change-dec int max sym msg",
      parse_player_timed_change_decrease);
 parser_reg(p, "msgt sym type", parse_player_timed_message_type);
 parser_reg(p, "fail str flag", parse_player_timed_fail);
 parser_reg(p, "grade sym color int max sym name sym up_msg ?sym down_msg",
      parse_player_timed_grade);
 parser_reg(p, "change-grade sym color int max int digits sym name",
      parse_player_timed_change_grade);
 parser_reg(p, "resist sym elem", parse_player_timed_resist);
 parser_reg(p, "este uint value", parse_player_timed_este);
 parser_reg(p, "save uint value", parse_player_timed_save);
 return p;
}
static errr run_parse_player_timed(struct parser *p)
{
 return parse_file_quit_not_found(p, "player_timed");
}
static errr finish_parse_player_timed(struct parser *p)
{
 parser_destroy(p);
 return 0;
}
static void cleanup_player_timed(void)
{
 for (size_t i = 0; i < TMD_MAX; i++) {
  struct timed_effect_data *effect = &timed_effects[i];
  struct timed_grade *grade = effect->grade;
  struct timed_change_grade *c_grade = effect->c_grade;
  struct timed_change *increase = effect->increase;
  while (grade) {
   struct timed_grade *next = grade->next;
   string_free(grade->name);
   if (grade->up_msg) string_free(grade->up_msg);
   if (grade->down_msg) string_free(grade->down_msg);
   mem_free(grade);
   grade = next;
  }
  effect->grade = NULL;
  while (c_grade) {
   struct timed_change_grade *next = c_grade->next;
   string_free(c_grade->name);
   mem_free(c_grade);
   c_grade = next;
  }
  effect->c_grade = NULL;
  while (increase) {
   struct timed_change *next = increase->next;
   string_free(increase->msg);
   if (increase->inc_msg) string_free(increase->inc_msg);
   mem_free(increase);
   increase = next;
  }
  effect->increase = NULL;
  string_free(effect->decrease.msg);
  effect->decrease.msg = NULL;
  string_free(effect->desc);
  if (effect->on_end)
   string_free(effect->on_end);
  if (effect->on_increase)
   string_free(effect->on_increase);
  if (effect->on_decrease)
   string_free(effect->on_decrease);
  effect->desc = NULL;
  effect->on_end = NULL;
  effect->on_increase = NULL;
  effect->on_decrease = NULL;
 }
}
struct file_parser player_timed_parser = {
 "player timed effects",
 init_parse_player_timed,
 run_parse_player_timed,
 finish_parse_player_timed,
 cleanup_player_timed
};
/**
 * ------------------------------------------------------------------------
 * Utilities for more complex or anomolous effects
 * ------------------------------------------------------------------------ */
/**
 * Amount to decrement over time
 */
int player_timed_decrement_amount(struct player *p, int idx)
{
 struct song *este = lookup_song("Este");
 struct song *freedom = lookup_song("Freedom");
 int bonus_este = song_bonus(p, p->state.skill_use[SKILL_SONG], este);
 int bonus_freedom = song_bonus(p, p->state.skill_use[SKILL_SONG], freedom);
 int amount = 1;
 /* Adjust for songs */
 if (timed_effects[idx].este && player_is_singing(p, este)) {
  amount = bonus_este;
 }
 if ((idx == TMD_SLOW) && player_is_singing(p, freedom)) {
  amount = bonus_freedom;
 }
 /* Special cases */
 if ((idx == TMD_CUT) || (idx == TMD_POISONED)) {
  amount *= ((p->timed[idx] + 4) / 5);
  p->upkeep->redraw |= (PR_STATUS);
 }
 return amount;
}
/**
 * Effects on end of temporary boost
 */
static void player_timed_end_effect(int idx)
{
 switch (idx) {
  case TMD_ENTRANCED: {
   player->upkeep->was_entranced = true;
   break;
  }
  case TMD_RAGE: {
   player->upkeep->redraw |= PR_MAP;
   break;
  }
  default: break;
 }
}
/**
 * Return the name of the current grade of a timed effect on a player.
 *
 * \param p is the player to query.
 * \param idx is the index of the timed effect.
 * \return NULL if the timed effect is not currently active; otherwise return
 * the name of the currently active grade for the timed effect.  The returned
 * string should not be freed.
 */
const char *player_get_timed_grade(const struct player *p, int idx)
{
 const struct timed_grade *grade;
 if (!p->timed[idx]) {
  return NULL;
 }
 grade = timed_effects[idx].grade;
 while (p->timed[idx] > grade->max) {
  grade = grade->next;
 }
 return grade->name;
}
/**
 * Return true if the player timed effect matches the given string
 */
bool player_timed_grade_eq(const struct player *p, int idx, const char *match)
{
 if (p->timed[idx]) {
  const struct timed_grade *grade = timed_effects[idx].grade;
  while (p->timed[idx] > grade->max) {
   grade = grade->next;
  }
  if (grade->name && streq(grade->name, match)) return true;
 }
 return false;
}
/**
 * Return true if the player timed effect is at a gradation above the given
 * string.
 */
bool player_timed_grade_gt(const struct player *p, int idx, const char *match)
{
 if (p->timed[idx]) {
  const struct timed_grade *grade = timed_effects[idx].grade;
  while (1) {
   if (!grade) {
    break;
   }
   if (grade->name && streq(grade->name, match)) {
    return p->timed[idx] > grade->max;
   }
   grade = grade->next;
  }
 }
 return false;
}
/**
 * Return true if the player timed effect is not set or is at a gradation below
 * the given string.
 */
bool player_timed_grade_lt(const struct player *p, int idx, const char *match)
{
 if (p->timed[idx]) {
  const struct timed_grade *grade = timed_effects[idx].grade;
  const struct timed_grade *prev_grade = NULL;
  while (1) {
   if (!grade) {
    return false;
   }
   if (grade->name && streq(grade->name, match)) {
    return prev_grade
     && p->timed[idx] <= prev_grade->max;
   }
   prev_grade = grade;
   grade = grade->next;
  }
 }
 return true;
}
/**
 * ------------------------------------------------------------------------
 * Setting, increasing, decreasing and clearing timed effects
 * ------------------------------------------------------------------------ */
/**
 * Set a timed effect.
 *
 * \param p is the player to affect.
 * \param idx is the index, greater than equal to zero and less than TMD_MAX,
 * for the effect.
 * \param v is the new value for the effect.  Internally, v is coerced to lie
 * within the range of acceptable values for the effect.
 * \param notify, if true, allows for messages, updates to the user interface,
 * and player disturbance if setting the effect doesn't duplicate an effect
 * already present.  If false, prevents messages, updates to the user interface,
 * and player disturbance unless setting the effect increases the effect's
 * gradation or decreases the effect's gradation when the effect has messages
 * for the gradations that lapse.
 * \param can_disturb, if true, allows for setting the effect to disturb the
 * player.
 * \return whether setting the effect caused the player to be notified.
 */
bool player_set_timed(struct player *p, int idx, int v, bool notify,
  bool can_disturb)
{
 assert(idx >= 0);
 assert(idx < TMD_MAX);
 struct timed_effect_data *effect = &timed_effects[idx];
 struct timed_grade *new_grade = effect->grade;
 struct timed_grade *current_grade = effect->grade;
 struct object *weapon = equipped_item_by_slot_name(p, "weapon");
 struct timed_grade *blackout_grade = (idx == TMD_STUN) ?
  timed_effects[TMD_STUN].grade : NULL;
 /* Lower bound */
 v = MAX(v, (idx == TMD_FOOD) ? 1 : 0);
 /* No change */
 if (p->timed[idx] == v) {
  return false;
 }
 /* Don't increase stunning if stunning value is greater than the
	 * limit for heavy stunning.  This is an effort to eliminate the
	 * "knocked out" instadeath. */
 if (blackout_grade) {
  while (!blackout_grade->name
    || !streq(blackout_grade->name, "Heavy Stun")) {
   blackout_grade = blackout_grade->next;
   assert(blackout_grade);
  }
  if (p->timed[idx] > blackout_grade->max && v > p->timed[idx]) {
   return false;
  }
 }
 /* Deal with graded effects */
 if (new_grade) {
  /* Find the grade we will be going to, and the current one */
  while (v > new_grade->max) {
   new_grade = new_grade->next;
   if (!new_grade->next) break;
  }
  while (p->timed[idx] > current_grade->max) {
   current_grade = current_grade->next;
   if (!current_grade->next) break;
  }
  /* Upper bound */
  if (v > new_grade->max) {
   if (p->timed[idx] == new_grade->max) {
    /*
				 * No change:  tried to exceed the maximum possible and
				 * already there
				 */
    return false;
   }
   v = new_grade->max;
  }
  /* Knocked out */
  if (blackout_grade && v > blackout_grade->max) {
   p->timed[TMD_BLIND] = MAX(p->timed[TMD_BLIND], 2);
  }
  /* Always mention going up a grade, otherwise on request */
  if (new_grade->grade > current_grade->grade) {
   if ((timed_effects[idx].temp_resist != -1) &&
    player_resists(p, timed_effects[idx].temp_resist)) {
    /* Special message for temporary + permanent resist */
    print_custom_message(weapon, effect->on_increase, effect->msgt,
          p);
   } else {
    print_custom_message(weapon, new_grade->up_msg, effect->msgt,
          p);
   }
   notify = true;
  } else if ((new_grade->grade < current_grade->grade) &&
       (new_grade->down_msg)) {
   print_custom_message(weapon, new_grade->down_msg, effect->msgt, p);
   /* Special case */
   if (blackout_grade && v < blackout_grade->max) {
    msg("You wake up.");
    p->timed[TMD_BLIND] = MAX(p->timed[TMD_BLIND] - 1, 0);
   }
   notify = true;
  } else if (notify) {
   if (v == 0) {
    /* Finishing */
    print_custom_message(weapon, effect->on_end, MSG_RECOVER, p);
    player_timed_end_effect(idx);
   } else if (p->timed[idx] > v && effect->on_decrease) {
    /* Decrementing */
    print_custom_message(weapon, effect->on_decrease, effect->msgt,
          p);
   }
  }
 } else {
  const struct timed_change_grade *last_grade = effect->c_grade;
  int change;
  /* There had better be a change grade */
  assert(last_grade);
  /* Upper bound is the maximum for the last change grade */
  while (last_grade->next) last_grade = last_grade->next;
  if (v > last_grade->max) {
   if (p->timed[idx] == last_grade->max) {
    /*
				 * No change:  tried to exceed the maximum
				 * possible but already at that maximum
				 */
    return false;
   }
   v = last_grade->max;
  }
  /* Find the change we will be using */
  change = v - p->timed[idx];
  /* Increase */
  if (change > 0) {
   struct timed_change *inc = effect->increase;
   while (change >= inc->max && inc->next) {
    inc = inc->next;
   }
   if (p->timed[idx] && inc->inc_msg) {
    /* Increasing from existing effect, and increase message */
    msgt(effect->msgt, inc->inc_msg);
    notify = true;
   } else {
    /* Effect starting, or no special increase message */
    msgt(effect->msgt, inc->msg);
    notify = true;
   }
  } else {
   /* Decrease */
   if (v == 0) {
    /* Finishing */
    msgt(effect->msgt, effect->on_end);
    notify = true;
   } else {
    int div = effect->decrease.max;
    if (-change > (p->timed[idx] + div - 1) / div) {
     msgt(effect->msgt, effect->decrease.msg);
     notify = true;
    }
   }
  }
 }
 /* Use the value */
 p->timed[idx] = v;
 if (notify) {
  /* Disturb */
  if (can_disturb) {
   disturb(p, false);
  }
  /* Update the visuals, as appropriate. */
  p->upkeep->update |= effect->flag_update;
  p->upkeep->redraw |= (PR_STATUS | effect->flag_redraw);
  /* Handle stuff */
  handle_stuff(p);
 }
 return notify;
}
/**
 * The saving throw is a will skill check.
 *
 * Note that the player is resisting and thus wins ties.
 */
bool player_saving_throw(struct player *p, struct monster *mon, int resistance)
{
 int player_skill = p->state.skill_use[SKILL_WILL];
 int difficulty = mon ? monster_skill(mon, SKILL_WILL) : 10;
 /* Adjust difficulty for resistance */
 difficulty -= 10 * resistance;
 if (mon) {
  return skill_check(source_monster(mon->midx), difficulty, player_skill,
         source_player()) <= 0;
 }
 return skill_check(source_none(), difficulty, player_skill,
        source_player()) <= 0;
}
/**
 * Check whether a timed effect will affect the player
 *
 * \param p is the player to check.
 * \param idx is the index, greater than equal to zero and less than TMD_MAX,
 * for the effect.
 * \param lore, if true, modifies the check so it is appropriate for filling
 * in details of monster recall.
 * \return whether the player can be affected by the effect.
 */
bool player_inc_check(struct player *p, int idx, bool lore)
{
 struct timed_effect_data *effect = &timed_effects[idx];
 struct monster *mon = cave->mon_current > 0 ?
  cave_monster(cave, cave->mon_current) : NULL;
 int resistance;
 /* Special case for rage */
 if ((idx == TMD_AFRAID) && p->timed[TMD_RAGE]) return false;
 /* If we're only doing this for monster lore purposes */
 if (lore) {
  return (effect->fail != -1) ?
   (p->known_state.flags[effect->fail] == 0) : true;
 }
 /* Check whether @ has resistance to this effect */
 resistance = (effect->fail != -1) ? p->state.flags[effect->fail]: 0;
 if (resistance) {
  /* Possibly identify relevant items */
  equip_learn_flag(p, effect->fail);
 }
 /* Determine whether the player saves */
 if (effect->save && player_saving_throw(p, mon, resistance)) {
  return false;
 }
 return true;
}
/**
 * Increase the timed effect `idx` by `v`.
 *
 * \param p is the player to affect.
 * \param idx is the index, greater than equal to zero and less than TMD_MAX,
 * for the effect.
 * \param notify, if true, allows for messages, updates to the user interface,
 * and player disturbance if increasing the duration doesn't duplicate an effect
 * already present.  If false, prevents messages, updates to the user interface,
 * and player disturbance unless increasing the duration increases the effect's
 * gradation or decreases the effect's gradation when the effect has messages
 * for the gradations that lapse.
 * \param can_disturb, if true, allows for setting the effect to disturb the
 * player.
 * \param check, if true, allows for the player to resist the effect if
 * player_inc_check(p, idx, false) is true.
 * \return whether increasing the duration caused the player to be notified.
 */
bool player_inc_timed(struct player *p, int idx, int v, bool notify,
  bool can_disturb, bool check)
{
 assert(idx >= 0);
 assert(idx < TMD_MAX);
 if (check == false || player_inc_check(p, idx, false) == true) {
  /* Entrancement should be non-cumulative */
  if (idx == TMD_ENTRANCED && p->timed[TMD_ENTRANCED] > 0) {
   return false;
  } else {
   return player_set_timed(p, idx, p->timed[idx] + v,
    notify, can_disturb);
  }
 }
 return false;
}
/**
 * Decrease the timed effect `idx` by `v`.
 *
 * \param p is the player to affect.
 * \param idx is the index, greater than equal to zero and less than TMD_MAX,
 * for the effect.
 * \param v is the amount to subtract from the effect's duration.
 * \param notify, if true or v is greater than or equal to the effect's current
 * duration, allows for messages, updates to the user interface, and player
 * disturbance.  If false and v is less than the effect's current duration,
 * prevents messages, updates to the user interface, and player disturbance
 * unless the change to the duration increases the effect's gradation or
 * decreases the effect's gradation when the effect has messages for the
 * gradations that lapse.
 * \param can_disturb, if true, allows for the change to the duration to disturb
 * the player.
 * \return whether changing the duration caused the player to be notified.
 */
bool player_dec_timed(struct player *p, int idx, int v, bool notify,
  bool can_disturb)
{
 int new_value;
 assert(idx >= 0);
 assert(idx < TMD_MAX);
 new_value = p->timed[idx] - v;
 /* Obey `notify` if not finishing; if finishing, always notify */
 if (new_value > 0) {
  return player_set_timed(p, idx, new_value, notify, can_disturb);
 }
 return player_set_timed(p, idx, new_value, true, can_disturb);
}
/**
 * Clear the timed effect `idx`.
 *
 * \param p is the player to affect.
 * \param idx is the index, greater than equal to zero and less than TMD_MAX,
 * for the effect.
 * \param notify, if true, allows for messages, updates to the user interface,
 * and player disturbance if clearing the effect doesn't duplicate an effect
 * already present.  If false, prevents messages, updates to the user interface,
 * and player disturbance unless clearing the effect decreases the effect's
 * gradation and the effect has messages for the gradations that lapse.
 * \param can_disturb, if true, allows for setting the effect to disturb the
 * player.
 * \return whether clearing the effect caused the player to be notified.
 */
bool player_clear_timed(struct player *p, int idx, bool notify,
  bool can_disturb)
{
 assert(idx >= 0);
 assert(idx < TMD_MAX);
 return player_set_timed(p, idx, 0, notify, can_disturb);
}
/**
 * Hack to check whether a timed effect happened.
 */
bool player_timed_inc_happened(struct player *p, int old[], int len)
{
 int idx;
 assert(len == TMD_MAX);
 for (idx = 0; idx < len; idx++) {
  if (player->timed[idx] > old[idx]) return true;
 }
 return false;
}
/**
 * \file player-util.c
 * \brief Player utility functions
 *
 * Copyright (c) 2011 The Angband Developers. See COPYING.
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
static const char *skill_names[] = {
/**
 * \file src/list-skills.h
 * \brief player skills
 *
 * Changing skill order or making new ones will break savefiles. Skills
 * below start from 0 on line 11, so a skill's sequence number is its line
 * number minus 11.
 *
 * Skill properties are not defined in lib/gamedata/object_property.txt
 */
"Melee",
"Archery",
"Evasion",
"Stealth",
"Perception",
"Will",
"Smithing",
"Song",

 ""
};
/**
 * Determines the shallowest a player is allowed to go.
 * As time goes on, they are forced deeper and deeper.
 */
int player_min_depth(struct player *p)
{
 int turns = 0;
 int depth = 0;
 /* Base minimum depth */
 while (turns < p->turn) {
  depth += 1;
  turns += 1000 + 50 * depth;
 }
 /* Bounds on the base */
 depth = MIN(MAX(depth, 1), z_info->dun_depth);
 /* Can't leave the throne room */
 if (p->depth == z_info->dun_depth) {
  depth = z_info->dun_depth;
 }
 /* No limits in the endgame */
 if (p->on_the_run) {
  depth = 0;
 }
 return depth;
}
/**
 * Increment to the next or decrement to the preceeding level.
 * Keep in mind to check all intermediate level for unskippable quests
*/
int dungeon_get_next_level(struct player *p, int dlev, int added)
{
 int target_level;
 /* Get target level */
 target_level = dlev + added;
 /* Don't allow levels below max */
 if (target_level > z_info->dun_depth)
  target_level = z_info->dun_depth;
 /* Don't allow levels above the town */
 if (target_level < 0) target_level = 0;
 return target_level;
}
/**
 * Change dungeon level - e.g. by going up stairs or with WoR.
 */
void dungeon_change_level(struct player *p, int dlev)
{
 /* New depth */
 p->depth = dlev;
 /* Leaving, make new level */
 p->upkeep->generate_level = true;
 /* Save the game when we arrive on the new level. */
 p->upkeep->autosave = true;
}
/**
 * Simple exponential function for integers with non-negative powers
 */
int int_exp(int base, int power)
{
 int i;
 int result = 1;
 for (i = 0; i < power; i++) {
  result *= base;
 }
 return result;
}
/**
 * Decreases players hit points and sets death flag if necessary
 *
 * Hack -- this function allows the user to save (or quit) the game
 * when he dies, since the "You die." message is shown before setting
 * the player to "dead".
 */
void take_hit(struct player *p, int dam, const char *kb_str)
{
 int old_chp = p->chp;
 int warning = (p->mhp * p->opts.hitpoint_warn / 10);
 time_t ct = time((time_t*)0);
 char long_day[40];
 char buf[120];
 /* Paranoia */
 if (p->is_dead) return;
 if (dam <= 0) return;
 /* Disturb */
 disturb(p, true);
 /* Hurt the player */
 p->chp -= dam;
 /* Display the hitpoints */
 p->upkeep->redraw |= (PR_HP);
 /* Dead player */
 if (p->chp <= 0) {
  /*
		 * Note cause of death.  Do it here so EVENT_CHEAT_DEATH
		 * handlers or things looking for the "Die? " prompt have
		 * access to it.
		 */
  if (p->timed[TMD_IMAGE]) {
   strnfmt(p->died_from, sizeof(p->died_from),
     "%s (while halluciinating)", kb_str);
  } else {
   my_strcpy(p->died_from, kb_str, sizeof(p->died_from));
  }
  if ((p->wizard || OPT(p, cheat_live)) && !get_check("Die? ")) {
   event_signal(EVENT_CHEAT_DEATH);
  } else {
   /* Hack -- Note death */
   msgt(MSG_DEATH, "You die.");
   event_signal(EVENT_MESSAGE_FLUSH);
   event_signal(EVENT_DEATH);
   /* Note death */
   p->is_dead = true;
   /* Killed by */
   strnfmt(buf, sizeof(buf), "Slain by %s.", p->died_from);
   history_add(p, buf, HIST_PLAYER_DEATH);
   /* Get time */
   (void)strftime(long_day, 40, "%d %B %Y", localtime(&ct));
   strnfmt(buf, sizeof(buf), "Died on %s.", long_day);
   history_add(p, buf, HIST_PLAYER_DEATH);
   /* Dead */
   return;
  }
 }
 /* Hitpoint warning */
 if (p->chp < warning) {
  /* Hack -- bell on first notice */
  if (old_chp > warning)
   bell();
  /* Message */
  msgt(MSG_HITPOINT_WARN, "*** LOW HITPOINT WARNING! ***");
  event_signal(EVENT_MESSAGE_FLUSH);
 }
 /* Cancel entrancement */
 player_set_timed(p, TMD_ENTRANCED, 0, false, true);
}
/**
 * Win or not, know inventory and history upon death, enter score
 */
void death_knowledge(struct player *p)
{
 struct object *obj;
 time_t death_time = (time_t)0;
 player_learn_all_runes(p);
 for (obj = p->gear; obj; obj = obj->next) {
  object_flavor_aware(p, obj);
 }
 history_unmask_unknown(p);
 /* Get time of death */
 (void)time(&death_time);
 enter_score(p, &death_time);
 /* Hack -- Recalculate bonuses */
 p->upkeep->update |= (PU_BONUS);
 handle_stuff(p);
}
/**
 * Regenerate one turn's worth of hit points
 */
void player_regen_hp(struct player *p)
{
 int old_chp = p->chp;
 int regen_multiplier = p->state.flags[OF_REGEN] + 1;
 int regen_period = z_info->player_regen_period;
 struct song *este = lookup_song("Este");
 /* Various things interfere with physical healing */
 if (p->timed[TMD_FOOD] < PY_FOOD_STARVE) return;
 if (p->timed[TMD_POISONED]) return;
 if (p->timed[TMD_CUT]) return;
 /* Various things speed up regeneration */
 if (player_is_singing(p, este)) {
  regen_multiplier *= song_bonus(p, p->state.skill_use[SKILL_SONG], este);
 }
 /* Complete healing every z_info->player_regen_period player turns, modified */
 if (regen_multiplier > 0) {
  regen_period /= regen_multiplier;
 } else {
  return;
 }
 /* Work out how much increase is due */
 p->chp += regen_amount(p->turn, p->mhp, regen_period);
 p->chp = MIN(p->chp, p->mhp);
 /* Notice changes */
 if (old_chp != p->chp) {
  equip_learn_flag(p, OF_REGEN);
  p->upkeep->redraw |= (PR_HP);
 }
}
/**
 * Regenerate one turn's worth of voice
 */
void player_regen_mana(struct player *p)
{
 int old_csp = p->csp;
 int regen_multiplier = p->state.flags[OF_REGEN] + 1;
 int regen_period = z_info->player_regen_period;
 /* Don't regenerate voice if singing */
 if (p->song[SONG_MAIN]) return;
 /* Complete healing every z_info->player_regen_period player turns,
	 * modified */
 if (regen_multiplier > 0) {
  regen_period /= regen_multiplier;
 } else {
  return;
 }
 /* Work out how much increase is due */
 p->csp += regen_amount(p->turn, p->msp, regen_period);
 p->csp = MIN(p->csp, p->msp);
 /* Notice changes */
 if (old_csp != p->csp) {
  equip_learn_flag(p, OF_REGEN);
  p->upkeep->redraw |= (PR_MANA);
 }
}
/**
 * Digest food.
 *
 * Speed and regeneration are taken into account already in the hunger rate.
 */
void player_digest(struct player *p)
{
 /* Basic digestion rate */
 int i = 1;
 /* Slow hunger rates are done statistically */
 if (p->state.hunger < 0) {
  if (!one_in_(int_exp(3, -(p->state.hunger)))) {
   i = 0;
  }
 } else if (p->state.hunger > 0) {
  i *= int_exp(3, p->state.hunger);
 }
 /* Digest quickly when gorged */
 if (p->timed[TMD_FOOD] >= PY_FOOD_MAX) i *= 9;
 /* Digest some food */
 (void)player_dec_timed(p, TMD_FOOD, i, false, true);
 /* Starve to death (slowly) */
 if (p->timed[TMD_FOOD] < PY_FOOD_STARVE) {
  /* Take damage */
  take_hit(p, 1, "starvation");
 }
}
/**
 * Update the player's light fuel
 */
void player_update_light(struct player *p)
{
 /* Check for light being wielded */
 struct object *obj = equipped_item_by_slot_name(p, "light");
 /* Burn some fuel in the current light */
 if (obj && tval_is_light(obj)) {
  bool burn_fuel = true;
  /* If the light has the NO_FUEL flag, well... */
  if (of_has(obj->flags, OF_NO_FUEL))
      burn_fuel = false;
  /* Use some fuel (except on artifacts, or during the day) */
  if (burn_fuel && obj->timeout > 0) {
   /* Decrease life-span */
   obj->timeout--;
   /* Hack -- notice interesting fuel steps */
   if ((obj->timeout < 100) || (!(obj->timeout % 100)))
    /* Redraw stuff */
    p->upkeep->redraw |= (PR_EQUIP);
   /* Hack -- Special treatment when blind */
   if (p->timed[TMD_BLIND]) {
    /* Hack -- save some light for later */
    if (obj->timeout == 0) obj->timeout++;
   } else if (obj->timeout == 0) {
    /* The light is now out */
    disturb(p, false);
    msg("Your light has gone out!");
   } else if ((obj->timeout <= 100) && (!(obj->timeout % 20))) {
    /* The light is getting dim */
    if (obj->timeout == 100) {
     /* Only disturb the first time */
     disturb(p, false);
    }
    msg("Your light is growing faint.");
   }
  }
 }
 /* Calculate torch radius */
 p->upkeep->update |= (PU_TORCH);
}
/**
 * Check the player for boots of radiance
 */
bool player_radiates(struct player *p)
{
 struct object *boots = equipped_item_by_slot_name(p, "feet");
 if (boots && of_has(boots->flags, OF_RADIANCE) &&
  !square_isglow(cave, p->grid)) {
  if (!of_has(boots->known->flags, OF_RADIANCE) && one_in_(10)) {
   char short_name[80];
   char full_name[80];
   object_desc(short_name, sizeof(short_name), boots, ODESC_BASE, p);
   player_learn_flag(p, OF_RADIANCE);
   object_desc(full_name, sizeof(full_name), boots, ODESC_FULL, p);
   msg("Your footsteps leave a trail of light!");
   msg("You recognize your %s to be %s", short_name, full_name);
  }
  return true;
 }
 return false;
}
/**
 * Player falls in a pit, maybe spiked
 */
void player_fall_in_pit(struct player *p, bool spiked)
{
 /* Falling damage */
 int dam = damroll(2, 4);
 const char *prefix = square_apparent_look_prefix(cave, p->grid);
 char name[50];
 square_apparent_name(cave, p->grid, name, sizeof(name));
 msg("You fall into %s%s!", prefix, name);
 /* Update combat rolls */
 event_signal_combat_attack(EVENT_COMBAT_ATTACK, source_grid(p->grid),
          source_player(), true, -1, -1, -1, -1, false);
 event_signal_combat_damage(EVENT_COMBAT_DAMAGE, 2, 4, dam, -1, -1, 0, 0,
          PROJ_HURT, false);
 /* Take the damage */
 take_hit(p, dam, name);
 /* Make some noise */
 p->stealth_score -= 5;
 /* Deal with spikes */
 if (spiked) {
  int prt, net_dam;
  /* Extra spike damage */
  dam = damroll(4, 5);
  /* Protection */
  prt = protection_roll(p, PROJ_HURT, true, RANDOMISE);
  net_dam = (dam - prt > 0) ? (dam - prt) : 0;
  /* Update combat rolls */
  event_signal_combat_attack(EVENT_COMBAT_ATTACK, source_grid(p->grid),
           source_player(), true, -1, -1, -1, -1,
           false);
  event_signal_combat_damage(EVENT_COMBAT_DAMAGE, 4, 5, dam, -1, -1, prt,
           100, PROJ_HURT, true);
  if (net_dam > 0) {
   msg("You are impaled!");
   /* Take the damage */
   take_hit(p, net_dam, name);
   (void)player_inc_timed(p, TMD_CUT,
    p->timed[TMD_CUT] + (net_dam + 1) / 2,
    true, true, false);
  } else {
   msg("Your armour protects you.");
  }
  /* Make some more noise */
  p->stealth_score -= 5;
 }
}
/**
 * Player takes damage from falling
 */
void player_falling_damage(struct player *p, bool stun)
{
 int dice = 3, dam;
 const char *message;
 if (square_ischasm(cave, p->grid)) {
  if (p->depth != z_info->dun_depth - 2) {
   /* Fall two floors if there's room */
   dice = 6;
  }
        message = "falling down a chasm";
 } else if (square_isstairs(cave, p->grid) || square_isshaft(cave, p->grid)){
        message = "a collapsing stair";
 } else {
        message = "a collapsing floor";
    }
 /* Calculate the damage */
 dam = damroll(dice, 4);
 /* Update combat rolls */
 event_signal_combat_attack(EVENT_COMBAT_ATTACK, source_grid(p->grid),
          source_player(), true, -1, -1, -1, -1, false);
 event_signal_combat_damage(EVENT_COMBAT_DAMAGE, dice, 4, dam, -1, -1, 0, 0,
          PROJ_HURT, false);
 /* Take the damage */
 take_hit(p, dam, message);
 if (stun) {
  (void)player_inc_timed(p, TMD_STUN, dam * 5, true, true, true);
 }
 /* Reset staircasiness */
 p->staircasiness = 0;
}
/**
 * Player falls in a chasm
 */
void player_fall_in_chasm(struct player *p)
{
 /* Special handling for the tutorial */
 if (in_tutorial()) {
  tutorial_leave_section(p);
  return;
 }
 /* Several messages so the player has a chance to see it happen */
 msg("You fall into the darkness!");
 event_signal(EVENT_MESSAGE_FLUSH);
 msg("...and land somewhere deeper in the Iron Hells.");
 event_signal(EVENT_MESSAGE_FLUSH);
 /* Add to the history */
 history_add(p, "Fell into a chasm", HIST_FELL_IN_CHASM);
 /* Take some damage */
 player_falling_damage(p, false);
 /* New level */
 dungeon_change_level(p, MIN(p->depth + 2, z_info->dun_depth - 1));
}
/**
 * Does any flanking or controlled retreat attack necessary when player moves
 */
void player_flanking_or_retreat(struct player *p, struct loc grid)
{
 int d, start;
 struct monster *mon = target_get_monster();
 bool flanking = player_active_ability(p, "Flanking");
 bool controlled_retreat = false;
 /* No attack if player is confused or afraid, or if the truce is in force */
 if (p->timed[TMD_CONFUSED] || p->timed[TMD_AFRAID] || p->truce) return;
 /* Need to have the ability, and to have not moved last round */
 if (player_active_ability(p, "Controlled Retreat") &&
     ((p->previous_action[1] > 9) || (p->previous_action[1] == 5))) {
  controlled_retreat = true;
 }
 /* Player needs one of the abilities */
 if (!(flanking || controlled_retreat)) return;
 /* First see if the targetted monster is eligible and attack it if so */
 if (mon) {
  /* Base conditions for an attack */
  if (monster_is_visible(mon) && (!OPT(p, forgo_attacking_unwary) ||
          (mon->alertness >= ALERTNESS_ALERT))) {
   /* Try a flanking attack */
   if (flanking && (distance(p->grid, mon->grid) == 1) &&
    (distance(grid, mon->grid) == 1)) {
    py_attack(p, mon->grid, ATT_FLANKING);
    return;
   }
   /* Try a controlled retreat attack */
   if (controlled_retreat && (distance(p->grid, mon->grid) == 1) &&
    (distance(grid, mon->grid) > 1)) {
    py_attack(p, mon->grid, ATT_CONTROLLED_RETREAT);
    return;
   }
  }
 }
 /* Otherwise look through eligible monsters and choose one randomly */
 start = randint0(8);
 /* Look for adjacent monsters */
 for (d = start; d < 8 + start; d++) {
  struct loc check = loc_sum(p->grid, ddgrid_ddd[d % 8]);
  /* Check Bounds */
  if (!square_in_bounds(cave, check)) continue;
  /* Check for a monster, and player readiness */
  mon = square_monster(cave, check);
  if (mon) {
   /* Base conditions for an attack */
   if (monster_is_visible(mon) &&
    (!OPT(p, forgo_attacking_unwary) ||
     (mon->alertness >= ALERTNESS_ALERT))) {
    /* Try a flanking attack */
    if (flanking && (distance(p->grid, mon->grid) == 1) &&
     (distance(grid, mon->grid) == 1)) {
     py_attack(p, mon->grid, ATT_FLANKING);
     return;
    }
    /* Try a controlled retreat attack */
    if (controlled_retreat && (distance(p->grid, mon->grid) == 1) &&
     (distance(grid, mon->grid) > 1)) {
     py_attack(p, mon->grid, ATT_CONTROLLED_RETREAT);
     return;
    }
   }
  }
 }
}
/**
 * Does any opportunist or zone of control attack necessary when player moves
 *
 * Note the use of skip_next_turn to stop the player getting opportunist
 * attacks afer knocking back
 */
void player_opportunist_or_zone(struct player *p, struct loc grid1,
        struct loc grid2, bool opp_only)
{
 bool opp = player_active_ability(p, "Opportunist");
 bool zone = player_active_ability(p, "Zone of Control") && !opp_only;
 /* Monster */
 char m_name[80];
 struct monster *mon = square_monster(cave, grid1);
 /* Handle Opportunist and Zone of Control */
 if ((opp || zone) && monster_is_visible(mon) && !mon->skip_next_turn &&
  !p->truce && !p->timed[TMD_CONFUSED] && !p->timed[TMD_AFRAID] &&
  !p->timed[TMD_ENTRANCED] && (p->timed[TMD_STUN] < 100) &&
  (distance(grid1, p->grid) == 1) &&
  (!OPT(p, forgo_attacking_unwary) ||
   (mon->alertness >= ALERTNESS_ALERT))) {
  monster_desc(m_name, sizeof(m_name), mon, MDESC_STANDARD);
  /* Zone of control */
  if (zone && (distance(grid2, p->grid) == 1)) {
   msg("%s moves through your zone of control.", m_name);
   py_attack_real(p, grid1, ATT_ZONE_OF_CONTROL);
  }
  /* Opportunist */
  if (opp && (distance(grid2, p->grid) > 1)) {
   msg("%s moves away from you.", m_name);
   py_attack_real(p, grid1, ATT_OPPORTUNIST);
  }
 }
}
/**
 * Does any polearm attack when a monster moves close to the player
 */
void player_polearm_passive_attack(struct player *p, struct loc grid_from,
        struct loc grid_to)
{
 char m_name[80];
 struct monster *mon = square_monster(cave, grid_to);
 if (mon && monster_is_visible(mon)) {
  struct object *obj = equipped_item_by_slot_name(p, "weapon");
  if (!OPT(p, forgo_attacking_unwary) ||
   (mon->alertness >= ALERTNESS_ALERT)) {
   if ((distance(grid_from, p->grid) > 1) &&
    (distance(grid_to, p->grid) == 1) &&
    !p->truce && !p->timed[TMD_CONFUSED] &&
    !p->timed[TMD_AFRAID] && of_has(obj->flags, OF_POLEARM)
    && p->focused) {
    char o_name[80];
    /* Get the basic name of the object */
    object_desc(o_name, sizeof(o_name), obj, ODESC_BASE, p);
    monster_desc(m_name, sizeof(m_name), mon, MDESC_STANDARD);
    msg("%s comes into reach of your %s.", m_name, o_name);
    py_attack_real(p, grid_to, ATT_POLEARM);
   }
  }
 }
}
/**
 * Player is able to start a leap
 */
bool player_can_leap(struct player *p, struct loc grid, int dir)
{
 int i, d;
 bool run_up = false;
 struct loc mid, end;
 if (p->timed[TMD_CONFUSED]) return false;
 if (!square_isleapable(cave, grid)) return false;
 if (!player_active_ability(p, "Leaping")) return false;
 /* Test all three directions roughly towards the chasm/pit */
 for (i = -1; i <= 1; i++) {
  d = cycle[chome[dir_from_delta(grid.y - p->grid.y,
            grid.x - p->grid.x)] + i];
  /* If the last action was a move in this direction, run_up is valid */
  if (p->previous_action[1] == d) run_up = true;
 }
 /* Get location */
 mid = loc_sum(p->grid, ddgrid[dir]);
 end = loc_sum(mid, ddgrid[dir]);
 /* Disturb the player */
 disturb(p, false);
 /* Flush messages */
 event_signal(EVENT_MESSAGE_FLUSH);
 /* Test legality */
 if (square_ispit(cave, p->grid)) {
  /* Can't jump from within pits */
  msg("You cannot leap from within a pit.");
  return false;
 } else if (square_iswebbed(cave, p->grid)) {
  /* Can't jump from within webs */
  msg("You cannot leap from within a web.");
  return false;
 } else if (!run_up) {
  /* Can't jump without a run up */
  msg("You cannot leap without a run up.");
  return false;
 } else if (square_isknown(cave, end) && !square_ispassable(cave, end)) {
  /* Need room to land */
  msg("You cannot leap over as there is no room to land.");
  return false;
 }
 return true;
}
/**
 * Attempts to break free of a web.
 */
bool player_break_web(struct player *p)
{
 int difficulty = 7; //NRM - better related to the "trap"
 /* Capped so you always have some chance */
 int score = MAX(p->state.stat_use[STAT_STR] * 2, difficulty - 8);
 /* Disturb the player */
 disturb(p, false);
 /* Free action helps a lot */
 difficulty -= 10 * p->state.flags[OF_FREE_ACT];
 /* Spider bane bonus helps */
 difficulty -= player_spider_bane_bonus(p);
 if (skill_check(source_player(), score, difficulty, source_none()) <= 0) {
  msg("You fail to break free of the web.");
  /* Take a full turn */
  p->upkeep->energy_use = z_info->move_energy;
  /* Store the action type */
  p->previous_action[0] = ACTION_MISC;
  return false;
 } else {
  msg("You break free!");
  square_destroy_trap(cave, p->grid);
  return true;
 }
}
/**
 * Attempts to climb out of a pit.
 */
bool player_escape_pit(struct player *p)
{
 /* Disturb the player */
 disturb(p, false);
 if (check_hit(square_pit_difficulty(cave, p->grid), false,
      source_grid(p->grid))) {
  msg("You try to climb out of the pit, but fail.");
  /* Take a full turn */
  p->upkeep->energy_use = z_info->move_energy;
  /* Store the action type */
  p->previous_action[0] = ACTION_MISC;
  return false;
 }
 msg("You climb out of the pit.");
 return true;
}
/**
 * Aim a horn of blasting at the ceiling
 */
void player_blast_ceiling(struct player *p)
{
 int will = p->state.skill_use[SKILL_WILL];
 if (player_active_ability(p, "Channeling")) {
  will += 5;
 }
 /* Skill check of Will vs 10 */
 if (skill_check(source_player(), will, 10, source_none()) > 0) {
  int dam = damroll(4, 8);
  int prt = protection_roll(p, PROJ_HURT, false, RANDOMISE);
  int net_dam = MAX(0, dam - prt);
  msg("The ceiling cracks and rock rains down upon you!");
  effect_simple(EF_EARTHQUAKE, source_player(), "0", 0, 3, 0, NULL);
  /* Update combat rolls */
  event_signal_combat_attack(EVENT_COMBAT_ATTACK, source_player(),
           source_player(), true, -1, -1, -1, -1,
           false);
  event_signal_combat_damage(EVENT_COMBAT_DAMAGE, 4, 8, dam, -1, -1, prt,
           100, PROJ_HURT, false);
  take_hit(p, net_dam, "a collapsing ceiling");
  (void)player_inc_timed(p, TMD_STUN, dam * 4, true, true, true);
 } else {
  msg("The blast hits the ceiling, but you did not blow hard enough to bring it down.");
 }
}
/**
 * Aim a horn of blasting at the floor
 */
void player_blast_floor(struct player *p)
{
 int will = p->state.skill_use[SKILL_WILL];
 if (player_active_ability(p, "Channeling")) {
  will += 5;
 }
 /* Skill check of Will vs 10 */
 if (skill_check(source_player(), will, 10, source_none()) > 0) {
  if (p->depth < z_info->dun_depth - 1 && !in_tutorial()) {
   msg("The floor crumbles beneath you!");
   event_signal(EVENT_MESSAGE_FLUSH);
   msg("You fall through...");
   event_signal(EVENT_MESSAGE_FLUSH);
   msg("...and land somewhere deeper in the Iron Hells.");
   event_signal(EVENT_MESSAGE_FLUSH);
   /* Add to the history */
   history_add(p, "Fell through the floor with a horn blast.",
      HIST_FELL_DOWN_LEVEL);
   /* Take some damage */
   player_falling_damage(p, true);
   event_signal(EVENT_MESSAGE_FLUSH);
   /* Change level */
   dungeon_change_level(p, p->depth + 1);
  } else {
   msg("Cracks spread across the floor, but it holds firm.");
  }
 } else {
  msg("The blast hits the floor, but you did not blow hard enough to collapse it.");
 }
}
/**
 * Find a skill given its name
 */
int lookup_skill(const char *name)
{
 int i;
 for (i = 0; i < SKILL_MAX; i++) {
  if (streq(skill_names[i], name)) {
   return i;
  }
 }
 msg("Could not find %s skill!", name);
 return -1;
}
/**
 * Check if the player moved n moves ago
 */
bool player_action_is_movement(struct player *p, int n)
{
 return ((p->previous_action[n] != ACTION_NOTHING) &&
   (p->previous_action[n] != ACTION_MISC) &&
   (p->previous_action[n] != ACTION_STAND));
}
/**
 * Determines the size of the player evasion bonus due to dodging (if any)
 */
int player_dodging_bonus(struct player *p)
{
 if (player_active_ability(p, "Dodging") && player_action_is_movement(p, 0)){
  return 3;
 } else {
  return 0;
 }
}
/**
 * Player can riposte
 */
bool player_can_riposte(struct player *p, int hit_result)
{
 struct object *weapon = equipped_item_by_slot_name(p, "weapon");
 return (weapon && player_active_ability(p, "Riposte") &&
   !p->upkeep->riposte &&
   !p->timed[TMD_AFRAID] &&
   !p->timed[TMD_CONFUSED] &&
   !p->timed[TMD_ENTRANCED] &&
   (p->timed[TMD_STUN] <= 100) &&
   (hit_result <= -10 - ((weapon->weight + 9) / 10)));
}
/**
 * Check if the player is sprinting
 */
bool player_is_sprinting(struct player *p)
{
 int i;
 int turns = 1;
 if (player_active_ability(p, "Sprinting")) {
  for (i = 1; i < 4; i++) {
   if (player_action_is_movement(p, i) &&
    player_action_is_movement(p, i + 1)) {
    if (p->previous_action[i] == p->previous_action[i + 1]) {
     /* Moving in the same direction */
     turns++;
    } else if (p->previous_action[i] ==
         cycle[chome[p->previous_action[i + 1]] - 1]) {
     turns++;
    } else if (p->previous_action[i] ==
         cycle[chome[p->previous_action[i + 1]] + 1]) {
     turns++;
    }
   }
  }
 }
 return (turns >= 4);
}
static const int bane_flag[] = {
/**
 * \file src/list-bane-types.h
 * \brief player bane types
 */
RF_NONE,
RF_ORC,
RF_WOLF,
RF_SPIDER,
RF_TROLL,
RF_UNDEAD,
RF_RAUKO,
RF_SERPENT,
RF_DRAGON,

};
int player_bane_type_killed(int bane_type)
{
 int j, k;
 if (bane_type < 0 || bane_type >= (int)N_ELEMENTS(bane_flag)) {
  return 0;
 }
 /* Scan the monster races */
 for (j = 1, k = 0; j < z_info->r_max; j++) {
  struct monster_race *race = &r_info[j];
  struct monster_lore *lore = get_lore(race);
  if (rf_has(race->flags, bane_flag[bane_type])) {
   k += lore->pkills;
  }
 }
 return k;
}
int calc_bane_bonus(struct player *p)
{
 int i = 2;
 int bonus = 0;
 int killed = player_bane_type_killed(p->bane_type);
 while (i <= killed) {
  i *= 2;
  bonus++;
 }
 return bonus;
}
int player_bane_bonus(struct player *p, struct monster *mon)
{
 int bonus = 0;
 /* Paranoia */
 if (!mon) return 0;
 /* Entranced players don't get the bonus */
 if (p->timed[TMD_ENTRANCED]) return 0;
 /* Knocked out players don't get the bonus */
 if (player_timed_grade_eq(p, TMD_STUN, "Knocked Out")) return 0;
 /* Calculate the bonus */
 if (rf_has(mon->race->flags, bane_flag[p->bane_type])) {
  bonus = calc_bane_bonus(p);
 }
 return bonus;
}
int player_spider_bane_bonus(struct player *p)
{
 return (bane_flag[p->bane_type] == RF_SPIDER) ? calc_bane_bonus(p) : 0;
}
/**
 * Return true if the player can fire something with a launcher.
 *
 * \param p is the player
 * \param show_msg should be set to true if a failure message should be
 * displayed.
 */
bool player_can_fire(struct player *p, bool show_msg)
{
 struct object *obj = equipped_item_by_slot_name(p, "shooting");
 /* Require a usable launcher */
 if (!obj || !p->state.ammo_tval) {
  if (show_msg)
   msg("You have nothing to fire with.");
  return false;
 }
 return true;
}
/**
 * Return true if the player can fire from the first quiver.
 *
 * \param p is the player
 * \param show_msg should be set to true if a failure message should be
 * displayed.
 */
bool player_can_fire_quiver1(struct player *p, bool show_msg)
{
 const struct object *ammo;
 if (!player_can_fire(p, show_msg)) {
  return false;
 }
 ammo = equipped_item_by_slot_name(p, "first quiver");
 if (!ammo) {
  if (show_msg) {
   msg("You have nothing in the first quiver to fire.");
  }
  return false;
 }
 if (ammo->tval != p->state.ammo_tval) {
  if (show_msg) {
   msg("The ammunition in the first quiver is not compatible with your launcher.");
  }
  return false;
 }
 return true;
}
/**
 * Return true if the player can fire from the second quiver.
 *
 * \param p is the player
 * \param show_msg should be set to true if a failure message should be
 * displayed.
 */
bool player_can_fire_quiver2(struct player *p, bool show_msg)
{
 const struct object *ammo;
 if (!player_can_fire(p, show_msg)) {
  return false;
 }
 ammo = equipped_item_by_slot_name(p, "second quiver");
 if (!ammo) {
  if (show_msg) {
   msg("You have nothing in the second quiver to fire.");
  }
  return false;
 }
 if (ammo->tval != p->state.ammo_tval) {
  if (show_msg) {
   msg("The ammunition in the second quiver is not compatible with your launcher.");
  }
  return false;
 }
 return true;
}
/**
 * Return true if the player can refuel their light source.
 *
 * \param p is the player
 * \param show_msg should be set to true if a failure message should be
 * displayed.
 */
bool player_can_refuel(struct player *p, bool show_msg)
{
 struct object *obj = equipped_item_by_slot_name(p, "light");
 if (!obj && show_msg) {
  msg("You are not wielding a light");
 }
 if (of_has(obj->flags, OF_TAKES_FUEL) || of_has(obj->flags, OF_BURNS_OUT)) {
  return true;
 }
 if (show_msg) {
  msg("Your light cannot be refuelled.");
 }
 return false;
}
/**
 * Prerequisite function for command. See struct cmd_info in ui-input.h and
 * it's use in ui-game.c.
 */
bool player_can_fire_prereq(void)
{
 return player_can_fire(player, true);
}
/**
 * Prerequisite function for command. See struct cmd_info in ui-input.h and
 * it's use in ui-game.c.
 */
bool player_can_fire_quiver1_prereq(void)
{
 return player_can_fire_quiver1(player, true);
}
/**
 * Prerequisite function for command. See struct cmd_info in ui-input.h and
 * it's use in ui-game.c.
 */
bool player_can_fire_quiver2_prereq(void)
{
 return player_can_fire_quiver2(player, true);
}
/**
 * Prerequisite function for command. See struct cmd_info in ui-input.h and
 * it's use in ui-game.c.
 */
bool player_can_refuel_prereq(void)
{
 return player_can_refuel(player, true);
}
/**
 * Prerequisite function for command. See struct cmd_info in ui-input.h and
 * it's use in ui-game.c.
 */
bool player_can_debug_prereq(void)
{
 if (player->noscore & NOSCORE_DEBUG) {
  return true;
 }
 if (confirm_debug()) {
  /* Mark savefile */
  player->noscore |= NOSCORE_DEBUG;
  return true;
 }
 return false;
}
/**
 * Prerequisite function for command. See struct cmd_info in ui-input.h and
 * its use in ui-game.c.
 */
bool player_can_save_prereq(void)
{
 return !in_tutorial();
}
/**
 * Apply confusion, if needed, to a direction
 *
 * Display a message and return true if direction changes.
 */
bool player_confuse_dir(struct player *p, int *dp, bool too)
{
 int dir = *dp;
 if (p->timed[TMD_CONFUSED]) {
  if ((dir == 5) || (randint0(100) < 75)) {
   /* Random direction */
   dir = ddd[randint0(8)];
  }
  /* Running attempts always fail */
  if (too) {
   msg("You are too confused.");
   return true;
  }
  if (*dp != dir) {
   msg("You are confused.");
   *dp = dir;
   return true;
  }
 }
 return false;
}
/**
 * Return true if the provided count is one of the conditional REST_ flags.
 */
bool player_resting_is_special(int16_t count)
{
 switch (count) {
  case REST_COMPLETE:
  case REST_ALL_POINTS:
  case REST_SOME_POINTS:
   return true;
 }
 return false;
}
/**
 * Return true if the player is resting.
 */
bool player_is_resting(const struct player *p)
{
 return (p->upkeep->resting > 0 ||
   player_resting_is_special(p->upkeep->resting));
}
/**
 * Return the remaining number of resting turns.
 */
int16_t player_resting_count(const struct player *p)
{
 return p->upkeep->resting;
}
/**
 * In order to prevent the regeneration bonus from the first few turns, we have
 * to store the number of turns the player has rested. Otherwise, the first
 * few turns will have the bonus and the last few will not.
 */
static int player_turns_rested = 0;
static bool player_rest_disturb = false;
/**
 * Set the number of resting turns.
 *
 * \param count is the number of turns to rest or one of the REST_ constants.
 */
void player_resting_set_count(struct player *p, int16_t count)
{
 /* Cancel if player is disturbed */
 if (player_rest_disturb) {
  p->upkeep->resting = 0;
  player_rest_disturb = false;
  return;
 }
 /* Ignore if the rest count is negative. */
 if ((count < 0) && !player_resting_is_special(count)) {
  p->upkeep->resting = 0;
  return;
 }
 /* Save the rest code */
 p->upkeep->resting = count;
 /* Truncate overlarge values */
 if (p->upkeep->resting > 9999) p->upkeep->resting = 9999;
}
/**
 * Cancel current rest.
 */
void player_resting_cancel(struct player *p, bool disturb)
{
 player_resting_set_count(p, 0);
 player_turns_rested = 0;
 player_rest_disturb = disturb;
}
/**
 * Return true if the player should get a regeneration bonus for the current
 * rest.
 */
bool player_resting_can_regenerate(const struct player *p)
{
 return player_turns_rested >= REST_REQUIRED_FOR_REGEN ||
  player_resting_is_special(p->upkeep->resting);
}
/**
 * Perform one turn of resting. This only handles the bookkeeping of resting
 * itself, and does not calculate any possible other effects of resting (see
 * process_world() for regeneration).
 */
void player_resting_step_turn(struct player *p)
{
 /* Timed rest */
 if (p->upkeep->resting > 0) {
  /* Reduce rest count */
  p->upkeep->resting--;
  /* Redraw the state */
  p->upkeep->redraw |= (PR_STATE);
 }
 /* Take a turn */
 p->upkeep->energy_use = z_info->move_energy;
 /* Store the action type */
 p->previous_action[0] = ACTION_STAND;
 /* Store the 'focus' attribute */
 p->focused = true;
 /* Searching */
 search(p);
 /* Increment the resting counters */
 p->resting_turn++;
 player_turns_rested++;
}
/**
 * Handle the conditions for conditional resting (resting with the REST_
 * constants).
 */
void player_resting_complete_special(struct player *p)
{
 /* Complete resting */
 if (!player_resting_is_special(p->upkeep->resting)) return;
 if (p->upkeep->resting == REST_ALL_POINTS) {
  if ((p->chp == p->mhp) && (p->csp == p->msp))
   /* Stop resting */
   disturb(p, false);
 } else if (p->upkeep->resting == REST_COMPLETE) {
  if ((p->chp == p->mhp) &&
   (p->csp == p->msp || !player_is_singing(p, NULL)) &&
   !p->timed[TMD_BLIND] && !p->timed[TMD_CONFUSED] &&
   !p->timed[TMD_POISONED] && !p->timed[TMD_AFRAID] &&
   !p->timed[TMD_STUN] &&
   !p->timed[TMD_CUT] && !p->timed[TMD_SLOW] &&
   !p->timed[TMD_ENTRANCED] && !p->timed[TMD_IMAGE])
   /* Stop resting */
   disturb(p, false);
 } else if (p->upkeep->resting == REST_SOME_POINTS) {
  if ((p->chp == p->mhp) || (p->csp == p->msp))
   /* Stop resting */
   disturb(p, false);
 }
}
/* Record the player's last rest count for repeating */
static int player_resting_repeat_count = 0;
/**
 * Get the number of resting turns to repeat.
 *
 * \param p The current player.
 */
int player_get_resting_repeat_count(struct player *p)
{
 return player_resting_repeat_count;
}
/**
 * Set the number of resting turns to repeat.
 *
 * \param count is the number of turns requested for rest most recently.
 */
void player_set_resting_repeat_count(struct player *p, int16_t count)
{
 player_resting_repeat_count = count;
}
/**
 * Check if the player resists (or better) an element
 */
bool player_resists(const struct player *p, int element)
{
 return (p->state.el_info[element].res_level > 0);
}
/**
 * Places the player at the given coordinates in the cave.
 */
void player_place(struct chunk *c, struct player *p, struct loc grid)
{
 assert(!square_monster(c, grid));
 /* Save player location */
 p->grid = grid;
 /* Mark cave grid */
 square_set_mon(c, grid, -1);
}
/**
 * Take care of bookkeeping after moving the player with monster_swap().
 *
 * \param p is the player that was moved.
 * \param eval_trap, if true, will cause evaluation (possibly affecting the
 * player) of the traps in the grid.
 * \param is_involuntary, if true, will do appropriate actions (flush the
 * command queue) for a move not expected by the player.
 */
void player_handle_post_move(struct player *p, bool eval_trap,
        bool is_involuntary)
{
 /* Flush command queue for involuntary moves */
 if (is_involuntary) {
  cmdq_flush();
 }
 /* Notice objects */
 square_know_pile(cave, p->grid);
 /* Discover stairs if blind */
 if (square_isstairs(cave, p->grid)) {
  square_memorize(cave, p->grid);
  square_light_spot(cave, p->grid);
 }
 /* Remark on Forge and discover it if blind */
 if (square_isforge(cave, p->grid)) {
  struct feature *feat = square_feat(cave, p->grid);
  if ((feat->fidx == FEAT_FORGE_UNIQUE) && !p->unique_forge_seen) {
   msg("You enter the forge 'Orodruth' - the Mountain's Anger - where Grond was made in days of old.");
   msg("The fires burn still.");
   p->unique_forge_seen = true;
   history_add(p, "Entered the forge 'Orodruth'", HIST_FORGE_FOUND);
  } else {
   const char *article = square_apparent_look_prefix(cave, p->grid);
   char name[50];
   square_apparent_name(cave, p->grid, name, sizeof(name));
   msg("You enter %s%s.", article, name);
  }
  square_memorize(cave, p->grid);
  square_light_spot(cave, p->grid);
 }
 /* Discover invisible traps, set off visible ones */
 if (eval_trap && square_isplayertrap(cave, p->grid)) {
  disturb(p, false);
  square_reveal_trap(cave, p->grid, true);
  hit_trap(p->grid);
 } else if (square_ischasm(cave, p->grid)) {
  player_fall_in_chasm(p);
 }
 /* Check for having left the level by falling */
 if (!p->upkeep->generate_level) {
  /* Update view */
  update_view(cave, p);
  cmdq_push(CMD_AUTOPICKUP);
  /*
		 * The autopickup is a side effect of the move:  whatever
		 * command triggered the move will be the target for CMD_REPEAT
		 * rather than repeating the autopickup.
		 */
  cmdq_peek()->is_background_command = true;
 }
}
/**
 * Something has happened to disturb the player.
 *
 * All disturbance cancels repeated commands, resting, and running.
 * Stealth mode is canceled if the second argument is true.
 *
 * XXX-AS: Make callers either pass in a command
 * or call cmd_cancel_repeat inside the function calling this
 */
void disturb(struct player *p, bool stop_stealth)
{
 int repeats = cmd_get_nrepeats();
 /* Cancel repeated commands */
 cmd_cancel_repeat();
 /* Cancel Resting */
 if (player_is_resting(p)) {
  player_resting_cancel(p, true);
  p->upkeep->redraw |= PR_STATE;
 }
 /* Cancel Smithing */
 if (p->upkeep->smithing) {
  /* Cancel */
  p->upkeep->smithing = false;
  /* Store the number of smithing turns left */
  p->smithing_leftover = repeats;
  /* Display a message */
  msg("Your work is interrupted!");
  /* Redraw the state (later) */
  p->upkeep->redraw |= (PR_STATE);
 }
 /* Cancel running */
 if (p->upkeep->running) {
  p->upkeep->running = 0;
  /* Cancel queued commands */
  cmdq_flush();
  /* Check for new panel if appropriate */
  event_signal(EVENT_PLAYERMOVED);
  p->upkeep->update |= PU_TORCH;
  /* Mark the whole map to be redrawn */
  event_signal_point(EVENT_MAP, -1, -1);
 }
 /* Cancel stealth if requested */
 if (stop_stealth && p->stealth_mode) {
  /* Signal that it will be stopped at the end of the turn */
  p->stealth_mode = STEALTH_MODE_STOPPING;
 }
 /* Flush input */
 event_signal(EVENT_INPUT_FLUSH);
}
/**
 * Search a single square for hidden things 
 * (a utility function called by 'search' and 'perceive')
 */
static void search_square(struct player *p, struct loc grid, int dist,
        int searching)
{
 int score = 0;
 int difficulty = 0;
 struct object *obj = chest_check(p, grid, CHEST_TRAPPED);
 int chest_level = obj && is_trapped_chest(obj) ? obj->pval : 0;
 /* If searching, discover unknown adjacent squares of interest */
 if (searching) {
  if ((dist == 1) && !square_isknown(cave, grid)) {
   struct object *square_obj = square_object(cave, grid);
   /* Remember all non-floor non-trap squares */
   if (!(square_isfloor(cave, grid) ||
     square_issecrettrap(cave, grid))) {
    square_memorize(cave, grid);
   }
   /* Mark an object, but not the square it is in */
   if (square_obj) {
    square_know_pile(cave, grid);
   }
   square_light_spot(cave, grid);
  }
 }
 /* If there is anything to notice... */
 if (obj || square_issecrettrap(cave, grid) ||
  square_issecretdoor(cave, grid)) {
  /* Give up if the square is unseen and not adjacent */
  if ((dist > 1) && !square_isseen(cave, grid)) return;
  /* Determine the base score */
  score = p->state.skill_use[SKILL_PERCEPTION];
  /* If using the search command give a score bonus */
  if (searching) score += 5;
  /* Eye for Detail ability */
  if (player_active_ability(p, "Eye for Detail")) score += 5;
  /* Determine the base difficulty */
  if (obj) {
   difficulty = chest_level / 2;
  } else {
   if (p->depth > 0) {
    difficulty = p->depth / 2;
   } else {
    difficulty = 10;
   }
  }
  /* Penalise distance */
  if (dist < 1) {
   /* No bonus for searching on your own square */
   dist = 1;
  }
  difficulty += 5 * (dist - 1);
  /* Give various penalties */
  if (p->timed[TMD_BLIND] || no_light(p) || p->timed[TMD_IMAGE]) {
   /* Can't see properly */
   difficulty += 5;
  }
  if (p->timed[TMD_CONFUSED]) {
   /* Confused */
   difficulty += 5;
  }
  if (square_issecrettrap(cave, grid)) {
   /* Dungeon trap */
   difficulty += 5;
  }
  if (square_issecretdoor(cave, grid)) {
   /* Secret door */
   difficulty += 10;
  }
  if (obj) {
   /* Chest trap */
   difficulty += 15;
  }
  /* Spider bane bonus helps to find webs */
  if (square_iswebbed(cave, grid)) {
   difficulty -= player_spider_bane_bonus(p);
  }
  /* Sometimes, notice things */
  if (skill_check(source_player(), score, difficulty, source_none()) > 0){
   /* Traps */
   if (square_issecrettrap(cave, grid)) {
    square_reveal_trap(cave, grid, true);
    disturb(p, false);
   }
   /* Secret doors */
   if (square_issecretdoor(cave, grid)) {
    msg("You have found a secret door.");
    place_closed_door(cave, grid);
    disturb(p, false);
   }
   /* Traps on chests */
   if (obj && obj->known && !obj->known->pval) {
    msg("You have discovered a trap on the chest!");
    obj->known->pval = obj->pval;
    disturb(p, false);
   }
  }
 }
}
/**
 * Search for adjacent hidden things
 */
void search(struct player *p)
{
 struct loc grid;
 /* Search the adjacent grids */
 for (grid.y = (p->grid.y - 1); grid.y <= (p->grid.y + 1); grid.y++) {
  for (grid.x = (p->grid.x - 1); grid.x <= (p->grid.x + 1); grid.x++) {
   if (!loc_eq(grid, p->grid)) {
    search_square(p, grid, 1, true);
   }
  }
 }
 /* Also make the normal perception check */
 perceive(p);
}
/**
 * Maybe notice hidden things nearby
 */
void perceive(struct player *p)
{
 struct loc grid;
 /* Search nearby grids */
 for (grid.y = (p->grid.y - 4); grid.y <= (p->grid.y + 4); grid.y++) {
  for (grid.x = (p->grid.x - 4); grid.x <= (p->grid.x + 4); grid.x++) {
   if (square_in_bounds(cave, grid)) {
    int dist = distance(p->grid, grid);
    /* Search only if adjacent, player lit or permanently lit */
    if ((dist <= 1) || (p->upkeep->cur_light >= dist) ||
     square_isglow(cave, grid)) {
     /* Search only if within four grids and in line of sight */
     if ((dist <= 4) && los(cave, p->grid, grid)) {
      search_square(p, grid, dist, false);
     }
    }
   }
  }
 }
}
/**
 * \file player.c
 * \brief Player implementation
 *
 * Copyright (c) 2011 elly+angband@leptoquark.net. See COPYING.
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Pointer to the player struct
 */
struct player *player = NULL;
struct player_body *bodies;
struct player_race *races;
struct player_sex *sexes;
struct player_house *houses;
struct player_ability *player_abilities;
struct player_race *player_id2race(guid id)
{
 struct player_race *r;
 for (r = races; r; r = r->next)
  if (guid_eq(r->ridx, id))
   break;
 return r;
}
struct player_house *player_id2house(guid id)
{
 struct player_house *h;
 for (h = houses; h; h = h->next)
  if (guid_eq(h->hidx, id))
   break;
 return h;
}
struct player_house *player_house_from_count(int idx)
{
 unsigned int min = 100;
 struct player_house *h;
 const struct player_race *race = player->race;
 for (h = houses; h; h = h->next) {
  if ((h->race == race) && (h->hidx < min)) min = h->hidx;
 }
 for (h = houses; h; h = h->next) {
  if ((h->race == race) && (h->hidx == min + idx)) return h;
 }
 return NULL;
}
struct player_sex *player_id2sex(guid id)
{
 struct player_sex *s;
 for (s = sexes; s; s = s->next)
  if (guid_eq(s->sidx, id))
   break;
 return s;
}
static const char *stat_name_list[] = {
/**
 * \file src/list-stats.h
 * \brief player stats
 *
 * Changing stat order or making new ones will break savefiles. Stats
 * below start from 0 on line 14, so a stat's sequence number is its line
 * number minus 14.
 *
 * Each stat has a matching sustain in src/list-object-flags.h, which should
 * be at the same index in that file as the stat in this file.
 *
 * Stat properties are defined in lib/gamedata/object_property.txt
 */
"STR",
"DEX",
"CON",
"GRA",

 "MAX",
    NULL
};
int stat_name_to_idx(const char *name)
{
    int i;
    for (i = 0; stat_name_list[i]; i++) {
        if (!my_stricmp(name, stat_name_list[i]))
            return i;
    }
    return -1;
}
const char *stat_idx_to_name(int type)
{
    assert(type >= 0);
    assert(type < STAT_MAX);
    return stat_name_list[type];
}
/**
 * Increase a stat by one level
 *
 * Most code will "restore" a stat before calling this function,
 * in particular, stat potions will always restore the stat and
 * then increase the fully restored value.
 */
bool player_stat_inc(struct player *p, int stat)
{
 /* Cannot go above BASE_STAT_MAX */
 if (p->stat_base[stat] < BASE_STAT_MAX) {
  p->stat_base[stat]++;
  /* Recalculate bonuses */
  p->upkeep->update |= (PU_BONUS);
  /* Redisplay the stats later */
  p->upkeep->redraw |= (PR_STATS);
  /* Success */
  return true;
 }
 /* Nothing to gain */
 return false;
}
/**
 * Increase a stat by a number of points
 *
 * Return true only if this actually makes a difference.
 */
bool player_stat_res(struct player *p, int stat, int points)
{
 /* Restore if needed */
 if (p->stat_drain[stat] < 0) {
  p->stat_drain[stat] += points;
  if (p->stat_drain[stat] > 0) p->stat_drain[stat] = 0;
  /* Recalculate bonuses */
  p->upkeep->update |= (PU_BONUS);
  /* Redisplay the stats later */
  p->upkeep->redraw |= (PR_STATS);
  /* Success */
  return true;
 }
 /* Nothing to gain */
 return false;
}
/**
 * Decreases a stat by one level.
 */
void player_stat_dec(struct player *p, int stat)
{
 /* Temporary damage */
 p->stat_drain[stat]--;
 /* Recalculate bonuses */
 p->upkeep->update |= (PU_BONUS);
 /* Redisplay the stats later */
 p->upkeep->redraw |= (PR_STATS);
}
/**
 * Advance experience levels and print experience
 */
static void check_experience(struct player *p)
{
 /* Limits */
 p->exp = MIN(MAX(p->exp, 0), PY_MAX_EXP);
 p->new_exp = MIN(MAX(p->new_exp, 0), PY_MAX_EXP);
 p->new_exp = MIN(p->new_exp, p->exp);
 /* Redraw experience */
 p->upkeep->redraw |= (PR_EXP);
 /* Redraw stuff */
 redraw_stuff(p);
}
/**
 * Gain experience
 */
void player_exp_gain(struct player *p, int32_t amount)
{
 /* Gain some experience */
 p->exp += amount;
 p->new_exp += amount;
 /* Check Experience */
 check_experience(p);
}
/**
 * Lose experience
 */
void player_exp_lose(struct player *p, int32_t amount)
{
 /* Never drop below zero new experience */
 if (amount > p->new_exp) amount = p->new_exp;
 /* Lose some experience */
 p->exp -= amount;
 p->new_exp -= amount;
 /* Check Experience */
 check_experience(p);
}
/**
 * Obtain object flags for the player
 */
void player_flags(struct player *p, bitflag f[OF_SIZE])
{
 /* Add racial flags */
 memcpy(f, p->race->pflags, sizeof(p->race->pflags));
}
/**
 * Combine any flags due to timed effects on the player into those in f.
 */
void player_flags_timed(struct player *p, bitflag f[OF_SIZE])
{
 if (p->timed[TMD_SINVIS]) {
  of_on(f, OF_SEE_INVIS);
 }
}
uint8_t player_hp_attr(struct player *p)
{
 uint8_t attr;
 if (p->chp >= p->mhp)
  attr = COLOUR_L_GREEN;
 else if (p->chp > (p->mhp * p->opts.hitpoint_warn) / 10)
  attr = COLOUR_YELLOW;
 else
  attr = COLOUR_RED;
 return attr;
}
uint8_t player_sp_attr(struct player *p)
{
 uint8_t attr;
 if (p->csp >= p->msp)
  attr = COLOUR_L_GREEN;
 else if (p->csp > (p->msp * p->opts.hitpoint_warn) / 10)
  attr = COLOUR_YELLOW;
 else
  attr = COLOUR_RED;
 return attr;
}
bool player_restore_mana(struct player *p, int amt) {
 int old_csp = p->csp;
 p->csp += amt;
 if (p->csp > p->msp) {
  p->csp = p->msp;
 }
 p->upkeep->redraw |= PR_MANA;
 msg("You feel some of your energies returning.");
 return p->csp != old_csp;
}
/**
 * Construct a random player name appropriate for the setting.
 *
 * \param buf is the buffer to contain the name.  Must have space for at
 * least buflen characters.
 * \param buflen is the maximum number of character that can be written to
 * buf.
 * \return the number of characters, excluding the terminating null, written
 * to the buffer
 */
size_t player_random_name(char *buf, size_t buflen)
{
 size_t result = randname_make(RANDNAME_TOLKIEN, 4, 8, buf, buflen,
  name_sections);
 my_strcap(buf);
 return result;
}
/**
 * Return a version of the player's name safe for use in filesystems.
 *
 * XXX This does not belong here.
 */
void player_safe_name(char *safe, size_t safelen, const char *name, bool strip_suffix)
{
 size_t i;
 size_t limit = 0;
 if (name) {
  char *suffix = find_roman_suffix_start(name);
  if (suffix) {
   limit = suffix - name - 1; /* -1 for preceding space */
  } else {
   limit = strlen(name);
  }
 }
 /* Limit to maximum size of safename buffer */
 limit = MIN(limit, safelen);
 for (i = 0; i < limit; i++) {
  char c = name[i];
  /* Convert all non-alphanumeric symbols */
  if (!isalpha((unsigned char)c) && !isdigit((unsigned char)c))
   c = '_';
  /* Build "base_name" */
  safe[i] = c;
 }
 /* Terminate */
 safe[i] = '\0';
 /* Require a "base" name */
 if (!safe[0])
  my_strcpy(safe, "PLAYER", safelen);
}
/**
 * Release resources allocated for fields in the player structure.
 */
void player_cleanup_members(struct player *p)
{
 /* Free the history */
 history_clear(p);
 mem_free(p->timed);
 if (p->upkeep) {
  mem_free(p->upkeep->inven);
  mem_free(p->upkeep);
  p->upkeep = NULL;
 }
 if (p->obj_k) {
  object_free(p->obj_k);
  p->obj_k = NULL;
 }
 mem_free(p->vaults);
 /* Free the things that are only sometimes initialised */
 if (p->gear) {
  object_pile_free(NULL, NULL, p->gear);
  object_pile_free(NULL, NULL, p->gear_k);
 }
 if (p->body.slots) {
  for (int i = 0; i < p->body.count; i++)
   string_free(p->body.slots[i].name);
  mem_free(p->body.slots);
 }
 string_free(p->body.name);
 string_free(p->history);
 release_ability_list(p->abilities);
 release_ability_list(p->item_abilities);
 if (p->cave) {
  cave_free(p->cave);
  p->cave = NULL;
 }
}
/**
 * Initialise player struct
 */
static void init_player(void) {
 /* Create the player array, initialised with 0 */
 player = mem_zalloc(sizeof *player);
 /* Allocate player sub-structs */
 player->upkeep = mem_zalloc(sizeof(struct player_upkeep));
 player->upkeep->inven = mem_zalloc((z_info->pack_size + 1) * sizeof(struct object *));
 player->timed = mem_zalloc(TMD_MAX * sizeof(int16_t));
 player->obj_k = object_new();
 player->obj_k->brands = mem_zalloc(z_info->brand_max * sizeof(bool));
 player->obj_k->slays = mem_zalloc(z_info->slay_max * sizeof(bool));
 player->vaults = mem_zalloc(z_info->v_max * sizeof(int16_t));
 options_init_defaults(&player->opts);
}
/**
 * Free player struct
 */
static void cleanup_player(void) {
 if (!player) return;
 player_cleanup_members(player);
 /* Free the basic player struct */
 mem_free(player);
 player = NULL;
}
struct init_module player_module = {
 .name = "player",
 .init = init_player,
 .cleanup = cleanup_player
};
/**
 * \file project.c
 * \brief The project() function and helpers
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
struct projection *projections;
/*
 * Specify attr/char pairs for visual special effects for project()
 * Ideally move these and PROJ-type colors to the UI - NRM
 */
uint8_t proj_to_attr[PROJ_MAX][BOLT_MAX];
wchar_t proj_to_char[PROJ_MAX][BOLT_MAX];
/**
 * ------------------------------------------------------------------------
 * PROJ type info needed for projections
 *
 * Note that elements come first, so PROJ_ACID == ELEM_ACID, etc
 * ------------------------------------------------------------------------ */
static const char *proj_name_list[] =
{
/**
 * \file list-elements.h
 * \brief Elements used in spells and other attacks.
 */
"ACID",
"FIRE",
"COLD",
"POIS",
"DARK",
/**
 * \file list-projections.h
 * \brief Spell types used by project() and related functions.
 *
 * ===== NOTICE =====
 * If you add new entries to this file, you must
 * also update lib/gamedata/projection.txt!
 * ===== NOTICE =====
 */
"NOTHING",
"HURT",
"ARROW",
"BOULDER",
"SOUND",
"FORCE",
"LIGHT",
"KILL_WALL",
"SLEEP",
"SPEED",
"SLOW",
"CONFUSION",
"FEAR",
"EARTHQUAKE",
"DARK_WEAK",
"KILL_DOOR",
"LOCK_DOOR",
"KILL_TRAP",
"DISP_ALL", /* Debug only */

 "MAX",
    NULL
};
int proj_name_to_idx(const char *name)
{
    int i;
    for (i = 0; proj_name_list[i]; i++) {
        if (!my_stricmp(name, proj_name_list[i]))
            return i;
    }
    return -1;
}
const char *proj_idx_to_name(int type)
{
    assert(type >= 0);
    assert(type < PROJ_MAX);
    return proj_name_list[type];
}
/**
 * ------------------------------------------------------------------------
 * Projection paths
 * ------------------------------------------------------------------------ */
/**
 * Determine if a bolt spell cast from grid1 to grid2 will arrive
 * at the final destination, assuming that no monster gets in the way,
 * using the project_path() function to check the projection path.
 *
 * Accept projection flags, and pass them onto project_path().
 *
 * Note that no grid is ever projectable() from itself.
 *
 * This function is used to determine if the player can (easily) target
 * a given grid, if a monster can target the player, and if a clear shot
 * exists from monster to player.
 */
int projectable(struct chunk *c, struct loc grid1, struct loc grid2, int flg)
{
 struct loc grid_g[512];
 struct loc final, old_final = grid2;
 int grid_n = 0;
 int max_range = z_info->max_range;
 /* We do not have permission to pass through walls */
 if (!(flg & (PROJECT_WALL | PROJECT_PASS))) {
  /* The character is the source or target of the projection */
  if (loc_eq(grid1, player->grid)) {
   /* Require that destination be in line of fire */
   if (!square_isfire(c, grid2)) return PROJECT_PATH_NO;
  } else if (loc_eq(grid2, player->grid)) {
   /* Require that source be in line of fire */
   if (!square_isfire(c, grid1)) return PROJECT_PATH_NO;
  }
 }
 /* Check the projection path */
 grid_n = project_path(c, grid_g, max_range, grid1, &grid2, flg);
 /* No grid is ever projectable from itself */
 if (!grid_n) return PROJECT_PATH_NO;
 /* Final grid.  As grid_n may be negative, use absolute value.  */
 final = grid_g[ABS(grid_n) - 1];
 /* May not end in an unrequested grid */
 if (!loc_eq(final, old_final)) return PROJECT_PATH_NO;
 /* May not end in a wall grid */
 if (!square_ispassable(c, final)) return PROJECT_PATH_NO;
 /* May not end in an unrequested grid */
 if (!loc_eq(grid_g[ABS(grid_n) - 1], final)) return PROJECT_PATH_NO;
 /* Promise a clear bolt shot if we have verified that there is one */
 if ((flg & (PROJECT_STOP)) || (flg & (PROJECT_CHCK))) {
  /* Positive value for grid_n mean no obstacle was found. */
  if (grid_n > 0) return PROJECT_PATH_CLEAR;
 }
 /* Assume projectable, but make no promises about clear shots */
 return PROJECT_PATH_NOT_CLEAR;
}
/**
 * ------------------------------------------------------------------------
 * The main project() function and its helpers
 * ------------------------------------------------------------------------ */
/**
 * Given an origin, find its coordinates and return them
 *
 * If there is no origin, return (-1, -1)
 */
struct loc origin_get_loc(struct source origin)
{
 switch (origin.what) {
  case SRC_MONSTER: {
   struct monster *who = cave_monster(cave, origin.which.monster);
   return who ? who->grid : loc(-1, -1);
  }
  case SRC_TRAP: {
   struct trap *trap = origin.which.trap;
   return trap->grid;
  }
  case SRC_GRID: {
   return origin.which.grid;
  }
  case SRC_PLAYER:
  case SRC_OBJECT: /* Currently only worn cursed objects use this */
  case SRC_CHEST_TRAP:
   return player->grid;
  case SRC_NONE:
   return loc(-1, -1);
 }
 return loc(-1, -1);
}
/**
 * Generic "beam"/"bolt"/"ball" projection routine.
 *   -BEN-, some changes by -LM-
 *
 *   \param origin Origin of the projection
 *   \param rad Radius of explosion (0 = beam/bolt, 1 to 20 = ball), or maximum
 *	  length of arc from the source.
 *   \param finish Target location (or location to travel towards).
 *   \param dd Is the number of dice of damage to monsters, terrain, objects,
 *        or the player.  If uniform is not true, flg includes PROJECT_ARC, and
 *        degrees_of_arc is greater than zero, dd is the number of dice at a
 *        range of one from the origin and the number of dice is reduced at
 *        greater ranges.
 *   \param ds Is the number of sides for each of the damage dice.
 *   \param dif Is the difficulty for defending against the attack (i.e. what
 *        is passed to the third argument of skill_check() if a defense is
 *        allowed).
 *   \param typ Type of projection (fire, frost, dispel demons etc.)
 *   \param flg Extra bit flags that control projection behavior
 *   \param degrees_of_arc How wide an arc spell is (in degrees).
 *   \param uniform If true, the damage not reduced by the distance from the
 *        origin within the radius specified.  Otherwise, the damage decreases
 *        from the center of the origin if flg includes PROJECT_ARC and
 *        degrees_of_arc is greater than zero.
 *   \param obj An object that the projection ignores
 *
 *   \return true if any effects of the projection were observed, else false
 *
 *
 * At present, there are five major types of projections:
 *
 * Point-effect projection:  (no PROJECT_BEAM flag, radius of zero, and either 
 *   jumps directly to target or has a single source and target grid)
 * A point-effect projection has no line of projection, and only affects one 
 *   grid.  It is used for most area-effect spells (like dispel evil) and 
 *   pinpoint strikes like the monster Holding prayer.
 * 
 * Bolt:  (no PROJECT_BEAM flag, radius of zero, has to travel from source to 
 *   target)
 * A bolt travels from source to target and affects only the final grid in its 
 *   projection path.  If given the PROJECT_STOP flag, it is stopped by any 
 *   monster or character in its path (at present, all bolts use this flag).
 *
 * Beam:  (PROJECT_BEAM)
 * A beam travels from source to target, affecting all grids passed through 
 *   with full damage.  It is never stopped by monsters in its path.  Beams 
 *   may never be combined with any other projection type.
 *
 * Ball:  (positive radius, unless the PROJECT_ARC flag is set)
 * A ball travels from source towards the target, and always explodes.  Unless 
 *   specified, it does not affect wall grids, but otherwise affects any grids 
 *   in LOS from the center of the explosion.
 * If used with a direction, a ball will explode on the first occupied grid in 
 *   its path.  If given a target, it will explode on that target.  If a 
 *   wall is in the way, it will explode against the wall.  If a ball reaches 
 *   z_info->max_range without hitting anything or reaching its target, it will 
 *   explode at that point.
 *
 * Arc:  (positive radius, with the PROJECT_ARC flag set)
 * An arc is a portion of a source-centered ball that explodes outwards 
 *   towards the target grid.  Like a ball, it affects all non-wall grids in 
 *   LOS of the source in the explosion area.  The width of arc spells is con-
 *   trolled by degrees_of_arc.
 * An arc is created by rejecting all grids that form the endpoints of lines 
 *   whose angular difference (in degrees) from the centerline of the arc is 
 *   greater than one-half the input "degrees_of_arc".  See the table "get_
 *   angle_to_grid" in "util.c" for more information.
 * Note:  An arc with a value for degrees_of_arc of zero is actually a beam of
 *   defined length.
 *
 * Projections that effect all monsters in LOS are handled through the use 
 *   of the PROJECT_LOS effect, which applies a single-grid projection to
 *   individual monsters.  Projections that light up rooms or affect all
 *   monsters on the level are more efficiently handled through special
 *   functions.
 *
 *
 * Variations:
 *
 * PROJECT_STOP forces a path of projection to stop at the first occupied grid 
 *   it hits.  This is used with bolts, and also by ball spells travelling in 
 *   a specific direction rather than towards a target.
 *
 * PROJECT_THRU allows a path of projection towards a target to continue 
 *   past that target.  It also allows a spell to affect wall grids adjacent 
 *   to a grid in LOS of the center of the explosion.
 * 
 * PROJECT_JUMP allows a projection to immediately set the source of the pro-
 *   jection to the target.  This is used for all area effect spells (like 
 *   dispel evil), and can also be used for bombardments.
 * 
 * PROJECT_HIDE erases all graphical effects, making the projection invisible.
 *
 * PROJECT_GRID allows projections to affect terrain features.
 *
 * PROJECT_ITEM allows projections to affect objects on the ground.
 *
 * PROJECT_KILL allows projections to affect monsters.
 *
 * PROJECT_PLAY allows projections to affect the player.
 *
 * PROJECT_RANGE_DAM will reset rad if rad is zero to the range at which
 * damage can still be inflicted
 *
 * degrees_of_arc controls the width of arc spells.  With a value for 
 *   degrees_of_arc of zero, arcs act like beams of defined length.
 *
 *
 * Implementation notes:
 *
 * If the source grid is not the same as the target, we project along the path 
 *   between them.  Bolts stop if they hit anything, beams stop if they hit a 
 *   wall, and balls and arcs may exhibit either bahavior.  When they reach 
 *   the final grid in the path, balls and arcs explode.  We do not allow 
 *   beams to be combined with explosions.
 * Balls affect all floor grids in LOS (optionally, also wall grids adjacent 
 *   to a grid in LOS) within their radius.  Arcs do the same, but only within 
 *   their cone of projection.
 * Because affected grids are only scanned once, and it is really helpful to 
 *   have explosions that travel outwards from the source, they are sorted by 
 *   distance.  For each distance, an adjusted damage is calculated.
 * In successive passes, the code then displays explosion graphics, erases 
 *   these graphics, marks terrain for possible later changes, affects 
 *   objects, monsters, the character, and finally changes features and 
 *   teleports monsters and characters in marked grids.
 * 
 *
 * Usage and graphics notes:
 *
 * Only 256 grids can be affected per projection, limiting the effective 
 * radius of standard ball attacks to nine units (diameter nineteen).  Arcs 
 * can have larger radii; an arc capable of going out to range 20 should not 
 * be wider than 70 degrees.
 *
 * Balls must explode BEFORE hitting walls, or they would affect monsters on 
 * both sides of a wall. 
 *
 * Note that for consistency, we pretend that the bolt actually takes time
 * to move from point A to point B, even if the player cannot see part of the
 * projection path.  Note that in general, the player will *always* see part
 * of the path, since it either starts at the player or ends on the player.
 *
 * Hack -- we assume that every "projection" is "self-illuminating".
 *
 * Hack -- when only a single monster is affected, we automatically track
 * (and recall) that monster, unless "PROJECT_JUMP" is used.
 *
 * Note that we must call "handle_stuff()" after affecting terrain features
 * in the blast radius, in case the illumination of the grid was changed,
 * and "update_view()" and "update_monsters()" need to be called.
 */
bool project(struct source origin, int rad, struct loc finish,
    int dd, int ds, int dif, int typ, int flg,
    int degrees_of_arc, bool uniform, const struct object *obj)
{
 int i, j, k, dist_from_centre;
 uint32_t dam_temp;
 struct loc centre;
 struct loc start;
 int n1y = 0;
 int n1x = 0;
 /* Assume the player sees nothing */
 bool notice = false;
 /* Notify the UI if it can draw this projection */
 bool drawing = false;
 /* Is the player blind? */
 bool blind = (player->timed[TMD_BLIND] ? true : false);
 /* Number of grids in the "path" */
 int num_path_grids = 0;
 /* Actual grids in the "path" */
 struct loc path_grid[512];
 /* Number of grids in the "blast area" (including the "beam" path) */
 int num_grids = 0;
 /* Coordinates of the affected grids */
 struct loc blast_grid[256];
 /* Distance to each of the affected grids. */
 int distance_to_grid[256];
 /* Player visibility of each of the affected grids. */
 bool player_sees_grid[256];
 /* Precalculated damage values for each distance. */
 int *dam_at_dist = malloc((z_info->max_range + 1) * sizeof(*dam_at_dist));
 /* Flush any pending output */
 handle_stuff(player);
 /* No projection path - jump to target */
 if (flg & PROJECT_JUMP) {
  start = finish;
  /* Clear the flag */
  flg &= ~(PROJECT_JUMP);
 } else {
  start = origin_get_loc(origin);
  /* Default to finish grid */
  if (start.y == -1 && start.x == -1) {
   start = finish;
  }
 }
 /* Default center of explosion (if any) */
 centre = start;
 /* If requested, set the radius to where damage can be inflicted. */
 if (!rad && (flg & (PROJECT_RANGE_DAM))) {
  if (uniform || !(flg & (PROJECT_ARC))) {
   /* No damage reduction with distance */
   rad = z_info->max_range;
  } else {
   rad = (dd + 1) / 2;
   if (rad < 0) {
    rad = 0;
   } else if (rad > z_info->max_range) {
    rad = z_info->max_range;
   }
  }
 }
 /*
	 * An arc spell with no width and a non-zero radius is actually a
	 * beam of defined length.  Mark it as such.
	 */
 if ((flg & (PROJECT_ARC)) && (degrees_of_arc == 0) && (rad != 0)) {
  /* No longer an arc */
  flg &= ~(PROJECT_ARC);
  /* Now considered a beam */
  flg |= (PROJECT_BEAM);
  flg |= (PROJECT_THRU);
 }
 /*
	 * If a single grid is both start and finish (for example
	 * if PROJECT_JUMP is set), store it; otherwise, travel along the
	 * projection path.
	 */
 if (loc_eq(start, finish)) {
  blast_grid[num_grids] = finish;
  centre = finish;
  distance_to_grid[num_grids] = 0;
  sqinfo_on(square(cave, finish)->info, SQUARE_PROJECT);
  num_grids++;
 } else {
  /* Start from caster */
  int y = start.y;
  int x = start.x;
  /* Calculate the projection path */
  if (flg & (PROJECT_BOOM)) {
   dist_from_centre = z_info->max_range;
  } else if (rad <= 0) {
   dist_from_centre = z_info->max_range;
  } else {
   dist_from_centre = rad;
  }
  num_path_grids = ABS(project_path(cave, path_grid, dist_from_centre,
            start, &finish, flg));
  /* Project along the path (except for arcs) */
  if (!(flg & (PROJECT_ARC))) {
   for (i = 0; i < num_path_grids; ++i) {
    int oy = y;
    int ox = x;
    int ny = path_grid[i].y;
    int nx = path_grid[i].x;
    /* Hack -- Balls explode before reaching walls. */
    if (!square_ispassable(cave, path_grid[i]) &&
     ((flg & (PROJECT_BOOM)) || (rad > 0)) &&
     !(flg & (PROJECT_BEAM)))
     break;
    /* Advance */
    y = ny;
    x = nx;
    /* Beams collect all grids in the path, all other methods
				 * collect only the final grid in the path. */
    if (flg & (PROJECT_BEAM)) {
     blast_grid[num_grids].y = y;
     blast_grid[num_grids].x = x;
     distance_to_grid[num_grids] = 0;
     sqinfo_on(square(cave, loc(x, y))->info, SQUARE_PROJECT);
     num_grids++;
    } else if (i == num_path_grids - 1) {
     blast_grid[num_grids].y = y;
     blast_grid[num_grids].x = x;
     distance_to_grid[num_grids] = 0;
     sqinfo_on(square(cave, loc(x, y))->info, SQUARE_PROJECT);
     num_grids++;
    }
    /* Only do visuals if requested and within range limit. */
    if (!blind && !(flg & (PROJECT_HIDE))) {
     bool seen = square_isview(cave, loc(x, y));
     bool beam = flg & (PROJECT_BEAM);
     /* Tell the UI to display the bolt */
     event_signal_bolt(EVENT_BOLT, typ, drawing, seen, beam, oy,
           ox, y, x);
    }
   }
  }
  /* Save the "blast epicenter" */
  centre.y = y;
  centre.x = x;
 }
 /* Now check for explosions.  Beams have already stored all the grids they
	 * will affect; all non-beam projections with positive radius explode in
	 * some way */
 if (((rad > 0) || (flg & (PROJECT_BOOM))) && !(flg & (PROJECT_BEAM))) {
  int y, x;
  /* Pre-calculate some things for arcs. */
  if ((flg & (PROJECT_ARC)) && (num_path_grids != 0)) {
   /* Explosion centers on the caster. */
   centre = start;
   /* The radius of arcs cannot be more than 20 */
   if (rad > 20)
    rad = 20;
   /* Ensure legal access into get_angle_to_grid table */
   if (num_path_grids < 21)
    i = num_path_grids - 1;
   else
    i = 20;
   /* Reorient the grid forming the end of the arc's centerline. */
   n1y = path_grid[i].y - centre.y + 20;
   n1x = path_grid[i].x - centre.x + 20;
  }
  /* If the explosion centre hasn't been saved already, save it now. */
  if (num_grids == 0) {
   blast_grid[num_grids] = centre;
   distance_to_grid[num_grids] = 0;
   sqinfo_on(square(cave, centre)->info, SQUARE_PROJECT);
   num_grids++;
  }
  /* Scan every grid that might possibly be in the blast radius. */
  for (y = centre.y - rad; y <= centre.y + rad; y++) {
   for (x = centre.x - rad; x <= centre.x + rad; x++) {
    struct loc grid = loc(x, y);
    bool on_path = false;
    /* Center grid has already been stored. */
    if (loc_eq(grid, centre))
     continue;
    /* Precaution: Stay within area limit. */
    if (num_grids >= 255)
     break;
    /* Ignore "illegal" locations */
    if (!square_in_bounds(cave, grid))
     continue;
    /* Spell with PROJECT_PASS ignore walls */
    if (!(flg & (PROJECT_PASS))) {
     /* Most explosions are immediately stopped by walls. If
					 * PROJECT_THRU is set, walls can be affected if adjacent to
					 * a grid visible from the explosion centre.
					 * All explosions can affect one layer of terrain which is
					 * passable but not projectable */
     if ((flg & (PROJECT_THRU)) ||
      square_ispassable(cave, grid)) {
      /* If this is a wall grid, ... */
      if (!square_isprojectable(cave, grid)) {
       bool can_see_one = false;
       /* Check neighbors */
       for (i = 0; i < 8; i++) {
        struct loc adj_grid = loc_sum(grid,
                 ddgrid_ddd[i]);
        if (los(cave, centre, adj_grid)) {
         can_see_one = true;
         break;
        }
       }
       /* Require at least one adjacent grid in LOS. */
       if (!can_see_one)
        continue;
      }
     } else if (!square_isprojectable(cave, grid))
      continue;
    }
    /* Must be within maximum distance. */
    dist_from_centre = (distance(centre, grid));
    if (dist_from_centre > rad)
     continue;
    /* Mark grids which are on the projection path */
    for (i = 0; i < num_path_grids; i++) {
     if (loc_eq(grid, path_grid[i])) {
      on_path = true;
     }
    }
    /* Do we need to consider a restricted angle? */
    if (flg & (PROJECT_ARC)) {
     /* Use angle comparison to delineate an arc. */
     int n2y, n2x, tmp, rotate, diff;
     /* Reorient current grid for table access. */
     n2y = y - start.y + 20;
     n2x = x - start.x + 20;
     /* Find the angular difference (/2) between the lines to
					 * the end of the arc's center-line and to the current grid.
					 */
     rotate = 90 - get_angle_to_grid[n1y][n1x];
     tmp = ABS(get_angle_to_grid[n2y][n2x] + rotate) % 180;
     diff = ABS(90 - tmp);
     /* If difference is greater then that allowed, skip it,
					 * unless it's on the target path */
     if ((diff >= (degrees_of_arc + 6) / 4) && !on_path)
      continue;
    }
    /* Accept remaining grids if in LOS or on the projection path */
    if (flg & (PROJECT_PASS) || los(cave, centre, grid) || on_path){
     blast_grid[num_grids].y = y;
     blast_grid[num_grids].x = x;
     distance_to_grid[num_grids] = dist_from_centre;
     sqinfo_on(square(cave, grid)->info, SQUARE_PROJECT);
     num_grids++;
    }
   }
  }
 }
 /* Calculate and store the actual damage at each distance. */
 for (i = 0; i <= z_info->max_range; i++) {
  if (i > rad) {
   /* No damage outside the radius. */
   dam_temp = 0;
  } else if (uniform || !(flg & PROJECT_ARC)) {
   /*
			 * No damage reduction with range if uniform or not an
			 * arc.
			 */
   dam_temp = dd;
  } else {
   /* Otherwise, lose two dice per square. */
   if (dd > 2 * (i - 1)) {
    dam_temp = dd - 2 * (i - 1);
   } else {
    dam_temp = 0;
   }
  }
  /* Store it. */
  dam_at_dist[i] = dam_temp;
 }
 /* Sort the blast grids by distance from the centre. */
 for (i = 0, k = 0; i <= rad; i++) {
  /* Collect all the grids of a given distance together. */
  for (j = k; j < num_grids; j++) {
   if (distance_to_grid[j] == i) {
    struct loc tmp;
    int tmp_d = distance_to_grid[k];
    tmp = blast_grid[k];
    blast_grid[k] = blast_grid[j];
    distance_to_grid[k] = distance_to_grid[j];
    blast_grid[j] = tmp;
    distance_to_grid[j] = tmp_d;
    /* Write to next slot */
    k++;
   }
  }
 }
 /* Establish which grids are visible - no blast visuals with PROJECT_HIDE */
 for (i = 0; i < num_grids; i++) {
  if (panel_contains(blast_grid[i].y, blast_grid[i].x) &&
   square_isview(cave, blast_grid[i]) &&
   !blind && !(flg & (PROJECT_HIDE))) {
   player_sees_grid[i] = true;
  } else {
   player_sees_grid[i] = false;
  }
 }
 /* Tell the UI to display the blast */
 event_signal_blast(EVENT_EXPLOSION, typ, num_grids, distance_to_grid,
        drawing, player_sees_grid, blast_grid, centre);
 /* Affect objects on every relevant grid */
 if (flg & (PROJECT_ITEM)) {
  for (i = 0; i < num_grids; i++) {
   if (project_o(blast_grid[i], typ, obj)) {
    notice = true;
   }
  }
 }
 /* Check monsters */
 if (flg & (PROJECT_KILL)) {
  bool was_obvious = false;
  bool did_hit = false;
  int num_hit = 0;
  struct loc last_hit_grid = loc(0, 0);
  /* Scan for monsters */
  for (i = 0; i < num_grids; i++) {
   struct monster *mon = NULL;
   /* Path grid index, reversed for force attacks */
   j = (typ == PROJ_FORCE) ? num_grids - 1 - i : i;
   /* Check this monster hasn't been processed already */
   if (!square_isproject(cave, blast_grid[j]))
    continue;
   /* Check there is actually a monster here */
   mon = square_monster(cave, blast_grid[j]);
   if (mon == NULL)
    continue;
   /* Affect the monster in the grid */
   project_m(origin, distance_to_grid[j], blast_grid[j],
             dam_at_dist[distance_to_grid[j]], ds, dif, typ, flg,
             &did_hit, &was_obvious);
   if (was_obvious) {
    notice = true;
   }
   if (did_hit) {
    num_hit++;
    /* Monster location may have been updated by project_m() */
    last_hit_grid = mon->grid;
   }
  }
  /* Player affected one monster (without "jumping") */
  if (origin.what == SRC_PLAYER &&
    num_hit == 1 &&
    !(flg & PROJECT_JUMP)) {
   /* Location */
   int x = last_hit_grid.x;
   int y = last_hit_grid.y;
   /* Track if possible */
   if (square(cave, loc(x, y))->mon > 0) {
    struct monster *mon = square_monster(cave, loc(x, y));
    /* Recall and track */
    if (monster_is_visible(mon)) {
     monster_race_track(player->upkeep, mon->race);
     health_track(player->upkeep, mon);
    }
   }
  }
 }
 /* Look for the player, affect them when found */
 if (flg & (PROJECT_PLAY)) {
  for (i = 0; i < num_grids; i++) {
   if (project_p(origin, blast_grid[i],
        dam_at_dist[distance_to_grid[i]], ds, typ)) {
    notice = true;
    if (player->is_dead) {
     free(dam_at_dist);
     return notice;
    }
    break;
   }
  }
 }
 /* Affect features in every relevant grid */
 if (flg & (PROJECT_GRID)) {
  for (i = 0; i < num_grids; i++) {
   if (project_f(origin, blast_grid[i], dif, typ)) {
    notice = true;
   }
  }
 }
 /* Clear all the processing marks. */
 for (i = 0; i < num_grids; i++) {
  /* Clear the mark */
  sqinfo_off(square(cave, blast_grid[i])->info, SQUARE_PROJECT);
 }
 /* Update stuff if needed */
 if (player->upkeep->update) update_stuff(player);
 free(dam_at_dist);
 /* Return "something was noticed" */
 return (notice);
}
/**
 * \file project-feat.c
 * \brief projection effects on terrain
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * ------------------------------------------------------------------------
 * Feature handlers
 * ------------------------------------------------------------------------ */
typedef struct project_feature_handler_context_s {
 const struct source origin;
 const struct loc grid;
 const int dif;
 const int type;
 bool obvious;
} project_feature_handler_context_t;
typedef void (*project_feature_handler_f)(project_feature_handler_context_t *);
static void project_feature_handler_FIRE(project_feature_handler_context_t *context)
{
}
static void project_feature_handler_COLD(project_feature_handler_context_t *context)
{
}
static void project_feature_handler_POIS(project_feature_handler_context_t *context)
{
}
/* Darken the grid */
static void project_feature_handler_DARK(project_feature_handler_context_t *context)
{
 const struct loc grid = context->grid;
 if ((player->depth != 0 || !is_daytime())) {
  /* Turn off the light */
  sqinfo_off(square(cave, grid)->info, SQUARE_GLOW);
 }
 /* Grid is in line of sight */
 if (square_isview(cave, grid)) {
  /* Observe */
  context->obvious = true;
  /* Fully update the visuals */
  player->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
 }
}
static void project_feature_handler_NOTHING(project_feature_handler_context_t *context)
{
}
static void project_feature_handler_HURT(project_feature_handler_context_t *context)
{
}
static void project_feature_handler_ARROW(project_feature_handler_context_t *context)
{
}
static void project_feature_handler_BOULDER(project_feature_handler_context_t *context)
{
}
static void project_feature_handler_ACID(project_feature_handler_context_t *context)
{
}
static void project_feature_handler_SOUND(project_feature_handler_context_t *context)
{
}
static void project_feature_handler_FORCE(project_feature_handler_context_t *context)
{
}
/* Light up the grid */
static void project_feature_handler_LIGHT(project_feature_handler_context_t *context)
{
 const struct loc grid = context->grid;
 /* Turn on the light */
 sqinfo_on(square(cave, grid)->info, SQUARE_GLOW);
 /* Grid is in line of sight */
 if (square_isview(cave, grid)) {
  if (!player->timed[TMD_BLIND]) {
   /* Observe */
   context->obvious = true;
   /* Fully update the visuals */
   player->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
  }
 }
}
/* Destroy walls (and doors) */
static void project_feature_handler_KILL_WALL(project_feature_handler_context_t *context)
{
 const struct loc grid = context->grid;
 bool success;
 /* Non-walls (etc) */
 if (square_ispassable(cave, grid) && !square_seemslikewall(cave, grid))
  return;
 /* Permanent walls */
 if (square_isperm(cave, grid)) return;
 success = skill_check(context->origin, context->dif, 10, source_none()) > 0;
 /* Different treatment for different walls */
 if (square_isrubble(cave, grid)) {
  if (success) {
   /* Message */
   if (square_isseen(cave, grid)) {
    msg("The rubble is blown away!");
    context->obvious = true;
    /* Forget the rubble */
    square_forget(cave, grid);
    square_light_spot(cave, grid);
   }
   /* Destroy the rubble */
   square_destroy_rubble(cave, grid);
  } else if (square_isseen(cave, grid)) {
   /* Message */
   msg("You fail to blow hard enough to smash the rubble.");
  }
 } else if (square_iscloseddoor(cave, grid)) {
  if (success) {
   /* Message */
   if (square_isseen(cave, grid)) {
    msg("The door is blown from its hinges!");
    context->obvious = true;
    /* Forget the door */
    square_forget(cave, grid);
    square_light_spot(cave, grid);
   }
   /* Destroy the door */
   square_destroy_door(cave, grid);
  } else if (square_isseen(cave, grid)) {
   /* Message */
   msg("You fail to blow hard enough to force the door open.");
  }
 } else if (square_isquartz(cave, grid)) {
  if (success) {
   /* Message */
   if (square_isseen(cave, grid)) {
    msg("The vein shatters!");
    context->obvious = true;
    /* Forget the wall */
    square_forget(cave, grid);
    square_light_spot(cave, grid);
   }
   /* Destroy the wall */
   square_set_feat(cave, grid, FEAT_RUBBLE);
  } else if (square_isseen(cave, grid)) {
   /* Message */
   msg("You fail to blow hard enough to shatter the quartz.");
  }
 } else if (square_isgranite(cave, grid)) {
  if (success) {
   /* Message */
   if (square_isseen(cave, grid)) {
    msg("The wall shatters!");
    context->obvious = true;
    /* Forget the wall */
    square_forget(cave, grid);
    square_light_spot(cave, grid);
   }
   /* Destroy the wall */
   square_set_feat(cave, grid, FEAT_RUBBLE);
  } else if (square_isseen(cave, grid)) {
   /* Message */
   msg("You fail to blow hard enough to shatter the wall.");
  }
 }
 /* Update the visuals */
 player->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
}
static void project_feature_handler_SLEEP(project_feature_handler_context_t *context)
{
}
static void project_feature_handler_SPEED(project_feature_handler_context_t *context)
{
}
static void project_feature_handler_SLOW(project_feature_handler_context_t *context)
{
}
static void project_feature_handler_CONFUSION(project_feature_handler_context_t *context)
{
}
static void project_feature_handler_FEAR(project_feature_handler_context_t *context)
{
}
static void project_feature_handler_EARTHQUAKE(project_feature_handler_context_t *context)
{
}
/* Darken the grid */
static void project_feature_handler_DARK_WEAK(project_feature_handler_context_t *context)
{
 project_feature_handler_DARK(context);
}
/* Destroy Doors */
static void project_feature_handler_KILL_DOOR(project_feature_handler_context_t *context)
{
 const struct loc grid = context->grid;
 int result = skill_check(context->origin, context->dif, 0, source_none());
 /* Doors */
 if (square_isdoor(cave, grid)) {
  if (result <= 0) {
   /* Do nothing */
  } else if (result <= 5) {
   if (square_islockeddoor(cave, grid)) {
    /* Unlock the door */
    square_unlock_door(cave, grid);
    msg("You hear a 'click'.");
   }
  } else if (result <= 10) {
   if (!square_isopendoor(cave, grid)
     && !square_isbrokendoor(cave, grid)) {
    /* Open the door */
    square_open_door(cave, grid);
    context->obvious = true;
    /* Message */
    if (square_isseen(cave, grid)) {
     msg("The door flies open.");
    } else {
     msg("You hear a door burst open.");
    }
   }
  } else if (!square_isbrokendoor(cave, grid)) {
   /* Break the door */
   square_smash_door(cave, grid);
   context->obvious = true;
   /* Message */
   if (square_isseen(cave, grid)) {
    msg("The door is ripped from its hinges.");
   } else {
    msg("You hear a door burst open.");
   }
  }
 } else if (square_isrubble(cave, grid)) {
  /* Rubble */
  if (result <= 0) {
   /* Do nothing */
  } else {
   /* Disperse the rubble */
   square_destroy_rubble(cave, grid);
   context->obvious = true;
   /* Message */
   if (square_isseen(cave, grid)) {
    msg("The rubble is scattered across the floor.");
   } else {
    msg("You hear a loud rumbling.");
   }
  }
 }
}
/* Make doors */
static void project_feature_handler_LOCK_DOOR(project_feature_handler_context_t *context)
{
 const struct loc grid = context->grid;
 int power = skill_check(context->origin, context->dif, 0, source_none());
 /* Require a grid without monsters */
 if (square_monster(cave, grid) || square_isplayer(cave, grid)) return;
 /* Broken doors are harder to lock */
 if (square_isbrokendoor(cave, grid)) power -= 10;
 /* Check power */
 if (power <= 0) return;
 /* Require a known door */
 if (!square_isdoor(cave, grid) || square_issecretdoor(cave, grid)) return;
 /* Close the door */
 if (square_isopendoor(cave, grid) || square_isbrokendoor(cave, grid)) {
  square_close_door(cave, grid);
  context->obvious = true;
  if (square_isseen(cave, grid)) {
   msg("The door slams shut.");
  } else {
   msg("You hear a door slam shut.");
  }
 } else {
  /* Or lock the door more firmly than it was before */
  if ((square_door_lock_power(cave, grid) < 7) && (power > 1)) {
   int lock_level = square_door_lock_power(cave, grid) + power / 2;
   square_set_door_lock(cave, grid, MIN(lock_level, 7));
   msg("You hear a 'click'.");
   context->obvious = true;
  }
 }
 /* Update the visuals */
 player->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
}
/* Disable traps, unlock doors */
static void project_feature_handler_KILL_TRAP(project_feature_handler_context_t *context)
{
 const struct loc grid = context->grid;
 /* Disable traps, unlock doors */
 if (square_isplayertrap(cave, grid)) {
  /* Check line of sight */
  if (square_isview(cave, grid) && square_isvisibletrap(cave, grid)) {
   context->obvious = true;
  }
  /* Destroy the trap */
  square_destroy_trap(cave, grid);
 }
}
static void project_feature_handler_DISP_ALL(project_feature_handler_context_t *context)
{
}
static const project_feature_handler_f feature_handlers[] = {
/**
 * \file list-elements.h
 * \brief Elements used in spells and other attacks.
 */
project_feature_handler_ACID,
project_feature_handler_FIRE,
project_feature_handler_COLD,
project_feature_handler_POIS,
project_feature_handler_DARK,
/**
 * \file list-projections.h
 * \brief Spell types used by project() and related functions.
 *
 * ===== NOTICE =====
 * If you add new entries to this file, you must
 * also update lib/gamedata/projection.txt!
 * ===== NOTICE =====
 */
project_feature_handler_NOTHING,
project_feature_handler_HURT,
project_feature_handler_ARROW,
project_feature_handler_BOULDER,
project_feature_handler_SOUND,
project_feature_handler_FORCE,
project_feature_handler_LIGHT,
project_feature_handler_KILL_WALL,
project_feature_handler_SLEEP,
project_feature_handler_SPEED,
project_feature_handler_SLOW,
project_feature_handler_CONFUSION,
project_feature_handler_FEAR,
project_feature_handler_EARTHQUAKE,
project_feature_handler_DARK_WEAK,
project_feature_handler_KILL_DOOR,
project_feature_handler_LOCK_DOOR,
project_feature_handler_KILL_TRAP,
project_feature_handler_DISP_ALL, /* Debug only */

 NULL
};
/**
 * Called from project() to affect terrain features
 *
 * Called for projections with the PROJECT_GRID flag set, which includes
 * beam, ball and breath effects.
 *
 * \param origin is the origin of the effect
 * \param grid the coordinates of the grid being handled
 * \param typ is the projection (PROJ_) type
 * \return whether the effects were obvious
 *
 * Note that this function determines if the player can see anything that
 * happens by taking into account: blindness, line-of-sight, and illumination.
 *
 * Hack -- effects on grids which are memorized but not in view are also seen.
 */
bool project_f(struct source origin, struct loc grid, int dif, int typ)
{
 bool obvious = false;
 project_feature_handler_context_t context = {
  origin,
  grid,
  dif,
  typ,
  obvious,
 };
 project_feature_handler_f feature_handler = feature_handlers[typ];
 if (feature_handler != NULL)
  feature_handler(&context);
 /* Return "Anything seen?" */
 return context.obvious;
}
/**
 *  \file project-mon.c
 *  \brief projection effects on monsters
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * ------------------------------------------------------------------------
 * Monster handlers
 * ------------------------------------------------------------------------ */
typedef struct project_monster_handler_context_s {
 const struct source origin;
 const int r;
 const struct loc grid;
 int dam;
 int dif;
 const int type;
 bool seen; /* Ideally, this would be const, but we can't with C89 initialization. */
 const bool id;
 struct monster *mon;
 struct monster_lore *lore;
 bool obvious;
 bool skipped;
 bool alert;
 uint16_t flag;
 enum mon_messages hurt_msg;
 enum mon_messages die_msg;
 int mon_timed[MON_TMD_MAX];
} project_monster_handler_context_t;
typedef void (*project_monster_handler_f)(project_monster_handler_context_t *);
/**
 * Resist an attack if the monster has the given elemental flag.
 *
 * If the effect is seen, we learn that the monster has a given flag.
 * Resistance is divided by the factor.
 *
 * \param context is the project_m context.
 * \param flag is the RF_ flag that the monster must have.
 * \param factor is the divisor for the base damage.
 */
static void project_monster_resist_element(project_monster_handler_context_t *context, int flag)
{
 if (context->seen) rf_on(context->lore->flags, flag);
 if (rf_has(context->mon->race->flags, flag)) {
  context->hurt_msg = MON_MSG_RESIST_A_LOT;
  context->dam = 0;
 }
}
/**
 * Resist an attack if the monster has the given flag or hurt the monster
 * more if it has another flag.
 *
 * If the effect is seen, we learn the status of both flags. Hurt is multiplied by hurt_factor.
 *
 * \param context is the project_m context.
 * \param hurt_flag is the RF_ flag that the monster must have to use the hurt factor.
 * \param imm_flag is the RF_ flag that the monster must have to use the resistance factor.
 * \param hurt_factor is the hurt multiplier for the base damage.
 * \param hurt_msg is the message that should be displayed when the monster is hurt.
 * \param die_msg is the message that should be displayed when the monster dies.
 */
static void project_monster_hurt_immune(project_monster_handler_context_t *context, int hurt_flag, int imm_flag, int hurt_factor, enum mon_messages hurt_msg, enum mon_messages die_msg)
{
 if (context->seen) {
  rf_on(context->lore->flags, imm_flag);
  rf_on(context->lore->flags, hurt_flag);
 }
 if (rf_has(context->mon->race->flags, imm_flag)) {
  context->hurt_msg = MON_MSG_RESIST_A_LOT;
  context->dam = 0;
 }
 else if (rf_has(context->mon->race->flags, hurt_flag)) {
  context->hurt_msg = hurt_msg;
  context->die_msg = die_msg;
  context->dam *= hurt_factor;
 }
}
/**
 * Hurt the monster if it has a given flag or do no damage.
 *
 * If the effect is seen, we learn the status the flag. There is no damage
 * multiplier.
 *
 * \param context is the project_m context.
 * \param flag is the RF_ flag that the monster must have.
 * \param hurt_msg is the message that should be displayed when the monster is hurt.
 * \param die_msg is the message that should be displayed when the monster dies.
 */
static void project_monster_hurt_only(project_monster_handler_context_t *context, int flag, enum mon_messages hurt_msg, enum mon_messages die_msg)
{
 if (context->seen) rf_on(context->lore->flags, flag);
 if (rf_has(context->mon->race->flags, flag)) {
  int resist = monster_stat(context->mon, STAT_CON) * 2;
  if (skill_check(source_player(), context->dif, resist,
      source_monster(context->mon->midx)) > 0) {
   context->hurt_msg = hurt_msg;
   context->die_msg = die_msg;
  } else {
   context->hurt_msg = MON_MSG_RESIST_A_LOT;
   context->dam = 0;
  }
 } else {
  context->dam = 0;
 }
}
/**
 * Resist an attack if the monster has the given spell flag.
 *
 * If the effect is seen, we learn that the monster has that spell (useful
 * for breaths). Resistance is multiplied by the factor and reduced by
 * a small random amount.
 *
 * \param context is the project_m context.
 * \param flag is the RSF_ flag that the monster must have.
 * \param factor is the multiplier for the base damage.
 */
static void project_monster_breath(project_monster_handler_context_t *context, int flag)
{
 if (rsf_has(context->mon->race->spell_flags, flag)) {
  /* Learn about breathers through resistance */
  //if (context->seen) rsf_on(context->lore->spell_flags, flag);
  context->hurt_msg = MON_MSG_RESIST;
  context->dam = 0;
 }
}
/**
 * Run a skill check for a monster to apply a timed effect.
 *
 * If the monster has the given flag, it resists, and the player learns
 * monster lore if the effect is seen.
 *
 * \param context is the project_m context.
 * \param flag is the RF_ flag that the monster must have to resist.
 */
static int project_monster_skill_check(project_monster_handler_context_t *context, int flag)
{
 int resistance = monster_skill(context->mon, SKILL_WILL);
 int dif = context->dif - context->r;
 if (rf_has(context->mon->race->flags, flag)) resistance += 100;
 return skill_check(context->origin, dif, resistance,
        source_monster(context->mon->midx));
}
/* Fire damage */
static void project_monster_handler_FIRE(project_monster_handler_context_t *context)
{
 project_monster_hurt_immune(context, RF_HURT_FIRE, RF_RES_FIRE, 2, MON_MSG_CATCH_FIRE, MON_MSG_DISINTEGRATES);
}
/* Cold */
static void project_monster_handler_COLD(project_monster_handler_context_t *context)
{
 project_monster_hurt_immune(context, RF_HURT_COLD, RF_RES_COLD, 2, MON_MSG_BADLY_FROZEN, MON_MSG_FREEZE_SHATTER);
}
/* Poison */
static void project_monster_handler_POIS(project_monster_handler_context_t *context)
{
 project_monster_resist_element(context, RF_RES_POIS);
}
/* Dark -- opposite of Light */
static void project_monster_handler_DARK(project_monster_handler_context_t *context)
{
 project_monster_breath(context, RSF_BR_DARK);
 if (rf_has(context->mon->race->flags, RF_UNDEAD) ||
  context->mon->race->light < 0) {
  context->dam = 0;
  context->hurt_msg = MON_MSG_RESIST_A_LOT;
 }
}
static void project_monster_handler_NOTHING(project_monster_handler_context_t *context)
{
}
static void project_monster_handler_HURT(project_monster_handler_context_t *context)
{
}
static void project_monster_handler_ARROW(project_monster_handler_context_t *context)
{
}
static void project_monster_handler_BOULDER(project_monster_handler_context_t *context)
{
}
/* Acid */
static void project_monster_handler_ACID(project_monster_handler_context_t *context)
{
}
/* Sound -- Sound breathers resist */
static void project_monster_handler_SOUND(project_monster_handler_context_t *context)
{
 context->mon_timed[MON_TMD_STUN] = context->dam;
 context->dam = 0;
}
/* Force */
static void project_monster_handler_FORCE(project_monster_handler_context_t *context)
{
 int resist = monster_stat(context->mon, STAT_CON) * 2;
 if (skill_check(source_player(), context->dif, resist,
     source_monster(context->mon->midx)) > 0) {
  if (monster_is_visible(context->mon)) {
   context->hurt_msg = MON_MSG_PUSHED;
   context->obvious = true;
  }
  knock_back(player->grid, context->mon->grid);
 } else {
  if (monster_is_visible(context->mon)) {
   context->hurt_msg = MON_MSG_NOT_PUSHED;
   context->obvious = true;
  }
 }
}
/* Light -- opposite of Dark */
static void project_monster_handler_LIGHT(project_monster_handler_context_t *context)
{
 if (context->seen) rf_on(context->lore->flags, RF_HURT_LIGHT);
 if (rf_has(context->mon->race->flags, RF_HURT_LIGHT)) {
  context->mon_timed[MON_TMD_STUN] = context->dam;
  context->hurt_msg = MON_MSG_CRINGE_LIGHT;
 }
 context->alert = false;
 context->dam = 0;
}
/* Stone to Mud */
static void project_monster_handler_KILL_WALL(project_monster_handler_context_t *context)
{
 project_monster_hurt_only(context, RF_STONE, MON_MSG_LOSE_SKIN,
         MON_MSG_DISSOLVE);
}
/* Sleep */
static void project_monster_handler_SLEEP(project_monster_handler_context_t *context)
{
 int result = project_monster_skill_check(context, RF_NO_SLEEP);
 if (result > 0) {
  if (context->seen) context->obvious = true;
  set_alertness(context->mon, context->mon->alertness - (result + 5));
 } else {
  context->hurt_msg = MON_MSG_UNAFFECTED;
  context->obvious = false;
  if (context->seen && rf_has(context->mon->race->flags, RF_NO_SLEEP)) {
   rf_on(context->lore->flags, RF_NO_SLEEP);
  }
 }
 context->alert = false;
 context->dam = 0;
}
/* Speed Monster (Ignore "dam") */
static void project_monster_handler_SPEED(project_monster_handler_context_t *context)
{
 if (context->seen) context->obvious = true;
 context->mon_timed[MON_TMD_FAST] = context->dam;
 if (context->mon->alertness < ALERTNESS_UNWARY) context->alert = false;
 context->dam = 0;
}
/* Slow Monster */
static void project_monster_handler_SLOW(project_monster_handler_context_t *context)
{
 int result = project_monster_skill_check(context, RF_NO_SLOW);
 if (result > 0) {
  if (context->seen) context->obvious = true;
  context->mon_timed[MON_TMD_SLOW] = result + 10;
 } else {
  context->alert = false;
  context->hurt_msg = MON_MSG_UNAFFECTED;
  context->obvious = false;
  if (context->seen && rf_has(context->mon->race->flags, RF_NO_SLOW)) {
   rf_on(context->lore->flags, RF_NO_SLOW);
  }
 }
 if (context->mon->alertness < ALERTNESS_UNWARY) context->alert = false;
 context->dam = 0;
}
/* Confusion */
static void project_monster_handler_CONFUSION(project_monster_handler_context_t *context)
{
 int result = project_monster_skill_check(context, RF_NO_CONF);
 if (result > 0) {
  if (context->seen) context->obvious = true;
  context->mon_timed[MON_TMD_CONF] = result + 10;
 } else {
  context->hurt_msg = MON_MSG_UNAFFECTED;
  context->obvious = false;
  if (context->seen && rf_has(context->mon->race->flags, RF_NO_CONF)) {
   rf_on(context->lore->flags, RF_NO_CONF);
  }
 }
 context->alert = false;
 context->dam = 0;
}
/* Fear */
static void project_monster_handler_FEAR(project_monster_handler_context_t *context)
{
 int result;
 context->dif += 5;
 result = project_monster_skill_check(context, RF_NO_FEAR);
 if (result > 0) {
  if (context->seen) context->obvious = true;
  context->mon->tmp_morale -= result * 20;
 } else {
  context->alert = false;
  context->hurt_msg = MON_MSG_UNAFFECTED;
  context->obvious = false;
  if (context->seen && rf_has(context->mon->race->flags, RF_NO_FEAR)) {
   rf_on(context->lore->flags, RF_NO_FEAR);
  }
 }
 context->dam = 0;
}
static void project_monster_handler_EARTHQUAKE(project_monster_handler_context_t *context)
{
 context->skipped = true;
 context->dam = 0;
}
static void project_monster_handler_DARK_WEAK(project_monster_handler_context_t *context)
{
 context->skipped = true;
 context->dam = 0;
}
static void project_monster_handler_KILL_DOOR(project_monster_handler_context_t *context)
{
 context->skipped = true;
 context->dam = 0;
}
static void project_monster_handler_LOCK_DOOR(project_monster_handler_context_t *context)
{
 context->skipped = true;
 context->dam = 0;
}
static void project_monster_handler_KILL_TRAP(project_monster_handler_context_t *context)
{
 context->skipped = true;
 context->dam = 0;
}
/* Dispel monster */
static void project_monster_handler_DISP_ALL(project_monster_handler_context_t *context)
{
 context->hurt_msg = MON_MSG_SHUDDER;
 context->die_msg = MON_MSG_DISSOLVE;
 context->dam = context->dif;
}
static const project_monster_handler_f monster_handlers[] = {
/**
 * \file list-elements.h
 * \brief Elements used in spells and other attacks.
 */
project_monster_handler_ACID,
project_monster_handler_FIRE,
project_monster_handler_COLD,
project_monster_handler_POIS,
project_monster_handler_DARK,
/**
 * \file list-projections.h
 * \brief Spell types used by project() and related functions.
 *
 * ===== NOTICE =====
 * If you add new entries to this file, you must
 * also update lib/gamedata/projection.txt!
 * ===== NOTICE =====
 */
project_monster_handler_NOTHING,
project_monster_handler_HURT,
project_monster_handler_ARROW,
project_monster_handler_BOULDER,
project_monster_handler_SOUND,
project_monster_handler_FORCE,
project_monster_handler_LIGHT,
project_monster_handler_KILL_WALL,
project_monster_handler_SLEEP,
project_monster_handler_SPEED,
project_monster_handler_SLOW,
project_monster_handler_CONFUSION,
project_monster_handler_FEAR,
project_monster_handler_EARTHQUAKE,
project_monster_handler_DARK_WEAK,
project_monster_handler_KILL_DOOR,
project_monster_handler_LOCK_DOOR,
project_monster_handler_KILL_TRAP,
project_monster_handler_DISP_ALL, /* Debug only */

 NULL
};
/**
 * Deal damage to a monster from another monster.
 *
 * This is a helper for project_m(). It is very similar to mon_take_hit(),
 * but eliminates the player-oriented stuff of that function. It isn't a type
 * handler, but we take a handler context since that has a lot of what we need.
 *
 * \param context is the project_m context.
 * \param m_idx is the cave monster index.
 * \return true if the monster died, false if it is still alive.
 */
static bool project_m_monster_attack(project_monster_handler_context_t *context, int m_idx)
{
 bool mon_died = false;
 bool seen = context->seen;
 int dam = context->dam;
 enum mon_messages die_msg = context->die_msg;
 enum mon_messages hurt_msg = context->hurt_msg;
 struct monster *mon = context->mon;
 /* Redraw (later) if needed */
 if (player->upkeep->health_who == mon)
  player->upkeep->redraw |= (PR_HEALTH);
 /* Become active */
 mflag_on(mon->mflag, MFLAG_ACTIVE);
 /* Hurt the monster */
 mon->hp -= dam;
 /* Dead or damaged monster */
 if (mon->hp <= 0) {
  /* Give detailed messages if destroyed */
  if (!seen) die_msg = MON_MSG_MORIA_DEATH;
  /* Death message */
  add_monster_message(mon, die_msg, false);
  /* Generate treasure, etc */
  monster_death(mon, player, false, NULL, false);
  mon_died = true;
 } else {
  /* Alert it */
  make_alert(mon, 0);
  /* Give detailed messages if visible or destroyed */
  if (seen) {
   if (hurt_msg != MON_MSG_NONE) {
    add_monster_message(mon, hurt_msg, false);
   }
  } else if (dam > 0) {
   /* Pain message */
   message_pain(mon, dam);
  }
 }
 return mon_died;
}
/**
 * Deal damage to a monster from a non-monster source (usually a player,
 * but could also be a trap)
 *
 * This is a helper for project_m(). It isn't a type handler, but we take a
 * handler context since that has a lot of what we need.
 *
 * \param context is the project_m context.
 * \return true if the monster died, false if it is still alive.
 */
static bool project_m_player_attack(project_monster_handler_context_t *context)
{
 bool mon_died = false;
 bool seen = context->seen;
 int dam = context->dam;
 enum mon_messages die_msg = context->die_msg;
 enum mon_messages hurt_msg = context->hurt_msg;
 struct monster *mon = context->mon;
 /* The monster is going to be killed, so display a specific death message.
	 * If the monster is not visible to the player, use a generic message.
	 *
	 * Note that mon_take_hit() below is passed a zero-length string, which
	 * ensures it doesn't print any death message and allows correct ordering
	 * of messages. */
 if (dam > mon->hp) {
  if (!seen) die_msg = MON_MSG_MORIA_DEATH;
  add_monster_message(mon, die_msg, false);
 }
 /* No damage is now going to mean the monster is not hit - and hence
	 * is not woken or released from holding */
 if (dam) {
  mon_died = mon_take_hit(mon, player, dam, "");
 }
 /* If the monster didn't die, provide additional messages about how it was
	 * hurt/damaged. If a specific message isn't provided, display a message
	 * based on the amount of damage dealt. Also display a message
	 * if the hit caused the monster to flee. */
 if (!mon_died) {
  if (seen) {
   if (hurt_msg != MON_MSG_NONE) {
    add_monster_message(mon, hurt_msg, false);
   }
  } else if (dam > 0) {
   message_pain(mon, dam);
  }
 }
 return mon_died;
}
/**
 * Apply side effects from an attack onto a monster.
 *
 * This is a helper for project_m(). It isn't a type handler, but we take a
 * handler context since that has a lot of what we need.
 *
 * \param context is the project_m context.
 * \param m_idx is the cave monster index.
 */
static void project_m_apply_side_effects(project_monster_handler_context_t *context, int m_idx)
{
 struct monster *mon = context->mon;
 for (int i = 0; i < MON_TMD_MAX; i++) {
  if (context->mon_timed[i] > 0) {
   mon_inc_timed(mon,
        i,
        context->mon_timed[i],
        context->flag | MON_TMD_FLG_NOTIFY);
   context->obvious = context->seen;
  }
 }
}
/**
 * Called from project() to affect monsters
 *
 * Called for projections with the PROJECT_KILL flag set, which includes
 * bolt, beam, ball and breath effects.
 *
 * \param origin is the monster list index of the caster
 * \param r is the distance from the centre of the effect
 * \param y the coordinates of the grid being handled
 * \param x the coordinates of the grid being handled
 * \param dam is the "damage" from the effect at distance r from the centre
 * \param typ is the projection (PROJ_) type
 * \param flg consists of any relevant PROJECT_ flags
 * \return whether the effects were obvious
 *
 * Note that this routine can handle "no damage" attacks (like teleport) by
 * taking a zero damage, and can even take parameters to attacks (like
 * confuse) by accepting a "damage", using it to calculate the effect, and
 * then setting the damage to zero.  Note that actual damage should be already 
 * adjusted for distance from the "epicenter" when passed in, but other effects 
 * may be influenced by r.
 *
 * Note that "polymorph" is dangerous, since a failure in "place_monster()"'
 * may result in a dereference of an invalid pointer.  XXX XXX XXX
 *
 * Various messages are produced, and damage is applied.
 *
 * Just casting an element (e.g. plasma) does not make you immune, you must
 * actually be made of that substance, or breathe big balls of it.
 *
 * We assume that "Plasma" monsters, and "Plasma" breathers, are immune
 * to plasma.
 *
 * We assume "Nether" is an evil, necromantic force, so it doesn't hurt undead,
 * and hurts evil less.  If can breath nether, then it resists it as well.
 * This should actually be coded into monster records rather than aasumed - NRM
 *
 * Damage reductions use the following formulas:
 *   Note that "dam = dam * 6 / (randint1(6) + 6);"
 *     gives avg damage of .655, ranging from .858 to .500
 *   Note that "dam = dam * 5 / (randint1(6) + 6);"
 *     gives avg damage of .544, ranging from .714 to .417
 *   Note that "dam = dam * 4 / (randint1(6) + 6);"
 *     gives avg damage of .444, ranging from .556 to .333
 *   Note that "dam = dam * 3 / (randint1(6) + 6);"
 *     gives avg damage of .327, ranging from .427 to .250
 *   Note that "dam = dam * 2 / (randint1(6) + 6);"
 *     gives something simple.
 *
 * In this function, "result" messages are postponed until the end, where
 * the "note" string is appended to the monster name, if not NULL.  So,
 * to make a spell have no effect just set "note" to NULL.  You should
 * also set "notice" to false, or the player will learn what the spell does.
 *
 * Note that this function determines if the player can see anything that
 * happens by taking into account: blindness, line-of-sight, and illumination.
 *
 * Hack -- effects on grids which are memorized but not in view are also seen.
 */
void project_m(struct source origin, int r, struct loc grid, int dam, int ds,
      int dif, int typ, int flg, bool *did_hit, bool *was_obvious)
{
 struct monster *mon;
 struct monster_lore *lore;
 /* Is the monster "seen"? */
 bool seen = false;
 bool mon_died = false;
 /* Is the effect obvious? */
 bool obvious = false;
 /* Are we trying to id the source of this effect? */
 bool id = (origin.what == SRC_PLAYER) ? !obvious : false;
 int m_idx = square(cave, grid)->mon;
 project_monster_handler_f monster_handler = monster_handlers[typ];
 project_monster_handler_context_t context = {
  origin,
  r,
  grid,
  dam,
  dif,
  typ,
  seen,
  id,
  NULL, /* mon */
  NULL, /* lore */
  obvious,
  false, /* skipped */
  true, /* alert */
  0, /* flag */
  MON_MSG_NONE, /* hurt_msg */
  MON_MSG_DIE, /* die_msg */
  { 0, 0, 0, 0 },
 };
 *did_hit = false;
 *was_obvious = false;
 /* Walls protect monsters */
 if (!square_ispassable(cave, grid)) return;
 /* No monster here */
 if (!(m_idx > 0)) return;
 /* Never affect projector */
 if (origin.what == SRC_MONSTER && origin.which.monster == m_idx) return;
 /* Obtain monster info */
 mon = cave_monster(cave, m_idx);
 lore = get_lore(mon->race);
 context.mon = mon;
 context.lore = lore;
 /* See visible monsters */
 if (monster_is_visible(mon)) {
  seen = true;
  context.seen = seen;
 }
 /* Some monsters get "destroyed" */
 if (monster_is_nonliving(mon))
  context.die_msg = MON_MSG_DESTROYED;
 /* Force obviousness for certain types if seen. */
 if (projections[typ].obvious && context.seen)
  context.obvious = true;
 /* Monster goes active */
 mflag_on(mon->mflag, MFLAG_ACTIVE);
 /* Mark the monster as attacked by the player */
 if (origin.what == SRC_PLAYER) mflag_on(mon->mflag, MFLAG_HIT_BY_RANGED);
 if (monster_handler != NULL)
  monster_handler(&context);
 /* Wake monster if required */
 if (projections[typ].wake)
  make_alert(mon, 0);
 /* Absolutely no effect */
 if (context.skipped) return;
 /* Apply damage to the monster, based on who did the damage. */
 if (origin.what == SRC_MONSTER) {
  mon_died = project_m_monster_attack(&context, m_idx);
 } else {
  mon_died = project_m_player_attack(&context);
 }
 if (!mon_died)
  project_m_apply_side_effects(&context, m_idx);
 /* Update locals, since the project_m_* functions can change some values. */
 mon = context.mon;
 obvious = context.obvious;
 /* Check for NULL, since polymorph can occasionally return NULL. */
 if (mon != NULL) {
  /* Update the monster */
  if (!mon_died)
   update_mon(mon, cave, false);
  /* Redraw the (possibly new) monster grid */
  square_light_spot(cave, mon->grid);
  /* Update monster recall window */
  if (player->upkeep->monster_race == mon->race) {
   /* Window stuff */
   player->upkeep->redraw |= (PR_MONSTER);
  }
 }
 /* Track it */
 *did_hit = true;
 /* Return "Anything seen?" */
 *was_obvious = !!obvious;
}
/**
 * \file project-obj.c
 * \brief projection effects on objects
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Destroys a type of item on a given percent chance.
 * The chance 'cperc' is in hundredths of a percent (1-in-10000)
 * Note that missiles are no longer necessarily all destroyed
 *
 * Returns number of items destroyed.
 */
int inven_damage(struct player *p, int type, int perc, int resistance)
{
 int k = 0;
 struct object *obj = p->gear;
 /* No chance means no damage */
 if (perc <= 0) return 0;
 /* Scan through the gear */
 while (obj) {
  struct object *next = obj->next;
  if (object_is_equipped(p->body, obj)) {
   obj = next;
   continue;
  }
  /* Hack -- for now, skip artifacts */
  if (obj->artifact) {
   obj = next;
   continue;
  }
  /* Give this item slot a shot at death if it is vulnerable */
  if ((obj->el_info[type].flags & EL_INFO_HATES) &&
   !(obj->el_info[type].flags & EL_INFO_IGNORE)) {
   /* Chance to destroy this item */
   int j, amt;
   /* Count the casualties */
   for (amt = j = 0; j < obj->number; ++j) {
    if (percent_chance(perc) &&
     ((resistance < 0) || one_in_(resistance))) {
     amt++;
    }
   }
   /* Some casualities */
   if (amt) {
    char o_name[80];
    struct object *destroyed;
    bool none_left = false;
    /* Get a description */
    object_desc(o_name, sizeof(o_name), obj,
     ODESC_BASE, p);
    /* Message */
    msgt(MSG_DESTROY, "%sour %s (%c) %s destroyed!",
      ((obj->number > 1) ?
       ((amt == obj->number) ? "All of y" :
        (amt > 1 ? "Some of y" : "One of y")) : "Y"),
      o_name,
      gear_to_label(p, obj),
      ((amt > 1) ? "were" : "was"));
    /* Destroy "amt" items */
    destroyed = gear_object_for_use(p, obj, amt, false, &none_left);
    if (destroyed->known)
     object_delete(NULL, NULL, &destroyed->known);
    object_delete(NULL, NULL, &destroyed);
    /* Count the casualties */
    k += amt;
   }
  }
  obj = next;
 }
 /* Return the casualty count */
 return k;
}
/**
 * ------------------------------------------------------------------------
 * Object handlers
 * ------------------------------------------------------------------------ */
typedef struct project_object_handler_context_s {
 const struct loc grid;
 const int type;
 const struct object *obj;
 bool obvious;
 bool do_kill;
 bool ignore;
 const char *note_kill;
} project_object_handler_context_t;
typedef void (*project_object_handler_f)(project_object_handler_context_t *);
/**
 * Project an effect onto an object.
 *
 * \param context is the project_o context.
 * \param element is for elements that will destroy an object, or that it will
 * ignore.
 * \param singular_verb is the verb that is displayed when one object is
 * destroyed.
 * \param plural_verb is the verb that is displayed in multiple objects are
 * destroyed.
 */
static void project_object_elemental(project_object_handler_context_t *context,
          int element, const char *singular_verb,
          const char *plural_verb)
{
 if (context->obj->el_info[element].flags & EL_INFO_HATES) {
  context->do_kill = true;
  context->note_kill = VERB_AGREEMENT(context->obj->number,
           singular_verb, plural_verb);
  context->ignore = (context->obj->el_info[element].flags &
         EL_INFO_IGNORE) ? true : false;
 }
}
/* Fire -- Flammable objects */
static void project_object_handler_FIRE(project_object_handler_context_t *context)
{
 project_object_elemental(context, ELEM_FIRE, "burns up", "burn up");
}
/* Cold -- potions and flasks */
static void project_object_handler_COLD(project_object_handler_context_t *context)
{
 project_object_elemental(context, ELEM_COLD, "shatters", "shatter");
}
static void project_object_handler_POIS(project_object_handler_context_t *context)
{
}
static void project_object_handler_DARK(project_object_handler_context_t *context)
{
}
static void project_object_handler_NOTHING(project_object_handler_context_t *context)
{
}
static void project_object_handler_HURT(project_object_handler_context_t *context)
{
}
static void project_object_handler_ARROW(project_object_handler_context_t *context)
{
}
static void project_object_handler_BOULDER(project_object_handler_context_t *context)
{
}
/* Acid -- Lots of things */
static void project_object_handler_ACID(project_object_handler_context_t *context)
{
 project_object_elemental(context, ELEM_ACID, "melts", "melt");
}
/* Sound -- potions and flasks */
static void project_object_handler_SOUND(project_object_handler_context_t *context)
{
 project_object_elemental(context, PROJ_SOUND, "shatters", "shatter");
}
static void project_object_handler_FORCE(project_object_handler_context_t *context)
{
}
static void project_object_handler_LIGHT(project_object_handler_context_t *context)
{
}
static void project_object_handler_KILL_WALL(project_object_handler_context_t *context)
{
}
static void project_object_handler_SLEEP(project_object_handler_context_t *context)
{
}
static void project_object_handler_SPEED(project_object_handler_context_t *context)
{
}
static void project_object_handler_SLOW(project_object_handler_context_t *context)
{
}
static void project_object_handler_CONFUSION(project_object_handler_context_t *context)
{
}
static void project_object_handler_FEAR(project_object_handler_context_t *context)
{
}
static void project_object_handler_EARTHQUAKE(project_object_handler_context_t *context)
{
 project_object_elemental(context, PROJ_SOUND, "shatters", "shatter");
}
static void project_object_handler_DARK_WEAK(project_object_handler_context_t *context)
{
}
static void project_object_handler_KILL_DOOR(project_object_handler_context_t *context)
{
 /* Chests are noticed only if trapped or locked */
 if (is_locked_chest(context->obj)) {
  /* Disarm or Unlock */
  unlock_chest((struct object * const)context->obj);
  /* Notice */
  if (context->obj->pval == context->obj->known->pval) {
   msg("Click!");
   context->obvious = true;
  }
 }
}
static void project_object_handler_LOCK_DOOR(project_object_handler_context_t *context)
{
}
/* Unlock chests */
static void project_object_handler_KILL_TRAP(project_object_handler_context_t *context)
{
 /* Chests are noticed only if trapped or locked */
 if (is_locked_chest(context->obj)) {
  /* Disarm or Unlock */
  unlock_chest((struct object * const)context->obj);
  /* Notice */
  if (context->obj->pval == context->obj->known->pval) {
   msg("Click!");
   context->obvious = true;
  }
 }
}
static void project_object_handler_DISP_ALL(project_object_handler_context_t *context)
{
}
static const project_object_handler_f object_handlers[] = {
/**
 * \file list-elements.h
 * \brief Elements used in spells and other attacks.
 */
project_object_handler_ACID,
project_object_handler_FIRE,
project_object_handler_COLD,
project_object_handler_POIS,
project_object_handler_DARK,
/**
 * \file list-projections.h
 * \brief Spell types used by project() and related functions.
 *
 * ===== NOTICE =====
 * If you add new entries to this file, you must
 * also update lib/gamedata/projection.txt!
 * ===== NOTICE =====
 */
project_object_handler_NOTHING,
project_object_handler_HURT,
project_object_handler_ARROW,
project_object_handler_BOULDER,
project_object_handler_SOUND,
project_object_handler_FORCE,
project_object_handler_LIGHT,
project_object_handler_KILL_WALL,
project_object_handler_SLEEP,
project_object_handler_SPEED,
project_object_handler_SLOW,
project_object_handler_CONFUSION,
project_object_handler_FEAR,
project_object_handler_EARTHQUAKE,
project_object_handler_DARK_WEAK,
project_object_handler_KILL_DOOR,
project_object_handler_LOCK_DOOR,
project_object_handler_KILL_TRAP,
project_object_handler_DISP_ALL, /* Debug only */

 NULL
};
/**
 * Called from project() to affect objects
 *
 * Called for projections with the PROJECT_ITEM flag set, which includes
 * beam, ball and breath effects.
 *
 * \param grid the coordinates of the grid being handled
 * \param typ is the projection (PROJ_) type
 * \param protected_obj is an object that should not be affected by the
 *        projection, typically the object that created it
 * \return whether the effects were obvious
 *
 * Note that this function determines if the player can see anything that
 * happens by taking into account: blindness, line-of-sight, and illumination.
 *
 * Hack -- effects on objects which are memorized but not in view are also seen.
 */
bool project_o(struct loc grid, int typ, const struct object *protected_obj)
{
 struct object *obj = square_object(cave, grid);
 bool obvious = false;
 /* Scan all objects in the grid */
 while (obj) {
  bool ignore = false;
  bool do_kill = false;
  const char *note_kill = NULL;
  struct object *next = obj->next;
  project_object_handler_f object_handler = object_handlers[typ];
  project_object_handler_context_t context = {
   grid,
   typ,
   obj,
   obvious,
   do_kill,
   ignore,
   note_kill,
  };
  if (object_handler != NULL)
   object_handler(&context);
  obvious = context.obvious;
  do_kill = context.do_kill && (obj != protected_obj);
  ignore = context.ignore;
  note_kill = context.note_kill;
  /* Attempt to destroy the object */
  if (do_kill) {
   char o_name[80];
   /* Effect observed */
   if (obj->known && !ignore_item_ok(player, obj) &&
    square_isseen(cave, grid)) {
    obvious = true;
    object_desc(o_name, sizeof(o_name), obj,
     ODESC_BASE, player);
   }
   /* Artifacts, and other objects, get to resist */
   if (obj->artifact || ignore) {
    /* Observe the resist */
    if (obvious && !ignore_item_ok(player, obj)) {
     msg("The %s %s unaffected!", o_name,
      VERB_AGREEMENT(obj->number, "is", "are"));
    }
   } else {
    /* Describe if needed */
    if (obvious && note_kill && !ignore_item_ok(player, obj)) {
     msgt(MSG_DESTROY, "The %s %s!", o_name, note_kill);
    }
    /* Prevent command repetition, if necessary. */
    if (loc_eq(grid, player->grid)) {
     cmd_disable_repeat_floor_item();
    }
    /* Delete the object */
    square_delete_object(cave, grid, obj, true, true);
   }
  }
  /* Next object */
  obj = next;
 }
 /* Return "Anything seen?" */
 return obvious;
}
/**
 * \file project-player.c
 * \brief projection effects on the player
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
typedef struct project_player_handler_context_s {
 const struct source origin;
 const struct loc grid;
 struct monster *mon;
 int dd;
 int ds;
 int dam;
 const int type;
} project_player_handler_context_t;
/**
 * Adjust damage according to resistance or vulnerability.
 *
 * \param p is the player
 * \param type is the attack type we are checking.
 * \param dam is the unadjusted damage.
 * \param resist is the degree of resistance (-1 = vuln, 3 = immune).
 */
int adjust_dam(struct player *p, int dd, int ds, int type)
{
 int prt = protection_roll(p, type, false, RANDOMISE);
 int dam = damroll(dd, ds);
 int resist = 1;
 int net_dam;
 /* If an actual player exists, get their actual resist */
 if (p && p->race) {
  resist = type < ELEM_MAX ? p->state.el_info[type].res_level : 0;
  /* Hack for acid */
  if (!type) resist = 1;
  if (resist < 1) resist -= 2;
 }
 /* Get the actual damage */
 net_dam = dam / resist;
 net_dam = net_dam > prt ? net_dam - prt : 0;
 event_signal_combat_damage(EVENT_COMBAT_DAMAGE, dd, ds, dam, -1, -1, prt,
          100, type, false);
 return net_dam;
}
/**
 * ------------------------------------------------------------------------
 * Player handlers
 * ------------------------------------------------------------------------ */
typedef void (*project_player_handler_f)(project_player_handler_context_t *);
static void project_player_handler_FIRE(project_player_handler_context_t *context)
{
 inven_damage(player, PROJ_FIRE, MIN(context->dam / 10, 3), 1);
 equip_learn_element(player, ELEM_FIRE);
}
static void project_player_handler_COLD(project_player_handler_context_t *context)
{
 inven_damage(player, PROJ_FIRE, MIN(context->dam / 10, 3), 1);
 equip_learn_element(player, ELEM_COLD);
}
static void project_player_handler_POIS(project_player_handler_context_t *context)
{
 player_inc_timed(player, TMD_POISONED, context->dam, true, true, false);
 equip_learn_element(player, ELEM_POIS);
}
static void project_player_handler_DARK(project_player_handler_context_t *context)
{
 int resistance = MAX(1, square_light(cave, player->grid));
 if (one_in_(resistance)) {
  (void)player_inc_timed(player, TMD_BLIND, damroll(2, 4),
   true, true, true);
 }
}
static void project_player_handler_NOTHING(project_player_handler_context_t *context)
{
}
static void project_player_handler_HURT(project_player_handler_context_t *context)
{
}
static void project_player_handler_ARROW(project_player_handler_context_t *context)
{
}
static void project_player_handler_BOULDER(project_player_handler_context_t *context)
{
}
static void project_player_handler_ACID(project_player_handler_context_t *context)
{
 if (context->dam) {
  minus_ac(player);
  inven_damage(player, PROJ_ACID, MIN(context->dam / 10, 3), 1);
 }
}
static void project_player_handler_SOUND(project_player_handler_context_t *context)
{
 /* Stun */
 if (!player_inc_timed(player, TMD_STUN, context->dam, true, true,
   true)) {
  msg("You are unfazed");
 }}
static void project_player_handler_FORCE(project_player_handler_context_t *context)
{
}
static void project_player_handler_LIGHT(project_player_handler_context_t *context)
{
}
static void project_player_handler_KILL_WALL(project_player_handler_context_t *context)
{
}
static void project_player_handler_SLEEP(project_player_handler_context_t *context)
{
}
static void project_player_handler_SPEED(project_player_handler_context_t *context)
{
}
static void project_player_handler_SLOW(project_player_handler_context_t *context)
{
}
static void project_player_handler_CONFUSION(project_player_handler_context_t *context)
{
}
static void project_player_handler_FEAR(project_player_handler_context_t *context)
{
}
static void project_player_handler_EARTHQUAKE(project_player_handler_context_t *context)
{
}
static void project_player_handler_DARK_WEAK(project_player_handler_context_t *context)
{
}
static void project_player_handler_KILL_DOOR(project_player_handler_context_t *context)
{
}
static void project_player_handler_LOCK_DOOR(project_player_handler_context_t *context)
{
}
static void project_player_handler_KILL_TRAP(project_player_handler_context_t *context)
{
}
static void project_player_handler_DISP_ALL(project_player_handler_context_t *context)
{
}
/**
 * Handle monster missiles (arrows, boulders) incoming on the player
 *
 * This is not a player handler, but takes a context argument anyway.
 * This function assumes that the attack is either arrow or boulder.
 */
static void monster_ranged_attack(project_player_handler_context_t *context,
          char *killer)
{
 int total_attack_mod, total_evasion_mod, crit_bonus_dice, hit_result;
 int total_dd, total_ds;
 int prt, dam, net_dam, weight;
 struct monster *mon = context->mon;
 struct monster_race *race = mon->race;
 bool arrow = context->type == PROJ_ARROW;
 /* Determine the monster's attack score */
 total_attack_mod = total_monster_attack(player, mon, race->spell_power);
 /* Determine the player's evasion score */
 total_evasion_mod = total_player_evasion(player, mon, false);
 /* Archery-specific stuff */
 if (arrow) {
  /* Target only gets half the evasion modifier against archery */
  total_evasion_mod /= 2;
  /* Simulate weights of longbows and shortbows */
  if (context->ds >= 11) {
   weight = 30;
  } else {
   weight = 20;
  }
 } else {
  weight = 100;
 }
 /* Perform the hit roll */
 hit_result = hit_roll(total_attack_mod, total_evasion_mod,
        source_monster(mon->midx), source_player(), true);
 if (hit_result > 0) {
  crit_bonus_dice = crit_bonus(player, hit_result, weight, &r_info[0],
          SKILL_ARCHERY, !arrow);
  total_dd = context->dd + crit_bonus_dice;
  total_ds = context->ds;
  dam = damroll(total_dd, total_ds);
  /* Armour is effective against arrows and boulders */
  prt = protection_roll(player, PROJ_HURT, false, RANDOMISE);
  net_dam = (dam - prt > 0) ? (dam - prt) : 0;
  if (player->timed[TMD_BLIND]) {
   msg("You are hit by %s.", projections[context->type].blind_desc);
  } else {
   if (net_dam > 0) {
    if (crit_bonus_dice == 0) {
     msg("It hits you.");
    } else {
     msg("It hits!");
    }
   }
  }
  event_signal_combat_damage(EVENT_COMBAT_DAMAGE, total_dd, total_ds, dam,
           -1, -1, prt, 100, PROJ_HURT, false);
  event_signal_hit(EVENT_HIT, net_dam, PROJ_HURT, player->is_dead,
       player->grid);
  if (net_dam) {
   take_hit(player, net_dam, killer);
   /* Deal with crippling shot ability */
   if (arrow && rf_has(race->flags, RF_CRIPPLING) &&
    (crit_bonus_dice >= 1) && (net_dam > 0)) {
    /* Sil-y: ideally we'd use a call to allow_player_slow()
				 * here, but that doesn't work as it can't take the
				 * level of the critical into account. Sadly my solution
				 * doesn't let you ID free action items. */
    int difficulty = player->state.skill_use[SKILL_WILL] +
     player->state.flags[OF_FREE_ACT] * 10;
    if (skill_check(source_monster(mon->midx), crit_bonus_dice * 4,
        difficulty, source_player()) > 0) {
     struct monster_lore *lore = get_lore(race);
     /* Remember that the monster can do this */
     if (monster_is_visible(mon)) {
      rf_on(lore->flags, RF_CRIPPLING);
     }
     msg("The shot tears into your thigh!");
     /* Slow the player */
     player_inc_timed(player, TMD_SLOW,
      crit_bonus_dice,
      true, true, false);
    }
   }
  }
  /* Make some noise */
  monsters_hear(true, false, arrow ? -5 : -10);
 }
}
static const project_player_handler_f player_handlers[] = {
/**
 * \file list-elements.h
 * \brief Elements used in spells and other attacks.
 */
project_player_handler_ACID,
project_player_handler_FIRE,
project_player_handler_COLD,
project_player_handler_POIS,
project_player_handler_DARK,
/**
 * \file list-projections.h
 * \brief Spell types used by project() and related functions.
 *
 * ===== NOTICE =====
 * If you add new entries to this file, you must
 * also update lib/gamedata/projection.txt!
 * ===== NOTICE =====
 */
project_player_handler_NOTHING,
project_player_handler_HURT,
project_player_handler_ARROW,
project_player_handler_BOULDER,
project_player_handler_SOUND,
project_player_handler_FORCE,
project_player_handler_LIGHT,
project_player_handler_KILL_WALL,
project_player_handler_SLEEP,
project_player_handler_SPEED,
project_player_handler_SLOW,
project_player_handler_CONFUSION,
project_player_handler_FEAR,
project_player_handler_EARTHQUAKE,
project_player_handler_DARK_WEAK,
project_player_handler_KILL_DOOR,
project_player_handler_LOCK_DOOR,
project_player_handler_KILL_TRAP,
project_player_handler_DISP_ALL, /* Debug only */

 NULL
};
/**
 * Called from project() to affect the player
 *
 * Called for projections with the PROJECT_PLAY flag set, which includes
 * bolt, beam, ball and breath effects.
 *
 * \param src is the origin of the effect
 * \param r is the distance from the centre of the effect
 * \param y the coordinates of the grid being handled
 * \param x the coordinates of the grid being handled
 * \param dam is the "damage" from the effect at distance r from the centre
 * \param typ is the projection (PROJ_) type
 * \return whether the effects were obvious
 *
 * If "r" is non-zero, then the blast was centered elsewhere; the damage
 * is reduced in project() before being passed in here.  This can happen if a
 * monster breathes at the player and hits a wall instead.
 *
 * We assume the player is aware of some effect, and always return "true".
 */
bool project_p(struct source origin, struct loc grid, int dd, int ds, int typ)
{
 bool blind = (player->timed[TMD_BLIND] ? true : false);
 bool seen = !blind;
 int dam = damroll(dd, ds);
 /* Monster or trap name (for damage) */
 char killer[80];
 project_player_handler_f player_handler = player_handlers[typ];
 project_player_handler_context_t context = {
  origin,
  grid,
  NULL,
  dd,
  ds,
  dam,
  typ
 };
 /* No player here */
 if (!square_isplayer(cave, grid)) {
  return false;
 }
 switch (origin.what) {
  case SRC_PLAYER: {
   /* Don't affect projector */
   return false;
   break;
  }
  case SRC_MONSTER: {
   struct monster *mon = cave_monster(cave, origin.which.monster);
   context.mon = mon;
   /* Check it is visible */
   if (!monster_is_visible(mon))
    seen = false;
   /* Get the monster's real name */
   monster_desc(killer, sizeof(killer), mon, MDESC_DIED_FROM);
   break;
  }
  case SRC_TRAP: {
   struct trap *trap = origin.which.trap;
   /* Get the trap name */
   strnfmt(killer, sizeof(killer), "a %s", trap->kind->desc);
   break;
  }
  case SRC_OBJECT: {
   struct object *obj = origin.which.object;
   object_desc(killer, sizeof(killer), obj,
    ODESC_PREFIX | ODESC_BASE, player);
   break;
  }
  case SRC_CHEST_TRAP: {
   struct chest_trap *trap = origin.which.chest_trap;
   /* Get the trap name */
   strnfmt(killer, sizeof(killer), "%s", trap->msg_death);
   break;
  }
  default: {
   my_strcpy(killer, "a bug", sizeof(killer));
   break;
  }
 }
 /* Let player know what is going on */
 if (!seen) {
  msg("You are hit by %s!", projections[typ].blind_desc);
 }
 /* Adjust damage for resistance, immunity or vulnerability */
 if (typ < ELEM_MAX) {
  event_signal_combat_attack(EVENT_COMBAT_ATTACK, origin,
   source_player(), true, -1, -1, -1, -1, false);
  context.dam = adjust_dam(player, context.dd, context.ds, context.type);
 }
 /* Apply the damage */
 if (context.dam && projections[typ].damaging) {
  /* Some attacks get a chance to evade and/or protect */
  if (projections[typ].evade) {
   monster_ranged_attack(&context, killer);
  } else {
   take_hit(player, context.dam, killer);
  }
 }
 /* Handle side effects */
 if (player_handler != NULL && player->is_dead == false) {
  player_handler(&context);
 }
 /* Disturb */
 disturb(player, true);
 /* Return "Anything seen?" */
 return true;
}
/**
 * \file randname.c
 * \brief Random name generation
 *
 * Copyright (c) 2007 Antony Sidwell, Sheldon Simms
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/* Markers for the start and end of words. */
/**
 * Array[RANDNAME_NUM_TYPES][num_names] of random names
 */
const char *** name_sections;
typedef unsigned short name_probs[26 +1][26 +1][27 +1];
/**
 * This function builds probability tables from a list of purely alphabetical
 * lower-case words, and puts them into the supplied name_probs object.
 * The array of names should have a NULL entry at the end of the list.
 * It relies on the ASCII character set (through use of A2I).
 */
static void build_prob(name_probs probs, const char **learn)
{
 int c_prev, c_cur, c_next;
 const char *ch;
 int i;
 /* Build raw frequencies */
 for (i = 0; learn[i] != NULL; i++) {
  c_prev = c_cur = 26;
  ch = learn[i];
  /* Iterate over the next word */
  while (*ch != '\0') {
   c_next = A2I(tolower((unsigned char)*ch));
   probs[c_prev][c_cur][c_next]++;
   probs[c_prev][c_cur][27]++;
   /* Step on */
   c_prev = c_cur;
   c_cur = c_next;
   ch++;
  }
  probs[c_prev][c_cur][26]++;
  probs[c_prev][c_cur][27]++;
 }
}
/**
 * Use W. Sheldon Simms' random name generator algorithm (Markov Chain stylee).
 * 
 * Generate a random word using the probability tables we built earlier.  
 * Relies on the A2I and I2A macros (and so the ASCII character set) and 
 * is_a_vowel (so the basic 5 English vowels).
 */
size_t randname_make(randname_type name_type, size_t min, size_t max,
      char *word_buf, size_t buflen, const char ***sections)
{
 size_t lnum = 0;
 bool found_word = false;
 static name_probs lprobs;
 static randname_type cached_type = RANDNAME_NUM_TYPES;
 assert(name_type > 0 && name_type < RANDNAME_NUM_TYPES);
 /* To allow for a terminating character */
 assert(buflen > max);
 /* We cache one set of probabilities, only regenerate when
	   the type changes.  It's as good a way as any for now.
	   Frankly, we could probably regenerate every time. */
 if (cached_type != name_type) {
  const char **wordlist = NULL;
  wordlist = sections[name_type];
  (void)memset(lprobs, 0, sizeof(name_probs));
  build_prob(lprobs, wordlist);
  cached_type = name_type;
 }
 /* Generate the actual word wanted. */
 while (!found_word) {
  char *cp = word_buf;
  int c_prev = 26;
  int c_cur = 26;
  int tries = 0;
  bool contains_vowel = false;
  lnum = 0;
  /* We start the word again if we run out of space or have
		   had to have 10 goes to find a word that satisfies the
		   minimal conditions. */
  while (tries < 10 && lnum <= max && !found_word) {
   /* Pick the next letter based on a simple weighting
			  of which letters can follow the previous two */
   int r;
   int c_next = 0;
   assert(c_prev >= 0 && c_prev <= 26);
   assert(c_cur >= 0 && c_cur <= 26);
   r = randint0(lprobs[c_prev][c_cur][27]);
   while (r >= lprobs[c_prev][c_cur][c_next]) {
    r -= lprobs[c_prev][c_cur][c_next];
    c_next++;
   }
   assert(c_next <= 26);
   assert(c_next >= 0);
   if (c_next == 26) {
    /* If we've reached the end, we check if we've
				   met the simple conditions, otherwise have
				   another go at choosing a letter for this
				   position. */
    if (lnum >= min && contains_vowel) {
     *cp = '\0';
     found_word = true;
    } else {
     tries++;
    }
   } else {
    /* Add the letter to the word and move on. */
    *cp = I2A(c_next);
    if (is_a_vowel(*cp))
     contains_vowel = true;
    cp++;
    lnum++;
    assert(c_next <= 26);
    assert(c_next >= 0);
    c_prev = c_cur;
    c_cur = c_next;
   }
  }
 }
 return lnum;
}
/**
 * To run standalone tests, #define RANDNAME_TESTING and link with
 *  with just z-rand.c from Angband. 
 */
/**
 * \file score.c
 * \brief Highscore handling for Angband
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * An integer value representing the player's "points".
 *
 * In reality it isn't so much a score as a number that has the same ordering
 * as the scores.
 *
 * It ranges from 100,000 to 141,399,999
 */
static int score_points(const struct high_score *score)
{
 int points = 0;
 int silmarils;
 int maxturns = 100000;
 int silmarils_factor = maxturns;
 int depth_factor = silmarils_factor * 10;
 int morgoth_factor = depth_factor * 100;
 /* Points from turns taken (00000 to 99999)  */
 points = maxturns - atoi(score->turns);
 if (points < 0) {
  points = 0;
 }
 if (points >= maxturns) {
  points = maxturns - 1;
 }
 /* Points from silmarils (0 00000 to 3 00000) */
 silmarils = atoi(score->silmarils);
 points += silmarils_factor * silmarils;
 /* Points from depth (01 0 00000 to 40 0 00000) */
 if (silmarils == 0) {
  points += depth_factor * atoi(score->cur_dun);
 } else {
  points += depth_factor * (40 - atoi(score->cur_dun));
 }
 /* Points for escaping (changes 40 0 00000 to 41 0 00000) */
 if (score->escaped[0] == 't') {
  points += depth_factor;
 }
 /* points slaying Morgoth  (0 00 0 00000 to 1 00 0 00000) */
 if (score->morgoth_slain[0] == 't') {
  points += morgoth_factor;
 }
 return points;
}
/**
 * Read in a highscore file.
 */
size_t highscore_read(struct high_score scores[], size_t sz)
{
 char fname[1024];
 ang_file *scorefile;
 size_t i;
 /* Wipe current scores */
 memset(scores, 0, sz * sizeof(struct high_score));
 path_build(fname, sizeof(fname), ANGBAND_DIR_SCORES, "scores.raw");
 safe_setuid_grab();
 scorefile = file_open(fname, MODE_READ, FTYPE_TEXT);
 safe_setuid_drop();
 if (!scorefile) return 0;
 for (i = 0; i < sz; i++)
  if (file_read(scorefile, (char *)&scores[i],
       sizeof(struct high_score)) <= 0)
   break;
 file_close(scorefile);
 return i;
}
/**
 * Just determine where a new score *would* be placed
 * Return the location (0 is best) or -1 on failure
 */
size_t highscore_where(const struct high_score *entry,
        const struct high_score scores[], size_t sz)
{
 size_t i;
 /* Read until we get to a higher score */
 for (i = 0; i < sz; i++) {
  int entry_pts = score_points(entry);
  int score_pts = score_points(&scores[i]);
  if (entry_pts >= score_pts)
   return i;
  if (scores[i].what[0] == '\0')
   return i;
 }
 /* The last entry is always usable */
 return sz - 1;
}
/**
 * Place an entry into a high score array
 */
size_t highscore_add(const struct high_score *entry, struct high_score scores[],
      size_t sz)
{
 size_t slot = highscore_where(entry, scores, sz);
 memmove(&scores[slot + 1], &scores[slot],
   sizeof(struct high_score) * (sz - 1 - slot));
 memcpy(&scores[slot], entry, sizeof(struct high_score));
 return slot;
}
static size_t highscore_count(const struct high_score scores[], size_t sz)
{
 size_t i;
 for (i = 0; i < sz; i++)
  if (scores[i].what[0] == '\0')
   break;
 return i;
}
/**
 * Actually place an entry into the high score file
 */
static void highscore_write(const struct high_score scores[], size_t sz)
{
 size_t n;
 ang_file *lok;
 ang_file *scorefile;
 char old_name[1024];
 char cur_name[1024];
 char new_name[1024];
 char lok_name[1024];
 bool exists;
 path_build(old_name, sizeof(old_name), ANGBAND_DIR_SCORES, "scores.old");
 path_build(cur_name, sizeof(cur_name), ANGBAND_DIR_SCORES, "scores.raw");
 path_build(new_name, sizeof(new_name), ANGBAND_DIR_SCORES, "scores.new");
 path_build(lok_name, sizeof(lok_name), ANGBAND_DIR_SCORES, "scores.lok");
 /* Read in and add new score */
 n = highscore_count(scores, sz);
 /* Lock scores */
 safe_setuid_grab();
 exists = file_exists(lok_name);
 safe_setuid_drop();
 if (exists) {
  msg("Lock file in place for scorefile; not writing.");
  return;
 }
 safe_setuid_grab();
 lok = file_open(lok_name, MODE_WRITE, FTYPE_RAW);
 if (!lok) {
  safe_setuid_drop();
  msg("Failed to create lock for scorefile; not writing.");
  return;
 } else {
  file_lock(lok);
  safe_setuid_drop();
 }
 /* Open the new file for writing */
 safe_setuid_grab();
 scorefile = file_open(new_name, MODE_WRITE, FTYPE_RAW);
 safe_setuid_drop();
 if (!scorefile) {
  msg("Failed to open new scorefile for writing.");
  file_close(lok);
  safe_setuid_grab();
  file_delete(lok_name);
  safe_setuid_drop();
  return;
 }
 file_write(scorefile, (const char *)scores, sizeof(struct high_score)*n);
 file_close(scorefile);
 /* Now move things around */
 safe_setuid_grab();
 if (file_exists(old_name) && !file_delete(old_name))
  msg("Couldn't delete old scorefile");
 if (file_exists(cur_name) && !file_move(cur_name, old_name))
  msg("Couldn't move old scores.raw out of the way");
 if (!file_move(new_name, cur_name))
  msg("Couldn't rename new scorefile to scores.raw");
 /* Remove the lock */
 file_close(lok);
 file_delete(lok_name);
 safe_setuid_drop();
}
/**
 * Fill in a score record for the given player.
 *
 * \param entry points to the record to fill in.
 * \param p is the player whose score should be recorded.
 * \param died_from is the reason for death.  In typical use, that will be
 * p->died_from, but when the player isn't dead yet, the caller may want to
 * use something else:  "nobody (yet!)" is traditional.
 * \param death_time points to the time at which the player died.  May be NULL
 * when the player isn't dead.
 *
 * Bug:  takes a player argument, but still accesses a bit of global state,
 * player_uid, referring to the player
 */
void build_score(struct high_score *entry, const struct player *p,
  const char *died_from, const time_t *death_time)
{
 memset(entry, 0, sizeof(struct high_score));
 /* Save the version */
 strnfmt(entry->what, sizeof(entry->what), "%s", buildid);
 /* Save the current turn */
 strnfmt(entry->turns, sizeof(entry->turns), "%9ld", (long)p->turn);
 /* Time of death */
 if (death_time)
  strftime(entry->day, sizeof(entry->day), "@%Y%m%d",
     localtime(death_time));
 else
  my_strcpy(entry->day, "TODAY", sizeof(entry->day));
 /* Save the player name (15 chars) */
 strnfmt(entry->who, sizeof(entry->who), "%-.15s", p->full_name);
 /* Save the player info XXX XXX XXX */
 strnfmt(entry->uid, sizeof(entry->uid), "%7u", player_uid);
 strnfmt(entry->p_s, sizeof(entry->p_s), "%2d", p->sex->sidx);
 strnfmt(entry->p_r, sizeof(entry->p_r), "%2d", p->race->ridx);
 strnfmt(entry->p_h, sizeof(entry->p_h), "%2d", p->house->hidx);
 /* Save the level and such */
 strnfmt(entry->cur_dun, sizeof(entry->cur_dun), "%3d", p->depth);
 strnfmt(entry->max_dun, sizeof(entry->max_dun), "%3d", p->max_depth);
 /* No cause of death */
 my_strcpy(entry->how, died_from, sizeof(entry->how));
 /* Save the number of silmarils, whether morgoth is slain,
	 * whether the player has escaped */
 strnfmt(entry->silmarils, sizeof(entry->silmarils), "%1d",
   silmarils_possessed((struct player *)p));
 if (p->morgoth_slain) {
  strnfmt(entry->morgoth_slain, sizeof(entry->morgoth_slain), "t");
 } else {
  strnfmt(entry->morgoth_slain, sizeof(entry->morgoth_slain), "f");
 }
 if (p->escaped) {
  strnfmt(entry->escaped, sizeof(entry->escaped), "t");
 } else {
  strnfmt(entry->escaped, sizeof(entry->escaped), "f");
 }
}
/**
 * Enter a player's name on a hi-score table, if "legal".
 *
 * \param p is the player to enter
 * \param death_time points to the time at which the player died; may be NULL
 * for a player that's not dead yet
 * Assumes "signals_ignore_tstp()" has been called.
 */
void enter_score(const struct player *p, const time_t *death_time)
{
 int j;
 /* Cheaters are not scored */
 for (j = 0; j < OPT_MAX; ++j) {
  if (option_type(j) != OP_SCORE)
   continue;
  if (!p->opts.opt[j])
   continue;
  msg("Score not registered for cheaters.");
  event_signal(EVENT_MESSAGE_FLUSH);
  return;
 }
 /* Add a new entry, if allowed */
 if (p->noscore & (NOSCORE_WIZARD | NOSCORE_DEBUG)) {
  msg("Score not registered for wizards.");
  event_signal(EVENT_MESSAGE_FLUSH);
 } else if (streq(p->died_from, "Interrupting")) {
  msg("Score not registered due to interruption.");
  event_signal(EVENT_MESSAGE_FLUSH);
 } else if (streq(p->died_from, "Retiring")) {
  msg("Score not registered due to retiring.");
  event_signal(EVENT_MESSAGE_FLUSH);
 } else {
  struct high_score entry;
  struct high_score scores[MAX_HISCORES];
  build_score(&entry, p, p->died_from, death_time);
  highscore_read(scores, N_ELEMENTS(scores));
  highscore_add(&entry, scores, N_ELEMENTS(scores));
  highscore_write(scores, N_ELEMENTS(scores));
 }
 /* Success */
 return;
}
/**
 * \file save.c
 * \brief Individual saving functions
 *
 * Copyright (c) 1997 Ben Harrison
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Write a description of the character
 */
void wr_description(void)
{
 char buf[1024];
 if (player->is_dead)
  strnfmt(buf, sizeof buf, "%s, dead (%s)",
    player->full_name,
    player->died_from);
 else
  strnfmt(buf, sizeof buf, "%s, Exp %ld %s %s, at DL%d",
    player->full_name,
    (long)player->exp,
    player->race->name,
    player->house->name,
    player->depth);
 wr_string(buf);
}
/**
 * Write an "item" record
 */
static void wr_item(const struct object *obj)
{
 size_t i;
 struct ability *ability;
 wr_u16b(0xffff);
 /* Unused */
 wr_byte(0);
 wr_u16b(obj->oidx);
 /* Location */
 wr_byte(obj->grid.y);
 wr_byte(obj->grid.x);
 /* Names of object type and object */
 wr_string(tval_find_name(obj->tval));
 if (obj->sval) {
  char name[1024];
  struct object_kind *kind = lookup_kind(obj->tval, obj->sval);
  obj_desc_name_format(name, sizeof name, 0, kind->name, 0, false);
  wr_string(name);
 } else {
  wr_string("");
 }
 /* Names of hallucinatory object type and object */
 if (obj->image_kind) {
  wr_string(tval_find_name(obj->image_kind->tval));
  if (obj->image_kind->sval) {
   char name[1024];
   struct object_kind *kind = lookup_kind(obj->image_kind->tval,
               obj->image_kind->sval);
   obj_desc_name_format(name, sizeof name, 0, kind->name, 0, false);
   wr_string(name);
  } else {
   wr_string("");
  }
 } else {
  wr_string("");
 }
 wr_s16b(obj->pval);
 wr_byte(obj->number);
 wr_s16b(obj->weight);
 if (obj->artifact) {
  wr_string(obj->artifact->name);
 } else {
  wr_string("");
 }
 if (obj->ego) {
  wr_string(obj->ego->name);
 } else {
  wr_string("");
 }
 wr_s16b(obj->timeout);
 wr_byte(obj->used);
 wr_s16b(obj->att);
 wr_byte(obj->dd);
 wr_byte(obj->ds);
 wr_s16b(obj->evn);
 wr_byte(obj->pd);
 wr_byte(obj->ps);
 wr_byte(obj->origin);
 wr_byte(obj->origin_depth);
 if (obj->origin_race) {
  wr_string(obj->origin_race->name);
 } else {
  wr_string("");
 }
 wr_byte(obj->notice);
 wr_byte(obj->pseudo);
 for (i = 0; i < OF_SIZE; i++)
  wr_byte(obj->flags[i]);
 for (i = 0; i < OBJ_MOD_MAX; i++) {
  wr_s16b(obj->modifiers[i]);
 }
 /* Write brands if any */
 if (obj->brands) {
  wr_byte(1);
  for (i = 0; i < z_info->brand_max; i++) {
   wr_byte(obj->brands[i] ? 1 : 0);
  }
 } else {
  wr_byte(0);
 }
 /* Write slays if any */
 if (obj->slays) {
  wr_byte(1);
  for (i = 0; i < z_info->slay_max; i++) {
   wr_byte(obj->slays[i] ? 1 : 0);
  }
 } else {
  wr_byte(0);
 }
 for (i = 0; i < ELEM_MAX; i++) {
  wr_s16b(obj->el_info[i].res_level);
  wr_byte(obj->el_info[i].flags);
 }
 /* Dump the abilities */
 for (ability = obj->abilities; ability; ability = ability->next) {
  wr_string(ability->name);
  wr_byte(ability->skill);
 }
 wr_string("end");
 /* Held by monster index */
 wr_s16b(obj->held_m_idx);
 /* Save the inscription (if any) */
 if (obj->note) {
  wr_byte(1);
  wr_string(quark_str(obj->note));
 } else {
  wr_byte(0);
 }
}
/**
 * Write a monster record (including held or mimicked objects)
 */
static void wr_monster(const struct monster *mon)
{
 size_t j;
 struct object *obj = mon->held_obj;
 struct object *dummy = object_new();
 wr_u16b(mon->midx);
 wr_string(mon->race->name);
 if (mon->image_race) {
  wr_string(mon->image_race->name);
 } else {
  wr_string("none");
 }
 wr_byte(mon->grid.y);
 wr_byte(mon->grid.x);
 wr_s16b(mon->hp);
 wr_s16b(mon->maxhp);
 wr_byte(mon->mana);
 wr_byte(mon->song ? mon->song->index : 0);
 wr_s16b(mon->alertness);
 wr_byte(mon->mspeed);
 wr_byte(mon->energy);
 wr_byte(mon->origin);
 wr_byte(mon->stance);
 wr_s16b(mon->morale);
 wr_s16b(mon->tmp_morale);
 wr_byte(mon->noise);
 wr_byte(mon->encountered);
 wr_byte(MON_TMD_MAX);
 for (j = 0; j < MON_TMD_MAX; j++)
  wr_s16b(mon->m_timed[j]);
 for (j = 0; j < MFLAG_SIZE; j++)
  wr_byte(mon->mflag[j]);
 for (j = 0; j < OF_SIZE; j++)
  wr_s16b(mon->known_pstate.flags[j]);
 for (j = 0; j < ELEM_MAX; j++)
  wr_s16b(mon->known_pstate.el_info[j].res_level);
 for (j = 0; j < MAX_ACTION; j++) {
  wr_byte(mon->previous_action[j]);
 }
 /* Write all held objects, followed by a dummy as a marker */
 while (obj) {
  wr_item(obj);
  obj = obj->next;
 }
 wr_item(dummy);
 object_delete(NULL, NULL, &dummy);
 /* Write group info */
 wr_u16b(mon->group_info.index);
 wr_byte(mon->group_info.role);
 wr_byte(mon->target.grid.y);
 wr_byte(mon->target.grid.x);
 wr_byte(mon->skip_this_turn);
 wr_byte(mon->skip_next_turn);
 wr_s16b(mon->consecutive_attacks);
 wr_s16b(mon->turns_stationary);
}
/**
 * Write a trap record
 */
static void wr_trap(struct trap *trap)
{
 size_t i;
 if (trap->t_idx) {
  wr_string(trap_info[trap->t_idx].desc);
 } else {
  wr_string("");
 }
 wr_byte(trap->grid.y);
 wr_byte(trap->grid.x);
 wr_byte(trap->power);
 for (i = 0; i < TRF_SIZE; i++)
  wr_byte(trap->flags[i]);
}
/**
 * Write RNG state
 *
 * There were originally 64 bytes of randomizer saved. Now we only need
 * 32 + 5 bytes saved, so we'll write an extra 27 bytes at the end which won't
 * be used.
 */
void wr_randomizer(void)
{
 int i;
 /* current value for the simple RNG */
 wr_u32b(Rand_value);
 /* state index */
 wr_u32b(state_i);
 /* RNG variables */
 wr_u32b(z0);
 wr_u32b(z1);
 wr_u32b(z2);
 /* RNG state */
 for (i = 0; i < RAND_DEG; i++)
  wr_u32b(STATE[i]);
 /* NULL padding */
 for (i = 0; i < 59 - RAND_DEG; i++)
  wr_u32b(0);
}
/**
 * Write the "options"
 */
void wr_options(void)
{
 int i;
 /* Special Options */
 wr_byte(player->opts.delay_factor);
 wr_byte(player->opts.hitpoint_warn);
 wr_byte(player->opts.lazymove_delay);
 /* Fix for tests - only write if angband_term exists, ie in a real game */
 wr_byte(angband_term[0] ? SIDEBAR_MODE : 0);
 /* Normal options */
 for (i = 0; i < OPT_MAX; i++) {
  const char *name = option_name(i);
  if (name) {
   wr_string(name);
   wr_byte(player->opts.opt[i]);
  }
   }
 /* Sentinel */
 wr_byte(0);
}
void wr_messages(void)
{
 int16_t i;
 uint16_t num;
 num = messages_num();
 if (num > 80) num = 80;
 wr_u16b(num);
 /* Dump the messages (oldest first!) */
 for (i = num - 1; i >= 0; i--) {
  wr_string(message_str(i));
  wr_u16b(message_type(i));
 }
}
void wr_monster_memory(void)
{
 int r_idx;
 wr_byte(MFLAG_SIZE);
 for (r_idx = 0; r_idx < z_info->r_max; r_idx++) {
  struct monster_race *race = &r_info[r_idx];
  struct monster_lore *lore = &l_list[r_idx];
  /* Names and kill counts */
  if (!race->name || ((!lore->pkills) && (!lore->psights))) continue;
  wr_string(race->name);
  wr_u16b(lore->pkills);
  wr_u16b(lore->psights);
 }
 wr_string("No more monsters");
}
void wr_object_memory(void)
{
 int k_idx;
 wr_u16b(z_info->k_max);
 wr_byte(OF_SIZE);
 wr_byte(OBJ_MOD_MAX);
 wr_byte(ELEM_MAX);
 wr_byte(z_info->brand_max);
 wr_byte(z_info->slay_max);
 /* Kind knowledge */
 for (k_idx = 0; k_idx < z_info->k_max; k_idx++) {
  uint8_t tmp8u = 0;
  struct object_kind *kind = &k_info[k_idx];
  if (kind->aware) tmp8u |= 0x01;
  if (kind->tried) tmp8u |= 0x02;
  if (kind_is_ignored_aware(kind)) tmp8u |= 0x04;
  if (kind->everseen) tmp8u |= 0x08;
  if (kind_is_ignored_unaware(kind)) tmp8u |= 0x10;
  wr_byte(tmp8u);
 }
}
void wr_player(void)
{
 int i;
 struct ability *ability;
 wr_string(player->full_name);
 wr_string(player->died_from);
 wr_string(player->history);
 /* Race/Class/Gender/Spells */
 wr_string(player->race->name);
 wr_string(player->house->name);
 wr_string(player->sex->name);
 wr_byte(player->opts.name_suffix);
 wr_s16b(player->game_type);
 wr_s16b(player->age);
 wr_s16b(player->ht);
 wr_s16b(player->wt);
 wr_s16b(player->ht_birth);
 wr_s16b(player->wt_birth);
 /* Dump the stats (base and drained) */
 wr_byte(STAT_MAX);
 for (i = 0; i < STAT_MAX; ++i) wr_s16b(player->stat_base[i]);
 for (i = 0; i < STAT_MAX; ++i) wr_s16b(player->stat_drain[i]);
 /* Dump the skill bases */
 wr_byte(SKILL_MAX);
 for (i = 0; i < SKILL_MAX; ++i) wr_s16b(player->skill_base[i]);
 /* Dump the abilities */
 for (ability = player->abilities; ability; ability = ability->next) {
  wr_string(ability->name);
  wr_byte(ability->skill);
  if (ability->active) {
   wr_byte(1);
  } else {
   wr_byte(0);
  }
 }
 wr_string("end");
 for (ability = player->item_abilities; ability; ability = ability->next) {
  wr_string(ability->name);
  wr_byte(ability->skill);
  if (ability->active) {
   wr_byte(1);
  } else {
   wr_byte(0);
  }
 }
 wr_string("end");
 /* Dump the action list */
 for (i = 0; i < MAX_ACTION; i++) {
  wr_byte(player->previous_action[i]);
 }
 /* Player body */
 wr_string(player->body.name);
 wr_u16b(player->body.count);
 for (i = 0; i < player->body.count; i++) {
  wr_u16b(player->body.slots[i].type);
  wr_string(player->body.slots[i].name);
 }
 wr_s32b(player->new_exp);
 wr_s32b(player->exp);
 wr_s32b(player->encounter_exp);
 wr_s32b(player->kill_exp);
 wr_s32b(player->descent_exp);
 wr_s32b(player->ident_exp);
 wr_s32b(player->turn);
 wr_s16b(player->mhp);
 wr_s16b(player->chp);
 wr_s16b(player->msp);
 wr_s16b(player->csp);
 /* Max Dungeon Level */
 wr_s16b(player->max_depth);
 wr_u16b(player->staircasiness);
 wr_s16b(player->energy);
 /* Total energy used so far */
 wr_u32b(player->total_energy);
 /* # of turns spent resting */
 wr_u32b(player->resting_turn);
 /* Find the number of timed effects */
 wr_byte(TMD_MAX);
 /* Read all the effects, in a loop */
 for (i = 0; i < TMD_MAX; i++)
  wr_s16b(player->timed[i]);
 /* Greater vaults seen */
 wr_u16b(z_info->v_max);
 for (i = 0; i < z_info->v_max; i++) {
  wr_byte(player->vaults[i]);
 }
 /* More info */
 wr_byte(player->unignoring);
 wr_s16b(player->last_attack_m_idx);
 wr_s16b(player->consecutive_attacks);
 wr_s16b(player->bane_type);
 wr_byte(player->focused);
 wr_byte(player->song[SONG_MAIN] ? player->song[SONG_MAIN]->index : 0);
 wr_byte(player->song[SONG_MINOR] ? player->song[SONG_MINOR]->index : 0);
 wr_s16b(player->song_duration);
 wr_s16b(player->wrath);
 wr_u16b(player->stairs_taken);
 wr_u16b(player->forge_drought);
 wr_u16b(player->forge_count);
 wr_byte(player->stealth_mode);
 wr_byte(player->self_made_arts);
 wr_byte(player->truce);
 wr_byte(player->morgoth_hits);
 wr_byte(player->crown_hint);
 wr_byte(player->crown_shatter);
 wr_byte(player->cursed);
 wr_byte(player->on_the_run);
 wr_byte(player->morgoth_slain);
 wr_byte(player->escaped);
 wr_u16b(player->noscore);
 wr_s16b(player->smithing_leftover);
 wr_byte(player->unique_forge_made);
 wr_byte(player->unique_forge_seen);
}
void wr_ignore(void)
{
 size_t i;
 uint16_t j, n;
 /* Write number of ignore bytes */
 assert(ignore_size <= 255);
 wr_byte((uint8_t)ignore_size);
 for (i = 0; i < ignore_size; i++)
  wr_byte(ignore_level[i]);
 /* Write ego-item ignore bits */
 wr_u16b(z_info->e_max);
 wr_u16b(ITYPE_SIZE);
 for (i = 0; i < z_info->e_max; i++) {
  bitflag everseen = 0, itypes[ITYPE_SIZE];
  /* Figure out and write the everseen and aware flags */
  if (e_info[i].everseen)
   everseen |= 0x02;
  if (e_info[i].aware)
   everseen |= 0x04;
  wr_byte(everseen);
  /* Figure out and write the ignore flags */
  itype_wipe(itypes);
  for (j = ITYPE_NONE; j < ITYPE_MAX; j++)
   if (ego_is_ignored(i, j))
    itype_on(itypes, j);
  for (j = 0; j < ITYPE_SIZE; j++)
   wr_byte(itypes[j]);
 }
 /* Write the current number of aware object auto-inscriptions */
 n = 0;
 for (i = 0; i < z_info->k_max; i++)
  if (k_info[i].note_aware)
   n++;
 wr_u16b(n);
 /* Write the aware object autoinscriptions array */
 for (i = 0; i < z_info->k_max; i++) {
  if (k_info[i].note_aware) {
   char name[1024];
   wr_string(tval_find_name(k_info[i].tval));
   obj_desc_name_format(name, sizeof name, 0, k_info[i].name, 0,
         false);
   wr_string(name);
   wr_string(quark_str(k_info[i].note_aware));
  }
 }
 /* Write the current number of unaware object auto-inscriptions */
 n = 0;
 for (i = 0; i < z_info->k_max; i++)
  if (k_info[i].note_unaware)
   n++;
 wr_u16b(n);
 /* Write the unaware object autoinscriptions array */
 for (i = 0; i < z_info->k_max; i++) {
  if (k_info[i].note_unaware) {
   char name[1024];
   wr_string(tval_find_name(k_info[i].tval));
   obj_desc_name_format(name, sizeof name, 0, k_info[i].name, 0,
         false);
   wr_string(name);
   wr_string(quark_str(k_info[i].note_unaware));
  }
 }
 return;
}
void wr_misc(void)
{
 size_t i;
 /* Random artifact seed */
 wr_u32b(seed_randart);
 /* Write the "object seeds" */
 wr_u32b(seed_flavor);
 /* Special stuff */
 wr_u16b(player->noscore);
 /* Write death */
 wr_byte(player->is_dead);
 /* Current turn */
 wr_s32b(turn);
 /* Flags */
 for (i = 0; i < OF_SIZE; i++)
  wr_byte(player->obj_k->flags[i]);
 /* Modifiers */
 for (i = 0; i < OBJ_MOD_MAX; i++) {
  wr_s16b(player->obj_k->modifiers[i]);
 }
 /* Elements */
 for (i = 0; i < ELEM_MAX; i++) {
  wr_s16b(player->obj_k->el_info[i].res_level);
  wr_byte(player->obj_k->el_info[i].flags);
 }
 /* Brands */
 for (i = 0; i < z_info->brand_max; i++) {
  wr_byte(player->obj_k->brands[i] ? 1 : 0);
 }
 /* Slays */
 for (i = 0; i < z_info->slay_max; i++) {
  wr_byte(player->obj_k->slays[i] ? 1 : 0);
 }
 /* Combat data */
 wr_s16b(player->obj_k->att);
 wr_s16b(player->obj_k->evn);
 wr_byte(player->obj_k->pd);
 wr_byte(player->obj_k->ps);
 wr_byte(player->obj_k->dd);
 wr_byte(player->obj_k->ds);
}
void wr_artifacts(void)
{
 int i;
 uint16_t tmp16u;
 /* Hack -- Dump the artifacts */
 tmp16u = z_info->a_max;
 wr_u16b(tmp16u);
 for (i = 0; i < tmp16u; i++) {
  const struct artifact_upkeep *au = &aup_info[i];
  wr_byte(au->created ? 1 : 0);
  wr_byte(au->seen ? 1 : 0);
  wr_byte(au->everseen ? 1 : 0);
  wr_byte(0);
 }
}
static void wr_gear_aux(struct object *gear)
{
 struct object *obj;
 /* Write the inventory */
 for (obj = gear; obj; obj = obj->next) {
  /* Skip non-objects */
  assert(obj->kind);
  /* Write code for equipment or other gear */
  wr_byte(object_slot(player->body, obj));
  /* Dump object */
  wr_item(obj);
 }
 /* Write finished code */
 wr_byte(FINISHED_CODE);
}
void wr_gear(void)
{
 wr_gear_aux(player->gear);
 wr_gear_aux(player->gear_k);
}
/**
 * Write the current dungeon terrain features and info flags
 *
 * Note that the cost and when fields of c->squares[y][x] are not saved
 */
static void wr_dungeon_aux(struct chunk *c)
{
 int y, x;
 size_t i;
 uint8_t tmp8u;
 uint8_t count;
 uint8_t prev_char;
 /* Dungeon specific info follows */
 wr_string(c->name ? c->name : "Blank");
 wr_u16b(c->height);
 wr_u16b(c->width);
 if (c->vault_name) {
  wr_byte(1);
  wr_string(c->vault_name);
 } else {
  wr_byte(0);
 }
 /* Run length encoding of c->squares[y][x].info */
 for (i = 0; i < SQUARE_SIZE; i++) {
  count = 0;
  prev_char = 0;
  /* Dump for each grid */
  for (y = 0; y < c->height; y++) {
   for (x = 0; x < c->width; x++) {
    /* Extract the important c->squares[y][x].info flags */
    tmp8u = square(c, loc(x, y))->info[i];
    /* If the run is broken, or too full, flush it */
    if ((tmp8u != prev_char) || (count == UCHAR_MAX)) {
     wr_byte(count);
     wr_byte(prev_char);
     prev_char = tmp8u;
     count = 1;
    } else /* Continue the run */
     count++;
   }
  }
  /* Flush the data (if any) */
  if (count) {
   wr_byte(count);
   wr_byte(prev_char);
  }
 }
 /* Now the terrain */
 count = 0;
 prev_char = 0;
 /* Dump for each grid */
 for (y = 0; y < c->height; y++) {
  for (x = 0; x < c->width; x++) {
   /* Extract a byte */
   tmp8u = square(c, loc(x, y))->feat;
   /* If the run is broken, or too full, flush it */
   if ((tmp8u != prev_char) || (count == UCHAR_MAX)) {
    wr_byte(count);
    wr_byte(prev_char);
    prev_char = tmp8u;
    count = 1;
   } else /* Continue the run */
    count++;
  }
 }
 /* Flush the data (if any) */
 if (count) {
  wr_byte(count);
  wr_byte(prev_char);
 }
}
/**
 * Write the dungeon floor objects
 */
static void wr_objects_aux(struct chunk *c)
{
 int y, x, i;
 struct object *dummy;
 if (player->is_dead)
  return;
 /* Write the objects */
 wr_u16b(c->obj_max);
 for (y = 0; y < c->height; y++) {
  for (x = 0; x < c->width; x++) {
   struct object *obj = square(c, loc(x, y))->obj;
   while (obj) {
    wr_item(obj);
    obj = obj->next;
   }
  }
 }
 /* Write known objects we don't know the location of, and imagined versions
	 * of known objects */
 for (i = 1; i < c->obj_max; i++) {
  struct object *obj = c->objects[i];
  if (!obj) continue;
  if (square_in_bounds_fully(c, obj->grid)) continue;
  if (obj->held_m_idx) continue;
  if (obj->known && !(obj->known->notice & OBJ_NOTICE_IMAGINED)) continue;
  assert(obj->oidx == i);
  wr_item(obj);
 }
 /* Write a dummy record as a marker */
 dummy = mem_zalloc(sizeof(*dummy));
 wr_item(dummy);
 mem_free(dummy);
}
/**
 * Write the monster list
 */
static void wr_monsters_aux(struct chunk *c)//TODO check flow info is covered
{
 int i;
 if (player->is_dead)
  return;
 /* Total monsters */
 wr_u16b(cave_monster_max(c));
 /* Dump the monsters */
 for (i = 1; i < cave_monster_max(c); i++) {
  const struct monster *mon = cave_monster(c, i);
  wr_monster(mon);
 }
}
static void wr_traps_aux(struct chunk *c)
{
    int x, y;
 struct trap *dummy;
    if (player->is_dead)
  return;
    wr_byte(TRF_SIZE);
 for (y = 0; y < c->height; y++) {
  for (x = 0; x < c->width; x++) {
   struct trap *trap = square(c, loc(x, y))->trap;
   while (trap) {
    wr_trap(trap);
    trap = trap->next;
   }
  }
 }
 /* Write a dummy record as a marker */
 dummy = mem_zalloc(sizeof(*dummy));
 wr_trap(dummy);
 mem_free(dummy);
}
void wr_dungeon(void)
{
 /* Dungeon specific info follows */
 wr_u16b(player->depth);
 wr_u16b(daycount);
 wr_u16b(player->grid.y);
 wr_u16b(player->grid.x);
 wr_byte(SQUARE_SIZE);
 if (player->is_dead)
  return;
 /* Write caves */
 wr_dungeon_aux(cave);
 wr_dungeon_aux(player->cave);
 /* Compact the monsters */
 compact_monsters(cave, 0);
}
void wr_objects(void)
{
 wr_objects_aux(cave);
 wr_objects_aux(player->cave);
}
void wr_monsters(void)
{
 wr_monsters_aux(cave);
 wr_monsters_aux(player->cave);
}
void wr_traps(void)
{
 wr_traps_aux(cave);
 wr_traps_aux(player->cave);
}
void wr_history(void)
{
 size_t i, j;
 struct history_info *history_list;
 uint32_t length = history_get_list(player, &history_list);
 wr_byte(HIST_SIZE);
 wr_u32b(length);
 for (i = 0; i < length; i++) {
  for (j = 0; j < HIST_SIZE; j++)
   wr_byte(history_list[i].type[j]);
  wr_s32b(history_list[i].turn);
  wr_s16b(history_list[i].dlev);
  if (history_list[i].a_idx) {
   wr_string(a_info[history_list[i].a_idx].name);
  } else {
   wr_string("");
  }
  wr_string(history_list[i].event);
 }
}
void wr_monster_groups(void)
{
 uint16_t i;
 /* Dump the group flow centres and wandering pauses */
 for (i = 1; i < z_info->level_monster_max; i++) {
  if (cave->monster_groups[i]) {
   struct monster_group *group = cave->monster_groups[i];
   wr_u16b(i);
   wr_byte(group->flow.centre.x);
   wr_byte(group->flow.centre.y);
   wr_s16b(group->wandering_pause);
  }
 }
 wr_u16b(0);
}
/**
 * \file savefile.c
 * \brief Savefile loading and saving main routines
 *
 * Copyright (c) 2009 Andi Sidwell <andi@takkaria.org>
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * The savefile code.
 *
 * Savefiles since ~3.1 have used a block-based system.  Each savefile
 * consists of an 8-byte header, the first four bytes of which mark this
 * as a savefile, the second four bytes provide a variant ID.
 *
 * After that, each block has the format:
 * - 16-byte string giving the type of block
 * - 4-byte block version
 * - 4-byte block size
 * - 4-byte block checksum
 * ... data ...
 * padding so that block is a multiple of 4 bytes
 *
 * The savefile deosn't contain the version number of that game that saved it;
 * versioning is left at the individual block level.  The current code
 * keeps a list of savefile blocks to save in savers[] below, along with
 * their current versions.
 *
 * For each block type and version, there is a loading function to load that
 * type/version combination.  For example, there may be a loader for v1
 * and v2 of the RNG block; these must be different functions.  It has been
 * done this way since it allows easier maintenance; after each release, you
 * need simply remove old loaders and you will not have to disentangle
 * lots of code with "if (version > 3)" and its like everywhere.
 *
 * Savefile loading and saving is done by keeping the current block in
 * memory, which is accessed using the wr_* and rd_* functions.  This is
 * then written out, whole, to disk, with the appropriate header.
 *
 *
 * So, if you want to make a savefile compat-breaking change, then there are
 * a few things you should do:
 *
 * - increment the version in 'savers' below
 * - add a loading function that accepts the new version (in addition to
 *   the previous loading function) to 'loaders'
 * - and watch the magic happen.
 *
 *
 * TODO:
 * - wr_ and rd_ should be passed a buffer to work with, rather than using
 *   the rd_ and wr_ functions with a universal buffer
 * - 
 */
/**
 * Global "we've just saved" variable
 */
bool character_saved;
/**
 * Magic bits at beginning of savefile
 */
static const uint8_t savefile_magic[4] = { 83, 97, 118, 101 };
static const uint8_t savefile_name[4] = "USIL";
/* Some useful types */
typedef int (*loader_t)(void);
struct blockheader {
 char name[16];
 uint32_t version;
 uint32_t size;
};
struct blockinfo {
 char name[16];
 loader_t loader;
 uint32_t version;
};
/**
 * Savefile saving functions
 */
static const struct {
 char name[16];
 void (*save)(void);
 uint32_t version;
} savers[] = {
 { "description", wr_description, 1 },
 { "rng", wr_randomizer, 1 },
 { "options", wr_options, 1 },
 { "messages", wr_messages, 1 },
 { "monster memory", wr_monster_memory, 1 },
 { "object memory", wr_object_memory, 1 },
 { "player", wr_player, 1 },
 { "ignore", wr_ignore, 1 },
 { "misc", wr_misc, 1 },
 { "artifacts", wr_artifacts, 1 },
 { "gear", wr_gear, 1 },
 { "dungeon", wr_dungeon, 1 },
 { "objects", wr_objects, 1 },
 { "monsters", wr_monsters, 1 },
 { "traps", wr_traps, 1 },
 { "history", wr_history, 1 },
 { "monster groups", wr_monster_groups, 1 },
};
/**
 * Savefile loading functions
 */
static const struct blockinfo loaders[] = {
 { "description", rd_null, 1 },
 { "rng", rd_randomizer, 1 },
 { "options", rd_options, 1 },
 { "messages", rd_messages, 1 },
 { "monster memory", rd_monster_memory, 1 },
 { "object memory", rd_object_memory, 1 },
 { "player", rd_player, 1 },
 { "ignore", rd_ignore, 1 },
 { "misc", rd_misc, 1 },
 { "artifacts", rd_artifacts, 1 },
 { "gear", rd_gear, 1 },
 { "dungeon", rd_dungeon, 1 },
 { "objects", rd_objects, 1 },
 { "monsters", rd_monsters, 1 },
 { "traps", rd_traps, 1 },
 { "history", rd_history, 1 },
 { "monster groups", rd_monster_groups, 1 },
};
/* Buffer bits */
static uint8_t *buffer;
static uint32_t buffer_size;
static uint32_t buffer_pos;
static uint32_t buffer_check;
/**
 * ------------------------------------------------------------------------
 * Utility
 * ------------------------------------------------------------------------ */
/**
 * Tell the UI something about loading the game.
 */
void note(const char *message)
{
 event_signal_message(EVENT_INITSTATUS, MSG_BIRTH, message);
}
/**
 * ------------------------------------------------------------------------
 * Base put/get
 * ------------------------------------------------------------------------ */
static void sf_put(uint8_t v)
{
 assert(buffer != NULL);
 assert(buffer_size > 0);
 if (buffer_size == buffer_pos)
 {
  buffer_size += 1024;
  buffer = mem_realloc(buffer, buffer_size);
 }
 assert(buffer_pos < buffer_size);
 buffer[buffer_pos++] = v;
 buffer_check += v;
}
static uint8_t sf_get(void)
{
 if ((buffer == NULL) || (buffer_size <= 0) || (buffer_pos >= buffer_size))
  quit("Broken savefile - probably from a development version");
 buffer_check += buffer[buffer_pos];
 return buffer[buffer_pos++];
}
/**
 * ------------------------------------------------------------------------
 * Accessor functions
 * ------------------------------------------------------------------------ */
void wr_byte(uint8_t v)
{
 sf_put(v);
}
void wr_u16b(uint16_t v)
{
 sf_put((uint8_t)(v & 0xFF));
 sf_put((uint8_t)((v >> 8) & 0xFF));
}
void wr_s16b(int16_t v)
{
 wr_u16b((uint16_t)v);
}
void wr_u32b(uint32_t v)
{
 sf_put((uint8_t)(v & 0xFF));
 sf_put((uint8_t)((v >> 8) & 0xFF));
 sf_put((uint8_t)((v >> 16) & 0xFF));
 sf_put((uint8_t)((v >> 24) & 0xFF));
}
void wr_s32b(int32_t v)
{
 wr_u32b((uint32_t)v);
}
void wr_string(const char *str)
{
 while (*str)
 {
  wr_byte(*str);
  str++;
 }
 wr_byte(*str);
}
void rd_byte(uint8_t *ip)
{
 *ip = sf_get();
}
void rd_u16b(uint16_t *ip)
{
 (*ip) = sf_get();
 (*ip) |= ((uint16_t)(sf_get()) << 8);
}
void rd_s16b(int16_t *ip)
{
 rd_u16b((uint16_t*)ip);
}
void rd_u32b(uint32_t *ip)
{
 (*ip) = sf_get();
 (*ip) |= ((uint32_t)(sf_get()) << 8);
 (*ip) |= ((uint32_t)(sf_get()) << 16);
 (*ip) |= ((uint32_t)(sf_get()) << 24);
}
void rd_s32b(int32_t *ip)
{
 rd_u32b((uint32_t*)ip);
}
void rd_string(char *str, int max)
{
 uint8_t tmp8u;
 int i = 0;
 do {
  rd_byte(&tmp8u);
  if (i < max) str[i] = tmp8u;
  if (!tmp8u) break;
 } while (++i);
 str[max - 1] = '\0';
}
void strip_bytes(int n)
{
 uint8_t tmp8u;
 while (n--) rd_byte(&tmp8u);
}
void pad_bytes(int n)
{
 while (n--) wr_byte(0);
}
/**
 * ------------------------------------------------------------------------
 * Savefile saving functions
 * ------------------------------------------------------------------------ */
static bool try_save(ang_file *file)
{
 uint8_t savefile_head[28];
 size_t i, pos;
 bool success = true;
 /* Start off the buffer */
 buffer = mem_alloc(1024);
 buffer_size = 1024;
 for (i = 0; i < N_ELEMENTS(savers); i++) {
  buffer_pos = 0;
  buffer_check = 0;
  savers[i].save();
  /* 16-byte block name */
  pos = my_strcpy((char *)savefile_head,
    savers[i].name,
    sizeof savefile_head);
  while (pos < 16)
   savefile_head[pos++] = 0;
  savefile_head[pos++] = (savers[i].version & 0xFF); savefile_head[pos++] = ((savers[i].version >> 8) & 0xFF); savefile_head[pos++] = ((savers[i].version >> 16) & 0xFF); savefile_head[pos++] = ((savers[i].version >> 24) & 0xFF);;
  savefile_head[pos++] = (buffer_pos & 0xFF); savefile_head[pos++] = ((buffer_pos >> 8) & 0xFF); savefile_head[pos++] = ((buffer_pos >> 16) & 0xFF); savefile_head[pos++] = ((buffer_pos >> 24) & 0xFF);;
  savefile_head[pos++] = (buffer_check & 0xFF); savefile_head[pos++] = ((buffer_check >> 8) & 0xFF); savefile_head[pos++] = ((buffer_check >> 16) & 0xFF); savefile_head[pos++] = ((buffer_check >> 24) & 0xFF);;
  assert(pos == 28);
  if (! file_write(file, (char *)savefile_head,
    28)) {
   success = false;
  }
  if (! file_write(file, (char *)buffer, buffer_pos)) {
   success = false;
  }
  /* pad to 4 byte multiples */
  if (buffer_pos % 4) {
   if (! file_write(file, "xxx", 4 - (buffer_pos % 4))) {
    success = false;
   }
  }
 }
 mem_free(buffer);
 return success;
}
/**
 * Attempt to save the player in a savefile
 */
bool savefile_save(const char *path)
{
 ang_file *file;
 int count = 0;
 char new_savefile[1024];
 char old_savefile[1024];
 /* Generate a CharOutput.txt, mainly for angband.live, when saving. */
 (void) save_charoutput();
 /* New savefile */
 safe_setuid_grab();
 strnfmt(old_savefile, sizeof(old_savefile), "%s%u.old", path,
   Rand_simple(1000000));
 while (file_exists(old_savefile) && (count++ < 100))
  strnfmt(old_savefile, sizeof(old_savefile), "%s%u%u.old", path,
    Rand_simple(1000000),count);
 count = 0;
 /* Open the savefile */
 strnfmt(new_savefile, sizeof(new_savefile), "%s%u.new", path,
   Rand_simple(1000000));
 while (file_exists(new_savefile) && (count++ < 100))
  strnfmt(new_savefile, sizeof(new_savefile), "%s%u%u.new", path,
    Rand_simple(1000000),count);
 file = file_open(new_savefile, MODE_WRITE, FTYPE_SAVE);
 safe_setuid_drop();
 if (file) {
  if (file_write(file, (char *) &savefile_magic, 4)
   && file_write(file, (char *) &savefile_name, 4)) {
   character_saved = try_save(file);
  } else {
   character_saved = false;
  }
  file_close(file);
 } else {
  character_saved = false;
 }
 if (character_saved) {
  bool err = false;
  safe_setuid_grab();
  if (file_exists(path) && !file_move(path, old_savefile))
   err = true;
  if (!err) {
   if (!file_move(new_savefile, path))
    err = true;
   if (err)
    file_move(old_savefile, path);
   else
    file_delete(old_savefile);
  }
  safe_setuid_drop();
  return err ? false : true;
 }
 /* Delete temp file if the save failed */
 if (file) {
  /* File is no longer valid, but it still points to a non zero
		 * value if the file was created above */
  safe_setuid_grab();
  file_delete(new_savefile);
  safe_setuid_drop();
 }
 return false;
}
/**
 * ------------------------------------------------------------------------
 * Savefile loading functions
 * ------------------------------------------------------------------------ */
/**
 * Check the savefile header file clearly inicates that it's a savefile
 */
static bool check_header(ang_file *f) {
 uint8_t head[8];
 if (file_read(f, (char *) &head, 8) == 8 &&
   memcmp(&head[0], savefile_magic, 4) == 0 &&
   memcmp(&head[4], savefile_name, 4) == 0)
  return true;
 return false;
}
/**
 * Get the next block header from the savefile
 */
static errr next_blockheader(ang_file *f, struct blockheader *b) {
 uint8_t savefile_head[28];
 size_t len;
 len = file_read(f, (char *)savefile_head, 28);
 if (len == 0) /* no more blocks */
  return 1;
 if (len != 28 || savefile_head[15] != 0) {
  return -1;
 }
 my_strcpy(b->name, (char *)&savefile_head, sizeof b->name);
 b->version = ((uint32_t) savefile_head[16]) | ((uint32_t) savefile_head[16 +1] << 8) | ((uint32_t) savefile_head[16 +2] << 16) | ((uint32_t) savefile_head[16 +3] << 24);;
 b->size = ((uint32_t) savefile_head[20]) | ((uint32_t) savefile_head[20 +1] << 8) | ((uint32_t) savefile_head[20 +2] << 16) | ((uint32_t) savefile_head[20 +3] << 24);;
 /* Pad to 4 bytes */
 if (b->size % 4)
  b->size += 4 - (b->size % 4);
 return 0;
}
/**
 * Find the right loader for this block, return it
 */
static loader_t find_loader(struct blockheader *b,
       const struct blockinfo *local_loaders)
{
 size_t i = 0;
 /* Find the right loader */
 for (i = 0; local_loaders[i].name[0]; i++) {
  if (!streq(b->name, local_loaders[i].name)) continue;
  if (b->version != local_loaders[i].version) continue;
  return local_loaders[i].loader;
 }
 return NULL;
}
/**
 * Load a given block with the given loader
 */
static bool load_block(ang_file *f, struct blockheader *b, loader_t loader)
{
 /* Allocate space for the buffer */
 buffer = mem_alloc(b->size);
 buffer_pos = 0;
 buffer_check = 0;
 buffer_size = file_read(f, (char *) buffer, b->size);
 if (buffer_size != b->size ||
   loader() != 0) {
  mem_free(buffer);
  return false;
 }
 mem_free(buffer);
 return true;
}
/**
 * Skip a block
 */
static void skip_block(ang_file *f, struct blockheader *b)
{
 file_skip(f, b->size);
}
/**
 * Try to load a savefile
 */
static bool try_load(ang_file *f, const struct blockinfo *local_loaders)
{
 struct blockheader b;
 errr err;
 if (!check_header(f)) {
  note("Savefile is corrupted -- incorrect file header.");
  return false;
 }
 /* Get the next block header */
 while ((err = next_blockheader(f, &b)) == 0) {
  loader_t loader = find_loader(&b, local_loaders);
  if (!loader) {
   note("Savefile block can't be read.");
   note("Maybe try and load the savefile in an earlier version of Angband.");
   return false;
  }
  if (!load_block(f, &b, loader)) {
   note(format("Savefile corrupted - Couldn't load block %s", b.name));
   return false;
  }
 }
 if (err == -1) {
  note("Savefile is corrupted -- block header mangled.");
  return false;
 }
 return true;
}
/* XXX this isn't nice but it'll have to do */
static char savefile_desc[120];
static int get_desc(void) {
 rd_string(savefile_desc, sizeof savefile_desc);
 return 0;
}
/**
 * Try to get the 'description' block from a savefile.  Fail gracefully.
 */
const char *savefile_get_description(const char *path) {
 struct blockheader b;
 ang_file *f;
 safe_setuid_grab();
 f = file_open(path, MODE_READ, FTYPE_TEXT);
 safe_setuid_drop();
 if (!f) return NULL;
 /* Blank the description */
 savefile_desc[0] = 0;
 if (!check_header(f)) {
  my_strcpy(savefile_desc, "Invalid savefile", sizeof savefile_desc);
 } else {
  while (!next_blockheader(f, &b)) {
   if (!streq(b.name, "description")) {
    skip_block(f, &b);
    continue;
   }
   load_block(f, &b, get_desc);
   break;
  }
 }
 file_close(f);
 return savefile_desc;
}
/**
 * Load a savefile.
 */
bool savefile_load(const char *path, bool cheat_death)
{
 bool ok;
 ang_file *f;
 safe_setuid_grab();
 f = file_open(path, MODE_READ, FTYPE_TEXT);
 safe_setuid_drop();
 if (!f) {
  note("Couldn't open savefile.");
  return false;
 }
 ok = try_load(f, loaders);
 file_close(f);
 if (player->chp < 0) {
  player->is_dead = true;
 }
 if (player->is_dead && cheat_death) {
   player->is_dead = false;
   player->chp = player->mhp;
   player->noscore |= NOSCORE_WIZARD;
 }
 /* Character is now "complete" */
 character_generated = true;
 player->upkeep->playing = true;
 return ok;
}
/**
 * Fill the given buffer with the panic save equivalent for a savefile.
 *
 * \param buf Is the buffer to fill.  The result wil be an empty string if
 * the result can't fit in the given buffer or the savefile name or panic
 * save directory are invalid.
 * \param len Is the maximum number of characters that the buffer can hold.
 * \param path Is the name of the savefile to use.  The storage for that must
 * not overlap buffer.
 */
void savefile_get_panic_name(char *buf, size_t len, const char *path)
{
 size_t name_offset = path_filename_index(path);
 size_t used = path_build(buf, len, ANGBAND_DIR_PANIC,
  path + name_offset);
 if (len > 0 && (used == 0 || !suffix(buf, path + name_offset))) {
  buf[0] = '\0';
 }
}
/**
 * \file save-charoutput.c
 * \brief Write short human-readable character synopsis for angband.live
 *
 * Copyright (c) 2020 Eric Branlund
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/* Based on the adaptation of Exo's patch to frogcomposband. */
bool save_charoutput(void)
{
 char path[1024];
 ang_file *fo;
 bool written = true;
 path_build(path, sizeof(path), ANGBAND_DIR_USER, "CharOutput.txt");
 fo = file_open(path, MODE_WRITE, FTYPE_TEXT);
 if (fo) {
  if (! file_put(fo, "{\n")) written = false;
  if (! file_putf(fo, "race: \"%s\",\n", player->race->name)) written = false;
  if (! file_putf(fo, "house: \"%s\",\n", player->house->name)) written = false;
  if (! file_put(fo, "mapName: \"Angband\",\n")) written = false;
  if (! file_putf(fo, "dLvl: \"%i\",\n", player->depth)) written = false;
  if (! file_putf(fo, "isDead: \"%i\",\n", (player->is_dead) ? 1 : 0)) written = false;
  if (! file_putf(fo, "killedBy: \"%s\"\n", player->died_from)) written = false;
  if (! file_put(fo, "}")) written = false;
  if (! file_close(fo)) written = false;
 } else {
  written = false;
 }
 return written;
}
/**
 * \file songs.c
 * \brief Player and monster songs
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
struct song *songs;
/**
 * ------------------------------------------------------------------------
 * Initialize songs
 * ------------------------------------------------------------------------ */
static int song_index = 1;
static enum parser_error parse_song_name(struct parser *p) {
    const char *name = parser_getstr(p, "name");
    struct song *h = parser_priv(p);
    struct song *s = mem_zalloc(sizeof *s);
    s->next = h;
    s->name = string_make(name);
    parser_setpriv(p, s);
 /* Static initialisation means first entry has index 0 */
 s->index = song_index;
 song_index++;
    return PARSE_ERROR_NONE;
}
static enum parser_error parse_song_verb(struct parser *p) {
    struct song *s = parser_priv(p);
    assert(s);
    s->verb = string_append(s->verb, parser_getstr(p, "text"));
    return PARSE_ERROR_NONE;
}
static enum parser_error parse_song_desc(struct parser *p) {
    struct song *s = parser_priv(p);
    assert(s);
    s->desc = string_append(s->desc, parser_getstr(p, "text"));
    return PARSE_ERROR_NONE;
}
static enum parser_error parse_song_alt_desc(struct parser *p) {
    struct song *s = parser_priv(p);
 struct alt_song_desc *alt = mem_zalloc(sizeof(*alt));
    assert(s);
 alt->next = s->alt_desc;
 s->alt_desc = alt;
    alt->desc = string_make(parser_getstr(p, "text"));
    return PARSE_ERROR_NONE;
}
static enum parser_error parse_song_msg(struct parser *p) {
    struct song *s = parser_priv(p);
    assert(s);
    s->msg = string_append(s->msg, parser_getstr(p, "text"));
    return PARSE_ERROR_NONE;
}
static enum parser_error parse_song_bonus_mult(struct parser *p) {
 struct song *s = parser_priv(p);
 if (!s)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 s->bonus_mult = parser_getint(p, "mult");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_song_bonus_div(struct parser *p) {
 struct song *s = parser_priv(p);
 if (!s)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 s->bonus_div = parser_getint(p, "div");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_song_bonus_min(struct parser *p) {
 struct song *s = parser_priv(p);
 if (!s)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 s->bonus_min = parser_getint(p, "min");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_song_noise(struct parser *p) {
 struct song *s = parser_priv(p);
 if (!s)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 s->noise = parser_getint(p, "noise");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_song_extend(struct parser *p) {
 struct song *s = parser_priv(p);
 if (!s)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 s->extend = parser_getint(p, "extend") ? true : false;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_song_effect(struct parser *p) {
 struct song *s = parser_priv(p);
 struct effect *new_effect = mem_zalloc(sizeof(*new_effect));
 if (!s)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 /* Songs only have a single effect */
 s->effect = new_effect;
 /* Fill in the detail */
 return grab_effect_data(p, new_effect);
}
static struct parser *init_parse_song(void) {
    struct parser *p = parser_new();
    parser_setpriv(p, NULL);
    parser_reg(p, "name str name", parse_song_name);
 parser_reg(p, "verb str text", parse_song_verb);
 parser_reg(p, "desc str text", parse_song_desc);
 parser_reg(p, "alt-desc str text", parse_song_alt_desc);
 parser_reg(p, "msg str text", parse_song_msg);
 parser_reg(p, "bonus-mult int mult", parse_song_bonus_mult);
 parser_reg(p, "bonus-div int div", parse_song_bonus_div);
 parser_reg(p, "bonus-min int min", parse_song_bonus_min);
 parser_reg(p, "noise int noise", parse_song_noise);
 parser_reg(p, "extend int extend", parse_song_extend);
 parser_reg(p, "effect sym eff ?sym type ?int radius ?int other",
      parse_song_effect);
 return p;
}
static errr run_parse_song(struct parser *p) {
    return parse_file_quit_not_found(p, "song");
}
static errr finish_parse_song(struct parser *p) {
 songs = parser_priv(p);
 parser_destroy(p);
 return 0;
}
static void cleanup_song(void)
{
 struct song *s = songs, *next;
 while (s) {
  struct alt_song_desc *alt = s->alt_desc;
  next = s->next;
  while (alt) {
   struct alt_song_desc *alt_tgt = alt;
   alt = alt->next;
   string_free(alt_tgt->desc);
   mem_free(alt_tgt);
  }
  free_effect(s->effect);
  string_free(s->msg);
  string_free(s->desc);
  string_free(s->verb);
  string_free(s->name);
  mem_free(s);
  s = next;
 }
}
struct file_parser song_parser = {
    "song",
    init_parse_song,
    run_parse_song,
    finish_parse_song,
    cleanup_song
};
/**
 * ------------------------------------------------------------------------
 * Player song routines
 * ------------------------------------------------------------------------ */
struct song *song_by_idx(int idx)
{
 struct song *s = songs;
 while (s) {
  if (s->index == idx) return s;
  s = s->next;
 }
 return NULL;
}
struct song *lookup_song(const char *name)
{
 struct song *s = songs;
 while (s) {
  if (streq(s->name, name)) return s;
  s = s->next;
 }
 return NULL;
}
/**
 * Player song bonus, returns 0 if the player is not singing the song
 */
int song_bonus(struct player *p, int pskill, struct song *song)
{
 int skill = MAX(pskill, 0);
 int bonus;
 if (!song) return 0;
 /* Adjust for minor theme and which song */
 if (p->song[SONG_MAIN] != song) {
  skill /= 2;
  if (p->song[SONG_MINOR] != song) {
   return 0;
  }
 }
 bonus = skill * song->bonus_mult;
 bonus /= song->bonus_div;
 bonus = MAX(bonus, song->bonus_min);
 /* Special case */
 if (streq(song->name, "Slaying")) {
  bonus *= p->wrath;
  bonus += 999;
  bonus /= 1000;
 }
 return bonus;
}
void player_change_song(struct player *p, struct song *song, bool exchange)
{
 int song_to_change;
 if (player_active_ability(p, "Woven Themes") && p->song[SONG_MAIN] && song){
  song_to_change = SONG_MINOR;
 } else {
  song_to_change = SONG_MAIN;
 }
 /* Attempting to change to the same song */
 if (p->song[SONG_MAIN] == song) {
  /* This can cancel minor themes... */
  if (!p->song[SONG_MINOR]) {
   song = NULL;
  } else if (song) {
   /* ...but otherwise does nothing */
   msg("You were already singing that.");
   return;
  }
 } else if ((p->song[SONG_MINOR] == song) && (song_to_change == SONG_MINOR)){
  /* Attempting to change minor theme to itself */
  msg("You are already using that minor theme.");
  return;
 }
 /* Recalculate various bonuses */
 p->upkeep->redraw |= (PR_SONG);
 p->upkeep->update |= (PU_BONUS);
 /* Swap the minor and major themes */
 if (exchange) {
  struct song *temp = p->song[SONG_MAIN];
  p->song[SONG_MAIN] = p->song[SONG_MINOR];
  p->song[SONG_MINOR] = temp;
  msg("You change the order of your themes.");
  /* Take time */
  p->upkeep->energy_use = z_info->move_energy;
  /* Store the action type */
  p->previous_action[0] = ACTION_MISC;
  return;
 }
 /* Reset the song duration counter if changing major theme */
 if (song_to_change == SONG_MAIN) {
  p->song_duration = 0;
 }
 /* Deal with ending a song */
 if (!song) {
  if ((song_to_change == SONG_MAIN) && p->song[SONG_MAIN]) {
   msg("You end your song.");
  } else if ((song_to_change == SONG_MINOR) && p->song[SONG_MINOR]){
   msg("You end your minor theme.");
  }
 } else if (song_to_change == SONG_MAIN) {
  /* Start a new main song */
  msg("You %s song %s.", song->verb, song->desc);
 } else if (p->song[SONG_MINOR]) {
  /* Change the minor theme */
  msg("You change you minor theme to one %s.", song->desc);
 } else {
  /* Add a minor theme */
  msg("You add a minor theme %s.", song->desc);
 }
 /* Add a message */
 if (song && song->msg) {
  msg(song->msg);
 }
 /* Actually set the song */
 if (song_to_change == SONG_MAIN) {
  p->song[SONG_MAIN] = song;
 } else if (song) {
  p->song[SONG_MINOR] = song;
 }
 /* Beginning/changing songs takes time */
 if (song) {
  /* Take time */
  p->upkeep->energy_use = z_info->move_energy;
  /* Store the action type */
  p->previous_action[0] = ACTION_MISC;
 }
}
bool player_is_singing(struct player *p, struct song *song)
{
 if (p->song[SONG_MAIN] == song) return true;
 if (song && (p->song[SONG_MINOR] == song)) return true;
 return false;
}
int player_song_noise(struct player *p)
{
 struct song *song = p->song[SONG_MAIN];
 if (!song) return 0;
 if (!p->song[SONG_MINOR]) return song->noise;
 /* Average the noise if there are two songs */
 return (song->noise + p->song[SONG_MINOR]->noise) / 2;
}
void player_sing(struct player *p)
{
 int i;
 int cost = 0;
 struct song *smain = p->song[SONG_MAIN];
 struct song *minor = p->song[SONG_MINOR];
 if (!p->song[SONG_MAIN]) return;
 /* Abort song if out of voice, lost the ability to weave themes,
	 * or lost either song ability */
 if ((p->csp < 1) ||
  (p->song[SONG_MINOR] && !player_active_ability(p, "Woven Themes")) ||
  (!player_active_ability(p, format("Song of %s", smain->name))) ||
  (p->song[SONG_MINOR] &&
   !player_active_ability(p, format("Song of %s", minor->name)))) {
  /* Stop singing */
  player_change_song(p, NULL, false);
  /* Disturb */
  disturb(p, false);
  return;
 } else {
  p->song_duration++;
 }
 for (i = 0; i < SONG_MAX; i++) {
  struct song *song = p->song[i];
  if (!song) continue;
  /* Cost */
  if (!song->extend || ((p->song_duration % 3) == i)) {
   cost++;
  }
  /* Song effects */
  if (song->effect) {
   bool dummy = false;
   effect_do(song->effect, source_player(), NULL, &dummy, true,
       DIR_NONE, NULL);
  }
 }
 /* Pay costs */
 p->csp -= MIN(cost, p->csp);
 p->upkeep->redraw |= (PR_MANA);
}
/**
 * ------------------------------------------------------------------------
 * Monster songs
 * ------------------------------------------------------------------------ */
/**
 * Print messages and calculate song skill for singing monsters
 */
int monster_sing(struct monster *mon, struct song *song)
{
    char m_name[80];
    char *description;
 struct song *silence = lookup_song("Silence");
 int song_skill = mon->race->song;
    int dist = flow_dist(cave->player_noise, mon->grid);
    /* Get the monster name */
    monster_desc(m_name, sizeof(m_name), mon, MDESC_SHOW);
    /* Messages for beginning a new song */
    if ((mon->song != song) && monster_is_visible(mon)) {
        msg("%s begins a song of %s.", m_name, song->desc);
        /* Disturb if message printed */
        disturb(player, true);
    } else {
        /* Messages for continuing a song */
  int pick = randint0(8);
  struct alt_song_desc *alt_desc = song->alt_desc;
  description = alt_desc->desc;
  while (pick) {
   alt_desc = alt_desc->next;
   if (!alt_desc) {
    description = song->desc;
    break;
   }
   description = alt_desc->desc;
   pick--;
  }
  if (monster_is_visible(mon)) {
   msg("%s sings of %s.", m_name, description);
   disturb(player, true);
  } else if (dist <= 20) {
   msg("You hear a song of %s.", description);
   disturb(player, true);
  } else if (dist <= 20) {
   msg("You hear singing in the distance.");
   disturb(player, true);
  }
 }
 /* Remember the monster is now singing this song */
 mon->song = song;
    /* If the player is singing the song of silence, penalise the monster */
 if (player_is_singing(player, silence)) {
  song_skill -= song_bonus(player, player->state.skill_use[SKILL_SONG],
         silence) / 2;
 }
 return song_skill;
}
/**
 * \file sound-core.c
 * \brief core sound support
 *
 * Copyright (c) 2016 Graeme Russ <graeme.russ@gmail.com>
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
struct sound_module
{
 const char *name;
 const char *help;
 errr (*init)(struct sound_hooks *hooks, int argc, char **argv);
};
struct msg_snd_data
{
 uint16_t num_sounds;
 uint16_t sound_ids[16];
};
/*
 * Not the most efficient use of memory, but brutally efficient runtime.
 * At time of writing, MSG_MAX ~= 150. sizeof(struct msg_snd_data) = 34,
 * so we are using ~5kB of memory.
 */
static struct msg_snd_data message_sounds[MSG_MAX];
/**
 * List of sound modules in the order they should be tried.
 */
static const struct sound_module sound_modules[] =
{
 { "", "", NULL },
};
/*
 * After processing the preference files, 'sounds' will contain next_sound_id
 * entries - each representing a sound that needs to be loaded by calling
 * load_sound_hook() for each entry.
 */
static uint16_t next_sound_id;
static struct sound_data *sounds;
/* These are the hooks installed by the platform sound module */
static struct sound_hooks hooks;
/*
 * If preload_sounds is true, sounds are loaded immediately when assigned to
 * a message. Otherwise, each sound is only loaded when first played.
 */
static bool preload_sounds = false;
/**
 * Iterate through all the sound types supporting by the platform's sound
 * module. Call the platform's sound modules 'load sound' function for each
 * supported file type until the platform's sound module tell us that it
 * could load the sound.
 * NOTE: The platform's sound module does not have to load the sound into
 * memory, it merely has to let us know that it can play the sound when
 * asked to.
 */
static void load_sound(struct sound_data *sound_data)
{
 if ((hooks.load_sound_hook) && (hooks.supported_files_hook)) {
  char path[2048];
  char *filename_buf;
  size_t filename_buf_size;
  int i = 0;
  bool load_success = false;
  const struct sound_file_type *supported_sound_files = hooks.supported_files_hook();
  /* Build the path to the sound file (minus extension) */
  path_build(path, sizeof(path), ANGBAND_DIR_SOUNDS, sound_data->name);
  /*
		 * Loop through all the extensions supported by the
		 * platform's sound module.
		 */
  while ((0 != supported_sound_files[i].type) && (!load_success)) {
   /*
			 * Create a buffer to store the filename plus extension
			 */
   filename_buf_size = strlen(path) + strlen(supported_sound_files[i].extension) + 1;
   filename_buf = mem_zalloc(filename_buf_size);
   my_strcpy(filename_buf, path, filename_buf_size);
   filename_buf = string_append(filename_buf, supported_sound_files[i].extension);
   if (file_exists(filename_buf)) {
    sound_data->status = SOUND_ST_ERROR;
    load_success = hooks.load_sound_hook(
     filename_buf,
     supported_sound_files[i].type,
     sound_data);
   }
   mem_free(filename_buf);
   i++;
  }
  if (!load_success)
   plog_fmt("Failed to load sound '%s'", sound_data->name);
 }
}
errr register_sound_pref_parser(struct parser *p)
{
 return parser_reg(p, SOUND_PRF_FORMAT, parse_prefs_dummy);
}
/**
 * Play a sound of type "event".
 */
static void play_sound(game_event_type type, game_event_data *data, void *user)
{
 int s, sound_id;
 if (hooks.play_sound_hook) {
  /* Paranoia */
  assert(data->message.type >= 0);
  if (!message_sounds[data->message.type].num_sounds)
   return; /* No sounds for this message */
  s = randint0(message_sounds[data->message.type].num_sounds);
  sound_id = message_sounds[data->message.type].sound_ids[s];
  assert((sound_id >= 0) && (sound_id < next_sound_id));
  /* Ensure the sound is loaded before we play it */
  if (sounds[sound_id].status == SOUND_ST_UNKNOWN)
   load_sound(&sounds[sound_id]);
  /* Only bother playing it if the platform can */
  if (sounds[sound_id].status == SOUND_ST_LOADED)
   hooks.play_sound_hook(&sounds[sound_id]);
 }
}
/**
 * Set whether all sounds are loaded when the sound preferences are loaded or
 * a sound is loaded when it is needed.
 *
 * \param new_setting will, if true, causes all sounds to be preloaded when
 * the sound preferences are loaded next.  If false, a sound will be loaded
 * just before it is first played..
 * \return the previous setting for whether sounds are preloaded.
 */
bool set_preloaded_sounds(bool new_setting)
{
 bool old_setting = preload_sounds;
 preload_sounds = new_setting;
 return old_setting;
}
/**
 * Init the sound "module".
 */
errr init_sound(const char *soundstr, int argc, char **argv)
{
 int i = 0;
 bool done = false;
 /* Release resources previously allocated if called multiple times. */
 close_sound();
 /* Try the modules in the order specified by sound_modules[] */
 while (sound_modules[i].init && !done) {
  if (!soundstr || streq(soundstr, sound_modules[i].name))
   if (0 == sound_modules[i].init(&hooks, argc, argv))
    done = true;
  i++;
 }
 /* Check that we have a sound module to use */
 if (!done)
  return 1;
 /* Open the platform specific sound system */
 if (!hooks.open_audio_hook)
  return 1;
 if (!hooks.open_audio_hook())
  return 1;
 /* Enable sound */
 event_add_handler(EVENT_SOUND, play_sound, NULL);
 /* Success */
 return (0);
}
/**
 * Shut down the sound "module".
 */
void close_sound(void)
{
 if (0 == next_sound_id) return; /* Never opened */
 /*
	 * Ask the platforms sound module to free resources for each
	 * sound
	 */
 if (hooks.unload_sound_hook) {
  int i;
  for (i = 0; i < next_sound_id; i++) {
   hooks.unload_sound_hook(&sounds[i]);
   string_free(sounds[i].name);
  }
 }
 mem_free(sounds);
 sounds = NULL;
 next_sound_id = 0;
 /* Close the platform's sound module */
 if (hooks.close_audio_hook) {
  hooks.close_audio_hook();
 }
}
/**
 * Print out the 'help' information for the sound module.
 */
void print_sound_help(void)
{
 int i;
 for (i = 0; i < (int)N_ELEMENTS(sound_modules); i++)
  printf("     %s   %s\n", sound_modules[i].name,
         sound_modules[i].help);
}
/**
 * \file source.c
 * \brief Type that allows various different origins for an effect
 *
 * Copyright (c) 2016 Andi Sidwell
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
struct source source_none(void)
{
 struct source src;
 src.what = SRC_NONE;
 return src;
}
struct source source_trap(struct trap *trap)
{
 struct source src;
 src.what = SRC_TRAP;
 src.which.trap = trap;
 return src;
}
struct source source_monster(int who)
{
 struct source src;
 src.what = SRC_MONSTER;
 src.which.monster = who;
 return src;
}
struct source source_player(void)
{
 struct source src;
 src.what = SRC_PLAYER;
 return src;
}
struct source source_object(struct object *object)
{
 struct source src;
 src.what = SRC_OBJECT;
 src.which.object = object;
 return src;
}
struct source source_chest_trap(struct chest_trap *chest_trap)
{
 struct source src;
 src.what = SRC_CHEST_TRAP;
 src.which.chest_trap = chest_trap;
 return src;
}
struct source source_grid(struct loc grid)
{
 struct source src;
 src.what = SRC_GRID;
 src.which.grid = grid;
 return src;
}
/**
 * \file target.c
 * \brief Targetting code
 *
 * Copyright (c) 1997-2007 Angband contributors
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Is the target set?
 */
static bool target_set;
/**
 * Is the target fixed (for the duration of a spell)?
 */
static bool target_fixed;
/**
 * Player target
 */
static struct target target;
/**
 * Old player target
 */
static struct target old_target;
/**
 * Monster health description
 */
void look_mon_desc(char *buf, size_t max, int m_idx)
{
 struct monster *mon = cave_monster(cave, m_idx);
 if (!mon) return;
 /* Start the string empty */
 my_strcpy(buf, " (", max);
 if (player->wizard) {
  if (mon->alertness < ALERTNESS_UNWARY) {
   my_strcat(buf, format("asleep (%d), ", mon->alertness), max);
  } else if (mon->alertness < ALERTNESS_ALERT) {
   my_strcat(buf, format("unwary (%d), ", mon->alertness), max);
  } else {
   my_strcat(buf, format("alert (%d), ", mon->alertness), max);
  }
 }
 /* Effect status */
 if (mon->m_timed[MON_TMD_CONF]) my_strcat(buf, "confused, ", max);
 if (mon->m_timed[MON_TMD_STUN]) my_strcat(buf, "stunned, ", max);
 if (mon->m_timed[MON_TMD_SLOW]) my_strcat(buf, "slowed, ", max);
 if (mon->m_timed[MON_TMD_FAST]) my_strcat(buf, "hasted, ", max);
 /* If nothing is going to be written, wipe the string */
 if (strlen(buf) == 2) {
  buf[0] = '\0';
 } else {
  /* Otherwise trim the final ", " and finish */
  buf[strlen(buf) - 2] = '\0';
  my_strcat(buf, ") ", max);
 }
}
/**
 * Determine if a monster makes a reasonable target
 *
 * The concept of "targetting" was stolen from "Morgul" (?)
 *
 * The player can target any location, or any "target-able" monster.
 *
 * Currently, a monster is "target_able" if it is visible, and if
 * the player can hit it with a projection, and the player is not
 * hallucinating.  This allows use of "use closest target" macros.
 */
bool target_able(struct monster *m)
{
 bool rage_visible = player->is_dead || !player->timed[TMD_RAGE] ||
  (m && m->race &&square_isseen(cave, m->grid));
 return m && m->race && monster_is_visible(m) &&
  projectable(cave, player->grid, m->grid, PROJECT_NONE) &&
  !player->timed[TMD_IMAGE] && rage_visible;
}
/**
 * Update (if necessary) and verify (if possible) the target.
 *
 * We return true if the target is "okay" and false otherwise.
 */
bool target_okay(int range)
{
 /* No target */
 if (!target_set) return false;
 /* Check "monster" targets */
 if (target.midx > 0) {
  struct monster *mon = cave_monster(cave, target.midx);
  if (target_able(mon)) {
   /* Get the monster location */
   target.grid = mon->grid;
   /* Reject if it is beyond the imposed range. */
   if (range && (distance(player->grid, target.grid)
     > range)) {
    return false;
   }
   /* Good target */
   return true;
  }
 } else if (target.grid.x && target.grid.y) {
        /* Reject things beyond range */
        if (range && (distance(player->grid, target.grid) > range))
   return false;
        /* Accept things in LOF */
        if (square_isfire(cave, target.grid)) return true;
        /* Accept walls (for horn of blasting stuff) */
        if (square_iswall(cave, target.grid)) return true;
 }
 /* Assume no target */
 return false;
}
/**
 * Set the target to a monster (or nobody); if target is fixed, don't unset
 */
bool target_set_monster(struct monster *mon)
{
 /* Acceptable target */
 if (mon && target_able(mon)) {
  target_set = true;
  target.midx = mon->midx;
  target.grid = mon->grid;
  return true;
 } else if (target_fixed) {
  /* If a monster has died during a spell, this maintains its grid as
		 * the target in case further effects of the spell need it */
  target.midx = 0;
  return true;
 }
 /* Reset target info */
 target_set = false;
 target.midx = 0;
 target.grid.y = 0;
 target.grid.x = 0;
 return false;
}
/**
 * Set the target to a location
 */
void target_set_location(struct loc grid)
{
 /* Legal target */
 if (square_in_bounds_fully(cave, grid)) {
  /* Save target info */
  target_set = true;
  target.midx = 0;
  target.grid = grid;
  return;
 }
 /* Reset target info */
 target_set = false;
 target.midx = 0;
 target.grid.y = 0;
 target.grid.x = 0;
}
/**
 * Tell the UI the target is set
 */
bool target_is_set(void)
{
 return target_set;
}
/**
 * Fix the target
 */
void target_fix(void)
{
 old_target = target;
 target_fixed = true;
}
/**
 * Release the target
 */
void target_release(void)
{
 target_fixed = false;
 /* If the old target is a now-dead monster, cancel it */
 if (old_target.midx != 0) {
  struct monster *mon = cave_monster(cave, old_target.midx);
  if (!mon || !mon->race || !monster_is_in_view(mon)) {
   target.grid.y = 0;
   target.grid.x = 0;
  }
 }
}
/**
 * Sorting hook -- comp function -- by "distance to player"
 *
 * We use "u" and "v" to point to arrays of "x" and "y" positions,
 * and sort the arrays by double-distance to the player.
 */
int cmp_distance(const void *a, const void *b)
{
 int py = player->grid.y;
 int px = player->grid.x;
 const struct loc *pa = a;
 const struct loc *pb = b;
 int da, db, kx, ky;
 /* Absolute distance components */
 kx = pa->x; kx -= px; kx = ABS(kx);
 ky = pa->y; ky -= py; ky = ABS(ky);
 /* Approximate Double Distance to the first point */
 da = ((kx > ky) ? (kx + kx + ky) : (ky + ky + kx));
 /* Absolute distance components */
 kx = pb->x; kx -= px; kx = ABS(kx);
 ky = pb->y; ky -= py; ky = ABS(ky);
 /* Approximate Double Distance to the first point */
 db = ((kx > ky) ? (kx + kx + ky) : (ky + ky + kx));
 /* Compare the distances */
 if (da < db)
  return -1;
 if (da > db)
  return 1;
 return 0;
}
/**
 * Help select a location.  This function picks the closest from a set in 
 *(roughly) a given direction.
 */
int16_t target_pick(int y1, int x1, int dy, int dx, struct point_set *targets)
{
 int i, v;
 int x2, y2, x3, y3, x4, y4;
 int b_i = -1, b_v = 9999;
 /* Scan the locations */
 for (i = 0; i < point_set_size(targets); i++) {
  /* Point 2 */
  x2 = targets->pts[i].x;
  y2 = targets->pts[i].y;
  /* Directed distance */
  x3 = (x2 - x1);
  y3 = (y2 - y1);
  /* Verify quadrant */
  if (dx && (x3 * dx <= 0)) continue;
  if (dy && (y3 * dy <= 0)) continue;
  /* Absolute distance */
  x4 = ABS(x3);
  y4 = ABS(y3);
  /* Verify quadrant */
  if (dy && !dx && (x4 > y4)) continue;
  if (dx && !dy && (y4 > x4)) continue;
  /* Approximate Double Distance */
  v = ((x4 > y4) ? (x4 + x4 + y4) : (y4 + y4 + x4));
  /* Track best */
  if ((b_i >= 0) && (v >= b_v)) continue;
  /* Track best */
  b_i = i; b_v = v;
 }
 /* Result */
 return (b_i);
}
/**
 * Determine if a given location is "interesting"
 */
static bool target_accept(struct loc grid)
{
 struct object *obj;
 /* Player grids are always interesting */
 if (square(cave, grid)->mon < 0) return true;
 /* Handle hallucination */
 if (player->timed[TMD_IMAGE]) return false;
 /* Obvious monsters */
 if (square(cave, grid)->mon > 0) {
  struct monster *mon = square_monster(cave, grid);
  if (monster_is_visible(mon)) {
   return true;
  }
 }
 /* Traps */
 if (square_isvisibletrap(player->cave, grid)) return true;
 /* Scan all objects in the grid */
 for (obj = square_object(player->cave, grid); obj; obj = obj->next) {
  /* Memorized object */
  if (obj->kind == unknown_item_kind
    || !ignore_known_item_ok(player, obj)) {
   return true;
  }
 }
 /* Interesting memorized features */
 if (square_isknown(cave, grid)
  && square_isinteresting(player->cave, grid)) {
  return true;
 }
 /* Nope */
 return false;
}
/**
 * Describe a location relative to the player position.
 * e.g. "12 S 35 W" or "0 N, 33 E" or "0 N, 0 E"
 */
void coords_desc(char *buf, int size, struct loc grid)
{
 const char *east_or_west;
 const char *north_or_south;
 if (grid.y > player->grid.y)
  north_or_south = "S";
 else
  north_or_south = "N";
 if (grid.x < player->grid.x)
  east_or_west = "W";
 else
  east_or_west = "E";
 strnfmt(buf, size, "%d %s, %d %s",
   ABS(grid.y - player->grid.y), north_or_south,
   ABS(grid.x - player->grid.x), east_or_west);
}
/**
 * Obtains the location the player currently targets.
 */
void target_get(struct loc *grid)
{
 assert(grid);
 *grid = target.grid;
}
/**
 * Returns the currently targeted monster index.
 */
struct monster *target_get_monster(void)
{
 return cave_monster(cave, target.midx);
}
/**
 * True if the player's current target is in LOS.
 */
bool target_sighted(void)
{
 return target_okay(z_info->max_sight) &&
   panel_contains(target.grid.y, target.grid.x) &&
    /* either the target is a grid and is visible, or it is a monster
			  * that is visible */
  ((!target.midx && square_isseen(cave, target.grid)) ||
   (target.midx && monster_is_visible(cave_monster(cave, target.midx))));
}
/**
 * Return a target set of interesting locations including monsters, objects,
 * traps, and features.
 *
 * \mode If mode includes TARGET_KILL, only target_able monsters matching pred
 *       are included
 * \pred The monster predicate used to filter monsters (optional)
 * \restrict_to_panel Restricts the interesting points to the current panel
 */
struct point_set *target_get_monsters(int mode, monster_predicate pred,
  bool restrict_to_panel)
{
 struct loc grid;
 int min_y, min_x, max_y, max_x;
 struct point_set *targets = point_set_new(20);
 if (restrict_to_panel) {
  /* Get the current panel */
  get_panel(&min_y, &min_x, &max_y, &max_x);
 } else {
  min_y = player->grid.y - z_info->max_range;
  max_y = player->grid.y + z_info->max_range + 1;
  min_x = player->grid.x - z_info->max_range;
  max_x = player->grid.x + z_info->max_range + 1;
 }
 /* Scan for targets */
 for (grid.y = min_y; grid.y < max_y; grid.y++) {
  for (grid.x = min_x; grid.x < max_x; grid.x++) {
   /* Check bounds */
   if (!square_in_bounds_fully(cave, grid)) continue;
   /* Require "interesting" contents */
   if (!target_accept(grid)) continue;
   /* Special mode */
   if (mode & (TARGET_KILL)) {
    struct monster *mon = square_monster(cave, grid);
    /* Must contain a monster */
    if (mon == NULL) continue;
    /* Must be a targettable monster */
    if (!target_able(mon)) continue;
    /* Must be the right sort of monster */
    if (pred && !pred(mon)) continue;
   }
   /* Save the location */
   add_to_point_set(targets, grid);
  }
 }
 sort(targets->pts, point_set_size(targets), sizeof(*(targets->pts)),
   cmp_distance);
 return targets;
}
/**
 * Set target to closest monster.
 */
bool target_set_closest(int mode, monster_predicate pred)
{
 struct monster *mon;
 char m_name[80];
 struct point_set *targets;
 /* Cancel old target */
 target_set_monster(NULL);
 /* Get ready to do targetting */
 targets = target_get_monsters(mode, pred, false);
 /* If nothing was prepared, then return */
 if (point_set_size(targets) < 1) {
  msg("No Available Target.");
  point_set_dispose(targets);
  return false;
 }
 /* Find the first monster in the queue */
 mon = square_monster(cave, targets->pts[0]);
 /* Target the monster, if possible */
 if (!target_able(mon)) {
  msg("No Available Target.");
  point_set_dispose(targets);
  return false;
 }
 /* Target the monster */
 monster_desc(m_name, sizeof(m_name), mon, MDESC_CAPITAL | MDESC_COMMA);
 if (!(mode & TARGET_QUIET))
  msg("%s is targeted.", m_name);
 /* Set up target information */
 monster_race_track(player->upkeep, mon->race);
 health_track(player->upkeep, mon);
 target_set_monster(mon);
 point_set_dispose(targets);
 return true;
}
/**
 * \file trap.c
 * \brief The trap layer - player traps, runes and door locks
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * ------------------------------------------------------------------------
 * Initialize traps
 * ------------------------------------------------------------------------ */
static const char *trap_flags[] =
{
/**
 * \file list-trap-flags.h
 * \brief trap properties
 *
 * Adjusting these flags does not break savefiles. Flags below start from 1
 * on line 13, so a flag's sequence number is its line number minus 12.
 *
 *
 */
/*  symbol		descr */
"NONE",
"GLYPH",
"TRAP",
"VISIBLE",
"INVISIBLE",
"FLOOR",
"SURFACE",
"DOWN",
"PIT",
"ONETIME",
"SAVE_SKILL",
"LOCK",
"JAM",
"FORGE_USE",
"DELAY",

    NULL
};
static enum parser_error parse_trap_name(struct parser *p) {
    const char *name = parser_getsym(p, "name");
    const char *desc = parser_getstr(p, "desc");
    struct trap_kind *h = parser_priv(p);
    struct trap_kind *t = mem_zalloc(sizeof *t);
    t->next = h;
    t->name = string_make(name);
 t->desc = string_make(desc);
    parser_setpriv(p, t);
    return PARSE_ERROR_NONE;
}
static enum parser_error parse_trap_graphics(struct parser *p) {
    wchar_t glyph = parser_getchar(p, "glyph");
    const char *color = parser_getsym(p, "color");
    int attr = 0;
    struct trap_kind *t = parser_priv(p);
    if (!t)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
    t->d_char = glyph;
    if (strlen(color) > 1)
  attr = color_text_to_attr(color);
    else
  attr = color_char_to_attr(color[0]);
    if (attr < 0)
  return PARSE_ERROR_INVALID_COLOR;
    t->d_attr = attr;
    return PARSE_ERROR_NONE;
}
static enum parser_error parse_trap_rarity(struct parser *p) {
    struct trap_kind *t = parser_priv(p);
    if (!t)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
    t->rarity = parser_getuint(p, "rarity");
    return PARSE_ERROR_NONE;
}
static enum parser_error parse_trap_min_depth(struct parser *p) {
    struct trap_kind *t = parser_priv(p);
    if (!t)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
    t->min_depth = parser_getuint(p, "mindepth");
    return PARSE_ERROR_NONE;
}
static enum parser_error parse_trap_max_depth(struct parser *p) {
    struct trap_kind *t = parser_priv(p);
    if (!t)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
    t->max_depth = parser_getuint(p, "maxdepth");
    return PARSE_ERROR_NONE;
}
static enum parser_error parse_trap_power(struct parser *p) {
    struct trap_kind *t = parser_priv(p);
    int power = parser_getint(p, "power");
    if (!t)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
    /*
     * Internally, a trap instance uses a uint8_t to store the power so reject
     * any power here that can not be unambiguously stored in a uint8_t.  -1
     * means the trap is undisarmable.
     */
    if (power < -1 || power > 254) {
        return PARSE_ERROR_INVALID_VALUE;
    }
    t->power = power;
    return PARSE_ERROR_NONE;
}
static enum parser_error parse_trap_stealth(struct parser *p) {
    struct trap_kind *t = parser_priv(p);
    if (!t)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
    t->stealth = parser_getint(p, "stealth");
    return PARSE_ERROR_NONE;
}
static enum parser_error parse_trap_flags(struct parser *p) {
    char *flags;
    struct trap_kind *t = parser_priv(p);
    char *s;
    if (!t)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
    if (!parser_hasval(p, "flags"))
  return PARSE_ERROR_NONE;
    flags = string_make(parser_getstr(p, "flags"));
    s = strtok(flags, " |");
    while (s) {
  if (grab_flag(t->flags, TRF_SIZE, trap_flags, s)) {
   break;
  }
  s = strtok(NULL, " |");
    }
    string_free(flags);
    return s ? PARSE_ERROR_INVALID_FLAG : PARSE_ERROR_NONE;
}
static enum parser_error parse_trap_effect(struct parser *p) {
    struct trap_kind *t = parser_priv(p);
 struct effect *effect, *new_effect;
 if (!t)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 /* Go to the next vacant effect and set it to the new one  */
 new_effect = mem_zalloc(sizeof(*new_effect));
 if (t->effect) {
  effect = t->effect;
  while (effect->next)
   effect = effect->next;
  effect->next = new_effect;
 } else
  t->effect = new_effect;
 /* Fill in the detail */
 return grab_effect_data(p, new_effect);
}
static enum parser_error parse_trap_dice(struct parser *p) {
 struct trap_kind *t = parser_priv(p);
 struct effect *effect;
 dice_t *dice;
 const char *string;
 if (!t)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 /* If there is no effect, assume that this is human and not parser error. */
 effect = t->effect;
 if (effect == NULL)
  return PARSE_ERROR_NONE;
 while (effect->next) effect = effect->next;
 dice = dice_new();
 if (dice == NULL)
  return PARSE_ERROR_INVALID_DICE;
 string = parser_getstr(p, "dice");
 if (dice_parse_string(dice, string)) {
  dice_free(effect->dice);
  effect->dice = dice;
 } else {
  dice_free(dice);
  return PARSE_ERROR_INVALID_DICE;
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_trap_expr(struct parser *p) {
 struct trap_kind *t = parser_priv(p);
 struct effect *effect;
 expression_t *expression;
 expression_base_value_f function;
 const char *name;
 const char *base;
 const char *expr;
 enum parser_error result;
 if (!t)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 /* If there is no effect, assume that this is human and not parser error. */
 effect = t->effect;
 if (effect == NULL)
  return PARSE_ERROR_NONE;
 while (effect->next) effect = effect->next;
 /* If there are no dice, assume that this is human and not parser error. */
 if (effect->dice == NULL)
  return PARSE_ERROR_NONE;
 name = parser_getsym(p, "name");
 base = parser_getsym(p, "base");
 expr = parser_getstr(p, "expr");
 expression = expression_new();
 if (expression == NULL)
  return PARSE_ERROR_INVALID_EXPRESSION;
 function = effect_value_base_by_name(base);
 expression_set_base_value(expression, function);
 if (expression_add_operations_string(expression, expr) < 0) {
  result = PARSE_ERROR_BAD_EXPRESSION_STRING;
 } else if (dice_bind_expression(effect->dice, name, expression) < 0) {
  result = PARSE_ERROR_UNBOUND_EXPRESSION;
 } else {
  result = PARSE_ERROR_NONE;
 }
 /* The dice object makes a deep copy of the expression, so we can free it */
 expression_free(expression);
 return result;
}
static enum parser_error parse_trap_effect_xtra(struct parser *p) {
 struct trap_kind *t = parser_priv(p);
 struct effect *effect, *new_effect;
 if (!t)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 /* Go to the next vacant effect and set it to the new one  */
 new_effect = mem_zalloc(sizeof(*new_effect));
 if (t->effect_xtra) {
  effect = t->effect_xtra;
  while (effect->next)
   effect = effect->next;
  effect->next = new_effect;
 } else
  t->effect_xtra = new_effect;
 /* Fill in the detail */
 return grab_effect_data(p, new_effect);
}
static enum parser_error parse_trap_dice_xtra(struct parser *p) {
 struct trap_kind *t = parser_priv(p);
 struct effect *effect;
 dice_t *dice;
 const char *string;
 if (!t)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 /* If there is no effect, assume that this is human and not parser error. */
 effect = t->effect_xtra;
 if (effect == NULL)
  return PARSE_ERROR_NONE;
 while (effect->next) effect = effect->next;
 dice = dice_new();
 if (dice == NULL)
  return PARSE_ERROR_INVALID_DICE;
 string = parser_getstr(p, "dice");
 if (dice_parse_string(dice, string)) {
  dice_free(effect->dice);
  effect->dice = dice;
 } else {
  dice_free(dice);
  return PARSE_ERROR_INVALID_DICE;
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_trap_expr_xtra(struct parser *p) {
 struct trap_kind *t = parser_priv(p);
 struct effect *effect;
 expression_t *expression;
 expression_base_value_f function;
 const char *name;
 const char *base;
 const char *expr;
 enum parser_error result;
 if (!t)
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 /* If there is no effect, assume that this is human and not parser error. */
 effect = t->effect_xtra;
 if (effect == NULL)
  return PARSE_ERROR_NONE;
 while (effect->next) effect = effect->next;
 /* If there are no dice, assume that this is human and not parser error. */
 if (effect->dice == NULL)
  return PARSE_ERROR_NONE;
 name = parser_getsym(p, "name");
 base = parser_getsym(p, "base");
 expr = parser_getstr(p, "expr");
 expression = expression_new();
 if (expression == NULL)
  return PARSE_ERROR_INVALID_EXPRESSION;
 function = effect_value_base_by_name(base);
 expression_set_base_value(expression, function);
 if (expression_add_operations_string(expression, expr) < 0) {
  result = PARSE_ERROR_BAD_EXPRESSION_STRING;
 } else if (dice_bind_expression(effect->dice, name, expression) < 0) {
  result = PARSE_ERROR_UNBOUND_EXPRESSION;
 } else {
  result = PARSE_ERROR_NONE;
 }
 /* The dice object makes a deep copy of the expression, so we can free it */
 expression_free(expression);
 return result;
}
static enum parser_error parse_trap_desc(struct parser *p) {
    struct trap_kind *t = parser_priv(p);
    if (!t) return PARSE_ERROR_MISSING_RECORD_HEADER;
    t->text = string_append(t->text, parser_getstr(p, "text"));
    return PARSE_ERROR_NONE;
}
static enum parser_error parse_trap_msg(struct parser *p) {
    struct trap_kind *t = parser_priv(p);
    if (!t) return PARSE_ERROR_MISSING_RECORD_HEADER;
    t->msg = string_append(t->msg, parser_getstr(p, "text"));
    return PARSE_ERROR_NONE;
}
static enum parser_error parse_trap_msg2(struct parser *p) {
    struct trap_kind *t = parser_priv(p);
    if (!t) return PARSE_ERROR_MISSING_RECORD_HEADER;
    t->msg2 = string_append(t->msg2, parser_getstr(p, "text"));
    return PARSE_ERROR_NONE;
}
static enum parser_error parse_trap_msg3(struct parser *p) {
    struct trap_kind *t = parser_priv(p);
    if (!t) return PARSE_ERROR_MISSING_RECORD_HEADER;
    t->msg3 = string_append(t->msg3, parser_getstr(p, "text"));
    return PARSE_ERROR_NONE;
}
static enum parser_error parse_trap_msg_vis(struct parser *p) {
    struct trap_kind *t = parser_priv(p);
    if (!t) return PARSE_ERROR_MISSING_RECORD_HEADER;
    t->msg_vis = string_append(t->msg_vis, parser_getstr(p, "text"));
    return PARSE_ERROR_NONE;
}
static enum parser_error parse_trap_msg_silence(struct parser *p) {
    struct trap_kind *t = parser_priv(p);
    if (!t) return PARSE_ERROR_MISSING_RECORD_HEADER;
    t->msg_silence = string_append(t->msg_silence, parser_getstr(p, "text"));
    return PARSE_ERROR_NONE;
}
static enum parser_error parse_trap_msg_good(struct parser *p) {
    struct trap_kind *t = parser_priv(p);
    if (!t) return PARSE_ERROR_MISSING_RECORD_HEADER;
    t->msg_good = string_append(t->msg_good, parser_getstr(p, "text"));
    return PARSE_ERROR_NONE;
}
static enum parser_error parse_trap_msg_bad(struct parser *p) {
    struct trap_kind *t = parser_priv(p);
    if (!t) return PARSE_ERROR_MISSING_RECORD_HEADER;
    t->msg_bad = string_append(t->msg_bad, parser_getstr(p, "text"));
    return PARSE_ERROR_NONE;
}
static enum parser_error parse_trap_msg_xtra(struct parser *p) {
    struct trap_kind *t = parser_priv(p);
    if (!t) return PARSE_ERROR_MISSING_RECORD_HEADER;
    t->msg_xtra = string_append(t->msg_xtra, parser_getstr(p, "text"));
    return PARSE_ERROR_NONE;
}
static struct parser *init_parse_trap(void) {
    struct parser *p = parser_new();
    parser_setpriv(p, NULL);
    parser_reg(p, "name sym name str desc", parse_trap_name);
    parser_reg(p, "graphics char glyph sym color", parse_trap_graphics);
    parser_reg(p, "rarity uint rarity", parse_trap_rarity);
    parser_reg(p, "min-depth uint mindepth", parse_trap_min_depth);
    parser_reg(p, "max-depth uint maxdepth", parse_trap_max_depth);
    parser_reg(p, "power int power", parse_trap_power);
    parser_reg(p, "stealth int stealth", parse_trap_stealth);
    parser_reg(p, "flags ?str flags", parse_trap_flags);
 parser_reg(p, "effect sym eff ?sym type ?int radius ?int other", parse_trap_effect);
 parser_reg(p, "dice str dice", parse_trap_dice);
 parser_reg(p, "expr sym name sym base str expr", parse_trap_expr);
 parser_reg(p, "effect-xtra sym eff ?sym type ?int radius ?int other", parse_trap_effect_xtra);
 parser_reg(p, "dice-xtra str dice", parse_trap_dice_xtra);
 parser_reg(p, "expr-xtra sym name sym base str expr", parse_trap_expr_xtra);
 parser_reg(p, "desc str text", parse_trap_desc);
 parser_reg(p, "msg str text", parse_trap_msg);
 parser_reg(p, "msg2 str text", parse_trap_msg2);
 parser_reg(p, "msg3 str text", parse_trap_msg3);
 parser_reg(p, "msg-vis str text", parse_trap_msg_vis);
 parser_reg(p, "msg-silence str text", parse_trap_msg_silence);
 parser_reg(p, "msg-good str text", parse_trap_msg_good);
 parser_reg(p, "msg-bad str text", parse_trap_msg_bad);
 parser_reg(p, "msg-xtra str text", parse_trap_msg_xtra);
    return p;
}
static errr run_parse_trap(struct parser *p) {
    return parse_file_quit_not_found(p, "trap");
}
static errr finish_parse_trap(struct parser *p) {
 struct trap_kind *t, *n;
 int tidx;
 /* Scan the list for the max id */
 z_info->trap_max = 0;
 t = parser_priv(p);
 while (t) {
  z_info->trap_max++;
  t = t->next;
 }
 trap_info = mem_zalloc((z_info->trap_max + 1) * sizeof(*t));
 tidx = z_info->trap_max - 1;
    for (t = parser_priv(p); t; t = t->next, tidx--) {
  assert(tidx >= 0);
  memcpy(&trap_info[tidx], t, sizeof(*t));
  trap_info[tidx].tidx = tidx;
  if (tidx < z_info->trap_max - 1)
   trap_info[tidx].next = &trap_info[tidx + 1];
  else
   trap_info[tidx].next = NULL;
    }
    t = parser_priv(p);
    while (t) {
  n = t->next;
  mem_free(t);
  t = n;
    }
    parser_destroy(p);
    return 0;
}
static void cleanup_trap(void)
{
 int i;
 for (i = 0; i < z_info->trap_max; i++) {
  string_free(trap_info[i].name);
  mem_free(trap_info[i].text);
  string_free(trap_info[i].desc);
  string_free(trap_info[i].msg);
  string_free(trap_info[i].msg2);
  string_free(trap_info[i].msg3);
  string_free(trap_info[i].msg_vis);
  string_free(trap_info[i].msg_silence);
  string_free(trap_info[i].msg_good);
  string_free(trap_info[i].msg_bad);
  string_free(trap_info[i].msg_xtra);
  free_effect(trap_info[i].effect);
  free_effect(trap_info[i].effect_xtra);
 }
 mem_free(trap_info);
}
struct file_parser trap_parser = {
    "trap",
    init_parse_trap,
    run_parse_trap,
    finish_parse_trap,
    cleanup_trap
};
/**
 * ------------------------------------------------------------------------
 * General trap routines
 * ------------------------------------------------------------------------ */
struct trap_kind *trap_info;
/**
 * Find a trap kind based on its short description
 */
struct trap_kind *lookup_trap(const char *desc)
{
 int i;
 struct trap_kind *closest = NULL;
 /* Look for it */
 for (i = 1; i < z_info->trap_max; i++) {
  struct trap_kind *kind = &trap_info[i];
  if (!kind->name)
   continue;
  /* Test for equality */
  if (streq(desc, kind->desc))
   return kind;
  /* Test for close matches */
  if (!closest && my_stristr(kind->desc, desc))
   closest = kind;
 }
 /* Return our best match */
 return closest;
}
/**
 * Is there a specific kind of trap in this square?
 */
bool square_trap_specific(struct chunk *c, struct loc grid, int t_idx)
{
    struct trap *trap = square_trap(c, grid);
    /* First, check the trap marker */
    if (!square_istrap(c, grid))
  return false;
    /* Scan the square trap list */
    while (trap) {
  /* We found a trap of the right kind */
  if (trap->t_idx == t_idx)
   return true;
  trap = trap->next;
 }
    /* Report failure */
    return false;
}
/**
 * Is there a trap with a given flag in this square?
 */
bool square_trap_flag(struct chunk *c, struct loc grid, int flag)
{
    struct trap *trap = square_trap(c, grid);
    /* First, check the trap marker */
    if (!square_istrap(c, grid))
  return false;
    /* Scan the square trap list */
    while (trap) {
  /* We found a trap with the right flag */
  if (trf_has(trap->flags, flag))
   return true;
  trap = trap->next;
    }
    /* Report failure */
    return false;
}
/**
 * Determine if a trap actually exists in this square.
 *
 * Called with vis = 0 to accept any trap, = 1 to accept only visible
 * traps, and = -1 to accept only invisible traps.
 *
 * Clear the SQUARE_TRAP flag if none exist.
 */
static bool square_verify_trap(struct chunk *c, struct loc grid, int vis)
{
    struct trap *trap = square_trap(c, grid);
    bool trap_exists = false;
    /* Scan the square trap list */
    while (trap) {
  /* Accept any trap */
  if (!vis)
   return true;
  /* Accept traps that match visibility requirements */
  if ((vis == 1) && trf_has(trap->flags, TRF_VISIBLE))
   return true;
  if ((vis == -1) && !trf_has(trap->flags, TRF_VISIBLE))
   return true;
  /* Note that a trap does exist */
  trap_exists = true;
    }
    /* No traps in this location. */
    if (!trap_exists) {
  /* No traps */
  sqinfo_off(square(c, grid)->info, SQUARE_TRAP);
  /* Take note */
  square_note_spot(c, grid);
    }
    /* Report failure */
    return false;
}
/**
 * Free memory for all traps on a grid
 */
void square_free_trap(struct chunk *c, struct loc grid)
{
 struct trap *next, *trap = square_trap(c, grid);
 while (trap) {
  next = trap->next;
  mem_free(trap);
  trap = next;
 }
}
/**
 * Remove all traps from a grid.
 *
 * Return true if traps were removed.
 */
bool square_remove_all_traps(struct chunk *c, struct loc grid)
{
 struct trap *trap = square(c, grid)->trap;
 bool were_there_traps = trap == NULL ? false : true;
 while (trap) {
  struct trap *next_trap = trap->next;
  mem_free(trap);
  trap = next_trap;
 }
 square_set_trap(c, grid, NULL);
 /* Refresh grids that the character can see */
 if (square_isseen(c, grid)) {
  square_memorize_traps(c, grid);
  square_light_spot(c, grid);
 }
 (void)square_verify_trap(c, grid, 0);
 return were_there_traps;
}
/**
 * Remove all traps with the given index.
 *
 * Return true if traps were removed.
 */
bool square_remove_trap(struct chunk *c, struct loc grid, int t_idx_remove)
{
 bool removed = false;
 /* Look at the traps in this grid */
 struct trap *prev_trap = NULL;
 struct trap *trap = square(c, grid)->trap;
 while (trap) {
  struct trap *next_trap = trap->next;
  if (t_idx_remove == trap->t_idx) {
   mem_free(trap);
   removed = true;
   if (prev_trap) {
    prev_trap->next = next_trap;
   } else {
    square_set_trap(c, grid, next_trap);
   }
   break;
  }
  prev_trap = trap;
  trap = next_trap;
 }
 /* Refresh grids that the character can see */
 if (square_isseen(c, grid)) {
  square_memorize_traps(c, grid);
  square_light_spot(c, grid);
 }
 (void)square_verify_trap(c, grid, 0);
 return removed;
}
/**
 * ------------------------------------------------------------------------
 * Player traps
 * ------------------------------------------------------------------------ */
/**
 * Determine if a trap affects the player, based on player's evasion.
 */
bool check_hit(int power, bool display_roll, struct source against)
{
 int skill = player->state.skill_use[SKILL_EVASION] +
  player_dodging_bonus(player);
 return hit_roll(power, skill, against, source_player(),
     display_roll) > 0;
}
/**
 * Determine if a cave grid is allowed to have player traps in it.
 */
bool square_player_trap_allowed(struct chunk *c, struct loc grid)
{
    /* We currently forbid multiple traps in a grid under normal conditions.
     * If this changes, various bits of code elsewhere will have to change too.
     */
    if (square_istrap(c, grid))
  return false;
    /* We currently forbid traps in a grid with objects. */
    if (square_object(c, grid))
  return false;
    /* Check it's a trappable square */
    return (square_istrappable(c, grid));
}
/**
 * Instantiate a player trap
 */
static int pick_trap(struct chunk *c, int feat, int trap_level)
{
    int i, pick;
 int *trap_probs = NULL;
 int trap_prob_max = 0;
    /* Paranoia */
    if (!feat_is_trap_holding(feat))
  return -1;
    /* Get trap probabilities */
 trap_probs = mem_zalloc(z_info->trap_max * sizeof(int));
 for (i = 0; i < z_info->trap_max; i++) {
  /* Get this trap */
  struct trap_kind *kind = &trap_info[i];
  trap_probs[i] = trap_prob_max;
  /* Ensure that this is a valid player trap */
  if (!kind->name) continue;
  if (!kind->rarity) continue;
  if (!trf_has(kind->flags, TRF_TRAP)) continue;
  /* Check depth conditions */
  if (kind->min_depth > trap_level) continue;
  if (kind->max_depth < trap_level) continue;
  if (!trap_level && !trf_has(kind->flags, TRF_SURFACE)) continue;
  /* Floor? */
  if (feat_is_floor(feat) && !trf_has(kind->flags, TRF_FLOOR))
   continue;
  /* Check legality of trapdoors. */
  if (trf_has(kind->flags, TRF_DOWN)) {
   /* No trap doors on the deepest level */
   if (player->depth >= z_info->dun_depth)
    continue;
     }
  /* Trap is okay, store the cumulative probability */
  trap_probs[i] += (100 / kind->rarity);
  trap_prob_max = trap_probs[i];
 }
 /* No valid trap */
 if (trap_prob_max == 0) {
  mem_free(trap_probs);
  return -1;
 }
 /* Pick at random. */
 pick = randint0(trap_prob_max);
 for (i = 0; i < z_info->trap_max; i++) {
  if (pick < trap_probs[i]) {
   break;
  }
 }
 mem_free(trap_probs);
    /* Return our chosen trap */
    return i < z_info->trap_max ? i : -1;
}
/**
 * Make a new trap of the given type.  Return true if successful.
 *
 * We choose a player trap at random if the index is not legal. This means that
 * things which are not player traps must be picked by passing a valid index.
 *
 * This should be the only function that places traps in the dungeon
 * except the savefile loading code.
 */
void place_trap(struct chunk *c, struct loc grid, int t_idx, int trap_level)
{
 struct trap *new_trap;
 /* We've been called with an illegal index; choose a random trap */
 if ((t_idx <= 0) || (t_idx >= z_info->trap_max)) {
  /* Require the correct terrain */
  if (!square_player_trap_allowed(c, grid)) return;
  t_idx = pick_trap(c, square(c, grid)->feat, trap_level);
 }
 /* Failure */
 if (t_idx < 0) return;
 /* Don't allow trap doors in the tutorial. */
 if (in_tutorial() && trf_has(trap_info[t_idx].flags, TRF_DOWN)) {
  return;
 }
 /* Allocate a new trap for this grid (at the front of the list) */
 new_trap = mem_zalloc(sizeof(*new_trap));
 new_trap->next = square_trap(c, grid);
 square_set_trap(c, grid, new_trap);
 /* Set the details */
 new_trap->t_idx = t_idx;
 new_trap->kind = &trap_info[t_idx];
 new_trap->grid = grid;
 new_trap->power = new_trap->kind->power;
 trf_copy(new_trap->flags, trap_info[t_idx].flags);
 /* Toggle on the trap marker */
 sqinfo_on(square(c, grid)->info, SQUARE_TRAP);
 /* Redraw the grid */
 square_note_spot(c, grid);
 square_light_spot(c, grid);
}
/**
 * Reveal some of the player traps in a square
 */
bool square_reveal_trap(struct chunk *c, struct loc grid, bool domsg)
{
    int found_trap = 0;
 struct trap *trap = square_trap(c, grid);
    /* Check there is a player trap */
    if (!square_isplayertrap(c, grid))
  return false;
 /* Scan the grid */
 while (trap) {
  /* Skip non-player traps */
  if (!trf_has(trap->flags, TRF_TRAP)) {
   trap = trap->next;
   continue;
  }
  /* Trap is invisible */
  if (!trf_has(trap->flags, TRF_VISIBLE)) {
   /* See the trap (actually, see all the traps) */
   trf_on(trap->flags, TRF_VISIBLE);
   square_memorize_traps(c, grid);
   /* We found a trap */
   found_trap++;
  }
  trap = trap->next;
 }
    /* We found at least one trap */
    if (found_trap) {
  /* We want to talk about it */
  if (domsg) {
   if (found_trap == 1)
    msg("You have found a trap.");
   else
    msg("You have found %d traps.", found_trap);
  }
  /* Memorize */
  square_memorize(c, grid);
  /* Redraw */
  square_light_spot(c, grid);
    }
    /* Return true if we found any traps */
    return (found_trap != 0);
}
/**
 * Memorize all the visible traps on a square
 */
void square_memorize_traps(struct chunk *c, struct loc grid)
{
 struct trap *trap = square(c, grid)->trap;
 struct trap *current = NULL;
 if (c != cave) return;
 /* Clear current knowledge */
 square_remove_all_traps(player->cave, grid);
 sqinfo_off(square(player->cave, grid)->info, SQUARE_TRAP);
 /* Copy all visible traps to the known cave */
 while (trap) {
  if (square_isvisibletrap(c, grid)) {
   struct trap *next;
   if (current) {
    next = mem_zalloc(sizeof(*next));
    current->next = next;
    current = next;
   } else {
    current = mem_zalloc(sizeof(*current));
    player->cave->squares[grid.y][grid.x].trap = current;
   }
   memcpy(current, trap, sizeof(*trap));
   current->next = NULL;
  }
  trap = trap->next;
 }
 if (square(player->cave, grid)->trap) {
  sqinfo_on(square(player->cave, grid)->info, SQUARE_TRAP);
 }
}
/**
 * Hit a trap. 
 */
void hit_trap(struct loc grid)
{
 bool ident = false;
 struct trap *trap;
 struct effect *effect;
 /* Look at the traps in this grid */
 for (trap = square_trap(cave, grid); trap; trap = trap->next) {
  struct song *silence = lookup_song("Silence");
  bool saved = false;
  /* Require that trap be capable of affecting the character */
  if (!trf_has(trap->kind->flags, TRF_TRAP)) continue;
  /* Disturb the player */
  disturb(player, false);
  /* Give a message */
  if (player_is_singing(player, silence) && trap->kind->msg_silence) {
   msg("%s", trap->kind->msg_silence);
  } else if (trap->kind->msg) {
   msg("%s", trap->kind->msg);
  }
  if (trap->kind->msg2) {
   event_signal(EVENT_MESSAGE_FLUSH);
   msg("%s", trap->kind->msg2);
  }
  if (trap->kind->msg3) {
   event_signal(EVENT_MESSAGE_FLUSH);
   msg("%s", trap->kind->msg3);
  }
  /* Test for save due to saving throw */
  if (trf_has(trap->kind->flags, TRF_SAVE_SKILL)) {
   int result = skill_check(source_player(),
          player->state.skill_use[SKILL_PERCEPTION],
          10, source_trap(trap));
   if (result > 0) saved = true;
  }
  /* Save, or fire off the trap */
  if (saved) {
   if (trap->kind->msg_good)
    msg("%s", trap->kind->msg_good);
  } else {
   if (trap->kind->msg_bad)
    msg("%s", trap->kind->msg_bad);
   if (trap->kind->msg_vis && !player->timed[TMD_BLIND])
    msg("%s", trap->kind->msg_vis);
   /* Affect stealth */
   player->stealth_score += trap->kind->stealth;
   effect = trap->kind->effect;
   effect_do(effect, source_trap(trap), NULL, &ident, false, 0, NULL);
   /* Trap may have gone or the player may be dead */
   if (!square_trap(cave, grid) || player->is_dead) break;
   /* Do any extra effects (hack - use ident as the trigger - NRM) */
   if (trap->kind->msg_xtra && ident) {
    msg("%s", trap->kind->msg_xtra);
    if (trap->kind->effect_xtra) {
     effect = trap->kind->effect_xtra;
     effect_do(effect, source_trap(trap), NULL, &ident, false,
         0, NULL);
    }
    /* Trap may have gone or the player may be dead */
    if (!square_trap(cave, grid) || player->is_dead) break;
   }
  }
  /* Some traps drop you a dungeon level */
  if (trf_has(trap->kind->flags, TRF_DOWN)) {
   int next = dungeon_get_next_level(player, player->depth, 1);
   dungeon_change_level(player, next);
   history_add(player, format("Fell through a %s", trap->kind->name),
      HIST_FELL_DOWN_LEVEL);
   return;
  }
  /* Some traps drop you onto them */
  if (trf_has(trap->kind->flags, TRF_PIT)) {
   monster_swap(player->grid, trap->grid);
   /*
			 * Don't retrigger the trap, but handle the
			 * other side effects of an involuntary move of the
			 * player.
			 */
   player_handle_post_move(player, false, true);
  }
  /* Some traps disappear after activating */
  if (trf_has(trap->kind->flags, TRF_ONETIME)) {
   square_destroy_trap(cave, grid);
   square_unmark(cave, grid);
  }
  /* Trap may have gone */
  if (!square_trap(cave, grid)) break;
  /* Trap becomes visible */
  trf_on(trap->flags, TRF_VISIBLE);
 }
 /* Update the player's view. */
 square_memorize_traps(cave, grid);
    if (square_isseen(cave, grid)) {
  square_light_spot(cave, grid);
    }
}
/**
 * ------------------------------------------------------------------------
 * Door locks and jams
 * ------------------------------------------------------------------------ */
/**
 * Lock a closed door to a given power
 */
void square_set_door_lock(struct chunk *c, struct loc grid, int power)
{
 struct trap_kind *lock = lookup_trap("door lock");
 struct trap *trap;
 /* Verify it's a closed door */
 if (!square_iscloseddoor(c, grid))
  return;
 /* If there's no lock there, add one */
 if (!square_trap_specific(c, grid, lock->tidx))
  place_trap(c, grid, lock->tidx, 0);
 /* Set the power (of all locks - there should be only one) */
 trap = square_trap(c, grid);
 while (trap) {
  if (trap->kind == lock)
   trap->power = power;
  trap = trap->next;
 }
}
/**
 * Return the power of the lock on a door
 */
int square_door_lock_power(struct chunk *c, struct loc grid)
{
 struct trap_kind *lock = lookup_trap("door lock");
 struct trap *trap;
 /* Verify it's a closed door */
 if (!square_iscloseddoor(c, grid))
  return 0;
 /* Is there a lock there? */
 if (!square_trap_specific(c, grid, lock->tidx))
  return 0;
 /* Get the power and return it */
 trap = square_trap(c, grid);
 while (trap) {
  if (trap->kind == lock)
   return trap->power;
  trap = trap->next;
 }
 return 0;
}
/**
 * Jam a closed door to a given power
 */
void square_set_door_jam(struct chunk *c, struct loc grid, int power)
{
 struct trap_kind *jam = lookup_trap("door jam");
 struct trap *trap;
 /* Verify it's a closed door */
 if (!square_iscloseddoor(c, grid))
  return;
 /* If there's no jam there, add one */
 if (!square_trap_specific(c, grid, jam->tidx))
  place_trap(c, grid, jam->tidx, 0);
 /* Set the power (of all jams - there should be only one) */
 trap = square_trap(c, grid);
 while (trap) {
  if (trap->kind == jam)
   trap->power = power;
  trap = trap->next;
 }
}
/**
 * Return the power of the jam on a door
 */
int square_door_jam_power(struct chunk *c, struct loc grid)
{
 struct trap_kind *jam = lookup_trap("door jam");
 struct trap *trap;
 /* Verify it's a closed door */
 if (!square_iscloseddoor(c, grid))
  return 0;
 /* Is there a jam there? */
 if (!square_trap_specific(c, grid, jam->tidx))
  return 0;
 /* Get the power and return it */
 trap = square_trap(c, grid);
 while (trap) {
  if (trap->kind == jam)
   return trap->power;
  trap = trap->next;
 }
 return 0;
}
/**
 * ------------------------------------------------------------------------
 * Forges
 * ------------------------------------------------------------------------ */
/**
 * Set a forge to a given number of uses
 */
void square_set_forge(struct chunk *c, struct loc grid, int uses)
{
 struct trap_kind *forge = lookup_trap("forge use");
 struct trap *trap;
 /* Verify it's a forge */
 if (!square_isforge(c, grid))
  return;
 /* If there's no "forge trap" there, add one */
 if (!square_trap_specific(c, grid, forge->tidx))
  place_trap(c, grid, forge->tidx, 0);
 /* Set the power (of all forges - there should be only one) */
 trap = square_trap(c, grid);
 while (trap) {
  if (trap->kind == forge)
   trap->power = uses;
  trap = trap->next;
 }
}
/**
 * Return the number of uses of a forge
 */
int square_forge_uses(struct chunk *c, struct loc grid)
{
 struct trap_kind *forge = lookup_trap("forge use");
 struct trap *trap;
 /* Verify it's a forge */
 if (!square_isforge(c, grid))
  return 0;
 /* Does it have any uses left? */
 if (!square_trap_specific(c, grid, forge->tidx))
  return 0;
 /* Get the power and return it */
 trap = square_trap(c, grid);
 while (trap) {
  if (trap->kind == forge)
   return trap->power;
  trap = trap->next;
 }
 return 0;
}
/**
 * \file tutorial.c
 * \brief Implement generation and management of tutorial levels.
 *
 * Copyright (c) 2022 Eric Branlund
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/*
 * Issues:
 * 1) While the tutorial notes can display a graphical tile for a feature,
 * monster, or object, that only works when the tile takes up one grid.  When
 * tiles take more than that either need to fall back to not displaying tiles,
 * have the text in a textblock flow around (by skipping lines) the tile, or
 * have the terminals and front-ends be able to display tiles scaled to
 * different sizes at the same time.
 * 2) There's no way to specify monster groups from tutorial.txt.
 * 3) Would be nice to be able to switch archetypes (i.e. the character
 * the player controls in the tutorial) when switching tutorial sections.
 *
 * NarSil-specific issues:
 * 1) The pit and spiked pit terrain types can't be included in a tutorial
 * section.
 */
typedef void (*place_thing_func)(struct chunk *c, struct loc grid,
 struct tutorial_section_sym_val *val);
static void tutorial_section_place_feature(struct chunk *c, struct loc grid,
 struct tutorial_section_sym_val *val);
static void tutorial_section_place_trap(struct chunk *c, struct loc grid,
 struct tutorial_section_sym_val *val);
static void tutorial_section_place_note(struct chunk *c, struct loc grid,
 struct tutorial_section_sym_val *val);
static void tutorial_section_place_trigger(struct chunk *c, struct loc grid,
 struct tutorial_section_sym_val *val);
static void tutorial_section_place_gate(struct chunk *c, struct loc grid,
 struct tutorial_section_sym_val *val);
static void tutorial_section_place_forge(struct chunk *c, struct loc grid,
 struct tutorial_section_sym_val *val);
static void tutorial_section_place_object(struct chunk *c, struct loc grid,
 struct tutorial_section_sym_val *val);
static void tutorial_section_place_monster(struct chunk *c, struct loc grid,
 struct tutorial_section_sym_val *val);
static void tutorial_section_place_custom_trap(struct chunk *c, struct loc grid,
 struct tutorial_section_sym_val *val);
static void tutorial_section_place_custom_door(struct chunk *c, struct loc grid,
 struct tutorial_section_sym_val *val);
void (*tutorial_textblock_show_hook)(textblock *tb, const char *header) = NULL;
void (*tutorial_textblock_append_command_phrase_hook)(textblock *tb,
 const char *command_name, bool capital, bool gerund) = NULL;
void (*tutorial_textblock_append_direction_phrase_hook)(textblock *tb,
 int dirnum, bool capital, bool gerund) = NULL;
void (*tutorial_textblock_append_direction_rose_hook)(textblock *tb);
void (*tutorial_textblock_append_feature_symbol_hook)(textblock *tb, int feat)
 = NULL;
void (*tutorial_textblock_append_monster_symbol_hook)(textblock *tb,
 const struct monster_race *race) = NULL;
void (*tutorial_textblock_append_object_symbol_hook)(textblock *tb,
 const struct object_kind *kind) = NULL;
static place_thing_func place_ftable[] = {
/**
 * \file list-tutorial-sym.h
 * \brief Symbols for tutorial section layouts
 *
 * Changing the second arguments will affect the parsing and interpretation of
 * the layout lines for tutorial sections in tutorial.txt.  Changing the
 * other arguments will have to match up with code changes in tutorial.c (and
 * tutorial.txt if adding or removing symbol types).  Any changes will require
 * recompiling tutorial.c and tutorial-init.c.
 *
 * The first argument is appended to SECTION_SYM_ to get the enumeration member.
 * The second argument is single code point UTF-8 string to use for a predefined
 * symbol.  Customizable symbols use NULL for it.
 * The third argument is the FEAT_ constant to use for a symbol that uses the
 * tutorial_section_place_feature() function.  Others use FEAT_NONE for it.
 * The fourth argument is the function name to call when setting up a grid
 * in the tutorial chunk.
 */
/* Placeholder for no value or error condition */
NULL,
/* Predefined symbols */
tutorial_section_place_note,
tutorial_section_place_feature,
tutorial_section_place_feature,
tutorial_section_place_feature,
tutorial_section_place_feature,
tutorial_section_place_feature,
tutorial_section_place_feature,
tutorial_section_place_feature,
tutorial_section_place_feature,
tutorial_section_place_trap,
/* Customizable symbols */
tutorial_section_place_note,
tutorial_section_place_trigger,
tutorial_section_place_gate,
tutorial_section_place_forge,
tutorial_section_place_object,
tutorial_section_place_monster,
tutorial_section_place_custom_trap,
tutorial_section_place_custom_door,

};
static struct object *create_tutorial_note(char *name)
{
 struct tutorial_dict_key_type dkey;
 struct tutorial_dict_val_type *dval;
 struct object *obj;
 dkey.name = name;
 dkey.comp = TUTORIAL_NOTE;
 dval = tutorial_dict_has(tutorial_parsed_data.d, &dkey);
 if (!dval) {
  msg("Tutorial has an unknown note, %s", name);
  return NULL;
 }
 obj = object_new();
 object_prep(obj, tutorial_parsed_data.note_kind, 0, RANDOMISE);
 obj->pval = dval->v.note.pval;
 obj->number = 1;
 return obj;
}
static void tutorial_section_place_feature(struct chunk *c, struct loc grid,
 struct tutorial_section_sym_val *val)
{
 assert(square_in_bounds_fully(c, grid));
 square_set_feat(c, grid, val->v.feat);
}
static void tutorial_section_place_trap(struct chunk *c, struct loc grid,
 struct tutorial_section_sym_val *val)
{
 assert(val->kind == SECTION_SYM_TRAP_RANDOM);
 assert(square_in_bounds_fully(c, grid));
 square_set_feat(c, grid, FEAT_FLOOR);
 square_add_trap(c, grid);
}
static void tutorial_section_place_note(struct chunk *c, struct loc grid,
 struct tutorial_section_sym_val *val)
{
 assert(val->kind == SECTION_SYM_NOTE || val->kind == SECTION_SYM_START);
 assert(square_in_bounds_fully(c, grid));
 square_set_feat(c, grid, FEAT_FLOOR);
 if (val->v.name) {
  struct object *obj = create_tutorial_note(val->v.name);
  if (obj) {
   bool dummy;
   obj->origin = ORIGIN_FLOOR;
   obj->origin_depth = convert_depth_to_origin(c->depth);
   if (floor_carry(c, grid, obj, &dummy)) {
    list_object(c, obj);
   } else {
    object_delete(c, NULL, &obj);
   }
  }
 }
}
static void tutorial_section_place_trigger(struct chunk *c, struct loc grid,
 struct tutorial_section_sym_val *val)
{
 struct tutorial_dict_key_type dkey;
 struct tutorial_dict_val_type *dval;
 assert(val->kind == SECTION_SYM_TRIGGER);
 assert(square_in_bounds_fully(c, grid));
 square_set_feat(c, grid, FEAT_FLOOR);
 dkey.name = val->v.name;
 dkey.comp = TUTORIAL_TRIGGER;
 dval = tutorial_dict_has(tutorial_parsed_data.d, &dkey);
 if (dval) {
  /* Add to the trigger and gate map. */
  assert(!tutorial_parsed_data.trigger_gate_map[grid.y][2 * grid.x]);
  tutorial_parsed_data.trigger_gate_map[grid.y][2 * grid.x] = dval;
 } else {
  msg("Tutorial has an unknown trigger, %s", val->v.name);
 }
}
static void tutorial_section_place_gate(struct chunk *c, struct loc grid,
 struct tutorial_section_sym_val *val)
{
 struct tutorial_dict_key_type dkey;
 struct tutorial_dict_val_type *dval;
 assert(val->kind == SECTION_SYM_GATE);
 assert(square_in_bounds_fully(c, grid));
 dkey.name = val->v.gate.dest;
 dkey.comp = TUTORIAL_SECTION;
 dval = tutorial_dict_has(tutorial_parsed_data.d, &dkey);
 if (dval) {
  /* Add to the trigger and gate map. */
  assert(!tutorial_parsed_data.trigger_gate_map[grid.y][2 * grid.x]);
  tutorial_parsed_data.trigger_gate_map[grid.y][2 * grid.x] = dval;
  square_set_feat(c, grid, val->v.gate.feat);
  if (val->v.gate.note) {
   dkey.name = val->v.gate.note;
   dkey.comp = TUTORIAL_NOTE;
   dval = tutorial_dict_has(tutorial_parsed_data.d,
    &dkey);
   if (dval) {
    assert(!tutorial_parsed_data.trigger_gate_map[grid.y][2 * grid.x + 1]);
    tutorial_parsed_data.trigger_gate_map[grid.y][2 * grid.x + 1] = dval;
   } else {
    msg("Tutorial has an unknown note, %s",
     val->v.gate.note);
   }
  }
 } else {
  square_set_feat(c, grid, FEAT_FLOOR);
  msg("Tutorial has a gate to an unknown section, %s",
   val->v.gate.dest);
 }
}
static void tutorial_section_place_forge(struct chunk *c, struct loc grid,
 struct tutorial_section_sym_val *val)
{
 assert(val->kind == SECTION_SYM_FORGE);
 assert(square_in_bounds_fully(c, grid));
 square_set_feat(c, grid, val->v.forge.feat);
 square_set_forge(c, grid, val->v.forge.uses);
}
static void tutorial_section_place_object(struct chunk *c, struct loc grid,
 struct tutorial_section_sym_val *val)
{
 struct object *obj;
 bool dummy;
 assert(val->kind == SECTION_SYM_ITEM);
 assert(square_in_bounds_fully(c, grid));
 square_set_feat(c, grid, FEAT_FLOOR);
 obj = (val->v.item.is_artifact) ?
  tutorial_create_artifact(val->v.item.v.art) :
  tutorial_create_object(&val->v.item);
 if (!obj) {
  return;
 }
 obj->origin = ORIGIN_FLOOR;
 obj->origin_depth = convert_depth_to_origin(c->depth);
 dummy = true;
 if (!floor_carry(c, grid, obj, &dummy)) {
  if (obj->artifact) {
   mark_artifact_created(obj->artifact, false);
  }
  object_delete(c, NULL, &obj);
  return;
 }
 list_object(c, obj);
}
static void tutorial_section_place_monster(struct chunk *c, struct loc grid,
 struct tutorial_section_sym_val *val)
{
 struct monster_group_info gi = { 0, 0 };
 struct monster *mon;
 assert(val->kind == SECTION_SYM_MONSTER);
 assert(square_in_bounds_fully(c, grid));
 square_set_feat(c, grid, FEAT_FLOOR);
 place_new_monster(c, grid, val->v.monster.race, false, false, gi,
  ORIGIN_DROP);
 mon = square_monster(c, grid);
 if (mon && val->v.monster.note) {
  struct object *obj = create_tutorial_note(val->v.monster.note);
  if (obj) {
   obj->origin = ORIGIN_DROP;
   obj->origin_depth = convert_depth_to_origin(c->depth);
   if (!monster_carry(c, mon, obj)) {
    object_free(obj);
   }
  }
 }
 if (mon) {
  int amount;
  if (val->v.monster.sleepiness_fixed) {
   amount = val->v.monster.sleepiness;
  } else {
   assert(val->v.monster.sleepiness > 0);
   amount = randint1(val->v.monster.sleepiness);
  }
  mon->alertness = MAX(ALERTNESS_MIN, MIN(ALERTNESS_MAX,
   ALERTNESS_ALERT - amount));
 }
}
static void tutorial_section_place_custom_trap(struct chunk *c, struct loc grid,
 struct tutorial_section_sym_val *val)
{
 assert(val->kind == SECTION_SYM_TRAP);
 assert(square_in_bounds_fully(c, grid));
 square_set_feat(c, grid, FEAT_FLOOR);
 place_trap(c, grid, val->v.trap.kind->tidx, c->depth);
 if (val->v.trap.vis) {
  square_reveal_trap(c, grid, false);
 }
}
static void tutorial_section_place_custom_door(struct chunk *c, struct loc grid,
 struct tutorial_section_sym_val *val)
{
 assert(val->kind == SECTION_SYM_DOOR);
 assert(square_in_bounds_fully(c, grid));
 square_set_feat(c, grid, val->v.door.feat);
 if (val->v.door.power > 0) {
  square_set_door_lock(c, grid, val->v.door.power);
 } else if (val->v.door.power < 0) {
  square_set_door_jam(c, grid, -val->v.door.power);
 }
}
static void append_with_case_sensitive_first(textblock *tb, const char *src,
  bool capital)
{
 if (isupper(src[0])) {
  if (capital) {
   textblock_append(tb, "%s", src);
  } else {
   textblock_append(tb, "%c%s", tolower(src[0]), src + 1);
  }
 } else if (capital) {
  textblock_append(tb, "%c%s", toupper(src[0]), src + 1);
 } else {
  textblock_append(tb, "%s", src);
 }
}
static textblock *tutorial_expand_message_from_string(const char *text,
  bool note)
{
 textblock *tb = textblock_new();
 if (!text || !text[0]) {
  if (note) {
   textblock_append(tb, "This note is blank.");
  }
  return tb;
 }
 if (note) {
  textblock_append(tb, "This note reads:\n");
 }
 while (1) {
  const char *lb;
  const char *rb;
  char *tmp;
  if (!text[0]) {
   /* Reached the end. */
   break;
  }
  /* Find an unescaped left brace; it introduces an expression. */
  lb = text;
  while (1) {
   lb = strchr(lb, '{');
   if (!lb || !tutorial_text_escaped(lb, text)) {
    break;
   }
   ++lb;
  }
  if (lb != text) {
   /*
			 * Add what was before the expression to the textblock.
			 * Do it in blocks of 512 characters to avoid
			 * internal buffer limits in z-form.c.
			 */
   size_t sz = (lb) ? (size_t)(lb - text) : strlen(text);
   size_t buf_sz = 512;
   tmp = mem_alloc(buf_sz);
   while (sz) {
    size_t read = tutorial_copy_strip_escapes(
     tmp, (sz < buf_sz) ? sz + 1: buf_sz,
     text, sz);
    assert(read <= sz);
    sz -= read;
    text += read;
    textblock_append(tb, "%s", tmp);
   }
   mem_free(tmp);
   /* There was no more directives; everything's done. */
   if (!lb) {
    break;
   }
  }
  text = lb + 1;
  /*
		 * Find an unescaped right brace; it terminates the expression.
		 */
  rb = text;
  while (1) {
   rb = strchr(rb, '}');
   if (!rb || !tutorial_text_escaped(rb, text)) {
    break;
   }
   ++rb;
  }
  /*
		 * Expand expression.  Drop unterminated or unrecognized ones.
		 */
  if (!rb) {
   break;
  }
  text = lb + 1;
  if (prefix(text, "command:")
    || prefix(text, "Command:")
    || prefix(text, "commanding:")
    || prefix(text, "Commanding:")) {
   bool capital = (text[0] == 'C');
   bool gerund;
   text = strchr(text, ':') + 1;
   gerund = (text[-2] == 'g');
   tmp = mem_alloc((rb - text) + 1);
   (void) tutorial_copy_strip_escapes(tmp,
    (rb - text) + 1, text, rb - text);
   tutorial_textblock_append_command_phrase(tb,
    tmp, capital, gerund);
   mem_free(tmp);
  } else if (prefix(text, "direction:")
    || prefix(text, "Direction:")
    || prefix(text, "directioning:")
    || prefix(text, "Directioning:")) {
   bool capital = (text[0] == 'D');
   bool gerund;
   int dir;
   text = strchr(text, ':') + 1;
   gerund = (text[-2] == 'g');
   if (prefix(text, "north}")) {
    assert(text + 5 == rb);
    dir = 8;
   } else if (prefix(text, "northeast}")) {
    assert(text + 9 == rb);
    dir = 9;
   } else if (prefix(text, "east}")) {
    assert(text + 4 == rb);
    dir = 6;
   } else if (prefix(text, "southeast}")) {
    assert(text + 9 == rb);
    dir = 3;
   } else if (prefix(text, "south}")) {
    assert(text + 5 == rb);
    dir = 2;
   } else if (prefix(text, "southwest}")) {
    assert(text + 9 == rb);
    dir = 1;
   } else if (prefix(text, "west}")) {
    assert(text + 4 == rb);
    dir = 4;
   } else if (prefix(text, "northwest}")) {
    assert(text + 9 == rb);
    dir = 7;
   } else if (prefix(text, "stay}")) {
    assert(text + 4 == rb);
    dir = 5;
   } else {
    dir = -1;
   }
   if (dir > 0) {
    tutorial_textblock_append_direction_phrase(
     tb, dir, capital, gerund);
   }
  } else if (prefix(text, "direction-rose}")) {
   assert(text + 14 == rb);
   tutorial_textblock_append_direction_rose(tb);
  } else if (prefix(text, "feature:")) {
   int feat;
   text += 8;
   tmp = mem_alloc((rb - text) + 1);
   (void) tutorial_copy_strip_escapes(tmp,
    (rb - text) + 1, text, rb - text);
   feat = lookup_feat(tmp);
   mem_free(tmp);
   if (feat >= 0) {
    tutorial_textblock_append_feature_symbol(tb,
     feat);
   }
  } else if (prefix(text, "house}") || prefix(text, "House}")) {
   assert(text + 5 == rb);
   append_with_case_sensitive_first(tb,
    player->house->name, (text[0] == 'H'));
  } else if (prefix(text, "monster:")) {
   struct monster_race *race;
   text += 8;
   tmp = mem_alloc((rb - text) + 1);
   (void) tutorial_copy_strip_escapes(tmp,
    (rb - text) + 1, text, rb - text);
   race = lookup_monster(tmp);
   mem_free(tmp);
   if (race) {
    tutorial_textblock_append_monster_symbol(tb,
     race);
   }
  } else if (prefix(text, "name}")) {
   assert(text + 4 == rb);
   textblock_append(tb, "%s", player->full_name);
  } else if (prefix(text, "object:")) {
   int tval = -1;
   int sval = -1;
   const char *colon;
   text += 7;
   /* Find unescaped colon. */
   colon = text;
   while (1) {
    colon = strchr(colon, ':');
    if (!colon || !tutorial_text_escaped(colon, text)) {
     break;
    }
    ++colon;
   }
   if (colon) {
    tmp = mem_alloc((colon - text) + 1);
    (void) tutorial_copy_strip_escapes(tmp,
     (colon - text) + 1, text, colon - text);
    tval = tval_find_idx(tmp);
    mem_free(tmp);
    text = colon + 1;
   }
   if (colon && tval >= 0) {
    tmp = mem_alloc((rb - text) + 1);
    (void) tutorial_copy_strip_escapes(tmp,
     (rb - text) + 1, text, rb - text);
    if (streq(tmp, "*")) {
     sval = 1;
    } else {
     sval = lookup_sval(tval, tmp);
    }
    mem_free(tmp);
   }
   if (tval >= 0 && sval >= 0) {
    struct object_kind *kind =
     lookup_kind(tval, sval);
    if (kind) {
     tutorial_textblock_append_object_symbol(
      tb, kind);
    }
   }
  } else if (prefix(text, "paragraphbreak}")) {
   assert(text + 14 == rb);
   textblock_append(tb, "\n\n");
  } else if (prefix(text, "race}") || prefix(text, "Race}")) {
   assert(text + 4 == rb);
   append_with_case_sensitive_first(tb,
    player->race->name, (text[0] == 'R'));
  }
  text = rb + 1;
 }
 return tb;
}
static void tutorial_handle_player_move(game_event_type t, game_event_data *d,
  void *u)
{
 struct tutorial_dict_val_type *entry;
 const struct object *obj;
 assert(t == EVENT_PLAYERMOVED || t == EVENT_NEW_LEVEL_DISPLAY);
 /* Check for a trigger.  The map should always be available. */
 assert(tutorial_parsed_data.trigger_gate_map);
 assert(cave && player && player->grid.x >= 0 && player->grid.y >= 0
  && player->grid.x < cave->width
  && player->grid.y < cave->height);
 entry = tutorial_parsed_data.trigger_gate_map[player->grid.y][
  2 * player->grid.x];
 if (entry && entry->key->comp == TUTORIAL_TRIGGER
   && entry->v.trigger.expr.n_stack > 0
   && (entry->v.trigger.text
   || entry->v.trigger.changes_death_note)) {
  bool *estack = mem_alloc(entry->v.trigger.expr.n_stack
   * sizeof(*estack));
  int next = 0, iop;
  bool triggered;
  for (iop = 0; iop < entry->v.trigger.expr.n_op; ++iop) {
   const struct trigger_compiled_op *op =
     entry->v.trigger.expr.ops + iop;
   struct ability *ability;
   switch (op->kind) {
   case TRIGGER_OP_NOT:
    assert(next > 0);
    estack[next - 1] = !estack[next - 1];
    break;
   case TRIGGER_OP_AND:
    assert(next > 1);
    estack[next - 2] = estack[next - 2]
     && estack[next - 1];
    --next;
    break;
   case TRIGGER_OP_OR:
    assert(next > 1);
    estack[next - 2] = estack[next - 2]
     || estack[next - 1];
    --next;
    break;
   case TRIGGER_OP_XOR:
    assert(next > 1);
    if (estack[next - 2]) {
     estack[next - 2] = !estack[next - 1];
    } else if (estack[next - 1]) {
     estack[next - 2] = true;
    } else {
     estack[next - 2] = false;
    }
    --next;
    break;
   case TRIGGER_OP_ABILITY:
    assert(next < entry->v.trigger.expr.n_stack);
    ability = lookup_ability(op->idx, op->name);
    estack[next] =
     player_has_ability(player, ability);
    ++next;
    break;
   case TRIGGER_OP_CARRIED:
    assert(next < entry->v.trigger.expr.n_stack);
    obj = player->gear;
    while (1) {
     if (!obj) {
      estack[next] = false;
      break;
     }
     if (obj->kind && obj->kind->tval
       == op->tval
       && (op->sval == -1
       || obj->kind->sval
       == op->sval)) {
      estack[next] = true;
      break;
     }
     obj = obj->next;
    }
    ++next;
    break;
   case TRIGGER_OP_DRAINED:
    assert(next < entry->v.trigger.expr.n_stack);
    if (op->idx >= 0 && op->idx < STAT_MAX) {
     estack[next] =
      player->stat_drain[op->idx] < 0;
    } else if (op->idx == STAT_MAX) {
     estack[next] = player->chp
      < player->mhp;
    } else if (op->idx == STAT_MAX + 1) {
     estack[next] = player->csp
      < player->msp;
    } else {
     quit("Unexpected drained criteria for tutorial trigger");
    }
    ++next;
    break;
   case TRIGGER_OP_EQUIPPED:
    assert(next < entry->v.trigger.expr.n_stack);
    obj = player->gear;
    while (1) {
     if (!obj) {
      estack[next] = false;
      break;
     }
     if (obj->kind && obj->kind->tval
       == op->tval
       && (op->sval == -1
       || obj->kind->sval
       == op->sval)
       && object_is_equipped(player->body, obj)) {
      estack[next] = true;
      break;
     }
     obj = obj->next;
    }
    ++next;
    break;
   case TRIGGER_OP_FALSE:
    assert(next < entry->v.trigger.expr.n_stack);
    estack[next] = false;
    ++next;
    break;
   case TRIGGER_OP_TIMED:
    assert(next < entry->v.trigger.expr.n_stack);
    assert(op->idx >= 0 && op->idx < TMD_MAX);
    estack[next] = player->timed[op->idx];
    ++next;
    break;
   case TRIGGER_OP_TIMED_ABOVE:
    assert(next < entry->v.trigger.expr.n_stack);
    assert(op->idx >= 0 && op->idx < TMD_MAX);
    estack[next] = player_timed_grade_gt(player,
     op->idx, op->name);
    ++next;
    break;
   case TRIGGER_OP_TIMED_BELOW:
    assert(next < entry->v.trigger.expr.n_stack);
    assert(op->idx >= 0 && op->idx < TMD_MAX);
    estack[next] = player_timed_grade_lt(player,
     op->idx, op->name);
    ++next;
    break;
   case TRIGGER_OP_TRUE:
    assert(next < entry->v.trigger.expr.n_stack);
    estack[next] = true;
    ++next;
    break;
   default:
    quit("Unexpected trigger operation in tutorial");
    break;
   }
  }
  assert(next == 1);
  triggered = estack[0];
  mem_free(estack);
  if (triggered) {
   if (entry->v.trigger.text) {
    textblock *text =
     tutorial_expand_message_from_string(
     entry->v.trigger.text, false);
    tutorial_textblock_show(text, NULL);
    textblock_free(text);
   }
   if (entry->v.trigger.changes_death_note) {
    tutorial_parsed_data.curr_death_note =
     entry->v.trigger.death_note_name;
   }
  }
 }
 /* Check for a tutorial note in the current grid. */
 obj = square_object(cave, player->grid);
 while (obj) {
  if (obj->kind == tutorial_parsed_data.note_kind) {
   textblock *text = tutorial_expand_message(obj->pval);
   tutorial_textblock_show(text, NULL);
   textblock_free(text);
  }
  obj = obj->next;
 }
}
static void tutorial_leave_section_helper(struct tutorial_dict_val_type **dest,
  struct tutorial_dict_val_type **note, const struct player *p)
{
 if (p->grid.x < 0 || p->grid.y < 0 || !cave || p->grid.x >= cave->width
   || p->grid.y >= cave->height) {
  quit("Logic error:  player coordinates are invalid when "
   "leaving a tutorial section.");
 }
 if (!tutorial_parsed_data.trigger_gate_map) {
  quit("Logic error:  there's no trigger/gate map when leaving "
   "a tutorial section.");
 }
 *dest = tutorial_parsed_data.trigger_gate_map[p->grid.y][
  2 * p->grid.x];
 if (!*dest || (*dest)->key->comp != TUTORIAL_SECTION) {
  quit("Logic error:  the trigger/gate map entry is invalid "
   "when leaving a tutorial section.");
 }
 *note = tutorial_parsed_data.trigger_gate_map[p->grid.y][
  2 * p->grid.x + 1];
}
/**
 * Test for whether a tutorial is in progress.
 */
bool in_tutorial(void)
{
 return player && player->game_type < 0;
}
/**
 * Generate the given tutorial section and place the player in it.
 *
 * \param name is the name of the tutorial section to generate or NULL for
 * the default tutorial section.
 * \param p is the current player struct, in practice the global player
 *
 * Acts much like prepare_next_level() does in normal gameplay.
 */
void tutorial_prepare_section(const char *name, struct player *p)
{
 struct tutorial_dict_val_type *section;
 struct loc grid;
 int i;
 /* Deal with the previous tutorial section. */
 if (character_dungeon) {
  if (p->cave) {
   assert(cave);
   /* Deal with artifacts. */
   for (grid.y = 0; grid.y < cave->height; ++grid.y) {
    for (grid.x = 0; grid.x < cave->width; ++grid.x) {
     struct object *obj;
     for (obj = square_object(cave, grid);
       obj; obj = obj->next) {
      if (!obj->artifact || !object_is_known_artifact(obj)) continue;
      history_lose_artifact(p, obj->artifact);
      mark_artifact_created(
       obj->artifact, true);
     }
    }
   }
   cave_free(p->cave);
   p->cave = NULL;
  }
  /* Mimic cave_clear() in generate.c. */
  p->smithing_leftover = 0;
  p->upkeep->knocked_back = false;
  wipe_mon_list(cave, p);
  forget_fire(cave);
  cave_free(cave);
 }
 /* Generate the tutorial section. */
 character_dungeon = false;
 if (name) {
  struct tutorial_dict_key_type key = {
   string_make(name), TUTORIAL_SECTION
  };
  section = tutorial_dict_has(tutorial_parsed_data.d, &key);
  string_free(key.name);
  if (!section) {
   quit_fmt("There's no tutorial section named, %s.",
    name);
  }
 } else {
  section = tutorial_parsed_data.default_section;
  if (!section) {
   quit("No default tutorial section was defined");
  }
 }
 /*
	 * Give the player a non-zero depth so the rest of the game doesn't
	 * think the player's in town.
	 */
 p->depth = 1;
 assert(section->v.section.rows > 0
  && section->v.section.rows < z_info->dungeon_hgt - 1
  && section->v.section.columns > 0
  && section->v.section.columns < z_info->dungeon_wid - 1);
 /* Set up an auxiliary map to lookup triggers and gates. */
 tutorial_cleanup_trigger_gate_map(
  tutorial_parsed_data.trigger_gate_map);
 /* There's one extra row as a NULL sentinel. */
 tutorial_parsed_data.trigger_gate_map = mem_alloc(
  (section->v.section.rows + 3)
  * sizeof(*tutorial_parsed_data.trigger_gate_map));
 for (i = 0; i < section->v.section.rows + 2; ++i) {
  /*
		 * Store two pointers per grid:  one for the gate or trigger
		 * and one for a gate's note if it has one.
		 */
  tutorial_parsed_data.trigger_gate_map[i] =
   mem_zalloc(2 * (size_t) (section->v.section.columns + 2)
    * sizeof(**tutorial_parsed_data.trigger_gate_map));
 }
 tutorial_parsed_data.trigger_gate_map[section->v.section.rows + 2] =
  NULL;
 /* Remember the death note for this section. */
 tutorial_parsed_data.curr_death_note =
  section->v.section.death_note_name;
 /* Set up the authoritative version of the cave. */
 cave = cave_new(section->v.section.rows + 2,
  section->v.section.columns + 2);
 cave->depth = p->depth;
 cave->turn = turn;
 /* Encase in permanent rock. */
 grid.y = 0;
 for (grid.x = 0; grid.x < cave->width; ++grid.x) {
  square_set_feat(cave, grid, FEAT_PERM);
 }
 for (grid.y = 1; grid.y < cave->height - 1; ++grid.y) {
  char *sym = section->v.section.lines[grid.y - 1];
  grid.x = 0;
  square_set_feat(cave, grid, FEAT_PERM);
  for (grid.x = 1; grid.x < cave->width - 1; ++grid.x) {
   /* Fill in the customized contents. */
   char *next_sym = utf8_fskip(sym, 1, NULL);
   struct tutorial_section_sym_key key;
   struct tutorial_section_sym_val *val;
   if (next_sym) {
    assert((size_t) (next_sym - sym)
     < sizeof(key.symbol));
    strnfmt(key.symbol, sizeof(key.symbol),
     "%.*s", (int) (next_sym - sym), sym);
   } else {
    assert(grid.x == cave->width - 2);
    my_strcpy(key.symbol, sym, sizeof(key.symbol));
   }
   key.x = grid.x - 1;
   key.y = grid.y - 1;
   val = tutorial_section_sym_table_has(
    section->v.section.symt, &key);
   if (!val) {
    key.x = -1;
    key.y = -1;
    val = tutorial_section_sym_table_has(
     section->v.section.symt, &key);
    assert(val);
   }
   (*place_ftable[val->kind])(cave, grid, val);
   if (val->kind == SECTION_SYM_START) {
    player_place(cave, p, grid);
   }
   sym = next_sym;
  }
  grid.x = cave->width - 1;
  square_set_feat(cave, grid, FEAT_PERM);
 }
 grid.y = cave->height - 1;
 for (grid.x = 0; grid.x < cave->width; ++grid.x) {
  square_set_feat(cave, grid, FEAT_PERM);
 }
 /* Apply the square flags. */
 for (i = 0; i < section->v.section.area_flag_count; ++i) {
  const struct tutorial_area_flag *flag =
   section->v.section.area_flags + i;
  int yst = MAX(0, flag->ul.y + 1);
  int ylim = MIN(cave->height - 1, flag->lr.y + 1);
  int xst = MAX(0, flag->ul.x + 1);
  int xlim = MIN(cave->width - 1, flag->lr.x + 1);
  if (flag->clear) {
   for (grid.y = yst; grid.y <= ylim; ++grid.y) {
    for (grid.x = xst; grid.x <= xlim; ++grid.x) {
     sqinfo_diff(square(cave, grid)->info,
      flag->flags);
    }
   }
  } else {
   for (grid.y = yst; grid.y <= ylim; ++grid.y) {
    for (grid.x = xst; grid.x <= xlim; ++grid.x) {
     sqinfo_union(square(cave, grid)->info,
      flag->flags);
    }
   }
  }
 }
 /* Set up the player's version of the cave. */
 p->cave = cave_new(cave->height, cave->width);
 p->cave->depth = cave->depth;
 p->cave->objects = mem_realloc(p->cave->objects,
  (cave->obj_max + 1) * sizeof(struct object*));
 p->cave->obj_max = cave->obj_max;
 for (i = 0; i <= p->cave->obj_max; ++i) {
  p->cave->objects[i] = NULL;
 }
 /* It's ready to go. */
 character_dungeon = true;
}
void tutorial_leave_section(struct player *p)
{
 struct tutorial_dict_val_type *dest = NULL;
 struct tutorial_dict_val_type *note = NULL;
 tutorial_leave_section_helper(&dest, &note, p);
 if (note) {
  textblock *text;
  assert(note->key->comp == TUTORIAL_NOTE);
  if (note->v.note.text) {
   text = tutorial_expand_message_from_string(
    note->v.note.text, false);
   event_signal_poem_textblock(EVENT_POEM, text, 5, 10);
   textblock_free(text);
  }
 }
 if (dest->key->name && streq(dest->key->name, "EXIT")) {
  p->upkeep->playing = false;
 }
}
const char *tutorial_get_next_section(const struct player *p)
{
 struct tutorial_dict_val_type *dest = NULL;
 struct tutorial_dict_val_type *note = NULL;
 tutorial_leave_section_helper(&dest, &note, p);
 return dest->key->name;
}
/**
 * Expand the message for a tutorial note with the given pval.
 *
 * \param pval is the pval for the note.
 * \return a textblock with the expanded message.  The textblock should be
 * released with textblock_free() when no longer needed.
 */
textblock *tutorial_expand_message(int pval)
{
 struct tutorial_dict_val_type *note;
 if (pval < 0 || pval >= tutorial_parsed_data.note_table_n) {
  quit_fmt("A tutorial note had an invalid pval, %d.", pval);
 }
 if (!tutorial_parsed_data.pval_to_note_table) {
  quit("Logic error:  missing tutorial note lookup table");
 }
 note = tutorial_parsed_data.pval_to_note_table[pval];
 if (!note) {
  quit_fmt("Logic error:  have a gap in the note lookup table");
 }
 assert(note->key->comp == TUTORIAL_NOTE && note->v.note.pval == pval);
 return tutorial_expand_message_from_string(note->v.note.text, true);
}
/**
 * Display a textblock, let the player interact with it, and then return when
 * done.
 *
 * \param tb is the block of text to display.
 * \param header is, if not NULL, the text to always display above the text
 * block.
 */
void tutorial_textblock_show(textblock *tb, const char *header)
{
 /* Defer the implementation to the UI. */
 if (tutorial_textblock_show_hook) {
  (*tutorial_textblock_show_hook)(tb, header);
 }
}
/**
 * Display the configured message when a player dies in the tutorial.
 *
 * \param p is the player that died.
 */
void tutorial_display_death_note(const struct player *p)
{
 if (tutorial_parsed_data.curr_death_note) {
  struct tutorial_dict_key_type dkey;
  struct tutorial_dict_val_type *dval;
  dkey.name = tutorial_parsed_data.curr_death_note;
  dkey.comp = TUTORIAL_NOTE;
  dval = tutorial_dict_has(tutorial_parsed_data.d, &dkey);
  if (dval) {
   textblock *text;
   assert(dval->key->comp == TUTORIAL_NOTE);
   text = tutorial_expand_message_from_string(
    dval->v.note.text, false);
   event_signal_poem_textblock(EVENT_POEM, text, 5, 10);
   textblock_free(text);
  } else {
   msg("Tutorial has an unknown note, %s",
    dkey.name);
  }
 }
}
/**
 * Append a phrase describing how to invoke a command to a textblock.
 *
 * \param tb is the textblock to modify.
 * \param command_name is the name of the command to describe.
 * \param capital sets whether to begin the phrase with an uppercase or
 * lowercase letter.  If true, the phrase will begin with an uppercase letter.
 * \param gerund sets whether or not to use a gerund phrase.
 */
void tutorial_textblock_append_command_phrase(textblock *tb,
  const char *command_name, bool capital, bool gerund)
{
 /* Defer the implementation to the UI. */
 if (tutorial_textblock_append_command_phrase_hook) {
  (*tutorial_textblock_append_command_phrase_hook)(tb,
   command_name, capital, gerund);
 }
}
/**
 * Append a phrase describing how to move in given direction to a textblock.
 *
 * \param tb is the textblock to modify.
 * \param dirnum is the number (as in the aiming direction number) of the
 * direction.
 * \param capital sets whether to begin the phrase with an uppercase or
 * lowercase letter.  If true, the phrase will begin with an uppercase letter.
 * \param gerund sets whether or not to use a gerund phrase.
 */
void tutorial_textblock_append_direction_phrase(textblock *tb, int dirnum,
  bool capital, bool gerund)
{
 /* Defer the implementation to the UI. */
 if (tutorial_textblock_append_direction_phrase_hook) {
  (*tutorial_textblock_append_direction_phrase_hook)(tb,
   dirnum, capital, gerund);
 }
}
/**
 * Append a description of how to move in any direction to a textblock.
 *
 * \param tb is the textblock to modify.
 */
void tutorial_textblock_append_direction_rose(textblock *tb)
{
 /* Defer the implementation to the UI. */
 if (tutorial_textblock_append_direction_rose_hook) {
  (*tutorial_textblock_append_direction_rose_hook)(tb);
 }
}
/**
 * Append the symbol for a dungeon feature to a textblock.
 *
 * \param tb is the textblock to modify.
 * \param feat is the feature index for the terrain.
 */
void tutorial_textblock_append_feature_symbol(textblock *tb, int feat)
{
 /* Defer the implementation to the UI. */
 if (tutorial_textblock_append_feature_symbol_hook) {
  (*tutorial_textblock_append_feature_symbol_hook)(tb, feat);
 }
}
/**
 * Append the symbol for a monster to a textblock.
 *
 * \param tb is the textblock to modify.
 * \param race is the race of the monster.
 */
void tutorial_textblock_append_monster_symbol(textblock *tb,
  const struct monster_race *race)
{
 /* Defer the implementation to the UI. */
 if (tutorial_textblock_append_monster_symbol_hook) {
  (*tutorial_textblock_append_monster_symbol_hook)(tb, race);
 }
}
/**
 * Append the symbol for an object to a textblock.
 *
 * \param tb is the textblock to modify.
 * \param kind is the kind of object to describe.
 */
void tutorial_textblock_append_object_symbol(textblock *tb,
  const struct object_kind *kind)
{
 /* Defer the implementation to the UI. */
 if (tutorial_textblock_append_object_symbol_hook) {
  (*tutorial_textblock_append_object_symbol_hook)(tb, kind);
 }
}
struct object *tutorial_create_artifact(const struct artifact *art)
{
 struct object_kind *kind;
 struct object *obj;
 if (!art->name || is_artifact_created(art)) return NULL;
 kind = lookup_kind(art->tval, art->sval);
 if (!kind) return NULL;
 obj = object_new();
 object_prep(obj, kind, art->level, RANDOMISE);
 obj->artifact = art;
 copy_artifact_data(obj, art);
 mark_artifact_created(art, true);
 return obj;
}
struct object *tutorial_create_object(const struct tutorial_item *item)
{
 struct object_kind *kind = lookup_kind(item->v.details.tval,
  item->v.details.sval);
 int n = randcalc(item->v.details.number, 0, RANDOMISE);
 struct object *obj;
 int j;
 assert(kind);
 n = MIN(n, kind->base->max_stack);
 if (n <= 0) {
  return NULL;
 }
 obj = object_new();
 object_prep(obj, kind, 0, RANDOMISE);
 if (item->v.details.ego) {
  obj->ego = item->v.details.ego;
  ego_apply_magic(obj, 0);
 }
 obj->number = n;
 for (j = 0; j < item->v.details.tweak_count; ++j) {
  const struct tutorial_item_tweak *tweak =
   item->v.details.tweaks + j;
  dice_t *dice;
  switch (tweak->kind) {
  case TWEAK_FLAG:
   of_on(obj->flags, tweak->idx);
   break;
  case TWEAK_SLAY:
   assert(tweak->idx >= 0
    && tweak->idx < z_info->slay_max);
   if (!obj->slays) {
    obj->slays = mem_zalloc(z_info->slay_max
     * sizeof(bool));
   }
   obj->slays[tweak->idx] = true;
   break;
  case TWEAK_BRAND:
   assert(tweak->idx >= 0
    && tweak->idx < z_info->brand_max);
   if (!obj->brands) {
    obj->brands = mem_zalloc(z_info->brand_max
     * sizeof(bool));
   }
   obj->brands[tweak->idx] = true;
   break;
  case TWEAK_ELEM_IGNORE:
   assert(tweak->idx >= 0 && tweak->idx < ELEM_MAX);
   obj->el_info[tweak->idx].flags |= EL_INFO_IGNORE;
   break;
  case TWEAK_ELEM_HATE:
   assert(tweak->idx >= 0 && tweak->idx < ELEM_MAX);
   obj->el_info[tweak->idx].flags |= EL_INFO_HATES;
   break;
  case TWEAK_MODIFIER:
   assert(tweak->idx >= 0 && tweak->idx < OBJ_MOD_MAX);
   obj->modifiers[tweak->idx] =
    randcalc(tweak->value, 0, RANDOMISE);
   break;
  case TWEAK_ELEM_RESIST:
   assert(tweak->idx >= 0 && tweak->idx < ELEM_MAX);
   obj->el_info[tweak->idx].res_level =
    randcalc(tweak->value, 0, RANDOMISE);
   break;
  case TWEAK_PVAL:
   dice = dice_new();
   if (dice_parse_string(dice, tweak->dice)) {
    expression_t *expr = expression_new();
    expression_set_fixed_base(expr, obj->number);
    dice_bind_expression(dice, "N", expr);
    obj->pval = dice_roll(dice, NULL);
   }
   dice_free(dice);
   break;
  }
 }
 return obj;
}
void tutorial_handle_enter_world(game_event_type t, game_event_data *d,
  void *u)
{
 assert(t == EVENT_ENTER_WORLD);
 event_add_handler(EVENT_PLAYERMOVED, tutorial_handle_player_move, NULL);
 event_add_handler(EVENT_NEW_LEVEL_DISPLAY,
  tutorial_handle_player_move, NULL);
}
void tutorial_handle_leave_world(game_event_type t, game_event_data *d,
  void *u)
{
 assert(t == EVENT_LEAVE_WORLD);
 event_remove_handler(EVENT_PLAYERMOVED, tutorial_handle_player_move,
  NULL);
 event_remove_handler(EVENT_NEW_LEVEL_DISPLAY,
  tutorial_handle_player_move, NULL);
}
/**
 * \file tutorial-init.c
 * \brief Implement parsing of the tutorial data.
 *
 * Copyright (c) 2022 Eric Branlund
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
static bool tutorial_section_sym_table_insert(
 struct tutorial_section_sym_table t,
 struct tutorial_section_sym_key *key,
 struct tutorial_section_sym_val *value);
static errr tutorial_run_parser(struct parser *p);
struct init_module tutorial_module = {
 "tutorial", NULL, tutorial_cleanup_parsed_data
};
struct tutorial_parsed_result tutorial_parsed_data = {
 { NULL }, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0
};
static struct file_parser tutorial_parser = {
 "tutorial",
 tutorial_init_parser,
 tutorial_run_parser,
 tutorial_finish_parser,
 tutorial_cleanup_parsed_data
};
static const char *square_flag_names[] = {
/**
 * \file list-square-flags.h
 * \brief special grid flags
 *
 * Adding flags to the end will not break savefiles (the added flags will be
 * read but not used when a savefile is loaded into an older version);
 * inserting into, deleting, or rearranging the existing flags will break
 * savefiles.  Flags below start from 1 on line 14, so a flag's sequence
 * number is its line number minus 13.
 */
/*  symbol          descr */
"NONE",
"MARK",
"GLOW",
"VAULT",
"G_VAULT",
"ROOM",
"SEEN",
"VIEW",
"WASSEEN",
"FEEL",
"TRAP",
"INVIS",
"WALL_INNER",
"WALL_OUTER",
"WALL_SOLID",
"CHASM",
"PROJECT",
"HIDDEN",
"TEMP",
"WALL",
"FIRE",
"CLOSE_PLAYER",
"OLD_VIEW",
"OLD_LIT",
"OLD_TORCH",

 NULL
};
static void tutorial_item_tweaks_free(struct tutorial_item_tweak *tweaks,
  int count)
{
 int i;
 for (i = 0; i < count; ++i) {
  string_free(tweaks[i].dice);
 }
 mem_free(tweaks);
}
static uint32_t tutorial_section_sym_key_hash(const void *key)
{
 const struct tutorial_section_sym_key *sk =
  (const struct tutorial_section_sym_key*) key;
 char buf[32];
 (void) strnfmt(buf, sizeof(buf), "%d,%d,%s", sk->x, sk->y, sk->symbol);
 return djb2_hash(buf);
}
static int tutorial_section_sym_key_compare(const void *a, const void *b)
{
 const struct tutorial_section_sym_key *ska =
  (const struct tutorial_section_sym_key*) a;
 const struct tutorial_section_sym_key *skb =
  (const struct tutorial_section_sym_key*) b;
 return (streq(ska->symbol, skb->symbol) && ska->x == skb->x
  && ska->y == skb->y) ? 0 : 1;
}
static void tutorial_section_sym_value_free(void *value)
{
 struct tutorial_section_sym_val *tv =
  (struct tutorial_section_sym_val*) value;
 switch (tv->kind) {
 case SECTION_SYM_GATE:
  string_free(tv->v.gate.dest);
  string_free(tv->v.gate.note);
  break;
 case SECTION_SYM_ITEM:
  if (!tv->v.item.is_artifact) {
   tutorial_item_tweaks_free(tv->v.item.v.details.tweaks,
    tv->v.item.v.details.tweak_count);
  }
  break;
 case SECTION_SYM_MONSTER:
  string_free(tv->v.monster.note);
  break;
 case SECTION_SYM_NOTE:
 case SECTION_SYM_START:
 case SECTION_SYM_TRIGGER:
  string_free(tv->v.name);
  break;
 default:
  /* There's nothing special to do. */
  break;
 }
 mem_free(tv);
}
/**
 * Create the dictionary for a tutorial section's symbols.  This is a thin
 * layer of type checking over the generic dictionary type.
 */
static struct tutorial_section_sym_table tutorial_section_sym_table_create(void)
{
 struct tutorial_section_sym_table result;
 struct {
  enum tutorial_section_sym_kind kind;
  const char *sym;
  int feat_idx;
 } symbol_kinds[] = {
/**
 * \file list-tutorial-sym.h
 * \brief Symbols for tutorial section layouts
 *
 * Changing the second arguments will affect the parsing and interpretation of
 * the layout lines for tutorial sections in tutorial.txt.  Changing the
 * other arguments will have to match up with code changes in tutorial.c (and
 * tutorial.txt if adding or removing symbol types).  Any changes will require
 * recompiling tutorial.c and tutorial-init.c.
 *
 * The first argument is appended to SECTION_SYM_ to get the enumeration member.
 * The second argument is single code point UTF-8 string to use for a predefined
 * symbol.  Customizable symbols use NULL for it.
 * The third argument is the FEAT_ constant to use for a symbol that uses the
 * tutorial_section_place_feature() function.  Others use FEAT_NONE for it.
 * The fourth argument is the function name to call when setting up a grid
 * in the tutorial chunk.
 */
/* Placeholder for no value or error condition */
{ SECTION_SYM_DUMMY, NULL, FEAT_NONE },
/* Predefined symbols */
{ SECTION_SYM_START, "0", FEAT_NONE },
{ SECTION_SYM_FLOOR, ".", FEAT_FLOOR },
{ SECTION_SYM_GRANITE0, "#", FEAT_GRANITE },
{ SECTION_SYM_GRANITE1, " ", FEAT_GRANITE },
{ SECTION_SYM_PERMROCK, "@", FEAT_PERM },
{ SECTION_SYM_IMPASS_RUBBLE, ":", FEAT_RUBBLE },
{ SECTION_SYM_CLOSED_DOOR, "+", FEAT_CLOSED },
{ SECTION_SYM_OPEN_DOOR, ",", FEAT_OPEN },
{ SECTION_SYM_SECRET_DOOR, "s", FEAT_SECRET },
{ SECTION_SYM_TRAP_RANDOM, "^", FEAT_NONE },
/* Customizable symbols */
{ SECTION_SYM_NOTE, NULL, FEAT_NONE },
{ SECTION_SYM_TRIGGER, NULL, FEAT_NONE },
{ SECTION_SYM_GATE, NULL, FEAT_NONE },
{ SECTION_SYM_FORGE, NULL, FEAT_NONE },
{ SECTION_SYM_ITEM, NULL, FEAT_NONE },
{ SECTION_SYM_MONSTER, NULL, FEAT_NONE },
{ SECTION_SYM_TRAP, NULL, FEAT_NONE },
{ SECTION_SYM_DOOR, NULL, FEAT_NONE },

 };
 size_t i;
 result.d = dict_create(tutorial_section_sym_key_hash,
  tutorial_section_sym_key_compare, mem_free,
  tutorial_section_sym_value_free);
 /* Insert the predefined symbols. */
 for (i = 0; i < N_ELEMENTS(symbol_kinds); ++i) {
  struct tutorial_section_sym_key *key;
  struct tutorial_section_sym_val *value;
  if (!symbol_kinds[i].sym) continue;
  key = mem_alloc(sizeof(*key));
  my_strcpy(key->symbol, symbol_kinds[i].sym,
   sizeof(key->symbol));
  key->x = -1;
  key->y = -1;
  value = mem_zalloc(sizeof(*value));
  if (symbol_kinds[i].feat_idx != FEAT_NONE) {
   value->v.feat = symbol_kinds[i].feat_idx;
  }
  value->is_predefined = true;
  value->kind = symbol_kinds[i].kind;
  if (!tutorial_section_sym_table_insert(result, key, value)) {
   quit("logic error:  duplicate symbols in list-tutorial-sym.h");
  }
 }
 return result;
}
/**
 * Destroy a tutorial section's symbol table.  This is a thin layer of type
 * checking over the generic dictionary type.
 */
static void tutorial_section_sym_table_destroy(
  struct tutorial_section_sym_table t)
{
 dict_destroy(t.d);
}
/**
 * Insert a key and value into a tutorial section's symbol table.  This is a
 * thin layer of type checking over the generic dictionary type.
 */
static bool tutorial_section_sym_table_insert(
  struct tutorial_section_sym_table t,
  struct tutorial_section_sym_key *key,
  struct tutorial_section_sym_val *value)
{
 return dict_insert(t.d, key, value);
}
/**
 * Parse a customized symbol for a tutorial section.
 */
static enum parser_error tutorial_section_parse_symbol(
  const char *symbol,
  struct tutorial_parser_priv *priv,
  struct tutorial_section_sym_table t,
  struct tutorial_section_sym_key **key)
{
 const char *lp = strchr(symbol + 1, '(');
 size_t sz = utf8_strlen(symbol);
 enum parser_error result = PARSE_ERROR_NONE;
 if (lp == NULL) {
  /* There's no coordinate specified. */
  if (sz != 1) {
   result = PARSE_ERROR_INVALID_UTF8_CODE_POINT;
  } else {
   *key = mem_alloc(sizeof(**key));
   my_strcpy((*key)->symbol, symbol,
    sizeof((*key)->symbol));
   (*key)->x = -1;
   (*key)->y = -1;
  }
 } else {
  const char *rp = strchr(lp + 1, ')');
  size_t sz1 = utf8_strlen(lp);
  assert(sz1 < sz);
  if (sz - sz1 != 1) {
   result = PARSE_ERROR_INVALID_UTF8_CODE_POINT;
  } else if (rp == NULL || *(rp + 1) != '\0') {
   result = PARSE_ERROR_MALFORMED_COORDINATE;
  } else {
   char *endx, *endy;
   long lx, ly;
   lx = strtol(lp + 1, &endx, 10);
   if (endx == lp + 1 || *endx != ',') {
    result = PARSE_ERROR_NOT_NUMBER;
   } else if (lx < 0 || lx >= z_info->dungeon_wid - 1) {
    result = PARSE_ERROR_OUT_OF_BOUNDS;
   } else {
    ly = strtol(endx + 1, &endy, 10);
    if (endy == endx + 1 || endy != rp) {
     result = PARSE_ERROR_NOT_NUMBER;
    } else if (ly < 0
      || ly >= z_info->dungeon_hgt - 1) {
     result = PARSE_ERROR_OUT_OF_BOUNDS;
    } else {
     struct tutorial_section_sym_val *val;
     *key = mem_alloc(sizeof(**key));
     strnfmt((*key)->symbol,
      sizeof((*key)->symbol),
      "%.*s", (int) (lp - symbol),
      symbol);
     /*
					 * Verify that it doesn't match a
					 * predefined symbol.
					 */
     (*key)->x = -1;
     (*key)->y = -1;
     val = tutorial_section_sym_table_has(
      t, *key);
     if (val && val->is_predefined) {
      result = PARSE_ERROR_DUPLICATED_SYMBOL;
      mem_free(*key);
      *key = NULL;
     } else {
      (*key)->x = (int) lx;
      (*key)->y = (int) ly;
     }
    }
   }
  }
 }
 return result;
}
static uint32_t tutorial_key_hash(const void *key)
{
 const struct tutorial_dict_key_type *tk =
  (const struct tutorial_dict_key_type*) key;
 return djb2_hash(tk->name);
}
static int tutorial_key_compare(const void *a, const void *b)
{
 const struct tutorial_dict_key_type *tka =
  (const struct tutorial_dict_key_type*) a;
 const struct tutorial_dict_key_type *tkb =
  (const struct tutorial_dict_key_type*) b;
 return (streq(tka->name, tkb->name) && tka->comp == tkb->comp) ? 0 : 1;
}
static void tutorial_key_free(void *key)
{
 struct tutorial_dict_key_type *tk =
  (struct tutorial_dict_key_type*) key;
 string_free(tk->name);
 mem_free(tk);
}
static void free_trigger_compiled_ops(struct trigger_compiled_op *ops, int n)
{
 int i;
 if (!ops) {
  return;
 }
 for (i = 0; i < n; ++i) {
  mem_free(ops[i].name);
 }
 mem_free(ops);
}
static void tutorial_value_free(void* value)
{
 struct tutorial_dict_val_type *tv =
  (struct tutorial_dict_val_type*) value;
 int i;
 switch (tv->key->comp) {
 case TUTORIAL_ARCHETYPE:
  string_free(tv->v.archetype.race_name);
  string_free(tv->v.archetype.house_name);
  string_free(tv->v.archetype.sex_name);
  string_free(tv->v.archetype.character_name);
  string_free(tv->v.archetype.history);
  mem_free(tv->v.archetype.added_abilities);
  for (i = 0; i < tv->v.archetype.kit_count; ++i) {
   if (!tv->v.archetype.kit[i].item.is_artifact) {
    tutorial_item_tweaks_free(tv->v.archetype.kit[i].item.v.details.tweaks,
     tv->v.archetype.kit[i].item.v.details.tweak_count);
   }
  }
  mem_free(tv->v.archetype.kit);
  break;
 case TUTORIAL_NOTE:
  string_free(tv->v.note.text);
  break;
 case TUTORIAL_TRIGGER:
  string_free(tv->v.trigger.text);
  string_free(tv->v.trigger.death_note_name);
  free_trigger_compiled_ops(tv->v.trigger.expr.ops,
   tv->v.trigger.expr.n_op);
  break;
 case TUTORIAL_SECTION:
  string_free(tv->v.section.start_note_name);
  string_free(tv->v.section.death_note_name);
  if (tv->v.section.lines) {
   for (i = 0; i < tv->v.section.rows; ++i) {
    string_free(tv->v.section.lines[i]);
   }
   mem_free(tv->v.section.lines);
  }
  mem_free(tv->v.section.area_flags);
  tutorial_section_sym_table_destroy(tv->v.section.symt);
  break;
 }
 mem_free(tv);
}
/**
 * Create the tutorial's dictionary.  This is a thin layer of type checking
 * over the generic dictionary type.
 */
static struct tutorial_dict_type tutorial_dict_create(void)
{
 struct tutorial_dict_type result;
 result.d = dict_create(tutorial_key_hash, tutorial_key_compare,
  tutorial_key_free, tutorial_value_free);
 return result;
}
/**
 * Destroy the tutorial's dictionary.  This is a thin layer of type checking
 * over the generic dictionary type.
 */
static void tutorial_dict_destroy(struct tutorial_dict_type d)
{
 dict_destroy(d.d);
}
/**
 * Insert a key and value into the tutorial's dictionary.  This is a thin
 * layer of type checking over the generic dictionary type.  If a starting
 * note is set, hook that up to the starting location.
 */
static bool tutorial_dict_insert(struct tutorial_dict_type d,
  struct tutorial_dict_key_type *key,
  struct tutorial_dict_val_type *value)
{
 return dict_insert(d.d, key, value);
}
/**
 * Verify that a tutorial section has exactly one starting point, at least
 * one exit, and no undefined symbols in the layout.  If a starting note is
 * set, hook that up to the starting location.
 *
 * Bad layouts trigger an exit via quit().
 */
static void verify_section(struct tutorial_dict_val_type *section)
{
 int count_starts = 0;
 int count_exits = 0;
 int count_unknown = 0;
 struct loc first_start = { -1, -1 };
 struct loc first_unknown = { -1, -1 };
 struct loc grid;
 char reasons[3][80] = { "", "", "" };
 int count_reasons;
 for (grid.y = 0; grid.y < section->v.section.rows; ++grid.y) {
  char *sym = section->v.section.lines[grid.y];
  for (grid.x = 0;
    grid.x < section->v.section.columns;
    ++grid.x) {
   char *next_sym = utf8_fskip(sym, 1, NULL);
   struct tutorial_section_sym_key key;
   struct tutorial_section_sym_val *val;
   if (next_sym) {
    assert((size_t) (next_sym - sym)
     < sizeof(key.symbol));
    strnfmt(key.symbol, sizeof(key.symbol),
     "%.*s", (int) (next_sym - sym), sym);
   } else {
    assert(grid.x
     == section->v.section.columns - 1);
    my_strcpy(key.symbol, sym, sizeof(key.symbol));
   }
   key.x = grid.x;
   key.y = grid.y;
   val = tutorial_section_sym_table_has(
    section->v.section.symt, &key);
   if (!val) {
    key.x = -1;
    key.y = -1;
    val = tutorial_section_sym_table_has(
     section->v.section.symt, &key);
   }
   if (val) {
    if (val->kind == SECTION_SYM_START) {
     if (!count_starts) {
      first_start = grid;
     }
     ++count_starts;
     /*
					 * Associate with the assigned starting
					 * note.
					 */
     assert(!val->v.name);
     val->v.name = string_make(
      section->v.section.start_note_name);
    } else if (val->kind == SECTION_SYM_GATE) {
     ++count_exits;
    }
   } else {
    if (!count_unknown) {
     first_unknown = grid;
    }
    ++count_unknown;
   }
   sym = next_sym;
  }
 }
 count_reasons = 0;
 if (count_starts == 0) {
  assert(count_reasons < (int)N_ELEMENTS(reasons));
  strnfmt(reasons[count_reasons], sizeof(reasons[count_reasons]),
   "  %d) no starting location", count_reasons + 1);
  ++count_reasons;
 } else if (count_starts > 1) {
  assert(count_reasons < (int)N_ELEMENTS(reasons));
  strnfmt(reasons[count_reasons], sizeof(reasons[count_reasons]),
   "  %d) %d starting locations; first at row %d and "
   "column %d", count_reasons + 1, count_starts,
   first_start.y, first_start.x);
  ++count_reasons;
 }
 if (count_exits == 0) {
  assert(count_reasons < (int)N_ELEMENTS(reasons));
  strnfmt(reasons[count_reasons], sizeof(reasons[count_reasons]),
   "  %d) no exits", count_reasons + 1);
  ++count_reasons;
 }
 if (count_unknown > 0) {
  assert(count_reasons < (int)N_ELEMENTS(reasons));
  strnfmt(reasons[count_reasons], sizeof(reasons[count_reasons]),
   "  %d) %d unknown symbols; first at row %d and "
   "column %d", count_reasons + 1, count_unknown,
   first_unknown.y, first_unknown.x);
  ++count_reasons;
 }
 if (count_reasons > 0) {
  quit_fmt("Tutorial section, %s, has these problems:%s%s%s",
   section->key->name, reasons[0], reasons[1], reasons[2]);
 }
}
static enum parser_error tutorial_add_item_tweak(
  struct tutorial_item_tweak **tweaks,
  int *count, int *alloc, enum tutorial_item_tweak_kind kind,
  const char *dice, const random_value *rv, int idx)
{
 assert(*count >= 0 && *count <= *alloc);
 if (*count == *alloc) {
  if (!*alloc) {
   *alloc = 4;
  } else if (*alloc >= 128) {
   return PARSE_ERROR_TOO_MANY_ENTRIES;
  } else {
   *alloc += *alloc;
  }
  *tweaks = mem_realloc(*tweaks, *alloc * sizeof(**tweaks));
 }
 (*tweaks)[*count].dice = string_make(dice);
 (*tweaks)[*count].value = *rv;
 (*tweaks)[*count].kind = kind;
 (*tweaks)[*count].idx = idx;
 ++*count;
 return PARSE_ERROR_NONE;
}
static enum parser_error tutorial_parse_tweaks(
  struct tutorial_item_tweak **tweaks, int *count, int *alloc,
  const char *props, const char *mods)
{
 random_value dummy_rv = { 0, 0, 0, 0 };
 char *flags, *s, *lb, *rb;
 int idx;
 enum parser_error add_error;
 *tweaks = NULL;
 *count = 0;
 *alloc = 0;
 flags = string_make(props);
 s = strtok(flags, " |");
 while (s) {
  idx = lookup_flag(obj_flags, s);
  if (idx >= 0) {
   if (idx) {
    add_error = tutorial_add_item_tweak(tweaks,
     count, alloc, TWEAK_FLAG, NULL,
     &dummy_rv, idx);
    if (add_error != PARSE_ERROR_NONE) {
     string_free(flags);
     return add_error;
    }
   }
  } else if (prefix(s, "IGNORE_")) {
   idx = lookup_flag(element_names, s + 7);
   if (idx > 0 && idx < ELEM_MAX + 1) {
    add_error = tutorial_add_item_tweak(tweaks,
     count, alloc, TWEAK_ELEM_IGNORE, NULL,
     &dummy_rv, idx - 1);
    if (add_error != PARSE_ERROR_NONE) {
     string_free(flags);
     return add_error;
    }
   } else {
    string_free(flags);
    return PARSE_ERROR_INVALID_PROPERTY;
   }
  } else if (prefix(s, "HATES_")) {
   idx = lookup_flag(element_names, s + 6);
   if (idx > 0 && idx < ELEM_MAX + 1) {
    add_error = tutorial_add_item_tweak(tweaks,
     count, alloc, TWEAK_ELEM_HATE, NULL,
     &dummy_rv, idx - 1);
    if (add_error != PARSE_ERROR_NONE) {
     string_free(flags);
     return add_error;
    }
   } else {
    string_free(flags);
    return PARSE_ERROR_INVALID_PROPERTY;
   }
  } else if ((idx = lookup_slay(s)) >= 0) {
   add_error = tutorial_add_item_tweak(tweaks,
    count, alloc, TWEAK_SLAY, NULL, &dummy_rv, idx);
   if (add_error != PARSE_ERROR_NONE) {
    string_free(flags);
    return add_error;
   }
  } else if ((idx = lookup_brand(s)) >= 0) {
   add_error = tutorial_add_item_tweak(tweaks,
    count, alloc, TWEAK_BRAND, NULL, &dummy_rv,
    idx);
   if (add_error != PARSE_ERROR_NONE) {
    string_free(flags);
    return add_error;
   }
  } else {
   string_free(flags);
   return PARSE_ERROR_INVALID_PROPERTY;
  }
  s = strtok(NULL, " |");
 }
 string_free(flags);
 flags = string_make(mods);
 s = strtok(flags, " |");
 while (s) {
  lb = strchr(s, '[');
  rb = strchr(s, ']');
  if (lb == NULL || rb == NULL || *(rb + 1) != '\0') {
   string_free(flags);
   return PARSE_ERROR_INVALID_DICE;
  }
  *lb = '\0';
  *rb = '\0';
  ++lb;
  if (streq(s, "PVAL")) {
   add_error = tutorial_add_item_tweak(tweaks, count,
    alloc, TWEAK_PVAL, lb + 1, &dummy_rv, 0);
   if (add_error != PARSE_ERROR_NONE) {
    string_free(flags);
    return add_error;
   }
  } else {
   dice_t *dice = dice_new();
   random_value rv;
   if (dice_parse_string(dice, lb)) {
    dice_random_value(dice, &rv);
    dice_free(dice);
   } else {
    dice_free(dice);
    string_free(flags);
    return PARSE_ERROR_INVALID_DICE;
   }
   idx = lookup_flag(obj_mods, s);
   if (idx >= 0) {
    if (idx > 0) {
     add_error = tutorial_add_item_tweak(
      tweaks, count, alloc,
      TWEAK_MODIFIER, NULL, &rv,
      idx - 1);
     if (add_error != PARSE_ERROR_NONE) {
      string_free(flags);
      return add_error;
     }
    }
   } else if (prefix(s, "RES_")) {
    idx = lookup_flag(element_names, s + 4);
    if (idx > 0 && idx < ELEM_MAX + 1) {
     add_error = tutorial_add_item_tweak(
      tweaks, count, alloc,
      TWEAK_ELEM_RESIST, NULL, &rv,
      idx - 1);
     if (add_error != PARSE_ERROR_NONE) {
      string_free(flags);
      return add_error;
     }
    } else {
     string_free(flags);
     return PARSE_ERROR_INVALID_PROPERTY;
    }
   } else {
    string_free(flags);
    return PARSE_ERROR_INVALID_PROPERTY;
   }
  }
  s = strtok(NULL, " |");
 }
 string_free(flags);
 return PARSE_ERROR_NONE;
}
static enum parser_error tutorial_add_area_flags(struct parser *p,
  struct tutorial_dict_val_type *val, bool clear)
{
 char *flags = string_make(parser_getstr(p, "flags"));
 char *s = strtok(flags, " |");
 bitflag bits[SQUARE_SIZE];
 struct tutorial_area_flag *this_area;
 sqinfo_wipe(bits);
 while (s) {
  int idx = lookup_flag(square_flag_names, s);
  if (idx > 0) {
   sqinfo_on(bits, idx);
  } else if (!streq(s, "NONE")) {
   string_free(flags);
   return PARSE_ERROR_INVALID_FLAG;
  }
  s = strtok(NULL, " |");
 }
 string_free(flags);
 assert(val->v.section.area_flag_count >= 0
  && val->v.section.area_flag_count
  <= val->v.section.area_flag_alloc);
 if (val->v.section.area_flag_count == val->v.section.area_flag_alloc) {
  if (!val->v.section.area_flag_alloc) {
   val->v.section.area_flag_alloc = 4;
  } else if (val->v.section.area_flag_alloc >= 1024) {
   return PARSE_ERROR_TOO_MANY_ENTRIES;
  } else {
   val->v.section.area_flag_alloc +=
    val->v.section.area_flag_alloc;
  }
  val->v.section.area_flags = mem_realloc(
   val->v.section.area_flags,
   val->v.section.area_flag_alloc
   * sizeof(*val->v.section.area_flags));
 }
 this_area = val->v.section.area_flags + val->v.section.area_flag_count;
 ++val->v.section.area_flag_count;
 sqinfo_copy(this_area->flags, bits);
 this_area->ul = loc(parser_getint(p, "xul"), parser_getint(p, "yul"));
 this_area->lr = loc(parser_getint(p, "xlr"), parser_getint(p, "ylr"));
 this_area->clear = clear;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_archetype_block_start(struct parser *p)
{
 struct tutorial_parser_priv *priv = (struct tutorial_parser_priv*)
  parser_priv(p);
 struct tutorial_dict_key_type *key;
 struct tutorial_dict_val_type *value;
 if (priv->curr_value
   && priv->curr_value->key->comp == TUTORIAL_SECTION) {
  if (priv->section_lines_parsed
    < priv->curr_value->v.section.rows) {
   return PARSE_ERROR_TOO_FEW_ENTRIES;
  }
  verify_section(priv->curr_value);
 }
 key = mem_alloc(sizeof(*key));
 key->name = string_make(parser_getstr(p, "name"));
 key->comp = TUTORIAL_ARCHETYPE;
 value = mem_zalloc(sizeof(*value));
 if (!tutorial_dict_insert(priv->r->d, key, value)) {
  tutorial_value_free(value);
  tutorial_key_free(key);
  return PARSE_ERROR_DUPLICATED_NAME;
 }
 value->key = key;
 /*
	 * Keep whatever unspent experience there is after buying skills and
	 * abilities.
	 */
 value->v.archetype.unspent_experience = -1;
 value->v.archetype.purge_kit = false;
 priv->curr_value = value;
 if (!priv->r->default_archetype) {
  priv->r->default_archetype = value;
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_note_block_start(struct parser *p)
{
 struct tutorial_parser_priv *priv = (struct tutorial_parser_priv*)
  parser_priv(p);
 struct tutorial_dict_key_type *key;
 struct tutorial_dict_val_type *value;
 if (priv->curr_value
   && priv->curr_value->key->comp == TUTORIAL_SECTION) {
  if (priv->section_lines_parsed
    < priv->curr_value->v.section.rows) {
   return PARSE_ERROR_TOO_FEW_ENTRIES;
  }
  verify_section(priv->curr_value);
 }
 key = mem_alloc(sizeof(*key));
 key->name = string_make(parser_getstr(p, "name"));
 key->comp = TUTORIAL_NOTE;
 value = mem_zalloc(sizeof(*value));
 if (!tutorial_dict_insert(priv->r->d, key, value)) {
  tutorial_value_free(value);
  tutorial_key_free(key);
  return PARSE_ERROR_DUPLICATED_NAME;
 }
 assert(priv->r->note_table_n >= 0
   && priv->r->note_table_n <= priv->r->note_table_a);
 if (priv->r->note_table_n == priv->r->note_table_a) {
  int new_a = (priv->r->note_table_a) ?
   priv->r->note_table_a + priv->r->note_table_a : 8;
  /* Limited by the number of possible pvals. */
  if (new_a > MAX_PVAL + 1) {
   return PARSE_ERROR_TOO_MANY_ENTRIES;
  }
  priv->r->note_table_a = new_a;
  priv->r->pval_to_note_table = mem_realloc(
   priv->r->pval_to_note_table,
   new_a * sizeof(*priv->r->pval_to_note_table));
 }
 value->key = key;
 value->v.note.pval = priv->r->note_table_n;
 priv->curr_value = value;
 priv->r->pval_to_note_table[priv->r->note_table_n] = value;
 ++priv->r->note_table_n;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_trigger_block_start(struct parser *p)
{
 struct tutorial_parser_priv *priv = (struct tutorial_parser_priv*)
  parser_priv(p);
 struct tutorial_dict_key_type *key;
 struct tutorial_dict_val_type *value;
 if (priv->curr_value
   && priv->curr_value->key->comp == TUTORIAL_SECTION) {
  if (priv->section_lines_parsed
    < priv->curr_value->v.section.rows) {
   return PARSE_ERROR_TOO_FEW_ENTRIES;
  }
  verify_section(priv->curr_value);
 }
 key = mem_alloc(sizeof(*key));
 key->name = string_make(parser_getstr(p, "name"));
 key->comp = TUTORIAL_TRIGGER;
 value = mem_zalloc(sizeof(*value));
 if (!tutorial_dict_insert(priv->r->d, key, value)) {
  tutorial_value_free(value);
  tutorial_key_free(key);
  return PARSE_ERROR_DUPLICATED_NAME;
 }
 value->key = key;
 priv->curr_value = value;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_section_block_start(struct parser *p)
{
 struct tutorial_parser_priv *priv = (struct tutorial_parser_priv*)
  parser_priv(p);
 const char *name = parser_getstr(p, "name");
 struct tutorial_dict_key_type *key;
 struct tutorial_dict_val_type *value;
 if (priv->curr_value
   && priv->curr_value->key->comp == TUTORIAL_SECTION) {
  if (priv->section_lines_parsed
    < priv->curr_value->v.section.rows) {
   return PARSE_ERROR_TOO_FEW_ENTRIES;
  }
  verify_section(priv->curr_value);
 }
 key = mem_alloc(sizeof(*key));
 key->name = string_make(name);
 key->comp = TUTORIAL_SECTION;
 value = mem_zalloc(sizeof(*value));
 if (!tutorial_dict_insert(priv->r->d, key, value)) {
  tutorial_value_free(value);
  tutorial_key_free(key);
  return PARSE_ERROR_DUPLICATED_NAME;
 }
 value->key = key;
 value->v.section.symt = tutorial_section_sym_table_create();
 priv->curr_value = value;
 priv->section_lines_parsed = 0;
 if (!priv->r->default_section) {
  priv->r->default_section = value;
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_archetype_race(struct parser *p)
{
 struct tutorial_parser_priv *priv = (struct tutorial_parser_priv*)
  parser_priv(p);
 enum parser_error result = PARSE_ERROR_NONE;
 if (priv->curr_value->key->comp == TUTORIAL_ARCHETYPE) {
  const char *name = parser_getstr(p, "name");
  if (priv->curr_value->v.archetype.race_name) {
   string_free(priv->curr_value->v.archetype.race_name);
  }
  priv->curr_value->v.archetype.race_name = string_make(name);
 } else {
  result = PARSE_ERROR_UNDEFINED_DIRECTIVE;
 }
 return result;
}
static enum parser_error parse_archetype_house(struct parser *p)
{
 struct tutorial_parser_priv *priv = (struct tutorial_parser_priv*)
  parser_priv(p);
 enum parser_error result = PARSE_ERROR_NONE;
 if (priv->curr_value->key->comp == TUTORIAL_ARCHETYPE) {
  const char *name = parser_getstr(p, "name");
  if (priv->curr_value->v.archetype.house_name) {
   string_free(priv->curr_value->v.archetype.house_name);
  }
  priv->curr_value->v.archetype.house_name = string_make(name);
 } else {
  result = PARSE_ERROR_UNDEFINED_DIRECTIVE;
 }
 return result;
}
static enum parser_error parse_archetype_sex(struct parser *p)
{
 struct tutorial_parser_priv *priv = (struct tutorial_parser_priv*)
  parser_priv(p);
 enum parser_error result = PARSE_ERROR_NONE;
 if (priv->curr_value->key->comp == TUTORIAL_ARCHETYPE) {
  const char *name = parser_getstr(p, "name");
  if (priv->curr_value->v.archetype.sex_name) {
   string_free(priv->curr_value->v.archetype.sex_name);
  }
  priv->curr_value->v.archetype.sex_name = string_make(name);
 } else {
  result = PARSE_ERROR_UNDEFINED_DIRECTIVE;
 }
 return result;
}
static enum parser_error parse_archetype_character_name(struct parser *p)
{
 struct tutorial_parser_priv *priv = (struct tutorial_parser_priv*)
  parser_priv(p);
 enum parser_error result = PARSE_ERROR_NONE;
 if (priv->curr_value->key->comp == TUTORIAL_ARCHETYPE) {
  const char *name = parser_getstr(p, "name");
  if (priv->curr_value->v.archetype.character_name) {
   string_free(priv->curr_value->v.archetype.character_name);
  }
  priv->curr_value->v.archetype.character_name =
   string_make(name);
 } else {
  result = PARSE_ERROR_UNDEFINED_DIRECTIVE;
 }
 return result;
}
static enum parser_error parse_archetype_history(struct parser *p)
{
 struct tutorial_parser_priv *priv = (struct tutorial_parser_priv*)
  parser_priv(p);
 enum parser_error result = PARSE_ERROR_NONE;
 if (priv->curr_value->key->comp == TUTORIAL_ARCHETYPE) {
  const char *text = parser_getstr(p, "history");
  priv->curr_value->v.archetype.history = string_append(
   priv->curr_value->v.archetype.history, text);
 } else {
  result = PARSE_ERROR_UNDEFINED_DIRECTIVE;
 }
 return result;
}
static enum parser_error parse_archetype_experience(struct parser *p)
{
 struct tutorial_parser_priv *priv = (struct tutorial_parser_priv*)
  parser_priv(p);
 enum parser_error result = PARSE_ERROR_NONE;
 if (priv->curr_value->key->comp == TUTORIAL_ARCHETYPE) {
  const char *text = parser_getstr(p, "value");
  char *endptr;
  long lval = strtol(text, &endptr, 10);
  if (text[0] == '\0'
    || (*endptr != '\0'
    && !contains_only_spaces(endptr))) {
   result = PARSE_ERROR_INVALID_VALUE;
  } else {
   priv->curr_value->v.archetype.unspent_experience =
    (int32_t)MAX(0L, MIN(lval, 0x7FFFFFFFL));
  }
 } else {
  result = PARSE_ERROR_UNDEFINED_DIRECTIVE;
 }
 return result;
}
static enum parser_error parse_archetype_stats(struct parser *p)
{
 struct tutorial_parser_priv *priv = (struct tutorial_parser_priv*)
  parser_priv(p);
 enum parser_error result = PARSE_ERROR_NONE;
 if (priv->curr_value->key->comp == TUTORIAL_ARCHETYPE) {
  char *s = string_make(parser_getstr(p, "values"));
  char *t = strtok(s, " |");
  while (t) {
   int value = 0;
   int idx = 0;
   if (grab_index_and_int(&value, &idx, obj_mods, "", t)
     || idx < 1 || idx > STAT_MAX) {
    result = PARSE_ERROR_INVALID_VALUE;
    break;
   }
   --idx;
   if (value >= 0 && priv->curr_value->v.archetype.stat_adj[idx] > INT_MAX - value) {
    result = PARSE_ERROR_INVALID_VALUE;
    break;
   }
   if (value < 0 && priv->curr_value->v.archetype.stat_adj[idx] < INT_MIN - value) {
    result = PARSE_ERROR_INVALID_VALUE;
    break;
   }
   priv->curr_value->v.archetype.stat_adj[idx] += value;
   t = strtok(NULL, " |");
  }
  string_free(s);
 } else {
  result = PARSE_ERROR_UNDEFINED_DIRECTIVE;
 }
 return result;
}
static enum parser_error parse_archetype_skills(struct parser *p)
{
 struct tutorial_parser_priv *priv = (struct tutorial_parser_priv*)
  parser_priv(p);
 enum parser_error result = PARSE_ERROR_NONE;
 if (priv->curr_value->key->comp == TUTORIAL_ARCHETYPE) {
  char *s = string_make(parser_getstr(p, "values"));
  char *t = strtok(s, " |");
  while (t) {
   int value = 0;
   int idx = 0;
   if (grab_index_and_int(&value, &idx, obj_mods, "", t)
     || idx < STAT_MAX + 1
     || idx > STAT_MAX + SKILL_MAX) {
    result = PARSE_ERROR_INVALID_VALUE;
    break;
   }
   idx -= STAT_MAX + 1;
   if (value >= 0 && priv->curr_value->v.archetype.skill_adj[idx] > INT_MAX - value) {
    result = PARSE_ERROR_INVALID_VALUE;
    break;
   }
   if (value < 0 && priv->curr_value->v.archetype.skill_adj[idx] < INT_MIN - value) {
    result = PARSE_ERROR_INVALID_VALUE;
    break;
   }
   priv->curr_value->v.archetype.skill_adj[idx] += value;
   t = strtok(NULL, " |");
  }
  string_free(s);
 } else {
  result = PARSE_ERROR_UNDEFINED_DIRECTIVE;
 }
 return result;
}
static enum parser_error parse_archetype_abilities(struct parser *p)
{
 struct tutorial_parser_priv *priv = (struct tutorial_parser_priv*)
  parser_priv(p);
 enum parser_error result = PARSE_ERROR_NONE;
 if (priv->curr_value->key->comp == TUTORIAL_ARCHETYPE) {
  char *s = string_make(parser_getstr(p, "values"));
  char *t = s;
  while (1) {
   char *tnext;
   bool done;
   int idx;
   char *rb;
   struct ability *ab;
   tnext = t + strcspn(t, " |");
   if (tnext == t) {
    if (*tnext) {
     t = tnext + 1;
     continue;
    }
    break;
   }
   while (*tnext == ' ' && *(tnext - 1) != ']') {
    tnext += 1 + strcspn(tnext + 1, " |");
   }
   if (*tnext) {
    *tnext = '\0';
    ++tnext;
    done = false;
   } else {
    done = true;
   }
   idx = STAT_MAX + 1;
   while (1) {
    if (idx > STAT_MAX + SKILL_MAX) {
     result = PARSE_ERROR_INVALID_SKILL;
     break;
    }
    if (prefix(t, obj_mods[idx])
      && t[strlen(obj_mods[idx])] == '[') {
     break;
    }
    ++idx;
   }
   if (result != PARSE_ERROR_NONE) {
    break;
   }
   t += strlen(obj_mods[idx]) + 1;
   rb = strchr(t, ']');
   if (!rb || rb[1]) {
    result = PARSE_ERROR_INVALID_ABILITY;
    break;
   }
   *rb = '\0';
   ab = lookup_ability(idx - STAT_MAX - 1, t);
   if (!ab) {
    result = PARSE_ERROR_INVALID_ABILITY;
    break;
   }
   assert(priv->curr_value->v.archetype.ability_count >= 0
    && priv->curr_value->v.archetype.ability_count
    <= priv->curr_value->v.archetype.ability_alloc);
   if (priv->curr_value->v.archetype.ability_count
     == priv->curr_value->v.archetype.ability_alloc) {
    if (!priv->curr_value->v.archetype.ability_alloc) {
     priv->curr_value->v.archetype.ability_alloc = 4;
    } else if (priv->curr_value->v.archetype.ability_alloc
      >= 1024) {
     /*
					 * Cap the number so allocated size
					 * won't have the potential to overflow
					 * a size_t.
					 */
     result = PARSE_ERROR_TOO_MANY_ENTRIES;
     break;
    } else {
     priv->curr_value->v.archetype.ability_alloc +=
      priv->curr_value->v.archetype.ability_alloc;
    }
    priv->curr_value->v.archetype.added_abilities =
     mem_realloc(priv->curr_value->v.archetype.added_abilities,
     priv->curr_value->v.archetype.ability_alloc
     * sizeof(*priv->curr_value->v.archetype.added_abilities));
   }
   priv->curr_value->v.archetype.added_abilities[priv->curr_value->v.archetype.ability_count] = ab;
   ++priv->curr_value->v.archetype.ability_count;
   if (done) {
    break;
   }
   t = tnext;
  }
  string_free(s);
 } else {
  result = PARSE_ERROR_UNDEFINED_DIRECTIVE;
 }
 return result;
}
static enum parser_error parse_archetype_object(struct parser *p)
{
 struct tutorial_parser_priv *priv = (struct tutorial_parser_priv*)
  parser_priv(p);
 const char *numstr = parser_getsym(p, "number");
 const char *eqstr = parser_getsym(p, "equipped");
 int tval, sval;
 dice_t *numdice;
 struct tutorial_kit_item *this_kit;
 if (priv->curr_value->key->comp != TUTORIAL_ARCHETYPE) {
  return PARSE_ERROR_UNDEFINED_DIRECTIVE;
 }
 tval = tval_find_idx(parser_getsym(p, "tval"));
 if (tval < 0) {
  return PARSE_ERROR_UNRECOGNISED_TVAL;
 }
 sval = lookup_sval(tval, parser_getsym(p, "sval"));
 if (sval < 0) {
  return PARSE_ERROR_UNRECOGNISED_SVAL;
 }
 assert(priv->curr_value->v.archetype.kit_count >= 0
  && priv->curr_value->v.archetype.kit_count
  <= priv->curr_value->v.archetype.kit_alloc);
 if (priv->curr_value->v.archetype.kit_count
   == priv->curr_value->v.archetype.kit_alloc) {
  if (!priv->curr_value->v.archetype.kit_count) {
   priv->curr_value->v.archetype.kit_alloc = 4;
  } else if (priv->curr_value->v.archetype.kit_alloc >= 128) {
   /*
			 * Cap the number so allocated size won't have the
			 * potential to overflow a size_t.
			 */
   return PARSE_ERROR_TOO_MANY_ENTRIES;
  } else {
   priv->curr_value->v.archetype.kit_alloc +=
    priv->curr_value->v.archetype.kit_alloc;
  }
  priv->curr_value->v.archetype.kit = mem_realloc(
   priv->curr_value->v.archetype.kit,
   priv->curr_value->v.archetype.kit_alloc *
   sizeof(*priv->curr_value->v.archetype.kit));
 }
 this_kit = priv->curr_value->v.archetype.kit
  + priv->curr_value->v.archetype.kit_count;
 numdice = dice_new();
 if (dice_parse_string(numdice, numstr)) {
  dice_random_value(numdice, &this_kit->item.v.details.number);
  dice_free(numdice);
 } else {
  dice_free(numdice);
  return PARSE_ERROR_INVALID_DICE;
 }
 ++priv->curr_value->v.archetype.kit_count;
 this_kit->item.v.details.ego = NULL;
 this_kit->item.v.details.tweaks = NULL;
 this_kit->item.v.details.tval = tval;
 this_kit->item.v.details.sval = sval;
 this_kit->item.v.details.tweak_count = 0;
 this_kit->item.is_artifact = false;
 this_kit->equipped = (my_stricmp(eqstr, "yes") == 0);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_archetype_complex_object(struct parser *p)
{
 struct tutorial_parser_priv *priv = (struct tutorial_parser_priv*)
  parser_priv(p);
 const char *numstr = parser_getsym(p, "number");
 const char *eqstr = parser_getsym(p, "equipped");
 const char *ego = parser_getsym(p, "ego");
 const char *props = parser_getsym(p, "properties");
 const char *mods = parser_getstr(p, "modifiers");
 int tval, sval;
 struct tutorial_item_tweak *tweaks;
 int tweak_count, tweak_alloc;
 enum parser_error tweak_result;
 dice_t *numdice;
 struct tutorial_kit_item *this_kit;
 if (priv->curr_value->key->comp != TUTORIAL_ARCHETYPE) {
  return PARSE_ERROR_UNDEFINED_DIRECTIVE;
 }
 tval = tval_find_idx(parser_getsym(p, "tval"));
 if (tval < 0) {
  return PARSE_ERROR_UNRECOGNISED_TVAL;
 }
 sval = lookup_sval(tval, parser_getsym(p, "sval"));
 if (sval < 0) {
  return PARSE_ERROR_UNRECOGNISED_SVAL;
 }
 assert(priv->curr_value->v.archetype.kit_count >= 0
  && priv->curr_value->v.archetype.kit_count
  <= priv->curr_value->v.archetype.kit_alloc);
 if (priv->curr_value->v.archetype.kit_count
   == priv->curr_value->v.archetype.kit_alloc) {
  if (!priv->curr_value->v.archetype.kit_count) {
   priv->curr_value->v.archetype.kit_alloc = 4;
  } else if (priv->curr_value->v.archetype.kit_alloc >= 128) {
   /*
			 * Cap the number so allocated size won't have the
			 * potential to overflow a size_t.
			 */
   return PARSE_ERROR_TOO_MANY_ENTRIES;
  } else {
   priv->curr_value->v.archetype.kit_alloc +=
    priv->curr_value->v.archetype.kit_alloc;
  }
  priv->curr_value->v.archetype.kit = mem_realloc(
   priv->curr_value->v.archetype.kit,
   priv->curr_value->v.archetype.kit_alloc *
   sizeof(*priv->curr_value->v.archetype.kit));
 }
 tweak_result = tutorial_parse_tweaks(&tweaks, &tweak_count,
  &tweak_alloc, props, mods);
 if (tweak_result != PARSE_ERROR_NONE) {
  tutorial_item_tweaks_free(tweaks, tweak_count);
  return tweak_result;
 }
 this_kit = priv->curr_value->v.archetype.kit
  + priv->curr_value->v.archetype.kit_count;
 numdice = dice_new();
 if (dice_parse_string(numdice, numstr)) {
  dice_random_value(numdice, &this_kit->item.v.details.number);
  dice_free(numdice);
 } else {
  dice_free(numdice);
  tutorial_item_tweaks_free(tweaks, tweak_count);
  return PARSE_ERROR_INVALID_DICE;
 }
 ++priv->curr_value->v.archetype.kit_count;
 this_kit->item.v.details.ego =
  streq(ego, "NONE") ? NULL : lookup_ego_item(ego, tval, sval);
 this_kit->item.v.details.tweaks = tweaks;
 this_kit->item.v.details.tval = tval;
 this_kit->item.v.details.sval = sval;
 this_kit->item.v.details.tweak_count = tweak_count;
 this_kit->item.is_artifact = false;
 this_kit->equipped = (my_stricmp(eqstr, "yes") == 0);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_archetype_artifact(struct parser *p)
{
 struct tutorial_parser_priv *priv = (struct tutorial_parser_priv*)
  parser_priv(p);
 const char *eqstr = parser_getsym(p, "equipped");
 const struct artifact *art;
 struct tutorial_kit_item *this_kit;
 if (priv->curr_value->key->comp != TUTORIAL_ARCHETYPE) {
  return PARSE_ERROR_UNDEFINED_DIRECTIVE;
 }
 art = lookup_artifact_name(parser_getsym(p, "name"));
 if (!art) {
  return PARSE_ERROR_NO_ARTIFACT_NAME;
 }
 assert(priv->curr_value->v.archetype.kit_count >= 0
  && priv->curr_value->v.archetype.kit_count
  <= priv->curr_value->v.archetype.kit_alloc);
 if (priv->curr_value->v.archetype.kit_count
   == priv->curr_value->v.archetype.kit_alloc) {
  if (!priv->curr_value->v.archetype.kit_count) {
   priv->curr_value->v.archetype.kit_alloc = 4;
  } else if (priv->curr_value->v.archetype.kit_alloc >= 128) {
   /*
			 * Cap the number so allocated size won't have the
			 * potential to overflow a size_t.
			 */
   return PARSE_ERROR_TOO_MANY_ENTRIES;
  } else {
   priv->curr_value->v.archetype.kit_alloc +=
    priv->curr_value->v.archetype.kit_alloc;
  }
  priv->curr_value->v.archetype.kit = mem_realloc(
   priv->curr_value->v.archetype.kit,
   priv->curr_value->v.archetype.kit_alloc *
   sizeof(*priv->curr_value->v.archetype.kit));
 }
 this_kit = priv->curr_value->v.archetype.kit
  + priv->curr_value->v.archetype.kit_count;
 ++priv->curr_value->v.archetype.kit_count;
 this_kit->item.v.art = art;
 this_kit->item.is_artifact = true;
 this_kit->equipped = (my_stricmp(eqstr, "yes") == 0);
 return PARSE_ERROR_NONE;
}
static void add_trigger_op(struct trigger_compiled_op **c, int *n_c, int *a_c,
  enum trigger_op_kind kind, int tval, int sval, int idx,
  char *name)
{
 struct trigger_compiled_op *this_op;
 assert(*n_c >= 0 && *n_c <= *a_c);
 if (*n_c == *a_c) {
  *a_c = (*a_c) ? *a_c + (*a_c) : 4;
  *c = mem_realloc(*c, *a_c * sizeof(**c));
 }
 this_op = (*c) + (*n_c);
 ++*n_c;
 this_op->kind = kind;
 this_op->tval = tval;
 this_op->sval = sval;
 this_op->idx = idx;
 this_op->name = name;
}
static int get_drained_index(const char *name)
{
 int result = 0;
 while (1) {
  if (result < STAT_MAX) {
   if (streq(name, obj_mods[result + 1])) {
    return result;
   } else {
    ++result;
   }
  } else if (streq(name, "HEALTH")) {
   return STAT_MAX;
  } else if (streq(name, "VOICE")) {
   return STAT_MAX + 1;
  } else {
   return -1;
  }
 }
}
static enum parser_error parse_trigger_condition(struct parser *p)
{
 struct tutorial_parser_priv *priv = (struct tutorial_parser_priv*)
  parser_priv(p);
 struct trigger_nesting {
  enum trigger_op_kind pend[2]; bool expect_binary;
 } *n;
 int n_n, a_n;
 struct trigger_compiled_op *c;
 int n_c, a_c;
 const char *s_expr;
 int i, curr_stack;
 if (priv->curr_value->key->comp != TUTORIAL_TRIGGER) {
  return PARSE_ERROR_UNDEFINED_DIRECTIVE;
 }
 /* Don't allow for multiple condition lines. */
 if (priv->curr_value->v.trigger.expr.ops) {
  return PARSE_ERROR_TOO_MANY_ENTRIES;
 }
 a_n = 4;
 n_n = 1;
 n = mem_alloc(a_n * sizeof(*n));
 n[0].pend[0] = TRIGGER_OP_NONE;
 n[0].pend[1] = TRIGGER_OP_NONE;
 n[0].expect_binary = false;
 n_c = 0;
 a_c = 0;
 c = NULL;
 s_expr = parser_getstr(p, "expression");
 while (*s_expr) {
  const char *rb, *term, *colon;
  char *tmp, *name;
  enum trigger_op_kind kind;
  int tval, sval, idx;
  assert(n_n > 0);
  switch (*s_expr) {
  case ' ':
  case '\t':
   /* Skip whitespace. */
   ++s_expr;
   break;
  case '(':
   if (n[n_n - 1].expect_binary) {
    free_trigger_compiled_ops(c, n_c);
    mem_free(n);
    return PARSE_ERROR_INVALID_EXPRESSION;
   }
   ++s_expr;
   if (n_n == a_n) {
    a_n += a_n;
    n = mem_realloc(n, a_n * sizeof(*n));
   }
   n[n_n].pend[0] = TRIGGER_OP_NONE;
   n[n_n].pend[1] = TRIGGER_OP_NONE;
   n[n_n].expect_binary = false;
   ++n_n;
   break;
  case ')':
   if (n_n == 1 || n[n_n - 1].expect_binary) {
    free_trigger_compiled_ops(c, n_c);
    mem_free(n);
    return PARSE_ERROR_INVALID_EXPRESSION;
   }
   ++s_expr;
   if (n[n_n - 1].pend[1] != TRIGGER_OP_NONE) {
    assert(n[n_n - 1].pend[1] == TRIGGER_OP_NOT);
    add_trigger_op(&c, &n_c, &a_c,
     n[n_n - 1].pend[1], 0, 0, 0, NULL);
   }
   if (n[n_n - 1].pend[0] != TRIGGER_OP_NONE) {
    assert(n[n_n - 1].pend[0] == TRIGGER_OP_AND
     || n[n_n - 1].pend[0] == TRIGGER_OP_NOT
     || n[n_n - 1].pend[0] == TRIGGER_OP_OR
     || n[n_n - 1].pend[0] == TRIGGER_OP_XOR);
    add_trigger_op(&c, &n_c, &a_c,
     n[n_n - 1].pend[0], 0, 0, 0, NULL);
   }
   --n_n;
   if (n[n_n - 1].pend[1] != TRIGGER_OP_NONE) {
    assert(n[n_n - 1].pend[1] == TRIGGER_OP_NOT);
    add_trigger_op(&c, &n_c, &a_c,
     n[n_n - 1].pend[1], 0, 0, 0, NULL);
    n[n_n - 1].pend[1] = TRIGGER_OP_NONE;
   }
   if (n[n_n - 1].pend[0] != TRIGGER_OP_NONE) {
    assert(n[n_n - 1].pend[0] == TRIGGER_OP_AND
     || n[n_n - 1].pend[0] == TRIGGER_OP_NOT
     || n[n_n - 1].pend[0] == TRIGGER_OP_OR
     || n[n_n - 1].pend[0] == TRIGGER_OP_XOR);
    add_trigger_op(&c, &n_c, &a_c,
     n[n_n - 1].pend[0], 0, 0, 0, NULL);
    n[n_n - 1].pend[0] = TRIGGER_OP_NONE;
   }
   n[n_n - 1].expect_binary = true;
   break;
  case 'a':
   if (!n[n_n - 1].expect_binary || *(s_expr + 1) != 'n'
     || *(s_expr + 2) != 'd') {
    free_trigger_compiled_ops(c, n_c);
    mem_free(n);
    return PARSE_ERROR_INVALID_EXPRESSION;
   }
   s_expr += 3;
   assert(n[n_n - 1].pend[0] == TRIGGER_OP_NONE);
   n[n_n - 1].pend[0] = TRIGGER_OP_AND;
   n[n_n - 1].expect_binary = false;
   break;
  case 'n':
   if (n[n_n - 1].expect_binary || *(s_expr + 1) != 'o'
     || *(s_expr + 2) != 't') {
    free_trigger_compiled_ops(c, n_c);
    mem_free(n);
    return PARSE_ERROR_INVALID_EXPRESSION;
   }
   s_expr += 3;
   if (n[n_n - 1].pend[0] == TRIGGER_OP_NONE) {
    n[n_n - 1].pend[0] = TRIGGER_OP_NOT;
   } else {
    assert(n[n_n - 1].pend[1] == TRIGGER_OP_NONE);
    n[n_n - 1].pend[1] = TRIGGER_OP_NOT;
   }
   break;
  case 'o':
   if (!n[n_n - 1].expect_binary || *(s_expr + 1) != 'r') {
    free_trigger_compiled_ops(c, n_c);
    mem_free(n);
    return PARSE_ERROR_INVALID_EXPRESSION;
   }
   s_expr += 2;
   assert(n[n_n - 1].pend[0] == TRIGGER_OP_NONE);
   n[n_n - 1].pend[0] = TRIGGER_OP_OR;
   n[n_n - 1].expect_binary = false;
   break;
  case 'x':
   if (!n[n_n - 1].expect_binary || *(s_expr + 1) != 'o'
     || *(s_expr + 2) != 'r') {
    free_trigger_compiled_ops(c, n_c);
    mem_free(n);
    return PARSE_ERROR_INVALID_EXPRESSION;
   }
   s_expr += 3;
   assert(n[n_n - 1].pend[0] == TRIGGER_OP_NONE);
   n[n_n - 1].pend[0] = TRIGGER_OP_XOR;
   n[n_n - 1].expect_binary = false;
   break;
  case '{':
   term = s_expr + 1;
   /* Find unescaped right brace. */
   rb = term;
   while (1) {
    rb = strchr(rb, '}');
    if (!rb || !tutorial_text_escaped(rb, term)) {
     break;
    }
    ++rb;
   }
   if (n[n_n - 1].expect_binary || !rb) {
    free_trigger_compiled_ops(c, n_c);
    mem_free(n);
    return PARSE_ERROR_INVALID_EXPRESSION;
   }
   s_expr = rb + 1;
   idx = 0;
   tval = 0;
   sval = 0;
   name = NULL;
   if (prefix(term, "ability:")) {
    enum parser_error ec = PARSE_ERROR_NONE;
    term += 8;
    kind = TRIGGER_OP_ABILITY;
    /* Find unescaped right colon. */
    colon = term;
    while (1) {
     colon = strchr(colon, ':');
     if (!colon || !tutorial_text_escaped(colon, term)) {
      break;
     }
     ++colon;
    }
    if (colon && colon < rb) {
     tmp = mem_alloc((colon - term) + 1);
     (void) tutorial_copy_strip_escapes(tmp,
      (colon - term) + 1, term,
      colon - term);
     idx = code_index_in_array(obj_mods,
      tmp);
     if (idx >= STAT_MAX + 1 &&
       idx <= STAT_MAX
       + SKILL_MAX) {
      idx -= STAT_MAX + 1;
     } else {
      ec = PARSE_ERROR_UNRECOGNISED_SKILL;
     }
     mem_free(tmp);
    } else {
     ec = PARSE_ERROR_UNRECOGNISED_SKILL;
    }
    if (ec != PARSE_ERROR_NONE) {
     free_trigger_compiled_ops(c, n_c);
     mem_free(n);
     return ec;
    }
    term = colon + 1;
    name = mem_alloc((rb - term) + 1);
    (void) tutorial_copy_strip_escapes(
     name, (rb - term) + 1, term,
     rb - term);
   } else if (prefix(term, "carried:")) {
    enum parser_error ec = PARSE_ERROR_NONE;
    term += 8;
    kind = TRIGGER_OP_CARRIED;
    /* Find unescaped right colon. */
    colon = term;
    while (1) {
     colon = strchr(colon, ':');
     if (!colon || !tutorial_text_escaped(colon, term)) {
      break;
     }
     ++colon;
    }
    if (colon && colon < rb) {
     tmp = mem_alloc((colon - term) + 1);
     (void) tutorial_copy_strip_escapes(tmp,
      (colon - term) + 1, term,
      colon - term);
     tval = tval_find_idx(tmp);
     mem_free(tmp);
     term = colon + 1;
     if (tval < 0) {
      ec = PARSE_ERROR_UNRECOGNISED_TVAL;
     }
    } else {
     ec = PARSE_ERROR_INVALID_EXPRESSION;
    }
    if (tval > 0) {
     tmp = mem_alloc((rb - term) + 1);
     (void) tutorial_copy_strip_escapes(tmp,
      (rb - term) + 1, term,
      rb - term);
     if (streq(tmp, "*")) {
      sval = -1;
     } else {
      sval = lookup_sval(tval, tmp);
      if (sval < 0) {
       ec = PARSE_ERROR_UNRECOGNISED_SVAL;
      }
     }
     mem_free(tmp);
    }
    if (ec != PARSE_ERROR_NONE) {
     free_trigger_compiled_ops(c, n_c);
     mem_free(n);
     return ec;
    }
   } else if (prefix(term, "drained:")) {
    term += 8;
    kind = TRIGGER_OP_DRAINED;
    tmp = mem_alloc((rb - term) + 1);
    (void) tutorial_copy_strip_escapes(tmp,
     (rb - term) + 1, term, rb - term);
    idx = get_drained_index(tmp);
    mem_free(tmp);
    if (idx == -1) {
     free_trigger_compiled_ops(c, n_c);
     mem_free(n);
     return PARSE_ERROR_INVALID_EXPRESSION;
    }
   } else if (prefix(term, "equipped:")) {
    enum parser_error ec = PARSE_ERROR_NONE;
    term += 9;
    kind = TRIGGER_OP_EQUIPPED;
    /* Find unescaped colon. */
    colon = term;
    while (1) {
     colon = strchr(colon, ':');
     if (!colon || !tutorial_text_escaped(colon, term)) {
      break;
     }
     ++colon;
    }
    if (colon && colon < rb) {
     tmp = mem_alloc((colon - term) + 1);
     (void) tutorial_copy_strip_escapes(tmp,
      (colon - term) + 1, term,
      colon - term);
     tval = tval_find_idx(tmp);
     mem_free(tmp);
     term = colon + 1;
     if (tval < 0) {
      ec = PARSE_ERROR_UNRECOGNISED_TVAL;
     }
    } else {
     ec = PARSE_ERROR_INVALID_EXPRESSION;
    }
    if (tval > 0) {
     tmp = mem_alloc((rb - term) + 1);
     (void) tutorial_copy_strip_escapes(tmp,
      (rb - term) + 1, term,
      rb - term);
     if (streq(tmp, "*")) {
      sval = -1;
     } else {
      sval = lookup_sval(tval, tmp);
      if (sval < 0) {
       ec = PARSE_ERROR_UNRECOGNISED_SVAL;
      }
     }
     mem_free(tmp);
    }
    if (ec != PARSE_ERROR_NONE) {
     free_trigger_compiled_ops(c, n_c);
     mem_free(n);
     return ec;
    }
   } else if (prefix(term, "false}")) {
    kind = TRIGGER_OP_FALSE;
   } else if (prefix(term, "timed:")) {
    enum parser_error ec = PARSE_ERROR_NONE;
    term += 6;
    /* Find unescaped colon. */
    colon = term;
    while (1) {
     colon = strchr(colon, ':');
     if (!colon || !tutorial_text_escaped(colon, term)) {
      break;
     }
     ++colon;
    }
    if (colon && colon < rb) {
     tmp = mem_alloc((colon - term) + 1);
     (void) tutorial_copy_strip_escapes(tmp,
      (colon - term) + 1, term,
      colon - term);
     idx = timed_name_to_idx(tmp);
     mem_free(tmp);
     if (idx < 0) {
      ec = PARSE_ERROR_INVALID_EXPRESSION;
     }
     term = colon + 1;
     if (prefix(term, "above:")) {
      kind = TRIGGER_OP_TIMED_ABOVE;
      term += 6;
     } else if (prefix(term, "below:")) {
      kind = TRIGGER_OP_TIMED_BELOW;
      term += 6;
     } else {
      ec = PARSE_ERROR_INVALID_EXPRESSION;
     }
     if (ec != PARSE_ERROR_INVALID_EXPRESSION) {
      name = mem_alloc((rb - term) + 1);
      (void) tutorial_copy_strip_escapes(
       name, (rb - term) + 1,
       term, rb - term);
     }
    } else {
     kind = TRIGGER_OP_TIMED;
     tmp = mem_alloc((rb - term) + 1);
     (void) tutorial_copy_strip_escapes(tmp,
      (rb - term) + 1, term,
      rb - term);
     idx = timed_name_to_idx(tmp);
     mem_free(tmp);
     if (idx < 0) {
      ec = PARSE_ERROR_INVALID_EXPRESSION;
     }
    }
    if (ec != PARSE_ERROR_NONE) {
     free_trigger_compiled_ops(c, n_c);
     mem_free(n);
     return ec;
    }
   } else if (prefix(term, "true}")) {
    kind = TRIGGER_OP_TRUE;
   } else {
    free_trigger_compiled_ops(c, n_c);
    mem_free(n);
    return PARSE_ERROR_INVALID_EXPRESSION;
   }
   add_trigger_op(&c, &n_c, &a_c, kind, tval, sval, idx,
    name);
   if (n[n_n - 1].pend[1] != TRIGGER_OP_NONE) {
    assert(n[n_n - 1].pend[1] == TRIGGER_OP_NOT);
    add_trigger_op(&c, &n_c, &a_c,
     n[n_n - 1].pend[1], 0, 0, 0, NULL);
    n[n_n - 1].pend[1] = TRIGGER_OP_NONE;
   }
   if (n[n_n - 1].pend[0] != TRIGGER_OP_NONE) {
    assert(n[n_n - 1].pend[0] == TRIGGER_OP_AND
     || n[n_n - 1].pend[0] == TRIGGER_OP_NOT
     || n[n_n - 1].pend[0] == TRIGGER_OP_OR
     || n[n_n - 1].pend[0] == TRIGGER_OP_XOR);
    add_trigger_op(&c, &n_c, &a_c,
     n[n_n - 1].pend[0], 0, 0, 0, NULL);
    n[n_n - 1].pend[0] = TRIGGER_OP_NONE;
   }
   n[n_n - 1].expect_binary = true;
   break;
  default:
   free_trigger_compiled_ops(c, n_c);
   mem_free(n);
   return PARSE_ERROR_INVALID_EXPRESSION;
  }
 }
 mem_free(n);
 priv->curr_value->v.trigger.expr.ops = c;
 priv->curr_value->v.trigger.expr.n_op = n_c;
 /* Determine the stack space that'll be needed. */
 priv->curr_value->v.trigger.expr.n_stack = 0;
 for (i = 0, curr_stack = 0; i < n_c; ++i) {
  switch (c[i].kind) {
  case TRIGGER_OP_ABILITY:
  case TRIGGER_OP_CARRIED:
  case TRIGGER_OP_DRAINED:
  case TRIGGER_OP_EQUIPPED:
  case TRIGGER_OP_FALSE:
  case TRIGGER_OP_TIMED:
  case TRIGGER_OP_TIMED_ABOVE:
  case TRIGGER_OP_TIMED_BELOW:
  case TRIGGER_OP_TRUE:
   /* Push one item onto the stack. */
   ++curr_stack;
   if (priv->curr_value->v.trigger.expr.n_stack
     < curr_stack) {
    priv->curr_value->v.trigger.expr.n_stack =
     curr_stack;
   }
   break;
  case TRIGGER_OP_NOT:
   /* Consumes one item and pushes one back for no change. */
   assert(curr_stack > 0);
   break;
  case TRIGGER_OP_AND:
  case TRIGGER_OP_OR:
  case TRIGGER_OP_XOR:
   /* Consume two items, push one back, for a change of -1.  */
   assert(curr_stack > 1);
   --curr_stack;
   break;
  default:
   assert(0);
   break;
  }
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_section_rows(struct parser *p)
{
 struct tutorial_parser_priv *priv = (struct tutorial_parser_priv*)
  parser_priv(p);
 enum parser_error result = PARSE_ERROR_NONE;
 if (priv->curr_value->key->comp == TUTORIAL_SECTION) {
  int rows = parser_getint(p, "value");
  if (rows > 0 && rows < z_info->dungeon_hgt - 1) {
   if (!priv->curr_value->v.section.lines) {
    priv->curr_value->v.section.rows = rows;
   } else {
    result = PARSE_ERROR_NON_SEQUENTIAL_RECORDS;
   }
  } else {
   result = PARSE_ERROR_INVALID_VALUE;
  }
 } else {
  result = PARSE_ERROR_UNDEFINED_DIRECTIVE;
 }
 return result;
}
static enum parser_error parse_section_columns(struct parser *p)
{
 struct tutorial_parser_priv *priv = (struct tutorial_parser_priv*)
  parser_priv(p);
 enum parser_error result = PARSE_ERROR_NONE;
 if (priv->curr_value->key->comp == TUTORIAL_SECTION) {
  int columns = parser_getint(p, "value");
  if (columns > 0 && columns < z_info->dungeon_wid - 1) {
   if (!priv->curr_value->v.section.lines) {
    priv->curr_value->v.section.columns = columns;
   } else {
    result = PARSE_ERROR_NON_SEQUENTIAL_RECORDS;
   }
  } else {
   result = PARSE_ERROR_INVALID_VALUE;
  }
 } else {
  result = PARSE_ERROR_UNDEFINED_DIRECTIVE;
 }
 return result;
}
static enum parser_error parse_section_area_flag(struct parser *p)
{
 struct tutorial_parser_priv *priv = (struct tutorial_parser_priv*)
  parser_priv(p);
 enum parser_error result = PARSE_ERROR_NONE;
 if (priv->curr_value->key->comp == TUTORIAL_SECTION) {
  result = tutorial_add_area_flags(p, priv->curr_value, false);
 } else {
  result = PARSE_ERROR_UNDEFINED_DIRECTIVE;
 }
 return result;
}
static enum parser_error parse_section_clear_area_flag(struct parser *p)
{
 struct tutorial_parser_priv *priv = (struct tutorial_parser_priv*)
  parser_priv(p);
 enum parser_error result = PARSE_ERROR_NONE;
 if (priv->curr_value->key->comp == TUTORIAL_SECTION) {
  result = tutorial_add_area_flags(p, priv->curr_value, true);
 } else {
  result = PARSE_ERROR_UNDEFINED_DIRECTIVE;
 }
 return result;
}
static enum parser_error parse_section_start_note(struct parser *p)
{
 struct tutorial_parser_priv *priv = (struct tutorial_parser_priv*)
  parser_priv(p);
 enum parser_error result = PARSE_ERROR_NONE;
 if (priv->curr_value->key->comp == TUTORIAL_SECTION) {
  const char* name = parser_getstr(p, "name");
  if (priv->curr_value->v.section.start_note_name) {
   string_free(priv->curr_value->v.section.start_note_name);
  }
  priv->curr_value->v.section.start_note_name = string_make(name);
 } else {
  result = PARSE_ERROR_UNDEFINED_DIRECTIVE;
 }
 return result;
}
static enum parser_error parse_trigger_or_section_death_note(struct parser *p)
{
 struct tutorial_parser_priv *priv = (struct tutorial_parser_priv*)
  parser_priv(p);
 enum parser_error result = PARSE_ERROR_NONE;
 if (priv->curr_value->key->comp == TUTORIAL_TRIGGER) {
  const char* name = parser_getstr(p, "name");
  if (priv->curr_value->v.trigger.death_note_name) {
   string_free(priv->curr_value->v.trigger.death_note_name);
  }
  priv->curr_value->v.trigger.death_note_name =
   (name[0]) ? string_make(name) : NULL;
  priv->curr_value->v.trigger.changes_death_note = true;
 } else if (priv->curr_value->key->comp == TUTORIAL_SECTION) {
  const char* name = parser_getstr(p, "name");
  if (priv->curr_value->v.section.death_note_name) {
   string_free(priv->curr_value->v.section.death_note_name);
  }
  priv->curr_value->v.section.death_note_name = string_make(name);
 } else {
  result = PARSE_ERROR_UNDEFINED_DIRECTIVE;
 }
 return result;
}
static enum parser_error parse_section_note(struct parser *p)
{
 struct tutorial_parser_priv *priv = (struct tutorial_parser_priv*)
  parser_priv(p);
 struct tutorial_section_sym_key *key;
 enum parser_error result;
 if (priv->curr_value->key->comp != TUTORIAL_SECTION) {
  return PARSE_ERROR_UNDEFINED_DIRECTIVE;
 }
 result = tutorial_section_parse_symbol(parser_getsym(p, "symbol"),
  priv, priv->curr_value->v.section.symt, &key);
 if (result == PARSE_ERROR_NONE) {
  struct tutorial_section_sym_val *value =
   mem_alloc(sizeof(*value));
  value->v.name = string_make(parser_getstr(p, "name"));
  value->is_predefined = false;
  value->kind = SECTION_SYM_NOTE;
  if (!tutorial_section_sym_table_insert(
    priv->curr_value->v.section.symt, key, value)) {
   tutorial_section_sym_value_free(value);
   mem_free(key);
   result = PARSE_ERROR_DUPLICATED_SYMBOL;
  }
 }
 return result;
}
static enum parser_error parse_section_trigger(struct parser *p)
{
 struct tutorial_parser_priv *priv = (struct tutorial_parser_priv*)
  parser_priv(p);
 struct tutorial_section_sym_key *key;
 enum parser_error result;
 if (priv->curr_value->key->comp != TUTORIAL_SECTION) {
  return PARSE_ERROR_UNDEFINED_DIRECTIVE;
 }
 result = tutorial_section_parse_symbol(parser_getsym(p, "symbol"),
  priv, priv->curr_value->v.section.symt, &key);
 if (result == PARSE_ERROR_NONE) {
  struct tutorial_section_sym_val *value =
   mem_alloc(sizeof(*value));
  value->v.name = string_make(parser_getstr(p, "name"));
  value->is_predefined = false;
  value->kind = SECTION_SYM_TRIGGER;
  if (!tutorial_section_sym_table_insert(
    priv->curr_value->v.section.symt, key, value)) {
   tutorial_section_sym_value_free(value);
   mem_free(key);
   result = PARSE_ERROR_DUPLICATED_SYMBOL;
  }
 }
 return result;
}
static enum parser_error parse_section_gate(struct parser *p)
{
 struct tutorial_parser_priv *priv = (struct tutorial_parser_priv*)
  parser_priv(p);
 int feat;
 struct tutorial_section_sym_key *key;
 enum parser_error result;
 if (priv->curr_value->key->comp != TUTORIAL_SECTION) {
  return PARSE_ERROR_UNDEFINED_DIRECTIVE;
 }
 feat = lookup_feat(parser_getsym(p, "terrain"));
 if (feat < 0) {
  return PARSE_ERROR_INVALID_TERRAIN;
 }
 result = tutorial_section_parse_symbol(parser_getsym(p, "symbol"),
  priv, priv->curr_value->v.section.symt, &key);
 if (result == PARSE_ERROR_NONE) {
  struct tutorial_section_sym_val *value =
   mem_alloc(sizeof(*value));
  value->v.gate.dest =
   string_make(parser_getsym(p, "destination"));
  value->v.gate.feat = feat;
  if (parser_hasval(p, "note")) {
   value->v.gate.note =
    string_make(parser_getstr(p, "note"));
  } else {
   value->v.gate.note = NULL;
  }
  value->is_predefined = false;
  value->kind = SECTION_SYM_GATE;
  if (!tutorial_section_sym_table_insert(
    priv->curr_value->v.section.symt, key, value)) {
   tutorial_section_sym_value_free(value);
   mem_free(key);
   result = PARSE_ERROR_DUPLICATED_SYMBOL;
  }
 }
 return result;
}
static enum parser_error parse_section_forge(struct parser *p)
{
 struct tutorial_parser_priv *priv = (struct tutorial_parser_priv*)
  parser_priv(p);
 const char *tstr = parser_getstr(p, "type");
 int feat = FEAT_NONE;
 struct tutorial_section_sym_key *key;
 enum parser_error result;
 if (priv->curr_value->key->comp != TUTORIAL_SECTION) {
  return PARSE_ERROR_UNDEFINED_DIRECTIVE;
 }
 if (streq(tstr, "NORMAL")) {
  feat = FEAT_FORGE;
 } else if (streq(tstr, "ENCHANTED")) {
  feat = FEAT_FORGE_GOOD;
 } else if (streq(tstr, "UNIQUE")) {
  feat = FEAT_FORGE_UNIQUE;
 } else {
  return PARSE_ERROR_INVALID_VALUE;
 }
 result = tutorial_section_parse_symbol(parser_getsym(p, "symbol"),
  priv, priv->curr_value->v.section.symt, &key);
 if (result == PARSE_ERROR_NONE) {
  struct tutorial_section_sym_val *value =
   mem_alloc(sizeof(*value));
  value->v.forge.feat = feat;
  value->v.forge.uses = parser_getint(p, "uses");
  value->is_predefined = false;
  value->kind = SECTION_SYM_FORGE;
  if (!tutorial_section_sym_table_insert(
    priv->curr_value->v.section.symt, key, value)) {
   tutorial_section_sym_value_free(value);
   mem_free(key);
   result = PARSE_ERROR_DUPLICATED_SYMBOL;
  }
 }
 return result;
}
static enum parser_error parse_section_object(struct parser *p)
{
 struct tutorial_parser_priv *priv = (struct tutorial_parser_priv*)
  parser_priv(p);
 int tval, sval;
 const char *numstr;
 dice_t *numdice;
 random_value rv;
 struct tutorial_section_sym_key *key;
 enum parser_error result;
 if (priv->curr_value->key->comp != TUTORIAL_SECTION) {
  return PARSE_ERROR_UNDEFINED_DIRECTIVE;
 }
 tval = tval_find_idx(parser_getsym(p, "tval"));
 if (tval < 0) {
  return PARSE_ERROR_UNRECOGNISED_TVAL;
 }
 sval = lookup_sval(tval, parser_getsym(p, "sval"));
 if (sval < 0) {
  return PARSE_ERROR_UNRECOGNISED_SVAL;
 }
 numstr = parser_getstr(p, "number");
 numdice = dice_new();
 if (!dice_parse_string(numdice, numstr)) {
  dice_free(numdice);
  return PARSE_ERROR_INVALID_DICE;
 }
 dice_random_value(numdice, &rv);
 dice_free(numdice);
 result = tutorial_section_parse_symbol(parser_getsym(p, "symbol"),
  priv, priv->curr_value->v.section.symt, &key);
 if (result == PARSE_ERROR_NONE) {
  struct tutorial_section_sym_val *value =
   mem_alloc(sizeof(*value));
  value->v.item.v.details.ego = NULL;
  value->v.item.v.details.tweaks = NULL;
  value->v.item.v.details.number = rv;
  value->v.item.v.details.tval = tval;
  value->v.item.v.details.sval = sval;
  value->v.item.v.details.tweak_count = 0;
  value->v.item.is_artifact = false;
  value->is_predefined = false;
  value->kind = SECTION_SYM_ITEM;
  if (!tutorial_section_sym_table_insert(
    priv->curr_value->v.section.symt, key, value)) {
   tutorial_section_sym_value_free(value);
   mem_free(key);
   result = PARSE_ERROR_DUPLICATED_SYMBOL;
  }
 }
 return result;
}
static enum parser_error parse_section_complex_object(struct parser *p)
{
 struct tutorial_parser_priv *priv = (struct tutorial_parser_priv*)
  parser_priv(p);
 int tval, sval;
 const char *numstr;
 dice_t *numdice;
 random_value rv;
 const char *ego;
 struct tutorial_item_tweak *tweaks;
 int tweak_count, tweak_alloc;
 struct tutorial_section_sym_key *key;
 enum parser_error result;
 if (priv->curr_value->key->comp != TUTORIAL_SECTION) {
  return PARSE_ERROR_UNDEFINED_DIRECTIVE;
 }
 tval = tval_find_idx(parser_getsym(p, "tval"));
 if (tval < 0) {
  return PARSE_ERROR_UNRECOGNISED_TVAL;
 }
 sval = lookup_sval(tval, parser_getsym(p, "sval"));
 if (sval < 0) {
  return PARSE_ERROR_UNRECOGNISED_SVAL;
 }
 numstr = parser_getsym(p, "number");
 numdice = dice_new();
 if (!dice_parse_string(numdice, numstr)) {
  dice_free(numdice);
  return PARSE_ERROR_INVALID_DICE;
 }
 dice_random_value(numdice, &rv);
 dice_free(numdice);
 ego = parser_getsym(p, "ego");
 result = tutorial_parse_tweaks(&tweaks, &tweak_count, &tweak_alloc,
  parser_getsym(p, "properties"), parser_getstr(p, "modifiers"));
 if (result != PARSE_ERROR_NONE) {
  tutorial_item_tweaks_free(tweaks, tweak_count);
  return result;
 }
 result = tutorial_section_parse_symbol(parser_getsym(p, "symbol"),
  priv, priv->curr_value->v.section.symt, &key);
 if (result == PARSE_ERROR_NONE) {
  struct tutorial_section_sym_val *value =
   mem_alloc(sizeof(*value));
  value->v.item.v.details.ego = streq(ego, "NONE") ?
   NULL : lookup_ego_item(ego, tval, sval);
  value->v.item.v.details.tweaks = tweaks;
  value->v.item.v.details.number = rv;
  value->v.item.v.details.tval = tval;
  value->v.item.v.details.sval = sval;
  value->v.item.v.details.tweak_count = tweak_count;
  value->v.item.is_artifact = false;
  value->is_predefined = false;
  value->kind = SECTION_SYM_ITEM;
  if (!tutorial_section_sym_table_insert(
    priv->curr_value->v.section.symt, key, value)) {
   tutorial_section_sym_value_free(value);
   mem_free(key);
   result = PARSE_ERROR_DUPLICATED_SYMBOL;
  }
 } else {
  tutorial_item_tweaks_free(tweaks, tweak_count);
 }
 return result;
}
static enum parser_error parse_section_artifact(struct parser *p)
{
 struct tutorial_parser_priv *priv = (struct tutorial_parser_priv*)
  parser_priv(p);
 const struct artifact *art;
 struct tutorial_section_sym_key *key;
 enum parser_error result;
 if (priv->curr_value->key->comp != TUTORIAL_SECTION) {
  return PARSE_ERROR_UNDEFINED_DIRECTIVE;
 }
 art = lookup_artifact_name(parser_getstr(p, "name"));
 if (!art) {
  return PARSE_ERROR_NO_ARTIFACT_NAME;
 }
 result = tutorial_section_parse_symbol(parser_getsym(p, "symbol"),
  priv, priv->curr_value->v.section.symt, &key);
 if (result == PARSE_ERROR_NONE) {
  struct tutorial_section_sym_val *value =
   mem_alloc(sizeof(*value));
  value->v.item.v.art = art;
  value->v.item.is_artifact = true;
  value->is_predefined = false;
  value->kind = SECTION_SYM_ITEM;
  if (!tutorial_section_sym_table_insert(
    priv->curr_value->v.section.symt, key, value)) {
   tutorial_section_sym_value_free(value);
   mem_free(key);
   result = PARSE_ERROR_DUPLICATED_SYMBOL;
  }
 }
 return result;
}
static enum parser_error parse_section_monster(struct parser *p)
{
 struct tutorial_parser_priv *priv = (struct tutorial_parser_priv*)
  parser_priv(p);
 struct monster_race *race;
 const char *alert_str;
 int sleepiness;
 bool sleepiness_fixed;
 struct tutorial_section_sym_key *key;
 enum parser_error result;
 if (priv->curr_value->key->comp != TUTORIAL_SECTION) {
  return PARSE_ERROR_UNDEFINED_DIRECTIVE;
 }
 race = lookup_monster(parser_getsym(p, "race"));
 if (race == NULL) {
  return PARSE_ERROR_INVALID_MONSTER;
 }
 alert_str = parser_getsym(p, "alertness");
 if (streq(alert_str, "ALERT")) {
  sleepiness = 0;
  sleepiness_fixed = true;
 } else if (streq(alert_str, "ASLEEP")) {
  sleepiness = race->sleep;
  sleepiness_fixed = (race->sleep <= 0);
 } else {
  char *p_end;
  long lalert = strtol(alert_str, &p_end, 10);
  if (alert_str[0] == '\0' || *p_end != '\0') {
   return PARSE_ERROR_INVALID_VALUE;
  }
  if (lalert < ALERTNESS_MIN || lalert > ALERTNESS_MAX) {
   return PARSE_ERROR_OUT_OF_BOUNDS;
  }
  sleepiness = ALERTNESS_ALERT - (int)lalert;
  sleepiness_fixed = true;
 }
 result = tutorial_section_parse_symbol(parser_getsym(p, "symbol"),
  priv, priv->curr_value->v.section.symt, &key);
 if (result == PARSE_ERROR_NONE) {
  struct tutorial_section_sym_val *value =
   mem_alloc(sizeof(*value));
  value->v.monster.race = race;
  if (parser_hasval(p, "note")) {
   value->v.monster.note =
    string_make(parser_getstr(p, "note"));
  } else {
   value->v.monster.note = NULL;
  }
  value->v.monster.sleepiness = sleepiness;
  value->v.monster.sleepiness_fixed = sleepiness_fixed;
  value->is_predefined = false;
  value->kind = SECTION_SYM_MONSTER;
  if (!tutorial_section_sym_table_insert(
    priv->curr_value->v.section.symt, key, value)) {
   tutorial_section_sym_value_free(value);
   mem_free(key);
   result = PARSE_ERROR_DUPLICATED_SYMBOL;
  }
 }
 return result;
}
static enum parser_error parse_section_trap(struct parser *p)
{
 const char *trap_flags[] = { "NONE", "VISIBLE", NULL };
 struct tutorial_parser_priv *priv = (struct tutorial_parser_priv*)
  parser_priv(p);
 struct trap_kind *trap;
 bool vis;
 char *flags, *s;
 struct tutorial_section_sym_key *key;
 enum parser_error result;
 if (priv->curr_value->key->comp != TUTORIAL_SECTION) {
  return PARSE_ERROR_UNDEFINED_DIRECTIVE;
 }
 trap = lookup_trap(parser_getsym(p, "name"));
 vis = false;
 flags = string_make(parser_getstr(p, "flags"));
 s = strtok(flags, " |");
 while (s) {
  int idx = lookup_flag(trap_flags, s);
  if (idx == 1) {
   vis = true;
  } else if (idx < 0) {
   string_free(flags);
   return PARSE_ERROR_INVALID_FLAG;
  }
  s = strtok(NULL, " |");
 }
 string_free(flags);
 result = tutorial_section_parse_symbol(parser_getsym(p, "symbol"),
  priv, priv->curr_value->v.section.symt, &key);
 if (result == PARSE_ERROR_NONE) {
  struct tutorial_section_sym_val *value =
   mem_alloc(sizeof(*value));
  value->v.trap.kind = trap;
  value->v.trap.vis = vis;
  value->is_predefined = false;
  value->kind = SECTION_SYM_TRAP;
  if (!tutorial_section_sym_table_insert(
    priv->curr_value->v.section.symt, key, value)) {
   tutorial_section_sym_value_free(value);
   mem_free(key);
   result = PARSE_ERROR_DUPLICATED_SYMBOL;
  }
 }
 return result;
}
static enum parser_error parse_section_door(struct parser *p)
{
 const char *door_flags[] = {
  "NONE",
  "BROKEN",
  "OPEN",
  "CLOSED",
  "SECRET",
  "LOCK_1",
  "LOCK_2",
  "LOCK_5",
  "LOCK_10",
  "LOCK_20",
  "LOCK_50",
  "STUCK_1",
  "STUCK_2",
  "STUCK_5",
  "STUCK_10",
  "STUCK_20",
  "STUCK_50",
  NULL
 };
 struct tutorial_parser_priv *priv = (struct tutorial_parser_priv*)
  parser_priv(p);
 int feat;
 int power;
 char *flags, *s;
 struct tutorial_section_sym_key *key;
 enum parser_error result;
 if (priv->curr_value->key->comp != TUTORIAL_SECTION) {
  return PARSE_ERROR_UNDEFINED_DIRECTIVE;
 }
 feat = FEAT_CLOSED;
 power = 0;
 flags = string_make(parser_getstr(p, "flags"));
 s = strtok(flags, " |");
 while (s) {
  int idx = lookup_flag(door_flags, s);
  switch (idx) {
   case 0: break;
   case 1: feat = FEAT_BROKEN; break;
   case 2: feat = FEAT_OPEN; break;
   case 3: feat = FEAT_CLOSED; break;
   case 4: feat = FEAT_SECRET; break;
   case 5: ++power; break;
   case 6: power += 2; break;
   case 7: power += 5; break;
   case 8: power += 10; break;
   case 9: power += 20; break;
   case 10: power += 50; break;
   case 11: --power; break;
   case 12: power -= 2; break;
   case 13: power -= 5; break;
   case 14: power -= 10; break;
   case 15: power -= 20; break;
   case 16: power -= 50; break;
   default:
    string_free(flags);
    return PARSE_ERROR_INVALID_FLAG;
  }
  s = strtok(NULL, " |");
 }
 string_free(flags);
 result = tutorial_section_parse_symbol(parser_getsym(p, "symbol"),
  priv, priv->curr_value->v.section.symt, &key);
 if (result == PARSE_ERROR_NONE) {
  struct tutorial_section_sym_val *value =
   mem_alloc(sizeof(*value));
  value->v.door.feat = feat;
  /*
		 * struct trap limits the lock power to a uint8_t; code in
		 * trap.c doesn't allow for secret doors to be locked or stuck.
		 */
  value->v.door.power = (feat == FEAT_CLOSED) ?
   MAX(MIN(power, 255), -255) : 0;
  value->is_predefined = false;
  value->kind = SECTION_SYM_DOOR;
  if (!tutorial_section_sym_table_insert(
    priv->curr_value->v.section.symt, key, value)) {
   tutorial_section_sym_value_free(value);
   mem_free(key);
   result = PARSE_ERROR_DUPLICATED_SYMBOL;
  }
 }
 return result;
}
static enum parser_error parse_section_line(struct parser *p)
{
 struct tutorial_parser_priv *priv = (struct tutorial_parser_priv*)
  parser_priv(p);
 const char *line;
 if (priv->curr_value->key->comp != TUTORIAL_SECTION) {
  return PARSE_ERROR_UNDEFINED_DIRECTIVE;
 }
 /* Need the rows and columns lines before this. */
 if (!priv->curr_value->v.section.rows
   || !priv->curr_value->v.section.columns) {
  return PARSE_ERROR_NON_SEQUENTIAL_RECORDS;
 }
 if (priv->section_lines_parsed == 0) {
  assert(!priv->curr_value->v.section.lines);
  priv->curr_value->v.section.lines = mem_zalloc(
   priv->curr_value->v.section.rows *
   sizeof(*(priv->curr_value->v.section.lines)));
 } else if (priv->section_lines_parsed
   >= priv->curr_value->v.section.rows) {
  return PARSE_ERROR_TOO_MANY_ENTRIES;
 }
 assert(!priv->curr_value->v.section.lines[priv->section_lines_parsed]);
 line = parser_getstr(p, "line");
 if (utf8_strlen(line) != (size_t) priv->curr_value->v.section.columns) {
  return PARSE_ERROR_VAULT_DESC_WRONG_LENGTH;
 }
 priv->curr_value->v.section.lines[priv->section_lines_parsed] =
  string_make(line);
 ++priv->section_lines_parsed;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_note_or_trigger_text(struct parser *p)
{
 struct tutorial_parser_priv *priv = (struct tutorial_parser_priv*)
  parser_priv(p);
 const char *text = parser_getstr(p, "contents");
 enum parser_error result = PARSE_ERROR_NONE;
 if (priv->curr_value->key->comp == TUTORIAL_NOTE) {
  priv->curr_value->v.note.text = string_append(
   priv->curr_value->v.note.text, text);
 } else if (priv->curr_value->key->comp == TUTORIAL_TRIGGER) {
  priv->curr_value->v.trigger.text = string_append(
   priv->curr_value->v.trigger.text, text);
 } else {
  result = PARSE_ERROR_UNDEFINED_DIRECTIVE;
 }
 return result;
}
static enum parser_error parse_archetype_or_section_flags(struct parser *p)
{
 struct tutorial_parser_priv *priv = (struct tutorial_parser_priv*)
  parser_priv(p);
 enum parser_error result = PARSE_ERROR_NONE;
 if (priv->curr_value->key->comp == TUTORIAL_ARCHETYPE
   || priv->curr_value->key->comp == TUTORIAL_SECTION) {
  char *flags = string_make(parser_getstr(p, "flags")), *s;
  s = strtok(flags, " |");
  while (s) {
   if (streq(s, "DEFAULT")) {
    if (priv->curr_value->key->comp
      == TUTORIAL_ARCHETYPE) {
     priv->r->default_archetype =
      priv->curr_value;
    } else {
     priv->r->default_section =
      priv->curr_value;
    }
   } else if (streq(s, "PURGE_NORMAL_KIT")
     && priv->curr_value->key->comp == TUTORIAL_ARCHETYPE) {
    priv->curr_value->v.archetype.purge_kit = true;
   } else {
    result = PARSE_ERROR_INVALID_FLAG;
   }
   s = strtok(NULL, " |");
  }
  string_free(flags);
 } else {
  result = PARSE_ERROR_UNDEFINED_DIRECTIVE;
 }
 return result;
}
/**
 * Run the parser for tutorial.txt.
 */
static errr tutorial_run_parser(struct parser *p)
{
 return parse_file_quit_not_found(p, "tutorial");
}
/**
 * Parse tutorial.txt.
 */
void tutorial_parse_data(void)
{
 run_parser(&tutorial_parser);
}
/**
 * Release the parsed data for the tutorial.
 */
void tutorial_cleanup_parsed_data(void)
{
 if (tutorial_parsed_data.d.d) {
  tutorial_dict_destroy(tutorial_parsed_data.d);
  tutorial_parsed_data.d.d = NULL;
 }
 tutorial_parsed_data.default_archetype = NULL;
 tutorial_parsed_data.default_section = NULL;
 mem_free(tutorial_parsed_data.pval_to_note_table);
 tutorial_parsed_data.pval_to_note_table = NULL;
 tutorial_cleanup_trigger_gate_map(
  tutorial_parsed_data.trigger_gate_map);
 tutorial_parsed_data.trigger_gate_map = NULL;
 tutorial_parsed_data.curr_death_note = NULL;
 tutorial_parsed_data.note_table_n = 0;
 tutorial_parsed_data.note_table_a = 0;
}
/**
 * Get a key's value from a tutorial section's symbol table.  This is a thin
 * layer of type checking over the generic dictionary type.
 */
struct tutorial_section_sym_val *tutorial_section_sym_table_has(
  struct tutorial_section_sym_table t,
  const struct tutorial_section_sym_key *key)
{
 return (struct tutorial_section_sym_val*) dict_has(t.d, key);
}
/**
 * Get a key's value from the tutorial's dictionary.  This is a thin
 * layer of type checking over the generic dictionary type.
 */
struct tutorial_dict_val_type *tutorial_dict_has(struct tutorial_dict_type d,
  const struct tutorial_dict_key_type *key)
{
 return (struct tutorial_dict_val_type*) dict_has(d.d, key);
}
/**
 * Return whether a character has been escaped.
 *
 * \param cursor is the location of the character to check.
 * \param limit is the bound for how far back before cursor to check.
 */
bool tutorial_text_escaped(const char *cursor, const char *limit)
{
 int count = 0;
 /*
	 * An odd number of backslashes immediately prior to it means it's
	 * escaped.
	 */
 while (cursor > limit && *(cursor - 1) == '\\') {
  ++count;
  --cursor;
 }
 return (count & 1) != 0;
}
/**
 * Copy from src to dest while handling backslashes.
 *
 * \param dest is the destination for the copy.
 * \param sz is the maximum number of characters, including a terminating null,
 * to copy.
 * \param src is the source for the copy.
 * \param rd is the maximum number of characters to consume from src.
 * \return the number of characters, not including the terminating null,
 * consumed from src.
 */
size_t tutorial_copy_strip_escapes(char *dest, size_t sz, const char *src,
  size_t rd)
{
 size_t out = 0;
 const char *start = src;
 if (sz == 0) return 0;
 while (out < sz - 1 && *src && (size_t)(src - start) < rd) {
  if (*src == '\\') {
   ++src;
   if (*src && (size_t)(src - start) < rd) {
    *dest = *src;
    ++src;
   } else {
    *dest = '\\';
   }
  } else {
   *dest = *src;
   ++src;
  }
  ++dest;
  ++out;
 }
 *dest = '\0';
 return src - start;
}
/**
 * Cleanup the lookup for the triggers and gates.
 */
void tutorial_cleanup_trigger_gate_map(struct tutorial_dict_val_type ***m)
{
 int i = 0;
 if (!m) return;
 /* Free each row until the sentinel is reached. */
 while (m[i]) {
  assert(i < z_info->dungeon_hgt);
  mem_free(m[i]);
  ++i;
 }
 mem_free(m);
}
/**
 * Set up the parser for tutorial.txt.
 */
struct parser *tutorial_init_parser(void)
{
 struct parser *p = parser_new();
 struct tutorial_parser_priv *priv = mem_zalloc(sizeof(*priv));
 struct tutorial_dict_key_type *tutorial_exit_key;
 struct tutorial_dict_val_type *tutorial_exit;
 priv->r = &tutorial_parsed_data;
 priv->r->d = tutorial_dict_create();
 /*
	 * Insert a placeholder that looks like a tutorial section for exiting
	 * the tutorial.
	 */
 tutorial_exit_key = mem_alloc(sizeof(*tutorial_exit_key));
 tutorial_exit_key->name = string_make("EXIT");
 tutorial_exit_key->comp = TUTORIAL_SECTION;
 tutorial_exit = mem_zalloc(sizeof(*tutorial_exit));
 if (!tutorial_dict_insert(priv->r->d, tutorial_exit_key,
   tutorial_exit)) {
  mem_free(tutorial_exit);
  mem_free(tutorial_exit_key);
  mem_free(priv);
  parser_destroy(p);
  return NULL;
 }
 tutorial_exit->key = tutorial_exit_key;
 priv->r->default_archetype = NULL;
 priv->r->default_section = NULL;
 priv->r->pval_to_note_table = NULL;
 priv->r->note_kind = lookup_kind(TV_NOTE,
  lookup_sval(TV_NOTE, "tutorial note"));
 if (!priv->r->note_kind) {
  mem_free(priv);
  parser_destroy(p);
  return NULL;
 }
 priv->r->note_table_n = 0;
 priv->r->note_table_a = 0;
 parser_setpriv(p, priv);
 /* These are the lines that introduce various blocks. */
 parser_reg(p, "archetype str name", parse_archetype_block_start);
 parser_reg(p, "note str name", parse_note_block_start);
 parser_reg(p, "trigger str name", parse_trigger_block_start);
 parser_reg(p, "section str name", parse_section_block_start);
 /* These are specific to the archetype block. */
 parser_reg(p, "race str name", parse_archetype_race);
 parser_reg(p, "house str name", parse_archetype_house);
 parser_reg(p, "sex str name", parse_archetype_sex);
 parser_reg(p, "name str name", parse_archetype_character_name);
 parser_reg(p, "history str history", parse_archetype_history);
 /*
	 * Parse as a string to avoid the ambiguity of whether an int has
	 * sufficient range for an int32_t.
	 */
 parser_reg(p, "experience str value", parse_archetype_experience);
 parser_reg(p, "stats str values", parse_archetype_stats);
 parser_reg(p, "skills str values", parse_archetype_skills);
 parser_reg(p, "abilities str values", parse_archetype_abilities);
 parser_reg(p, "object sym tval sym sval sym number sym equipped",
  parse_archetype_object);
 parser_reg(p, "complex-object sym tval sym sval sym number "
  "sym equipped sym ego sym properties str modifiers",
  parse_archetype_complex_object);
 parser_reg(p, "artifact sym name sym equipped",
  parse_archetype_artifact);
 /* These are specific to the trigger block. */
 parser_reg(p, "condition str expression", parse_trigger_condition);
 /* These are specific to the section block. */
 parser_reg(p, "rows int value", parse_section_rows);
 parser_reg(p, "columns int value", parse_section_columns);
 parser_reg(p, "area-flag int xul int yul int xlr int ylr str flags",
  parse_section_area_flag);
 parser_reg(p, "clear-area-flag int xul int yul int xlr int ylr "
  "str flags", parse_section_clear_area_flag);
 parser_reg(p, "start-note str name", parse_section_start_note);
 parser_reg(p, "place-note sym symbol str name",
  parse_section_note);
 parser_reg(p, "place-trigger sym symbol str name",
  parse_section_trigger);
 parser_reg(p, "gate sym symbol sym destination sym terrain ?str note",
  parse_section_gate);
 parser_reg(p, "forge sym symbol int uses str type",
  parse_section_forge);
 parser_reg(p, "place-object sym symbol sym tval sym sval str number",
  parse_section_object);
 parser_reg(p, "place-complex-object sym symbol sym tval sym sval "
  "sym number sym ego sym properties str modifiers",
  parse_section_complex_object);
 parser_reg(p, "place-artifact sym symbol str name",
  parse_section_artifact);
 parser_reg(p, "monster sym symbol sym race sym alertness ?str note",
  parse_section_monster);
 parser_reg(p, "trap sym symbol sym name str flags", parse_section_trap);
 parser_reg(p, "door sym symbol str flags", parse_section_door);
 parser_reg(p, "D str line", parse_section_line);
 /* These are shared by the note and trigger blocks. */
 parser_reg(p, "text str contents", parse_note_or_trigger_text);
 /* These are shared by archetype and section blocks. */
 parser_reg(p, "flags str flags", parse_archetype_or_section_flags);
 /* These are shared by the trigger and section blocks. */
 parser_reg(p, "death-note str name",
  parse_trigger_or_section_death_note);
 return p;
}
/**
 * Cleanup the parser for tutorial.txt; handle any post-processing of the
 * parsed results.
 */
errr tutorial_finish_parser(struct parser *p)
{
 struct tutorial_parser_priv *priv = (struct tutorial_parser_priv*)
  parser_priv(p);
 struct tutorial_dict_val_type *last_val = priv->curr_value;
 int n_lines = priv->section_lines_parsed;
 mem_free(priv);
 parser_destroy(p);
 if (last_val && last_val->key->comp == TUTORIAL_SECTION) {
  if (n_lines < last_val->v.section.rows) {
   return PARSE_ERROR_TOO_FEW_ENTRIES;
  }
  verify_section(last_val);
 }
 return 0;
}
/**
 * \file ui-abilities.c
 * \brief Text-based user interface for player abilities
 *
 * Copyright (c) 1987 - 2022 Angband contributors
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
static struct ability **skill_abilities;
static struct bane_type {
 int kills;
 const char *name;
} bane_types[] = {
/**
 * \file src/list-bane-types.h
 * \brief player bane types
 */
{ 0, "Nothing" },
{ 0, "Orc" },
{ 0, "Wolf" },
{ 0, "Spider" },
{ 0, "Troll" },
{ 0, "Wraith" },
{ 0, "Rauko" },
{ 0, "Serpent" },
{ 0, "Dragon" },

};
static int get_skill_abilities(int skill)
{
 struct ability *a = abilities;
 int count = 0;
 while (a) {
  if (a->skill == skill) skill_abilities[count++] = a;
  a = a->next;
 }
 return count;
}
/**
 * Display an entry in the bane menu.
 */
static void bane_display(struct menu *menu, int oid, bool cursor, int row,
       int col, int width)
{
 struct bane_type *choice = menu->menu_data;
 uint8_t name_attr = (oid && choice[oid].kills < 4)
  ? COLOUR_L_DARK : COLOUR_SLATE;
 c_put_str(name_attr, choice[oid].name, row, col);
 if (cursor) {
  textblock *tb = textblock_new();
  region area;
  area.col = col - 7;
  area.row = row + (menu->count - oid) + 1;
  area.width = -1;
  area.page_rows = -1;
  if (!oid) {
   textblock_append(tb,
    "                                            "
    "                  ");
  } else if (choice[oid].kills >= 4) {
   textblock_append(tb,
    "You have slain %d of these foes.            "
    "                  ", choice[oid].kills);
  } else {
   textblock_append(tb,
    "You have slain %d of these foes and need to "
    "slay %d more.", choice[oid].kills,
    4 - choice[oid].kills);
  }
  textui_textblock_place(tb, area, NULL);
  textblock_free(tb);
 }
}
/**i
 * Handle keypresses in the bane menu.
 */
static bool bane_action(struct menu *m, const ui_event *event, int oid)
{
 if ((event->type == EVT_SELECT) && oid) {
  struct bane_type *choice = m->menu_data;
  if (choice[oid].kills < 4) {
   /* Need 4 kills to select. */
   return true;
  }
  player->bane_type = oid;
 }
 return false;
}
/**
 * Display the bane menu.
 */
static bool bane_menu(void)
{
 struct menu menu;
 menu_iter menu_f = { NULL, NULL, bane_display, bane_action, NULL };
 region area = { 46, 4, -1,
  (int)N_ELEMENTS(bane_types) + 3 };
 ui_event menu_result;
 int i;
 bane_types[0].kills = 0;
 for (i = 1; i < (int)N_ELEMENTS(bane_types); ++i) {
  bane_types[i].kills = player_bane_type_killed(i);
 }
 menu_init(&menu, MN_SKIN_SCROLL, &menu_f);
 menu.title = "Enemy types";
 menu.selections = lower_case;
 menu_setpriv(&menu, N_ELEMENTS(bane_types), bane_types);
 menu_layout(&menu, &area);
 screen_save();
 /* Erase to the bottom of the terminal. */
 area.page_rows = -1;
 region_erase(&area);
 menu_result = menu_select(&menu, 0, false);
 screen_load();
 return menu_result.type == EVT_SELECT && player->bane_type != 0;
}
/**
 * Display an entry in the ability menu.
 */
static void ability_display(struct menu *menu, int oid, bool cursor, int row,
       int col, int width)
{
 struct ability **choice = menu->menu_data;
 struct ability *innate = locate_ability(player->abilities, choice[oid]);
 struct ability *item = locate_ability(player->item_abilities, choice[oid]);
 const char *name = choice[oid]->name;
 char *name_allocated = NULL;
 uint8_t attr = COLOUR_L_DARK;
 int points = player->skill_base[choice[oid]->skill];
 int points_needed = choice[oid]->level;
 if (innate) {
  attr = innate->active ? COLOUR_WHITE : COLOUR_RED;
  if (innate->skill == SKILL_PERCEPTION
    && streq(innate->name, "Bane")
    && player->bane_type > 0) {
   name_allocated = string_make(format("%s-Bane",
    bane_types[player->bane_type].name));
   name = name_allocated;
  }
 } else if (item) {
  attr = item->active ? COLOUR_L_GREEN : COLOUR_RED;
 } else if (player_has_prereq_abilities(player, choice[oid]) &&
      (points >= points_needed)) {
  attr = COLOUR_SLATE;
 }
 c_put_str(attr, name, row, col);
 string_free(name_allocated);
}
/**
 * Handle keypresses in the ability menu.
 */
static bool ability_action(struct menu *m, const ui_event *event, int oid)
{
 struct ability **choice = m->menu_data;
 struct ability *possessed = locate_ability(player->abilities, choice[oid]);
 bool points = player->skill_base[choice[oid]->skill] >= choice[oid]->level;
 /* Check for item abilities */
 if (!possessed) {
  possessed = locate_ability(player->item_abilities, choice[oid]);
 }
 if (event->type == EVT_SELECT) {
  if (possessed) {
   if (possessed->active) {
    possessed->active = false;
    put_str("Ability now switched off.", 0, 0);
   } else {
    possessed->active = true;
    put_str("Ability now switched on.", 0, 0);
   }
  } else if (player_has_prereq_abilities(player, choice[oid]) && points) {
   if (player_can_gain_ability(player, choice[oid])) {
    if (streq(choice[oid]->name, "Bane")) {
     if (!bane_menu()) return false;
    }
    if (player_gain_ability(player, choice[oid])) {
     put_str("Ability gained.", 0, 0);
    } else if (streq(choice[oid]->name, "Bane")) {
     /* Rejected the selection so clear. */
     player->bane_type = 0;
    }
   } else {
    msg("You do not have enough experience to acquire this ability.");
   }
  } else {
   msg("Insufficient prerequisites for ability!");
  }
  return true;
 }
 return false;
}
/**
 * Show ability data
 */
static void ability_browser(int oid, void *data, const region *loc)
{
 struct ability **choice = data;
 struct ability *current = choice[oid];
 bool learned = player_has_ability(player, current);
 uint8_t attr = COLOUR_L_DARK;
 bool points = player->skill_base[current->skill] >= current->level;
 /* Redirect output to the screen */
 text_out_hook = text_out_to_screen;
 text_out_wrap = 79;
 text_out_indent = 46;
 Term_gotoxy(text_out_indent, 4);
 /* Print the description of the current ability */
 if (current->desc) {
  text_out_c(COLOUR_L_WHITE, "%s", current->desc);
 }
 /* Print more info if you don't have the skill */
 if (!learned) {
  struct ability *prereq = current->prerequisites;
  bool ready = player_has_prereq_abilities(player, current);
  int line = 0;
  if (ready && points) {
   attr = COLOUR_SLATE;
  }
  Term_gotoxy(text_out_indent, 10);
  text_out_c(attr, "Prerequisites:");
  Term_gotoxy(text_out_indent, 12);
  if (points) {
   text_out_c(COLOUR_SLATE, "  %d skill points", current->level);
  } else {
   text_out_c(COLOUR_L_DARK, "  %d skill points (you have %d)",
        current->level, player->skill_base[current->skill]);
  }
  Term_gotoxy(text_out_indent + 2, 13);
  while (prereq) {
   if (locate_ability(player->abilities, prereq)) {
    attr = COLOUR_SLATE;
   } else {
    attr = COLOUR_L_DARK;
   }
   text_out_c(attr, "%s", prereq->name);
   prereq = prereq->next;
   line++;
   if (prereq) {
    Term_gotoxy(text_out_indent + 2, 13 + line);
    text_out_c(COLOUR_L_DARK, "or ");
   }
  }
  if (ready) {
   int exp_cost = player_ability_cost(player, current);
   bool have_exp = player_can_gain_ability(player, current);
   attr = have_exp ? COLOUR_SLATE : COLOUR_L_DARK;
   Term_gotoxy(text_out_indent, 16);
   text_out_c(attr, "Current price:");
   Term_gotoxy(text_out_indent + 2, 18);
   if (have_exp) {
    text_out_c(attr, "%d experience", exp_cost);
   } else {
    text_out_c(attr, "%d experience (you have %d)", exp_cost,
         player->new_exp);
   }
  }
 } else if (current->skill == SKILL_PERCEPTION
   && streq(current->name, "Bane")
   && player->bane_type > 0) {
  /* Or if you have the ability and it is Bane... */
  Term_gotoxy(text_out_indent, 10);
  text_out_c(COLOUR_WHITE, "%s-Bane:",
   bane_types[player->bane_type].name);
  Term_gotoxy(text_out_indent + 2, 12);
  text_out_c(COLOUR_WHITE, "%d slain, giving a %+d bonus",
   bane_types[player->bane_type].kills,
   calc_bane_bonus(player));
 }
}
/**
 * Display an entry in the skill menu.
 */
static void skill_display(struct menu *menu, int oid, bool cursor, int row,
       int col, int width)
{
 char **choice = menu->menu_data;
 uint8_t attr = (cursor ? COLOUR_L_BLUE : COLOUR_WHITE);
 c_put_str(attr, choice[oid], row, col);
}
/**
 * Handle keypresses in the skill menu.
 */
static bool skill_action(struct menu *m, const ui_event *event, int oid)
{
 struct menu menu;
 menu_iter menu_f = { NULL, NULL, ability_display, ability_action, NULL };
 region area = { 17, 2, 46 - 17 - 5, 0 };
 int count;
 menu_init(&menu, MN_SKIN_SCROLL, &menu_f);
 menu.title = "Abilities";
 skill_abilities = mem_zalloc(100 * sizeof(struct ability*));
 count = get_skill_abilities(oid);
 if (count) {
  menu_setpriv(&menu, count, skill_abilities);
  menu.browse_hook = ability_browser;
  menu.selections = lower_case;
  menu.flags = MN_CASELESS_TAGS;
  menu_layout(&menu, &area);
  menu_select(&menu, 0, true);
 }
 mem_free(skill_abilities);
 return true;
}
/**
 * Display the abilities main menu.
 */
void do_cmd_abilities(void)
{
 struct menu menu;
 menu_iter menu_f = { NULL, NULL, skill_display, skill_action, NULL };
 const char *skill_names[] = {
/**
 * \file src/list-skills.h
 * \brief player skills
 *
 * Changing skill order or making new ones will break savefiles. Skills
 * below start from 0 on line 11, so a skill's sequence number is its line
 * number minus 11.
 *
 * Skill properties are not defined in lib/gamedata/object_property.txt
 */
"Melee",
"Archery",
"Evasion",
"Stealth",
"Perception",
"Will",
"Smithing",
"Song",

 };
 ui_event evt = EVENT_EMPTY;
 screen_save();
 clear_from(0);
 /* Set up the menu */
 menu_init(&menu, MN_SKIN_SCROLL, &menu_f);
 menu.title = "Skills";
 menu_setpriv(&menu, SKILL_MAX, skill_names);
 menu.selections = lower_case;
 menu.flags = MN_CASELESS_TAGS;
 menu_layout(&menu, &SCREEN_REGION);
 /* Select an entry */
 while (evt.type != EVT_ESCAPE)
  evt = menu_select(&menu, 0, false);
 screen_load();
}
/**
 * \file ui-birth.c
 * \brief Text-based user interface for character creation
 *
 * Copyright (c) 1987 - 2015 Angband contributors
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Overview
 * ========
 * This file implements the user interface side of the birth process
 * for the classic terminal-based UI of Angband.
 *
 * It models birth as a series of steps which must be carried out in 
 * a specified order, with the option of stepping backwards to revisit
 * past choices.
 *
 * It starts when we receive the EVENT_ENTER_BIRTH event from the game,
 * and ends when we receive the EVENT_LEAVE_BIRTH event.  In between,
 * we will repeatedly be asked to supply a game command, which change
 * the state of the character being rolled.  Once the player is happy
 * with their character, we send the CMD_ACCEPT_CHARACTER command.
 */
/**
 * A local-to-this-file global to hold the most important bit of state
 * between calls to the game proper.  Probably not strictly necessary,
 * but reduces complexity a bit. */
enum birth_stage
{
 BIRTH_BACK = -1,
 BIRTH_RESET = 0,
 BIRTH_QUICKSTART,
 BIRTH_RACE_CHOICE,
 BIRTH_HOUSE_CHOICE,
 BIRTH_SEX_CHOICE,
 BIRTH_STAT_POINTS,
 BIRTH_SKILL_POINTS,
 BIRTH_NAME_CHOICE,
 BIRTH_AHW_CHOICE,
 BIRTH_HISTORY_CHOICE,
 BIRTH_FINAL_CONFIRM,
 BIRTH_COMPLETE
};
enum birth_questions
{
 BQ_METHOD = 0,
 BQ_RACE,
 BQ_HOUSE,
 MAX_BIRTH_QUESTIONS
};
const char *list_player_flag_names[] = {
/**
 * \file list-player-flags.h
 * \brief player race and class flags
 *
 * Adjusting these flags does not break savefiles. Flags below start from 1
 * on line 14, so a flag's sequence number is its line number minus 13.
 *
 * Fields:
 * symbol - the flag name
 * additional details in player_property.txt
 */
"",
"Blade proficiency",
"Axe proficiency",

 NULL
};
static bool quickstart_allowed = false;
bool arg_force_name;
/**
 * ------------------------------------------------------------------------
 * Quickstart? screen.
 * ------------------------------------------------------------------------ */
static enum birth_stage textui_birth_quickstart(void)
//phantom name change changes
{
 const char *prompt = "['Y': use as is; 'N': redo; 'C': change name/history; '=': set birth options]";
 enum birth_stage next = BIRTH_QUICKSTART;
 /* Prompt for it */
 prt("New character based on previous one:", 0, 0);
 prt(prompt, Term->hgt - 1, Term->wid / 2 - strlen(prompt) / 2);
 do {
  /* Get a key */
  struct keypress ke = inkey();
  if (ke.code == 'N' || ke.code == 'n') {
   cmdq_push(CMD_BIRTH_RESET);
   /*
			 * If the player rejects the quickstart, also reset
			 * the stat buy that was used for the previous
			 * character.
			 */
   cmdq_push(CMD_RESET_STATS);
   next = BIRTH_RACE_CHOICE;
  } else if (ke.code == KTRL('X')) {
   quit(NULL);
  } else if ( !arg_force_name && (ke.code == 'C' || ke.code == 'c')) {
   next = BIRTH_NAME_CHOICE;
  } else if (ke.code == '=') {
   do_cmd_options_birth();
  } else if (ke.code == 'Y' || ke.code == 'y') {
   cmdq_push(CMD_ACCEPT_CHARACTER);
   next = BIRTH_COMPLETE;
  }
 } while (next == BIRTH_QUICKSTART);
 /* Clear prompt */
 clear_from(23);
 return next;
}
/**
 * ------------------------------------------------------------------------
 * The various "menu" bits of the birth process - namely choice of race,
 * house, and sex.
 * ------------------------------------------------------------------------ */
/**
 * The various menus
 */
static struct menu race_menu, house_menu, sex_menu;
static int house_start = 0;
/**
 * Locations of the menus, etc. on the screen
 */
/**
 * upper left column and row, width, and lower column
 */
static region race_region = {2, 9, 17, 9 + 14};
static region house_region = {19, 9, 17, 9 + 14};
static region sex_region = {42, 9, 34, 9 + 14};
/**
 * We use different menu "browse functions" to display the help text
 * sometimes supplied with the menu items - currently just the list
 * of bonuses, etc, corresponding to each race and house.
 */
typedef void (*browse_f) (int oid, void *db, const region *l);
/**
 * We have one of these structures for each menu we display - it holds
 * the useful information for the menu - text of the menu items, "help"
 * text, current (or default) selection, whether random selection is allowed,
 * and the current stage of the process for setting up a context menu and
 * relaying the reuslt of a selection in that menu.
 */
struct birthmenu_data
{
 const char **items;
 const char *hint;
 bool allow_random;
 enum birth_stage stage_inout;
};
/**
 * A custom "display" function for our menus that simply displays the
 * text from our stored data in a different colour if it's currently
 * selected.
 */
static void birthmenu_display(struct menu *menu, int oid, bool cursor,
         int row, int col, int width)
{
 struct birthmenu_data *data = menu->menu_data;
 uint8_t attr = curs_attrs[CURS_KNOWN][0 != cursor];
 c_put_str(attr, data->items[oid], row, col);
}
/**
 * Our custom menu iterator, only really needed to allow us to override
 * the default handling of "commands" in the standard iterators (hence
 * only defining the display and handler parts).
 */
static const menu_iter birth_iter = { NULL, NULL, birthmenu_display, NULL, NULL };
static int stat_attr(int adj)
{
 int attr;
 if (adj < 0) {
  attr = COLOUR_RED;
 } else if (adj == 0) {
  attr = COLOUR_L_DARK;
 } else if (adj == 1) {
  attr = COLOUR_GREEN;
 } else if (adj == 2) {
  attr = COLOUR_L_GREEN;
 } else {
  attr = COLOUR_L_BLUE;
 }
 return attr;
}
static void race_help(int i, void *db, const region *l)
{
 int j;
 struct player_race *r = player_id2race(i);
 if (!r) return;
 /* Output to the screen */
 text_out_hook = text_out_to_screen;
 clear_from(14);
 /* Indent output */
 text_out_indent = 19;
 Term_gotoxy(19, 9);
 for (j = 0; j < STAT_MAX; j++) {
  const char *name = stat_names_reduced[j];
  int adj = r->stat_adj[j];
  text_out_e("%s", name);
  text_out_c(stat_attr(adj), "%+3d", adj);
  text_out("\n");
 }
 text_out_e("\n");
 for (j = 0; j < SKILL_MAX; j++) {
  int adj = r->skill_adj[j];
  if (adj > 0) {
   text_out_c(COLOUR_GREEN, "%s affinity\n", skill_names[j]);
  } else if (adj < 0) {
   text_out_c(COLOUR_RED, "%s penalty\n", skill_names[j]);
  }
 }
 for (j = 0; j < PF_MAX; j++) {
  if (pf_has(r->pflags, j)) {
   text_out_c(COLOUR_GREEN, "%s\n", list_player_flag_names[j]);
  }
 }
 Term_gotoxy(19, 18);
 text_out_c(COLOUR_L_WHITE, "%s", r->desc);
 /* Reset text_out() indentation */
 text_out_indent = 0;
}
static void house_help(int i, void *db, const region *l)
{
 int j;
 const struct player_race *r = player->race;
 struct player_house *h = player_house_from_count(i);
 if (!h) return;
 /* Output to the screen */
 text_out_hook = text_out_to_screen;
 clear_from(14);
 /* Indent output */
 text_out_indent = 42;
 Term_gotoxy(42, 9);
 for (j = 0; j < STAT_MAX; j++) {
  const char *name = stat_names_reduced[j];
  int adj = r->stat_adj[j] + h->stat_adj[j];
  text_out_e("%s", name);
  text_out_c(stat_attr(adj), "%+3d", adj);
  text_out("\n");
 }
 text_out_e("\n");
 for (j = 0; j < SKILL_MAX; j++) {
  int adj = r->skill_adj[j] + h->skill_adj[j];
  if (adj > 1) {
   text_out_c(COLOUR_L_GREEN, "%s mastery\n", skill_names[j]);
  } else if (adj > 0) {
   text_out_c(COLOUR_GREEN, "%s affinity\n", skill_names[j]);
  } else if (adj < 0) {
   text_out_c(COLOUR_RED, "%s penalty\n", skill_names[j]);
  }
 }
 for (j = 0; j < PF_MAX; j++) {
  if (pf_has(r->pflags, j)) {
   text_out_c(COLOUR_GREEN, "%s\n", list_player_flag_names[j]);
  }
 }
 Term_gotoxy(42, 18);
 text_out_c(COLOUR_L_WHITE, "%s", h->desc);
 /* Reset text_out() indentation */
 text_out_indent = 0;
}
static void sex_help(int i, void *db, const region *l)
{
 clear_from(14);
}
/**
 * Display and handle user interaction with a context menu appropriate for the
 * current stage.  That way actions available with certain keys are also
 * available if only using the mouse.
 *
 * \param current_menu is the standard (not contextual) menu for the stage.
 * \param in is the event triggering the context menu.  in->type must be
 * EVT_MOUSE.
 * \param out is the event to be passed upstream (to internal handling in
 * menu_select() or, potentially, menu_select()'s caller).
 * \return true if the event was handled; otherwise, return false.
 *
 * The logic here overlaps with what's done to handle cmd_keys in
 * menu_question().
 */
static bool use_context_menu_birth(struct menu *current_menu,
  const ui_event *in, ui_event *out)
{
 enum {
  ACT_CTX_BIRTH_OPT,
  ACT_CTX_BIRTH_RAND,
  ACT_CTX_BIRTH_QUIT,
  ACT_CTX_BIRTH_HELP
 };
 struct birthmenu_data *menu_data = menu_priv(current_menu);
 char *labels;
 struct menu *m;
 int selected;
 assert(in->type == EVT_MOUSE);
 if (in->mouse.y != 7 && in->mouse.y != 7 + 1) {
  return false;
 }
 labels = string_make(lower_case);
 m = menu_dynamic_new();
 m->selections = labels;
 menu_dynamic_add_label(m, "Show birth options", '=',
  ACT_CTX_BIRTH_OPT, labels);
 if (menu_data->allow_random) {
  menu_dynamic_add_label(m, "Select one at random", '*',
   ACT_CTX_BIRTH_RAND, labels);
 }
 menu_dynamic_add_label(m, "Quit", 'q', ACT_CTX_BIRTH_QUIT, labels);
 menu_dynamic_add_label(m, "Help", '?', ACT_CTX_BIRTH_HELP, labels);
 screen_save();
 menu_dynamic_calc_location(m, in->mouse.x, in->mouse.y);
 region_erase_bordered(&m->boundary);
 selected = menu_dynamic_select(m);
 menu_dynamic_free(m);
 string_free(labels);
 screen_load();
 switch (selected) {
 case ACT_CTX_BIRTH_OPT:
  do_cmd_options_birth();
  /* The stage remains the same so leave stage_inout as is. */
  out->type = EVT_SWITCH;
  break;
 case ACT_CTX_BIRTH_RAND:
  current_menu->cursor = randint0(current_menu->count);
  out->type = EVT_SELECT;
  break;
 case ACT_CTX_BIRTH_QUIT:
  quit(NULL);
  break;
 case ACT_CTX_BIRTH_HELP:
  do_cmd_help();
  menu_data->stage_inout = BIRTH_RESET;
  out->type = EVT_SWITCH;
 default:
  /* There's nothing to do. */
  break;
 }
 return true;
}
/**
 * Set up one of our menus ready to display choices for a birth question.
 * This is slightly involved.
 */
static void init_birth_menu(struct menu *menu, int n_choices,
       int initial_choice, const region *reg,
       bool allow_random, browse_f aux)
{
 struct birthmenu_data *menu_data;
 /* Initialise a basic menu */
 menu_init(menu, MN_SKIN_SCROLL, &birth_iter);
 /* A couple of behavioural flags - we want selections as letters
	   skipping the rogue-like cardinal direction movements and a
	   double tap to act as a selection. */
 menu->selections = all_letters_nohjkl;
 menu->flags = MN_DBL_TAP;
 /* Copy across the game's suggested initial selection, etc. */
 menu->cursor = initial_choice;
 /* Allocate sufficient space for our own bits of menu information. */
 menu_data = mem_alloc(sizeof *menu_data);
 /* Allocate space for an array of menu item texts and help texts
	   (where applicable) */
 menu_data->items = mem_alloc(n_choices * sizeof *menu_data->items);
 menu_data->allow_random = allow_random;
 /* Set private data */
 menu_setpriv(menu, n_choices, menu_data);
 /* Set up the "browse" hook to display help text (where applicable). */
 menu->browse_hook = aux;
 /*
	 * All use the same hook to display a context menu so that
	 * functionality driven by keyboard input (see how cmd_keys is used
	 * in menu_question()) is also available using the mouse.
	 */
 menu->context_hook = use_context_menu_birth;
 /* Lay out the menu appropriately */
 menu_layout(menu, reg);
}
static void setup_menus(void)
{
 int n;
 struct player_sex *s;
 struct player_race *r;
 struct birthmenu_data *mdata;
 /* Count the races */
 n = 0;
 for (r = races; r; r = r->next) n++;
 /* Race menu. */
 init_birth_menu(&race_menu, n, player->race ? player->race->ridx : 0,
                 &race_region, true, race_help);
 mdata = race_menu.menu_data;
 for (r = races; r; r = r->next) {
  mdata->items[r->ridx] = r->name;
 }
 mdata->hint = "Race affects stats, skills, and other character traits.";
 /* Count the sexes */
 n = 0;
 for (s = sexes; s; s = s->next) n++;
 /* Sex menu similar to race. */
 init_birth_menu(&sex_menu, n, player->sex ? player->sex->sidx : 0,
     &sex_region, true, sex_help);
 mdata = sex_menu.menu_data;
 for (s = sexes; s; s = s->next) {
  mdata->items[s->sidx] = s->name;
 }
 mdata->hint = "Sex has no gameplay effect.";
}
static void setup_house_menu(const struct player_race *r)
{
 int i, n;
 struct player_house *h;
 struct birthmenu_data *mdata;
 /* Count the houses */
 n = 0;
 for (h = houses; h; h = h->next) {
  if (h->race == r) n++;
 }
 /* House menu similar to race. */
 init_birth_menu(&house_menu, n, house_start, &house_region, true,
     house_help);
 mdata = house_menu.menu_data;
 for (i = n - 1, h = houses; h; h = h->next) {
  if (h->race == r) {
   mdata->items[i] = h->name;
   i--;
  }
 }
 mdata->hint = "House affects stats, skills, and other character traits.";
}
/**
 * Cleans up our stored menu info when we've finished with it.
 */
static void free_birth_menu(struct menu *menu)
{
 struct birthmenu_data *data = menu->menu_data;
 if (data) {
  mem_free(data->items);
  mem_free(data);
  menu->menu_data = NULL;
 }
}
static void free_birth_menus(void)
{
 /* We don't need these any more. */
 free_birth_menu(&race_menu);
 free_birth_menu(&house_menu);
 free_birth_menu(&sex_menu);
}
/**
 * Clear the previous question
 */
static void clear_question(void)
{
 int i;
 for (i = 7; i < 9; i++)
  /* Clear line, position cursor */
  Term_erase(0, i, 255);
}
/**
 * Show the birth instructions on an otherwise blank screen
 */
static void print_menu_instructions(void)
{
 /* Clear screen */
 Term_clear();
 /* Output to the screen */
 text_out_hook = text_out_to_screen;
 /* Indent output */
 text_out_indent = 2;
 Term_gotoxy(2, 1);
 /* Display some helpful information */
 text_out_e("{light blue}Please select your character traits from the menus below:{/}\n\n" "Use the {light green}movement keys{/} to scroll the menu, " "{light green}Enter{/} to select the current menu item, '{light green}*{/}' " "for a random menu item, " "'{light green}ESC{/}' to step back through the birth process, " "'{light green}={/}' for the birth options, '{light green}?{/}' " "for help, or '{light green}Ctrl-X{/}' to quit.");
 /* Reset text_out() indentation */
 text_out_indent = 0;
}
/**
 * Allow the user to select from the current menu, and return the 
 * corresponding command to the game.  Some actions are handled entirely
 * by the UI (displaying help text, for instance).
 */
static enum birth_stage menu_question(enum birth_stage current,
           struct menu *current_menu,
           cmd_code choice_command)
{
 struct birthmenu_data *menu_data = menu_priv(current_menu);
 ui_event cx;
 enum birth_stage next = BIRTH_RESET;
 /* Print the question currently being asked. */
 clear_question();
 Term_putstr(2, 7, -1, COLOUR_YELLOW, menu_data->hint);
 current_menu->cmd_keys = "?=*@\x18"; /* ?, =, *, @, <ctl-X> */
 while (next == BIRTH_RESET) {
  /* Display the menu, wait for a selection of some sort to be made. */
  menu_data->stage_inout = current;
  cx = menu_select(current_menu, EVT_KBRD, false);
  /* As all the menus are displayed in "hierarchical" style, we allow
		   use of "back" (left arrow key or equivalent) to step back in 
		   the proces as well as "escape". */
  if (cx.type == EVT_ESCAPE) {
   next = BIRTH_BACK;
  } else if (cx.type == EVT_SELECT) {
   cmdq_push(choice_command);
   cmd_set_arg_choice(cmdq_peek(), "choice", current_menu->cursor);
   if (current == BIRTH_HOUSE_CHOICE) {
    house_start = current_menu->cursor;
   }
   next = current + 1;
  } else if (cx.type == EVT_SWITCH) {
   next = menu_data->stage_inout;
  } else if (cx.type == EVT_KBRD) {
   /* '*' chooses an option at random from those the game's provided */
   if (cx.key.code == '*' && menu_data->allow_random) {
    current_menu->cursor = randint0(current_menu->count);
    cmdq_push(choice_command);
    cmd_set_arg_choice(cmdq_peek(), "choice", current_menu->cursor);
    if (current == BIRTH_HOUSE_CHOICE) {
     house_start = current_menu->cursor;
    }
    menu_refresh(current_menu, false);
    next = current + 1;
   } else if (cx.key.code == '=') {
    do_cmd_options_birth();
    next = current;
   } else if (cx.key.code == KTRL('X')) {
    quit(NULL);
   } else if (cx.key.code == '?') {
    do_cmd_help();
   }
  }
 }
 return next;
}
/**
 * ------------------------------------------------------------------------
 * Point-based stat allocation.
 * ------------------------------------------------------------------------ */
/* The locations of the stat costs area on the birth screen. */
/*
 * Remember what's possible for a given stat.  0 means can't buy or sell.
 * 1 means can sell.  2 means can buy.  3 means can buy or sell.
 */
static int buysell[STAT_MAX];
/**
 * This is called whenever a stat changes.  We take the easy road, and just
 * redisplay them all using the standard function.
 */
static void point_stats(game_event_type type, game_event_data *data,
         void *user)
{
 display_player_stat_info();
}
/**
 * This is called whenever any of the other miscellaneous stat-dependent things
 * changed.  We redisplay everything because it's easier.
 */
static void point_misc(game_event_type type, game_event_data *data,
        void *user)
{
 display_player_xtra_info();
}
/**
 * This is called whenever the points totals are changed (in birth.c), so
 * that we can update our display of how many points have been spent and
 * are available.
 */
static void stat_points(game_event_type type, game_event_data *data,
      void *user)
{
 int i;
 int sum = 0;
 const int *spent = data->points.points;
 const int *inc = data->points.inc_points;
 int remaining = data->points.remaining;
 /* Display the costs header */
 put_str("Cost", 2 - 1, (42 + 32));
 for (i = 0; i < STAT_MAX; i++) {
  /* Remember what's allowed. */
  buysell[i] = 0;
  if (spent[i] > 0) {
   buysell[i] |= 1;
  }
  if (inc[i] <= remaining) {
   buysell[i] |= 2;
  }
  /* Display cost */
  put_str(format("%4d", spent[i]), 2 + i, (42 + 32));
  sum += spent[i];
 }
 put_str(format("Total Cost: %2d/%2d", sum, remaining + sum),
  2 + STAT_MAX, (42 + 19));
}
static void stat_points_start(void)
{
 const char *prompt = "[up/down to move, left/right to modify, 'r' to reset, 'Enter' to accept]";
 int i;
 /* Clear */
 Term_clear();
 /* Display the player */
 display_player_xtra_info();
 display_player_stat_info();
 display_player_skill_info();
 prt(prompt, Term->hgt - 1, Term->wid / 2 - strlen(prompt) / 2);
 for (i = 0; i < STAT_MAX; ++i) {
  buysell[i] = 0;
 }
 /* Register handlers for various events - cheat a bit because we redraw
	   the lot at once rather than each bit at a time. */
 event_add_handler(EVENT_STATPOINTS, stat_points, NULL);
 event_add_handler(EVENT_STATS, point_stats, NULL);
 event_add_handler(EVENT_EXP_CHANGE, point_misc, NULL);
}
static void stat_points_stop(void)
{
 event_remove_handler(EVENT_STATPOINTS, stat_points, NULL);
 event_remove_handler(EVENT_STATS, point_stats, NULL);
 event_remove_handler(EVENT_EXP_CHANGE, point_misc, NULL);
}
static enum birth_stage stat_points_command(void)
{
 static int stat = 0;
 enum {
  ACT_CTX_BIRTH_PTS_NONE,
  ACT_CTX_BIRTH_PTS_BUY,
  ACT_CTX_BIRTH_PTS_SELL,
  ACT_CTX_BIRTH_PTS_ESCAPE,
  ACT_CTX_BIRTH_PTS_RESET,
  ACT_CTX_BIRTH_PTS_ACCEPT,
  ACT_CTX_BIRTH_PTS_QUIT
 };
 int action = ACT_CTX_BIRTH_PTS_NONE;
 ui_event in;
 enum birth_stage next = BIRTH_STAT_POINTS;
 /* Place cursor just after cost of current stat */
 Term_gotoxy((42 + 32) + 4, 2 + stat);
 /*
	 * Get input.  Emulate what inkey() does without coercing mouse events
	 * to look like keystrokes.
	 */
 while (1) {
  in = inkey_ex();
  if (in.type == EVT_KBRD || in.type == EVT_MOUSE) {
   break;
  }
  if (in.type == EVT_BUTTON) {
   in.type = EVT_KBRD;
  }
  if (in.type == EVT_ESCAPE) {
   in.type = EVT_KBRD;
   in.key.code = ESCAPE;
   in.key.mods = 0;
   break;
  }
 }
 /* Figure out what to do. */
 if (in.type == EVT_KBRD) {
  if (in.key.code == KTRL('X')) {
   action = ACT_CTX_BIRTH_PTS_QUIT;
  } else if (in.key.code == ESCAPE) {
   action = ACT_CTX_BIRTH_PTS_ESCAPE;
  } else if (in.key.code == 'r' || in.key.code == 'R') {
   action = ACT_CTX_BIRTH_PTS_RESET;
  } else if (in.key.code == KC_ENTER) {
   action = ACT_CTX_BIRTH_PTS_ACCEPT;
  } else {
   int dir;
   if (in.key.code == '-') {
    dir = 4;
   } else if (in.key.code == '+') {
    dir = 6;
   } else {
    dir = target_dir(in.key);
   }
   /*
			 * Go to previous stat.  Loop back to the last if at
			 * the first.
			 */
   if (dir == 8) {
    stat = (stat + STAT_MAX - 1) % STAT_MAX;
   }
   /*
			 * Go to next stat.  Loop back to the first if at the
			 * last.
			 */
   if (dir == 2) {
    stat = (stat + 1) % STAT_MAX;
   }
   /* Decrease stat (if possible). */
   if (dir == 4) {
    action = ACT_CTX_BIRTH_PTS_SELL;
   }
   /* Increase stat (if possible). */
   if (dir == 6) {
    action = ACT_CTX_BIRTH_PTS_BUY;
   }
  }
 } else if (in.type == EVT_MOUSE) {
  assert(stat >= 0 && stat < STAT_MAX);
  if (in.mouse.button == 2) {
   action = ACT_CTX_BIRTH_PTS_ESCAPE;
  } else if (in.mouse.y >= 2
    && in.mouse.y < 2 + STAT_MAX
    && in.mouse.y != 2 + stat) {
   /*
			 * Make that stat the current one if buying or selling.
			 */
   stat = in.mouse.y - 2;
  } else {
   /* Present a context menu with the other actions. */
   char *labels = string_make(lower_case);
   struct menu *m = menu_dynamic_new();
   m->selections = labels;
   if (in.mouse.y == 2 + stat
     && (buysell[stat] & 1)) {
    menu_dynamic_add_label(m, "Sell", 's',
     ACT_CTX_BIRTH_PTS_SELL, labels);
   }
   if (in.mouse.y == 2 + stat
     && (buysell[stat] & 2)) {
    menu_dynamic_add_label(m, "Buy", 'b',
     ACT_CTX_BIRTH_PTS_BUY, labels);
   }
   menu_dynamic_add_label(m, "Accept", 'a',
    ACT_CTX_BIRTH_PTS_ACCEPT, labels);
   menu_dynamic_add_label(m, "Reset", 'r',
    ACT_CTX_BIRTH_PTS_RESET, labels);
   menu_dynamic_add_label(m, "Quit", 'q',
    ACT_CTX_BIRTH_PTS_QUIT, labels);
   screen_save();
   menu_dynamic_calc_location(m, in.mouse.x, in.mouse.y);
   region_erase_bordered(&m->boundary);
   action = menu_dynamic_select(m);
   menu_dynamic_free(m);
   string_free(labels);
   screen_load();
  }
 }
 /* Do it. */
 switch (action) {
 case ACT_CTX_BIRTH_PTS_SELL:
  assert(stat >= 0 && stat < STAT_MAX);
  cmdq_push(CMD_SELL_STAT);
  cmd_set_arg_choice(cmdq_peek(), "choice", stat);
  break;
 case ACT_CTX_BIRTH_PTS_BUY:
  assert(stat >= 0 && stat < STAT_MAX);
  cmdq_push(CMD_BUY_STAT);
  cmd_set_arg_choice(cmdq_peek(), "choice", stat);
  break;
 case ACT_CTX_BIRTH_PTS_ESCAPE:
  /* Go back a step or back to the start of this step. */
  next = BIRTH_BACK;
  break;
 case ACT_CTX_BIRTH_PTS_RESET:
  cmdq_push(CMD_RESET_STATS);
  cmd_set_arg_choice(cmdq_peek(), "choice", false);
  break;
 case ACT_CTX_BIRTH_PTS_ACCEPT:
  /* Done with this stage.  Proceed to the next. */
  next = BIRTH_SKILL_POINTS;
  break;
 case ACT_CTX_BIRTH_PTS_QUIT:
  quit(NULL);
  break;
 default:
  /* Do nothing and remain at this stage. */
  break;
 }
 return next;
}
/**
 * ------------------------------------------------------------------------
 * Asking for the player's chosen name.
 * ------------------------------------------------------------------------ */
//phantom changes for server
static enum birth_stage get_name_command(void)
{
 enum birth_stage next;
 char name[PLAYER_NAME_LEN];
 /* Use frontend-provided savefile name if requested */
 if (arg_name[0]) {
  my_strcpy(player->full_name, arg_name, sizeof(player->full_name));
 }
 /*
	 * If not forcing the character's name, the front end didn't set the
	 * savefile to use, and the chosen name for the character would lead
	 * to overwriting an existing savefile, confirm that's okay with the
	 * player.
	 */
 if (arg_force_name) {
  next = BIRTH_HISTORY_CHOICE;
 } else if (get_character_name(name, sizeof(name))
   && (savefile[0]
   || !savefile_name_already_used(name, true, true)
   || get_check("A savefile for that name exists.  Overwrite it? "))) {
  cmdq_push(CMD_NAME_CHOICE);
  cmd_set_arg_string(cmdq_peek(), "name", name);
  next = BIRTH_HISTORY_CHOICE;
 } else {
  next = BIRTH_BACK;
 }
 return next;
}
static void get_screen_loc(size_t cursor, int *x, int *y, size_t n_lines,
 size_t *line_starts, size_t *line_lengths)
{
 size_t lengths_so_far = 0;
 size_t i;
 if (!line_starts || !line_lengths) return;
 for (i = 0; i < n_lines; i++) {
  if (cursor >= line_starts[i]) {
   if (cursor <= (line_starts[i] + line_lengths[i])) {
    *y = i;
    *x = cursor - lengths_so_far;
    break;
   }
  }
  /* +1 for the space */
  lengths_so_far += line_lengths[i] + 1;
 }
}
static int edit_text(char *buffer, int buflen) {
 int len = strlen(buffer);
 bool done = false;
 int cursor = 0;
 while (!done) {
  int x = 0, y = 0;
  struct keypress ke;
  region area = { 1, 18 + 1, 71, 5 };
  textblock *tb = textblock_new();
  size_t *line_starts = NULL, *line_lengths = NULL;
  size_t n_lines;
  /*
		 * This is the total number of UTF-8 characters; can be less
		 * less than len, the number of 8-bit units in the buffer,
		 * if a single character is encoded with more than one 8-bit
		 * unit.
		 */
  int ulen;
  /* Display on screen */
  clear_from(18);
  textblock_append(tb, "%s", buffer);
  textui_textblock_place(tb, area, NULL);
  n_lines = textblock_calculate_lines(tb,
    &line_starts, &line_lengths, area.width);
  ulen = (n_lines > 0) ? line_starts[n_lines - 1] +
   line_lengths[n_lines - 1]: 0;
  /* Set cursor to current editing position */
  get_screen_loc(cursor, &x, &y, n_lines, line_starts, line_lengths);
  Term_gotoxy(1 + x, 19 + y);
  ke = inkey();
  switch (ke.code) {
   case ESCAPE:
    return -1;
   case KC_ENTER:
    done = true;
    break;
   case ARROW_LEFT:
    if (cursor > 0) cursor--;
    break;
   case ARROW_RIGHT:
    if (cursor < ulen) cursor++;
    break;
   case ARROW_DOWN: {
    int add = line_lengths[y] + 1;
    if (cursor + add < ulen) cursor += add;
    break;
   }
   case ARROW_UP:
    if (y > 0) {
     int up = line_lengths[y - 1] + 1;
     if (cursor - up >= 0) cursor -= up;
    }
    break;
   case KC_END:
    cursor = MAX(0, ulen);
    break;
   case KC_HOME:
    cursor = 0;
    break;
   case KC_BACKSPACE:
   case KC_DELETE: {
    char *ocurs, *oshift;
    /* Refuse to backspace into oblivion */
    if ((ke.code == KC_BACKSPACE && cursor == 0) ||
      (ke.code == KC_DELETE && cursor >= ulen))
     break;
    /*
				 * Move the string from k to nul along to the
				 * left by 1.  First, have to get offset
				 * corresponding to the cursor position.
				 */
    ocurs = utf8_fskip(buffer, cursor, NULL);
    assert(ocurs);
    if (ke.code == KC_BACKSPACE) {
     /* Get offset of the previous character. */
     oshift = utf8_rskip(ocurs, 1, buffer);
     assert(oshift);
     memmove(oshift, ocurs,
      len - (ocurs - buffer));
     /* Decrement */
     --cursor;
     len -= ocurs - oshift;
    } else {
     /* Get offset of the next character. */
     oshift = utf8_fskip(ocurs, 1, NULL);
     assert(oshift);
     memmove(ocurs, oshift,
      len - (oshift - buffer));
     /* Decrement. */
     len -= oshift - ocurs;
    }
    /* Terminate */
    buffer[len] = '\0';
    break;
   }
   default: {
    bool atnull = (cursor == ulen);
    char encoded[5];
    int n_enc;
    char *ocurs;
    if (!keycode_isprint(ke.code))
     break;
    n_enc = utf32_to_utf8(encoded,
     N_ELEMENTS(encoded), &ke.code, 1, NULL);
    /*
				 * Make sure we have something to add and have
				 * enough space.
				 */
    if (n_enc == 0 || n_enc + len >= buflen) {
     break;
    }
    /* Insert the encoded character. */
    if (atnull) {
     ocurs = buffer + len;
    } else {
     ocurs = utf8_fskip(buffer, cursor, NULL);
     assert(ocurs);
     /*
					 * Move the rest of the buffer along
					 * to make room.
					 */
     memmove(ocurs + n_enc, ocurs,
      len - (ocurs - buffer));
    }
    memcpy(ocurs, encoded, n_enc);
    /* Update cursor position and length. */
    ++cursor;
    len += n_enc;
    /* Terminate */
    buffer[len] = '\0';
    break;
   }
  }
  mem_free(line_starts);
  mem_free(line_lengths);
  textblock_free(tb);
 }
 return 0;
}
/**
 * ------------------------------------------------------------------------
 * Allowing the player to reroll their age, height, weight.
 * ------------------------------------------------------------------------ */
static enum birth_stage get_ahw_command(void)
{
 enum birth_stage next = 0;
 struct keypress ke;
 /* Ask ahw */
 prt("Accept age, height and weight? [y/n]", 0, 0);
 ke = inkey();
 /* Quit, go back, change history, or accept */
 if (ke.code == KTRL('X')) {
  quit(NULL);
 } else if (ke.code == ESCAPE) {
  next = BIRTH_BACK;
 } else if (ke.code == 'N' || ke.code == 'n') {
  get_ahw(player);
  next = BIRTH_AHW_CHOICE;
 } else {
  next = BIRTH_HISTORY_CHOICE;
 }
 return next;
}
/**
 * ------------------------------------------------------------------------
 * Allowing the player to choose their history.
 * ------------------------------------------------------------------------ */
static enum birth_stage get_history_command(void)
{
 enum birth_stage next = 0;
 struct keypress ke;
 char old_history[240];
 /* Save the original history */
 my_strcpy(old_history, player->history, sizeof(old_history));
 /* Ask for some history */
 prt("Accept character history? [y/n]", 0, 0);
 ke = inkey();
 /* Quit, go back, change history, or accept */
 if (ke.code == KTRL('X')) {
  quit(NULL);
 } else if (ke.code == ESCAPE) {
  next = BIRTH_BACK;
 } else if (ke.code == 'N' || ke.code == 'n') {
  char history[240];
  my_strcpy(history, player->history, sizeof(history));
  switch (edit_text(history, sizeof(history))) {
   case -1:
    next = BIRTH_BACK;
    break;
   case 0:
    cmdq_push(CMD_HISTORY_CHOICE);
    cmd_set_arg_string(cmdq_peek(), "history", history);
    next = BIRTH_HISTORY_CHOICE;
  }
 } else {
  next = BIRTH_FINAL_CONFIRM;
 }
 return next;
}
/**
 * ------------------------------------------------------------------------
 * Final confirmation of character.
 * ------------------------------------------------------------------------ */
static enum birth_stage get_confirm_command(void)
{
 const char *prompt = "['ESC' to step back, 'S' to start over, or any other key to continue]";
 struct keypress ke;
 enum birth_stage next = BIRTH_RESET;
 /* Prompt for it */
 prt(prompt, Term->hgt - 1, Term->wid / 2 - strlen(prompt) / 2);
 /* Get a key */
 ke = inkey();
 /* Start over */
 if (ke.code == 'S' || ke.code == 's') {
  next = BIRTH_RESET;
 } else if (ke.code == KTRL('X')) {
  quit(NULL);
 } else if (ke.code == ESCAPE) {
  next = BIRTH_BACK;
 } else {
  cmdq_push(CMD_ACCEPT_CHARACTER);
  next = BIRTH_COMPLETE;
 }
 /* Clear prompt */
 clear_from(23);
 return next;
}
/**
 * ------------------------------------------------------------------------
 * Things that relate to the world outside this file: receiving game events
 * and being asked for game commands.
 * ------------------------------------------------------------------------ */
/**
 * This is called when we receive a request for a command in the birth 
 * process.

 * The birth process continues until we send a final character confirmation
 * command (or quit), so this is effectively called in a loop by the main
 * game.
 *
 * We're imposing a step-based system onto the main game here, so we need
 * to keep track of where we're up to, where each step moves on to, etc.
 */
int textui_do_birth(void)
{
 enum birth_stage current_stage = BIRTH_RESET;
 enum birth_stage prev = BIRTH_BACK;
 enum birth_stage next = current_stage;
 bool done = false;
 cmdq_push(CMD_BIRTH_INIT);
 cmdq_execute(CTX_BIRTH);
 while (!done) {
  switch (current_stage)
  {
   case BIRTH_RESET:
   {
    cmdq_push(CMD_BIRTH_RESET);
    if (quickstart_allowed)
     next = BIRTH_QUICKSTART;
    else
     next = BIRTH_RACE_CHOICE;
    break;
   }
   case BIRTH_QUICKSTART:
   {
    display_player(0);
    next = textui_birth_quickstart();
    if (next == BIRTH_COMPLETE)
     done = true;
    break;
   }
   case BIRTH_HOUSE_CHOICE:
   case BIRTH_RACE_CHOICE:
   case BIRTH_SEX_CHOICE:
   {
    struct menu *menu = &race_menu;
    cmd_code command = CMD_CHOOSE_RACE;
    Term_clear();
    print_menu_instructions();
    if (current_stage > BIRTH_RACE_CHOICE) {
     menu_refresh(&race_menu, false);
     free_birth_menu(&house_menu);
     setup_house_menu(player->race);
     menu = &house_menu;
     command = CMD_CHOOSE_HOUSE;
    }
    if (current_stage > BIRTH_HOUSE_CHOICE) {
     menu_refresh(&house_menu, false);
     menu = &sex_menu;
     command = CMD_CHOOSE_SEX;
    }
    next = menu_question(current_stage, menu, command);
    if (next == BIRTH_BACK) {
     next = current_stage - 1;
    }
    /* Make sure the character gets reset before quickstarting */
    if (next == BIRTH_QUICKSTART)
     next = BIRTH_RESET;
    break;
   }
   case BIRTH_STAT_POINTS:
   {
    stat_points_start();
    /*
				 * Force a redraw of the point
				 * allocations but do not reset them.
				 */
    cmdq_push(CMD_REFRESH_STATS);
    cmdq_execute(CTX_BIRTH);
    next = stat_points_command();
    if (next == BIRTH_BACK)
     next = BIRTH_SEX_CHOICE;
    stat_points_stop();
    break;
   }
   case BIRTH_SKILL_POINTS:
   {
    int skill_action = gain_skills(CTX_BIRTH,
              (prev == BIRTH_STAT_POINTS));
    if (skill_action > 0) {
     next = BIRTH_NAME_CHOICE;
    } else if (skill_action < 0) {
     next = BIRTH_STAT_POINTS;
    } else {
     /* Shouldn't get here */
     next = BIRTH_SKILL_POINTS;
    }
    break;
   }
   case BIRTH_NAME_CHOICE:
   {
    if (prev < BIRTH_NAME_CHOICE)
     display_player(0);
    next = get_name_command();
    if (next == BIRTH_BACK)
     next = BIRTH_SKILL_POINTS;
    break;
   }
   case BIRTH_AHW_CHOICE:
   {
    if (prev < BIRTH_AHW_CHOICE)
     display_player(0);
    next = get_ahw_command();
    if (next == BIRTH_BACK)
     next = BIRTH_NAME_CHOICE;
    break;
   }
   case BIRTH_HISTORY_CHOICE:
   {
    if (prev < BIRTH_HISTORY_CHOICE)
     display_player(0);
    next = get_history_command();
    if (next == BIRTH_BACK)
     next = BIRTH_AHW_CHOICE;
    break;
   }
   case BIRTH_FINAL_CONFIRM:
   {
    if (prev < BIRTH_FINAL_CONFIRM)
     display_player(0);
    next = get_confirm_command();
    if (next == BIRTH_BACK)
     next = BIRTH_HISTORY_CHOICE;
    if (next == BIRTH_COMPLETE)
     done = true;
    break;
   }
   default:
   {
    /* Remove dodgy compiler warning, */
   }
  }
  prev = current_stage;
  current_stage = next;
  /* Execute whatever commands have been sent */
  cmdq_execute(CTX_BIRTH);
 }
 return 0;
}
/**
 * Called when we enter the birth mode - so we set up handlers, command hooks,
 * etc, here.
 */
static void ui_enter_birthscreen(game_event_type type, game_event_data *data,
         void *user)
{
 /* Set the ugly static global that tells us if quickstart's available. */
 quickstart_allowed = data->flag;
 setup_menus();
}
static void ui_leave_birthscreen(game_event_type type, game_event_data *data,
         void *user)
{
 /* Set the savefile name if it's not already set */
 if (!savefile[0])
  savefile_set_name(player->full_name, true, true);
 free_birth_menus();
}
void ui_init_birthstate_handlers(void)
{
 event_add_handler(EVENT_ENTER_BIRTH, ui_enter_birthscreen, NULL);
 event_add_handler(EVENT_LEAVE_BIRTH, ui_leave_birthscreen, NULL);
}
/**
 * \file ui-combat.c
 * \brief Printing of combat roll information
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
static int combat_number = 0;
static int combat_number_old = 0;
static int turns_since_combat = 0;
struct combat_roll combat_rolls[2][MAX_COMBAT_ROLLS] = { { { 0 }, { 0 } } };
/**
 * Start a new combat round
 */
void new_combat_round(game_event_type type, game_event_data *data, void *user)
{
 int i;
 if (combat_number != 0) combat_number_old = combat_number;
 combat_number = 0;
 turns_since_combat++;
 if (turns_since_combat == 1) {
  /* Copy previous round's rolls into old round's rolls */
  for (i = 0; i < MAX_COMBAT_ROLLS; i++) {
   memcpy(&combat_rolls[1][i], &combat_rolls[0][i],
       sizeof(struct combat_roll));
  }
 } else if (turns_since_combat == 11) {
  /* Reset old round's rolls */
  combat_number_old = 0;
  for (i = 0; i < MAX_COMBAT_ROLLS; i++) {
   combat_rolls[1][i].att_type = COMBAT_ROLL_NONE;
  }
 }
 /* Reset new round's rolls */
 for (i = 0; i < MAX_COMBAT_ROLLS; i++) {
  combat_rolls[0][i].att_type = COMBAT_ROLL_NONE;
 }
 /* Redraw */
 player->upkeep->redraw |= (PR_COMBAT);
}
/**
 * Update combat roll table part 1 (the attack rolls)
 *
 * If melee is false, there is no roll made -- eg breath attack
 */
void update_combat_rolls_attack(game_event_type type, game_event_data *data,
        void *user)
{
 struct monster *mon;
 struct monster_race *race1 = NULL;
 struct monster_race *race2 = NULL;
 struct source attacker = data->combat_attack.attacker;
 struct source defender = data->combat_attack.defender;
 bool vis = data->combat_attack.vis;
 int att = data->combat_attack.att;
 int att_roll = data->combat_attack.att_roll;
 int evn = data->combat_attack.evn;
 int evn_roll = data->combat_attack.evn_roll;
 bool melee = data->combat_attack.melee;
 switch (attacker.what) {
  case SRC_PLAYER: race1 = &r_info[0]; break;
  case SRC_MONSTER: {
   mon = cave_monster(cave, attacker.which.monster);
   if (player->timed[TMD_IMAGE]) {
    race1 = mon->image_race;
   } else {
    race1 = mon->race;
   }
   break;
  }
  case SRC_TRAP: break;
  default: break;
 }
 switch (defender.what) {
  case SRC_PLAYER: race2 = &r_info[0]; break;
  case SRC_MONSTER: {
   mon = cave_monster(cave, defender.which.monster);
   if (player->timed[TMD_IMAGE]) {
    race2 = mon->image_race;
   } else {
    race2 = mon->race;
   }
   break;
  }
  default: break;
 }
 if (combat_number < MAX_COMBAT_ROLLS) {
  combat_rolls[0][combat_number].att_type =
   melee ? COMBAT_ROLL_ROLL : COMBAT_ROLL_AUTO;
  if (attacker.what == SRC_GRID) {
   combat_rolls[0][combat_number].attacker_char =
    square_feat(cave, player->grid)->d_char;
   combat_rolls[0][combat_number].attacker_attr =
    square_feat(cave, player->grid)->d_attr;
  } else if (attacker.what == SRC_TRAP) {
   combat_rolls[0][combat_number].attacker_char =
    attacker.which.trap->kind->d_char;
   combat_rolls[0][combat_number].attacker_attr =
    attacker.which.trap->kind->d_attr;
  } else if ((vis && (attacker.what == SRC_MONSTER))
    || (attacker.what == SRC_PLAYER)) {
   combat_rolls[0][combat_number].attacker_char = race1->d_char;
   if (player->timed[TMD_RAGE] && (attacker.what != SRC_PLAYER)) {
    combat_rolls[0][combat_number].attacker_attr = COLOUR_RED;
   } else {
    combat_rolls[0][combat_number].attacker_attr = race1->d_attr;
   }
  } else {
   combat_rolls[0][combat_number].attacker_char = L'?';
   combat_rolls[0][combat_number].attacker_attr = COLOUR_SLATE;
  }
  if ((defender.what == SRC_NONE) && melee) {
   /* Hack for Iron Crown */
   combat_rolls[0][combat_number].defender_char = L']';
   combat_rolls[0][combat_number].defender_attr = COLOUR_L_DARK;
  } else if ((vis && (defender.what == SRC_MONSTER))
    || (defender.what == SRC_PLAYER)) {
   combat_rolls[0][combat_number].defender_char = race2->d_char;
   if (player->timed[TMD_RAGE] && (defender.what != SRC_PLAYER)) {
    combat_rolls[0][combat_number].defender_attr = COLOUR_RED;
   } else {
    combat_rolls[0][combat_number].defender_attr = race2->d_attr;
   }
  } else {
   combat_rolls[0][combat_number].defender_char = L'?';
   combat_rolls[0][combat_number].defender_attr = COLOUR_SLATE;
  }
  if (melee) {
   combat_rolls[0][combat_number].att = att;
   combat_rolls[0][combat_number].att_roll = att_roll;
   combat_rolls[0][combat_number].evn = evn;
   combat_rolls[0][combat_number].evn_roll = evn_roll;
  }
  combat_number++;
  turns_since_combat = 0;
 }
 /* Redraw */
 player->upkeep->redraw |= (PR_COMBAT);
}
/**
 * Update combat roll table part 2 (the damage rolls)
 */
void update_combat_rolls_damage(game_event_type type, game_event_data *data,
        void *user)
{
 int dd = data->combat_damage.dd;
 int ds = data->combat_damage.ds;
 int dam = data->combat_damage.dam;
 int pd = data->combat_damage.pd;
 int ps = data->combat_damage.ps;
 int prot = data->combat_damage.prot;
 int prt_percent = data->combat_damage.prt_percent;
 int dam_type = data->combat_damage.dam_type;
 bool melee = data->combat_damage.melee;
 if (combat_number - 1 < MAX_COMBAT_ROLLS) {
  combat_rolls[0][combat_number - 1].dam_type = dam_type;
  combat_rolls[0][combat_number - 1].dd = dd;
  combat_rolls[0][combat_number - 1].ds = ds;
  combat_rolls[0][combat_number - 1].dam = dam;
  combat_rolls[0][combat_number - 1].pd = pd;
  combat_rolls[0][combat_number - 1].ps = ps;
  combat_rolls[0][combat_number - 1].prot = prot;
  combat_rolls[0][combat_number - 1].prt_percent = prt_percent;
  combat_rolls[0][combat_number - 1].melee = melee;
  /* deal with protection for the player */
  /* this hackishly uses the pd and ps to store the min and max prot for
		 * the player */
  if (pd == -1) {
   /* use the protection values for pure elemental types if there was
			 * no attack roll */
   if (combat_rolls[0][combat_number - 1].att_type
    == COMBAT_ROLL_AUTO) {
    combat_rolls[0][combat_number - 1].pd =
     protection_roll(player, dam_type, melee, MINIMISE);
    combat_rolls[0][combat_number - 1].ps =
     protection_roll(player, dam_type, melee, MAXIMISE);
   } else {
    /* otherwise use the normal protection values  */
    combat_rolls[0][combat_number - 1].pd =
     protection_roll(player, PROJ_HURT, melee, MINIMISE);
    combat_rolls[0][combat_number - 1].ps =
     protection_roll(player, PROJ_HURT, melee, MAXIMISE);
   }
  }
 }
 /* Redraw */
 player->upkeep->redraw |= (PR_COMBAT);
}
/**
 * Display combat rolls in a window
 */
void display_combat_rolls(game_event_type type, game_event_data *data, void *user)
{
 /* all the update_combat_rolls*() stuff */
 int i;
 int line = 0;
 char buf[80];
 int net_att = 0; /* a default value (required) */
 int net_dam;
 int a_att;
 int a_evn;
 int a_hit;
 int a_dam_roll;
 int a_prot_roll;
 int a_net_dam;
 int round;
 int combat_num_for_round = combat_number;
 int total_player_attacks = 0;
 int player_attacks = 0;
 int monster_attacks = 0;
 int line_jump = 0;
 int res = 1; /* a default value to soothe compilation warnings */
 /* Clear the window */
 for (i = 0; i < Term->hgt; i++) {
  /* Erase the line */
  Term_erase(0, i, 255);
 }
 for (round = 0; round < 2; round++) {
  /* initialise some things */
  if (round == 1) {
   combat_num_for_round = combat_number_old;
   line_jump = player_attacks + monster_attacks + 2;
   if (player_attacks > 0) line_jump++;
   if (monster_attacks > 0) line_jump++;
   if (combat_number + combat_number_old > 0) {
    Term_putstr(0, line_jump - 1, 80, COLOUR_L_DARK, "_______________________________________________________________________________");
   }
  }
  total_player_attacks = 0;
  player_attacks = 0;
  monster_attacks = 0;
  for (i = 0; i < combat_num_for_round; i++) {
   if ((combat_rolls[round][i].attacker_char == r_info[0].d_char) &&
    (combat_rolls[round][i].attacker_attr == r_info[0].d_attr)) {
    total_player_attacks++;
   }
  }
  for (i = 0; i < combat_num_for_round; i++) {
   /* default values: */
   a_net_dam = COLOUR_L_RED;
   res = 1;
   /* determine the appropriate resistance if the player was attacked*/
   if ((combat_rolls[round][i].defender_char == r_info[0].d_char) &&
    (combat_rolls[round][i].defender_attr == r_info[0].d_attr)) {
    int dam_type = combat_rolls[round][i].dam_type;
    if (dam_type && (dam_type < ELEM_MAX)) {
     res = player->state.el_info[dam_type].res_level;
    }
   }
   if ((combat_rolls[round][i].attacker_char == r_info[0].d_char) &&
    (combat_rolls[round][i].attacker_attr == r_info[0].d_attr)) {
    player_attacks++;
    a_att = COLOUR_L_BLUE;
    a_evn = COLOUR_WHITE;
    a_hit = COLOUR_L_RED;
    a_dam_roll = COLOUR_L_BLUE;
    if (combat_rolls[round][i].prt_percent >= 100) {
     a_prot_roll = COLOUR_WHITE;
    } else if (combat_rolls[round][i].prt_percent >= 1) {
     a_prot_roll = COLOUR_SLATE;
    } else {
     a_prot_roll = COLOUR_DARK;
    }
    line = player_attacks + line_jump;
   } else {
    monster_attacks++;
    a_att = COLOUR_WHITE;
    a_evn = COLOUR_L_BLUE;
    a_hit = COLOUR_L_RED;
    a_dam_roll = COLOUR_WHITE;
    if (combat_rolls[round][i].prt_percent >= 100)
     a_prot_roll = COLOUR_L_BLUE;
    else if (combat_rolls[round][i].prt_percent >= 1)
     a_prot_roll = COLOUR_BLUE;
    else
     a_prot_roll = COLOUR_DARK;
    line = 1 + total_player_attacks + monster_attacks + line_jump;
    if (total_player_attacks == 0) line--;
   }
   /* Display the entry itself */
   Term_putstr(0, line, 1, COLOUR_WHITE, " ");
   Term_addch(combat_rolls[round][i].attacker_attr,
        combat_rolls[round][i].attacker_char);
   /* First display the attack side of the roll.
			 * Don't print attack info if there isn't any (i.e. if it is
			 * a breath or other elemental attack) */
   if (combat_rolls[round][i].att_type == COMBAT_ROLL_ROLL) {
    if (combat_rolls[round][i].att < 10) {
     strnfmt(buf, sizeof (buf), "  (%+d)",
       combat_rolls[round][i].att);
    } else {
     strnfmt(buf, sizeof (buf), " (%+d)",
       combat_rolls[round][i].att);
    }
    Term_addstr(-1, a_att, buf);
    strnfmt(buf, sizeof (buf), "%4d",
      combat_rolls[round][i].att +
      combat_rolls[round][i].att_roll);
    Term_addstr(-1, a_att, buf);
    net_att = combat_rolls[round][i].att_roll +
     combat_rolls[round][i].att -
     combat_rolls[round][i].evn_roll -
     combat_rolls[round][i].evn;
    if (net_att > 0) {
     strnfmt(buf, sizeof (buf), "%4d", net_att);
     Term_addstr(-1, a_hit, buf);
    } else {
     Term_addstr(-1, COLOUR_SLATE, "   -");
    }
    strnfmt(buf, sizeof (buf), "%4d",
      combat_rolls[round][i].evn +
      combat_rolls[round][i].evn_roll);
    Term_addstr(-1, a_evn, buf);
    if (combat_rolls[round][i].evn < 10) {
     strnfmt(buf, sizeof (buf), "   [%+d]",
       combat_rolls[round][i].evn);
    } else {
     strnfmt(buf, sizeof (buf), "  [%+d]",
       combat_rolls[round][i].evn);
    }
    Term_addstr(-1, a_evn, buf);
    /* add the defender char */
    Term_addch(COLOUR_WHITE, ' ');
    Term_addch(combat_rolls[round][i].defender_attr,
         combat_rolls[round][i].defender_char);
   } else if (combat_rolls[round][i].att_type == COMBAT_ROLL_AUTO) {
    Term_addstr(-1, COLOUR_L_DARK, "                         ");
    /* add the defender char */
    Term_addch(COLOUR_WHITE, ' ');
    Term_addch(combat_rolls[round][i].defender_attr,
         combat_rolls[round][i].defender_char);
   }
   /* Now display the damage side of the roll */
   if ((net_att > 0) ||
    (combat_rolls[round][i].att_type == COMBAT_ROLL_AUTO)) {
    Term_addstr(-1, COLOUR_L_DARK, "  ->");
    if (combat_rolls[round][i].ds < 10) {
     strnfmt(buf, sizeof (buf), "   (%dd%d)",
       combat_rolls[round][i].dd,
       combat_rolls[round][i].ds);
    } else {
     strnfmt(buf, sizeof (buf), "  (%dd%d)",
       combat_rolls[round][i].dd,
       combat_rolls[round][i].ds);
    }
    Term_addstr(-1, a_dam_roll, buf);
    strnfmt(buf, sizeof (buf), "%4d", combat_rolls[round][i].dam);
    Term_addstr(-1, a_dam_roll, buf);
    if (combat_rolls[round][i].att_type == COMBAT_ROLL_ROLL) {
     net_dam = combat_rolls[round][i].dam -
      combat_rolls[round][i].prot;
     if (net_dam > 0) {
      strnfmt(buf, sizeof (buf), "%4d", net_dam);
      Term_addstr(-1, a_net_dam, buf);
     } else {
      Term_addstr(-1, COLOUR_SLATE, "   -");
     }
     strnfmt(buf, sizeof (buf), "%4d",
       combat_rolls[round][i].prot);
     Term_addstr(-1, a_prot_roll, buf);
     /* if monster is being hit, show protection dice */
     if ((combat_rolls[round][i].defender_char !=
       r_info[0].d_char) ||
      (combat_rolls[round][i].defender_attr !=
       r_info[0].d_attr)) {
      if ((combat_rolls[round][i].ps < 1) ||
       (combat_rolls[round][i].pd < 1)) {
       my_strcpy(buf, "        ", sizeof (buf));
       Term_addstr(-1, a_prot_roll, buf);
      } else if (combat_rolls[round][i].ps < 10) {
       strnfmt(buf, sizeof (buf), "   [%dd%d]",
         combat_rolls[round][i].pd,
         combat_rolls[round][i].ps);
       Term_addstr(-1, a_prot_roll, buf);
      } else {
       strnfmt(buf, sizeof (buf), "  [%dd%d]",
         combat_rolls[round][i].pd,
         combat_rolls[round][i].ps);
       Term_addstr(-1, a_prot_roll, buf);
      }
      if ((combat_rolls[round][i].prt_percent > 0) &&
       (combat_rolls[round][i].prt_percent < 100)) {
       strnfmt(buf, sizeof (buf), " (%d%%)",
         combat_rolls[round][i].prt_percent);
       Term_addstr(-1, a_prot_roll, buf);
      }
     } else {
      /* if player is being hit, show protection *range* */
      strnfmt(buf, sizeof (buf), "  [%d-%d]",
        (combat_rolls[round][i].pd *
         combat_rolls[round][i].prt_percent) / 100,
        (combat_rolls[round][i].ps *
         combat_rolls[round][i].prt_percent) / 100);
      Term_addstr(-1, a_prot_roll, buf);
     }
    } else if (combat_rolls[round][i].att_type == COMBAT_ROLL_AUTO){
     /* display attacks that don't use hit rolls */
     /* shield etc protection and resistance */
     if (combat_rolls[round][i].melee) {
       net_dam = combat_rolls[round][i].dam -
       combat_rolls[round][i].prot;
     } else if (res > 0) {
      net_dam = (combat_rolls[round][i].dam / res) -
       combat_rolls[round][i].prot;
     } else {
      net_dam = (combat_rolls[round][i].dam * (-res)) -
       combat_rolls[round][i].prot;
     }
     if (net_dam > 0) {
      strnfmt(buf, sizeof (buf), "%4d", net_dam);
      Term_addstr(-1, a_net_dam, buf);
     } else {
      Term_addstr(-1, COLOUR_SLATE, "   -");
     }
     strnfmt(buf, sizeof (buf), "%4d",
       combat_rolls[round][i].prot);
     Term_addstr(-1, a_prot_roll, buf);
     /* if monster is being hit, show protection dice */
     if ((combat_rolls[round][i].defender_char !=
       r_info[0].d_char) ||
      (combat_rolls[round][i].defender_attr !=
       r_info[0].d_attr)) {
      if ((combat_rolls[round][i].ps < 1) ||
       (combat_rolls[round][i].pd < 1)) {
       my_strcpy(buf, "        ", sizeof (buf));
       Term_addstr(-1, a_prot_roll, buf);
      } else if (combat_rolls[round][i].ps < 10) {
       strnfmt(buf, sizeof (buf), "   [%dd%d]",
         combat_rolls[round][i].pd,
         combat_rolls[round][i].ps);
       Term_addstr(-1, a_prot_roll, buf);
      } else {
       strnfmt(buf, sizeof (buf), "  [%dd%d]",
         combat_rolls[round][i].pd,
         combat_rolls[round][i].ps);
       Term_addstr(-1, a_prot_roll, buf);
      }
      if ((combat_rolls[round][i].prt_percent > 0) &&
       (combat_rolls[round][i].prt_percent < 100)) {
       strnfmt(buf, sizeof (buf), " (%d%%)",
         combat_rolls[round][i].prt_percent);
       Term_addstr(-1, a_prot_roll, buf);
      }
     } else {
      /* if a player is being hit, show protection range etc*/
      if (!(combat_rolls[round][i].melee)) {
       if (res > 1) {
        strnfmt(buf, sizeof (buf), "  1/%d then", res);
        Term_addstr(-1, COLOUR_L_BLUE, buf);
       } else if (res < 0) {
        strnfmt(buf, sizeof (buf), "  x%d then", -res);
        Term_addstr(-1, COLOUR_L_BLUE, buf);
       }
      }
      if (combat_rolls[round][i].ps < 10) {
       strnfmt(buf, sizeof (buf), "  [%d-%d]",
         combat_rolls[round][i].pd,
         combat_rolls[round][i].ps);
       Term_addstr(-1, a_prot_roll, buf);
      } else {
       strnfmt(buf, sizeof (buf), " [%d-%d]",
         combat_rolls[round][i].pd,
         combat_rolls[round][i].ps);
       Term_addstr(-1, a_prot_roll, buf);
      }
     }
    }
   }
  }
 }
}
/**
 * \file ui-command.c
 * \brief Deal with UI only command processing.
 *
 * Copyright (c) 1997-2014 Angband developers
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Redraw the screen
 *
 * This command performs various low level updates, clears all the "extra"
 * windows, does a total redraw of the main window, and requests all of the
 * interesting updates and redraws that I can think of.
 *
 * This command is also used to "instantiate" the results of the user
 * selecting various things, such as graphics mode, so it must call
 * the "TERM_XTRA_REACT" hook before redrawing the windows.
 *
 */
void do_cmd_redraw(void)
{
 /* Low level flush */
 Term_flush();
 /* Reset "inkey()" */
 event_signal(EVENT_INPUT_FLUSH);
 if (character_dungeon)
  verify_panel();
 /* Hack -- React to changes */
 Term_xtra(TERM_XTRA_REACT, 0);
 if (character_dungeon) {
  /* Combine the pack (later) */
  player->upkeep->notice |= (PN_COMBINE);
  /* Update torch, gear */
  player->upkeep->update |= (PU_TORCH | PU_INVEN);
  /* Update stuff */
  player->upkeep->update |= (PU_BONUS | PU_HP | PU_SPELLS);
  /* Fully update the visuals */
  player->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
  /* Redraw everything */
  player->upkeep->redraw |= (PR_BASIC | PR_EXTRA | PR_MAP | PR_INVEN |
           PR_EQUIP | PR_MESSAGE | PR_MONSTER |
           PR_OBJECT | PR_MONLIST | PR_ITEMLIST);
 }
 /* Clear screen */
 Term_clear();
 if (character_dungeon) {
  /* Hack -- update */
  handle_stuff(player);
  /* Place the cursor on the player */
  if ((0 != character_dungeon) && target_sighted()) {
   struct loc target;
   target_get(&target);
   move_cursor_relative(target.y, target.x);
  } else {
   move_cursor_relative(player->grid.y, player->grid.x);
  }
 }
 /* Redraw every window */
 (void) Term_redraw_all();
}
/**
 * Display the options and redraw afterward.
 */
void do_cmd_xxx_options(void)
{
 do_cmd_options();
 do_cmd_redraw();
}
/**
 * Invoked when the command isn't recognised.
 */
void do_cmd_unknown(void)
{
 prt("Type '?' for help.", 0, 0);
}
/**
 * Print the version and copyright notice.
 */
void do_cmd_version(void)
{
 char header_buf[120];
 textblock *tb = textblock_new();
 region local_area = { 0, 0, 0, 0 };
 my_strcpy(header_buf,
     format("You are playing %s.  Type '?' for more info.", buildver),
     sizeof(header_buf));
 textblock_append(tb, "\n");
 textblock_append(tb, "%s", copyright);
 textui_textblock_show(tb, local_area, header_buf);
 textblock_free(tb);
}
/**
 * Verify the retire command
 */
void textui_cmd_retire(void)
{
 struct keypress ch;
 /* Flush input */
 event_signal(EVENT_INPUT_FLUSH);
 /* Verify */
 if (!get_check("Do you really want to retire?")) return;
 /* Special Verification for retirement */
 prt("Please verify RETIRING THIS CHARACTER by typing the '@' sign: ", 0, 0);
 event_signal(EVENT_INPUT_FLUSH);
 ch = inkey();
 prt("", 0, 0);
 if (ch.code != '@') return;
 cmdq_push(CMD_RETIRE);
}
/**
 * Get input for the rest command
 */
void textui_cmd_rest(void)
{
 const char *p = "Rest (0-9999, '!' for HP or SP, '*' for HP and SP, '&' as needed): ";
 char out_val[5] = "& ";
 /* Ask for duration */
 if (!get_string(p, out_val, sizeof(out_val))) return;
 /* Rest... */
 if (out_val[0] == '&') {
  /* ...until done */
  cmdq_push(CMD_REST);
  cmd_set_arg_choice(cmdq_peek(), "choice", REST_COMPLETE);
 } else if (out_val[0] == '*') {
  /* ...a lot */
  cmdq_push(CMD_REST);
  cmd_set_arg_choice(cmdq_peek(), "choice", REST_ALL_POINTS);
 } else if (out_val[0] == '!') {
  /* ...until HP or SP filled */
  cmdq_push(CMD_REST);
  cmd_set_arg_choice(cmdq_peek(), "choice", REST_SOME_POINTS);
 } else {
  /* ...some */
  int turns = atoi(out_val);
  if (turns <= 0) return;
  if (turns > 9999) turns = 9999;
  cmdq_push(CMD_REST);
  cmd_set_arg_choice(cmdq_peek(), "choice", turns);
 }
}
/**
 * Quit the game.
 */
void textui_quit(void)
{
 /* The tutorial doesn't allow saves, so confirm before quitting. */
 if (in_tutorial() && !get_check("Really exit the tutorial? ")) {
  return;
 }
 player->upkeep->playing = false;
}
/**
 * ------------------------------------------------------------------------
 * Screenshot loading/saving code
 * ------------------------------------------------------------------------ */
static void write_html_escape_char(ang_file *fp, char *mbbuf, wchar_t c)
{
 switch (c)
 {
  case L'<':
   file_putf(fp, "&lt;");
   break;
  case L'>':
   file_putf(fp, "&gt;");
   break;
  case L'&':
   file_putf(fp, "&amp;");
   break;
  default:
  {
   int nc = text_wctomb(mbbuf, c);
   if (nc > 0) {
    mbbuf[nc] = 0;
   } else {
    mbbuf[0] = ' ';
    mbbuf[1] = 0;
   }
   file_putf(fp, "%s", mbbuf);
   break;
  }
 }
}
static void screenshot_term_query(int wid, int hgt, int x, int y, int *a, wchar_t *c)
{
 if (y < ROW_MAP || y >= hgt - ROW_BOTTOM_MAP || x < COL_MAP) {
  /* Record everything outside the map. */
  (void) Term_what(x, y, a, c);
 } else {
  /*
		 * In the map, skip over the padding for scaled up tiles.  As
		 * necessary, pad trailing columns and rows with blanks.
		 */
  int srcx = (x - COL_MAP) * tile_width + COL_MAP;
  int srcy = (y - ROW_MAP) * tile_height + ROW_MAP;
  if (srcx < wid && srcy < hgt - ROW_BOTTOM_MAP) {
   (void) Term_what(srcx, srcy, a, c);
  } else {
   *a = COLOUR_WHITE;
   *c = ' ';
  }
 }
}
/**
 * Take an html screenshot
 */
void html_screenshot(const char *path, int mode, term *other_term)
{
 /* Put the contents of the other terminal on the right by default. */
 bool other_left = false;
 int y, x;
 int main_wid, main_hgt, other_wid, other_hgt, wid, hgt;
 int main_xst, other_xst;
 int a = COLOUR_WHITE;
 int oa = COLOUR_WHITE;
 int fg_colour = COLOUR_WHITE;
 int bg_colour = COLOUR_DARK;
 wchar_t c = L' ';
 term *main_term = Term;
 const char *new_color_fmt = "<font color=\"#%02X%02X%02X\" style=\"background-color: #%02X%02X%02X\">";
 const char *change_color_fmt = (mode == 0) ?
     "</font><font color=\"#%02X%02X%02X\" style=\"background-color: #%02X%02X%02X\">"
     : "[/COLOR][COLOR=\"#%02X%02X%02X\"]";
 const char *close_color_str = "</font>";
 char *mbbuf;
 ang_file *fp;
 mbbuf = mem_alloc(text_wcsz() + 1);
 fp = file_open(path, MODE_WRITE, FTYPE_TEXT);
 /* Oops */
 if (!fp) {
  mem_free(mbbuf);
  plog_fmt("Cannot write the '%s' file!", path);
  return;
 }
 /* Retrieve current screen size */
 Term_get_size(&main_wid, &main_hgt);
 if (other_term) {
  Term_activate(other_term);
  Term_get_size(&other_wid, &other_hgt);
  Term_activate(main_term);
 } else {
  other_wid = 0;
  other_hgt = 0;
 }
 if (other_left) {
  other_xst = 0;
  main_xst = (other_wid > 0) ? other_wid + 1 : 0;
 } else {
  other_xst = main_wid + 1;
  main_xst = 0;
 }
 hgt = MAX(main_hgt, other_hgt);
 wid = (other_wid > 0) ? main_wid + other_wid + 1 : main_wid;
 if (mode == 0) {
  file_putf(fp, "<!DOCTYPE html><html><head>\n");
  file_putf(fp, "  <meta http-equiv='Content-Type' content='text/html; charset=utf-8'>\n");
  file_putf(fp, "  <meta name='generator' content='%s'>\n", buildid);
  file_putf(fp, "  <title>%s</title>\n", path);
  file_putf(fp, "</head>\n\n");
  file_putf(fp, "<body style='color: #%02X%02X%02X; background: #%02X%02X%02X;'>\n",
   angband_color_table[COLOUR_WHITE][1],
   angband_color_table[COLOUR_WHITE][2],
   angband_color_table[COLOUR_WHITE][3],
   angband_color_table[COLOUR_DARK][1],
   angband_color_table[COLOUR_DARK][2],
   angband_color_table[COLOUR_DARK][3]);
  file_putf(fp, "<pre>\n");
 } else {
  file_putf(fp, "[CODE][TT][BC=\"#%02X%02X%02X\"][COLOR=\"#%02X%02X%02X\"]\n",
   angband_color_table[COLOUR_DARK][1],
   angband_color_table[COLOUR_DARK][2],
   angband_color_table[COLOUR_DARK][3],
   angband_color_table[COLOUR_WHITE][1],
   angband_color_table[COLOUR_WHITE][2],
   angband_color_table[COLOUR_WHITE][3]);
 }
 /* Dump the screen */
 for (y = 0; y < hgt; y++) {
  for (x = 0; x < wid; x++) {
   /* Get the attr/char */
   if (x >= main_xst && x < main_xst + main_wid
     && y < main_hgt) {
    screenshot_term_query(wid, hgt, x - main_xst, y,
     &a, &c);
   } else if (x >= other_xst && x < other_xst + other_wid
     && y < other_hgt) {
    if (x == other_xst) {
     Term_activate(other_term);
    }
    Term_what(x - other_xst, y, &a, &c);
    if (x == other_xst + other_wid - 1) {
     Term_activate(main_term);
    }
   } else {
    a = COLOUR_WHITE;
    c = ' ';
   }
   /* Set the foreground and background */
   fg_colour = a % MAX_COLORS;
   switch (a / MULT_BG)
   {
    case BG_BLACK:
     bg_colour = COLOUR_DARK;
     break;
    case BG_SAME:
     bg_colour = fg_colour;
     break;
    case BG_DARK:
     bg_colour = COLOUR_SHADE;
     break;
    default:
     assert((a >= 0)
      && (a < BG_MAX * MULT_BG));
   }
   /*
			 * Color change (for forum text, ignore changes if the character is
			 * a space since the forum software strips [COLOR][/COLOR] elements that
			 * only contain whitespace)
			 */
   if (oa != a && (mode == 0 || c != L' ')) {
    if (oa == COLOUR_WHITE && mode == 0) {
     /* From the default white to another color */
     file_putf(fp, new_color_fmt,
         angband_color_table[fg_colour][1],
         angband_color_table[fg_colour][2],
         angband_color_table[fg_colour][3],
         angband_color_table[bg_colour][1],
         angband_color_table[bg_colour][2],
         angband_color_table[bg_colour][3]);
    } else if (fg_colour == COLOUR_WHITE
      && bg_colour == COLOUR_DARK
      && mode == 0) {
     /* From another color to the default white */
     file_putf(fp, "%s", close_color_str);
    } else {
     /* Change colors */
     file_putf(fp, change_color_fmt,
         angband_color_table[fg_colour][1],
         angband_color_table[fg_colour][2],
         angband_color_table[fg_colour][3],
         angband_color_table[bg_colour][1],
         angband_color_table[bg_colour][2],
         angband_color_table[bg_colour][3]);
    }
    /* Remember the last color */
    oa = a;
   }
   /* Write the character and escape special HTML characters */
   if (mode == 0) write_html_escape_char(fp, mbbuf, c);
   else {
    int nc = text_wctomb(mbbuf, c);
    if (nc > 0) {
     mbbuf[nc] = 0;
    } else {
     mbbuf[0] = ' ';
     mbbuf[1] = 0;
    }
    file_putf(fp, "%s", mbbuf);
   }
  }
  /* End the row */
  file_putf(fp, "\n");
 }
 /* Close the last font-color tag if necessary */
 if (oa != COLOUR_WHITE && mode == 0) file_putf(fp, "%s", close_color_str);
 if (mode == 0) {
  file_putf(fp, "</pre>\n");
  file_putf(fp, "</body>\n");
  file_putf(fp, "</html>\n");
 } else {
  file_putf(fp, "[/COLOR][/BC][/TT][/CODE]\n");
 }
 /* Close it */
 file_close(fp);
 mem_free(mbbuf);
}
/**
 * Hack -- save a screen dump to a file in html format
 */
static void do_cmd_save_screen_html(int mode, term *other_term)
{
 size_t i;
 ang_file *fff;
 char file_name[1024];
 char tmp_val[256];
 typedef void (*dump_func)(ang_file *);
 dump_func dump_visuals [] = { dump_monsters, dump_features, dump_objects,
          dump_flavors, dump_colors };
 /* Ask for a file */
 if (!get_file(mode == 0 ? "dump.html" : "dump.txt",
      tmp_val, sizeof(tmp_val))) return;
 /* Save current preferences */
 path_build(file_name, sizeof(file_name), ANGBAND_DIR_USER, "dump.prf");
 fff = file_open(file_name, MODE_WRITE, FTYPE_TEXT);
 /* Check for failure */
 if (!fff) {
  msg("Screen dump failed.");
  event_signal(EVENT_MESSAGE_FLUSH);
  return;
 }
 /* Dump all the visuals */
 for (i = 0; i < N_ELEMENTS(dump_visuals); i++)
  dump_visuals[i](fff);
 file_close(fff);
 /* Dump the screen with raw character attributes */
 reset_visuals(false);
 do_cmd_redraw();
 html_screenshot(tmp_val, mode, other_term);
 /* Recover current graphics settings */
 reset_visuals(true);
 process_pref_file(file_name, true, false);
 file_delete(file_name);
 do_cmd_redraw();
 msg("%s screen dump saved.", mode ? "Forum text" : "HTML");
 event_signal(EVENT_MESSAGE_FLUSH);
}
/**
 * Hack -- save a screen dump to a file
 */
void do_cmd_save_screen(void)
{
 char ch = get_char("Dump as (H)TML or (F)orum text? ", "hf", 2, ' ');
 int mode = 0;
 term *ml_term;
 switch (ch) {
  case 'h':
   mode = 0;
   break;
  case 'f':
   mode = 1;
   break;
  default:
   return;
 }
 ml_term = find_first_subwindow(PW_MONLIST);
 if (ml_term) {
  if (!get_check("Include monster list? ")) ml_term = NULL;
 }
 do_cmd_save_screen_html(mode, ml_term);
}
/**
 * \file ui-context.c
 * \brief Show player and terrain context menus.
 *
 * Copyright (c) 2011 Brett Reid
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband license":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Additional constants for menu item values. The values must not collide
 * with the cmd_code enum, since those are the main values for these menu items.
 */
enum context_menu_value_e {
    MENU_VALUE_INSPECT = CMD_REPEAT + 1000,
    MENU_VALUE_DROP_ALL,
 MENU_VALUE_LOOK,
 MENU_VALUE_RECALL,
 MENU_VALUE_REST,
 MENU_VALUE_INVENTORY,
 MENU_VALUE_CENTER_MAP,
 MENU_VALUE_FLOOR,
 MENU_VALUE_CHARACTER,
 MENU_VALUE_OTHER,
 MENU_VALUE_KNOWLEDGE,
 MENU_VALUE_MAP,
 MENU_VALUE_MESSAGES,
 MENU_VALUE_OBJECTS,
 MENU_VALUE_MONSTERS,
 MENU_VALUE_TOGGLE_IGNORED,
 MENU_VALUE_OPTIONS,
 MENU_VALUE_HELP,
};
static int context_menu_player_2(int mx, int my)
{
 struct menu *m;
 int selected;
 char *labels;
 bool allowed = true;
 int mode = OPT(player, angband_keyset) ? KEYMAP_MODE_ANGBAND : KEYMAP_MODE_ORIG;
 unsigned char cmdkey;
 if (OPT(player, hjkl_movement)) {
  mode |= KEYMAP_MODE_ROGUE;
 }
 m = menu_dynamic_new();
 if (!m) {
  return 0;
 }
 labels = string_make(lower_case);
 m->selections = labels;
 menu_dynamic_add_label(m, "Knowledge", '~', MENU_VALUE_KNOWLEDGE, labels);
 menu_dynamic_add_label(m, "Show Map", 'M', MENU_VALUE_MAP, labels);
 menu_dynamic_add_label(m, "^Show Messages", 'P', MENU_VALUE_MESSAGES,
         labels);
 menu_dynamic_add_label(m, "Show Monster List", '[', MENU_VALUE_MONSTERS,
         labels);
 menu_dynamic_add_label(m, "Show Object List", ']', MENU_VALUE_OBJECTS,
         labels);
 /* Ignore toggle has different keys, but we don't have a way to look them
	 * up (see ui-game.c). */
 menu_dynamic_add_label(m, "Toggle Ignored", 'K', MENU_VALUE_TOGGLE_IGNORED,
         labels);
 { cmdkey = cmd_lookup_key_unktrl((CMD_IGNORE), mode); menu_dynamic_add_label_valid(m, ("Ignore an item"), cmdkey, (CMD_IGNORE), labels, (MN_ROW_VALID)); };
 cmdkey = (mode & KEYMAP_MODE_ANGBAND) ? '=' : 'O';
 menu_dynamic_add_label(m, "Options", cmdkey, MENU_VALUE_OPTIONS, labels);
 menu_dynamic_add_label(m, "Commands", '?', MENU_VALUE_HELP, labels);
 /* Hack -- no flush needed */
 msg_flag = false;
 screen_save();
 menu_dynamic_calc_location(m, mx, my);
 region_erase_bordered(&m->boundary);
 prt("(Enter to select, ESC) Command:", 0, 0);
 selected = menu_dynamic_select(m);
 menu_dynamic_free(m);
 string_free(labels);
 screen_load();
 /* Check the command to see if it is allowed. */
 switch (selected) {
  case -1:
   /* User cancelled the menu. */
   return 3;
  case MENU_VALUE_KNOWLEDGE:
  case MENU_VALUE_MAP:
  case MENU_VALUE_MESSAGES:
  case MENU_VALUE_TOGGLE_IGNORED:
  case MENU_VALUE_HELP:
  case MENU_VALUE_MONSTERS:
  case MENU_VALUE_OBJECTS:
  case MENU_VALUE_OPTIONS:
   allowed = true;
   break;
  case CMD_IGNORE:
   cmdkey = cmd_lookup_key(selected, mode);
   allowed = key_confirm_command(cmdkey);
   break;
  default:
   /* Invalid command; prevent anything from happening. */
   bell();
   allowed = false;
   break;
 }
 if (!allowed)
  return 1;
 /* Perform the command. */
 switch (selected) {
  case MENU_VALUE_KNOWLEDGE:
   Term_keypress('~', 0);
   break;
  case MENU_VALUE_MAP:
   Term_keypress('M', 0);
   break;
  case MENU_VALUE_MESSAGES:
   Term_keypress(KTRL('p'), 0);
   break;
  case CMD_IGNORE:
   cmdkey = cmd_lookup_key(selected, mode);
   Term_keypress(cmdkey, 0);
   break;
  case MENU_VALUE_TOGGLE_IGNORED:
   Term_keypress('K', 0);
   break;
  case MENU_VALUE_HELP:
   context_menu_command(mx, my);
   break;
  case MENU_VALUE_MONSTERS:
   Term_keypress('[', 0);
   break;
  case MENU_VALUE_OBJECTS:
   Term_keypress(']', 0);
   break;
  case MENU_VALUE_OPTIONS:
   Term_keypress('=', 0);
   break;
  default:
   break;
 }
 return 1;
}
static void context_menu_player_display_floor(void)
{
 int diff = weight_remaining(player);
 struct object *obj;
 /* There is an item on the floor, select from there */
 player->upkeep->command_wrk = (USE_FLOOR);
 /* Save screen */
 screen_save();
 /* Prompt for a command */
 prt(format("(Inventory) Burden %d.%d lb (%d.%d lb %s). Item for command: ",
      player->upkeep->total_weight / 10,
      player->upkeep->total_weight % 10,
      abs(diff) / 10, abs(diff) % 10,
      (diff < 0 ? "overweight" : "remaining")), 0, 0);//TODO prompt
 /* Get an item to use a context command on */
 if (get_item(&obj, NULL, NULL, CMD_NULL, NULL, USE_EQUIP | USE_INVEN | USE_QUIVER | USE_FLOOR | SHOW_EMPTY | IS_HARMLESS)) {
  /* Track the object kind */
  track_object(player->upkeep, obj);
  context_menu_object(obj);
 }
 /* Load screen */
 screen_load();
}
int context_menu_player(int mx, int my)
{
 struct menu *m;
 int selected;
 char *labels;
 bool allowed = true;
 int mode = OPT(player, angband_keyset) ? KEYMAP_MODE_ANGBAND : KEYMAP_MODE_ORIG;
 unsigned char cmdkey;
 struct object *obj;
 if (OPT(player, hjkl_movement)) {
  mode |= KEYMAP_MODE_ROGUE;
 }
 m = menu_dynamic_new();
 if (!m) {
  return 0;
 }
 labels = string_make(lower_case);
 m->selections = labels;
 { cmdkey = cmd_lookup_key_unktrl((CMD_USE), mode); menu_dynamic_add_label_valid(m, ("Use"), cmdkey, (CMD_USE), labels, (MN_ROW_VALID)); };
 /* if player is on stairs add option to use them */
 if (square_isupstairs(cave, player->grid)) {
  { cmdkey = cmd_lookup_key_unktrl((CMD_GO_UP), mode); menu_dynamic_add_label_valid(m, ("Go Up"), cmdkey, (CMD_GO_UP), labels, (MN_ROW_VALID)); };
 }
 else if (square_isdownstairs(cave, player->grid)) {
  { cmdkey = cmd_lookup_key_unktrl((CMD_GO_DOWN), mode); menu_dynamic_add_label_valid(m, ("Go Down"), cmdkey, (CMD_GO_DOWN), labels, (MN_ROW_VALID)); };
 }
 menu_dynamic_add_label(m, "Look", 'l', MENU_VALUE_LOOK, labels);
 /* 'R' is used for resting in both keymaps. */
 menu_dynamic_add_label(m, "Rest", 'R', MENU_VALUE_REST, labels);
 /* 'i' is used for inventory in both keymaps. */
 menu_dynamic_add_label(m, "Inventory", 'i', MENU_VALUE_INVENTORY, labels);
 /* if object under player add pickup option */
 obj = square_object(cave, player->grid);
 if (obj && !ignore_item_ok(player, obj)) {
   menu_row_validity_t valid;
   /* 'f' isn't in rogue keymap, so we can use it here. */
     menu_dynamic_add_label(m, "Floor", 'f', MENU_VALUE_FLOOR, labels);
   valid = (inven_carry_okay(obj)) ? MN_ROW_VALID : MN_ROW_INVALID;
   { cmdkey = cmd_lookup_key_unktrl((CMD_PICKUP), mode); menu_dynamic_add_label_valid(m, ("Pick up"), cmdkey, (CMD_PICKUP), labels, (valid)); };
 }
 /* 'C' is used for the character sheet in both keymaps. */
 menu_dynamic_add_label(m, "Character", 'C', MENU_VALUE_CHARACTER, labels);
 if (!OPT(player, center_player)) {
  menu_dynamic_add_label(m, "^Center Map", 'L', MENU_VALUE_CENTER_MAP,
          labels);
 }
 menu_dynamic_add_label(m, "Other", ' ', MENU_VALUE_OTHER, labels);
 /* Hack -- no flush needed */
 msg_flag = false;
 screen_save();
 menu_dynamic_calc_location(m, mx, my);
 region_erase_bordered(&m->boundary);
 prt("(Enter to select, ESC) Command:", 0, 0);
 selected = menu_dynamic_select(m);
 menu_dynamic_free(m);
 string_free(labels);
 screen_load();
 cmdkey = cmd_lookup_key(selected, mode);
 /* Check the command to see if it is allowed. */
 switch(selected) {
  case -1:
   /* User cancelled the menu. */
   return 3;
  case CMD_USE:
  case CMD_GO_UP:
  case CMD_GO_DOWN:
  case CMD_PICKUP:
   /* Only check for ^ inscriptions, since we don't have an object
			 * selected (if we need one). */
   allowed = key_confirm_command(cmdkey);
   break;
  case MENU_VALUE_REST:
   allowed = key_confirm_command('R');
   break;
  case MENU_VALUE_INVENTORY:
  case MENU_VALUE_LOOK:
  case MENU_VALUE_CHARACTER:
  case MENU_VALUE_OTHER:
  case MENU_VALUE_FLOOR:
  case MENU_VALUE_CENTER_MAP:
   allowed = true;
   break;
  default:
   /* Invalid command; prevent anything from happening. */
   bell();
   allowed = false;
   break;
 }
 if (!allowed)
  return 1;
 /* Perform the command. */
 switch(selected) {
  case CMD_USE:
   cmdkey = cmd_lookup_key(selected, mode);
   Term_keypress(cmdkey, 0);
   break;
  case CMD_GO_UP:
  case CMD_GO_DOWN:
  case CMD_PICKUP:
   cmdq_push(selected);
   break;
  case MENU_VALUE_REST:
   Term_keypress('R', 0);
   break;
  case MENU_VALUE_INVENTORY:
   Term_keypress('i', 0);
   break;
  case MENU_VALUE_LOOK:
   if (target_set_interactive(TARGET_LOOK, player->grid, 0))
    msg("Target Selected.");
   break;
  case MENU_VALUE_CHARACTER:
   Term_keypress('C', 0);
   break;
  case MENU_VALUE_OTHER:
   context_menu_player_2(mx, my);
   break;
  case MENU_VALUE_FLOOR:
   context_menu_player_display_floor();
   break;
  case MENU_VALUE_CENTER_MAP:
   do_cmd_center_map();
   break;
  default:
   break;
 }
 return 1;
}
int context_menu_cave(struct chunk *c, int y, int x, int adjacent, int mx,
       int my)
{
 struct menu *m;
 int selected;
 char *labels;
 bool allowed = true;
 int mode = OPT(player, angband_keyset) ? KEYMAP_MODE_ANGBAND : KEYMAP_MODE_ORIG;
 unsigned char cmdkey;
 struct loc grid = loc(x, y);
 struct object *square_obj = square_object(c, grid);
 if (OPT(player, hjkl_movement)) {
  mode |= KEYMAP_MODE_ROGUE;
 }
 m = menu_dynamic_new();
 if (!m)
  return 0;
 labels = string_make(lower_case);
 m->selections = labels;
 menu_dynamic_add_label(m, "Look At", 'l', MENU_VALUE_LOOK, labels);
 { cmdkey = cmd_lookup_key_unktrl((CMD_USE), mode); menu_dynamic_add_label_valid(m, ("Use Item On"), cmdkey, (CMD_USE), labels, (MN_ROW_VALID)); };
 if (adjacent) {
  struct object *obj = chest_check(player, grid, CHEST_ANY);
  { cmdkey = cmd_lookup_key_unktrl((CMD_ALTER), mode); menu_dynamic_add_label_valid(m, ((square(c, grid)->mon) ? "Attack" : "Alter"), cmdkey, (CMD_ALTER), labels, (MN_ROW_VALID)); };
  if (obj && !ignore_item_ok(player, obj)) {
   if (obj->known->pval) {
    if (is_locked_chest(obj)) {
     { cmdkey = cmd_lookup_key_unktrl((CMD_DISARM), mode); menu_dynamic_add_label_valid(m, ("Disarm Chest"), cmdkey, (CMD_DISARM), labels, (MN_ROW_VALID)); };
     { cmdkey = cmd_lookup_key_unktrl((CMD_OPEN), mode); menu_dynamic_add_label_valid(m, ("Open Chest"), cmdkey, (CMD_OPEN), labels, (MN_ROW_VALID)); };
    } else {
     { cmdkey = cmd_lookup_key_unktrl((CMD_OPEN), mode); menu_dynamic_add_label_valid(m, ("Open Disarmed Chest"), cmdkey, (CMD_OPEN), labels, (MN_ROW_VALID)); };
    }
   } else {
    { cmdkey = cmd_lookup_key_unktrl((CMD_OPEN), mode); menu_dynamic_add_label_valid(m, ("Open Chest"), cmdkey, (CMD_OPEN), labels, (MN_ROW_VALID)); };
   }
  }
  if (square_isdisarmabletrap(c, grid)) {
   { cmdkey = cmd_lookup_key_unktrl((CMD_DISARM), mode); menu_dynamic_add_label_valid(m, ("Disarm"), cmdkey, (CMD_DISARM), labels, (MN_ROW_VALID)); };
   { cmdkey = cmd_lookup_key_unktrl((CMD_JUMP), mode); menu_dynamic_add_label_valid(m, ("Jump Onto"), cmdkey, (CMD_JUMP), labels, (MN_ROW_VALID)); };
  }
  else if (square_iswarded(c, grid)) {
   { cmdkey = cmd_lookup_key_unktrl((CMD_DISARM), mode); menu_dynamic_add_label_valid(m, ("Disarm"), cmdkey, (CMD_DISARM), labels, (MN_ROW_VALID)); };
  }
  if (square_isopendoor(c, grid)) {
   { cmdkey = cmd_lookup_key_unktrl((CMD_CLOSE), mode); menu_dynamic_add_label_valid(m, ("Close"), cmdkey, (CMD_CLOSE), labels, (MN_ROW_VALID)); };
  }
  else if (square_iscloseddoor(c, grid)
    && !square_issecretdoor(c, grid)) {
   { cmdkey = cmd_lookup_key_unktrl((CMD_OPEN), mode); menu_dynamic_add_label_valid(m, ("Open"), cmdkey, (CMD_OPEN), labels, (MN_ROW_VALID)); };
   { cmdkey = cmd_lookup_key_unktrl((CMD_BASH), mode); menu_dynamic_add_label_valid(m, ("Bash"), cmdkey, (CMD_BASH), labels, (MN_ROW_VALID)); };
  }
  else if (square_isdiggable(c, grid)) {
   { cmdkey = cmd_lookup_key_unktrl((CMD_TUNNEL), mode); menu_dynamic_add_label_valid(m, ("Tunnel"), cmdkey, (CMD_TUNNEL), labels, (MN_ROW_VALID)); };
  }
  { cmdkey = cmd_lookup_key_unktrl((CMD_WALK), mode); menu_dynamic_add_label_valid(m, ("Walk Towards"), cmdkey, (CMD_WALK), labels, (MN_ROW_VALID)); };
 } else {
  /* ',' is used for ignore in rogue keymap, so we'll just swap letters */
  cmdkey = (mode == KEYMAP_MODE_ORIG) ? ',' : '.';
  menu_dynamic_add_label(m, "Pathfind To", cmdkey, CMD_PATHFIND, labels);
  { cmdkey = cmd_lookup_key_unktrl((CMD_WALK), mode); menu_dynamic_add_label_valid(m, ("Walk Towards"), cmdkey, (CMD_WALK), labels, (MN_ROW_VALID)); };
  { cmdkey = cmd_lookup_key_unktrl((CMD_RUN), mode); menu_dynamic_add_label_valid(m, ("Run Towards"), cmdkey, (CMD_RUN), labels, (MN_ROW_VALID)); };
 }
 if (player_can_fire(player, false)) {
  { cmdkey = cmd_lookup_key_unktrl((CMD_FIRE), mode); menu_dynamic_add_label_valid(m, ("Fire On"), cmdkey, (CMD_FIRE), labels, (MN_ROW_VALID)); };
 }
 { cmdkey = cmd_lookup_key_unktrl((CMD_THROW), mode); menu_dynamic_add_label_valid(m, ("Throw To"), cmdkey, (CMD_THROW), labels, (MN_ROW_VALID)); };
 /* Hack -- no flush needed */
 msg_flag = false;
 screen_save();
 menu_dynamic_calc_location(m, mx, my);
 region_erase_bordered(&m->boundary);
 if (player->timed[TMD_IMAGE]) {
  prt("(Enter to select command, ESC to cancel) You see something strange:", 0, 0);
 } else if (square(c, grid)->mon) {
  char m_name[80];
  struct monster *mon = square_monster(c, grid);
  /* Get the monster name ("a kobold") */
  monster_desc(m_name, sizeof(m_name), mon, MDESC_IND_VIS);
  prt(format("(Enter to select command, ESC to cancel) You see %s:",
       m_name), 0, 0);
 } else if (square_obj && !ignore_item_ok(player, square_obj)) {
  char o_name[80];
  /* Obtain an object description */
  object_desc(o_name, sizeof (o_name), square_obj,
   ODESC_PREFIX | ODESC_FULL, player);
  prt(format("(Enter to select command, ESC to cancel) You see %s:",
       o_name), 0, 0);
 } else {
  /* Feature (apply mimic) */
  char name[50];
  const char *prefix = square_apparent_look_prefix(player->cave, grid);
  square_apparent_name(player->cave, grid, name, sizeof(name));
  prt(format("(Enter to select command, ESC to cancel) You see %s%s:", prefix, name), 0, 0);
 }
 selected = menu_dynamic_select(m);
 menu_dynamic_free(m);
 string_free(labels);
 screen_load();
 cmdkey = cmd_lookup_key(selected, mode);
 /* Check the command to see if it is allowed. */
 switch (selected) {
  case -1:
   /* User cancelled the menu. */
   return 3;
  case MENU_VALUE_LOOK:
  case MENU_VALUE_RECALL:
  case CMD_PATHFIND:
   allowed = true;
   break;
  case CMD_ALTER:
  case CMD_BASH:
  case CMD_DISARM:
  case CMD_JUMP:
  case CMD_CLOSE:
  case CMD_OPEN:
  case CMD_TUNNEL:
  case CMD_WALK:
  case CMD_RUN:
  case CMD_FIRE:
  case CMD_THROW:
  case CMD_USE:
   /* Only check for ^ inscriptions, since we don't have an object
			 * selected (if we need one). */
   allowed = key_confirm_command(cmdkey);
   break;
  default:
   /* Invalid command; prevent anything from happening. */
   bell();
   allowed = false;
   break;
 }
 if (!allowed)
  return 1;
 /* Perform the command. */
 switch (selected) {
  case MENU_VALUE_LOOK:
   /* Look at the spot */
   if (target_set_interactive(TARGET_LOOK, grid, 0)) {
    msg("Target Selected.");
   }
   break;
  case MENU_VALUE_RECALL: {
   /* Recall monster Info */
   struct monster *mon = square_monster(c, grid);
   if (mon) {
    struct monster_lore *lore = get_lore(mon->race);
    lore_show_interactive(mon->race, lore);
   }
  }
   break;
  case CMD_PATHFIND:
   cmdq_push(selected);
   cmd_set_arg_point(cmdq_peek(), "point", loc(x, y));
   break;
  case CMD_ALTER:
  case CMD_BASH:
  case CMD_DISARM:
  case CMD_JUMP:
  case CMD_CLOSE:
  case CMD_OPEN:
  case CMD_TUNNEL:
  case CMD_WALK:
  case CMD_RUN:
   cmdq_push(selected);
   cmd_set_arg_direction(cmdq_peek(), "direction",
          motion_dir(player->grid, loc(x, y)));
   break;
  case CMD_FIRE:
  case CMD_THROW:
  case CMD_USE:
   cmdq_push(selected);
   cmd_set_arg_target(cmdq_peek(), "target", DIR_TARGET);
   break;
  default:
   break;
 }
 return 1;
}
/**
 * Pick the context menu options appropiate for the item
 */
int context_menu_object(struct object *obj)
{
 struct menu *m;
 region r;
 int selected;
 char *labels;
 char header[120];
 textblock *tb;
 region area = { 0, 0, 0, 0 };
 bool allowed = true;
 int mode = OPT(player, angband_keyset) ? KEYMAP_MODE_ANGBAND : KEYMAP_MODE_ORIG;
 unsigned char cmdkey;
 if (OPT(player, hjkl_movement)) {
  mode |= KEYMAP_MODE_ROGUE;
 }
 m = menu_dynamic_new();
 if (!m || !obj)
  return 0;
 object_desc(header, sizeof(header), obj, ODESC_PREFIX | ODESC_BASE,
  player);
 labels = string_make(lower_case);
 m->selections = labels;
 /* 'I' is used for inspect in both keymaps. */
 menu_dynamic_add_label(m, "Inspect", 'I', MENU_VALUE_INSPECT, labels);
 if (obj_is_useable(obj)) {
  if (tval_is_horn(obj)) {
   menu_row_validity_t valid = (player->csp) ?
    MN_ROW_VALID : MN_ROW_INVALID;
   { cmdkey = cmd_lookup_key_unktrl((CMD_BLOW_HORN), mode); menu_dynamic_add_label_valid(m, ("Blow"), cmdkey, (CMD_BLOW_HORN), labels, (valid)); };
  } else if (tval_is_staff(obj)) {
   menu_row_validity_t valid = (obj_has_charges(obj)) ?
    MN_ROW_VALID : MN_ROW_INVALID;
   { cmdkey = cmd_lookup_key_unktrl((CMD_USE_STAFF), mode); menu_dynamic_add_label_valid(m, ("Use"), cmdkey, (CMD_USE_STAFF), labels, (valid)); };
  } else if (tval_is_potion(obj)) {
   { cmdkey = cmd_lookup_key_unktrl((CMD_QUAFF), mode); menu_dynamic_add_label_valid(m, ("Quaff"), cmdkey, (CMD_QUAFF), labels, (MN_ROW_VALID)); };
  } else if (tval_is_edible(obj)) {
   { cmdkey = cmd_lookup_key_unktrl((CMD_EAT), mode); menu_dynamic_add_label_valid(m, ("Eat"), cmdkey, (CMD_EAT), labels, (MN_ROW_VALID)); };
  } else if (obj_can_fire(obj)
    && object_is_in_quiver(player, obj)) {
   { cmdkey = cmd_lookup_key_unktrl((CMD_FIRE), mode); menu_dynamic_add_label_valid(m, ("Fire"), cmdkey, (CMD_FIRE), labels, (MN_ROW_VALID)); };
  } else {
   { cmdkey = cmd_lookup_key_unktrl((CMD_USE), mode); menu_dynamic_add_label_valid(m, ("Use"), cmdkey, (CMD_USE), labels, (MN_ROW_VALID)); };
  }
 }
 if (obj_can_refuel(obj))
  { cmdkey = cmd_lookup_key_unktrl((CMD_REFUEL), mode); menu_dynamic_add_label_valid(m, ("Refuel"), cmdkey, (CMD_REFUEL), labels, (MN_ROW_VALID)); };
 if (object_is_equipped(player->body, obj) && obj_can_takeoff(obj)) {
  { cmdkey = cmd_lookup_key_unktrl((CMD_TAKEOFF), mode); menu_dynamic_add_label_valid(m, ("Take off"), cmdkey, (CMD_TAKEOFF), labels, (MN_ROW_VALID)); };
 } else if (!object_is_equipped(player->body, obj) && obj_can_wear(obj)) {
  { cmdkey = cmd_lookup_key_unktrl((CMD_WIELD), mode); menu_dynamic_add_label_valid(m, ("Equip"), cmdkey, (CMD_WIELD), labels, (MN_ROW_VALID)); };
 }
 if (object_is_carried(player, obj)) {
  { cmdkey = cmd_lookup_key_unktrl((CMD_DROP), mode); menu_dynamic_add_label_valid(m, ("Drop"), cmdkey, (CMD_DROP), labels, (MN_ROW_VALID)); };
 } else {
  menu_row_validity_t valid = (inven_carry_okay(obj)) ?
   MN_ROW_VALID : MN_ROW_INVALID;
  { cmdkey = cmd_lookup_key_unktrl((CMD_PICKUP), mode); menu_dynamic_add_label_valid(m, ("Pick up"), cmdkey, (CMD_PICKUP), labels, (valid)); };
 }
 if (obj_can_throw(obj)) {
  { cmdkey = cmd_lookup_key_unktrl((CMD_THROW), mode); menu_dynamic_add_label_valid(m, ("Throw"), cmdkey, (CMD_THROW), labels, (MN_ROW_VALID)); };
 }
 { cmdkey = cmd_lookup_key_unktrl((CMD_INSCRIBE), mode); menu_dynamic_add_label_valid(m, ("Inscribe"), cmdkey, (CMD_INSCRIBE), labels, (MN_ROW_VALID)); };
 if (obj_has_inscrip(obj))
  { cmdkey = cmd_lookup_key_unktrl((CMD_UNINSCRIBE), mode); menu_dynamic_add_label_valid(m, ("Uninscribe"), cmdkey, (CMD_UNINSCRIBE), labels, (MN_ROW_VALID)); };
 { cmdkey = cmd_lookup_key_unktrl((CMD_IGNORE), mode); menu_dynamic_add_label_valid(m, ((object_is_ignored(obj) ? "Unignore" : "Ignore")), cmdkey, (CMD_IGNORE), labels, (MN_ROW_VALID)); };
 /* work out display region */
 r.width = (int)menu_dynamic_longest_entry(m) + 3 + 2; /* +3 for tag,
														   * 2 for pad */
 r.col = Term->wid - r.width - 1;
 r.row = 1;
 r.page_rows = m->count;
 area.width = -(r.width + 2);
 /* Hack -- no flush needed */
 msg_flag = false;
 screen_save();
 /* Display info */
 tb = object_info(obj, OINFO_NONE);
 object_desc(header, sizeof(header), obj, ODESC_PREFIX | ODESC_FULL,
  player);
 textui_textblock_place(tb, area, format("%s", header));
 textblock_free(tb);
 menu_layout(m, &r);
 region_erase_bordered(&r);
 prt(format("(Enter to select, ESC) Command for %s:", header), 0, 0);
 selected = menu_dynamic_select(m);
 menu_dynamic_free(m);
 string_free(labels);
 screen_load();
 cmdkey = cmd_lookup_key(selected, mode);
 switch (selected) {
  case -1:
   /* User cancelled the menu. */
   return 3;
  case MENU_VALUE_INSPECT:
   /* copied from textui_obj_examine */
   /* Display info */
   tb = object_info(obj, OINFO_NONE);
   object_desc(header, sizeof(header), obj,
    ODESC_PREFIX | ODESC_FULL, player);
   textui_textblock_show(tb, area, format("%s", header));
   textblock_free(tb);
   return 2;
  case CMD_IGNORE:
  case CMD_WIELD:
  case CMD_TAKEOFF:
  case CMD_INSCRIBE:
  case CMD_UNINSCRIBE:
  case CMD_PICKUP:
  case CMD_DROP:
  case CMD_REFUEL:
  case CMD_THROW:
  case CMD_BLOW_HORN:
  case CMD_USE_STAFF:
  case CMD_QUAFF:
  case CMD_EAT:
  case CMD_FIRE:
  case CMD_USE:
   /* Check for inscriptions that trigger confirmation. */
   allowed = key_confirm_command(cmdkey) &&
    get_item_allow(obj, cmdkey, selected, false);
   break;
  default:
   /* Invalid command; prevent anything from happening. */
   bell();
   allowed = false;
   break;
 }
 if (!allowed)
  return 1;
 if (selected == CMD_IGNORE) {
  /* ignore or unignore the item */
  textui_cmd_ignore_menu(obj);
 } else {
  cmdq_push(selected);
  cmd_set_arg_item(cmdq_peek(), "item", obj);
 }
 return 1;
}
static int show_command_list(struct cmd_info cmd_list[], int size, int mx,
                             int my)
{
 struct menu *m;
 int selected;
 int i;
 char cmd_name[80];
 char key[3];
 int mode = OPT(player, angband_keyset) ? KEYMAP_MODE_ANGBAND : KEYMAP_MODE_ORIG;
 if (OPT(player, hjkl_movement)) {
  mode |= KEYMAP_MODE_ROGUE;
 }
 m = menu_dynamic_new();
 if (!m) {
  return 0;
 }
 m->selections = lower_case;
 key[2] = '\0';
 for (i = 0; i < size; ++i) {
  if (KTRL(cmd_list[i].key[mode]) == cmd_list[i].key[mode]) {
   key[0] = '^';
   key[1] = UN_KTRL(cmd_list[i].key[mode]);
  } else {
   key[0] = cmd_list[i].key[mode];
   key[1] = '\0';
  }
  strnfmt(cmd_name, 80, "%s (%s)", cmd_list[i].desc, key);
  menu_dynamic_add(m, cmd_name, i+1);
 }
 menu_dynamic_calc_location(m, mx, my);
 screen_save();
 region_erase_bordered(&m->boundary);
 prt("(Enter to select, ESC) Command:", 0, 0);
 selected = menu_dynamic_select(m);
 menu_dynamic_free(m);
 screen_load();
 if ((selected > 0) && (selected < size+1)) {
  /* execute the command */
  Term_keypress(cmd_list[selected-1].key[mode], 0);
 }
 return 1;
}
int context_menu_command(int mx, int my)
{
 struct menu *m;
 int selected;
 m = menu_dynamic_new();
 if (!m) {
  return 0;
 }
 m->selections = lower_case;
 menu_dynamic_add(m, "Item", 1);
 menu_dynamic_add(m, "Action", 2);
 menu_dynamic_add(m, "Item Management", 3);
 menu_dynamic_add(m, "Info", 4);
 menu_dynamic_add(m, "Util", 5);
 menu_dynamic_add(m, "Misc", 6);
 menu_dynamic_calc_location(m, mx, my);
 screen_save();
 region_erase_bordered(&m->boundary);
 prt("(Enter to select, ESC) Command:", 0, 0);
 selected = menu_dynamic_select(m);
 menu_dynamic_free(m);
 screen_load();
 /* XXX-AS this is gross, as is the way there's two ways to display the
	 * entire command list.  Fix me */
 if (selected > 0) {
  selected--;
  show_command_list(cmds_all[selected].list, cmds_all[selected].len,
        mx, my);
 } else {
  return 0;
 }
 return 1;
}
/**
 * Handle a textui mouseclick.
 */
void textui_process_click(ui_event e)
{
 int x, y;
 if (!OPT(player, mouse_movement)) return;
 y = KEY_GRID_Y(e);
 x = KEY_GRID_X(e);
 /* Check for a valid location */
 if (!square_in_bounds_fully(cave, loc(x, y))) return;
 /* XXX show context menu here */
 if (loc_eq(player->grid, loc(x, y))) {
  if (e.mouse.mods & KC_MOD_SHIFT) {
   /* shift-click - cast magic */
   if (e.mouse.button == 2) {
    Term_keypress('i',0);
   }
  } else if (e.mouse.mods & KC_MOD_CONTROL) {
   /* ctrl-click - use feature / use inventory item */
   /* switch with default */
   if (e.mouse.button == 1) {
    if (square_isupstairs(cave, player->grid))
     cmdq_push(CMD_GO_UP);
    else if (square_isdownstairs(cave, player->grid))
     cmdq_push(CMD_GO_DOWN);
   } else if (e.mouse.button == 2) {
    cmdq_push(CMD_USE);
   }
  } else if (e.mouse.mods & KC_MOD_ALT) {
   /* alt-click - show char screen */
   /* XXX call a platform specific hook */
   if (e.mouse.button == 1) {
    Term_keypress('C',0);
   }
  } else {
   if (e.mouse.button == 1) {
    if (square_object(cave, loc(x, y))) {
     cmdq_push(CMD_PICKUP);
    } else {
     cmdq_push(CMD_HOLD);
    }
   } else if (e.mouse.button == 2) {
    /* Show a context menu */
    context_menu_player(e.mouse.x, e.mouse.y);
   }
  }
 } else if (e.mouse.button == 1) {
  if (player->timed[TMD_CONFUSED]) {
   cmdq_push(CMD_WALK);
  } else {
   if (e.mouse.mods & KC_MOD_SHIFT) {
    /* shift-click - run */
    cmdq_push(CMD_RUN);
    cmd_set_arg_direction(cmdq_peek(), "direction",
           motion_dir(player->grid, loc(x, y)));
   } else if (e.mouse.mods & KC_MOD_CONTROL) {
    /* control-click - alter */
    cmdq_push(CMD_ALTER);
    cmd_set_arg_direction(cmdq_peek(), "direction",
           motion_dir(player->grid, loc(x, y)));
   } else if (e.mouse.mods & KC_MOD_ALT) {
    /* alt-click - look */
    if (target_set_interactive(TARGET_LOOK, loc(x, y), 0)) {
     msg("Target Selected.");
    }
   } else {
    /* Pathfind does not work well on trap detection borders,
				 * so if the click is next to the player, force a walk step */
    if ((y - player->grid.y >= -1) && (y - player->grid.y <= 1) &&
     (x - player->grid.x >= -1) && (x - player->grid.x <= 1)) {
     cmdq_push(CMD_WALK);
     cmd_set_arg_direction(cmdq_peek(), "direction",
            motion_dir(player->grid, loc(x, y)));
    } else {
     cmdq_push(CMD_PATHFIND);
     cmd_set_arg_point(cmdq_peek(), "point", loc(x, y));
    }
   }
  }
 } else if (e.mouse.button == 2) {
  struct monster *m = square_monster(cave, loc(x, y));
  if (m && target_able(m)) {
   /* Set up target information */
   monster_race_track(player->upkeep, m->race);
   health_track(player->upkeep, m);
   target_set_monster(m);
  } else {
   target_set_location(loc(x, y));
  }
  if (e.mouse.mods & KC_MOD_CONTROL) {
   /* control-click - fire at target */
   cmdq_push(CMD_USE);
   cmd_set_arg_target(cmdq_peek(), "target", DIR_TARGET);
  } else if (e.mouse.mods & KC_MOD_ALT) {
   /* alt-click - throw at target */
   cmdq_push(CMD_THROW);
   cmd_set_arg_target(cmdq_peek(), "target", DIR_TARGET);
  } else {
   /* see if the click was adjacent to the player */
   if ((y - player->grid.y >= -1) && (y - player->grid.y <= 1) &&
    (x - player->grid.x >= -1) && (x - player->grid.x <= 1)) {
    context_menu_cave(cave,y,x,1,e.mouse.x, e.mouse.y);
   } else {
    context_menu_cave(cave,y,x,0,e.mouse.x, e.mouse.y);
   }
  }
 }
}
/**
 * ------------------------------------------------------------------------
 * Menu functions
 * ------------------------------------------------------------------------ */
/**
 * Display an entry on a command menu
 */
static void cmd_sub_entry(struct menu *menu, int oid, bool cursor, int row,
        int col, int width)
{
 uint8_t attr = (cursor ? COLOUR_L_BLUE : COLOUR_WHITE);
 const struct cmd_info *commands = menu_priv(menu);
 int mode = OPT(player, angband_keyset) ? KEYMAP_MODE_ANGBAND : KEYMAP_MODE_ORIG;
 struct keypress kp = { EVT_KBRD, commands[oid].key[mode], 0 };
 char buf[16];
 if (OPT(player, hjkl_movement)) {
  mode |= KEYMAP_MODE_ROGUE;
 }
 /* Write the description */
 Term_putstr(col, row, -1, attr, commands[oid].desc);
 /*
	 * Include keypress for commands that aren't placeholders to drive the
	 * menu system.
	 */
 if (kp.code) {
  Term_addch(attr, L' ');
  Term_addch(attr, L'(');
  /* Get readable version */
  keypress_to_readable(buf, sizeof buf, kp);
  Term_addstr(-1, attr, buf);
  Term_addch(attr, L')');
 }
}
/**
 * Display a list of commands.
 */
static bool cmd_menu(struct command_list *list, void *selection_p)
{
 struct menu menu;
 menu_iter commands_menu = { NULL, NULL, cmd_sub_entry, NULL, NULL };
 region area = { 23, 4, 37, 13 };
 ui_event evt;
 struct cmd_info **selection = selection_p;
 /*
	 * By default, cause the containing menu to break out of its event
	 * handling when this function returns.
	 */
 bool result = false;
 /* Set up the menu */
 menu_init(&menu, MN_SKIN_SCROLL, &commands_menu);
 menu_setpriv(&menu, list->len, list->list);
 area.col += 2 * list->menu_level;
 area.row -= list->menu_level;
 assert(area.row > 1);
 menu_layout(&menu, &area);
 /* Set up the screen */
 screen_save();
 window_make(area.col - 2, area.row - 1, area.col + 39, area.row + 13);
 while (1) {
  /* Select an entry */
  evt = menu_select(&menu, 0, true);
  if (evt.type == EVT_SELECT) {
   if (list->list[menu.cursor].cmd ||
     list->list[menu.cursor].hook) {
    /* It's a proper command. */
    *selection = &list->list[menu.cursor];
    break;
   } else {
    /*
				 * It's a placeholder that's a parent for a
				 * nested menu.
				 */
    /*
				 * Look up the list of commands for the nested
				 * menu.
				 */
    if (list->list[menu.cursor].nested_cached_idx == -1) {
     list->list[menu.cursor].nested_cached_idx =
      cmd_list_lookup_by_name(list->list[menu.cursor].nested_name);
    }
    if (list->list[menu.cursor].nested_cached_idx >= 0) {
     /* Display a menu for it. */
     if (!cmd_menu(&cmds_all[list->list[menu.cursor].nested_cached_idx], selection_p)) {
      break;
     }
    } else {
     break;
    }
   }
  } else if (evt.type == EVT_ESCAPE) {
   /*
			 * Return to the containing menu and don't break out all
			 * the way to main game loop.
			 */
   result = true;
   break;
  }
 }
 /*
	 * Load the screen.  Do a more expensive update if not breaking out
	 * all the way from the menus and there may be partially overwritten
	 * big tiles.
	 */
 if (result && screen_save_depth > 1
   && (tile_width > 1 || tile_height > 1)) {
  screen_load_all();
 } else {
  screen_load();
 }
 return result;
}
static bool cmd_list_action(struct menu *m, const ui_event *event, int oid)
{
 if (event->type == EVT_SELECT)
  return cmd_menu(&cmds_all[oid], menu_priv(m));
 else
  return false;
}
static void cmd_list_entry(struct menu *menu, int oid, bool cursor, int row,
         int col, int width)
{
 uint8_t attr = (cursor ? COLOUR_L_BLUE : COLOUR_WHITE);
 Term_putstr(col, row, -1, attr, cmds_all[oid].name);
}
static struct menu *command_menu;
static menu_iter command_menu_iter =
{
 NULL,
 NULL,
 cmd_list_entry,
 cmd_list_action,
 NULL
};
/**
 * Display a list of command types, allowing the user to select one.
 */
struct cmd_info *textui_action_menu_choose(void)
{
 region area = { 21, 5, 37, 6 };
 int len = 0;
 struct cmd_info *chosen_command = NULL;
 if (!command_menu)
  command_menu = menu_new(MN_SKIN_SCROLL, &command_menu_iter);
 while (cmds_all[len].len && cmds_all[len].menu_level == 0) {
  len++;
 };
 menu_setpriv(command_menu, len, &chosen_command);
 menu_layout(command_menu, &area);
 /* Set up the screen */
 screen_save();
 window_make(19, 4, 58, 11);
 menu_select(command_menu, 0, true);
 screen_load();
 return chosen_command;
}
/**
 * \file ui-death.c
 * \brief Handle the UI bits that happen after the character dies.
 *
 * Copyright (c) 1987 - 2007 Angband contributors
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Display the exit screen
 */
static void display_exit_screen(struct high_score *score)
{
 if (player->escaped) {
  Term_putstr(15, 2, -1, COLOUR_L_BLUE, "You have escaped");
 } else if (streq(player->died_from, "Retiring")) {
  Term_putstr(15, 2, -1, COLOUR_L_BLUE, "You have retired");
 } else {
  Term_putstr(15, 2, -1, COLOUR_L_BLUE, "You have been slain");
 }
 display_single_score(score, 1, 0, COLOUR_WHITE);
 Term_putstr( 3, 10, -1, COLOUR_L_DARK, "____________________________________________________");
 prt_mini_screenshot(5, 14);
}
/**
 * Menu command: see top twenty scores.
 */
static void death_scores(const char *title, int row)
{
 screen_save();
 show_scores();
 screen_load();
}
/**
 * Menu command: examine items in the inventory.
 */
static void death_examine(const char *title, int row)
{
 struct object *obj;
 const char *q, *s;
 /* Get an item */
 q = "Examine which item? ";
 s = "You have nothing to examine.";
 while (get_item(&obj, q, s, 0, NULL, (USE_INVEN | USE_QUIVER | USE_EQUIP | IS_HARMLESS))) {
  char header[120];
  textblock *tb;
  region area = { 0, 0, 0, 0 };
  tb = object_info(obj, OINFO_NONE);
  object_desc(header, sizeof(header), obj,
   ODESC_PREFIX | ODESC_FULL | ODESC_CAPITAL, player);
  textui_textblock_show(tb, area, header);
  textblock_free(tb);
 }
}
/**
 * Menu command: Look at the dungeon.
 */
static void death_dungeon(const char *title, int row)
{
 int i;
 struct object *obj;
 /* Save screen */
 screen_save();
 /* Dungeon objects */
 for (i = 1; i < cave->obj_max; i++) {
  /* Get the next object from the dungeon */
  obj = cave->objects[i];
  /* Skip dead objects */
  if (!obj || !obj->kind) continue;
  /* ID it */
  object_flavor_aware(player, obj);
  object_see(player, obj);
  object_touch(player, obj);
  player_know_object(player, obj);
 }
 /* Light the level, show all monsters and redraw */
 Term_clear();
 wiz_light(cave, player);
 effect_simple(EF_DETECT_MONSTERS, source_player(), "0",
  0, 0, 0, NULL);
 player->upkeep->redraw |= 0x0FFFFFFFL;
 handle_stuff(player);
 /* Allow the player to look around */
 prt_map();
 do_cmd_look();
 /* Load screen */
 screen_load();
}
/**
 * Menu command: peruse pre-death messages.
 */
static void death_messages(const char *title, int row)
{
 screen_save();
 do_cmd_messages();
 screen_load();
}
/**
 * Menu command: view character dump and inventory.
 */
static void death_info(const char *title, int row)
{
 screen_save();
 /* Display player */
 display_player(0);
 /* Prompt for inventory */
 prt("Hit any key to see more information: ", 0, 0);
 /* Allow abort at this point */
 (void)anykey();
 /* Show equipment and inventory */
 /* Equipment -- if any */
 if (player->upkeep->equip_cnt) {
  Term_clear();
  show_equip(OLIST_WEIGHT | OLIST_SEMPTY | OLIST_DEATH, NULL);
  prt("You are using: -more-", 0, 0);
  (void)anykey();
 }
 /* Inventory -- if any */
 if (player->upkeep->inven_cnt) {
  Term_clear();
  show_inven(OLIST_WEIGHT | OLIST_DEATH, NULL);
  prt("You are carrying: -more-", 0, 0);
  (void)anykey();
 }
 screen_load();
}
/**
 * Menu command: view character history.
 */
static void death_history(const char *title, int row)
{
 history_display();
}
/**
 * Menu command: add to character history.
 */
static void death_note(const char *title, int row)
{
 do_cmd_note();
}
/**
 * Menu command: dump character dump to file.
 */
static void death_file(const char *title, int row)
{
 char buf[1024];
 char ftmp[80];
 /* Get the filesystem-safe name and append .txt */
 player_safe_name(ftmp, sizeof(ftmp), player->full_name, false);
 my_strcat(ftmp, ".txt", sizeof(ftmp));
 if (get_file(ftmp, buf, sizeof buf)) {
  bool success;
  /* Dump a character file */
  screen_save();
  success = dump_save(buf);
  screen_load();
  /* Check result */
  if (success)
   msg("Character dump successful.");
  else
   msg("Character dump failed!");
  /* Flush messages */
  event_signal(EVENT_MESSAGE_FLUSH);
 }
}
/**
 * Menu command: allow spoiler generation (mainly for randarts).
 */
static void death_spoilers(const char *title, int row)
{
 do_cmd_spoilers();
}
/**
 * Menu command: start a new game
 */
static void death_new_game(const char *title, int row)
{
    play_again = get_check("Start a new game? ");
}
/**
 * Menu structures for the death menu. Note that Quit must always be the
 * last option, due to a hard-coded check in death_screen
 */
static menu_action death_actions[] =
{
 { 0, 'v', "View scores", death_scores },
 { 0, 'x', "View inventory and equipment", death_examine },
 { 0, 'd', "View dungeon", death_dungeon },
 { 0, 'm', "View final messages", death_messages },
 { 0, 'c', "View character sheet", death_info },
 { 0, 'h', "View character history", death_history },
 { 0, 'a', "Add comment to history", death_note },
 { 0, 'f', "Save character sheet", death_file },
 { 0, 's', "Spoilers", death_spoilers },
 { 0, 'g', "Another game", death_new_game },
 { 0, 'q', "Quit", NULL },
};
/**
 * Handle character death
 */
void death_screen(void)
{
 struct menu *death_menu;
 bool done = false;
 const region area = { 15, 12, 0, N_ELEMENTS(death_actions) };
 time_t death_time = (time_t)0;
 struct high_score score;
 /* Get time of death, prepare score */
 (void)time(&death_time);
 build_score(&score, player, player->died_from, &death_time);
 clear_from(0);
 display_exit_screen(&score);
 /* Flush all input and output */
 event_signal(EVENT_INPUT_FLUSH);
 event_signal(EVENT_MESSAGE_FLUSH);
 /* Display and use the death menu */
 death_menu = menu_new_action(death_actions,
   N_ELEMENTS(death_actions));
 death_menu->flags = MN_CASELESS_TAGS;
 menu_layout(death_menu, &area);
 while (!done && !play_again) {
  ui_event e = menu_select(death_menu, EVT_KBRD, false);
  if (e.type == EVT_KBRD) {
   if (e.key.code == KTRL('X')) break;
   if (e.key.code == KTRL('N')) play_again = true;
  } else if (e.type == EVT_SELECT) {
   done = true;
  }
 }
 menu_free(death_menu);
}
/**
 * \file ui-display.c
 * \brief Handles the setting up updating, and cleaning up of the game display.
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 * Copyright (c) 2007 Antony Sidwell
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * There are a few functions installed to be triggered by several 
 * of the basic player events.  For convenience, these have been grouped 
 * in this list.
 */
static game_event_type player_events[] =
{
 EVENT_NAME,
 EVENT_EXPERIENCE,
 EVENT_EQUIPMENT, /* For equippy chars */
 EVENT_STATS,
 EVENT_HP,
 EVENT_MANA,
 EVENT_MELEE,
 EVENT_ARCHERY,
 EVENT_ARMOR,
 EVENT_MONSTERHEALTH,
 EVENT_DUNGEONLEVEL,
 EVENT_STATUS,
 EVENT_SONG
};
static game_event_type statusline_events[] =
{
 EVENT_STATUS,
 EVENT_STATE,
 EVENT_LIGHT,
 EVENT_PLAYERSPEED,
};
/**
 * Abbreviations of healthy stats
 */
const char *stat_names[STAT_MAX] =
{
 "STR: ", "DEX: ", "CON: ", "GRA: "
};
/**
 * Abbreviations of damaged stats
 */
const char *stat_names_reduced[STAT_MAX] =
{
 "Str: ", "Dex: ", "Con: ", "Gra: "
};
/**
 * Help prt_tmd(), prt_cut(), and prt_poisoned(), print the indicator for
 * the timed effect, ind.  Return the number of characters printed.
 */
static int prt_one_tmd(int row, int col, int ind)
{
 int printed = 0;
 if (timed_effects[ind].grade) {
  const struct timed_grade *grade = timed_effects[ind].grade;
  while (player->timed[ind] > grade->max) {
   grade = grade->next;
   assert(grade);
  }
  if (grade->name) {
   c_put_str(grade->color, grade->name, row, col);
   printed = (int)strlen(grade->name);
  }
 } else if (timed_effects[ind].c_grade) {
  const struct timed_change_grade *cg =
   timed_effects[ind].c_grade;
  while (player->timed[ind] > cg->max) {
   cg = cg->next;
   assert(cg);
  }
  if (cg->name) {
   if (cg->digits > 0) {
    char *meter = format("%s %-*d",
     cg->name, cg->digits,
     player->timed[ind]);
    c_put_str(cg->color, meter, row, col);
    printed = (int)strlen(meter);
   } else {
    c_put_str(cg->color, cg->name, row, col);
    printed = (int)strlen(cg->name);
   }
  }
 }
 return printed;
}
/**
 * ------------------------------------------------------------------------
 * Sidebar display functions
 * ------------------------------------------------------------------------ */
/**
 * Print character info at given row, column in a 13 char field
 */
static void prt_field(const char *info, int row, int col)
{
 /* Dump 13 spaces to clear */
 c_put_str(COLOUR_WHITE, "             ", row, col);
 /* Dump the info itself */
 c_put_str(COLOUR_L_BLUE, info, row, col);
}
/**
 * Print character name in given row, column
 */
static void prt_name(int row, int col)
{
 if (strlen(player->full_name) <= 12) {
  prt_field(player->full_name, row, col);
 }
}
/**
 * Print character stat in given row, column
 */
static void prt_stat(int stat, int row, int col)
{
 char tmp[32];
 /* Injured or healthy stat */
 if (player->stat_drain[stat] < 0) {
  put_str(stat_names_reduced[stat], row, col);
  strnfmt(tmp, sizeof(tmp), "    %2d", player->state.stat_use[stat]);
  c_put_str(COLOUR_YELLOW, tmp, row, col + 6);
 } else {
  put_str(stat_names[stat], row, col);
  strnfmt(tmp, sizeof(tmp), "    %2d", player->state.stat_use[stat]);
  c_put_str(COLOUR_L_GREEN, tmp, row, col + 6);
 }
 /* Indicate temporary modifiers */
 if ((stat == STAT_STR) && player->timed[TMD_STR])
  put_str("*", row, col + 3);
 if ((stat == STAT_DEX) && player->timed[TMD_DEX])
  put_str("*", row, col + 3);
 if ((stat == STAT_CON) && player->timed[TMD_CON])
  put_str("*", row, col + 3);
 if ((stat == STAT_GRA) && player->timed[TMD_GRA])
  put_str("*", row, col + 3);
}
/**
 * Display the experience
 */
static void prt_exp(int row, int col)
{
 char out_val[32];
 /* Format XP */
 strnfmt(out_val, sizeof(out_val), "%8d", player->new_exp);
 put_str("Exp ", row, col);
 c_put_str(COLOUR_L_GREEN, out_val, row, col + 4);
}
/**
 * Equippy chars (ASCII representation of gear in equipment slot order)
 */
static void prt_equippy(int row, int col)
{
 int i;
 uint8_t a;
 wchar_t c;
 struct object *obj;
 /* Dump equippy chars */
 for (i = 0; i < player->body.count; i++) {
  /* Object */
  obj = slot_object(player, i);
  /* Get attr/char for display; clear if big tiles or no object */
  if (obj && tile_width == 1 && tile_height == 1) {
   c = object_char(obj);
   a = object_attr(obj);
  } else {
   c = L' ';
   a = COLOUR_WHITE;
  }
  /* Dump */
  Term_putch(col + i, row, a, c);
 }
}
/**
 * Prints current melee
 */
static void prt_mel(int row, int col)
{
 char buf[32];
 struct object *off = equipped_item_by_slot_name(player, "arm");
 int mod = off && tval_is_weapon(off) ? -1 : 0;
 /* Melee attacks */
 strnfmt(buf, sizeof(buf), "(%+d,%dd%d)",
   player->state.skill_use[SKILL_MELEE],
   player->state.mdd, player->state.mds);
 put_str(format("%12s", buf), row + mod, col);
 if (player_active_ability(player, "Rapid Attack")) {
  put_str("2x", row + mod, col);
 }
 if (!mod) {
  put_str("            ", row - 1, col);
 } else {
  strnfmt(buf, sizeof(buf), "(%+d,%dd%d)",
    player->state.skill_use[SKILL_MELEE]
    + player->state.offhand_mel_mod,
    player->state.mdd2, player->state.mds2);
  put_str(format("%12s", buf), row, col);
 }
}
/**
 * Prints current archery
 */
static void prt_arc(int row, int col)
{
 char buf[32];
 /* Range attacks */
 if (equipped_item_by_slot_name(player, "shooting")) {
  strnfmt(buf, sizeof(buf), "(%+d,%dd%d)",
    player->state.skill_use[SKILL_ARCHERY],
    player->state.add, player->state.ads);
  c_put_str(COLOUR_UMBER, format("%12s", buf), row, col);
  if (player_active_ability(player, "Rapid Fire")) {
   c_put_str(COLOUR_UMBER, "2x", row, col);
   //} else {
   //strnfmt(buf, sizeof(buf), "            ");
   //put_str("            ", row, col);
  }
 }
}
/**
 * Prints current evasion
 */
static void prt_evn(int row, int col)
{
 char buf[32];
 /* Total Armor */
 strnfmt(buf, sizeof(buf), "[%+d,%d-%d]",
   player->state.skill_use[SKILL_EVASION],
   protection_roll(player, PROJ_HURT, true, MINIMISE),
   protection_roll(player, PROJ_HURT, true, MAXIMISE));
 c_put_str(COLOUR_SLATE, format("%12s", buf), row, col);
}
/**
 * Prints current hitpoints
 */
static void prt_hp(int row, int col)
{
 char cur_hp[32], health[32];
 uint8_t color = player_hp_attr(player);
 int len;
 if (player->mhp >= 100) {
  put_str("Hth        ", row, col);
 } else {
  put_str("Health      ", row, col);
 }
 len = strnfmt(health, sizeof(health), "%d:%d", player->chp, player->mhp);
 c_put_str(COLOUR_L_GREEN, health, row, col + 12 - len);
 /* Done? */
 if (player->chp >= player->mhp) return;
 /* Show current hitpoints using another color */
 strnfmt(cur_hp, sizeof(cur_hp), "%d", player->chp);
 c_put_str(color, cur_hp, row, col + 12 - len);
}
/**
 * Prints players max/cur voice
 */
static void prt_sp(int row, int col)
{
 char cur_sp[32], voice[32];
 uint8_t color = player_sp_attr(player);
 int len;
 if (player->msp >= 100) {
  put_str("Vce        ", row, col);
 } else {
  put_str("Voice      ", row, col);
 }
 len = strnfmt(voice, sizeof(voice), "%d:%d", player->csp, player->msp);
 c_put_str(COLOUR_L_GREEN, voice, row, col + 12 - len);
 /* Done? */
 if (player->csp >= player->msp) return;
 /* Show current voice using another color */
 strnfmt(cur_sp, sizeof(cur_sp), "%d", player->csp);
 c_put_str(color, cur_sp, row, col + 12 - len);
}
/**
 * Prints player's current song (if any)
 */
static void prt_song(int row, int col)
{
 char buf[80];
 struct song *song1 = player->song[SONG_MAIN];
 struct song *song2 = player->song[SONG_MINOR];
 struct song *slaying = lookup_song("Slaying");
 int slaying_bonus = song_bonus(player, player->state.skill_use[SKILL_SONG],
           slaying);
 /* Wipe old songs */
 put_str("             ", row, col);
 put_str("             ", row + 1, col);
 /* Show the first song */
 if (player->song[SONG_MAIN]) {
  c_put_str(COLOUR_L_BLUE, song1->name, row, col);
 }
 /* Show the second song */
 if (player->song[SONG_MINOR]) {
  c_put_str(COLOUR_BLUE, song2->name, row + 1, col);
 }
 /* Show the slaying score */
 if (slaying_bonus > 0) {
  strnfmt(buf, sizeof(buf), "+%d", slaying_bonus);
  if (song1 == slaying) {
   c_put_str(COLOUR_L_BLUE, buf, row, col + 8);
  } else if (song2 == slaying) {
   c_put_str(COLOUR_BLUE, buf, row + 1, col + 8);
  }
 }
}
/**
 * Calculate the monster bar color separately, for ports.
 * Also used for the player glyph on the map
 */
uint8_t health_attr(int current, int max)
{
 uint8_t attr;
 switch (health_level(current, max)) {
  case HEALTH_UNHURT: attr = COLOUR_WHITE; break;
  case HEALTH_SOMEWHAT_WOUNDED: attr = COLOUR_YELLOW; break;
  case HEALTH_WOUNDED: attr = COLOUR_ORANGE; break;
  case HEALTH_BADLY_WOUNDED: attr = COLOUR_L_RED; break;
  case HEALTH_ALMOST_DEAD: attr = COLOUR_RED; break;
  default: attr = COLOUR_RED; break;
 }
 return attr;
}
static int prt_health_aux(int row, int col)
{
 struct monster *mon = player->upkeep->health_who;
 char buf[20];
 int len = 0;
 uint8_t attr = COLOUR_L_DARK;
 /* Not tracking */
 if (!mon) {
  /* Erase the health bar */
  Term_erase(col, row, 12);
  /* Erase the morale bar */
  Term_erase(col, row + 1, 12);
  return 0;
 }
 /* Tracking an unseen, hallucinatory, or dead monster */
 if (!monster_is_visible(mon) || /* Unseen */
  (player->timed[TMD_IMAGE]) || /* Hallucination */
  (mon->hp <= 0)) { /* Dead (?) */
  /* The monster health is "unknown" */
  Term_putstr(col, row, 12, attr, "  --------  ");
  /* Erase the morale bar */
  Term_erase(col, row + 1, 12);
  return 12;
 }
 /* Visible */
 attr = health_attr(mon->hp, mon->maxhp);
 /* Convert into health bar (using ceiling for length) */
 len = (8 * mon->hp + mon->maxhp - 1) / mon->maxhp;
 /* Default to "unknown" */
 Term_putstr(col, row, 12, COLOUR_WHITE, "  --------  ");
 /* Dump the current "health" (handle monster stunning, confusion) */
 if (mon->m_timed[MON_TMD_CONF] && mon->m_timed[MON_TMD_STUN])
  Term_putstr(col + 2, row, len, attr, "cscscscs");
 else if (mon->m_timed[MON_TMD_CONF])
  Term_putstr(col + 2, row, len, attr, "cccccccc");
 else if (mon->m_timed[MON_TMD_STUN])
  Term_putstr(col + 2, row, len, attr, "ssssssss");
 else
  Term_putstr(col + 2, row, len, attr, "********");
 /* Show the alertness/morale bar */
 Term_erase(col, row + 1, 12);
 if (mon->alertness < ALERTNESS_UNWARY) {
  my_strcpy(buf, "Sleeping", sizeof(buf));
  attr = COLOUR_BLUE;
  len = strlen(buf);
 } else if (mon->alertness < ALERTNESS_ALERT) {
  my_strcpy(buf, "Unwary", sizeof(buf));
  attr = COLOUR_L_BLUE;
  len = strlen(buf);
 } else {
  if (rf_has(mon->race->flags, RF_MINDLESS)) {
   my_strcpy(buf, "Mindless", sizeof(buf));
   attr = COLOUR_L_DARK;
   len = strlen(buf);
  } else {
   char tmp[20];
   /* Morale */
   if (mon->stance == STANCE_FLEEING) {
    my_strcpy(tmp, "Fleeing", sizeof(tmp));
    attr = COLOUR_VIOLET;
   } else if (mon->stance == STANCE_CONFIDENT) {
    my_strcpy(tmp, "Confident", sizeof(tmp));
    attr = COLOUR_L_WHITE;
   } else if (mon->stance == STANCE_AGGRESSIVE) {
    my_strcpy(tmp, "Aggress", sizeof(tmp));
    attr = COLOUR_L_WHITE;
   } else {
                /* Sometimes (only in debugging?) we are looking at a monster
				 * before it has a stance in this case just exit and don't do
				 * anything (to avoid printing uninitialised strings!) */
    return 0;
   }
   if (mon->morale >= 0) {
    len = strnfmt(buf, sizeof(buf), "%s %d", tmp,
         (mon->morale + 9) / 10);
   } else {
    len = strnfmt(buf, sizeof(buf), "%s %d", tmp, mon->morale / 10);
   }
  }
 }
 Term_putstr(col, row + 1, 12, COLOUR_DARK, "            ");
 Term_putstr(col + (13 - len) / 2, row + 1, MIN(len, 12), attr, buf);
 return 12;
}
/**
 * Redraw the "monster health bar"
 *
 * The "monster health bar" provides visual feedback on the "health"
 * of the monster currently being "tracked".  There are several ways
 * to "track" a monster, including targetting it, attacking it, and
 * affecting it (and nobody else) with a ranged attack.  When nothing
 * is being tracked, we clear the health bar.  If the monster being
 * tracked is not currently visible, a special health bar is shown.
 */
static void prt_health(int row, int col)
{
 prt_health_aux(row, col);
}
/**
 * Displays the amount of bleeding.
 * This is a bit tricky as it is in the same row as poison, *unless* you have
 * both, in which case it is the row above.
 */
static void prt_cut(int row, int col)
{
 int r = row;
 if (player->timed[TMD_POISONED]) r--;
 /* Clear out what was there before. */
 put_str(format("%*s", col_map[SIDEBAR_LEFT] - col, " "), r, col);
 prt_one_tmd(r, col, TMD_CUT);
}
/**
 * Prints Poisoned status
 */
static void prt_poisoned(int row, int col)
{
 /* Clear out what was there before. */
 put_str(format("%*s", col_map[SIDEBAR_LEFT] - col, " "), row, col);
 prt_one_tmd(row, col, TMD_POISONED);
}
/**
 * Prints the speed of a character.
 */
static void prt_speed(int row, int col)
{
 int i = player->state.speed;
 const char *type = NULL;
 uint8_t attr = COLOUR_WHITE;
 char buf[32] = "";
 /* 2 is normal speed, and requires no display */
 if (i > 2) {
  attr = COLOUR_L_GREEN;
  type = "Fast ";
 } else if (i < 2) {
  attr = COLOUR_ORANGE;
  type = "Slow ";
 }
 if (type)
  strnfmt(buf, sizeof(buf), "%s", type);
 /* Display the speed */
 c_put_str(attr, format("%-4s", buf), row, col);
}
/**
 * Some simple wrapper functions
 */
static void prt_str(int row, int col) { prt_stat(STAT_STR, row, col); }
static void prt_dex(int row, int col) { prt_stat(STAT_DEX, row, col); }
static void prt_con(int row, int col) { prt_stat(STAT_CON, row, col); }
static void prt_gra(int row, int col) { prt_stat(STAT_GRA, row, col); }
static int prt_stat_short(int stat, int row, int col)
{
 char tmp[32];
 /* Injured or healthy stat */
 if (player->stat_drain[stat] < 0) {
  put_str(format("%c:", stat_names_reduced[stat][0]), row, col);
  strnfmt(tmp, sizeof(tmp), "    %2d", player->state.stat_use[stat]);
  /* Trim whitespace */
  strskip(tmp,' ', 0);
  c_put_str(COLOUR_YELLOW, tmp, row, col + 2);
 } else {
  put_str(format("%c:", stat_names[stat][0]), row, col);
  strnfmt(tmp, sizeof(tmp), "    %2d", player->state.stat_use[stat]);
  /* Trim whitespace */
  strskip(tmp,' ', 0);
  c_put_str(COLOUR_L_GREEN, tmp, row, col + 2);
 }
 return 3+strlen(tmp);
}
static int prt_exp_short(int row, int col)
{
 char out_val[32];
 long xp = (long)player->exp;
 /* Format XP */
 strnfmt(out_val, sizeof(out_val), "%ld", xp);
 put_str("EXP:", row, col);
 c_put_str(COLOUR_L_GREEN, out_val, row, col + 4);
 return 5+strlen(out_val);
}
static int prt_hp_short(int row, int col)
{
 char cur_hp[32], max_hp[32];
 uint8_t color = player_hp_attr(player);
 put_str("HP:", row, col);
 col += 3;
 strnfmt(max_hp, sizeof(max_hp), "%d", player->mhp);
 strnfmt(cur_hp, sizeof(cur_hp), "%d", player->chp);
 c_put_str(color, cur_hp, row, col);
 col += strlen(cur_hp);
 c_put_str(COLOUR_WHITE, "/", row, col);
 col += 1;
 c_put_str(COLOUR_L_GREEN, max_hp, row, col);
 return 5+strlen(cur_hp)+strlen(max_hp);
}
static int prt_sp_short(int row, int col)
{
 char cur_sp[32], max_sp[32];
 uint8_t color = player_sp_attr(player);
 put_str("Vo:", row, col);
 col += 3;
 strnfmt(max_sp, sizeof(max_sp), "%d", player->msp);
 strnfmt(cur_sp, sizeof(cur_sp), "%d", player->csp);
 /* Show mana */
 c_put_str(color, cur_sp, row, col);
 col += strlen(cur_sp);
 c_put_str(COLOUR_WHITE, "/", row, col);
 col += 1;
 c_put_str(COLOUR_L_GREEN, max_sp, row, col);
 return 5+strlen(cur_sp)+strlen(max_sp);
}
static int prt_health_short(int row, int col)
{
 int len = prt_health_aux(row, col);
 if (len > 0) {
  return len+1;
 }
 return 0;
}
static void update_topbar(game_event_type type, game_event_data *data,
        void *user, int row)//TODO short display versions
{
 int col = 0;
 prt("", row, col);
 col += prt_exp_short(row, col);
 col += prt_stat_short(STAT_STR, row, col);
 col += prt_stat_short(STAT_DEX, row, col);
 col += prt_stat_short(STAT_CON, row, col);
 col += prt_stat_short(STAT_GRA, row, col);
 ++row;
 col = 0;
 prt("", row, col);
 col += prt_hp_short(row, col);
 col += prt_sp_short(row, col);
 col += prt_health_short(row, col);
}
/**
 * Struct of sidebar handlers.
 */
static const struct side_handler_t
{
 void (*hook)(int, int); /* int row, int col */
 int priority; /* 1 is most important (always displayed) */
 game_event_type type; /* PR_* flag this corresponds to */
} side_handlers[] = {
 { NULL, 21, 0 },
 { prt_name, 13, EVENT_NAME },
 { NULL, 22, 0 },
 { prt_str, 4, EVENT_STATS },
 { prt_dex, 3, EVENT_STATS },
 { prt_con, 2, EVENT_STATS },
 { prt_gra, 1, EVENT_STATS },
 { NULL, 23, 0 },
 { prt_exp, 5, EVENT_EXPERIENCE },
 { NULL, 24, 0 },
 { prt_hp, 6, EVENT_HP },
 { prt_sp, 7, EVENT_MANA },
 { NULL, 17, 0 },
 { prt_mel, 8, EVENT_MELEE },/* May overlap upwards */
 { prt_arc, 9, EVENT_ARCHERY },
 { prt_evn, 10, EVENT_ARMOR },
 { NULL, 25, 0 },
 { prt_health, 11, EVENT_MONSTERHEALTH },/* May overlap downwards */
 { NULL, 14, 0 },
 { NULL, 20, 0 },
 { prt_cut, 15, EVENT_STATUS },/* May overlap upwards */
 { prt_poisoned,16, EVENT_STATUS },
 { prt_song, 12, EVENT_SONG },/* May overlap downwards */
 { NULL, 18, 0 },
 { prt_speed, 19, EVENT_STATUS },
};
/**
 * This prints the sidebar, using a clever method which means that it will only
 * print as much as can be displayed on <24-line screens.
 *
 * Each row is given a priority; the least important higher numbers and the most
 * important lower numbers.  As the screen gets smaller, the rows start to
 * disappear in the order of lowest to highest importance.
 */
static void update_sidebar(game_event_type type, game_event_data *data,
         void *user)
{
 int x, y, row;
 int max_priority;
 size_t i;
 if (Term->sidebar_mode == SIDEBAR_NONE) {
  return;
 }
 if (Term->sidebar_mode == SIDEBAR_TOP) {
  update_topbar(type, data, user, 1);
  return;
 }
 Term_get_size(&x, &y);
 /* Keep the top and bottom lines clear. */
 max_priority = y - 2;
 /* Display list entries */
 for (i = 0, row = 1; i < N_ELEMENTS(side_handlers); i++) {
  const struct side_handler_t *hnd = &side_handlers[i];
  int priority = hnd->priority;
  bool from_bottom = false;
  /* Negative means print from bottom */
  if (priority < 0) {
   priority = -priority;
   from_bottom = true;
  }
  /* If this is high enough priority, display it */
  if (priority <= max_priority) {
   if (hnd->type == type && hnd->hook) {
    if (from_bottom)
     hnd->hook(Term->hgt - (N_ELEMENTS(side_handlers) - i), 0);
    else
        hnd->hook(row, 0);
   }
   /* Increment for next time */
   row++;
  }
 }
}
/**
 * Redraw player, since the player's color indicates approximate health.  Note
 * that using this command is only for when graphics mode is off, as
 * otherwise it causes the character to be a black square.
 */
static void hp_colour_change(game_event_type type, game_event_data *data,
        void *user)
{
 if (use_graphics == GRAPHICS_NONE)
  square_light_spot(cave, player->grid);
}
/**
 * ------------------------------------------------------------------------
 * Status line display functions
 * ------------------------------------------------------------------------ */
/**
 * Struct to describe different timed effects
 */
struct state_info
{
 int value;
 const char *str;
 size_t len;
 uint8_t attr;
};
/**
 * Prints Resting, or 'count' status
 * Display is always exactly 10 characters wide (see below)
 *
 * This function was a major bottleneck when resting, so a lot of
 * the text formatting code was optimized in place below.
 */
static size_t prt_state(int row, int col)
{
 uint8_t attr = COLOUR_WHITE;
 char text[16] = "";
 /* Smithing */
 if (player->upkeep->smithing) {
  my_strcpy(text, "Smithing  ", sizeof (text));
 } else if (player_is_resting(player)) {
  int i;
  int n = player_resting_count(player);
  /* Start with "Rest" */
  my_strcpy(text, "Rest      ", sizeof(text));
  /* Display according to length or intent of rest */
  if (n >= 1000) {
   i = n / 100;
   text[9] = '0';
   text[8] = '0';
   text[7] = I2D(i % 10);
   if (i >= 10) {
    i = i / 10;
    text[6] = I2D(i % 10);
    if (i >= 10)
     text[5] = I2D(i / 10);
   }
  } else if (n >= 100) {
   i = n;
   text[9] = I2D(i % 10);
   i = i / 10;
   text[8] = I2D(i % 10);
   text[7] = I2D(i / 10);
  } else if (n >= 10) {
   i = n;
   text[9] = I2D(i % 10);
   text[8] = I2D(i / 10);
  } else if (n > 0) {
   i = n;
   text[9] = I2D(i);
  } else if (n == REST_ALL_POINTS)
   text[5] = text[6] = text[7] = text[8] = text[9] = '*';
  else if (n == REST_COMPLETE)
   text[5] = text[6] = text[7] = text[8] = text[9] = '&';
  else if (n == REST_SOME_POINTS)
   text[5] = text[6] = text[7] = text[8] = text[9] = '!';
 } else if (cmd_get_nrepeats()) {
  int nrepeats = cmd_get_nrepeats();
  if (nrepeats > 999)
   strnfmt(text, sizeof(text), "Rep. %3d00", nrepeats / 100);
  else
   strnfmt(text, sizeof(text), "Repeat %3d", nrepeats);
 } else if (player->stealth_mode) {
  my_strcpy(text, "Stealth   ", sizeof (text));
 }
 /* Display the info (or blanks) */
 c_put_str(attr, text, row, col);
 return strlen(text) + 1;
}
/**
 * Prints player grid light level
 */
static size_t prt_light(int row, int col)
{
 int light = square_light(cave, player->grid);
 if (light > 0) {
  c_put_str(COLOUR_YELLOW, format("Light %d ", light), row, col);
 } else {
  c_put_str(COLOUR_PURPLE, format("Light %d ", light), row, col);
 }
 return 8 + (ABS(light) > 9 ? 1 : 0) + (light < 0 ? 1 : 0);
}
/**
 * Get the longest relevant terrain or trap name for prt_terrain()
 */
static int longest_terrain_name(void)
{
 size_t i, max = 0;
 for (i = 0; i < z_info->trap_max; i++) {
  if (strlen(trap_info[i].name) > max) {
   max = strlen(trap_info[i].name);
  }
 }
 for (i = 0; i < FEAT_MAX; i++) {
  if (strlen(f_info[i].name) > max) {
   max = strlen(f_info[i].name);
  }
 }
 return max;
}
/**
 * Prints player trap (if any) or terrain
 */
static size_t prt_terrain(int row, int col)
{
 struct feature *feat = square_feat(cave, player->grid);
 struct trap *trap = square_trap(cave, player->grid);
 char buf[30];
 uint8_t attr;
 if (trap && !square_isinvis(cave, player->grid) &&
  !square_isforge(cave, player->grid)) {
  my_strcpy(buf, trap->kind->name, sizeof(buf));
  attr = trap->kind->d_attr;
 } else {
  my_strcpy(buf, feat->name, sizeof(buf));
  attr = feat->d_attr;
 }
 my_strcap(buf);
 c_put_str(attr, format("%s ", buf), row, col);
 return longest_terrain_name() + 1;
}
/**
 * Print all timed effects.
 */
static size_t prt_tmd(int row, int col)
{
 size_t i, len = 0;
 for (i = 0; i < TMD_MAX; i++) {
  /*
		 * Cuts and poisoning are displayed in the sidebar, so skip
		 * them here.
		 */
  if ((i == TMD_CUT || i == TMD_POISONED)
    && Term->sidebar_mode == SIDEBAR_LEFT) {
   continue;
  }
  len += prt_one_tmd(row, col + len, i) + 1;
 }
 return len;
}
/**
 * Print "unignoring" status
 */
static size_t prt_unignore(int row, int col)
{
 if (player->unignoring) {
  const char *str = "Unignoring";
  put_str(str, row, col);
  return strlen(str) + 1;
 }
 return 0;
}
/**
 * Prints depth in stat area
 */
static size_t prt_depth(int row, int col)
{
 char buf[32];
 if (!player->depth)
  my_strcpy(buf, "Surface", sizeof(buf));
 else
  strnfmt(buf, sizeof(buf), "%d'", player->depth * 50);
 /* Right-Adjust the "depth", and clear old values */
 put_str(format("%7s", buf), row, col);
 return 7;
}
/**
 * Descriptive typedef for status handlers
 */
typedef size_t status_f(int row, int col);
static status_f *status_handlers[] =
{ prt_light, prt_unignore, prt_state, prt_tmd, prt_terrain, prt_depth };
static void update_statusline_aux(int row, int col)
{
 size_t i;
 /* Clear the remainder of the line */
 prt("", row, col);
 /* Display those which need redrawing */
 for (i = 0; i < N_ELEMENTS(status_handlers); i++)
  col += status_handlers[i](row, col);
}
/**
 * Print the status line.
 */
static void update_statusline(game_event_type type, game_event_data *data, void *user)
{
 int row = Term->hgt - 1;
 if (Term->sidebar_mode == SIDEBAR_TOP) {
  row = 3;
 }
 update_statusline_aux(row, COL_MAP);
}
/**
 * ------------------------------------------------------------------------
 * Map redraw.
 * ------------------------------------------------------------------------ */
/**
 * Update either a single map grid or a whole map
 */
static void update_maps(game_event_type type, game_event_data *data, void *user)
{
 term *t = user;
 /* This signals a whole-map redraw. */
 if (data->point.x == -1 && data->point.y == -1)
  prt_map();
 /* Single point to be redrawn */
 else {
  struct grid_data g;
  int a, ta;
  wchar_t c, tc;
  int ky, kx;
  int vy, vx;
  int clipy;
  /* Location relative to panel */
  ky = data->point.y - t->offset_y;
  kx = data->point.x - t->offset_x;
  if (t == angband_term[0]) {
   /* Verify location */
   if ((ky < 0) || (ky >= SCREEN_HGT)) return;
   if ((kx < 0) || (kx >= SCREEN_WID)) return;
   /* Location in window */
   vy = tile_height * ky + ROW_MAP;
   vx = tile_width * kx + COL_MAP;
   /* Protect the status line against modification. */
   clipy = ROW_MAP + SCREEN_ROWS;
  } else {
   /* Verify location */
   if ((ky < 0) || (ky >= t->hgt / tile_height)) return;
   if ((kx < 0) || (kx >= t->wid / tile_width)) return;
   /* Location in window */
   vy = tile_height * ky;
   vx = tile_width * kx;
   /* All the rows may be used for the map. */
   clipy = t->hgt;
  }
  /* Redraw the grid spot */
  map_info(data->point, &g);
  grid_data_as_text(&g, &a, &c, &ta, &tc);
  Term_queue_char(t, vx, vy, a, c, ta, tc);
  if ((tile_width > 1) || (tile_height > 1))
   Term_big_queue_char(t, vx, vy, clipy, a, c, COLOUR_WHITE, L' ');
 }
 /* Refresh the main screen unless the map needs to center */
 if (player->upkeep->update & (PU_PANEL) && OPT(player, center_player)) {
  int hgt = (t == angband_term[0]) ? SCREEN_HGT / 2 :
   t->hgt / (tile_height * 2);
  int wid = (t == angband_term[0]) ? SCREEN_WID / 2 :
   t->wid / (tile_width * 2);
  if (panel_should_modify(t, player->grid.y - hgt, player->grid.x - wid))
   return;
 }
 Term_fresh();
}
/**
 * ------------------------------------------------------------------------
 * Animations.
 * ------------------------------------------------------------------------ */
static bool animations_allowed = true;
/**
 * A counter to select the step color from the flicker table.
 */
static uint8_t flicker = 0;
/**
 * This animates monsters and/or items as necessary.
 */
static void do_animation(void)
{
 int i;
 for (i = 1; i < cave_monster_max(cave); i++) {
  uint8_t attr;
  struct monster *mon = cave_monster(cave, i);
  if (!mon || !mon->race || !monster_is_visible(mon))
   continue;
  else if (rf_has(mon->race->flags, RF_ATTR_MULTI))
   attr = randint1(BASIC_COLORS - 1);
  else if (rf_has(mon->race->flags, RF_ATTR_FLICKER)) {
   uint8_t base_attr = monster_x_attr[mon->race->ridx];
   /* Get the color cycled attribute, if available. */
   attr = visuals_cycler_get_attr_for_race(mon->race, flicker);
   if (attr == BASIC_COLORS) {
    /* Fall back to the flicker attribute. */
    attr = visuals_flicker_get_attr_for_frame(base_attr, flicker);
   }
   if (attr == BASIC_COLORS) {
    /* Fall back to the static attribute if cycling fails. */
    attr = base_attr;
   }
  }
  else
   continue;
  mon->attr = attr;
  player->upkeep->redraw |= (PR_MAP | PR_MONLIST);
 }
 flicker++;
}
/**
 * Set animations to allowed
 */
void allow_animations(void)
{
 animations_allowed = true;
}
/**
 * Set animations to disallowed
 */
void disallow_animations(void)
{
 animations_allowed = false;
}
/**
 * Update animations on request
 */
static void animate(game_event_type type, game_event_data *data, void *user)
{
 do_animation();
}
/**
 * This is used when the user is idle to allow for simple animations.
 * Currently the only thing it really does is animate shimmering monsters.
 */
void idle_update(void)
{
 if (!animations_allowed) return;
 if (msg_flag) return;
 if (!character_dungeon) return;
 if (!OPT(player, animate_flicker) || (use_graphics != GRAPHICS_NONE))
  return;
 /* Animate and redraw if necessary */
 do_animation();
 redraw_stuff(player);
 /* Refresh the main screen */
 Term_fresh();
}
/**
 * Find the attr/char pair to use for a spell effect
 *
 * It is moving (or has moved) from (x, y) to (nx, ny); if the distance is not
 * "one", we (may) return "*".
 */
static void bolt_pict(int y, int x, int ny, int nx, int typ, uint8_t *a,
       wchar_t *c)
{
 int motion;
 /* Convert co-ordinates into motion */
 if ((ny == y) && (nx == x))
  motion = BOLT_NO_MOTION;
 else if (nx == x)
  motion = BOLT_0;
 else if ((ny-y) == (x-nx))
  motion = BOLT_45;
 else if (ny == y)
  motion = BOLT_90;
 else if ((ny-y) == (nx-x))
  motion = BOLT_135;
 else
  motion = BOLT_NO_MOTION;
 /* Decide on output char */
 if (use_graphics == GRAPHICS_NONE) {
  /* ASCII is simple */
  wchar_t chars[] = L"*|/-\\";
  *c = chars[motion];
  *a = projections[typ].color;
 } else {
  *a = proj_to_attr[typ][motion];
  *c = proj_to_char[typ][motion];
 }
}
/**
 * Draw an explosion
 */
static void display_explosion(game_event_type type, game_event_data *data,
         void *user)
{
 bool new_radius = false;
 bool drawn = false;
 int i, y, x;
 int msec = player->opts.delay_factor;
 int proj_type = data->explosion.proj_type;
 int num_grids = data->explosion.num_grids;
 int *distance_to_grid = data->explosion.distance_to_grid;
 bool drawing = data->explosion.drawing;
 bool *player_sees_grid = data->explosion.player_sees_grid;
 struct loc *blast_grid = data->explosion.blast_grid;
 struct loc centre = data->explosion.centre;
 /* Draw the blast from inside out */
 for (i = 0; i < num_grids; i++) {
  /* Extract the location */
  y = blast_grid[i].y;
  x = blast_grid[i].x;
  /* Only do visuals if the player can see the blast */
  if (player_sees_grid[i]) {
   uint8_t a;
   wchar_t c;
   drawn = true;
   /* Obtain the explosion pict */
   bolt_pict(y, x, y, x, proj_type, &a, &c);
   /* Just display the pict, ignoring what was under it */
   print_rel(c, a, y, x);
  }
  /* Center the cursor to stop it tracking the blast grids  */
  move_cursor_relative(centre.y, centre.x);
  /* Check for new radius, taking care not to overrun array */
  if (i == num_grids - 1)
   new_radius = true;
  else if (distance_to_grid[i + 1] > distance_to_grid[i])
   new_radius = true;
  /* We have all the grids at the current radius, so draw it */
  if (new_radius) {
   /* Flush all the grids at this radius */
   Term_fresh();
   if (player->upkeep->redraw)
    redraw_stuff(player);
   /* Delay to show this radius appearing */
   if (drawn || drawing) {
    Term_xtra(TERM_XTRA_DELAY, msec);
   }
   new_radius = false;
  }
 }
 /* Erase and flush */
 if (drawn) {
  /* Erase the explosion drawn above */
  for (i = 0; i < num_grids; i++) {
   /* Extract the location */
   y = blast_grid[i].y;
   x = blast_grid[i].x;
   /* Erase visible, valid grids */
   if (player_sees_grid[i])
    event_signal_point(EVENT_MAP, x, y);
  }
  /* Center the cursor */
  move_cursor_relative(centre.y, centre.x);
  /* Flush the explosion */
  Term_fresh();
  if (player->upkeep->redraw)
   redraw_stuff(player);
 }
}
/**
 * Draw a moving spell effect (bolt or beam)
 */
static void display_bolt(game_event_type type, game_event_data *data,
       void *user)
{
 int msec = player->opts.delay_factor;
 int proj_type = data->bolt.proj_type;
 bool drawing = data->bolt.drawing;
 bool seen = data->bolt.seen;
 bool beam = data->bolt.beam;
 int oy = data->bolt.oy;
 int ox = data->bolt.ox;
 int y = data->bolt.y;
 int x = data->bolt.x;
 /* Only do visuals if the player can "see" the bolt */
 if (seen) {
  uint8_t a;
  wchar_t c;
  /* Obtain the bolt pict */
  bolt_pict(oy, ox, y, x, proj_type, &a, &c);
  /* Visual effects */
  print_rel(c, a, y, x);
  move_cursor_relative(y, x);
  Term_fresh();
  if (player->upkeep->redraw)
   redraw_stuff(player);
  Term_xtra(TERM_XTRA_DELAY, msec);
  event_signal_point(EVENT_MAP, x, y);
  Term_fresh();
  if (player->upkeep->redraw)
   redraw_stuff(player);
  /* Display "beam" grids */
  if (beam) {
   /* Obtain the explosion pict */
   bolt_pict(y, x, y, x, proj_type, &a, &c);
   /* Visual effects */
   print_rel(c, a, y, x);
  }
 } else if (drawing) {
  /* Delay for consistency */
  Term_xtra(TERM_XTRA_DELAY, msec);
 }
}
/**
 * Draw a moving missile
 */
static void display_missile(game_event_type type, game_event_data *data,
       void *user)
{
 int msec = player->opts.delay_factor;
 struct object *obj = data->missile.obj;
 bool seen = data->missile.seen;
 int y = data->missile.y;
 int x = data->missile.x;
 /* Only do visuals if the player can "see" the missile */
 if (seen) {
  print_rel(object_char(obj), object_attr(obj), y, x);
  move_cursor_relative(y, x);
  Term_fresh();
  if (player->upkeep->redraw) redraw_stuff(player);
  Term_xtra(TERM_XTRA_DELAY, msec);
  event_signal_point(EVENT_MAP, x, y);
  Term_fresh();
  if (player->upkeep->redraw) redraw_stuff(player);
 }
}
/**
 * Find the attr/char pair to use for a visual hit effect
 */
static void hit_pict(int dam, int typ, bool fatal, uint8_t *a)
{
 if (1) {
  /* Basic hit color */
  if (fatal) {
   *a = COLOUR_RED;
  } else if (!dam) {
   /* only knock back overrides the default for zero damage hits */
   if (typ == PROJ_SOUND) {
    *a = COLOUR_L_UMBER;
   } else {
    *a = COLOUR_L_WHITE;
   }
  } else {
   if (typ == PROJ_POIS) {
    *a = COLOUR_GREEN;
   } else if (typ == PROJ_SOUND) {
    *a = COLOUR_L_UMBER;
   } else {
    *a = COLOUR_L_RED;
   }
  }
 } else {
  /* No graphics support yet */
  //int add;
     //msg_print("Error: displaying hits doesn't work with tiles.");
  // Sil-y: this might look very silly in graphical tiles, but then we don't support them at all
  /* base graphic */
  //base = 0x00;
  //add = 0;
  //k = 0;
  /* Obtain attr/char */
  //a = misc_to_attr[base+k];
  //c = misc_to_char[base+k] + add;
 }
}
static void display_hit(game_event_type type, game_event_data *data, void *user)
{
 /*
	 * Sil 1.3 uses 25 * base delay for 125 in default case; use 3 * base
	 * delay here for 120 in default case.
	 */
 int msec = 3 * player->opts.delay_factor;
 int dam = data->hit.dam;
 int dam_type = data->hit.dam_type;
 bool fatal = data->hit.fatal;
 int y = data->hit.grid.y;
 int x = data->hit.grid.x;
 int ones, tens;
 /* do nothing unless the appropriate option is set */
 if (!OPT(player, display_hits)) return;
 if (dam <= 0) {
  ones = 0;
  tens = 0;
 } else if (dam < 100) {
  ones = dam % 10;
  tens = dam / 10;
 } else {
  /* Display everything greater than 99 as 99. */
  ones = 9;
  tens = 9;
 }
 if (damage_x_attr[0] & 0x80) {
  print_rel(damage_x_char[ones], damage_x_attr[ones], y, x);
  move_cursor_relative(y, x);
  if (dam >= 10) {
   print_rel(damage_x_char[tens], damage_x_attr[tens],
    y, x - 1);
   move_cursor_relative(y, x - 1);
  }
 } else {
  uint8_t a;
  wchar_t c;
  /* Obtain the hit colour */
  hit_pict(dam, dam_type, fatal, &a);
  /* Print the 'ones' digit */
  c = '0' + ones;
  print_rel(c, a, y, x);
  move_cursor_relative(y, x);
  /* Print the 'tens' digit if needed */
  if (dam >= 10) {
   c = '0' + tens;
   print_rel(c, a, y, x - 1);
   move_cursor_relative(y, x - 1);
  }
 }
 Term_fresh();
 Term_xtra(TERM_XTRA_DELAY, msec);
 event_signal_point(EVENT_MAP, x, y);
 if (dam >= 10) {
  event_signal_point(EVENT_MAP, x - 1, y);
 }
 Term_fresh();
 if (player->upkeep->redraw) redraw_stuff(player);
}
/**
 * ------------------------------------------------------------------------
 * Show the poetry on entering Morgoth's Throne Room, etc
 * ------------------------------------------------------------------------ */
static void pause_with_text(game_event_type type, game_event_data *data,
       void *user)
{
 ang_file *fp = NULL;
 char buf[1024];
 int row = data->verse.row;
 int col = data->verse.col;
 int msec = 50;
 if (data->verse.filename) {
  /* Build the filename */
  path_build(buf, 1024, ANGBAND_DIR_GAMEDATA, format("%s.txt",
   data->verse.filename));
  /* Open the file */
  fp = file_open(buf, MODE_READ, FTYPE_TEXT);
  /* Failed */
  if (!fp) {
   return;
  }
 }
 /* Save screen */
 screen_save();
 /* Clear screen */
 Term_clear();
 if (data->verse.filename) {
  /* Read each line and display */
  int i = 0;
  while (file_getl(fp, buf, 80)) {
   c_put_str(COLOUR_WHITE, buf, row + i, col);
   Term_xtra(TERM_XTRA_DELAY, msec);
   Term_fresh();
   i++;
  }
 } else if (data->verse.text) {
  size_t *line_starts = NULL, *line_lengths = NULL;
  const wchar_t *txt;
  size_t n_lines;
  int w, h, i, nln_lim;
  Term_get_size(&w, &h);
  if (w <= col || h <= row) {
   return;
  }
  n_lines = textblock_calculate_lines(data->verse.text,
   &line_starts, &line_lengths, MIN(80, w - col));
  nln_lim = (n_lines < (size_t)w - (size_t)row) ?
   (int)n_lines : w - row;
  txt = textblock_text(data->verse.text);
  for (i = 0; i < nln_lim; ++i) {
   int j;
   for (j = 0; j < (int)line_lengths[i]; ++j) {
    Term_putch(col + j, row + i,
     COLOUR_WHITE, txt[line_starts[i] + j]);
   }
   Term_xtra(TERM_XTRA_DELAY, msec);
   Term_fresh();
  }
  mem_free(line_starts);
  mem_free(line_lengths);
 }
 /* Keypress means done */
 anykey();
 /* Flush messages */
 event_signal(EVENT_MESSAGE_FLUSH);
 /* Close the file */
 if (data->verse.filename) {
  file_close(fp);
 }
 /* Load screen */
 screen_load();
}
/**
 * ------------------------------------------------------------------------
 * Subwindow displays
 * ------------------------------------------------------------------------ */
/**
 * true when we're supposed to display the equipment in the inventory 
 * window, or vice-versa.
 */
static bool flip_inven;
static void update_inven_subwindow(game_event_type type, game_event_data *data,
           void *user)
{
 term *old = Term;
 term *inv_term = user;
 /* Activate */
 Term_activate(inv_term);
 if (!flip_inven)
  show_inven(OLIST_WINDOW | OLIST_WEIGHT, NULL);
 else
  show_equip(OLIST_WINDOW | OLIST_WEIGHT, NULL);
 Term_fresh();
 /* Restore */
 Term_activate(old);
}
static void update_equip_subwindow(game_event_type type, game_event_data *data,
       void *user)
{
 term *old = Term;
 term *inv_term = user;
 /* Activate */
 Term_activate(inv_term);
 if (!flip_inven)
  show_equip(OLIST_WINDOW | OLIST_WEIGHT, NULL);
 else
  show_inven(OLIST_WINDOW | OLIST_WEIGHT, NULL);
 Term_fresh();
 /* Restore */
 Term_activate(old);
}
/**
 * Flip "inven" and "equip" in any sub-windows
 */
void toggle_inven_equip(void)
{
 term *old = Term;
 int i;
 /* Change the actual setting */
 flip_inven = !flip_inven;
 /* Redraw any subwindows showing the inventory/equipment lists */
 for (i = 0; i < ANGBAND_TERM_MAX; i++) {
  /* Skip unused subwindows. */
  if (!angband_term[i]) continue;
  Term_activate(angband_term[i]);
  if (window_flag[i] & PW_INVEN) {
   if (!flip_inven)
    show_inven(OLIST_WINDOW | OLIST_WEIGHT, NULL);
   else
    show_equip(OLIST_WINDOW | OLIST_WEIGHT, NULL);
   Term_fresh();
  } else if (window_flag[i] & PW_EQUIP) {
   if (!flip_inven)
    show_equip(OLIST_WINDOW | OLIST_WEIGHT, NULL);
   else
    show_inven(OLIST_WINDOW | OLIST_WEIGHT, NULL);
   Term_fresh();
  }
 }
 Term_activate(old);
}
static void update_itemlist_subwindow(game_event_type type,
           game_event_data *data, void *user)
{
 term *old = Term;
 term *inv_term = user;
 /* Activate */
 Term_activate(inv_term);
    clear_from(0);
    object_list_show_subwindow(Term->hgt, Term->wid);
 Term_fresh();
 /* Restore */
 Term_activate(old);
}
static void update_monlist_subwindow(game_event_type type,
          game_event_data *data, void *user)
{
 term *old = Term;
 term *inv_term = user;
 /* Activate */
 Term_activate(inv_term);
 clear_from(0);
 monster_list_show_subwindow(Term->hgt, Term->wid);
 Term_fresh();
 /* Restore */
 Term_activate(old);
}
static void update_monster_subwindow(game_event_type type,
          game_event_data *data, void *user)
{
 term *old = Term;
 term *inv_term = user;
 /* Activate */
 Term_activate(inv_term);
 /* Display monster race info */
 if (player->upkeep->monster_race)
  lore_show_subwindow(player->upkeep->monster_race,
       get_lore(player->upkeep->monster_race));
 Term_fresh();
 /* Restore */
 Term_activate(old);
}
static void update_object_subwindow(game_event_type type,
         game_event_data *data, void *user)
{
 term *old = Term;
 term *inv_term = user;
 /* Activate */
 Term_activate(inv_term);
 if (player->upkeep->object != NULL)
  display_object_recall(player->upkeep->object);
 else if (player->upkeep->object_kind)
  display_object_kind_recall(player->upkeep->object_kind);
 Term_fresh();
 /* Restore */
 Term_activate(old);
}
static void update_messages_subwindow(game_event_type type,
           game_event_data *data, void *user)
{
 term *old = Term;
 term *inv_term = user;
 int i;
 int w, h;
 int x, y;
 const char *msg;
 /* Activate */
 Term_activate(inv_term);
 /* Get size */
 Term_get_size(&w, &h);
 /* Dump messages */
 for (i = 0; i < h; i++) {
  uint8_t color = message_color(i);
  uint16_t count = message_count(i);
  const char *str = message_str(i);
  if (count == 1)
   msg = str;
  else if (count == 0)
   msg = " ";
  else
   msg = format("%s <%dx>", str, count);
  Term_putstr(0, (h - 1) - i, -1, color, msg);
  /* Cursor */
  Term_locate(&x, &y);
  /* Clear to end of line */
  Term_erase(x, y, 255);
 }
 Term_fresh();
 /* Restore */
 Term_activate(old);
}
static struct minimap_flags
{
 int win_idx;
 bool needs_redraw;
} minimap_data[ANGBAND_TERM_MAX];
static void update_minimap_subwindow(game_event_type type,
 game_event_data *data, void *user)
{
 struct minimap_flags *flags = user;
 if (player_resting_count(player) || player->upkeep->running) return;
 if (type == EVENT_END) {
  term *old = Term;
  term *t = angband_term[flags->win_idx];
  /* Activate */
  Term_activate(t);
  /* If whole-map redraw, clear window first. */
  if (flags->needs_redraw)
   Term_clear();
  /* Redraw map */
  display_map(NULL, NULL);
  Term_fresh();
  /* Restore */
  Term_activate(old);
  flags->needs_redraw = false;
 } else if (type == EVENT_DUNGEONLEVEL) {
  /* XXX map_height and map_width need to be kept in sync with
		 * display_map() */
  term *t = angband_term[flags->win_idx];
  int map_height = t->hgt - 2;
  int map_width = t->wid - 2;
  /* Clear the entire term if the new map isn't going to fit the
		 * entire thing */
  if (cave->height <= map_height || cave->width <= map_width) {
   flags->needs_redraw = true;
  }
 }
}
/**
 * Display player in sub-windows (mode 0)
 */
static void update_player0_subwindow(game_event_type type,
          game_event_data *data, void *user)
{
 term *old = Term;
 term *inv_term = user;
 /* Activate */
 Term_activate(inv_term);
 /* Display flags */
 display_player(0);
 Term_fresh();
 /* Restore */
 Term_activate(old);
}
/**
 * Display player in sub-windows (mode 1)
 */
static void update_player1_subwindow(game_event_type type,
          game_event_data *data, void *user)
{
 term *old = Term;
 term *inv_term = user;
 /* Activate */
 Term_activate(inv_term);
 /* Display flags */
 display_player(1);
 Term_fresh();
 /* Restore */
 Term_activate(old);
}
static void update_topbar_subwindow(game_event_type type,
         game_event_data *data, void *user)
{
 term *old = Term;
 term *inv_term = user;
 /* Check sanity */
 if (!(player && player->race && player->house && cave)) return;
 /* Activate */
 Term_activate(inv_term);
 update_topbar(type, data, user, 0);
 update_statusline_aux(2, 0);
 Term_fresh();
 /* Restore */
 Term_activate(old);
}
/**
 * Display the left-hand-side of the main term, in more compact fashion.
 */
static void update_player_compact_subwindow(game_event_type type,
           game_event_data *data, void *user)
{
 int row = 0;
 int col = 0;
 int i;
 term *old = Term;
 term *inv_term = user;
 /* Activate */
 Term_activate(inv_term);
 /* Title */
 prt_name(row++, col);
 /* Level/Experience */
 prt_exp(row++, col);
 /* Equippy chars */
 prt_equippy(row++, col);
 /* All Stats */
 for (i = 0; i < STAT_MAX; i++) prt_stat(i, row++, col);
 /* Empty row */
 row++;
 /* Armor */
 //prt_ac(row++, col);
 /* Hitpoints */
 prt_hp(row++, col);
 /* Spellpoints */
 prt_sp(row++, col);
 /* Monster health */
 prt_health(row, col);
 Term_fresh();
 /* Restore */
 Term_activate(old);
}
static void update_combat_rolls_subwindow(game_event_type type,
            game_event_data *data, void *user)
{
 term *old = Term;
 term *inv_term = user;
 /* Activate */
 Term_activate(inv_term);
 /* Display combat rolls */
 display_combat_rolls(type, data, user);
 Term_fresh();
 /* Restore */
 Term_activate(old);
}
static void flush_subwindow(game_event_type type, game_event_data *data,
       void *user)
{
 term *old = Term;
 term *t = user;
 /* Activate */
 Term_activate(t);
 Term_fresh();
 /* Restore */
 Term_activate(old);
}
/**
 * Certain "screens" always use the main screen, including News, Birth,
 * Dungeon, Tomb-stone, High-scores, Macros, Colors, Visuals, Options.
 *
 * Later, special flags may allow sub-windows to "steal" stuff from the
 * main window, including File dump (help), File dump (artifacts, uniques),
 * Character screen, Small scale map, Previous Messages, Store screen, etc.
 */
const char *window_flag_desc[32] =
{
 "Display inven/equip",
 "Display equip/inven",
 "Display player (basic)",
 "Display player (extra)",
 "Display player (compact)",
 "Display map view",
 "Display messages",
 "Display overhead view",
 "Display monster recall",
 "Display object recall",
 "Display monster list",
 "Display status",
 "Display item list",
 "Display player (topbar)",
 "Display combat rolls",
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL
};
static void subwindow_flag_changed(int win_idx, uint32_t flag, bool new_state)
{
 void (*register_or_deregister)(game_event_type type, game_event_handler *fn,
           void *user);
 void (*set_register_or_deregister)(game_event_type *type, size_t n_events,
            game_event_handler *fn, void *user);
 /* Decide whether to register or deregister an evenrt handler */
 if (new_state == false) {
  register_or_deregister = event_remove_handler;
  set_register_or_deregister = event_remove_handler_set;
 } else {
  register_or_deregister = event_add_handler;
  set_register_or_deregister = event_add_handler_set;
 }
 switch (flag)
 {
  case PW_INVEN:
  {
   register_or_deregister(EVENT_INVENTORY,
            update_inven_subwindow,
            angband_term[win_idx]);
   break;
  }
  case PW_EQUIP:
  {
   register_or_deregister(EVENT_EQUIPMENT,
            update_equip_subwindow,
            angband_term[win_idx]);
   break;
  }
  case PW_PLAYER_0:
  {
   set_register_or_deregister(player_events,
         N_ELEMENTS(player_events),
         update_player0_subwindow,
         angband_term[win_idx]);
   break;
  }
  case PW_PLAYER_1:
  {
   set_register_or_deregister(player_events,
         N_ELEMENTS(player_events),
         update_player1_subwindow,
         angband_term[win_idx]);
   break;
  }
  case PW_PLAYER_2:
  {
   set_register_or_deregister(player_events,
         N_ELEMENTS(player_events),
         update_player_compact_subwindow,
         angband_term[win_idx]);
   break;
  }
  case PW_PLAYER_3:
  {
   /* Topbar */
   set_register_or_deregister(player_events,
         N_ELEMENTS(player_events),
         update_topbar_subwindow,
         angband_term[win_idx]);
   /* Also update status */
   set_register_or_deregister(statusline_events,
         N_ELEMENTS(statusline_events),
         update_topbar_subwindow,
         angband_term[win_idx]);
   break;
  }
  case PW_COMBAT_ROLLS:
  {
   register_or_deregister(EVENT_COMBAT_DISPLAY,
           update_combat_rolls_subwindow,
           angband_term[win_idx]);
   break;
  }
  case PW_MAP:
  {
   minimap_data[win_idx].win_idx = win_idx;
   register_or_deregister(EVENT_MAP,
            update_minimap_subwindow,
            &minimap_data[win_idx]);
   register_or_deregister(EVENT_DUNGEONLEVEL, update_minimap_subwindow,
           &minimap_data[win_idx]);
   register_or_deregister(EVENT_END,
            update_minimap_subwindow,
            &minimap_data[win_idx]);
   break;
  }
  case PW_MESSAGE:
  {
   register_or_deregister(EVENT_MESSAGE,
            update_messages_subwindow,
            angband_term[win_idx]);
   break;
  }
  case PW_OVERHEAD:
  {
   register_or_deregister(EVENT_MAP,
            update_maps,
            angband_term[win_idx]);
   register_or_deregister(EVENT_END,
            flush_subwindow,
            angband_term[win_idx]);
   break;
  }
  case PW_MONSTER:
  {
   register_or_deregister(EVENT_MONSTERTARGET,
            update_monster_subwindow,
            angband_term[win_idx]);
   break;
  }
  case PW_OBJECT:
  {
   register_or_deregister(EVENT_OBJECTTARGET,
         update_object_subwindow,
         angband_term[win_idx]);
   break;
  }
  case PW_MONLIST:
  {
   register_or_deregister(EVENT_MONSTERLIST,
            update_monlist_subwindow,
            angband_term[win_idx]);
   break;
  }
  case PW_ITEMLIST:
  {
   register_or_deregister(EVENT_ITEMLIST,
         update_itemlist_subwindow,
         angband_term[win_idx]);
   break;
  }
 }
}
/**
 * Set the flags for one Term, calling "subwindow_flag_changed" with each flag
 * that has changed setting so that it can do any housekeeping to do with 
 * displaying the new thing or no longer displaying the old one.
 */
static void subwindow_set_flags(int win_idx, uint32_t new_flags)
{
 term *old = Term;
 int i;
 /* Deal with the changed flags by seeing what's changed */
 for (i = 0; i < 32; i++)
  /* Only process valid flags */
  if (window_flag_desc[i]) {
   uint32_t flag = ((uint32_t) 1) << i;
   if ((new_flags & flag) !=
     (window_flag[win_idx] & flag)) {
    subwindow_flag_changed(win_idx, flag,
      (new_flags & flag) != 0);
   }
  }
 /* Store the new flags */
 window_flag[win_idx] = new_flags;
 /* Activate */
 Term_activate(angband_term[win_idx]);
 /* Erase */
 Term_clear();
 /* Refresh */
 Term_fresh();
 /* Restore */
 Term_activate(old);
}
/**
 * Called with an array of the new flags for all the subwindows, in order
 * to set them to the new values, with a chance to perform housekeeping.
 */
void subwindows_set_flags(uint32_t *new_flags, size_t n_subwindows)
{
 size_t j;
 for (j = 0; j < n_subwindows; j++) {
  /* Dead window */
  if (!angband_term[j]) continue;
  /* Ignore non-changes */
  if (window_flag[j] != new_flags[j])
   subwindow_set_flags(j, new_flags[j]);
 }
}
/**
 * ------------------------------------------------------------------------
 * Showing and updating the splash screen.
 * ------------------------------------------------------------------------ */
/**
 * Explain a broken "lib" folder and quit (see below).
 */
static void init_angband_aux(const char *why)
{
 quit_fmt("%s\n\n%s", why,
          "The 'lib' directory is probably missing or broken.\n"
          "Perhaps the archive was not extracted correctly.\n"
          "See the 'readme.txt' file for more information.");
}
/*
 * Take notes on line 23
 */
static void splashscreen_note(game_event_type type, game_event_data *data,
         void *user)
{
 if (data->message.type == MSG_BIRTH) {
  static int y = 2;
  /* Draw the message */
  prt(data->message.msg, y, 0);
  pause_line(Term);
  /* Advance one line (wrap if needed) */
  if (++y >= 24) y = 2;
 } else {
  char *s = format("[%s]", data->message.msg);
  Term_erase(0, (Term->hgt - 23) / 5 + 23, 255);
  Term_putstr((Term->wid - strlen(s)) / 2, (Term->hgt - 23) / 5 + 23, -1,
     COLOUR_WHITE, s);
 }
 Term_fresh();
}
static void show_splashscreen(game_event_type type, game_event_data *data,
         void *user)
{
 ang_file *fp;
 char buf[1024];
 /* Verify the "news" file */
 path_build(buf, sizeof(buf), ANGBAND_DIR_SCREENS, "news.txt");
 if (!file_exists(buf)) {
  char why[1024];
  /* Crash and burn */
  strnfmt(why, sizeof(why), "Cannot access the '%s' file!", buf);
  init_angband_aux(why);
 }
 /* Prepare to display the "news" file */
 Term_clear();
 /* Open the News file */
 path_build(buf, sizeof(buf), ANGBAND_DIR_SCREENS, "news.txt");
 fp = file_open(buf, MODE_READ, FTYPE_TEXT);
 text_out_hook = text_out_to_screen;
 /* Dump */
 if (fp) {
  /* Centre the splashscreen - assume news.txt has width 80, height 23 */
  text_out_indent = (Term->wid - 80) / 2;
  Term_gotoxy(0, (Term->hgt - 23) / 5);
  /* Dump the file to the screen */
  while (file_getl(fp, buf, sizeof(buf))) {
   char *version_marker = strstr(buf, "$VERSION");
   if (version_marker) {
    ptrdiff_t pos = version_marker - buf;
    strnfmt(version_marker, sizeof(buf) - pos, "%-8s", buildver);
   }
   text_out_e("%s", buf);
   text_out("\n");
  }
  text_out_indent = 0;
  file_close(fp);
 }
 /* Flush it */
 Term_fresh();
}
/**
 * ------------------------------------------------------------------------
 * Visual updates betweeen player turns.
 * ------------------------------------------------------------------------ */
static void ui_refresh(game_event_type type, game_event_data *data, void *user)
{
 Term_fresh();
}
static void repeated_command_display(game_event_type type,
          game_event_data *data, void *user)
{
 /* Assume messages were seen */
 msg_flag = false;
 /* Clear the top line */
 prt("", 0, 0);
}
/**
 * Housekeeping on arriving on a new level
 */
static void new_level_display_update(game_event_type type,
          game_event_data *data, void *user)
{
 /* Hack -- enforce illegal panel */
 Term->offset_y = z_info->dungeon_hgt;
 Term->offset_x = z_info->dungeon_wid;
 /* Choose panel */
 verify_panel();
 /* Clear */
 Term_clear();
 /* Update stuff */
 player->upkeep->update |= (PU_BONUS | PU_HP | PU_SPELLS);
 /* Calculate torch radius */
 player->upkeep->update |= (PU_TORCH);
 /* Fully update the visuals (and monster distances) */
 player->upkeep->update |= (PU_UPDATE_VIEW | PU_DISTANCE);
 /* Redraw dungeon */
 player->upkeep->redraw |= (PR_BASIC | PR_EXTRA | PR_MAP);
 /* Redraw "statusy" things */
 player->upkeep->redraw |= (PR_INVEN | PR_EQUIP | PR_MONSTER | PR_MONLIST | PR_ITEMLIST);
 /* Because changing levels doesn't take a turn and PR_MONLIST might not be
	 * set for a few game turns, manually force an update on level change. */
 monster_list_force_subwindow_update();
 /* If autosave is pending, do it now. */
 if (player->upkeep->autosave) {
  save_game();
  player->upkeep->autosave = false;
 }
 /*
	 * Saving has side effect of calling handle_stuff(), but if we did
	 * not save or saving no longer calls handle_stuff(), call
	 * handle_stuff() now to process the pending updates and redraws.
	 */
 handle_stuff(player);
 /* Refresh */
 Term_fresh();
}
/**
 * ------------------------------------------------------------------------
 * Temporary (hopefully) hackish solutions.
 * ------------------------------------------------------------------------ */
static void cheat_death(game_event_type type, game_event_data *data, void *user)
{
 msg("You invoke wizard mode and cheat death.");
 event_signal(EVENT_MESSAGE_FLUSH);
 wiz_cheat_death();
}
static void check_panel(game_event_type type, game_event_data *data, void *user)
{
 verify_panel();
}
static void see_floor_items(game_event_type type, game_event_data *data,
       void *user)
{
 int floor_max = z_info->floor_size;
 struct object **floor_list = mem_zalloc(floor_max * sizeof(*floor_list));
 int floor_num = 0;
 bool blind = ((player->timed[TMD_BLIND]) || (no_light(player)));
 const char *p = "see";
 bool can_pickup = false;
 int i;
 /* Scan all visible, sensed objects in the grid */
 floor_num = scan_floor(floor_list, floor_max, player,
         OFLOOR_SENSE | OFLOOR_VISIBLE, NULL);
 if (floor_num == 0) {
  mem_free(floor_list);
  return;
 }
 /* Can we pick any up? */
 for (i = 0; i < floor_num; i++)
     if (inven_carry_okay(floor_list[i]))
   can_pickup = true;
 /* One object */
 if (floor_num == 1) {
  /* Get the object */
  struct object *obj = floor_list[0];
  char o_name[80];
  if (!can_pickup)
   p = "have no room for";
  else if (blind)
   p = "feel";
  /* Describe the object.  Less detail if blind. */
  if (blind) {
   object_desc(o_name, sizeof(o_name), obj,
    ODESC_PREFIX | ODESC_BASE, player);
  } else {
   object_desc(o_name, sizeof(o_name), obj,
    ODESC_PREFIX | ODESC_FULL, player);
  }
  /* Message */
  event_signal(EVENT_MESSAGE_FLUSH);
  /* Arms and armour show weight */
  if ((tval_is_weapon(obj) && !tval_is_ammo(obj))
    || tval_is_armor(obj)) {
   int wgt = obj->weight;
   msg("You %s %s %d.%1d lb.", p, o_name, wgt / 10, wgt % 10);
  } else {
   msg("You %s %s.", p, o_name);
  }
  /* Special explanation the first time you step over the crown */
  if (obj->artifact && streq(obj->artifact->name, "of Morgoth") &&
   !player->crown_hint) {
   msg("To attempt to prise a Silmaril from the crown, use the 'destroy' command (which is 'k' by default).");
   player->crown_hint = true;
  }
 } else {
  ui_event e;
  if (!can_pickup)
   p = "have no room for the following objects";
  else if (blind)
   p = "feel something on the floor";
  /* Display objects on the floor */
  screen_save();
  show_floor(floor_list, floor_num, OLIST_WEIGHT, NULL);
  prt(format("You %s: ", p), 0, 0);
  /* Wait for it.  Use key as next command. */
  e = inkey_ex();
  Term_event_push(&e);
  /* Restore screen */
  screen_load();
 }
 mem_free(floor_list);
}
/**
 * ------------------------------------------------------------------------
 * Initialising
 * ------------------------------------------------------------------------ */
/**
 * Process the user pref files relevant to a newly loaded character
 */
static void process_character_pref_files(void)
{
 bool found;
 char buf[1024];
 /* Process the "window.prf" file */
 process_pref_file("window.prf", true, true);
 /* Process the "user.prf" file */
 process_pref_file("user.prf", true, true);
 /* Get the filesystem-safe name and append .prf */
 player_safe_name(buf, sizeof(buf), player->full_name, true);
 my_strcat(buf, ".prf", sizeof(buf));
 found = process_pref_file(buf, true, true);
    /* Try pref file using savefile name if we fail using character name */
    if (!found) {
  int filename_index = path_filename_index(savefile);
  char filename[128];
  my_strcpy(filename, &savefile[filename_index], sizeof(filename));
  strnfmt(buf, sizeof(buf), "%s.prf", filename);
  process_pref_file(buf, true, true);
    }
}
static void ui_enter_init(game_event_type type, game_event_data *data,
        void *user)
{
 show_splashscreen(type, data, user);
 /* Set up our splashscreen handlers */
 event_add_handler(EVENT_INITSTATUS, splashscreen_note, NULL);
}
static void ui_leave_init(game_event_type type, game_event_data *data,
        void *user)
{
 /* Reset visuals, then load prefs, and react to changes */
 reset_visuals(true);
 process_character_pref_files();
 Term_xtra(TERM_XTRA_REACT, 0);
 (void) Term_redraw_all();
 /* Remove our splashscreen handlers */
 event_remove_handler(EVENT_INITSTATUS, splashscreen_note, NULL);
 /* Flash a message */
 prt("Please wait...", 0, 0);
 /* Flush the message */
 Term_fresh();
}
static void ui_enter_world(game_event_type type, game_event_data *data,
        void *user)
{
 /* Allow big cursor */
 smlcurs = false;
 /* Redraw stuff */
 player->upkeep->redraw |= (PR_INVEN | PR_EQUIP | PR_MONSTER | PR_MESSAGE);
 redraw_stuff(player);
 /* Because of the "flexible" sidebar, all these things trigger
	   the same function. */
 event_add_handler_set(player_events, N_ELEMENTS(player_events),
         update_sidebar, NULL);
 /* The flexible statusbar has similar requirements, so is
	   also trigger by a large set of events. */
 event_add_handler_set(statusline_events, N_ELEMENTS(statusline_events),
         update_statusline, NULL);
 /* Player HP can optionally change the colour of the '@' now. */
 event_add_handler(EVENT_HP, hp_colour_change, NULL);
 /* Simplest way to keep the map up to date - will do for now */
 event_add_handler(EVENT_MAP, update_maps, angband_term[0]);
 /* Check if the panel should shift when the player's moved */
 event_add_handler(EVENT_PLAYERMOVED, check_panel, NULL);
 /* Take note of what's on the floor */
 event_add_handler(EVENT_SEEFLOOR, see_floor_items, NULL);
 /* Display an explosion */
 event_add_handler(EVENT_EXPLOSION, display_explosion, NULL);
 /* Display a bolt spell */
 event_add_handler(EVENT_BOLT, display_bolt, NULL);
 /* Display a physical missile */
 event_add_handler(EVENT_MISSILE, display_missile, NULL);
 /* Display damage values */
 event_add_handler(EVENT_HIT, display_hit, NULL);
 /* New combat round */
 event_add_handler(EVENT_COMBAT_RESET, new_combat_round, NULL);
 /* Update combat rolls - attack */
 event_add_handler(EVENT_COMBAT_ATTACK, update_combat_rolls_attack, NULL);
 /* Update combat rolls - damage */
 event_add_handler(EVENT_COMBAT_DAMAGE, update_combat_rolls_damage, NULL);
 /* Check to see if the player has tried to cancel game processing */
 event_add_handler(EVENT_CHECK_INTERRUPT, check_for_player_interrupt, NULL);
 /* Refresh the screen and put the cursor in the appropriate place */
 event_add_handler(EVENT_REFRESH, ui_refresh, NULL);
 /* Do the visual updates required on a new dungeon level */
 event_add_handler(EVENT_NEW_LEVEL_DISPLAY, new_level_display_update, NULL);
 /* Automatically clear messages while the game is repeating commands */
 event_add_handler(EVENT_COMMAND_REPEAT, repeated_command_display, NULL);
 /* Do animations (e.g. monster colour changes) */
 event_add_handler(EVENT_ANIMATE, animate, NULL);
 /* Allow the player to cheat death, if appropriate */
 event_add_handler(EVENT_CHEAT_DEATH, cheat_death, NULL);
 /* Record the player's death in glorious technicolour */
 event_add_handler(EVENT_DEATH, mini_screenshot, NULL);
 /* Hack -- Decrease "icky" depth */
 screen_save_depth--;
}
static void ui_leave_world(game_event_type type, game_event_data *data,
        void *user)
{
 /* Disallow big cursor */
 smlcurs = true;
 /* Because of the "flexible" sidebar, all these things trigger
	   the same function. */
 event_remove_handler_set(player_events, N_ELEMENTS(player_events),
         update_sidebar, NULL);
 /* The flexible statusbar has similar requirements, so is
	   also trigger by a large set of events. */
 event_remove_handler_set(statusline_events, N_ELEMENTS(statusline_events),
         update_statusline, NULL);
 /* Player HP can optionally change the colour of the '@' now. */
 event_remove_handler(EVENT_HP, hp_colour_change, NULL);
 /*
	 * Note that ui_leave_game() handles the map handlers on term 0
	 * to allow for post-death viewing of the dungeon.
	 */
 /* Check if the panel should shift when the player's moved */
 event_remove_handler(EVENT_PLAYERMOVED, check_panel, NULL);
 /* Take note of what's on the floor */
 event_remove_handler(EVENT_SEEFLOOR, see_floor_items, NULL);
 /* Display an explosion */
 event_remove_handler(EVENT_EXPLOSION, display_explosion, NULL);
 /* Display a bolt spell */
 event_remove_handler(EVENT_BOLT, display_bolt, NULL);
 /* Display a physical missile */
 event_remove_handler(EVENT_MISSILE, display_missile, NULL);
 /* Display damage values */
 event_remove_handler(EVENT_HIT, display_hit, NULL);
 /* New combat round */
 event_remove_handler(EVENT_COMBAT_RESET, new_combat_round, NULL);
 /* Update combat rolls - attack */
 event_remove_handler(EVENT_COMBAT_ATTACK, update_combat_rolls_attack, NULL);
 /* Update combat rolls - damage */
 event_remove_handler(EVENT_COMBAT_DAMAGE, update_combat_rolls_damage, NULL);
 /* Check to see if the player has tried to cancel game processing */
 event_remove_handler(EVENT_CHECK_INTERRUPT, check_for_player_interrupt, NULL);
 /* Refresh the screen and put the cursor in the appropriate place */
 event_remove_handler(EVENT_REFRESH, ui_refresh, NULL);
 /* Do the visual updates required on a new dungeon level */
 event_remove_handler(EVENT_NEW_LEVEL_DISPLAY, new_level_display_update, NULL);
 /* Automatically clear messages while the game is repeating commands */
 event_remove_handler(EVENT_COMMAND_REPEAT, repeated_command_display, NULL);
 /* Do animations (e.g. monster colour changes) */
 event_remove_handler(EVENT_ANIMATE, animate, NULL);
 /* Allow the player to cheat death, if appropriate */
 event_remove_handler(EVENT_CHEAT_DEATH, cheat_death, NULL);
 /* Record the player's death in glorious technicolour */
 event_remove_handler(EVENT_DEATH, mini_screenshot, NULL);
 /* Hack -- Increase "icky" depth */
 screen_save_depth++;
}
static void ui_enter_game(game_event_type type, game_event_data *data,
        void *user)
{
 /* Display a message to the player */
 event_add_handler(EVENT_MESSAGE, display_message, NULL);
 /* Display a message and make a noise to the player */
 event_add_handler(EVENT_BELL, bell_message, NULL);
 /* Tell the UI to ignore all pending input */
 event_add_handler(EVENT_INPUT_FLUSH, flush, NULL);
 /* Print all waiting messages */
 event_add_handler(EVENT_MESSAGE_FLUSH, message_flush, NULL);
 /* Write a poem or note to the screen */
 event_add_handler(EVENT_POEM, pause_with_text, NULL);
}
static void ui_leave_game(game_event_type type, game_event_data *data,
        void *user)
{
 /*
	 * These are removed here rather than ui_leave_world() to allow for
	 * post-death viewing of the dungeon.
	 */
 event_remove_handler(EVENT_MAP, update_maps, angband_term[0]);
 /* Display a message to the player */
 event_remove_handler(EVENT_MESSAGE, display_message, NULL);
 /* Display a message and make a noise to the player */
 event_remove_handler(EVENT_BELL, bell_message, NULL);
 /* Tell the UI to ignore all pending input */
 event_remove_handler(EVENT_INPUT_FLUSH, flush, NULL);
 /* Print all waiting messages */
 event_remove_handler(EVENT_MESSAGE_FLUSH, message_flush, NULL);
 /* Write a poem or note to the screen */
 event_remove_handler(EVENT_POEM, pause_with_text, NULL);
}
void init_display(void)
{
 event_add_handler(EVENT_ENTER_INIT, ui_enter_init, NULL);
 event_add_handler(EVENT_LEAVE_INIT, ui_leave_init, NULL);
 event_add_handler(EVENT_ENTER_GAME, ui_enter_game, NULL);
 event_add_handler(EVENT_LEAVE_GAME, ui_leave_game, NULL);
 event_add_handler(EVENT_ENTER_WORLD, ui_enter_world, NULL);
 event_add_handler(EVENT_LEAVE_WORLD, ui_leave_world, NULL);
 ui_init_birthstate_handlers();
}
/**
 * \file ui-effect.c
 * \brief Implement functions for the text UI's handling of effects
 *
 * Copyright (c) 2021 Eric Branlund
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Create and initialize an effect menu.
 * \param effect is the pointer to the first effect in the linked list.
 * \param count is the number of elements to take from the linked list.
 * \param allow_random if true, include an option to choose one of the effects
 * at random.
 * \return a pointer to the menu structure if successful or NULL if creating
 * the menu failed
 */
static struct menu *effect_menu_new(struct effect *effect, int count,
  bool allow_random)
{
 struct menu *m = menu_new(MN_SKIN_SCROLL,
  menu_find_iter(MN_ITER_STRINGS));
 int width = 0;
 region loc = { 0, 1, -99, -99 };
 int ms_count = 0;
 char **ms;
 char buf[80];
 m->selections = all_letters_nohjkl;
 /* Collect a string for each effect. */
 if (count > 0) {
  if (allow_random) ++count;
  /*
		 * There's one extra element to serve as a sentinel for
		 * effect_menu_destroy().
		 */
  ms = mem_alloc((count + 1) * sizeof(*ms));
  if (allow_random) {
   ms[ms_count] =
    string_make("one of the following at random");
   width = MAX(width, (int)MIN(strlen(ms[ms_count])
    + 3, (size_t)(Term->wid)));
   ++ms_count;
  }
 } else {
  ms = NULL;
 }
 while (ms_count < count) {
  size_t len;
  len = effect_get_menu_name(buf, sizeof(buf), effect);
  if (!len) {
   int j;
   for (j = 0; j < ms_count; ++j) {
    string_free(ms[j]);
   }
   mem_free(ms);
   mem_free(m);
   msg("Mismatched count and effect list passed to effect_menu_new().  Please report this bug.");
   return NULL;
  }
  ms[ms_count] = string_make(buf);
  width = MAX(width, (int)MIN(len + 3, (size_t)(Term->wid)));
  ++ms_count;
  effect = effect_next(effect);
 }
 /* Set the sentinel element. */
 ms[ms_count] = NULL;
 menu_setpriv(m, ms_count, ms);
 /* Set size. */
 loc.width = width;
 loc.page_rows = MIN(ms_count, Term->hgt - 2);
 menu_layout(m, &loc);
 return m;
}
static int effect_menu_select(struct menu *m, const char *prompt, bool allow_random)
{
 ui_event out;
 int selection;
 screen_save();
 region_erase_bordered(&m->active);
 prt((prompt) ? prompt : "Which effect? ", 0, 0);
 out = menu_select(m, 0, false);
 if (out.type & EVT_SELECT) {
  selection = m->cursor;
  if (allow_random) {
   if (selection == 0) {
    selection = -2;
   } else if (selection > 0) {
    --selection;
   }
  }
 } else {
  selection = -1;
 }
 screen_load();
 return selection;
}
/**
 * Release resources allocated by effect_menu_new().
 * \param m is a menu returned by effect_menu_new().
 */
static void effect_menu_destroy(struct menu *m)
{
 if (m) {
  char **ms = menu_priv(m);
  int i = 0;
  while (ms[i]) {
   string_free(ms[i]);
   ++i;
  }
  mem_free(ms);
  mem_free(m);
 }
}
/**
 * Display a menu to select an effect from the given list.
 * \param prompt is the string to use as the prompt for the menu.  May be NULL
 * to use a default prompt.
 * \param effect is the pointer to the first element in the linked list of
 * effects.
 * \param count is the number of effects to take from the linked list.
 * \param allow_random if true, also include an option to get a random element
 * from the list.
 * \return the index of the selected item, -2 if the user selected the random
 * option enabled by allow_random, or -1 to indicate that the selection was
 * canceled or invalid
 */
int textui_get_effect_from_list(const char *prompt, struct effect *effect,
 int count, bool allow_random)
{
 struct menu *m;
 int choice;
 if (count == -1) {
  struct effect *cursor = effect;
  count = 0;
  while (cursor) {
   ++count;
   cursor = effect_next(cursor);
  }
 }
 m = effect_menu_new(effect, count, allow_random);
 if (m) {
  choice = effect_menu_select(m, prompt, allow_random);
  effect_menu_destroy(m);
 } else {
  choice = -1;
 }
 return choice;
}
/**
 * \file ui-event.c
 * \brief Utility functions relating to UI events
 *
 * Copyright (c) 2011 Andi Sidwell
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Map keycodes to their textual equivalent.
 */
static const struct {
 keycode_t code;
 const char *desc;
} mappings[] = {
 { ESCAPE, "Escape" },
 { KC_ENTER, "Enter" },
 { KC_TAB, "Tab" },
 { KC_DELETE, "Delete" },
 { KC_BACKSPACE, "Backspace" },
 { ARROW_DOWN, "Down" },
 { ARROW_LEFT, "Left" },
 { ARROW_RIGHT, "Right" },
 { ARROW_UP, "Up" },
 { KC_F1, "F1" },
 { KC_F2, "F2" },
 { KC_F3, "F3" },
 { KC_F4, "F4" },
 { KC_F5, "F5" },
 { KC_F6, "F6" },
 { KC_F7, "F7" },
 { KC_F8, "F8" },
 { KC_F9, "F9" },
 { KC_F10, "F10" },
 { KC_F11, "F11" },
 { KC_F12, "F12" },
 { KC_F13, "F13" },
 { KC_F14, "F14" },
 { KC_F15, "F15" },
 { KC_HELP, "Help" },
 { KC_HOME, "Home" },
 { KC_PGUP, "PageUp" },
 { KC_END, "End" },
 { KC_PGDOWN, "PageDown" },
 { KC_INSERT, "Insert" },
 { KC_PAUSE, "Pause" },
 { KC_BREAK, "Break" },
 { KC_BEGIN, "Begin" },
};
/**
 * Given a string, try and find it in "mappings".
 */
keycode_t keycode_find_code(const char *str, size_t len)
{
 size_t i;
 for (i = 0; i < N_ELEMENTS(mappings); i++) {
  if (strncmp(str, mappings[i].desc, len) == 0)
   return mappings[i].code;
 }
 return 0;
}
/**
 * Given a keycode, return its textual mapping.
 */
const char *keycode_find_desc(keycode_t kc)
{
 size_t i;
 for (i = 0; i < N_ELEMENTS(mappings); i++) {
  if (mappings[i].code == kc)
   return mappings[i].desc;
 }
 return NULL;
}
/**
 * Given a keycode, return whether it corresponds to a printable character.
 */
bool keycode_isprint(keycode_t kc)
{
 /*
	 * Exclude ESCAPE (not part of the Unicode standard).  Otherwise,
	 * treat the keycode as a Unicode code point.
	 */
 return kc != ESCAPE && utf32_isprint(kc);
}
/**
 * Convert a hexidecimal-digit into a decimal
 */
static int dehex(char c)
{
 if (isdigit((unsigned char)c)) return (D2I(c));
 if (isalpha((unsigned char)c)) return (A2I(tolower((unsigned char)c)) + 10);
 return (0);
}
/**
 * Convert an encoding of a set of keypresses into actual keypresses.
 */
void keypress_from_text(struct keypress *buf, size_t len, const char *str)
{
 size_t cur = 0;
 uint8_t mods = 0;
 memset(buf, 0, len * sizeof *buf);
 /* Analyze the "ascii" string */
 while (*str && cur < len) {
  buf[cur].type = EVT_KBRD;
  if (*str == '\\') {
   str++;
   if (*str == '\0') break;
   switch (*str) {
    /* Hex-mode */
    case 'x': {
     if (isxdigit((unsigned char)(*(str + 1))) &&
       isxdigit((unsigned char)(*(str + 2)))) {
      int v1 = dehex(*++str) * 16;
      int v2 = dehex(*++str);
      /* store a nice hex digit */
      { int p = (cur++); keycode_t c = (v1 + v2); uint8_t m = (mods); if ((m & KC_MOD_CONTROL) && ENCODE_KTRL(c)) { m &= ~KC_MOD_CONTROL; c = KTRL(c); } buf[p].mods = m; buf[p].code = c; };
     } else {
      /* invalids get ignored */
      { int p = (cur++); keycode_t c = ('?'); uint8_t m = (mods); if ((m & KC_MOD_CONTROL) && ENCODE_KTRL(c)) { m &= ~KC_MOD_CONTROL; c = KTRL(c); } buf[p].mods = m; buf[p].code = c; };
     }
     break;
    }
    case 'a': { int p = (cur++); keycode_t c = ('\a'); uint8_t m = (mods); if ((m & KC_MOD_CONTROL) && ENCODE_KTRL(c)) { m &= ~KC_MOD_CONTROL; c = KTRL(c); } buf[p].mods = m; buf[p].code = c; }; break;
    case '\\': { int p = (cur++); keycode_t c = ('\\'); uint8_t m = (mods); if ((m & KC_MOD_CONTROL) && ENCODE_KTRL(c)) { m &= ~KC_MOD_CONTROL; c = KTRL(c); } buf[p].mods = m; buf[p].code = c; }; break;
    case '^': { int p = (cur++); keycode_t c = ('^'); uint8_t m = (mods); if ((m & KC_MOD_CONTROL) && ENCODE_KTRL(c)) { m &= ~KC_MOD_CONTROL; c = KTRL(c); } buf[p].mods = m; buf[p].code = c; }; break;
    case '[': { int p = (cur++); keycode_t c = ('['); uint8_t m = (mods); if ((m & KC_MOD_CONTROL) && ENCODE_KTRL(c)) { m &= ~KC_MOD_CONTROL; c = KTRL(c); } buf[p].mods = m; buf[p].code = c; }; break;
    case '{': { int p = (cur++); keycode_t c = ('{'); uint8_t m = (mods); if ((m & KC_MOD_CONTROL) && ENCODE_KTRL(c)) { m &= ~KC_MOD_CONTROL; c = KTRL(c); } buf[p].mods = m; buf[p].code = c; }; break;
    default: { int p = (cur++); keycode_t c = (*str); uint8_t m = (mods); if ((m & KC_MOD_CONTROL) && ENCODE_KTRL(c)) { m &= ~KC_MOD_CONTROL; c = KTRL(c); } buf[p].mods = m; buf[p].code = c; }; break;
   }
   mods = 0;
   /* Skip the final char */
   str++;
  } else if (*str == '[') {
   /* parse non-ascii keycodes */
   char *end;
   keycode_t kc;
   if (*str++ == 0) return;
   end = strchr(str, (unsigned char) ']');
   if (!end) return;
   kc = keycode_find_code(str, (size_t) (end - str));
   if (!kc) return;
   { int p = (cur++); keycode_t c = (kc); uint8_t m = (mods); if ((m & KC_MOD_CONTROL) && ENCODE_KTRL(c)) { m &= ~KC_MOD_CONTROL; c = KTRL(c); } buf[p].mods = m; buf[p].code = c; };
   mods = 0;
   str = end + 1;
  } else if (*str == '{') {
   /* Specify modifier for next character */
   str++;
   if (*str == '\0' || !strchr(str, (unsigned char) '}'))
    return;
   /* analyze modifier chars */
   while (*str != '}') {
    switch (*str) {
     case '^': mods |= KC_MOD_CONTROL; break;
     case 'S': mods |= KC_MOD_SHIFT; break;
     case 'A': mods |= KC_MOD_ALT; break;
     case 'M': mods |= KC_MOD_META; break;
     case 'K': mods |= KC_MOD_KEYPAD; break;
     default:
      return;
    }
    str++;
   }
   /* skip ending bracket */
   str++;
  } else if (*str == '^') {
   mods |= KC_MOD_CONTROL;
   str++;
  } else {
   /* everything else */
   { int p = (cur++); keycode_t c = (*str++); uint8_t m = (mods); if ((m & KC_MOD_CONTROL) && ENCODE_KTRL(c)) { m &= ~KC_MOD_CONTROL; c = KTRL(c); } buf[p].mods = m; buf[p].code = c; };
   mods = 0;
  }
 }
 /* Terminate */
 cur = MIN(cur, len - 1);
 buf[cur].type = EVT_NONE;
}
/**
 * Convert a string of keypresses into their textual equivalent.
 */
void keypress_to_text(char *buf, size_t len, const struct keypress *src,
 bool expand_backslash)
{
 size_t cur = 0;
 size_t end = 0;
 while (src[cur].type == EVT_KBRD) {
  keycode_t i = src[cur].code;
  int mods = src[cur].mods;
  const char *desc = keycode_find_desc(i);
  /* un-ktrl control characters if they don't have a description */
  /* this is so that Tab (^i) doesn't get turned into ^i but gets
		 * displayed as [Tab] */
  if (i < 0x20 && !desc) {
   mods |= KC_MOD_CONTROL;
   i = UN_KTRL(i);
  }
  if (mods) {
   if (mods & KC_MOD_CONTROL && !(mods & ~KC_MOD_CONTROL)) {
    strnfcat(buf, len, &end, "^");
   } else {
    strnfcat(buf, len, &end, "{");
    if (mods & KC_MOD_CONTROL) strnfcat(buf, len, &end, "^");
    if (mods & KC_MOD_SHIFT) strnfcat(buf, len, &end, "S");
    if (mods & KC_MOD_ALT) strnfcat(buf, len, &end, "A");
    if (mods & KC_MOD_META) strnfcat(buf, len, &end, "M");
    if (mods & KC_MOD_KEYPAD) strnfcat(buf, len, &end, "K");
    strnfcat(buf, len, &end, "}");
   }
  }
  if (desc) {
   strnfcat(buf, len, &end, "[%s]", desc);
  } else {
   switch (i) {
    case '\a': strnfcat(buf, len, &end, "\a"); break;
    case '\\': {
     if (expand_backslash)
      strnfcat(buf, len, &end, "\\\\");
     else
      strnfcat(buf, len, &end, "\\");
     break;
    }
    case '^': strnfcat(buf, len, &end, "\\^"); break;
    case '[': strnfcat(buf, len, &end, "\\["); break;
    case '{': strnfcat(buf, len, &end, "\\{"); break;
    default: {
     if (i < 127)
      strnfcat(buf, len, &end, "%c", (int)i);
     else
      strnfcat(buf, len, &end, "\\x%02lx", (unsigned long)i);
     break;
    }
   }
  }
  cur++;
 }
 /* Terminate */
 buf[end] = '\0';
}
/**
 * Convert a keypress into something readable.
 */
void keypress_to_readable(char *buf, size_t len, struct keypress src)
{
 size_t end = 0;
 keycode_t i = src.code;
 int mods = src.mods;
 const char *desc = keycode_find_desc(i);
 /* un-ktrl control characters if they don't have a description */
 /* this is so that Tab (^i) doesn't get turned into ^i but gets
	 * displayed as [Tab] */
 if (i < 0x20 && !desc) {
  mods |= KC_MOD_CONTROL;
  i = UN_KTRL(i);
 }
 if (mods) {
  if (mods & KC_MOD_CONTROL && !(mods & ~KC_MOD_CONTROL) &&
    i != '^') {
   strnfcat(buf, len, &end, "^");
  } else {
   if (mods & KC_MOD_CONTROL) strnfcat(buf, len, &end, "Control-");
   if (mods & KC_MOD_SHIFT) strnfcat(buf, len, &end, "Shift-");
   if (mods & KC_MOD_ALT) strnfcat(buf, len, &end, "Alt-");
   if (mods & KC_MOD_META) strnfcat(buf, len, &end, "Meta-");
   if (mods & KC_MOD_KEYPAD) strnfcat(buf, len, &end, "Keypad-");
  }
 }
 if (desc) {
  strnfcat(buf, len, &end, "%s", desc);
 } else {
  char out[5];
  if (utf32_to_utf8(out, sizeof(out), &i, 1, NULL) > 0) {
   strnfcat(buf, len, &end, "%s", out);
  } else {
   strnfcat(buf, len, &end, "Unknown");
  }
 }
 /* Terminate */
 buf[end] = '\0';
}
/**
 * Return whether the given display char matches an entered symbol
 *
 * Horrible hack. TODO UTF-8 find some way of entering mb chars
 */
bool char_matches_key(wchar_t c, keycode_t key)
{
 wchar_t keychar[2];
 char k[2] = {'\0', '\0'};
 k[0] = (char)key;
 text_mbstowcs(keychar, k, 1);
 return (c == keychar[0]);
}
/**
 * Check if a UI event matches a certain keycode ('a', 'b', etc)
 */
bool event_is_key(ui_event e, keycode_t key)
{
 return e.type == EVT_KBRD && e.key.code == key;
}
/**
 * Check if a UI event matches a certain mouse button (1, 2, 3)
 */
bool event_is_mouse(ui_event e, uint8_t button)
{
 return e.type == EVT_MOUSE && e.mouse.button == button;
}
/**
 * Check if a UI event matches a certain mouse button (1, 2, 3) and has
 * specific modifiers (KC_MOD_*)
 */
bool event_is_mouse_m(ui_event e, uint8_t button, uint8_t mods)
{
 return e.type == EVT_MOUSE && e.mouse.button == button && (e.mouse.mods & mods);
}
/**
 * \file ui-game.c
 * \brief Game management for the traditional text UI
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 * Copyright (c) 2015 Nick McConnell
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
struct savefile_getter_impl {
 ang_dir *d;
 struct savefile_details details;
 bool have_details;
 bool have_savedir;
};
bool arg_wizard; /* Command arg -- Request wizard mode */
/**
 * Buffer to hold the current savefile name
 */
char savefile[1024];
/**
 * Buffer to hold the name of the panic save corresponding to savefile.  Only
 * set and used as necessary (in start_game() and handle_signal_abort()).  Use
 * static storage to avoid complications in the signal handler (i.e. limited
 * stack space or the possibility of a full or corrupted heap).
 */
char panicfile[1024];
/**
 * Set by the front end to perform necessary actions when restarting after death
 * without exiting.  May be NULL.
 */
void (*reinit_hook)(void) = NULL;
/**
 * Here are lists of commands, stored in this format so that they can be
 * easily maniuplated for e.g. help displays, or if a port wants to provide a
 * native menu containing a command list.
 *
 * Consider a two-paned layout for the command menus. XXX
 */
/**
 * Item commands
 */
struct cmd_info cmd_item[] =
{
 { "Inscribe an object", { '{' }, CMD_INSCRIBE, NULL, NULL, 0, NULL, NULL, NULL, 0 },
 { "Uninscribe an object", { '}' }, CMD_UNINSCRIBE, NULL, NULL, 0, NULL, NULL, NULL, 0 },
 { "Wear/wield an item", { 'w' }, CMD_WIELD, NULL, NULL, 0, NULL, NULL, NULL, 0 },
 { "Take off/unwield an item", { 'r', 'r', 't', 't' }, CMD_TAKEOFF, NULL, NULL, 0, NULL, NULL, NULL, 0 },
 { "Examine an item", { 'x', 'x', 'I', 'I' }, CMD_NULL, textui_obj_examine, NULL, 0, NULL, NULL, NULL, 0 },
 { "Drop an item", { 'd' }, CMD_DROP, NULL, NULL, 0, NULL, NULL, NULL, 0 },
 { "Destroy an item", { 'k', KTRL('K'), 'k', KTRL('K') }, CMD_DESTROY, NULL, NULL, 0, NULL, NULL, NULL, 0 },
 { "Fire from quiver 1", { 'f' }, CMD_NULL, do_cmd_fire_quiver1, player_can_fire_quiver1_prereq, 0, NULL, NULL, NULL, 0 },
 { "Fire from quiver 2", { 'F' }, CMD_NULL, do_cmd_fire_quiver2, player_can_fire_quiver2_prereq, 0, NULL, NULL, NULL, 0 },
 { "Use a staff", { 'a', 'a', 'u', 'u' }, CMD_USE_STAFF, NULL, NULL, 0, NULL, NULL, NULL, 0 },
 { "Blow a horn", { 'p' }, CMD_BLOW_HORN, NULL, NULL, 0, NULL, NULL, NULL, 0 },
 { "Eat some food", { 'E' }, CMD_EAT, NULL, NULL, 0, NULL, NULL, NULL, 0 },
 { "Quaff a potion", { 'q' }, CMD_QUAFF, NULL, NULL, 0, NULL, NULL, NULL, 0 },
 { "Fuel your light source", { KTRL('F') }, CMD_REFUEL, NULL, player_can_refuel_prereq, 0, NULL, NULL, NULL, 0 },
 { "Use an item", { 'u', KTRL('U'), 'U', KTRL('U') }, CMD_USE, NULL, NULL, 0, NULL, NULL, NULL, 0 },
 { "Smith an item", { '0', '0', KTRL('D'), KTRL('D') }, CMD_SMITH, NULL, NULL, 0, NULL, NULL, NULL, 0 }
};
/**
 * General actions
 */
struct cmd_info cmd_action[] =
{
 { "Disarm a trap or chest", { 'D' }, CMD_DISARM, NULL, NULL, 0, NULL, NULL, NULL, 0 },
 { "Rest for a while", { 'Z', 'Z', 'R', 'R' }, CMD_NULL, textui_cmd_rest, NULL, 0, NULL, NULL, NULL, 0 },
 { "Look around", { 'l', KTRL('L'), 'l', KTRL('L') }, CMD_NULL, do_cmd_look, NULL, 0, NULL, NULL, NULL, 0 },
 { "Target monster or location", { '*' }, CMD_NULL, textui_target, NULL, 0, NULL, NULL, NULL, 0 },
 { "Target closest monster", { '\'' }, CMD_NULL, textui_target_closest, NULL, 0, NULL, NULL, NULL, 0 },
 { "Dig a tunnel", { 'T' }, CMD_TUNNEL, NULL, NULL, 0, NULL, NULL, NULL, 0 },
 { "Go up staircase", {'<' }, CMD_GO_UP, NULL, NULL, 0, NULL, NULL, NULL, 0 },
 { "Go down staircase", { '>' }, CMD_GO_DOWN, NULL, NULL, 0, NULL, NULL, NULL, 0 },
 { "Open a door or a chest", { 'o' }, CMD_OPEN, NULL, NULL, 0, NULL, NULL, NULL, 0 },
 { "Close a door", { 'c' }, CMD_CLOSE, NULL, NULL, 0, NULL, NULL, NULL, 0 },
 { "Bash a door", { 'b', KTRL('B'), 'B', KTRL('B') }, CMD_BASH, NULL, NULL, 0, NULL, NULL, NULL, 0 },
 { "Fire at nearest target", { 'm' }, CMD_NULL, do_cmd_fire_at_nearest, NULL, 0, NULL, NULL, NULL, 0 },
 { "Throw an item", { 't', 't', 'v', 'v' }, CMD_THROW, NULL, NULL, 0, NULL, NULL, NULL, 0 },
 { "Throw automatically", { KTRL('T') }, CMD_NULL, do_cmd_automatic_throw, player_has_throwable_prereq, 0, NULL, NULL, NULL, 0 },
 { "Change song", { 's', 's', 'a', 'a' }, CMD_SING, NULL, NULL, 0, NULL, NULL, NULL, 0 },
 { "Toggle stealth mode", { 'S' }, CMD_TOGGLE_STEALTH, NULL, NULL, 0, NULL, NULL, NULL, 0 },
 { "Walk into a trap", { '_' }, CMD_JUMP, NULL, NULL, 0, NULL, NULL, NULL, 0 },
 { "Exchange places", { 'X' }, CMD_EXCHANGE, NULL, NULL, 0, NULL, NULL, NULL, 0 },
};
/**
 * Item management commands
 */
struct cmd_info cmd_item_manage[] =
{
 { "Display equipment listing", { 'e' }, CMD_NULL, do_cmd_equip, NULL, 0, NULL, NULL, NULL, 0 },
 { "Display inventory listing", { 'i' }, CMD_NULL, do_cmd_inven, NULL, 0, NULL, NULL, NULL, 0 },
 { "Pick up objects", { 'g' }, CMD_PICKUP, NULL, NULL, 0, NULL, NULL, NULL, 0 },
 { "Ignore an item", { 'G' }, CMD_IGNORE, textui_cmd_ignore, NULL, 0, NULL, NULL, NULL, 0 },
};
/**
 * Information access commands
 */
struct cmd_info cmd_info[] =
{
 { "Full dungeon map", { 'M' }, CMD_NULL, do_cmd_view_map, NULL, 0, NULL, NULL, NULL, 0 },
 { "Toggle ignoring of items", { 'P' }, CMD_NULL, textui_cmd_toggle_ignore, NULL, 0, NULL, NULL, NULL, 0 },
 { "Display visible item list", { ']' }, CMD_NULL, do_cmd_itemlist, NULL, 0, NULL, NULL, NULL, 0 },
 { "Display visible monster list", { '[' }, CMD_NULL, do_cmd_monlist, NULL, 0, NULL, NULL, NULL, 0 },
 { "Locate player on map", { 'L', 'W', 'L', 'W' }, CMD_NULL, do_cmd_locate, NULL, 0, NULL, NULL, NULL, 0 },
 { "Help", { '?' }, CMD_NULL, do_cmd_help, NULL, 0, NULL, NULL, NULL, 0 },
 { "Identify symbol", { '|', '|', '/', '/',}, CMD_NULL, do_cmd_query_symbol, NULL, 0, NULL, NULL, NULL, 0 },
 { "Character description", { '@', '@', 'C', 'C' }, CMD_NULL, do_cmd_change_name, NULL, 0, NULL, NULL, NULL, 0 },
 { "Abilities list", { KC_TAB, KC_TAB, KC_TAB, KC_TAB }, CMD_NULL, do_cmd_abilities, NULL, 0, NULL, NULL, NULL, 0 },
 { "Check knowledge", { '~' }, CMD_NULL, textui_browse_knowledge, NULL, 0, NULL, NULL, NULL, 0 },
 { "Show previous message", { KTRL('O') }, CMD_NULL, do_cmd_message_one, NULL, 0, NULL, NULL, NULL, 0 },
 { "Show previous messages", { KTRL('P') }, CMD_NULL, do_cmd_messages, NULL, 0, NULL, NULL, NULL, 0 }
};
/**
 * Utility/assorted commands
 */
struct cmd_info cmd_util[] =
{
 { "Interact with options", { 'O', 'O', '=', '=' }, CMD_NULL, do_cmd_xxx_options, NULL, 0, NULL, NULL, NULL, 0 },
 { "Save and don't quit", { KTRL('S') }, CMD_NULL, save_game, player_can_save_prereq, 0, NULL, NULL, NULL, 0 },
 { "Save and quit", { KTRL('X') }, CMD_NULL, textui_quit, NULL, 0, NULL, NULL, NULL, 0 },
 { "Retire character and quit", { 'Q' }, CMD_NULL, textui_cmd_retire, NULL, 0, NULL, NULL, NULL, 0 },
 { "Redraw the screen", { KTRL('R') }, CMD_NULL, do_cmd_redraw, NULL, 0, NULL, NULL, NULL, 0 },
 { "Save \"screen dump\"", { ')' }, CMD_NULL, do_cmd_save_screen, NULL, 0, NULL, NULL, NULL, 0 }
};
/**
 * Commands that shouldn't be shown to the user
 */
struct cmd_info cmd_hidden[] =
{
 { "Take notes", { ':' }, CMD_NULL, do_cmd_note, NULL, 0, NULL, NULL, NULL, 0 },
 { "Version info", { 'V' }, CMD_NULL, do_cmd_version, NULL, 0, NULL, NULL, NULL, 0 },
 { "Load a single pref line", { '"' }, CMD_NULL, do_cmd_pref, NULL, 0, NULL, NULL, NULL, 0 },
 { "Toggle windows", { KTRL('E') }, CMD_NULL, toggle_inven_equip, NULL, 0, NULL, NULL, NULL, 0 }, /* XXX */
 { "Alter a grid", { '/', '/', '+', '+' }, CMD_ALTER, NULL, NULL, 0, NULL, NULL, NULL, 0 },
 { "Walk", { ';' }, CMD_WALK, NULL, NULL, 0, NULL, NULL, NULL, 0 },
 { "Start running", { '.' }, CMD_RUN, NULL, NULL, 0, NULL, NULL, NULL, 0 },
 { "Stand still", { 'z', 'z', 's', 's' }, CMD_HOLD, NULL, NULL, 0, NULL, NULL, NULL, 0 },
 { "Center map", { 'C', 'C', '@', '@' }, CMD_NULL, do_cmd_center_map, NULL, 0, NULL, NULL, NULL, 0 },
 { "Toggle wizard mode", { KTRL('W') }, CMD_NULL, do_cmd_wizard, NULL, 0, NULL, NULL, NULL, 0 },
 { "Repeat previous command", { 'n', KTRL('N'), 'n', KTRL('N') }, CMD_REPEAT, NULL, NULL, 0, NULL, NULL, NULL, 0 },
 { "Do autopickup", { KTRL('G') }, CMD_AUTOPICKUP, NULL, NULL, 0, NULL, NULL, NULL, 0 },
 { "Debug mode commands", { KTRL('A') }, CMD_NULL, NULL, NULL, 1, "Debug Command: ", "That is not a valid debug command.", "Debug", -1 },
};
/**
 * Debug mode command categories; placeholders for the Enter menu system
 */
struct cmd_info cmd_debug[] =
{
 { "Items", { '\0' }, CMD_NULL, NULL, NULL, 0, NULL, NULL, "DbgObj", -1 },
 { "Player", { '\0' }, CMD_NULL, NULL, NULL, 0, NULL, NULL, "DbgPlayer", -1 },
 { "Teleport", { '\0' }, CMD_NULL, NULL, NULL, 0, NULL, NULL, "DbgTele", -1 },
 { "Effects", { '\0' }, CMD_NULL, NULL, NULL, 0, NULL, NULL, "DbgEffects", -1 },
 { "Summon", { '\0' }, CMD_NULL, NULL, NULL, 0, NULL, NULL, "DbgSummon", -1 },
 { "Files", { '\0' }, CMD_NULL, NULL, NULL, 0, NULL, NULL, "DbgFiles", -1 },
 { "Statistics", { '\0' }, CMD_NULL, NULL, NULL, 0, NULL, NULL, "DbgStat", -1 },
 { "Query", { '\0' }, CMD_NULL, NULL, NULL, 0, NULL, NULL, "DbgQuery", -1 },
 { "Miscellaneous", { '\0' }, CMD_NULL, NULL, NULL, 0, NULL, NULL, "DbgMisc", -1 },
};
struct cmd_info cmd_debug_obj[] =
{
 { "Create an object", { 'c' }, CMD_NULL, wiz_create_nonartifact, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
 { "Create an artifact", { 'C' }, CMD_NULL, wiz_create_artifact, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
 { "Create all from tval", { 'V' }, CMD_NULL, wiz_create_all_for_tval, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
 { "Acquire good", { 'g' }, CMD_NULL, wiz_acquire_good, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
 { "Acquire great", { 'v' }, CMD_NULL, wiz_acquire_great, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
 { "Play with item", { 'o' }, CMD_WIZ_PLAY_ITEM, NULL, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
};
struct cmd_info cmd_debug_player[] =
{
 { "Cure everything", { 'a' }, CMD_WIZ_CURE_ALL, NULL, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
 { "Make powerful", { 'A' }, CMD_WIZ_ADVANCE, NULL, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
 { "Increase experience", { 'x' }, CMD_WIZ_INCREASE_EXP, NULL, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
 { "Rerate hitpoints", { 'h' }, CMD_WIZ_RERATE, NULL, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
 { "Edit player", { 'e' }, CMD_WIZ_EDIT_PLAYER_START, NULL, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
 { "Learn object kinds", { 'l' }, CMD_NULL, wiz_learn_all_object_kinds, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
 { "Recall monster", { 'r' }, CMD_WIZ_RECALL_MONSTER, NULL, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
 { "Erase monster recall", { 'W' }, CMD_WIZ_WIPE_RECALL, NULL, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
};
struct cmd_info cmd_debug_tele[] =
{
 { "To location", { 'b' }, CMD_WIZ_TELEPORT_TO, NULL, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
 { "Jump to a level", { 'j' }, CMD_WIZ_JUMP_LEVEL, NULL, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
};
struct cmd_info cmd_debug_effects[] =
{
 { "Detect all nearby", { 'd' }, CMD_WIZ_DETECT_ALL_LOCAL, NULL, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
 { "Detect all monsters", { 'u' }, CMD_WIZ_DETECT_ALL_MONSTERS, NULL, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
 { "Map local area", { 'm' }, CMD_WIZ_MAGIC_MAP, NULL, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
 { "Hit all in LOS", { 'H' }, CMD_WIZ_HIT_ALL_LOS, NULL, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
 { "Perform an effect", { 'E' }, CMD_WIZ_PERFORM_EFFECT, NULL, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
 { "Graphics demo", { 'G' }, CMD_NULL, wiz_proj_demo, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
};
struct cmd_info cmd_debug_summon[] =
{
 { "Summon specific", { 'n' }, CMD_WIZ_SUMMON_NAMED, NULL, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
 { "Summon random", { 's' }, CMD_WIZ_SUMMON_RANDOM, NULL, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
};
struct cmd_info cmd_debug_files[] =
{
 { "Create spoilers", { '"' }, CMD_NULL, do_cmd_spoilers, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
 { "Write map", { 'M' }, CMD_WIZ_DUMP_LEVEL_MAP, NULL, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
};
struct cmd_info cmd_debug_stats[] =
{
 { "Objects and monsters", { 'S' }, CMD_WIZ_COLLECT_OBJ_MON_STATS, NULL, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
 { "Pits", { 'P' }, CMD_WIZ_COLLECT_PIT_STATS, NULL, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
 { "Disconnected levels", { 'D' }, CMD_WIZ_COLLECT_DISCONNECT_STATS, NULL, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
 { "Obj/mon alternate key", { 'f' }, CMD_WIZ_COLLECT_OBJ_MON_STATS, NULL, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
};
struct cmd_info cmd_debug_query[] =
{
 { "Feature", { 'F' }, CMD_WIZ_QUERY_FEATURE, NULL, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
 { "Square flag", { 'q' }, CMD_WIZ_QUERY_SQUARE_FLAG, NULL, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
 { "Noise and scent", { '_' }, CMD_WIZ_PEEK_NOISE_SCENT, NULL, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
 { "Keystroke log", { 'L' }, CMD_WIZ_DISPLAY_KEYLOG, NULL, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
};
struct cmd_info cmd_debug_misc[] =
{
 { "Wizard light level", { 'w' }, CMD_WIZ_WIZARD_LIGHT, NULL, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
 { "Create a trap", { 'T' }, CMD_WIZ_CREATE_TRAP, NULL, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
 { "Banish nearby monsters", { 'z' }, CMD_WIZ_BANISH, NULL, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
 { "Push objects from square", { '>' }, CMD_WIZ_PUSH_OBJECT, NULL, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
 { "Quit without saving", { 'X' }, CMD_NULL, wiz_confirm_quit_no_save, player_can_debug_prereq, 0, NULL, NULL, NULL, 0 },
};
/**
 * List of command lists; because of the implementation in ui-context.c all
 * entries with menu_level == 0 should appear first; hardwired geometry in
 * ui-context.c limits the maximum nesting level to 2
 */
struct command_list cmds_all[] =
{
 { "Items", cmd_item, N_ELEMENTS(cmd_item), 0, 0 },
 { "Action commands", cmd_action, N_ELEMENTS(cmd_action), 0, 0 },
 { "Manage items", cmd_item_manage, N_ELEMENTS(cmd_item_manage), 0, 0 },
 { "Information", cmd_info, N_ELEMENTS(cmd_info), 0, 0 },
 { "Utility", cmd_util, N_ELEMENTS(cmd_util), 0, 0 },
 { "Hidden", cmd_hidden, N_ELEMENTS(cmd_hidden), 0, 0 },
 /*
	 * This is nested below "Hidden"->"Debug mode commands" and only
	 * contains categories.
	 */
 { "Debug", cmd_debug, N_ELEMENTS(cmd_debug), 1, -1 },
 /* These are nested in "Debug"; names have to match with cmd_debug. */
 { "DbgObj", cmd_debug_obj, N_ELEMENTS(cmd_debug_obj), 2, 1 },
 { "DbgPlayer", cmd_debug_player, N_ELEMENTS(cmd_debug_player), 2, 1 },
 { "DbgTele", cmd_debug_tele, N_ELEMENTS(cmd_debug_tele), 2, 1 },
 { "DbgEffects", cmd_debug_effects, N_ELEMENTS(cmd_debug_effects), 2, 1 },
 { "DbgSummon", cmd_debug_summon, N_ELEMENTS(cmd_debug_summon), 2, 1 },
 { "DbgFiles", cmd_debug_files, N_ELEMENTS(cmd_debug_files), 2, 1 },
 { "DbgStat", cmd_debug_stats, N_ELEMENTS(cmd_debug_stats), 2, 1 },
 { "DbgQuery", cmd_debug_query, N_ELEMENTS(cmd_debug_query), 2, 1 },
 { "DbgMisc", cmd_debug_misc, N_ELEMENTS(cmd_debug_misc), 2, 1 },
 { NULL, NULL, 0, 0, 0 }
};
/*** Exported functions ***/
/* List of directly accessible commands indexed by char */
static struct cmd_info *converted_list[4][UCHAR_MAX+1];
/*
 * Lists of nested commands; each list is also indexed by char but there's no
 * distinction between original/roguelike keys
 */
static int n_nested = 0;
static struct cmd_info ***nested_lists = NULL;
/**
 * Initialise the command list.
 */
void cmd_init(void)
{
 size_t i, j;
 memset(converted_list, 0, sizeof(converted_list));
 /* Set up storage for the nested command lists */
 if (nested_lists != NULL) {
  assert(n_nested >= 0);
  for (j = 0; j < (size_t)n_nested; j++) {
   mem_free(nested_lists[j]);
  }
  nested_lists = NULL;
 }
 n_nested = 0;
 for (j = 0; j < N_ELEMENTS(cmds_all) - 1; j++) {
  n_nested = MAX(n_nested, cmds_all[j].keymap);
 }
 if (n_nested > 0) {
  nested_lists = mem_zalloc(n_nested * sizeof(*nested_lists));
  for (j = 0; j < (size_t)n_nested; j++) {
   nested_lists[j] = mem_zalloc((UCHAR_MAX + 1) *
           sizeof(*(nested_lists[j])));
  }
 }
 /* Go through all generic commands (-1 for NULL end entry) */
 for (j = 0; j < N_ELEMENTS(cmds_all) - 1; j++)
 {
  struct cmd_info *commands = cmds_all[j].list;
  /* Fill everything in */
  if (cmds_all[j].keymap == 0) {
   for (i = 0; i < cmds_all[j].len; i++) {
    /* If a key for a set isn't given, use the first */
    if (!commands[i].key[3])
     commands[i].key[3] = commands[i].key[0];
    if (!commands[i].key[2])
     commands[i].key[2] = commands[i].key[0];
    if (!commands[i].key[1])
     commands[i].key[1] = commands[i].key[0];
    /* Skip entries that don't have a valid key. */
    if (!commands[i].key[0] || !commands[i].key[1] ||
     !commands[i].key[2] || !commands[i].key[3])
     continue;
    converted_list[0][commands[i].key[0]] =
     &commands[i];
    converted_list[1][commands[i].key[1]] =
     &commands[i];
    converted_list[2][commands[i].key[2]] =
     &commands[i];
    converted_list[3][commands[i].key[3]] =
     &commands[i];
   }
  } else if (cmds_all[j].keymap > 0) {
   int kidx = cmds_all[j].keymap - 1;
   assert(kidx < n_nested);
   for (i = 0; i < cmds_all[j].len; i++) {
    /*
				 * Nested commands don't go through a keymap;
				 * use the default for all keys.
				 */
    commands[i].key[3] = commands[i].key[0];
    commands[i].key[2] = commands[i].key[0];
    commands[i].key[1] = commands[i].key[0];
    /*
				 * Check for duplicated keys in the same
				 * command set.
				 */
    assert(!nested_lists[kidx][commands[i].key[0]]);
    nested_lists[kidx][commands[i].key[0]] =
     &commands[i];
   }
  }
 }
}
unsigned char cmd_lookup_key(cmd_code lookup_cmd, int mode)
{
 unsigned int i;
 assert(mode >= KEYMAP_MODE_ORIG || mode < KEYMAP_MODE_MAX);
 for (i = 0; i < N_ELEMENTS(converted_list[mode]); i++) {
  struct cmd_info *cmd = converted_list[mode][i];
  if (cmd && cmd->cmd == lookup_cmd)
   return cmd->key[mode];
 }
 return 0;
}
unsigned char cmd_lookup_key_unktrl(cmd_code lookup_cmd, int mode)
{
 unsigned char c = cmd_lookup_key(lookup_cmd, mode);
 if (c < 0x20)
  c = UN_KTRL(c);
 return c;
}
cmd_code cmd_lookup(unsigned char key, int mode)
{
 assert(mode >= KEYMAP_MODE_ORIG || mode < KEYMAP_MODE_MAX);
 if (!converted_list[mode][key])
  return CMD_NULL;
 return converted_list[mode][key]->cmd;
}
/**
 * Return the index into cmds_all for the given name or -2 if not found.
 */
size_t cmd_list_lookup_by_name(const char *name)
{
 size_t i = 0;
 while (1) {
  if (i >= (int) N_ELEMENTS(cmds_all)) {
   /*
			 * Return a negative value other than -1 to prevent
			 * future lookups for the same name by ui-context.c.
			 * Those lookups are guaranteed to fail since the
			 * names in cmds_all don't change.
			 */
   return -2;
  }
  if (streq(cmds_all[i].name, name)) {
   return i;
  }
  ++i;
 }
}
/**
 * Parse and execute the current command
 * Give "Warning" on illegal commands.
 */
void textui_process_command(void)
{
 int count = 0;
 bool done = true;
 ui_event e = textui_get_command(&count);
 struct cmd_info *cmd = NULL;
 unsigned char key = '\0';
 int mode = OPT(player, angband_keyset) ? KEYMAP_MODE_ANGBAND : KEYMAP_MODE_ORIG;
 if (OPT(player, hjkl_movement)) {
  mode |= KEYMAP_MODE_ROGUE;
 }
 switch (e.type) {
  case EVT_RESIZE: do_cmd_redraw(); return;
  case EVT_MOUSE: textui_process_click(e); return;
  case EVT_BUTTON:
  case EVT_KBRD: done = textui_process_key(e.key, &key, count); break;
  default: ;
 }
 /* Null command */
 if (!key && done)
  return;
 if (key == KC_ENTER) {
  /* Use command menus */
  cmd = textui_action_menu_choose();
 } else {
  /* Command key */
  cmd = converted_list[mode][key];
 }
 if (cmd && done) {
  if (cmd->cmd || cmd->hook) {
   /* Confirm for worn equipment inscriptions. */
   if (!key_confirm_command(key)) cmd = NULL;
  } else {
   /*
			 * It refers to nested commands.  Get the nested
			 * command.  Those aren't subject to keymaps and
			 * inherit the count.
			 */
   while (cmd && !cmd->cmd && !cmd->hook) {
    char nestkey;
    if (cmd->nested_keymap > 0 &&
      cmd->nested_keymap <= n_nested &&
      cmd->nested_prompt) {
     if (get_com(cmd->nested_prompt, &nestkey)) {
      const char* em =
       cmd->nested_error;
      cmd = nested_lists[cmd->nested_keymap - 1][(unsigned char) nestkey];
      if (!cmd) {
       msg("%s", em ? em : "That is not a valid nested command.");
      }
     } else {
      cmd = NULL;
     }
    } else {
     cmd = NULL;
    }
   }
  }
  /* Check prereqs. */
  if (cmd && cmd->prereq && !cmd->prereq()) cmd = NULL;
  /* Split on type of command */
  if (cmd && cmd->hook)
   /* UI command */
   cmd->hook();
  else if (cmd && cmd->cmd)
   /* Game command */
   cmdq_push_repeat(cmd->cmd, count);
 } else
  /* Error */
  do_cmd_unknown();
}
errr textui_get_cmd(cmd_context context)
{
 if (context == CTX_GAME)
  textui_process_command();
 /* If we've reached here, we haven't got a command. */
 return 1;
}
/**
 * Allow for user abort during repeated commands, running and resting.
 *
 * This will only check during every 128th game turn while resting.
 */
void check_for_player_interrupt(game_event_type type, game_event_data *data,
        void *user)
{
 /* Check for "player abort" */
 if (player->upkeep->running ||
     cmd_get_nrepeats() > 0 ||
     (player_is_resting(player) && !(turn & 0x7F))) {
  ui_event e;
  /* Do not wait */
  inkey_scan = SCAN_INSTANT;
  /* Check for a key */
  e = inkey_ex();
  if (e.type != EVT_NONE) {
   /* Flush and disturb */
   event_signal(EVENT_INPUT_FLUSH);
   disturb(player, false);
   msg("Cancelled.");
  }
 }
}
static void pre_turn_refresh(void)
{
 term *old = Term;
 int j;
 if (character_dungeon) {
  /* Redraw map */
  player->upkeep->redraw |= (PR_MAP | PR_STATE);
  player->upkeep->redraw |= (PR_MONLIST | PR_ITEMLIST);
  handle_stuff(player);
  move_cursor_relative(player->grid.y, player->grid.x);
  for (j = 0; j < ANGBAND_TERM_MAX; j++) {
   if (!angband_term[j]) continue;
   Term_activate(angband_term[j]);
   Term_fresh();
  }
 }
 Term_activate(old);
}
/**
 * Start actually playing a game, either by loading a savefile or creating
 * a new character
 */
static bool start_game(bool new_game)
{
 const char *loadpath = savefile;
 bool exists;
 /* Player will be resuscitated if living in the savefile */
 player->is_dead = true;
 /* Try loading */
 savefile_get_panic_name(panicfile, sizeof(panicfile), loadpath);
 safe_setuid_grab();
 exists = loadpath[0] && file_exists(panicfile);
 safe_setuid_drop();
 if (exists) {
  bool newer;
  safe_setuid_grab();
  newer = file_newer(panicfile, loadpath);
  safe_setuid_drop();
  if (newer) {
   if (get_check("A panic save exists.  Use it? ")) {
    loadpath = panicfile;
   }
  } else {
   /* Remove the out-of-date panic save. */
   safe_setuid_grab();
   file_delete(panicfile);
   safe_setuid_drop();
  }
 }
 safe_setuid_grab();
 exists = file_exists(loadpath);
 safe_setuid_drop();
 if (exists && !savefile_load(loadpath, arg_wizard)) {
  return false;
 }
 /* No living character loaded */
 if (player->is_dead || new_game) {
  character_generated = false;
  textui_do_birth();
 }
 /* Tell the UI we've started. */
 event_signal(EVENT_LEAVE_INIT);
 event_signal(EVENT_ENTER_GAME);
 event_signal(EVENT_ENTER_WORLD);
 /* Save not required yet. */
 player->upkeep->autosave = false;
 /* Enter the level, generating a new one if needed */
 if (!character_dungeon) {
  prepare_next_level(player);
 }
 on_new_level();
 return true;
}
/**
 * Help select_savefile():  clean up the array of strings
 */
static void cleanup_savefile_selection_strings(char **entries, int count)
{
 int i;
 for (i = 0; i < count; ++i) {
  string_free(entries[i]);
 }
 mem_free(entries);
}
/**
 * Help play_game():  implement the savefile selection menu.
 *
 * \param retry flags that this is a repeated call because the savefile selected
 * by an earlier one could not be loaded.
 * \return GAME_NEW if starting a new game, GAME_LOAD if loading a savefile
 * or GAME_TUTORIAL if starting the tutorial.
 */
static enum game_mode_type select_savefile(bool retry)
{
 /* Build the list of selections. */
 savefile_getter g = NULL;
 /*
	 * Leave the first two entries for selecting a new game or the
	 * tutorial.  Will fill in the labels later.
	 */
 int count = 2, allocated = 16;
 char **entries = mem_zalloc(allocated * sizeof(*entries));
 char **names = mem_zalloc(allocated * sizeof(*names));
 int default_entry = 0;
 struct region m_region = { 0, 3, 0, 0 };
 int new_game_ind = 0, tutorial_ind = 1;
 enum game_mode_type result = GAME_LOAD;
 bool failed;
 struct menu *m;
 ui_event selection;
 while (got_savefile(&g)) {
  const struct savefile_details *details =
   get_savefile_details(g);
  assert(details);
  if (count == allocated) {
   allocated *= 2;
   entries = mem_realloc(entries,
    allocated * sizeof(*entries));
   names = mem_realloc(names, allocated * sizeof(*names));
  }
  if (details->desc) {
   entries[count] = string_make(format("Use %s: %s",
    details->fnam + details->foff, details->desc));
  } else {
   entries[count] = string_make(format("Use %s",
    details->fnam + details->foff));
  }
  names[count] = string_make(details->fnam);
  if (suffix(savefile, details->fnam)) {
   /*
			 * Matches what's in savefile; put it third in the
			 * list and mark it as the default entry.  If not
			 * forcing the name, clear savefile and arg_name so
			 * the new game option won't be set up to overwrite
			 * an existing savefile.
			 */
   if (count != 2) {
    char *hold_entry = entries[count];
    char *hold_name = names[count];
    int i;
    for (i = count; i > 2; --i) {
     entries[i] = entries[i - 1];
     names[i] = names[i - 1];
    }
    entries[2] = hold_entry;
    names[2] = hold_name;
   }
   default_entry = 2;
   if (!arg_force_name) {
    savefile[0] = '\0';
    arg_name[0] = '\0';
   }
  }
  ++count;
 }
 if (got_savefile_dir(g)) {
  assert(allocated > 1 && !entries[0] && !names[0]
   && !entries[1] && !names[1]);
  if (default_entry && arg_force_name) {
   /*
			 * Name set by front end is already in use and names
			 * are forced so don't allow the new game option.
			 */
   int i;
   for (i = 1; i < count - 1; ++i) {
    entries[i] = entries[i + 1];
    names[i] = names[i + 1];
   }
   --default_entry;
   --count;
   new_game_ind = -1;
   tutorial_ind = 0;
  } else {
   entries[new_game_ind] = string_make("New game");
  }
  entries[tutorial_ind] = string_make("Tutorial");
  failed = false;
 } else {
  failed = true;
 }
 cleanup_savefile_getter(g);
 if (failed) {
  cleanup_savefile_selection_strings(names, count);
  cleanup_savefile_selection_strings(entries, count);
  quit("Cannot open the savefile directory");
 }
 m = menu_new(MN_SKIN_SCROLL, menu_find_iter(MN_ITER_STRINGS));
 menu_setpriv(m, count, entries);
 menu_layout(m, &m_region);
 m->cursor = default_entry;
 m->flags |= MN_DBL_TAP;
 screen_save();
 prt("Select the save to use (movement keys and enter or mouse) or quit",
  0, 0);
 prt("(escape or second mouse button).", 1, 0);
 prt((retry) ? "The previously selected savefile was unusable." : "",
  2, 0);
 selection = menu_select(m, 0, false);
 screen_load();
 if (selection.type == EVT_SELECT) {
  if (m->cursor == new_game_ind) {
   result = GAME_NEW;
  } else if (m->cursor == tutorial_ind) {
   result = GAME_TUTORIAL;
  } else {
   assert(m->cursor > 0 && m->cursor < count
    && names[m->cursor]);
   path_build(savefile, sizeof(savefile),
    ANGBAND_DIR_SAVE, names[m->cursor]);
  }
 }
 menu_free(m);
 cleanup_savefile_selection_strings(names, count);
 cleanup_savefile_selection_strings(entries, count);
 if (selection.type == EVT_ESCAPE) {
  quit(NULL);
 }
 return result;
}
/**
 * Play Angband
 */
void play_game(enum game_mode_type mode)
{
 while (1) {
  play_again = false;
  /* Load a savefile or birth a character, or both */
  switch (mode) {
  case GAME_LOAD:
  case GAME_NEW:
   if (!start_game(mode == GAME_NEW)) {
    quit("Broken savefile");
   }
   break;
  case GAME_SELECT:
   {
    bool retry = false;
    while (1) {
     mode = select_savefile(retry);
     if (mode == GAME_LOAD
       || mode == GAME_NEW) {
      if (start_game(mode == GAME_NEW)) {
       break;
      }
      retry = true;
     } else {
      assert(mode == GAME_TUTORIAL);
      play_again = true;
      start_tutorial();
      break;
     }
    }
   }
   break;
  case GAME_TUTORIAL:
   play_again = true;
   start_tutorial();
   break;
  default:
   quit("Invalid game mode in play_game()");
   break;
  }
  /* Get commands from the user, then process the game world
		 * until the command queue is empty and a new player command
		 * is needed */
  while (!player->is_dead && player->upkeep->playing) {
   pre_turn_refresh();
   cmd_get_hook(CTX_GAME);
   run_game_loop();
  }
  /* Close game on death or quitting */
  close_game(true);
  if (!play_again) break;
  cleanup_angband();
  init_display();
  init_angband();
  if (reinit_hook != NULL) {
   (*reinit_hook)();
  }
  textui_init();
  mode = GAME_SELECT;
 }
}
/**
 * Set the savefile name.
 */
void savefile_set_name(const char *fname, bool make_safe, bool strip_suffix)
{
 char path[128];
 size_t pathlen = sizeof path;
 size_t off = 0;
 if (make_safe) {
  player_safe_name(path + off, pathlen, fname, strip_suffix);
 } else {
  my_strcpy(path + off, fname, pathlen);
 }
 /* Save the path */
 path_build(savefile, sizeof(savefile), ANGBAND_DIR_SAVE, path);
}
/**
 * Test whether savefile_set_name() generates a name that's already in use.
 */
bool savefile_name_already_used(const char *fname, bool make_safe,
  bool strip_suffix)
{
 char *hold = string_make(savefile);
 bool result;
 savefile_set_name(fname, make_safe, strip_suffix);
 result = file_exists(savefile);
 my_strcpy(savefile, hold, sizeof(savefile));
 string_free(hold);
 return result;
}
/**
 * Save the game.
 */
void save_game(void)
{
 (void) save_game_checked();
}
/**
 * Save the game.
 *
 * \return whether the save was successful.
 */
bool save_game_checked(void)
{
 char path[1024];
 bool result;
 /* Disturb the player */
 disturb(player, true);
 /* Clear messages */
 event_signal(EVENT_MESSAGE_FLUSH);
 /* Handle stuff */
 handle_stuff(player);
 /* Message */
 prt("Saving game...", 0, 0);
 /* Refresh */
 Term_fresh();
 /* The player is not dead */
 my_strcpy(player->died_from, "(saved)", sizeof(player->died_from));
 /* Forbid suspend */
 signals_ignore_tstp();
 /* Save the player */
 if (savefile_save(savefile)) {
  prt("Saving game... done.", 0, 0);
  result = true;
 } else {
  prt("Saving game... failed!", 0, 0);
  result = false;
 }
 /* Refresh */
 Term_fresh();
 /* Allow suspend again */
 signals_handle_tstp();
 /* Save the window prefs */
 path_build(path, sizeof(path), ANGBAND_DIR_USER, "window.prf");
 if (!prefs_save(path, option_dump, "Dump window settings"))
  prt("Failed to save subwindow preferences", 0, 0);
 /* Refresh */
 Term_fresh();
 /* Save monster memory to user directory */
 if (!lore_save("lore.txt")) {
  msg("lore save failed!");
  event_signal(EVENT_MESSAGE_FLUSH);
 }
 /* Refresh */
 Term_fresh();
 /* Note that the player is not dead */
 my_strcpy(player->died_from, "(alive and well)", sizeof(player->died_from));
 return result;
}
/**
 * Close up the current game (player may or may not be dead).
 *
 * \param prompt_failed_save If true, prompt the user to retry if saving fails.
 * Otherwise, no prompt is issued.
 *
 * Note that the savefile is not saved until the tombstone is
 * actually displayed and the player has a chance to examine
 * the inventory and such.  This allows cheating if the game
 * is equipped with a "quit without save" method.  XXX XXX XXX
 */
void close_game(bool prompt_failed_save)
{
 bool prompting = true;
 /* Tell the UI we're done with the world */
 event_signal(EVENT_LEAVE_WORLD);
 /* Handle stuff */
 handle_stuff(player);
 /* Flush the messages */
 event_signal(EVENT_MESSAGE_FLUSH);
 /* Flush the input */
 event_signal(EVENT_INPUT_FLUSH);
 /* No suspending now */
 signals_ignore_tstp();
 /* Hack -- Increase "icky" depth */
 screen_save_depth++;
 /* Deal with the randarts file */
 if (player->self_made_arts > 0) {
  write_self_made_artefacts();
  deactivate_randart_file();
 }
 /* Handle death or life */
 if (!in_tutorial()) {
  if (player->is_dead) {
   death_knowledge(player);
   death_screen();
   /* Save dead player */
   while (prompting && !savefile_save(savefile)) {
    if (!prompt_failed_save
      || !get_check("Saving failed.  Try again? ")) {
     prompting = false;
     msg("death save failed!");
     event_signal(EVENT_MESSAGE_FLUSH);
    }
   }
  } else {
   /* Save the game */
   while (prompting && !save_game_checked()) {
    if (!prompt_failed_save
      || !get_check("Saving failed.  Try again? ")) {
     prompting = false;
    }
   }
   if (Term->mapped_flag) {
    struct keypress ch;
    prt("Press Return (or Escape).", 0, 40);
    ch = inkey();
    if (ch.code != ESCAPE)
     predict_score(false);
   }
  }
 } else if (player->is_dead) {
  tutorial_display_death_note(player);
 }
 /* Wipe the monster list */
 wipe_mon_list(cave, player);
 /* Hack -- Decrease "icky" depth */
 screen_save_depth--;
 /* Tell the UI we're done with the game state */
 event_signal(EVENT_LEAVE_GAME);
 /* Allow suspending now */
 signals_handle_tstp();
}
/**
 * Enumerate savefiles in the savefile directory that are available to the
 * current player.
 *
 * \param pg points to the state for the enumeration.  If *pg is NULL, the
 * enumeration will start from scratch.  After enumerating, *pg should be
 * passed to cleanup_savefile_getter() to release any allocated resources.
 * \return true if another savefile useful for the player was found.  In
 * that case calling get_savefile_details() on *pg will return a non-NULL
 * result.  Otherwise, return false.
 */
bool got_savefile(savefile_getter *pg)
{
 char fname[256];
 if (*pg == NULL) {
  /* Initialize the enumeration. */
  *pg = mem_zalloc(sizeof(**pg));
  /* Need enhanced privileges to read from the save directory. */
  safe_setuid_grab();
  (*pg)->d = my_dopen(ANGBAND_DIR_SAVE);
  safe_setuid_drop();
  if (!(*pg)->d) {
   return false;
  }
  (*pg)->have_savedir = true;
  /*
		 * Set up the user-specific prefix.  Mimics savefile_set_name().
		 */
  (*pg)->details.foff = 0;
 } else {
  if (!(*pg)->d) {
   assert(!(*pg)->have_details);
   return false;
  }
 }
 while (1) {
  char path[1024];
  const char *desc;
  bool no_entry;
  /*
		 * Also need elevated privileges for the file attribute queries
		 * in my_dread().
		 */
  safe_setuid_grab();
  no_entry = !my_dread((*pg)->d, fname, sizeof(fname));
  safe_setuid_drop();
  if (no_entry) {
   break;
  }
  path_build(path, sizeof(path), ANGBAND_DIR_SAVE, fname);
  desc = savefile_get_description(path);
  string_free((*pg)->details.fnam);
  (*pg)->details.fnam = string_make(fname);
  string_free((*pg)->details.desc);
  (*pg)->details.desc = string_make(desc);
  (*pg)->have_details = true;
  return true;
 }
 my_dclose((*pg)->d);
 (*pg)->d = NULL;
 (*pg)->have_details = false;
 return false;
}
/**
 * Return whether the savefile directory was at all readable.
 */
bool got_savefile_dir(const savefile_getter g)
{
 return g && g->have_savedir;
}
/**
 * Return the details for a savefile enumerated by a prior call to
 * got_savefile().
 *
 * \return is NULL if the prior call to get_savefile() failed.  Otherwise,
 * returns a non-null pointer with the details about the enumerated savefile.
 */
const struct savefile_details *get_savefile_details(const savefile_getter g)
{
 return (g && g->have_details) ? &g->details : NULL;
}
/**
 * Cleanup resources allocated by got_savefile().
 */
void cleanup_savefile_getter(savefile_getter g)
{
 if (g) {
  string_free(g->details.desc);
  string_free(g->details.fnam);
  if (g->d) {
   my_dclose(g->d);
  }
  mem_free(g);
 }
}
/**
 * \file ui-help.c
 * \brief In-game help
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Make a string lower case.
 */
static void string_lower(char *buf)
{
 char *s;
 /* Lowercase the string */
 for (s = buf; *s != 0; s++) *s = tolower((unsigned char)*s);
}
/**
 * Recursive file perusal.
 *
 * Return false on "?", otherwise true.
 *
 * This function could be made much more efficient with the use of "seek"
 * functionality, especially when moving backwards through a file, or
 * forwards through a file by less than a page at a time.  XXX XXX XXX
 */
bool show_file(const char *name, const char *what, int line, int mode)
{
 int i, k, n;
 struct keypress ch = KEYPRESS_NULL;
 /* Number of "real" lines passed by */
 int next = 0;
 /* Number of "real" lines in the file */
 int size;
 /* Backup value for "line" */
 int back = 0;
 /* This screen has sub-screens */
 bool menu = false;
 /* Case sensitive search */
 bool case_sensitive = false;
 /* Current help file */
 ang_file *fff = NULL;
 /* Find this string (if any) */
 char *find = NULL;
 /* Jump to this tag */
 const char *tag = NULL;
 /* Hold a string to find */
 char finder[80] = "";
 /* Hold a string to show */
 char shower[80] = "";
 /* Filename */
 char filename[1024];
 /* Describe this thing */
 char caption[128] = "";
 /* Path buffer */
 char path[1024];
 /* General buffer */
 char buf[1024];
 /* Lower case version of the buffer, for searching */
 char lc_buf[1024];
 /* Sub-menu information */
 char hook[26][32];
 int wid, hgt;
 /* true if we are inside a RST block that should be skipped */
 bool skip_lines = false;
 /* Wipe the hooks */
 for (i = 0; i < 26; i++) hook[i][0] = '\0';
 /* Get size */
 Term_get_size(&wid, &hgt);
 /* Copy the filename */
 my_strcpy(filename, name, sizeof(filename));
 n = strlen(filename);
 /* Extract the tag from the filename */
 for (i = 0; i < n; i++) {
  if (filename[i] == '#') {
   filename[i] = '\0';
   tag = filename + i + 1;
   break;
  }
 }
 /* Redirect the name */
 name = filename;
 /* Currently unused facility to show and describe arbitrary files */
 if (what) {
  my_strcpy(caption, what, sizeof(caption));
  my_strcpy(path, name, sizeof(path));
  fff = file_open(path, MODE_READ, FTYPE_TEXT);
 }
 /* Look in "help" */
 if (!fff) {
  strnfmt(caption, sizeof(caption), "Help file '%s'", name);
  path_build(path, sizeof(path), ANGBAND_DIR_HELP, name);
  fff = file_open(path, MODE_READ, FTYPE_TEXT);
 }
 /* Oops */
 if (!fff) {
  /* Message */
  msg("Cannot open '%s'.", name);
  event_signal(EVENT_MESSAGE_FLUSH);
  /* Oops */
  return (true);
 }
 /* Pre-Parse the file */
 while (true) {
  /* Read a line or stop */
  if (!file_getl(fff, buf, sizeof(buf))) break;
  /* Skip lines if we are inside a RST directive */
  if (skip_lines){
   if (contains_only_spaces(buf))
    skip_lines = false;
   continue;
  }
  /* Parse a very small subset of RST */
  /* TODO: should be more flexible */
  if (prefix(buf, ".. ")) {
   /* parse ".. menu:: [x] filename.txt" (with exact spacing)*/
   if (prefix(buf+strlen(".. "), "menu:: [") &&
                           buf[strlen(".. menu:: [x")]==']') {
    /* This is a menu file */
    menu = true;
    /* Extract the menu item */
    k = A2I(buf[strlen(".. menu:: [")]);
    /* Store the menu item (if valid) */
    if ((k >= 0) && (k < 26))
     my_strcpy(hook[k], buf + strlen(".. menu:: [x] "),
         sizeof(hook[0]));
   } else if (buf[strlen(".. ")] == '_') {
    /* parse ".. _some_hyperlink_target:" */
    if (tag) {
     /* Remove the closing '>' of the tag */
     buf[strlen(buf) - 1] = '\0';
     /* Compare with the requested tag */
     if (streq(buf + strlen(".. _"), tag)) {
      /* Remember the tagged line */
      line = next;
     }
    }
   }
   /* Skip this and enter skip mode*/
   skip_lines = true;
   continue;
  }
  /* Count the "real" lines */
  next++;
 }
 /* Save the number of "real" lines */
 size = next;
 /* Display the file */
 while (true) {
  /* Clear screen */
  Term_clear();
  /* Restrict the visible range */
  if (line > (size - (hgt - 4))) line = size - (hgt - 4);
  if (line < 0) line = 0;
  skip_lines = false;
  /* Re-open the file if needed */
  if (next > line) {
   /* Close it */
   file_close(fff);
   /* Hack -- Re-Open the file */
   fff = file_open(path, MODE_READ, FTYPE_TEXT);
   if (!fff) return (true);
   /* File has been restarted */
   next = 0;
  }
  /* Goto the selected line */
  while (next < line) {
   /* Get a line */
   if (!file_getl(fff, buf, sizeof(buf))) break;
   /* Skip lines if we are inside a RST directive*/
   if (skip_lines) {
    if (contains_only_spaces(buf))
     skip_lines=false;
    continue;
   }
   /* Skip RST directives */
   if (prefix(buf, ".. ")) {
    skip_lines=true;
    continue;
   }
   /* Count the lines */
   next++;
  }
  /* Dump the next lines of the file */
  for (i = 0; i < hgt - 4; ) {
   /* Hack -- track the "first" line */
   if (!i) line = next;
   /* Get a line of the file or stop */
   if (!file_getl(fff, buf, sizeof(buf))) break;
   /* Skip lines if we are inside a RST directive */
   if (skip_lines) {
    if (contains_only_spaces(buf))
     skip_lines = false;
    continue;
   }
   /* Skip RST directives */
   if (prefix(buf, ".. ")) {
    skip_lines=true;
    continue;
   }
   /* Count the "real" lines */
   next++;
   /* Make a copy of the current line for searching */
   my_strcpy(lc_buf, buf, sizeof(lc_buf));
   /* Make the line lower case */
   if (!case_sensitive) string_lower(lc_buf);
   /* Hack -- keep searching */
   if (find && !i && !strstr(lc_buf, find)) continue;
   /* Hack -- stop searching */
   find = NULL;
   /* Dump the line */
   Term_putstr(0, i+2, -1, COLOUR_WHITE, buf);
   /* Highlight "shower" */
   if (strlen(shower)) {
    const char *str = lc_buf;
    /* Display matches */
    while ((str = strstr(str, shower)) != NULL) {
     int len = strlen(shower);
     /* Display the match */
     Term_putstr(str-lc_buf, i+2, len, COLOUR_YELLOW,
        &buf[str-lc_buf]);
     /* Advance */
     str += len;
    }
   }
   /* Count the printed lines */
   i++;
  }
  /* Hack -- failed search */
  if (find) {
   bell();
   line = back;
   find = NULL;
   continue;
  }
  /* Show a general "title" */
  prt(format("[%s, %s, Line %d-%d/%d]", buildid,
             caption, line, line + hgt - 4, size), 0, 0);
  /* Prompt */
  if (menu) {
   /* Menu screen */
   prt("[Press a Letter, or ESC to exit.]", hgt - 1, 0);
  } else if (size <= hgt - 4) {
   /* Small files */
   prt("[Press ESC to exit.]", hgt - 1, 0);
  } else {
   /* Large files */
   prt("[Press Space to advance, or ESC to exit.]", hgt - 1, 0);
  }
  /* Get a keypress */
  ch = inkey();
  /* Exit the help */
  if (ch.code == '?') break;
  /* Toggle case sensitive on/off */
  if (ch.code == '!')
   case_sensitive = !case_sensitive;
  /* Try showing */
  if (ch.code == '&') {
   /* Get "shower" */
   prt("Show: ", hgt - 1, 0);
   (void)askfor_aux(shower, sizeof(shower), NULL);
   /* Make the "shower" lowercase */
   if (!case_sensitive) string_lower(shower);
  }
  /* Try finding */
  if (ch.code == '/') {
   /* Get "finder" */
   prt("Find: ", hgt - 1, 0);
   if (askfor_aux(finder, sizeof(finder), NULL)) {
    /* Find it */
    find = finder;
    back = line;
    line = line + 1;
    /* Make the "finder" lowercase */
    if (!case_sensitive) string_lower(finder);
    /* Show it */
    my_strcpy(shower, finder, sizeof(shower));
   }
  }
  /* Go to a specific line */
  if (ch.code == '#') {
   char tmp[80] = "0";
   prt("Goto Line: ", hgt - 1, 0);
   if (askfor_aux(tmp, sizeof(tmp), NULL))
    line = atoi(tmp);
  }
  /* Go to a specific file */
  if (ch.code == '%') {
   char ftmp[80];
   if (OPT(player, angband_keyset)) {
    my_strcpy(ftmp, "a_index.txt", sizeof(ftmp));
   } else {
    my_strcpy(ftmp, "index.txt", sizeof(ftmp));
   }
   prt("Goto File: ", hgt - 1, 0);
   if (askfor_aux(ftmp, sizeof(ftmp), NULL)) {
    if (!show_file(ftmp, NULL, 0, mode))
     ch.code = ESCAPE;
   }
  }
  switch (ch.code) {
   /* up a line */
   case ARROW_UP:
   case 'k':
   case '8': line--; break;
   /* up a page */
   case KC_PGUP:
   case '9':
   case '-': line -= (hgt - 4); break;
   /* home */
   case KC_HOME:
   case '7': line = 0; break;
   /* down a line */
   case ARROW_DOWN:
   case '2':
   case 'j':
   case KC_ENTER: line++; break;
   /* down a page */
   case KC_PGDOWN:
   case '3':
   case ' ': line += hgt - 4; break;
   /* end */
   case KC_END:
   case '1': line = size; break;
  }
  /* Recurse on letters */
  if (menu && isalpha((unsigned char)ch.code)) {
   /* Extract the requested menu item */
   k = A2I(ch.code);
   /* Verify the menu item */
   if ((k >= 0) && (k <= 25) && hook[k][0]) {
    /* Recurse on that file */
    if (!show_file(hook[k], NULL, 0, mode)) ch.code = ESCAPE;
   }
  }
  /* Exit on escape */
  if (ch.code == ESCAPE) break;
 }
 /* Close the file */
 file_close(fff);
 /* Done */
 return (ch.code != '?');
}
/**
 * Peruse the On-Line-Help
 */
void do_cmd_help(void)
{
 /* Save screen */
 screen_save();
 /* Peruse the main help file */
 (void)show_file((OPT(player, angband_keyset)) ?
  "a_index.txt" : "index.txt", NULL, 0, 0);
 /* Load screen */
 screen_load();
}
/**
 * \file ui-history.c
 * \brief Character auto-history display UI
 *
 * Copyright (c) 2007 J.D. White
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Print the header for the history display
 */
static void print_history_header(void)
{
 c_put_str(COLOUR_WHITE, "[Player history]", 0, 0);
 c_put_str(COLOUR_L_BLUE, "      Turn   Depth  Note", 1, 0);
}
/**
 * Handles all of the display functionality for the history list.
 */
void history_display(void)
{
 struct history_info *history_list_local = NULL;
 size_t max_item = history_get_list(player, &history_list_local);
 int row, wid, hgt, page_size;
 char buf[120];
 static size_t first_item = 0;
 size_t i;
 bool active = true;
 Term_get_size(&wid, &hgt);
 /* Five lines provide space for the header and footer */
 page_size = hgt - 5;
 screen_save();
 while (active)
 {
  struct keypress ch;
  Term_clear();
  /* Print everything to screen */
  print_history_header();
  row = 0;
  for (i = first_item; row <= page_size && i < max_item; i++)
  {
   strnfmt(buf, sizeof(buf), "%10ld%7d\'  %s",
    (long)history_list_local[i].turn,
    history_list_local[i].dlev * 50,
    history_list_local[i].event);
   if (hist_has(history_list_local[i].type, HIST_ARTIFACT_LOST))
    my_strcat(buf, " (LOST)", sizeof(buf));
   /* Size of header = 3 lines */
   prt(buf, row + 2, 0);
   row++;
  }
  prt("[Arrow keys scroll, p/PgUp for previous page, n/PgDn for next page, ESC to exit.]", hgt - 1, 0);
  ch = inkey();
  switch (ch.code) {
   case 'n':
   case ' ':
   case KC_PGDOWN: {
    size_t scroll_to = first_item + page_size;
    first_item = (scroll_to < max_item ? scroll_to : max_item);
    break;
   }
   case 'p':
   case KC_PGUP: {
    int scroll_to = first_item - page_size;
    first_item = (scroll_to >= 0 ? scroll_to : 0);
    break;
   }
   case 'j':
   case ARROW_DOWN: {
    size_t scroll_to = first_item + 1;
    first_item = (scroll_to < max_item ? scroll_to : max_item);
    break;
   }
   case 'k':
   case ARROW_UP: {
    int scroll_to = first_item - 1;
    first_item = (scroll_to >= 0 ? scroll_to : 0);
    break;
   }
   case ESCAPE:
    active = false;
    break;
  }
 }
 screen_load();
 return;
}
/**
 * Dump character history to a file, which we assume is already open.
 */
void dump_history(ang_file *file)
{
 struct history_info *history_list_local = NULL;
 size_t max_item = history_get_list(player, &history_list_local);
 size_t i;
 char buf[120];
 file_putf(file, "[Player history]\n");
 file_putf(file, "      Turn   Depth  Note\n");
 for (i = 0; i < max_item; i++) {
  strnfmt(buf, sizeof(buf), "%10ld%7d\'  %s",
    (long)history_list_local[i].turn,
    history_list_local[i].dlev * 50,
    history_list_local[i].event);
  if (hist_has(history_list_local[i].type, HIST_ARTIFACT_LOST))
   my_strcat(buf, " (LOST)", sizeof(buf));
  file_putf(file, "%s", buf);
  file_put(file, "\n");
 }
 return;
}
/**
 * \file ui-init.c
 * \brief UI initialistion
 *
 * Copyright (c) 2015 Nick McConnell
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 *
 * This file is used to initialize various variables and arrays for the
 * Angband game.
 *
 * Several of the arrays for Angband are built from data files in the
 * "lib/gamedata" directory.
 */
/**
 * Initialise the UI
 */
void textui_init(void)
{
 uint32_t default_window_flag[ANGBAND_TERM_MAX];
 /* Initialize graphics info and basic pref data */
 event_signal_message(EVENT_INITSTATUS, 0, "Loading basic pref file...");
 (void)process_pref_file("pref.prf", false, false);
 if (!play_again) {
  /* Sneakily init command list */
  cmd_init();
  /* Initialize knowledge things */
  textui_knowledge_init();
  /* Initialize input hooks */
  textui_input_init();
  /* Initialize visual prefs */
  textui_prefs_init();
  /* Hack -- Increase "icky" depth */
  screen_save_depth++;
  /* Verify main term */
  if (!term_screen)
   quit("Main window does not exist");
  /* Make sure main term is active */
  Term_activate(term_screen);
  /* Verify minimum size */
  if ((Term->hgt < 24) || (Term->wid < 80))
   plog("Main window is too small - please make it bigger.");
  /* Hack -- Turn off the cursor */
  (void)Term_set_cursor(false);
  /* Update terminals for preference changes. */
  (void) Term_xtra(TERM_XTRA_REACT, 0);
  (void) Term_redraw_all();
 } else {
  /* Redo knowledge initialization. */
  textui_knowledge_cleanup();
  textui_knowledge_init();
 }
 /* Initialize window options that will be overridden by any "window.prf" */
 memset(window_flag, 0, sizeof(uint32_t)*ANGBAND_TERM_MAX);
 memset(default_window_flag, 0, sizeof default_window_flag);
 if (ANGBAND_TERM_MAX > 1) default_window_flag[1] = (PW_INVEN);
 if (ANGBAND_TERM_MAX > 2) default_window_flag[2] = (PW_EQUIP);
 if (ANGBAND_TERM_MAX > 3) default_window_flag[3] = (PW_COMBAT_ROLLS);
 if (ANGBAND_TERM_MAX > 4) default_window_flag[4] = (PW_MONSTER);
 if (ANGBAND_TERM_MAX > 5) default_window_flag[5] = (PW_PLAYER_0);
 if (ANGBAND_TERM_MAX > 6) default_window_flag[6] = (PW_MESSAGE);
 if (ANGBAND_TERM_MAX > 7) default_window_flag[7] = (PW_MONLIST);
 /* Set up the subwindows */
 subwindows_set_flags(default_window_flag, ANGBAND_TERM_MAX);
 /* Done */
 event_signal_message(EVENT_INITSTATUS, 0, "Initialization complete");
}
/**
 * Clean up UI
 */
void textui_cleanup(void)
{
 /* Cleanup any options menus */
 cleanup_options();
 keymap_free();
 textui_prefs_free();
 textui_knowledge_cleanup();
}
/**
 * \file ui-input.c
 * \brief Some high-level UI functions, inkey()
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
static bool inkey_xtra;
uint32_t inkey_scan; /* See the "inkey()" function */
bool inkey_flag; /* See the "inkey()" function */
/**
 * Flush all pending input.
 *
 * Actually, remember the flush, using the "inkey_xtra" flag, and in the
 * next call to "inkey()", perform the actual flushing, for efficiency,
 * and correctness of the "inkey()" function.
 */
void flush(game_event_type unused, game_event_data *data, void *user)
{
 /* Do it later */
 inkey_xtra = true;
}
/**
 * Helper function called only from "inkey()"
 */
static ui_event inkey_aux(int scan_cutoff)
{
 int w = 0;
 ui_event ke;
 /* Wait for a keypress */
 if (scan_cutoff == SCAN_OFF) {
  (void)(Term_inkey(&ke, true, true));
 } else {
  w = 0;
  /* Wait only as long as macro activation would wait */
  while (Term_inkey(&ke, false, true) != 0) {
   /* Increase "wait" */
   w++;
   /* Excessive delay */
   if (w >= scan_cutoff) {
    ui_event empty = EVENT_EMPTY;
    return empty;
   }
   /* Delay */
   Term_xtra(TERM_XTRA_DELAY, 10);
  }
 }
 return (ke);
}
/**
 * Mega-Hack -- special "inkey_next" pointer.  XXX XXX XXX
 *
 * This special pointer allows a sequence of keys to be "inserted" into
 * the stream of keys returned by "inkey()".  This key sequence cannot be
 * bypassed by the Borg.  We use it to implement keymaps.
 */
struct keypress *inkey_next = NULL;
/**
 * See if more propmts will be skipped while in a keymap.
 */
static bool keymap_auto_more;
/**
 * Get a keypress from the user.
 *
 * This function recognizes a few "global parameters".  These are variables
 * which, if set to true before calling this function, will have an effect
 * on this function, and which are always reset to false by this function
 * before this function returns.  Thus they function just like normal
 * parameters, except that most calls to this function can ignore them.
 *
 * If "inkey_xtra" is true, then all pending keypresses will be flushed.
 * This is set by flush(), which doesn't actually flush anything itself
 * but uses that flag to trigger delayed flushing.
 *
 * If "inkey_scan" is true, then we will immediately return "zero" if no
 * keypress is available, instead of waiting for a keypress.
 *
 * If "inkey_flag" is true, then we are waiting for a command in the main
 * map interface, and we shouldn't show a cursor.
 *
 * If we are waiting for a keypress, and no keypress is ready, then we will
 * refresh (once) the window which was active when this function was called.
 *
 * Note that "back-quote" is automatically converted into "escape" for
 * convenience on machines with no "escape" key.
 *
 * If "angband_term[0]" is not active, we will make it active during this
 * function, so that the various "main-xxx.c" files can assume that input
 * is only requested (via "Term_inkey()") when "angband_term[0]" is active.
 *
 * Mega-Hack -- This function is used as the entry point for clearing the
 * "signal_count" variable, and of the "character_saved" variable.
 *
 * Mega-Hack -- Note the use of "inkey_hack" to allow the "Borg" to steal
 * control of the keyboard from the user.
 */
ui_event inkey_ex(void)
{
 bool cursor_state;
 ui_event kk;
 ui_event ke = EVENT_EMPTY;
 bool done = false;
 term *old = Term;
 /* Delayed flush */
 if (inkey_xtra) {
  Term_flush();
  inkey_next = NULL;
  inkey_xtra = false;
 }
 /* Hack -- Use the "inkey_next" pointer */
 while (inkey_next && inkey_next->code) {
  /* Get next character, and advance */
  ke.key = *inkey_next++;
  /* Cancel the various "global parameters" */
  inkey_flag = false;
  inkey_scan = 0;
  /* Peek at the key, and see if we want to skip more prompts */
  if (ke.key.code == '(') {
   keymap_auto_more = true;
   /* Since we are not returning this char, make sure the
			 * next key below works well */
   if (!inkey_next || !inkey_next->code) {
    ke.type = EVT_NONE;
    break;
   }
   continue;
  } else if (ke.key.code == ')') {
   keymap_auto_more = false;
   /* Since we are not returning this char, make sure the
			 * next key below works well */
   if (!inkey_next || !inkey_next->code) {
    ke.type = EVT_NONE;
    break;
   }
   continue;
  }
  /* Accept result */
  return (ke);
 }
 /* make sure that the flag to skip more prompts is off */
 keymap_auto_more = false;
 /* Forget pointer */
 inkey_next = NULL;
 /* Get the cursor state */
 (void)Term_get_cursor(&cursor_state);
 /* Show the cursor if waiting, except sometimes in "command" mode */
 if (!inkey_scan && (!inkey_flag || screen_save_depth))
  (void)Term_set_cursor(true);
 /* Hack -- Activate main screen */
 Term_activate(term_screen);
 /* Get a key */
 while (ke.type == EVT_NONE) {
  /* Hack -- Handle "inkey_scan == SCAN_INSTANT */
  if (inkey_scan == SCAN_INSTANT &&
   (0 != Term_inkey(&kk, false, false)))
   break;
  /* Hack -- Flush output once when no key ready */
  if (!done && (0 != Term_inkey(&kk, false, false))) {
   /* Hack -- activate proper term */
   Term_activate(old);
   /* Flush output */
   Term_fresh();
   /* Hack -- activate main screen */
   Term_activate(term_screen);
   /* Mega-Hack -- reset saved flag */
   character_saved = false;
   /* Mega-Hack -- reset signal counter */
   signal_count = 0;
   /* Only once */
   done = true;
  }
  /* Get a key (see above) */
  ke = inkey_aux(inkey_scan);
  if (inkey_scan && ke.type == EVT_NONE)
   /* The keypress timed out. We need to stop here. */
   break;
  /* Treat back-quote as escape */
  if (ke.key.code == '`')
   ke.key.code = ESCAPE;
 }
 /* Hack -- restore the term */
 Term_activate(old);
 /* Restore the cursor */
 Term_set_cursor(cursor_state);
 /* Cancel the various "global parameters" */
 inkey_flag = false;
 inkey_scan = 0;
 /* Return the keypress */
 return (ke);
}
/**
 * Get a keypress or mouse click from the user and ignore it.
 */
void anykey(void)
{
 ui_event ke = EVENT_EMPTY;
 /* Only accept a keypress or mouse click */
 while (ke.type != EVT_MOUSE && ke.type != EVT_KBRD)
  ke = inkey_ex();
}
/**
 * Get a "keypress" from the user.
 */
struct keypress inkey(void)
{
 ui_event ke = EVENT_EMPTY;
 while (ke.type != EVT_ESCAPE && ke.type != EVT_KBRD &&
     ke.type != EVT_MOUSE && ke.type != EVT_BUTTON)
  ke = inkey_ex();
 /* Make the event a keypress */
 if (ke.type == EVT_ESCAPE) {
  ke.type = EVT_KBRD;
  ke.key.code = ESCAPE;
  ke.key.mods = 0;
 } else if (ke.type == EVT_MOUSE) {
  if (ke.mouse.button == 1) {
   ke.type = EVT_KBRD;
   ke.key.code = '\n';
   ke.key.mods = 0;
  } else {
   ke.type = EVT_KBRD;
   ke.key.code = ESCAPE;
   ke.key.mods = 0;
  }
 } else if (ke.type == EVT_BUTTON) {
  ke.type = EVT_KBRD;
 }
 return ke.key;
}
/**
 * Get a "keypress" or a "mousepress" from the user.
 * on return the event must be either a key press or a mouse press
 */
ui_event inkey_m(void)
{
 ui_event ke = EVENT_EMPTY;
 /* Only accept a keypress */
 while (ke.type != EVT_ESCAPE && ke.type != EVT_KBRD &&
     ke.type != EVT_MOUSE && ke.type != EVT_BUTTON)
  ke = inkey_ex();
 if (ke.type == EVT_ESCAPE) {
  ke.type = EVT_KBRD;
  ke.key.code = ESCAPE;
  ke.key.mods = 0;
 } else if (ke.type == EVT_BUTTON) {
  ke.type = EVT_KBRD;
 }
  return ke;
}
/**
 * Hack -- flush
 */
static void msg_flush(int x)
{
 uint8_t a = COLOUR_L_BLUE;
 /* Pause for response */
 Term_putstr(x, 0, -1, a, "-more-");
 if ((!OPT(player, auto_more)) && !keymap_auto_more)
  anykey();
 /* Clear the line */
 Term_erase(0, 0, 255);
}
/**
 * Like msg_flush() but split what has already been pushed to the Term's
 * buffer to make room for the "-more-" prompt.
 *
 * \param w is the number of columns in the terminal
 * \param x points to the integer storing the column where the next
 * message will start.
 */
static void msg_flush_split_existing(int w, int *x)
{
 /* Default place to split what's there */
 int split = MIN(*x, w - 8);
 int i = split;
 wchar_t *svc = NULL;
 int *sva = NULL;
 /* Find the rightmost split point. */
 while (i > w / 2) {
  int a;
  wchar_t c;
  --i;
  Term_what(i, 0, &a, &c);
  if (c == L' ') {
   split = i;
   break;
  }
 }
 /* Remember what's on and after the split point. */
 *x -= split;
 if (*x > 0) {
  svc = mem_alloc(*x * sizeof(*svc));
  sva = mem_alloc(*x * sizeof(*sva));
  for (i = 0; i < *x; ++i) {
   Term_what(i + split, 0, &sva[i], &svc[i]);
  }
 }
 Term_erase(split, 0, w);
 msg_flush(split + 1);
 /* Put back what was remembered. */
 if (*x > 0) {
  for (i = 0; i < *x; ++i) {
   Term_putch(i, 0, sva[i], svc[i]);
  }
  mem_free(sva);
  mem_free(svc);
 }
}
static int message_column = 0;
/**
 * Player has pending message
 */
bool msg_flag;
/**
 * Output a message to the top line of the screen.
 *
 * Break long messages into multiple pieces (40-72 chars).
 *
 * Allow multiple short messages to "share" the top line.
 *
 * Prompt the user to make sure he has a chance to read them.
 *
 * These messages are memorized for later reference (see above).
 *
 * We could do a "Term_fresh()" to provide "flicker" if needed.
 *
 * The global "msg_flag" variable can be cleared to tell us to "erase" any
 * "pending" messages still on the screen, instead of using "msg_flush()".
 * This should only be done when the user is known to have read the message.
 *
 * We must be very careful about using the "msg("%s", )" functions without
 * explicitly calling the special "msg("%s", NULL)" function, since this may
 * result in the loss of information if the screen is cleared, or if anything
 * is displayed on the top line.
 *
 * Hack -- Note that "msg("%s", NULL)" will clear the top line even if no
 * messages are pending.
 */
void display_message(game_event_type unused, game_event_data *data, void *user)
{
 int n;
 char *t;
 char buf[1024];
 uint8_t color;
 int w, h;
 int type;
 const char *msg;
 if (!data) return;
 type = data->message.type;
 msg = data->message.msg;
 if (Term && type == MSG_BELL) {
  Term_xtra(TERM_XTRA_NOISE, 0);
  return;
 }
 if (!msg || !Term || !character_generated)
  return;
 /* Obtain the size */
 (void)Term_get_size(&w, &h);
 /* Hack -- Reset */
 if (!msg_flag) message_column = 0;
 /* Message Length */
 n = (msg ? strlen(msg) : 0);
 /* Hack -- flush when requested or needed */
 if (message_column && (!msg || ((message_column + n) > (w - 8)))) {
  /* Flush */
  if (message_column <= w - 8) {
   msg_flush(message_column);
   message_column = 0;
  } else {
   msg_flush_split_existing(w, &message_column);
  }
  /* Forget it */
  msg_flag = false;
 }
 /* No message */
 if (!msg) return;
 /* Paranoia */
 if (n > 1000) return;
 /* Copy it */
 my_strcpy(buf, msg, sizeof(buf));
 /* Analyze the buffer */
 t = buf;
 /* Get the color of the message */
 color = message_type_color(type);
 /* Split message */
 while (message_column + n > w - 1) {
  /* Default split */
  int split = MAX(w - 8 - message_column, 0);
  int check = split;
  char oops;
  /* Find the rightmost split point */
  while (check > MAX(w / 2 - message_column, 0)) {
   --check;
   if (t[check] == ' ') {
    split = check;
    break;
   }
  }
  /* Save the split character */
  oops = t[split];
  /* Split the message */
  t[split] = '\0';
  /* Display part of the message */
  Term_putstr(message_column, 0, split, color, t);
  /* Flush it */
  msg_flush(message_column + split + 1);
  /* Restore the split character */
  t[split] = oops;
  /* Insert a space */
  t[--split] = ' ';
  /* Prepare to recurse on the rest of "buf" */
  t += split; n -= split; message_column = 0;
 }
 /* Display the tail of the message */
 Term_putstr(message_column, 0, n, color, t);
 /* Remember the message */
 msg_flag = true;
 /* Remember the position */
 message_column += n + 1;
}
/**
 * Flush the output before displaying for emphasis
 */
void bell_message(game_event_type unused, game_event_data *data, void *user)
{
 /* Flush the output */
 Term_fresh();
 display_message(unused, data, user);
 player->upkeep->redraw |= PR_MESSAGE;
}
/**
 * Print the queued messages.
 */
void message_flush(game_event_type unused, game_event_data *data, void *user)
{
 /* Hack -- Reset */
 if (!msg_flag) message_column = 0;
 /* Flush when needed */
 if (message_column) {
  /* Print pending messages */
  if (Term) {
   int w, h;
   (void)Term_get_size(&w, &h);
   while (message_column > w - 8) {
    msg_flush_split_existing(w, &message_column);
   }
   if (message_column) {
    msg_flush(message_column);
   }
  }
  /* Forget it */
  msg_flag = false;
  /* Reset */
  message_column = 0;
 }
}
/**
 * Clear the bottom part of the screen
 */
void clear_from(int row)
{
 int y;
 /* Erase requested rows */
 for (y = row; y < Term->hgt; y++)
  Term_erase(0, y, 255);
}
/**
 * The default "keypress handling function" for askfor_aux()/askfor_aux_ext(),
 * this takes the given keypress, input buffer, length, etc, and does the
 * appropriate action for that keypress, such as moving the cursor left or
 * inserting a character.
 *
 * It should return true when editing of the buffer is "complete" (e.g. on
 * the press of RETURN).
 */
bool askfor_aux_keypress(char *buf, size_t buflen, size_t *curs, size_t *len,
       struct keypress keypress, bool firsttime)
{
 size_t ulen = utf8_strlen(buf);
 switch (keypress.code)
 {
  case ESCAPE:
  {
   *curs = 0;
   return true;
  }
  case KC_ENTER:
  {
   *curs = ulen;
   return true;
  }
  case ARROW_LEFT:
  {
   if (firsttime) {
    *curs = 0;
   } else if (*curs > 0) {
    (*curs)--;
   }
   break;
  }
  case ARROW_RIGHT:
  {
   if (firsttime) {
    *curs = ulen;
   } else if (*curs < ulen) {
    (*curs)++;
   }
   break;
  }
  case KC_BACKSPACE:
  case KC_DELETE:
  {
   char *ocurs, *oshift;
   /* If this is the first time round, backspace means "delete all" */
   if (firsttime) {
    buf[0] = '\0';
    *curs = 0;
    *len = 0;
    break;
   }
   /* Refuse to backspace into oblivion */
   if ((keypress.code == KC_BACKSPACE && *curs == 0) ||
    (keypress.code == KC_DELETE && *curs >= ulen))
    break;
   /*
			 * Move the string from k to nul along to the left
			 * by 1.  First, have to get offset corresponding to
			 * the cursor position.
			 */
   ocurs = utf8_fskip(buf, *curs, NULL);
   assert(ocurs);
   if (keypress.code == KC_BACKSPACE) {
    /* Get offset of the previous character. */
    oshift = utf8_rskip(ocurs, 1, buf);
    assert(oshift);
    memmove(oshift, ocurs, *len - (ocurs - buf));
    /* Decrement. */
    (*curs)--;
    *len -= ocurs - oshift;
   } else {
    /* Get offset of the next character. */
    oshift = utf8_fskip(buf + *curs, 1, NULL);
    assert(oshift);
    memmove(ocurs, oshift, *len - (oshift - buf));
    /* Decrement */
    *len -= oshift - ocurs;
   }
   /* Terminate */
   buf[*len] = '\0';
   break;
  }
  default:
  {
   bool atnull = (*curs == ulen);
   char encoded[5];
   size_t n_enc = 0;
   char *ocurs;
   if (keycode_isprint(keypress.code)) {
    n_enc = utf32_to_utf8(encoded,
     N_ELEMENTS(encoded), &keypress.code,
     1, NULL);
   }
   if (n_enc == 0) {
    bell();
    break;
   }
   /* Clear the buffer if this is the first time round */
   if (firsttime) {
    buf[0] = '\0';
    *curs = 0;
    *len = 0;
    atnull = 1;
   }
   /* Make sure we have enough room for the new character */
   if (*len + n_enc >= buflen) {
    break;
   }
   /* Insert the encoded character. */
   if (atnull) {
    ocurs = buf + *len;
   } else {
    ocurs = utf8_fskip(buf, *curs, NULL);
    assert(ocurs);
    /*
				 * Move the rest of the buffer along to make
				 * room.
				 */
    memmove(ocurs + n_enc, ocurs,
     *len - (ocurs - buf));
   }
   memcpy(ocurs, encoded, n_enc);
   /* Update position and length. */
   (*curs)++;
   *len += n_enc;
   /* Terminate */
   buf[*len] = '\0';
   break;
  }
 }
 /* By default, we aren't done. */
 return false;
}
/**
 * Handle a mouse event during editing of a string.  This is the default mouse
 * event handler for askfor_aux_ext().
 *
 * \param buf is the buffer with the string to be edited.
 * \param buflen is the maximum number of characters that may be stored in buf.
 * \param curs is the pointer to the position of the cursor in the buffer.
 * \param len is the pointer to position of the first null character in the
 * buffer.
 * \param mouse is a description of the mouse event to handle.
 * \param firsttime is whether or not this is the first call to the keypress or
 * mouse handler in this editing session.
 * \return zero if the editing session should continue, one if the editing
 * session should end and the current contents of the buffer be accepted, or
 * two if the editing session should end and the current contents of the buffer
 * be rejected.
 *
 * askfor_aux_mouse() is very simple.  Any mouse click terminates the editing
 * session, and if that click is with the second button, the result of the
 * editing is rejected.
 */
int askfor_aux_mouse(char *buf, size_t buflen, size_t *curs, size_t *len,
  struct mouseclick mouse, bool firsttime)
{
 return (mouse.button == 2) ? 2 : 1;
}
/**
 * Get some input at the cursor location.
 *
 * The buffer is assumed to have been initialized to a default string.
 * Note that this string is often "empty" (see below).
 *
 * The default buffer is displayed in yellow until cleared, which happens
 * on the first keypress, unless that keypress is Return.
 *
 * Normal chars clear the default and append the char.
 * Backspace clears the default or deletes the final char.
 * Return accepts the current buffer contents and returns true.
 * Escape clears the buffer and the window and returns false.
 *
 * Note that 'len' refers to the size of the buffer.  The maximum length
 * of the input is 'len-1'.
 *
 * 'keypress_h' is a pointer to a function to handle keypresses, altering
 * the input buffer, cursor position and suchlike as required.  See
 * 'askfor_aux_keypress' (the default handler if you supply NULL for
 * 'keypress_h') for an example.
 */
bool askfor_aux(char *buf, size_t len, bool (*keypress_h)(char *, size_t, size_t *, size_t *, struct keypress, bool))
{
 int y, x;
 size_t k = 0; /* Cursor position */
 size_t nul = 0; /* Position of the null byte in the string */
 struct keypress ch = KEYPRESS_NULL;
 bool done = false;
 bool firsttime = true;
 if (keypress_h == NULL)
  keypress_h = askfor_aux_keypress;
 /* Locate the cursor */
 Term_locate(&x, &y);
 /* Paranoia */
 if ((x < 0) || (x >= 80)) x = 0;
 /* Restrict the length */
 if (x + len > 80) len = 80 - x;
 /* Truncate the default entry */
 buf[len-1] = '\0';
 /* Get the position of the null byte */
 nul = strlen(buf);
 /* Display the default answer */
 Term_erase(x, y, (int)len);
 Term_putstr(x, y, -1, COLOUR_YELLOW, buf);
 /* Process input */
 while (!done) {
  /* Place cursor */
  Term_gotoxy(x + k, y);
  /* Get a key */
  ch = inkey();
  /* Let the keypress handler deal with the keypress */
  done = keypress_h(buf, len, &k, &nul, ch, firsttime);
  /* Update the entry */
  Term_erase(x, y, (int)len);
  Term_putstr(x, y, -1, COLOUR_WHITE, buf);
  /* Not the first time round anymore */
  firsttime = false;
 }
 /* Done */
 return (ch.code != ESCAPE);
}
/**
 * Act like askfor_aux() but allow customization of what happens with mouse
 * input.
 *
 * \param buf is the buffer with the string to edit.
 * \param len is the maximum number of characters buf can hold.
 * \param keypress_h is the function to call to handle a keypress.  It may be
 * NULL.  In that case, askfor_aux_keypress() is used.  The function takes
 * six arguments and should return whether or not to end this editing
 * session.  The first argument is the buffer with the string to be edited.  The
 * second argument is the maximum number of characters that can be stored in
 * that buffer.  The third argument is a pointer to the position of the cursor
 * in the buffer.  The fourth argument is a pointer to the position of the
 * first null character in the buffer.  The fifth argument is a description of
 * the keypress to be handled.  The sixth argument is whether or not this is
 * the first call to the keypress handler or mouse handler in this editing
 * session.
 * \param mouse_h is the function to call to handle a mouse click.  It may be
 * NULL.  In that case, askfor_aux_mouse() is used.  The function takes six
 * arguments and should either return zero (this editing should session should
 * continue), one (this editing session should end and the result in the buffer
 * be accepted), or a non-zero value other than one (this editing session should
 * end and the result in the buffer should not be accepted).  The first argument
 * is the buffer with the string to be edited.  The second argument is the
 * maximum number of characters that can be stored in that buffer.  The third
 * argument is a pointer to the position of the cursor in the buffer.  The
 * fourth argument is a pointer to the position of the first null character in
 * the buffer.  The fifth argument is a description of the keypress to be
 * handled.  The sixth argument is whether or not this is the first call to the
 * keypress handler or mouse handler in this editing session.
 */
bool askfor_aux_ext(char *buf, size_t len,
 bool (*keypress_h)(char *, size_t, size_t *, size_t *, struct keypress, bool),
 int (*mouse_h)(char *, size_t, size_t *, size_t *, struct mouseclick, bool))
{
 size_t k = 0; /* Cursor position */
 size_t nul = 0; /* Position of the null byte in the string */
 bool firsttime = true;
 bool done = false;
 bool accepted = true;
 int y, x;
 if (keypress_h == NULL) {
  keypress_h = askfor_aux_keypress;
 }
 if (mouse_h == NULL) {
  mouse_h = askfor_aux_mouse;
 }
 /* Locate the cursor */
 Term_locate(&x, &y);
 /* Paranoia */
 if (x < 0 || x >= 80) x = 0;
 /* Restrict the length */
 if (x + len > 80) len = 80 - x;
 /* Truncate the default entry */
 buf[len-1] = '\0';
 /* Get the position of the null byte */
 nul = strlen(buf);
 /* Display the default answer */
 Term_erase(x, y, (int)len);
 Term_putstr(x, y, -1, COLOUR_YELLOW, buf);
 /* Process input */
 while (!done) {
  ui_event in;
  /* Place cursor */
  Term_gotoxy(x + k, y);
  /*
		 * Get input.  Emulate what inkey() does without the coercing
		 * mouse events to look like keystrokes.
		 */
  while (1) {
   in = inkey_ex();
   if (in.type == EVT_KBRD || in.type == EVT_MOUSE) {
    break;
   }
   if (in.type == EVT_BUTTON) {
    in.type = EVT_KBRD;
    break;
   }
   if (in.type == EVT_ESCAPE) {
    in.type = EVT_KBRD;
    in.key.code = ESCAPE;
    in.key.mods = 0;
    break;
   }
  }
  /* Pass on to the appropriate handler. */
  if (in.type == EVT_KBRD) {
   done = keypress_h(buf, len, &k, &nul, in.key,
    firsttime);
   accepted = (in.key.code != ESCAPE);
  } else if (in.type == EVT_MOUSE) {
   int result = mouse_h(buf, len, &k, &nul, in.mouse,
    firsttime);
   if (result != 0) {
    done = true;
    accepted = (result == 1);
   }
  }
  /* Update the entry */
  Term_erase(x, y, (int)len);
  Term_putstr(x, y, -1, COLOUR_WHITE, buf);
  /* Not the first time round anymore */
  firsttime = false;
 }
 return accepted;
}
/**
 * A "keypress" handling function for askfor_aux, that handles the special
 * case of '*' for a new random "name" and passes any other "keypress"
 * through to the default "editing" handler.
 */
static bool get_name_keypress(char *buf, size_t buflen, size_t *curs,
         size_t *len, struct keypress keypress,
         bool firsttime)
{
 bool result;
 switch (keypress.code)
 {
  case '*':
  {
   *len = player_random_name(buf, buflen);
   *curs = 0;
   result = false;
   break;
  }
  default:
  {
   result = askfor_aux_keypress(buf, buflen, curs, len, keypress,
           firsttime);
   break;
  }
 }
 return result;
}
/**
 * Handle a mouse event during editing of a string:  presents a context menu
 * with options appropriate for handling editing a character's name.
 *
 * \param buf is the buffer with the string to be edited.
 * \param buflen is the maximum number of characters that may be stored in buf.
 * \param curs is the pointer to the position of the cursor in the buffer.
 * \param len is the pointer to position of the first null character in the
 * buffer.
 * \param mouse is a description of the mouse event to handle.
 * \param firsttime is whether or not this is the first call to the keypress or
 * mouse handler in this editing session.
 * \return zero if the editing session should continue, one if the editing
 * session should end and the current contents of the buffer be accepted, or
 * two if the editing session should end and the current contents of the buffer
 * be rejected.
 */
static int handle_name_mouse(char *buf, size_t buflen, size_t *curs,
  size_t *len, struct mouseclick mouse, bool firsttime)
{
 enum { ACT_CTX_NAME_ACCEPT, ACT_CTX_NAME_RANDOM, ACT_CTX_NAME_CLEAR };
 int result = 2;
 char *labels;
 struct menu *m;
 int action;
 /*
	 * A mouse click with the second button ends the editing session and
	 * indicates that the result of editing should be rejected.
	 */
 if (mouse.button == 2) {
  return result;
 }
 /* By default, don't end the editing session. */
 result = 0;
 /* Present a context menu with the possible actions. */
 labels = string_make(lower_case);
 m = menu_dynamic_new();
 m->selections = labels;
 menu_dynamic_add_label(m, "Accept", 'a', ACT_CTX_NAME_ACCEPT, labels);
 menu_dynamic_add_label(m, "Set to random name", 'r',
  ACT_CTX_NAME_RANDOM, labels);
 menu_dynamic_add_label(m, "Clear name", 'c', ACT_CTX_NAME_CLEAR,
  labels);
 screen_save();
 menu_dynamic_calc_location(m, mouse.x, mouse.y);
 region_erase_bordered(&m->boundary);
 action = menu_dynamic_select(m);
 menu_dynamic_free(m);
 string_free(labels);
 screen_load();
 /* Do what was requested. */
 switch (action) {
 case ACT_CTX_NAME_ACCEPT:
  /* End the editing session and accept the result. */
  result = 1;
  break;
 case ACT_CTX_NAME_RANDOM:
  *len = player_random_name(buf, buflen);
  *curs = 0;
  break;
 case ACT_CTX_NAME_CLEAR:
  assert(buflen > 0);
  buf[0] = '\0';
  *len = 0;
  *curs = 0;
  break;
 }
 return result;
}
/**
 * Gets a name for the character, reacting to name changes.
 *
 * If sf is true, we change the savefile name depending on the character name.
 */
bool get_character_name(char *buf, size_t buflen)
{
 bool res;
 /* Paranoia */
 event_signal(EVENT_MESSAGE_FLUSH);
 /* Display prompt */
 prt("Enter a name for your character (* for a random name): ", 0, 0);
 /* Save the player name */
 my_strcpy(buf, player->full_name, buflen);
 /* Ask the user for a string */
 res = askfor_aux_ext(buf, buflen, get_name_keypress, handle_name_mouse);
 /* Clear prompt */
 prt("", 0, 0);
 /* Revert to the old name if the player doesn't pick a new one. */
 if (!res)
  my_strcpy(buf, player->full_name, buflen);
 return res;
}
/**
 * Prompt for a string from the user.
 *
 * The "prompt" should take the form "Prompt: ".
 *
 * See "askfor_aux" for some notes about "buf" and "len", and about
 * the return value of this function.
 */
static bool textui_get_string(const char *prompt, char *buf, size_t len)
{
 bool res;
 /* Paranoia */
 event_signal(EVENT_MESSAGE_FLUSH);
 /* Display prompt */
 prt(prompt, 0, 0);
 /* Ask the user for a string */
 res = askfor_aux(buf, len, NULL);
 /* Clear prompt */
 prt("", 0, 0);
 /* Result */
 return (res);
}
/**
 * Request a "quantity" from the user
 */
static int textui_get_quantity(const char *prompt, int max)
{
 int amt = 1;
 /* Prompt if needed */
 if (max != 1) {
  char tmp[80];
  char buf[80];
  /* Build a prompt if needed */
  if (!prompt) {
   /* Build a prompt */
   strnfmt(tmp, sizeof(tmp), "Quantity (0-%d, *=all): ", max);
   /* Use that prompt */
   prompt = tmp;
  }
  /* Build the default */
  strnfmt(buf, sizeof(buf), "%d", amt);
  /* Ask for a quantity */
  if (!get_string(prompt, buf, 7)) return (0);
  /* Extract a number */
  amt = atoi(buf);
  /* A star or letter means "all" */
  if ((buf[0] == '*') || isalpha((unsigned char)buf[0])) amt = max;
 }
 /* Enforce the maximum */
 if (amt > max) amt = max;
 /* Enforce the minimum */
 if (amt < 0) amt = 0;
 /* Return the result */
 return (amt);
}
/**
 * Verify something with the user
 *
 * The "prompt" should take the form "Query? "
 *
 * Note that "[y/n]" is appended to the prompt.
 */
static bool textui_get_check(const char *prompt)
{
 ui_event ke;
 char buf[80];
 /*
	 * Hack -- Build a "useful" prompt; do this first so prompts built by
	 * format() won't run afoul of event_signal()'s side effects.
	 */
 strnfmt(buf, 78, "%.70s[y/n] ", prompt);
 /* Paranoia */
 event_signal(EVENT_MESSAGE_FLUSH);
 /* Prompt for it */
 prt(buf, 0, 0);
 ke = inkey_m();
 /* Erase the prompt */
 prt("", 0, 0);
 /* Normal negation */
 if (ke.type == EVT_MOUSE) {
  if ((ke.mouse.button != 1) && (ke.mouse.y != 0))
   return (false);
 } else {
  if ((ke.key.code != 'Y') && (ke.key.code != 'y'))
   return (false);
 }
 /* Success */
 return (true);
}
/* TODO: refactor get_check() in terms of get_char() */
/**
 * Ask the user to respond with a character. Options is a constant string,
 * e.g. "yns"; len is the length of the constant string, and fallback should
 * be the default answer if the user hits escape or an invalid key.
 *
 * Example: get_char("Study? ", "yns", 3, 'n')
 *     This prompts "Study? [yns]" and defaults to 'n'.
 *
 */
char get_char(const char *prompt, const char *options, size_t len, char fallback)
{
 struct keypress key;
 char buf[80];
 /* Paranoia */
 event_signal(EVENT_MESSAGE_FLUSH);
 /* Hack -- Build a "useful" prompt */
 strnfmt(buf, 78, "%.70s[%s] ", prompt, options);
 /* Prompt for it */
 prt(buf, 0, 0);
 /* Get an acceptable answer */
 key = inkey();
 /* Lowercase answer if necessary */
 if (key.code >= 'A' && key.code <= 'Z') key.code += 32;
 /* See if key is in our options string */
 if (!strchr(options, (char)key.code))
  key.code = fallback;
 /* Erase the prompt */
 prt("", 0, 0);
 /* Success */
 return key.code;
}
/**
 * Text-native way of getting a filename.
 */
static bool get_file_text(const char *suggested_name, char *path, size_t len)
{
 char buf[160];
 /* Get filename */
 my_strcpy(buf, suggested_name, sizeof buf);
 if (!arg_force_name) {
   if (!get_string("File name: ", buf, sizeof buf)) return false;
   /* Make sure it's actually a filename */
   if (buf[0] == '\0' || buf[0] == ' ') return false;
 } else {
  int old_len;
  time_t ltime;
  struct tm *today;
  /* Get the current time */
  time(&ltime);
  today = localtime(&ltime);
  prt("File name: ", 0,0);
  /* Overwrite the ".txt" that was added */
  assert(strlen(buf) >= 4);
  old_len = strlen(buf) - 4;
  strftime(buf + old_len, sizeof(buf) - len, "-%Y-%m-%d-%H-%M.txt", today);
  /* Prompt the user to confirm or cancel the file dump */
  if (!get_check(format("Confirm writing to %s? ", buf))) return false;
 }
 /* Build the path */
 path_build(path, len, ANGBAND_DIR_USER, buf);
 /* Check if it already exists */
 if (file_exists(path) && !get_check("Replace existing file? "))
  return false;
 /* Tell the user where it's saved to. */
 prt(format("Saving as %s.", path), 0, 0);
 anykey();
 prt("", 0, 0);
 return true;
}
/**
 * Get a pathname to save a file to, given the suggested name.  Returns the
 * result in "path".
 */
bool (*get_file)(const char *suggested_name, char *path, size_t len) = get_file_text;
/**
 * Prompts for a keypress
 *
 * The "prompt" should take the form "Command: "
 * -------
 * Warning - this function assumes that the entered command is an ASCII
 *           character, and so should be used with great caution - NRM
 * -------
 * Returns true unless the character is "Escape"
 */
static bool textui_get_com(const char *prompt, char *command)
{
 ui_event ke;
 bool result;
 result = get_com_ex(prompt, &ke);
 *command = (char)ke.key.code;
 return result;
}
bool get_com_ex(const char *prompt, ui_event *command)
{
 ui_event ke;
 /* Paranoia XXX XXX XXX */
 event_signal(EVENT_MESSAGE_FLUSH);
 /* Display a prompt */
 prt(prompt, 0, 0);
 /* Get a key */
 ke = inkey_m();
 /* Clear the prompt */
 prt("", 0, 0);
 /* Save the command */
 *command = ke;
 /* Done */
 if ((ke.type == EVT_KBRD && ke.key.code != ESCAPE) ||
  (ke.type == EVT_MOUSE))
  return true;
 else
  return false;
}
/**
 * Pause for user response
 *
 * This function is stupid.  XXX XXX XXX
 */
void pause_line(struct term *tm)
{
 prt("", tm->hgt - 1, 0);
 put_str("[Press any key to continue]", tm->hgt - 1, (tm->wid - 27) / 2);
 (void)anykey();
 prt("", tm->hgt - 1, 0);
}
static int dir_transitions[10][10] =
{
 /* 0-> */ { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 },
 /* 1-> */ { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
 /* 2-> */ { 0, 0, 2, 0, 1, 0, 3, 0, 5, 0 },
 /* 3-> */ { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
 /* 4-> */ { 0, 0, 1, 0, 4, 0, 5, 0, 7, 0 },
 /* 5-> */ { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
 /* 6-> */ { 0, 0, 3, 0, 5, 0, 6, 0, 9, 0 },
 /* 7-> */ { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
 /* 8-> */ { 0, 0, 5, 0, 7, 0, 9, 0, 8, 0 },
 /* 9-> */ { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
};
/**
 * Request a "movement" direction (1,2,3,4,6,7,8,9) from the user.
 *
 * Return true if a direction was chosen, otherwise return false.
 *
 * This function should be used for all "repeatable" commands, such as
 * run, walk, open, close, bash, disarm, spike, tunnel, etc, as well
 * as all commands which must reference a grid adjacent to the player,
 * and which may not reference the grid under the player.
 *
 * Directions "5" and "0" are illegal and will not be accepted.
 *
 * This function tracks and uses the "global direction", and uses
 * that as the "desired direction", if it is set.
 */
static bool textui_get_rep_dir(int *dp, bool allow_5)
{
 int dir = 0;
 ui_event ke;
 /* Initialize */
 (*dp) = 0;
 /* Get a direction */
 while (!dir) {
  /* Paranoia*/
  event_signal(EVENT_MESSAGE_FLUSH);
  /* Get first keypress - the first test is to avoid displaying the
		 * prompt for direction if there's already a keypress queued up
		 * and waiting - this just avoids a flickering prompt if there is
		 * a "lazy" movement delay. */
  inkey_scan = SCAN_INSTANT;
  ke = inkey_ex();
  inkey_scan = SCAN_OFF;
  if (ke.type == EVT_NONE ||
    (ke.type == EVT_KBRD
    && !target_dir_allow(ke.key, allow_5))) {
   prt("Direction or <click> (Escape to cancel)? ", 0, 0);
   ke = inkey_ex();
  }
  /* Check mouse coordinates, or get keypresses until a dir is chosen */
  if (ke.type == EVT_MOUSE) {
   if (ke.mouse.button == 1) {
    int y = KEY_GRID_Y(ke);
    int x = KEY_GRID_X(ke);
    struct loc from = player->grid;
    struct loc to = loc(x, y);
    dir = pathfind_direction_to(from, to);
   } else if (ke.mouse.button == 2) {
    /* Clear the prompt */
    prt("", 0, 0);
    return (false);
   }
  } else if (ke.type == EVT_KBRD) {
   int keypresses_handled = 0;
   while (ke.type == EVT_KBRD && ke.key.code != 0) {
    int this_dir;
    if (ke.key.code == ESCAPE) {
     /* Clear the prompt */
     prt("", 0, 0);
     return (false);
    }
    /* XXX Ideally show and move the cursor here to indicate
				 the currently "Pending" direction. XXX */
    this_dir = target_dir_allow(ke.key, allow_5);
    if (this_dir)
     dir = dir_transitions[dir][this_dir];
    if (player->opts.lazymove_delay == 0 || ++keypresses_handled > 1)
     break;
    inkey_scan = player->opts.lazymove_delay;
    ke = inkey_ex();
   }
   /* 5 is equivalent to "escape" */
   if (dir == 5 && !allow_5) {
    /* Clear the prompt */
    prt("", 0, 0);
    return (false);
   }
  }
  /* Oops */
  if (!dir) bell();
 }
 /* Clear the prompt */
 prt("", 0, 0);
 /* Save direction */
 (*dp) = dir;
 /* Success */
 return (true);
}
/**
 * Get an "aiming direction" (1,2,3,4,6,7,8,9 or 5) from the user.
 *
 * Return true if a direction was chosen, otherwise return false.
 *
 * The direction "5" is special, and means "use current target".
 *
 * This function tracks and uses the "global direction", and uses
 * that as the "desired direction", if it is set.
 *
 * Note that "Force Target", if set, will pre-empt user interaction,
 * if there is a usable target already set.
 */
static bool textui_get_aim_dir(int *dp, int range)
{
 /* Global direction */
 int dir = 0;
 ui_event ke;
 const char *p;
 /* Initialize */
 (*dp) = 0;
 /* Ask until satisfied */
 while (!dir) {
  /*
		 * Whether to generate an audible warning about a targeting
		 * failure.
		 */
  bool need_beep = false;
  /* Choose a prompt */
  if (!target_okay(range))
   p = "Direction ('*' or <click> to target, \"'\" for closest, Escape to cancel)? ";
  else
   p = "Direction ('5' for target, '*' or <click> to re-target, Escape to cancel)? ";
  /* Get a command (or Cancel) */
  if (!get_com_ex(p, &ke)) break;
  if (ke.type == EVT_MOUSE) {
   if (ke.mouse.button == 1) {
    if (target_set_interactive(TARGET_KILL,
             loc(KEY_GRID_X(ke), KEY_GRID_Y(ke)),
             range))
     dir = DIR_TARGET;
   } else if (ke.mouse.button == 2) {
    break;
   }
  } else if (ke.type == EVT_KBRD) {
   if (ke.key.code == '*') {
    /* Set new target, use target if legal */
    if (target_set_interactive(TARGET_KILL, loc(-1, -1), range))
     dir = DIR_TARGET;
   } else if (ke.key.code == '\'') {
    /* Set to closest target */
    if (target_set_closest(TARGET_KILL, NULL)) {
     dir = DIR_TARGET;
    } else {
     need_beep = true;
    }
   } else if (ke.key.code == 't' || ke.key.code == '5' ||
        ke.key.code == '0' || ke.key.code == '.') {
    if (target_okay(range)) {
     dir = DIR_TARGET;
    } else {
     need_beep = true;
    }
   } else if (ke.key.code == '>') {
    /* Rarely we need to aim at the floor */
    dir = DIR_DOWN;
   } else if (ke.key.code == '<') {
    /* Rarely we need to aim at the ceiling */
    dir = DIR_UP;
   } else {
    /* Possible direction */
    int keypresses_handled = 0;
    while (ke.key.code != 0){
     int this_dir;
     /* XXX Ideally show and move the cursor here to indicate
					 * the currently "Pending" direction. XXX */
     this_dir = target_dir(ke.key);
     if (this_dir) {
      dir = dir_transitions[dir][this_dir];
     } else {
      need_beep = true;
      break;
     }
     if (player->opts.lazymove_delay == 0 || ++keypresses_handled > 1)
      break;
     /* See if there's a second keypress within the defined
					 * period of time. */
     inkey_scan = player->opts.lazymove_delay;
     ke = inkey_ex();
    }
   }
  }
  /* Error */
  if (need_beep) bell();
 }
 /* No direction */
 if (!dir) return (false);
 /* Save direction */
 (*dp) = dir;
 /* A "valid" direction was entered */
 return (true);
}
/**
 * Initialise the UI hooks to give input asked for by the game
 */
void textui_input_init(void)
{
 get_string_hook = textui_get_string;
 get_quantity_hook = textui_get_quantity;
 get_check_hook = textui_get_check;
 get_com_hook = textui_get_com;
 get_rep_dir_hook = textui_get_rep_dir;
 get_aim_dir_hook = textui_get_aim_dir;
 get_effect_from_list_hook = textui_get_effect_from_list;
 get_item_hook = textui_get_item;
 get_panel_hook = textui_get_panel;
 panel_contains_hook = textui_panel_contains;
 map_is_visible_hook = textui_map_is_visible;
 smith_object_hook = textui_smith_object;
 change_song_hook = textui_change_song;
}
/*** Input processing ***/
/**
 * Get a command count, with the '0' key.
 */
static int textui_get_count(void)
{
 int count = 0;
 while (1) {
  struct keypress ke;
  prt(format("Repeat: %d", count), 0, 0);
  ke = inkey();
  if (ke.code == ESCAPE)
   return -1;
  /* Simple editing (delete or backspace) */
  else if (ke.code == KC_DELETE || ke.code == KC_BACKSPACE)
   count = count / 10;
  /* Actual numeric data */
  else if (isdigit((unsigned char) ke.code)) {
   count = count * 10 + D2I(ke.code);
   if (count >= 9999) {
    bell();
    count = 9999;
   }
  } else {
   /* Anything non-numeric passes straight to command input */
   /* XXX nasty hardcoding of action menu key */
   if (ke.code != KC_ENTER)
    Term_keypress(ke.code, ke.mods);
   break;
  }
 }
 return count;
}
/**
 * Hack -- special buffer to hold the action of the current keymap
 */
static struct keypress request_command_buffer[256];
/**
 * Request a command from the user.
 *
 * Note that "caret" ("^") is treated specially, and is used to
 * allow manual input of control characters.  This can be used
 * on many machines to request repeated tunneling (Ctrl-H) and
 * on the Macintosh to request "Control-Caret".
 *
 * Note that "backslash" is treated specially, and is used to bypass any
 * keymap entry for the following character.  This is useful for macros.
 */
ui_event textui_get_command(int *count)
{
 int mode = OPT(player, angband_keyset) ? KEYMAP_MODE_ANGBAND : KEYMAP_MODE_ORIG;
 struct keypress tmp[2] = { KEYPRESS_NULL, KEYPRESS_NULL };
 ui_event ke = EVENT_EMPTY;
 const struct keypress *act = NULL;
 if (OPT(player, hjkl_movement)) {
  mode |= KEYMAP_MODE_ROGUE;
 }
 /* Get command */
 while (1) {
  /* Hack -- no flush needed */
  msg_flag = false;
  /* Activate "command mode" */
  inkey_flag = true;
  /* Toggle on cursor if requested */
  if (OPT(player, highlight_player)) {
   Term_set_cursor(true);
   move_cursor_relative(player->grid.y, player->grid.x);
  }
  /* Get a command */
  ke = inkey_ex();
  /* Toggle off cursor */
  if (OPT(player, highlight_player)) {
   Term_set_cursor(false);
  }
  if (ke.type == EVT_KBRD) {
   bool keymap_ok = true;
   switch (ke.key.code) {
    case '0': {
     if (ke.key.mods & KC_MOD_KEYPAD) break;
     if (!(mode & KEYMAP_MODE_ANGBAND)) break;
     int c = textui_get_count();
     if (c == -1 || !get_com_ex("Command: ", &ke))
      continue;
     else
      *count = c;
     break;
    }
    case 'R': {
     if (mode & KEYMAP_MODE_ANGBAND) break;
     int c = textui_get_count();
     if (c == -1 || !get_com_ex("Command: ", &ke))
      continue;
     else
      *count = c;
     break;
    }
    case '\\': {
     /* Allow keymaps to be bypassed */
     (void)get_com_ex("Command: ", &ke);
     keymap_ok = false;
     break;
    }
    case '^': {
     /* Allow "control chars" to be entered */
     if (!get_com_ex("Control: ", &ke)
       || ke.type != EVT_KBRD) {
      continue;
     }
     if (ENCODE_KTRL(ke.key.code)) {
      ke.key.code = KTRL(ke.key.code);
     } else {
      ke.key.mods |= KC_MOD_CONTROL;
     }
     break;
    }
   }
   /* Find any relevant keymap */
   if (keymap_ok)
    act = keymap_find(mode, ke.key);
  }
  /* Erase the message line */
  prt("", 0, 0);
  if (ke.type == EVT_BUTTON) {
   /* Buttons are always specified in standard keyset */
   act = tmp;
   tmp[0] = ke.key;
  }
  /* Apply keymap if not inside a keymap already */
  if (ke.key.code && act && !inkey_next) {
   size_t n = 0;
   while (act[n].type)
    n++;
   /* Make room for the terminator */
   n += 1;
   /* Install the keymap */
   memcpy(request_command_buffer, act, n * sizeof(struct keypress));
   /* Start using the buffer */
   inkey_next = request_command_buffer;
   /* Continue */
   continue;
  }
  /* Done */
  break;
 }
 return ke;
}
/**
 * Check no currently worn items are stopping the action 'c'
 */
bool key_confirm_command(unsigned char c)
{
 int i;
 /* Hack -- Scan equipment */
 for (i = 0; i < player->body.count; i++) {
  char verify_inscrip[] = "^*";
  unsigned n;
  struct object *obj = slot_object(player, i);
  if (!obj) continue;
  /* Set up string to look for, e.g. "^d" */
  verify_inscrip[1] = c;
  /* Verify command */
  n = check_for_inscrip(obj, "^*") +
    check_for_inscrip(obj, verify_inscrip);
  while (n--) {
   if (!get_check("Are you sure? "))
    return false;
  }
 }
 return true;
}
/**
 * Process a textui keypress.
 */
bool textui_process_key(struct keypress kp, unsigned char *c, int count)
{
 keycode_t key = kp.code;
 /* Null command */
 if (key == '\0' || key == ESCAPE || key == ' ' || key == '\a')
  return true;
 /* Invalid keypress */
 if (key > UCHAR_MAX)
  return false;
 *c = key;
 return true;
}
/**
 * \file ui-keymap.c
 * \brief Keymap handling
 *
 * Copyright (c) 2011 Andi Sidwell
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Keymap implementation.
 *
 * Keymaps are defined in pref files and map onto the internal game keyset,
 * which is roughly what you get if you have roguelike keys turned off.
 *
 * We store keymaps by pairing triggers with actions; the trigger is a single
 * keypress and the action is stored as a string of keypresses, terminated
 * with a keypress with type == EVT_NONE.
 *
 * XXX We should note when we read in keymaps that are "official game" keymaps
 * and ones which are user-defined.  Then we can avoid writing out official
 * game ones and messing up everyone's pref files with a load of junk.
 */
/**
 * Struct for a keymap.
 */
struct keymap {
 struct keypress key;
 struct keypress *actions;
 bool user; /* User-defined keymap */
 struct keymap *next;
};
/**
 * List of keymaps.
 */
static struct keymap *keymaps[KEYMAP_MODE_MAX];
/**
 * Find a keymap, given a keypress.
 */
const struct keypress *keymap_find(int keymap, struct keypress kc)
{
 struct keymap *k;
 assert(keymap >= 0 && keymap < KEYMAP_MODE_MAX);
 for (k = keymaps[keymap]; k; k = k->next) {
  if (k->key.code == kc.code && k->key.mods == kc.mods)
   return k->actions;
 }
 return NULL;
}
/**
 * Duplicate a given keypress string and return the duplicate.
 */
static struct keypress *keymap_make(const struct keypress *actions)
{
 struct keypress *new;
 size_t n = 0;
 while (actions[n].type) {
  n++;
 }
 /* Make room for the terminator */
 n += 1;
 new = mem_zalloc(sizeof *new * n);
 memcpy(new, actions, sizeof *new * n);
 new[n - 1].type = EVT_NONE;
 return new;
}
/**
 * Add a keymap to the mappings table.
 */
void keymap_add(int keymap, struct keypress trigger, struct keypress *actions, bool user)
{
 struct keymap *k = mem_zalloc(sizeof *k);
 assert(keymap >= 0 && keymap < KEYMAP_MODE_MAX);
 keymap_remove(keymap, trigger);
 k->key = trigger;
 k->actions = keymap_make(actions);
 k->user = user;
 k->next = keymaps[keymap];
 keymaps[keymap] = k;
 return;
}
/**
 * Remove a keymap.  Return true if one was removed.
 */
bool keymap_remove(int keymap, struct keypress trigger)
{
 struct keymap *k;
 struct keymap *prev = NULL;
 assert(keymap >= 0 && keymap < KEYMAP_MODE_MAX);
 for (k = keymaps[keymap]; k; k = k->next) {
  if (k->key.code == trigger.code && k->key.mods == trigger.mods) {
   mem_free(k->actions);
   if (prev)
    prev->next = k->next;
   else
    keymaps[keymap] = k->next;
   mem_free(k);
   return true;
  }
  prev = k;
 }
 return false;
}
/**
 * Forget and free all keymaps.
 */
void keymap_free(void)
{
 size_t i;
 struct keymap *k;
 for (i = 0; i < N_ELEMENTS(keymaps); i++) {
  k = keymaps[i];
  while (k) {
   struct keymap *next = k->next;
   mem_free(k->actions);
   mem_free(k);
   k = next;
  }
 }
}
/**
 * Append active keymaps to a given file.
 */
void keymap_dump(ang_file *fff)
{
 int mode;
 struct keymap *k;
 if (OPT(player, angband_keyset)) {
  mode = KEYMAP_MODE_ANGBAND;
 } else {
  mode = KEYMAP_MODE_ORIG;
 }
 if (OPT(player, hjkl_movement)) {
  mode |= KEYMAP_MODE_ROGUE;
 }
 for (k = keymaps[mode]; k; k = k->next) {
  char buf[1024];
  struct keypress key[2] = { KEYPRESS_NULL, KEYPRESS_NULL };
  if (!k->user) continue;
  /* Encode the action */
  keypress_to_text(buf, sizeof(buf), k->actions, false);
  file_putf(fff, "keymap-act:%s\n", buf);
  /* Convert the key into a string */
  key[0] = k->key;
  keypress_to_text(buf, sizeof(buf), key, true);
  file_putf(fff, "keymap-input:%d:%s\n", mode, buf);
  file_putf(fff, "\n");
 }
}
/**
 * \file ui-knowledge.c
 * \brief Player knowledge functions
 *
 * Copyright (c) 2000-2007 Eytan Zweig, Andrew Doull, Pete Mack.
 * Copyright (c) 2010 Peter Denison, Chris Carr.
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * The first part of this file contains the knowledge menus.  Generic display
 * routines are followed  by sections which implement "subclasses" of the
 * abstract classes represented by member_funcs and group_funcs.
 *
 * After the knowledge menus are various knowledge functions - message review;
 * inventory, equipment, monster and object lists; symbol lookup; and the 
 * "locate" command which scrolls the screen around the current dungeon level.
 */
typedef struct {
 /* Name of this group */
 const char *(*name)(int gid);
 /* Compares gids of two oids */
 int (*gcomp)(const void *, const void *);
 /* Returns gid for an oid */
 int (*group)(int oid);
 /* Summary function for the "object" information. */
 void (*summary)(int gid, const int *item_list, int n, int top, int row,
     int col);
 /* Maximum possible item count for this class */
 int maxnum;
 /* Items don't need to be IDed to recognize membership */
 bool easy_know;
} group_funcs;
typedef struct {
 /* Displays an entry at given location, including kill-count and graphics */
 void (*display_member)(int col, int row, bool cursor, int oid);
 /* Displays lore for an oid */
 void (*lore)(int oid);
 /* Required only for objects with modifiable display attributes
	 * Unknown 'flavors' return flavor attributes */
 /* Get character attr for OID (by address) */
 wchar_t *(*xchar)(int oid);
 /* Get color attr for OID (by address) */
 uint8_t *(*xattr)(int oid);
 /* Returns optional extra prompt */
 const char *(*xtra_prompt)(int oid);
 /* Handles optional extra actions */
 void (*xtra_act)(struct keypress ch, int oid);
 /* Does this kind have visual editing? */
 bool is_visual;
} member_funcs;
/**
 * Helper class for generating joins
 */
typedef struct join {
  int oid;
  int gid;
} join_t;
static struct parser *init_ui_knowledge_parser(void);
static errr run_ui_knowledge_parser(struct parser *p);
static errr finish_ui_knowledge_parser(struct parser *p);
static void cleanup_ui_knowledge_parsed_data(void);
struct file_parser ui_knowledge_parser = {
 "ui_knowledge",
 init_ui_knowledge_parser,
 run_ui_knowledge_parser,
 finish_ui_knowledge_parser,
 cleanup_ui_knowledge_parsed_data
};
/**
 * A default group-by
 */
static join_t *default_join;
/**
 * Clipboard variables for copy & paste in visual mode
 */
static uint8_t attr_idx = 0;
static wchar_t char_idx = 0;
/**
 * ------------------------------------------------------------------------
 * Knowledge menu utilities
 * ------------------------------------------------------------------------ */
static int default_item_id(int oid)
{
 return default_join[oid].oid;
}
static int default_group_id(int oid)
{
 return default_join[oid].gid;
}
/**
 * Return a specific ordering for the features
 */
static int feat_order(int feat)
{
 if (tf_has(f_info[feat].flags, TF_FLOOR)) return 0;
 if (tf_has(f_info[feat].flags, TF_STAIR)) return 2;
 if (tf_has(f_info[feat].flags, TF_SHAFT)) return 2;
 if (tf_has(f_info[feat].flags, TF_DOOR_ANY)) return 1;
 if (tf_has(f_info[feat].flags, TF_PIT)) return 6;
 if (tf_has(f_info[feat].flags, TF_CHASM)) return 4;
 if (tf_has(f_info[feat].flags, TF_FORGE)) return 5;
 /* This also has WALL set so check them first before checking WALL. */
 if (tf_has(f_info[feat].flags, TF_QUARTZ)) return 4;
 /* These also have ROCK set so check them first before checking ROCK. */
 if (tf_has(f_info[feat].flags, TF_WALL)) return 3;
 if (tf_has(f_info[feat].flags, TF_ROCK)) return 4;
 return 7;
}
/**
 * Return the actual width of a symbol
 */
static int actual_width(int width)
{
 return width * tile_width;
}
/**
 * Return the actual height of a symbol
 */
static int actual_height(int height)
{
 return height * tile_height;
}
/**
 * From an actual width, return the logical width
 */
static int logical_width(int width)
{
 return width / tile_width;
}
/**
 * From an actual height, return the logical height
 */
static int logical_height(int height)
{
 return height / tile_height;
}
/**
 * Display tiles.
 */
static void display_tiles(int col, int row, int height, int width,
  uint8_t attr_top, wchar_t char_left)
{
 int i, j;
 /* Clear the display lines */
 for (i = 0; i < height; i++)
   Term_erase(col, row + i, width);
 width = logical_width(width);
 height = logical_height(height);
 /* Display lines until done */
 for (i = 0; i < height; i++) {
  /* Display columns until done */
  for (j = 0; j < width; j++) {
   uint8_t a;
   wchar_t c;
   int x = col + actual_width(j);
   int y = row + actual_height(i);
   int ia, ic;
   ia = attr_top + i;
   ic = char_left + j;
   a = (uint8_t)ia;
   c = (wchar_t)ic;
   /* Display symbol */
   big_pad(x, y, a, c);
  }
 }
}
/**
 * Place the cursor at the correct position for tile picking
 */
static void place_tile_cursor(int col, int row, uint8_t a, wchar_t c,
  uint8_t attr_top, wchar_t char_left)
{
 int i = a - attr_top;
 int j = c - char_left;
 int x = col + actual_width(j);
 int y = row + actual_height(i);
 /* Place the cursor */
 Term_gotoxy(x, y);
}
/**
 * Remove the tile display and clear the screen 
 */
static void remove_tiles(int col, int row, bool *picker_ptr, int width,
       int height)
{
 int i;
 /* No more big cursor */
 bigcurs = false;
 /* Cancel visual list */
 *picker_ptr = false;
 /* Clear the display lines */
 for (i = 0; i < height; i++)
  Term_erase(col, row + i, width);
}
/**
 *  Do tile picker command -- Change tiles
 */
static bool tile_picker_command(ui_event ke, bool *tile_picker_ptr,
  int height, int width, uint8_t *attr_top_ptr,
  wchar_t *char_left_ptr, uint8_t *cur_attr_ptr,
  wchar_t *cur_char_ptr, int col, int row, int *delay)
{
 static uint8_t attr_old = 0;
 static wchar_t char_old = 0;
 /* These are the distance we want to maintain between the
	 * cursor and borders. */
 int frame_left = logical_width(10);
 int frame_right = logical_width(10);
 int frame_top = logical_height(4);
 int frame_bottom = logical_height(4);
 /* Get mouse movement */
 if (*tile_picker_ptr && (ke.type == EVT_MOUSE)) {
  int eff_width = actual_width(width);
  int eff_height = actual_height(height);
  uint8_t a = *cur_attr_ptr;
  wchar_t c = *cur_char_ptr;
  int my = logical_height(ke.mouse.y - row);
  int mx = logical_width(ke.mouse.x - col);
  if ((my >= 0) && (my < eff_height) && (mx >= 0) && (mx < eff_width)
   && ((ke.mouse.button == 1) || (a != *attr_top_ptr + my)
    || (c != *char_left_ptr + mx))) {
   /* Set the visual */
   *cur_attr_ptr = a = *attr_top_ptr + my;
   *cur_char_ptr = c = *char_left_ptr + mx;
   /* Move the frame */
   if (*char_left_ptr > MAX(0, (int)c - frame_left))
    (*char_left_ptr)--;
   if (*char_left_ptr + eff_width <= MIN(255, (int)c + frame_right))
    (*char_left_ptr)++;
   if (*attr_top_ptr > MAX(0, (int)a - frame_top))
    (*attr_top_ptr)--;
   if (*attr_top_ptr + eff_height <= MIN(255, (int)a + frame_bottom))
    (*attr_top_ptr)++;
   /* Delay */
   *delay = 100;
   /* Accept change */
   if (ke.mouse.button)
     remove_tiles(col, row, tile_picker_ptr, width, height);
   return true;
  } else if (ke.mouse.button == 2) {
   /* Cancel change */
   *cur_attr_ptr = attr_old;
   *cur_char_ptr = char_old;
   remove_tiles(col, row, tile_picker_ptr, width, height);
   return true;
  } else {
   return false;
  }
 }
 if (ke.type != EVT_KBRD)
  return false;
 switch (ke.key.code)
 {
  case ESCAPE:
  {
   if (*tile_picker_ptr) {
    /* Cancel change */
    *cur_attr_ptr = attr_old;
    *cur_char_ptr = char_old;
    remove_tiles(col, row, tile_picker_ptr, width, height);
    return true;
   }
   break;
  }
  case KC_ENTER:
  {
   if (*tile_picker_ptr) {
    /* Accept change */
    remove_tiles(col, row, tile_picker_ptr, width, height);
    return true;
   }
   break;
  }
  case 'V':
  case 'v':
  {
   /* No visual mode without graphics, for now - NRM */
   if (current_graphics_mode != NULL)
    if (current_graphics_mode->grafID == 0)
     break;
   if (!*tile_picker_ptr) {
    *tile_picker_ptr = true;
    bigcurs = true;
    *attr_top_ptr = (uint8_t)MAX(0, (int)*cur_attr_ptr - frame_top);
    *char_left_ptr = (wchar_t)MAX(0, (int)*cur_char_ptr - frame_left);
    attr_old = *cur_attr_ptr;
    char_old = *cur_char_ptr;
   } else {
    /* Cancel change */
    *cur_attr_ptr = attr_old;
    *cur_char_ptr = char_old;
    remove_tiles(col, row, tile_picker_ptr, width, height);
   }
   return true;
  }
  case 'C':
  case 'c':
  {
   /* Set the tile */
   attr_idx = *cur_attr_ptr;
   char_idx = *cur_char_ptr;
   return true;
  }
  case 'P':
  case 'p':
  {
   if (attr_idx) {
    /* Set the char */
    *cur_attr_ptr = attr_idx;
    *attr_top_ptr = (uint8_t)MAX(0, (int)*cur_attr_ptr - frame_top);
   }
   if (char_idx) {
    /* Set the char */
    *cur_char_ptr = char_idx;
    *char_left_ptr = (wchar_t)MAX(0, (int)*cur_char_ptr - frame_left);
   }
   return true;
  }
  default:
  {
   int d = target_dir(ke.key);
   uint8_t a = *cur_attr_ptr;
   wchar_t c = *cur_char_ptr;
   if (!*tile_picker_ptr)
    break;
   bigcurs = true;
   /* Restrict direction */
   if ((a == 0) && (ddy[d] < 0)) d = 0;
   if ((c == 0) && (ddx[d] < 0)) d = 0;
   if ((a == 255) && (ddy[d] > 0)) d = 0;
   if ((c == 255) && (ddx[d] > 0)) d = 0;
   a += ddy[d];
   c += ddx[d];
   /* Set the tile */
   *cur_attr_ptr = a;
   *cur_char_ptr = c;
   /* Move the frame */
   if (ddx[d] < 0 &&
     *char_left_ptr > MAX(0, (int)c - frame_left))
    (*char_left_ptr)--;
   if ((ddx[d] > 0) &&
     *char_left_ptr + (width / tile_width) <=
       MIN(255, (int)c + frame_right))
   (*char_left_ptr)++;
   if (ddy[d] < 0 &&
     *attr_top_ptr > MAX(0, (int)a - frame_top))
    (*attr_top_ptr)--;
   if (ddy[d] > 0 &&
     *attr_top_ptr + (height / tile_height) <=
       MIN(255, (int)a + frame_bottom))
    (*attr_top_ptr)++;
   /* We need to always eat the input even if it is clipped,
			 * otherwise it will be interpreted as a change object
			 * selection command with messy results.
			 */
   return true;
  }
 }
 /* Tile picker command is not used */
 return false;
}
/**
 * Display glyph and colours
 */
static void display_glyphs(int col, int row, int height, int width, uint8_t a,
      wchar_t c)
{
 int i;
 int x, y;
 /* Clear the display lines */
 for (i = 0; i < height; i++)
         Term_erase(col, row + i, width);
 /* Prompt */
 prt("Choose colour:", row + height/2, col);
 Term_locate(&x, &y);
 for (i = 0; i < MAX_COLORS; i++) big_pad(x + i, y, i, c);
 /* Place the cursor */
 Term_gotoxy(x + a, y);
}
/**
 * Do glyph picker command -- Change glyphs
 */
static bool glyph_command(ui_event ke, bool *glyph_picker_ptr,
     int height, int width, uint8_t *cur_attr_ptr,
     wchar_t *cur_char_ptr, int col, int row)
{
 static uint8_t attr_old = 0;
 static wchar_t char_old = 0;
 /* Get mouse movement */
 if (*glyph_picker_ptr && (ke.type == EVT_MOUSE)) {
  int mx = logical_width(ke.mouse.x - col);
  if (ke.mouse.y != row + height / 2) return false;
  if ((mx >= 0) && (mx < MAX_COLORS) && (ke.mouse.button == 1)) {
   /* Set the visual */
   *cur_attr_ptr = mx - 14;
   /* Accept change */
   remove_tiles(col, row, glyph_picker_ptr, width, height);
   return true;
  } else {
          return false;
  }
 }
 if (ke.type != EVT_KBRD)
         return false;
 switch (ke.key.code)
 {
         case ESCAPE:
  {
   if (*glyph_picker_ptr) {
    /* Cancel change */
    *cur_attr_ptr = attr_old;
    *cur_char_ptr = char_old;
    remove_tiles(col, row, glyph_picker_ptr, width, height);
    return true;
   }
   break;
  }
     case KC_ENTER:
     {
      if (*glyph_picker_ptr) {
       /* Accept change */
       remove_tiles(col, row, glyph_picker_ptr, width, height);
       return true;
      }
      break;
     }
     case 'V':
     case 'v':
     {
      if (!*glyph_picker_ptr) {
       *glyph_picker_ptr = true;
       attr_old = *cur_attr_ptr;
       char_old = *cur_char_ptr;
      } else {
       /* Cancel change */
       *cur_attr_ptr = attr_old;
       *cur_char_ptr = char_old;
       remove_tiles(col, row, glyph_picker_ptr, width, height);
      }
      return true;
     }
  case 'C':
  case 'c':
  {
   /* Set the tile */
   attr_idx = *cur_attr_ptr;
   char_idx = *cur_char_ptr;
   return true;
  }
  case 'P':
  case 'p':
  {
   if (attr_idx) {
    /* Set the char */
    *cur_attr_ptr = attr_idx;
   }
   if (char_idx) {
    /* Set the char */
    *cur_char_ptr = char_idx;
   }
   return true;
  }
     case 'i':
     case 'I':
     {
      if (*glyph_picker_ptr) {
       char code_point[6];
       bool res = false;
       /* Ask the user for a code point */
       Term_gotoxy(col, row + height/2 + 2);
       res = get_string("(up to 5 hex digits):", code_point, 5);
       /* Process input */
       if (res) {
        unsigned long int point = strtoul(code_point,
               (char **)NULL, 16);
        *cur_char_ptr = (wchar_t) point;
        return true;
       }
      }
      break;
     }
     default:
     {
      int d = target_dir(ke.key);
      uint8_t a = *cur_attr_ptr;
      if (!*glyph_picker_ptr)
    break;
      /* Horizontal only */
      if (ddy[d] != 0) break;
      /* Horizontal movement */
      if (ddx[d] != 0) {
    a += ddx[d] + BASIC_COLORS;
    a = a % BASIC_COLORS;
    *cur_attr_ptr = a;
      }
      /* We need to always eat the input even if it is clipped,
		     * otherwise it will be interpreted as a change object
		     * selection command with messy results.
		     */
      return true;
     }
 }
 /* Glyph picker command is not used */
 return false;
}
static void display_group_member(struct menu *menu, int oid,
      bool cursor, int row, int col, int wid)
{
 const member_funcs *o_funcs = menu->menu_data;
 uint8_t attr = curs_attrs[CURS_KNOWN][cursor == oid];
 (void)wid;
 /* Print the interesting part */
 o_funcs->display_member(col, row, cursor, oid);
 /* Do visual mode */
 if (o_funcs->is_visual && o_funcs->xattr) {
  wchar_t c = *o_funcs->xchar(oid);
  uint8_t a = *o_funcs->xattr(oid);
  char buf[12];
  strnfmt(buf, sizeof(buf), "%d/%d", a, c);
  c_put_str(attr, buf, row, 64 - (int) strlen(buf));
 }
}
static const char *recall_prompt(int oid)
{
 (void)oid;
 return ", 'r' to recall";
}
/* Flag value for missing array entry */
/**
 * Interactive group by.
 * Recognises inscriptions, graphical symbols, lore
 */
static void display_knowledge(const char *title, int *obj_list, int o_count,
    group_funcs g_funcs, member_funcs o_funcs,
    const char *otherfields)
{
 /* Maximum number of groups to display */
 int max_group = g_funcs.maxnum < o_count ? g_funcs.maxnum : o_count ;
 /* This could (should?) be (void **) */
 int *g_list, *g_offset;
 const char **g_names;
 int g_name_len = 8; /* group name length, minumum is 8 */
 int grp_cnt = 0; /* total number groups */
 int g_cur = 0, grp_old = -1; /* group list positions */
 int o_cur = 0; /* object list positions */
 int g_o_count = 0; /* object count for group */
 int oid; /* object identifiers */
 region title_area = { 0, 0, 0, 4 };
 region group_region = { 0, 6, -17, -2 };
 region object_region = { -17, 6, 0, -2 };
 /* display state variables */
 bool tiles = (current_graphics_mode != NULL);
 bool tile_picker = false;
 bool glyph_picker = false;
 uint8_t attr_top = 0;
 wchar_t char_left = 0;
 int delay = 0;
 struct menu group_menu;
 struct menu object_menu;
 menu_iter object_iter = { NULL, NULL, display_group_member, NULL, NULL };
 /* Panel state */
 /* These are swapped in parallel whenever the actively browsing " */
 /* changes */
 int *active_cursor = &g_cur, *inactive_cursor = &o_cur;
 struct menu *active_menu = &group_menu, *inactive_menu = &object_menu;
 int panel = 0;
 void *swapspace;
 bool do_swap = false;
 bool flag = false;
 bool redraw = true;
 int browser_rows;
 int wid, hgt;
 int i;
 int prev_g = -1;
 ui_event ke;
 /* Get size */
 Term_get_size(&wid, &hgt);
 browser_rows = hgt - 8;
 /* Determine if using tiles or not */
 if (tiles) tiles = (current_graphics_mode->grafID != 0);
 if (g_funcs.gcomp)
  sort(obj_list, o_count, sizeof(*obj_list), g_funcs.gcomp);
 /* Sort everything into group order */
 g_list = mem_zalloc((max_group + 1) * sizeof(int));
 g_offset = mem_zalloc((max_group + 1) * sizeof(int));
 for (i = 0; i < o_count; i++) {
  if (prev_g != g_funcs.group(obj_list[i])) {
   prev_g = g_funcs.group(obj_list[i]);
   g_offset[grp_cnt] = i;
   g_list[grp_cnt++] = prev_g;
  }
 }
 g_offset[grp_cnt] = o_count;
 g_list[grp_cnt] = -1;
 /* The compact set of group names, in display order */
 g_names = mem_zalloc(grp_cnt * sizeof(char*));
 for (i = 0; i < grp_cnt; i++) {
  int len;
  g_names[i] = g_funcs.name(g_list[i]);
  len = strlen(g_names[i]);
  if (len > g_name_len) g_name_len = len;
 }
 /* Reasonable max group name len */
 if (g_name_len >= 20) g_name_len = 20;
 object_region.col = g_name_len + 3;
 group_region.width = g_name_len;
 /* Leave room for the group summary information */
 if (g_funcs.summary) object_region.page_rows = -3;
 /* Set up the two menus */
 menu_init(&group_menu, MN_SKIN_SCROLL, menu_find_iter(MN_ITER_STRINGS));
 menu_setpriv(&group_menu, grp_cnt, g_names);
 menu_layout(&group_menu, &group_region);
 group_menu.flags |= MN_DBL_TAP;
 menu_init(&object_menu, MN_SKIN_SCROLL, &object_iter);
 menu_setpriv(&object_menu, 0, &o_funcs);
 menu_layout(&object_menu, &object_region);
 object_menu.flags |= MN_DBL_TAP;
 o_funcs.is_visual = false;
 /* Save screen */
 screen_save();
 clear_from(0);
 /* This is the event loop for a multi-region panel */
 /* Panels are -- text panels, two menus, and visual browser */
 /* with "pop-up menu" for lore */
 while ((!flag) && (grp_cnt)) {
  bool recall = false;
  if (redraw) {
   /* Print the title bits */
   region_erase(&title_area);
   prt(format("Knowledge - %s", title), 2, 0);
   prt("Group", 4, 0);
   prt("Name", 4, g_name_len + 3);
   if (otherfields)
    prt(otherfields, 4, 46);
   /* Print dividers: horizontal and vertical */
   for (i = 0; i < 79; i++)
    Term_putch(i, 5, COLOUR_WHITE, L'=');
   for (i = 0; i < browser_rows; i++)
    Term_putch(g_name_len + 1, 6 + i, COLOUR_WHITE, L'|');
   /* Reset redraw flag */
   redraw = false;
  }
  if (g_cur != grp_old) {
   grp_old = g_cur;
   o_cur = 0;
   g_o_count = g_offset[g_cur+1] - g_offset[g_cur];
   menu_set_filter(&object_menu, obj_list + g_offset[g_cur],
       g_o_count);
   group_menu.cursor = g_cur;
   object_menu.cursor = 0;
  }
  /* HACK ... */
  if (!(tile_picker || glyph_picker)) {
   /* ... The object menu may be browsing the entire group... */
   o_funcs.is_visual = false;
   menu_set_filter(&object_menu, obj_list + g_offset[g_cur],
       g_o_count);
   object_menu.cursor = o_cur;
  } else {
   /* ... or just a single element in the group. */
   o_funcs.is_visual = true;
   menu_set_filter(&object_menu, obj_list + o_cur + g_offset[g_cur],
       1);
   object_menu.cursor = 0;
  }
  oid = obj_list[g_offset[g_cur]+o_cur];
  /* Print prompt */
  {
   const char *pedit = (!o_funcs.xattr) ? "" :
     (!(attr_idx|char_idx) ?
      ", 'c' to copy" : ", 'c', 'p' to paste");
   const char *xtra = o_funcs.xtra_prompt ?
    o_funcs.xtra_prompt(oid) : "";
   const char *pvs = "";
   if (tile_picker) pvs = ", ENTER to accept";
   else if (glyph_picker) pvs = ", 'i' to insert, ENTER to accept";
   else if (o_funcs.xattr) pvs = ", 'v' for visuals";
   prt(format("<dir>%s%s%s, ESC", pvs, pedit, xtra), hgt - 1, 0);
  }
  if (do_swap) {
   do_swap = false;
   (swapspace = (void*)(active_menu)), ((active_menu) = (inactive_menu)), ((inactive_menu) = swapspace);
   (swapspace = (void*)(active_cursor)), ((active_cursor) = (inactive_cursor)), ((inactive_cursor) = swapspace);
   panel = 1 - panel;
  }
  if (g_funcs.summary && !tile_picker && !glyph_picker) {
   g_funcs.summary(g_cur, obj_list, g_o_count, g_offset[g_cur],
                   object_menu.active.row +
       object_menu.active.page_rows,
                   object_region.col);
  }
  menu_refresh(inactive_menu, false);
  menu_refresh(active_menu, false);
  handle_stuff(player);
  if (tile_picker) {
          bigcurs = true;
   display_tiles(g_name_len + 3, 7, browser_rows - 1,
          wid - (g_name_len + 3), attr_top,
          char_left);
   place_tile_cursor(g_name_len + 3, 7,
       *o_funcs.xattr(oid),
       *o_funcs.xchar(oid),
       attr_top, char_left);
  }
  if (glyph_picker) {
          display_glyphs(g_name_len + 3, 7, browser_rows - 1,
           wid - (g_name_len + 3),
           *o_funcs.xattr(oid),
           *o_funcs.xchar(oid));
  }
  if (delay) {
   /* Force screen update */
   Term_fresh();
   /* Delay */
   Term_xtra(TERM_XTRA_DELAY, delay);
   delay = 0;
  }
  ke = inkey_ex();
  if (!tile_picker && !glyph_picker) {
   ui_event ke0 = EVENT_EMPTY;
   if (ke.type == EVT_MOUSE)
    menu_handle_mouse(active_menu, &ke, &ke0);
   else if (ke.type == EVT_KBRD)
    menu_handle_keypress(active_menu, &ke, &ke0);
   if (ke0.type != EVT_NONE)
    ke = ke0;
  }
  /* XXX Do visual mode command if needed */
  if (o_funcs.xattr && o_funcs.xchar) {
   if (tiles) {
    if (tile_picker_command(ke, &tile_picker,
      browser_rows - 1,
      wid - (g_name_len + 3),
      &attr_top, &char_left,
      o_funcs.xattr(oid),
      o_funcs.xchar(oid),
      g_name_len + 3, 7, &delay))
     continue;
   } else {
    if (glyph_command(ke, &glyph_picker,
      browser_rows - 1, wid - (g_name_len + 3),
      o_funcs.xattr(oid),
      o_funcs.xchar(oid),
      g_name_len + 3, 7))
     continue;
   }
  }
  switch (ke.type)
  {
   case EVT_KBRD:
   {
    if (ke.key.code == 'r' || ke.key.code == 'R')
     recall = true;
    else if (o_funcs.xtra_act)
     o_funcs.xtra_act(ke.key, oid);
    break;
   }
   case EVT_MOUSE:
   {
    /* Change active panels */
    if (region_inside(&inactive_menu->active, &ke)) {
     (swapspace = (void*)(active_menu)), ((active_menu) = (inactive_menu)), ((inactive_menu) = swapspace);
     (swapspace = (void*)(active_cursor)), ((active_cursor) = (inactive_cursor)), ((inactive_cursor) = swapspace);
     panel = 1-panel;
    }
    continue;
   }
   case EVT_ESCAPE:
   {
    if (panel == 1)
     do_swap = true;
    else
     flag = true;
    break;
   }
   case EVT_SELECT:
   {
    if (panel == 0)
     do_swap = true;
    else if (panel == 1 && oid >= 0 && o_cur == active_menu->cursor)
     recall = true;
    break;
   }
   case EVT_MOVE:
   {
    *active_cursor = active_menu->cursor;
    break;
   }
   default:
   {
    break;
   }
  }
  /* Recall on screen */
  if (recall) {
   if (oid >= 0)
    o_funcs.lore(oid);
   redraw = true;
  }
 }
 /* Prompt */
 if (!grp_cnt)
  prt(format("No %s known.", title), 15, 0);
 mem_free(g_names);
 mem_free(g_offset);
 mem_free(g_list);
 screen_load();
}
/**
 * ------------------------------------------------------------------------
 *  MONSTERS
 * ------------------------------------------------------------------------ */
/**
 * Is a flat array describing each monster group.  Configured by
 * ui_knowledge.txt.  The last element receives special treatment and is
 * used to catch any type of monster not caught by the other categories.
 * That's intended as a debugging tool while modding the game.
 */
static struct ui_monster_category *monster_group = NULL;
/**
 * Is the number of entries, including the last one receiving special
 * treatment, in monster_group.
 */
static int n_monster_group = 0;
/**
 * Display a monster
 */
static void display_monster(int col, int row, bool cursor, int oid)
{
 /* HACK Get the race index. (Should be a wrapper function) */
 int r_idx = default_item_id(oid);
 /* Access the race */
 struct monster_race *race = &r_info[r_idx];
 struct monster_lore *lore = &l_list[r_idx];
 /* Choose colors */
 uint8_t attr = curs_attrs[CURS_KNOWN][(int)cursor];
 uint8_t a = monster_x_attr[race->ridx];
 wchar_t c = monster_x_char[race->ridx];
 if ((tile_height != 1) && (a & 0x80)) {
  a = race->d_attr;
  c = race->d_char;
 }
 /* Display the name */
 c_prt(attr, race->name, row, col);
 /* Display symbol */
 big_pad(66, row, a, c);
 /* Display kills */
 if (!race->rarity) {
  put_str(format("%s", "shape"), row, 70);
 } else if (rf_has(race->flags, RF_UNIQUE)) {
  put_str(format("%s", (race->max_num == 0)? " dead" : "alive"),
    row, 70);
 } else {
  put_str(format("%5d", lore->pkills), row, 70);
 }
}
static int m_cmp_race(const void *a, const void *b)
{
 const int a_val = *(const int *)a;
 const int b_val = *(const int *)b;
 const struct monster_race *r_a = &r_info[default_item_id(a_val)];
 const struct monster_race *r_b = &r_info[default_item_id(b_val)];
 int gid = default_group_id(a_val);
 /* Group by */
 int c = gid - default_group_id(b_val);
 if (c)
  return c;
 /*
	 * If the group specifies monster bases, order those that are included
	 * by the base by those bases.  Those that aren't in any of the bases
	 * appear last.
	 */
 assert(gid >= 0 && gid < n_monster_group);
 if (monster_group[gid].n_inc_bases) {
  int base_a = monster_group[gid].n_inc_bases;
  int base_b = monster_group[gid].n_inc_bases;
  int i;
  for (i = 0; i < monster_group[gid].n_inc_bases; ++i) {
   if (r_a->base == monster_group[gid].inc_bases[i]) {
    base_a = i;
   }
   if (r_b->base == monster_group[gid].inc_bases[i]) {
    base_b = i;
   }
  }
  c = base_a - base_b;
  if (c) {
   return c;
  }
  if (base_a < monster_group[gid].n_inc_bases) {
   /*
			 * Have c be nonzer if a base was matched to skip
			 * checks on flags or the glyph below.
			 */
   c = 1;
  }
 }
 if (!c) {
  /*
		 * If a monster is included because it matches a flag, then
		 * it appears before a monster that is only included because
		 * of a glyph.
		 */
  if (rf_is_inter(r_a->flags, monster_group[gid].inc_flags)) {
   if (!rf_is_inter(r_b->flags,
     monster_group[gid].inc_flags)) {
    return -1;
   }
  } else if (rf_is_inter(r_b->flags, monster_group[gid].inc_flags)) {
   return 1;
  } else {
   /*
			 * If only included by a glyph, put an earlier glyph
			 * before a later one.
			 */
   int glyph_a = monster_group[gid].n_inc_glyphs;
   int glyph_b = monster_group[gid].n_inc_glyphs;
   int i;
   for (i = 0; i < monster_group[gid].n_inc_glyphs; ++i) {
    if (r_a->d_char == monster_group[gid].inc_glyphs[i]) {
     glyph_a = i;
    }
    if (r_b->d_char == monster_group[gid].inc_glyphs[i]) {
     glyph_b = i;
    }
   }
   c = glyph_a - glyph_b;
   if (c) {
    return c;
   }
  }
 }
 /*
	 * Within the same base, or if outside of the base but included by flag
	 * or by the same glyph, order by level and then by name.
	 */
 c = r_a->level - r_b->level;
 if (c)
  return c;
 return strcmp(r_a->name, r_b->name);
}
static wchar_t *m_xchar(int oid)
{
 return &monster_x_char[default_join[oid].oid];
}
static uint8_t *m_xattr(int oid)
{
 return &monster_x_attr[default_join[oid].oid];
}
static const char *race_name(int gid)
{
 return monster_group[gid].name;
}
static void mon_lore(int oid)
{
 int r_idx;
 struct monster_race *race;
 const struct monster_lore *lore;
 textblock *tb;
 r_idx = default_item_id(oid);
 assert(r_idx);
 race = &r_info[r_idx];
 lore = get_lore(race);
 /* Update the monster recall window */
 monster_race_track(player->upkeep, race);
 handle_stuff(player);
 tb = textblock_new();
 lore_description(tb, race, lore, false);
 textui_textblock_show(tb, SCREEN_REGION, NULL);
 textblock_free(tb);
}
static void mon_summary(int gid, const int *item_list, int n, int top,
      int row, int col)
{
 int i;
 int kills = 0;
 /* Access the race */
 for (i = 0; i < n; i++) {
  int oid = default_join[item_list[i+top]].oid;
  kills += l_list[oid].pkills;
 }
 /* Different display for the first item if we've got uniques to show */
 if (gid == 0 &&
  rf_has((&r_info[default_join[item_list[0]].oid])->flags, RF_UNIQUE)) {
  c_prt(COLOUR_L_BLUE, format("%d known uniques, %d slain.", n, kills),
     row, col);
 } else {
  int tkills = 0;
  for (i = 0; i < z_info->r_max; i++)
   tkills += l_list[i].pkills;
  c_prt(COLOUR_L_BLUE, format("Creatures slain: %d/%d (in group/in total)", kills, tkills), row, col);
 }
}
static int count_known_monsters(void)
{
 int m_count = 0, i;
 for (i = 0; i < z_info->r_max; ++i) {
  struct monster_race *race = &r_info[i];
  bool classified = false;
  int j;
  if (!l_list[i].all_known && !l_list[i].tsights) {
   continue;
  }
  if (!race->name) continue;
  for (j = 0; j < n_monster_group - 1; ++j) {
   bool has_base = false;
   int k;
   if (monster_group[j].n_inc_bases) {
    for (k = 0; k < monster_group[j].n_inc_bases;
      ++k) {
     if (race->base == monster_group[j].inc_bases[k]) {
      ++m_count;
      has_base = true;
      classified = true;
      break;
     }
    }
   }
   if (!has_base) {
    if (rf_is_inter(race->flags,
      monster_group[j].inc_flags)) {
     ++m_count;
     classified = true;
    } else if (monster_group[j].n_inc_glyphs) {
     for (k = 0; k < monster_group[j].n_inc_glyphs;
       ++k) {
      if (race->d_char == monster_group[j].inc_glyphs[k]) {
       ++m_count;
       classified = true;
       break;
      }
     }
    }
   }
  }
  if (!classified) {
   ++m_count;
  }
 }
 return m_count;
}
/**
 * Display known monsters.
 */
static void do_cmd_knowledge_monsters(const char *name, int row)
{
 group_funcs r_funcs = {race_name, m_cmp_race, default_group_id,
  mon_summary, n_monster_group, false };
 member_funcs m_funcs = {display_monster, mon_lore, m_xchar, m_xattr,
  recall_prompt, 0, 0};
 int *monsters;
 int m_count = count_known_monsters(), i, ind;
 default_join = mem_zalloc(m_count * sizeof(join_t));
 monsters = mem_zalloc(m_count * sizeof(int));
 ind = 0;
 for (i = 0; i < z_info->r_max; ++i) {
  struct monster_race *race = &r_info[i];
  bool classified = false;
  int j;
  if (!l_list[i].all_known && !l_list[i].tsights) {
   continue;
  }
  if (!race->name) continue;
  for (j = 0; j < n_monster_group - 1; ++j) {
   bool has_base = false;
   int k;
   if (monster_group[j].n_inc_bases) {
    for (k = 0; k < monster_group[j].n_inc_bases;
      ++k) {
     if (race->base == monster_group[j].inc_bases[k]) {
      assert(ind < m_count);
      monsters[ind] = ind;
      default_join[ind].oid = i;
      default_join[ind].gid = j;
      ++ind;
      has_base = true;
      classified = true;
      break;
     }
    }
   }
   if (!has_base) {
    if (rf_is_inter(race->flags,
      monster_group[j].inc_flags)) {
     assert(ind < m_count);
     monsters[ind] = ind;
     default_join[ind].oid = i;
     default_join[ind].gid = j;
     ++ind;
     classified = true;
    } else if (monster_group[j].n_inc_glyphs) {
     for (k = 0; k < monster_group[j].n_inc_glyphs;
       ++k) {
      if (race->d_char == monster_group[j].inc_glyphs[k]) {
       assert(ind < m_count);
       monsters[ind] = ind;
       default_join[ind].oid = i;
       default_join[ind].gid = j;
       ++ind;
       classified = true;
       break;
      }
     }
    }
   }
  }
  if (!classified) {
   assert(ind < m_count);
   monsters[ind] = ind;
   default_join[ind].oid = i;
   default_join[ind].gid = n_monster_group - 1;
   ++ind;
  }
 }
 display_knowledge("monsters", monsters, m_count, r_funcs, m_funcs,
   "                   Sym  Kills");
 mem_free(default_join);
 mem_free(monsters);
}
/**
 * ------------------------------------------------------------------------
 *  ARTIFACTS
 * ------------------------------------------------------------------------ */
/**
 * These are used for all the object sections
 */
static const grouper object_text_order[] =
{
 {TV_RING, "Ring" },
 {TV_AMULET, "Amulet" },
 {TV_POTION, "Potion" },
 {TV_STAFF, "Staff" },
 {TV_HORN, "Horn" },
  {TV_FOOD, "Food" },
  {TV_HERB, "Herb" },
 {TV_LIGHT, "Light" },
 {TV_FLASK, "Flask" },
 {TV_SWORD, "Sword" },
 {TV_POLEARM, "Polearm" },
 {TV_HAFTED, "Hafted Weapon" },
 {TV_BOW, "Bow" },
 {TV_ARROW, "Ammunition" },
 {TV_SHIELD, "Shield" },
 {TV_CROWN, "Crown" },
 {TV_HELM, "Helm" },
 {TV_GLOVES, "Gloves" },
 {TV_BOOTS, "Boots" },
 {TV_CLOAK, "Cloak" },
 {TV_MAIL, "Hard Armor" },
 {TV_SOFT_ARMOR, "Soft Armor" },
 {TV_DIGGING, "Digger" },
 {TV_METAL, "Metal" },
 {0, NULL }
};
static int *obj_group_order = NULL;
static void get_artifact_display_name(char *o_name, size_t namelen, int a_idx)
{
 struct object body = OBJECT_NULL, known_body = OBJECT_NULL;
 struct object *obj = &body, *known_obj = &known_body;
 make_fake_artifact(obj, &a_info[a_idx]);
 object_wipe(known_obj);
 object_copy(known_obj, obj);
 obj->known = known_obj;
 object_desc(o_name, namelen, obj,
  ODESC_PREFIX | ODESC_BASE | ODESC_SPOIL, NULL);
 object_wipe(known_obj);
 object_wipe(obj);
}
/**
 * Display an artifact label
 */
static void display_artifact(int col, int row, bool cursor, int oid)
{
 uint8_t attr = curs_attrs[CURS_KNOWN][(int)cursor];
 char o_name[80];
 get_artifact_display_name(o_name, sizeof o_name, oid);
 c_prt(attr, o_name, row, col);
}
/**
 * Look for an artifact
 */
static struct object *find_artifact(struct artifact *artifact)
{
 int y, x, i;
 struct object *obj;
 /* Ground objects */
 for (y = 1; y < cave->height; y++) {
  for (x = 1; x < cave->width; x++) {
   struct loc grid = loc(x, y);
   for (obj = square_object(cave, grid); obj; obj = obj->next) {
    if (obj->artifact == artifact) return obj;
   }
  }
 }
 /* Player objects */
 for (obj = player->gear; obj; obj = obj->next) {
  if (obj->artifact == artifact) return obj;
 }
 /* Monster objects */
 for (i = cave_monster_max(cave) - 1; i >= 1; i--) {
  struct monster *mon = cave_monster(cave, i);
  obj = mon ? mon->held_obj : NULL;
  while (obj) {
   if (obj->artifact == artifact) return obj;
   obj = obj->next;
  }
 }
 return NULL;
}
/**
 * Show artifact lore
 */
static void desc_art_fake(int a_idx)
{
 struct object *obj, *known_obj = NULL;
 struct object object_body = OBJECT_NULL, known_object_body = OBJECT_NULL;
 bool fake = false;
 char header[120];
 textblock *tb;
 region area = { 0, 0, 0, 0 };
 obj = find_artifact(&a_info[a_idx]);
 /* If it's been lost, make a fake artifact for it */
 if (!obj) {
  fake = true;
  obj = &object_body;
  known_obj = &known_object_body;
  make_fake_artifact(obj, &a_info[a_idx]);
  obj->known = known_obj;
  known_obj->artifact = obj->artifact;
  known_obj->kind = obj->kind;
  /* Check the history entry, to see if it was fully known before it
		 * was lost */
  if (history_is_artifact_known(player, obj->artifact))
   /* Be very careful not to influence anything but this object */
   object_copy(known_obj, obj);
 }
 /* Hack -- Handle stuff */
 handle_stuff(player);
 tb = object_info(obj, OINFO_NONE);
 object_desc(header, sizeof(header), obj,
  ODESC_PREFIX | ODESC_FULL | ODESC_CAPITAL, player);
 if (fake) {
  object_wipe(known_obj);
  object_wipe(obj);
 }
 textui_textblock_show(tb, area, header);
 textblock_free(tb);
}
static int a_cmp_tval(const void *a, const void *b)
{
 const int a_val = *(const int *)a;
 const int b_val = *(const int *)b;
 const struct artifact *a_a = &a_info[a_val];
 const struct artifact *a_b = &a_info[b_val];
 /* Group by */
 int ta = obj_group_order[a_a->tval];
 int tb = obj_group_order[a_b->tval];
 int c = ta - tb;
 if (c) return c;
 /* Order by */
 c = a_a->sval - a_b->sval;
 if (c) return c;
 return strcmp(a_a->name, a_b->name);
}
static const char *kind_name(int gid)
{
 return object_text_order[gid].name;
}
static int art2gid(int oid)
{
 return obj_group_order[a_info[oid].tval];
}
/**
 * Check if the given artifact idx is something we should "Know" about
 */
static bool artifact_is_known(int a_idx)
{
 struct object *obj;
 if (!a_info[a_idx].name)
  return false;
 if (player->wizard)
  return true;
 if (!is_artifact_created(&a_info[a_idx]))
  return false;
 /* Check all objects to see if it exists but hasn't been IDed */
 obj = find_artifact(&a_info[a_idx]);
 if (obj && !object_is_known_artifact(obj))
  return false;
 return true;
}
/**
 * If 'artifacts' is NULL, it counts the number of known artifacts, otherwise
 * it collects the list of known artifacts into 'artifacts' as well.
 */
static int collect_known_artifacts(int *artifacts, size_t artifacts_len)
{
 int a_count = 0;
 int j;
 if (artifacts)
  assert(artifacts_len >= z_info->a_max);
 for (j = 0; j < z_info->a_max; j++) {
  /* Artifact doesn't exist */
  if (!a_info[j].name) continue;
  if (OPT(player, cheat_xtra) || artifact_is_known(j)) {
   if (artifacts)
    artifacts[a_count++] = j;
   else
    a_count++;
  }
 }
 return a_count;
}
/**
 * Display known artifacts
 */
static void do_cmd_knowledge_artifacts(const char *name, int row)
{
 /* HACK -- should be TV_MAX */
 group_funcs obj_f = {kind_name, a_cmp_tval, art2gid, 0, TV_MAX, false};
 member_funcs art_f = {display_artifact, desc_art_fake, 0, 0, recall_prompt,
        0, 0};
 int *artifacts;
 int a_count = 0;
 char title[40];
 artifacts = mem_zalloc(z_info->a_max * sizeof(int));
 /* Collect valid artifacts */
 a_count = collect_known_artifacts(artifacts, z_info->a_max);
 strnfmt(title, sizeof(title), "artifacts");
 display_knowledge(title, artifacts, a_count, obj_f, art_f, NULL);
 mem_free(artifacts);
}
/**
 * ------------------------------------------------------------------------
 *  EGO ITEMS
 * ------------------------------------------------------------------------ */
static const char *ego_grp_name(int gid)
{
 return object_text_order[gid].name;
}
static void display_ego_item(int col, int row, bool cursor, int oid)
{
 /* Access the object */
 struct ego_item *ego = &e_info[default_item_id(oid)];
 /* Choose a color */
 uint8_t attr = curs_attrs[0 != (int)ego->everseen][0 != (int)cursor];
 /* Display the name */
 c_prt(attr, ego->name, row, col);
}
/**
 * Describe fake ego item "lore"
 */
static void desc_ego_fake(int oid)
{
 int e_idx = default_item_id(oid);
 struct ego_item *ego = &e_info[e_idx];
 textblock *tb;
 region area = { 0, 0, 0, 0 };
 /* List ego flags */
 tb = object_info_ego(ego);
 textui_textblock_show(tb, area, format("%s %s",
             ego_grp_name(default_group_id(oid)),
             ego->name));
 textblock_free(tb);
}
/* TODO? Currently ego items will order by e_idx */
static int e_cmp_tval(const void *a, const void *b)
{
 const int a_val = *(const int *)a;
 const int b_val = *(const int *)b;
 const struct ego_item *ea = &e_info[default_item_id(a_val)];
 const struct ego_item *eb = &e_info[default_item_id(b_val)];
 /* Group by */
 int c = default_group_id(a_val) - default_group_id(b_val);
 if (c) return c;
 /* Order by */
 return strcmp(ea->name, eb->name);
}
/**
 * Display known ego_items
 */
static void do_cmd_knowledge_ego_items(const char *name, int row)
{
 group_funcs obj_f =
  {ego_grp_name, e_cmp_tval, default_group_id, 0, TV_MAX, false};
 member_funcs ego_f =
  {display_ego_item, desc_ego_fake, 0, 0, recall_prompt, 0, 0};
 int *egoitems;
 int e_count = 0;
 int i;
 /* Overkill - NRM */
 int max_pairs = z_info->e_max * N_ELEMENTS(object_text_order);
 egoitems = mem_zalloc(max_pairs * sizeof(int));
 default_join = mem_zalloc(max_pairs * sizeof(join_t));
 /* Look at all the ego items */
 for (i = 0; i < z_info->e_max; i++) {
  struct ego_item *ego = &e_info[i];
  if (ego->everseen || OPT(player, cheat_xtra)) {
   size_t j;
   int *tval = mem_zalloc(N_ELEMENTS(object_text_order) * sizeof(int));
   struct poss_item *poss;
   /* Note the tvals which are possible for this ego */
   for (poss = ego->poss_items; poss; poss = poss->next) {
    struct object_kind *kind = &k_info[poss->kidx];
    assert(obj_group_order[kind->tval] >= 0);
    tval[obj_group_order[kind->tval]]++;
   }
   /* Count and put into the list */
   for (j = 0; j < TV_MAX; j++) {
    int gid = obj_group_order[j];
    /* Skip if nothing in this group */
    if (gid < 0) continue;
    /* Ignore duplicates */
    if ((e_count > 0) && (gid == default_join[e_count - 1].gid)
     && (i == default_join[e_count - 1].oid))
     continue;
    if (tval[gid]) {
     egoitems[e_count] = e_count;
     default_join[e_count].oid = i;
     default_join[e_count++].gid = gid;
    }
   }
   mem_free(tval);
  }
 }
 display_knowledge("ego items", egoitems, e_count, obj_f, ego_f, NULL);
 mem_free(default_join);
 mem_free(egoitems);
}
/**
 * ------------------------------------------------------------------------
 * ORDINARY OBJECTS
 * ------------------------------------------------------------------------ */
/**
 * Display the objects in a group.
 */
static void display_object(int col, int row, bool cursor, int oid)
{
 struct object_kind *kind = &k_info[oid];
 const char *inscrip = get_autoinscription(kind, kind->aware);
 char o_name[80];
 /* Choose a color */
 bool aware = (!kind->flavor || kind->aware);
 uint8_t attr = curs_attrs[(int)aware][(int)cursor];
 /* Graphics versions of the object_char and object_attr defines */
 uint8_t a = object_kind_attr(kind);
 wchar_t c = object_kind_char(kind);
 /* Don't display special artifacts */
 if (!kf_has(kind->kind_flags, KF_INSTA_ART))
   object_kind_name(o_name, sizeof(o_name), kind, OPT(player, cheat_xtra));
 /* If the type is "tried", display that */
 if (kind->tried && !aware)
  my_strcat(o_name, " {tried}", sizeof(o_name));
 /* Display the name */
 c_prt(attr, o_name, row, col);
 /* Show ignore status */
 if ((aware && kind_is_ignored_aware(kind)) ||
  (!aware && kind_is_ignored_unaware(kind)))
  c_put_str(attr, "Yes", row, 46);
 /* Show autoinscription if around */
 if (inscrip)
  c_put_str(COLOUR_YELLOW, inscrip, row, 55);
 if (tile_height == 1) {
  big_pad(76, row, a, c);
 }
}
/**
 * Describe fake object
 */
static void desc_obj_fake(int k_idx)
{
 struct object_kind *kind = &k_info[k_idx];
 struct object_kind *old_kind = player->upkeep->object_kind;
 struct object *old_obj = player->upkeep->object;
 struct object *obj = object_new(), *known_obj = object_new();
 char header[120];
 textblock *tb;
 region area = { 0, 0, 0, 0 };
 /* Update the object recall window */
 track_object_kind(player->upkeep, kind);
 handle_stuff(player);
 /* Create the artifact */
 object_prep(obj, kind, 0, EXTREMIFY);
 /* It's fully known */
 if (kind->aware || !kind->flavor)
  object_copy(known_obj, obj);
 obj->known = known_obj;
 /* Hack -- Handle stuff */
 handle_stuff(player);
 tb = object_info(obj, OINFO_FAKE);
 object_desc(header, sizeof(header), obj,
  ODESC_PREFIX | ODESC_CAPITAL, player);
 textui_textblock_show(tb, area, header);
 object_delete(NULL, NULL, &known_obj);
 object_delete(NULL, NULL, &obj);
 textblock_free(tb);
 /* Restore the old trackee */
 if (old_kind)
  track_object_kind(player->upkeep, old_kind);
 else if (old_obj)
  track_object(player->upkeep, old_obj);
 else
  track_object_cancel(player->upkeep);
}
static int o_cmp_tval(const void *a, const void *b)
{
 const int a_val = *(const int *)a;
 const int b_val = *(const int *)b;
 const struct object_kind *k_a = &k_info[a_val];
 const struct object_kind *k_b = &k_info[b_val];
 /* Group by */
 int ta = obj_group_order[k_a->tval];
 int tb = obj_group_order[k_b->tval];
 int c = ta - tb;
 if (c) return c;
 /* Order by */
 c = k_a->aware - k_b->aware;
 if (c) return -c; /* aware has low sort weight */
 switch (k_a->tval)
 {
  case TV_LIGHT:
   /* leave sorted by sval */
   break;
  default:
   if (k_a->aware)
    return strcmp(k_a->name, k_b->name);
   /* Then in tried order */
   c = k_a->tried - k_b->tried;
   if (c) return -c;
   return strcmp(k_a->flavor->text, k_b->flavor->text);
 }
 return k_a->sval - k_b->sval;
}
static int obj2gid(int oid)
{
 return obj_group_order[k_info[oid].tval];
}
static wchar_t *o_xchar(int oid)
{
 struct object_kind *kind = objkind_byid(oid);
 if (!kind) return 0;
 if (!kind->flavor || kind->aware)
  return &kind_x_char[kind->kidx];
 else
  return &flavor_x_char[kind->flavor->fidx];
}
static uint8_t *o_xattr(int oid)
{
 struct object_kind *kind = objkind_byid(oid);
 if (!kind) return NULL;
 if (!kind->flavor || kind->aware)
  return &kind_x_attr[kind->kidx];
 else
  return &flavor_x_attr[kind->flavor->fidx];
}
/**
 * Display special prompt for object inscription.
 */
static const char *o_xtra_prompt(int oid)
{
 struct object_kind *kind = objkind_byid(oid);
 const char *no_insc = ", 's' to toggle ignore, 'r'ecall, '{'";
 const char *with_insc = ", 's' to toggle ignore, 'r'ecall, '{', '}'";
 if (!kind) return NULL;
 /* Appropriate prompt */
 if (kind->aware)
  return kind->note_aware ? with_insc : no_insc;
 else
  return kind->note_unaware ? with_insc : no_insc;
}
/**
 * Special key actions for object inscription.
 */
static void o_xtra_act(struct keypress ch, int oid)
{
 struct object_kind *k = objkind_byid(oid);
 if (!k) return;
 /* Toggle ignore */
 if (ignore_tval(k->tval) && (ch.code == 's' || ch.code == 'S')) {
  if (k->aware) {
   if (kind_is_ignored_aware(k))
    kind_ignore_clear(k);
   else
    kind_ignore_when_aware(k);
  } else {
   if (kind_is_ignored_unaware(k))
    kind_ignore_clear(k);
   else
    kind_ignore_when_unaware(k);
  }
  return;
 }
 /* Uninscribe */
 if (ch.code == '}') {
  remove_autoinscription(oid);
 } else if (ch.code == '{') {
  /* Inscribe */
  char text[80] = "";
  /* Avoid the prompt getting in the way */
  screen_save();
  /* Prompt */
  prt("Inscribe with: ", 0, 0);
  /* Default note */
  if (k->note_aware || k->note_unaware)
   strnfmt(text, sizeof(text), "%s", get_autoinscription(k, k->aware));
  /* Get an inscription */
  if (askfor_aux(text, sizeof(text), NULL)) {
   /* Remove old inscription if existent */
   if (k->note_aware || k->note_unaware)
    remove_autoinscription(oid);
   /* Add the autoinscription */
   add_autoinscription(oid, text, k->aware);
   cmdq_push(CMD_AUTOINSCRIBE);
   /* Redraw gear */
   player->upkeep->redraw |= (PR_INVEN | PR_EQUIP);
  }
  /* Reload the screen */
  screen_load();
 }
}
/**
 * Display known objects
 */
void textui_browse_object_knowledge(const char *name, int row)
{
 group_funcs kind_f = {kind_name, o_cmp_tval, obj2gid, 0, TV_MAX, false};
 member_funcs obj_f = {display_object, desc_obj_fake, o_xchar, o_xattr,
        o_xtra_prompt, o_xtra_act, 0};
 int *objects;
 int o_count = 0;
 int i;
 struct object_kind *kind;
 objects = mem_zalloc(z_info->k_max * sizeof(int));
 for (i = 0; i < z_info->k_max; i++) {
  kind = &k_info[i];
  /* It's in the list if we've ever seen it, or it has a flavour,
		 * and it's not one of the special artifacts. This way the flavour
		 * appears in the list until it is found. */
  if ((kind->everseen || kind->flavor || OPT(player, cheat_xtra)) &&
   (!kf_has(kind->kind_flags, KF_INSTA_ART))) {
   int c = obj_group_order[k_info[i].tval];
   if (c >= 0) objects[o_count++] = i;
  }
 }
 display_knowledge("known objects", objects, o_count, kind_f, obj_f,
       "Ignore  Inscribed          Sym");
 mem_free(objects);
}
/**
 * ------------------------------------------------------------------------
 * OBJECT RUNES
 * ------------------------------------------------------------------------ */
/**
 * Description of each rune group.
 */
static const char *rune_group_text[] =
{
 "Combat",
 "Modifiers",
 "Resists",
 "Brands",
 "Slays",
 "Curses",
 "Other",
 NULL
};
/**
 * Display the runes in a group.
 */
static void display_rune(int col, int row, bool cursor, int oid )
{
 uint8_t attr = curs_attrs[CURS_KNOWN][(int)cursor];
 const char *inscrip = quark_str(rune_note(oid));
 c_prt(attr, rune_name(oid), row, col);
 /* Show autoinscription if around */
 if (inscrip)
  c_put_str(COLOUR_YELLOW, inscrip, row, 47);
}
static const char *rune_var_name(int gid)
{
 return rune_group_text[gid];
}
static int rune_var(int oid)
{
 return (int) rune_variety(oid);
}
static void rune_lore(int oid)
{
 textblock *tb = textblock_new();
 char *title = string_make(rune_name(oid));
 my_strcap(title);
 textblock_append_c(tb, COLOUR_L_BLUE, "%s", title);
 textblock_append(tb, "\n");
 textblock_append(tb, "%s", rune_desc(oid));
 textblock_append(tb, "\n");
 textui_textblock_show(tb, SCREEN_REGION, NULL);
 textblock_free(tb);
 string_free(title);
}
/**
 * Display special prompt for rune inscription.
 */
static const char *rune_xtra_prompt(int oid)
{
 const char *no_insc = ", 'r'ecall, '{'";
 const char *with_insc = ", 'r'ecall, '{', '}'";
 /* Appropriate prompt */
 return rune_note(oid) ? with_insc : no_insc;
}
/**
 * Special key actions for rune inscription.
 */
static void rune_xtra_act(struct keypress ch, int oid)
{
 /* Uninscribe */
 if (ch.code == '}') {
  rune_set_note(oid, NULL);
 } else if (ch.code == '{') {
  /* Inscribe */
  char note_text[80] = "";
  /* Avoid the prompt getting in the way */
  screen_save();
  /* Prompt */
  prt("Inscribe with: ", 0, 0);
  /* Default note */
  if (rune_note(oid))
   strnfmt(note_text, sizeof(note_text), "%s",
     quark_str(rune_note(oid)));
  /* Get an inscription */
  if (askfor_aux(note_text, sizeof(note_text), NULL)) {
   /* Remove old inscription if existent */
   if (rune_note(oid))
    rune_set_note(oid, NULL);
   /* Add the autoinscription */
   rune_set_note(oid, note_text);
   rune_autoinscribe(player, oid);
   /* Redraw gear */
   player->upkeep->redraw |= (PR_INVEN | PR_EQUIP);
  }
  /* Reload the screen */
  screen_load();
 }
}
/**
 * Display rune knowledge.
 */
static void do_cmd_knowledge_runes(const char *name, int row)
{
 group_funcs rune_var_f = {rune_var_name, NULL, rune_var, 0,
         N_ELEMENTS(rune_group_text), false};
 member_funcs rune_f = {display_rune, rune_lore, NULL, NULL,
         rune_xtra_prompt, rune_xtra_act, 0};
 int *runes;
 int rune_max = max_runes();
 int count = 0;
 int i;
 char buf[30];
 runes = mem_zalloc(rune_max * sizeof(int));
 for (i = 0; i < rune_max; i++) {
  /* Ignore unknown runes */
  if (!player_knows_rune(player, i))
   continue;
  runes[count++] = i;
 }
 strnfmt(buf, sizeof(buf), "runes (%d unknown)", rune_max - count);
 display_knowledge(buf, runes, count, rune_var_f, rune_f, "Inscribed");
 mem_free(runes);
}
/**
 * ------------------------------------------------------------------------
 * TERRAIN FEATURES
 * ------------------------------------------------------------------------ */
/**
 * Description of each feature group.
 */
static const char *feature_group_text[] =
{
 "Floors",
 "Doors",
 "Stairs",
 "Walls",
 "Obstructions",
 "Forges",
 "Pits",
 "Other",
 NULL
};
/**
 * Display the features in a group.
 */
static void display_feature(int col, int row, bool cursor, int oid )
{
 struct feature *feat = &f_info[oid];
 uint8_t attr = curs_attrs[CURS_KNOWN][(int)cursor];
 c_prt(attr, feat->name, row, col);
 if (tile_height == 1) {
  /* Display symbols */
  col = 65;
  col += big_pad(col, row, feat_x_attr[LIGHTING_DARK][feat->fidx],
        feat_x_char[LIGHTING_DARK][feat->fidx]);
  col += big_pad(col, row, feat_x_attr[LIGHTING_LIT][feat->fidx],
        feat_x_char[LIGHTING_LIT][feat->fidx]);
  col += big_pad(col, row, feat_x_attr[LIGHTING_TORCH][feat->fidx],
        feat_x_char[LIGHTING_TORCH][feat->fidx]);
  (void) big_pad(col, row, feat_x_attr[LIGHTING_LOS][feat->fidx],
        feat_x_char[LIGHTING_LOS][feat->fidx]);
 }
}
static int f_cmp_fkind(const void *a, const void *b)
{
 const int a_val = *(const int *)a;
 const int b_val = *(const int *)b;
 const struct feature *fa = &f_info[a_val];
 const struct feature *fb = &f_info[b_val];
 /* Group by */
 int c = feat_order(a_val) - feat_order(b_val);
 if (c) return c;
 /* Order by feature name */
 return strcmp(fa->name, fb->name);
}
static const char *fkind_name(int gid)
{
 return feature_group_text[gid];
}
/**
 * Disgusting hack to allow 4 in 1 editing of terrain visuals
 */
static enum grid_light_level f_uik_lighting = LIGHTING_LIT;
/* XXX needs *better* retooling for multi-light terrain */
static uint8_t *f_xattr(int oid)
{
 return &feat_x_attr[f_uik_lighting][oid];
}
static wchar_t *f_xchar(int oid)
{
 return &feat_x_char[f_uik_lighting][oid];
}
static void feat_lore(int oid)
{
 struct feature *feat = &f_info[oid];
 if (feat->desc) {
  textblock *tb = textblock_new();
  char *title = string_make(feat->name);
  my_strcap(title);
  textblock_append_c(tb, COLOUR_L_BLUE, "%s", title);
  string_free(title);
  textblock_append(tb, "\n");
  textblock_append(tb, "%s", feat->desc);
  textblock_append(tb, "\n");
  textui_textblock_show(tb, SCREEN_REGION, NULL);
  textblock_free(tb);
 }
}
static const char *feat_prompt(int oid)
{
 (void)oid;
  switch (f_uik_lighting) {
    case LIGHTING_LIT: return ", 't/T' for lighting (lit)";
                case LIGHTING_TORCH: return ", 't/T' for lighting (torch)";
    case LIGHTING_LOS: return ", 't/T' for lighting (LOS)";
    default: return ", 't/T' for lighting (dark)";
  }
}
/**
 * Special key actions for cycling lighting
 */
static void f_xtra_act(struct keypress ch, int oid)
{
 /* XXX must be a better way to cycle this */
 if (ch.code == 't') {
  switch (f_uik_lighting) {
    case LIGHTING_LIT: f_uik_lighting = LIGHTING_TORCH; break;
                case LIGHTING_TORCH: f_uik_lighting = LIGHTING_LOS; break;
    case LIGHTING_LOS: f_uik_lighting = LIGHTING_DARK; break;
    default: f_uik_lighting = LIGHTING_LIT; break;
  }
 } else if (ch.code == 'T') {
  switch (f_uik_lighting) {
    case LIGHTING_DARK: f_uik_lighting = LIGHTING_LOS; break;
                case LIGHTING_LOS: f_uik_lighting = LIGHTING_TORCH; break;
    case LIGHTING_LIT: f_uik_lighting = LIGHTING_DARK; break;
    default: f_uik_lighting = LIGHTING_LIT; break;
  }
 }
}
/**
 * Interact with feature visuals.
 */
static void do_cmd_knowledge_features(const char *name, int row)
{
 group_funcs fkind_f = {fkind_name, f_cmp_fkind, feat_order, 0,
         N_ELEMENTS(feature_group_text), false};
 member_funcs feat_f = {display_feature, feat_lore, f_xchar, f_xattr,
         feat_prompt, f_xtra_act, 0};
 int *features;
 int f_count = 0;
 int i;
 features = mem_zalloc(FEAT_MAX * sizeof(int));
 for (i = 0; i < FEAT_MAX; i++) {
  /* Ignore non-features and mimics */
  if (f_info[i].name == 0 || f_info[i].mimic)
   continue;
  /* Currently no filter for features */
  features[f_count++] = i;
 }
 display_knowledge("features", features, f_count, fkind_f, feat_f,
       "                    Sym");
 mem_free(features);
}
/**
 * ------------------------------------------------------------------------
 * TRAPS
 * ------------------------------------------------------------------------ */
/**
 * Description of each feature group.
 */
static const char *trap_group_text[] =
{
 "Runes",
 "Locks",
 "Traps",
 "Other",
 NULL
};
/**
 * Display the features in a group.
 */
static void display_trap(int col, int row, bool cursor, int oid )
{
 struct trap_kind *trap = &trap_info[oid];
 uint8_t attr = curs_attrs[CURS_KNOWN][(int)cursor];
 c_prt(attr, trap->desc, row, col);
 if (tile_height == 1) {
  /* Display symbols */
  col = 65;
  col += big_pad(col, row, trap_x_attr[LIGHTING_DARK][trap->tidx],
    trap_x_char[LIGHTING_DARK][trap->tidx]);
  col += big_pad(col, row, trap_x_attr[LIGHTING_LIT][trap->tidx],
    trap_x_char[LIGHTING_LIT][trap->tidx]);
  col += big_pad(col, row, trap_x_attr[LIGHTING_TORCH][trap->tidx],
    trap_x_char[LIGHTING_TORCH][trap->tidx]);
  (void) big_pad(col, row, trap_x_attr[LIGHTING_LOS][trap->tidx],
    trap_x_char[LIGHTING_LOS][trap->tidx]);
 }
}
static int trap_order(int trap)
{
 const struct trap_kind *t = &trap_info[trap];
 if (trf_has(t->flags, TRF_GLYPH))
  return 0;
 else if (trf_has(t->flags, TRF_LOCK))
  return 1;
 else if (trf_has(t->flags, TRF_TRAP))
  return 2;
 else
  return 3;
}
static int t_cmp_tkind(const void *a, const void *b)
{
 const int a_val = *(const int *)a;
 const int b_val = *(const int *)b;
 const struct trap_kind *ta = &trap_info[a_val];
 const struct trap_kind *tb = &trap_info[b_val];
 /* Group by */
 int c = trap_order(a_val) - trap_order(b_val);
 if (c) return c;
 /* Order by name */
 if (ta->name) {
  if (tb->name)
   return strcmp(ta->name, tb->name);
  else
   return 1;
 } else if (tb->name) {
  return -1;
 }
 return 0;
}
static const char *tkind_name(int gid)
{
 return trap_group_text[gid];
}
/**
 * Disgusting hack to allow 4 in 1 editing of trap visuals
 */
static enum grid_light_level t_uik_lighting = LIGHTING_LIT;
/* XXX needs *better* retooling for multi-light terrain */
static uint8_t *t_xattr(int oid)
{
 return &trap_x_attr[t_uik_lighting][oid];
}
static wchar_t *t_xchar(int oid)
{
 return &trap_x_char[t_uik_lighting][oid];
}
static void trap_lore(int oid)
{
 struct trap_kind *trap = &trap_info[oid];
 if (trap->text) {
  textblock *tb = textblock_new();
  char *title = string_make(trap->desc);
  my_strcap(title);
  textblock_append_c(tb, COLOUR_L_BLUE, "%s", title);
  string_free(title);
  textblock_append(tb, "\n");
  textblock_append(tb, "%s", trap->text);
  textblock_append(tb, "\n");
  textui_textblock_show(tb, SCREEN_REGION, NULL);
  textblock_free(tb);
 }
}
static const char *trap_prompt(int oid)
{
 (void)oid;
 return ", 't' to cycle lighting";
}
/**
 * Special key actions for cycling lighting
 */
static void t_xtra_act(struct keypress ch, int oid)
{
 /* XXX must be a better way to cycle this */
 if (ch.code == 't') {
  switch (t_uik_lighting) {
    case LIGHTING_LIT: t_uik_lighting = LIGHTING_TORCH; break;
                case LIGHTING_TORCH: t_uik_lighting = LIGHTING_LOS; break;
    case LIGHTING_LOS: t_uik_lighting = LIGHTING_DARK; break;
    default: t_uik_lighting = LIGHTING_LIT; break;
  }
 } else if (ch.code == 'T') {
  switch (t_uik_lighting) {
    case LIGHTING_DARK: t_uik_lighting = LIGHTING_LOS; break;
                case LIGHTING_LOS: t_uik_lighting = LIGHTING_TORCH; break;
    case LIGHTING_LIT: t_uik_lighting = LIGHTING_DARK; break;
    default: t_uik_lighting = LIGHTING_LIT; break;
  }
 }
}
/**
 * Interact with trap visuals.
 */
static void do_cmd_knowledge_traps(const char *name, int row)
{
 group_funcs tkind_f = {tkind_name, t_cmp_tkind, trap_order, 0,
         N_ELEMENTS(trap_group_text), false};
 member_funcs trap_f = {display_trap, trap_lore, t_xchar, t_xattr,
         trap_prompt, t_xtra_act, 0};
 int *traps;
 int t_count = 0;
 int i;
 traps = mem_zalloc(z_info->trap_max * sizeof(int));
 for (i = 0; i < z_info->trap_max; i++) {
  if (!trap_info[i].name) continue;
  traps[t_count++] = i;
 }
 display_knowledge("traps", traps, t_count, tkind_f, trap_f,
       "                    Sym");
 mem_free(traps);
}
/**
 *
 * ------------------------------------------------------------------------
 * ui_knowledge.txt parsing
 * ------------------------------------------------------------------------
 */
static enum parser_error parse_monster_category(struct parser *p)
{
 struct ui_knowledge_parse_state *s =
  (struct ui_knowledge_parse_state*) parser_priv(p);
 struct ui_monster_category *c;
 assert(s);
 c = mem_zalloc(sizeof(*c));
 c->next = s->categories;
 c->name = string_make(parser_getstr(p, "name"));
 s->categories = c;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_mcat_include_base(struct parser *p)
{
 struct ui_knowledge_parse_state *s =
  (struct ui_knowledge_parse_state*) parser_priv(p);
 struct monster_base *b;
 assert(s);
 if (!s->categories) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 b = lookup_monster_base(parser_getstr(p, "name"));
 if (!b) {
  return PARSE_ERROR_INVALID_MONSTER_BASE;
 }
 assert(s->categories->n_inc_bases >= 0
  && s->categories->n_inc_bases <= s->categories->max_inc_bases);
 if (s->categories->n_inc_bases == s->categories->max_inc_bases) {
  if (s->categories->max_inc_bases > INT_MAX
    / (2 * (int) sizeof(struct monster_base*))) {
   return PARSE_ERROR_TOO_MANY_ENTRIES;
  }
  s->categories->max_inc_bases = (s->categories->max_inc_bases)
   ? 2 * s->categories->max_inc_bases : 2;
  s->categories->inc_bases = mem_realloc(
   s->categories->inc_bases,
   s->categories->max_inc_bases
   * sizeof(struct monster_base*));
 }
 s->categories->inc_bases[s->categories->n_inc_bases] = b;
 ++s->categories->n_inc_bases;
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_mcat_include_flag(struct parser *p)
{
 struct ui_knowledge_parse_state *s =
  (struct ui_knowledge_parse_state*) parser_priv(p);
 char *flags, *next_flag;
 assert(s);
 if (!s->categories) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 if (!parser_hasval(p, "flags")) {
  return PARSE_ERROR_NONE;
 }
 flags = string_make(parser_getstr(p, "flags"));
 next_flag = strtok(flags, " |");
 while (next_flag) {
  if (grab_flag(s->categories->inc_flags, RF_SIZE, r_info_flags,
    next_flag)) {
   string_free(flags);
   return PARSE_ERROR_INVALID_FLAG;
  }
  next_flag = strtok(NULL, " |");
 }
 string_free(flags);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_mcat_include_glyph(struct parser *p)
{
 struct ui_knowledge_parse_state *s =
  (struct ui_knowledge_parse_state*) parser_priv(p);
 assert(s);
 if (!s->categories) {
  return PARSE_ERROR_MISSING_RECORD_HEADER;
 }
 assert(s->categories->n_inc_glyphs >= 0
  && s->categories->n_inc_glyphs <= s->categories->max_inc_glyphs);
 if (s->categories->n_inc_glyphs == s->categories->max_inc_glyphs) {
  if (s->categories->max_inc_glyphs > INT_MAX
    / (2 * (int) sizeof(wchar_t))) {
   return PARSE_ERROR_TOO_MANY_ENTRIES;
  }
  s->categories->max_inc_glyphs = (s->categories->max_inc_glyphs)
   ? 2 * s->categories->max_inc_glyphs : 4;
  s->categories->inc_glyphs = mem_realloc(
   s->categories->inc_glyphs,
   s->categories->max_inc_glyphs * sizeof(wchar_t));
 }
 s->categories->inc_glyphs[s->categories->n_inc_glyphs] =
  parser_getchar(p, "glyph");
 ++s->categories->n_inc_glyphs;
 return PARSE_ERROR_NONE;
}
static struct parser *init_ui_knowledge_parser(void)
{
 struct ui_knowledge_parse_state *s = mem_zalloc(sizeof(*s));
 struct parser *p = parser_new();
 parser_setpriv(p, s);
 parser_reg(p, "monster-category str name", parse_monster_category);
 parser_reg(p, "mcat-include-base str name", parse_mcat_include_base);
 parser_reg(p, "mcat-include-flag ?str flags", parse_mcat_include_flag);
 parser_reg(p, "mcat-include-glyph char glyph", parse_mcat_include_glyph);
 return p;
}
static errr run_ui_knowledge_parser(struct parser *p)
{
 return parse_file_quit_not_found(p, "ui_knowledge");
}
static errr finish_ui_knowledge_parser(struct parser *p)
{
 struct ui_knowledge_parse_state *s =
  (struct ui_knowledge_parse_state*) parser_priv(p);
 struct ui_monster_category *cursor;
 size_t count;
 assert(s);
 /* Count the number of categories and allocate a flat array for them. */
 count = 0;
 for (cursor = s->categories; cursor; cursor = cursor->next) {
  ++count;
 }
 if (count > INT_MAX - 1) {
  /*
		 * The sorting and display logic for monster groups assumes
		 * the number of categories fits in an int.
		 */
  cursor = s->categories;
  while (cursor) {
   struct ui_monster_category *tgt = cursor;
   cursor = cursor->next;
   string_free((char*) tgt->name);
   mem_free(tgt->inc_bases);
   mem_free(tgt->inc_glyphs);
   mem_free(tgt);
  }
  mem_free(s);
  parser_destroy(p);
  return PARSE_ERROR_TOO_MANY_ENTRIES;
 }
 if (monster_group) {
  cleanup_ui_knowledge_parsed_data();
 }
 monster_group = mem_alloc((count + 1) * sizeof(*monster_group));
 n_monster_group = (int) (count + 1);
 /* Set the element at the end which receives special treatment. */
 monster_group[count].next = NULL;
 monster_group[count].name = string_make("***Unclassified***");
 monster_group[count].inc_bases = NULL;
 monster_group[count].inc_glyphs = NULL;
 rf_wipe(monster_group[count].inc_flags);
 monster_group[count].n_inc_bases = 0;
 monster_group[count].max_inc_bases = 0;
 monster_group[count].n_inc_glyphs = 0;
 monster_group[count].max_inc_glyphs = 0;
 /*
	 * Set the others, restoring the order they had in the data file.
	 * Release the memory for the linked list (but ot pointed to data
	 * as ownership for that is transferred to the flat array).
	 */
 cursor = s->categories;
 while (cursor) {
  struct ui_monster_category *src = cursor;
  cursor = cursor->next;
  --count;
  monster_group[count].next = monster_group + count + 1;
  monster_group[count].name = src->name;
  monster_group[count].inc_bases = src->inc_bases;
  monster_group[count].inc_glyphs = src->inc_glyphs;
  rf_copy(monster_group[count].inc_flags, src->inc_flags);
  monster_group[count].n_inc_bases = src->n_inc_bases;
  monster_group[count].max_inc_bases = src->max_inc_bases;
  monster_group[count].n_inc_glyphs = src->n_inc_glyphs;
  monster_group[count].max_inc_glyphs = src->max_inc_glyphs;
  mem_free(src);
 }
 mem_free(s);
 parser_destroy(p);
 return 0;
}
static void cleanup_ui_knowledge_parsed_data(void)
{
 int i;
 for (i = 0; i < n_monster_group; ++i) {
  string_free((char*) monster_group[i].name);
  mem_free(monster_group[i].inc_bases);
  mem_free(monster_group[i].inc_glyphs);
 }
 mem_free(monster_group);
 monster_group = NULL;
 n_monster_group = 0;
}
/**
 * ------------------------------------------------------------------------
 * Main knowledge menus
 * ------------------------------------------------------------------------ */
static void do_cmd_knowledge_scores(const char *name, int row)
{
 show_scores();
}
static void do_cmd_knowledge_history(const char *name, int row)
{
 history_display();
}
/**
 * Definition of the "player knowledge" menu.
 */
static menu_action knowledge_actions[] =
{
{ 0, 0, "Display object knowledge", textui_browse_object_knowledge },
{ 0, 0, "Display rune knowledge", do_cmd_knowledge_runes },
{ 0, 0, "Display artifact knowledge", do_cmd_knowledge_artifacts },
{ 0, 0, "Display special item knowledge", do_cmd_knowledge_ego_items },
{ 0, 0, "Display monster knowledge", do_cmd_knowledge_monsters },
{ 0, 0, "Display feature knowledge", do_cmd_knowledge_features },
{ 0, 0, "Display trap knowledge", do_cmd_knowledge_traps },
{ 0, 0, "Display hall of fame", do_cmd_knowledge_scores },
{ 0, 0, "Display character history", do_cmd_knowledge_history },
};
static struct menu knowledge_menu;
void textui_knowledge_init(void)
{
 /* Initialize the menus */
 struct menu *menu = &knowledge_menu;
 menu_init(menu, MN_SKIN_SCROLL, menu_find_iter(MN_ITER_ACTIONS));
 menu_setpriv(menu, N_ELEMENTS(knowledge_actions), knowledge_actions);
 menu->title = "Display current knowledge";
 menu->selections = all_letters_nohjkl;
 /* initialize other static variables */
 if (run_parser(&ui_knowledge_parser) != PARSE_ERROR_NONE) {
  quit_fmt("Encountered error parsing ui_knowledge.txt");
 }
 if (!obj_group_order) {
  int i;
  int gid = -1;
  obj_group_order = mem_zalloc((TV_MAX + 1) * sizeof(int));
  /* Allow for missing values */
  for (i = 0; i < TV_MAX; i++)
   obj_group_order[i] = -1;
  for (i = 0; 0 != object_text_order[i].tval; i++) {
   if (kb_info[object_text_order[i].tval].num_svals == 0) continue;
   if (object_text_order[i].name) gid = i;
   obj_group_order[object_text_order[i].tval] = gid;
  }
 }
}
void textui_knowledge_cleanup(void)
{
 mem_free(obj_group_order);
 obj_group_order = NULL;
 cleanup_parser(&ui_knowledge_parser);
}
/**
 * Display the "player knowledge" menu, greying out items that won't display
 * anything.
 */
void textui_browse_knowledge(void)
{
 int i;
 region knowledge_region = { 0, 0, -1, 2 + (int)N_ELEMENTS(knowledge_actions) };
 /* Artifacts */
 if (collect_known_artifacts(NULL, 0) > 0)
  knowledge_actions[1].flags = 0;
 else
  knowledge_actions[1].flags = MN_ACT_GRAYED;
 /* Ego items */
 knowledge_actions[2].flags = MN_ACT_GRAYED;
 for (i = 0; i < z_info->e_max; i++) {
  if (e_info[i].everseen || OPT(player, cheat_xtra)) {
   knowledge_actions[2].flags = 0;
   break;
  }
 }
 /* Monsters */
 if (count_known_monsters() > 0)
  knowledge_actions[3].flags = 0;
 else
  knowledge_actions[3].flags = MN_ACT_GRAYED;
 screen_save();
 menu_layout(&knowledge_menu, &knowledge_region);
 clear_from(0);
 menu_select(&knowledge_menu, 0, false);
 screen_load();
}
/**
 * ------------------------------------------------------------------------
 * Other knowledge functions
 * ------------------------------------------------------------------------ */
/**
 * Recall the most recent message
 */
void do_cmd_message_one(void)
{
 /* Recall one message XXX XXX XXX */
 c_prt(message_color(0), format( "> %s", message_str(0)), 0, 0);
}
/**
 * Show previous messages to the user
 *
 * The screen format uses line 0 and 23 for headers and prompts,
 * skips line 1 and 22, and uses line 2 thru 21 for old messages.
 *
 * This command shows you which commands you are viewing, and allows
 * you to "search" for strings in the recall.
 *
 * Note that messages may be longer than 80 characters, but they are
 * displayed using "infinite" length, with a special sub-command to
 * "slide" the virtual display to the left or right.
 *
 * Attempt to only highlight the matching portions of the string.
 */
void do_cmd_messages(void)
{
 ui_event ke;
 bool more = true;
 int i, j, n, q;
 int wid, hgt;
 char shower[80] = "";
 /* Total messages */
 n = messages_num();
 /* Start on first message */
 i = 0;
 /* Start at leftmost edge */
 q = 0;
 /* Get size */
 Term_get_size(&wid, &hgt);
 /* Save screen */
 screen_save();
 /* Process requests until done */
 while (more) {
  /* Clear screen */
  Term_clear();
  /* Dump messages */
  for (j = 0; (j < hgt - 4) && (i + j < n); j++) {
   const char *msg;
   const char *str = message_str(i + j);
   uint8_t attr = message_color(i + j);
   uint16_t count = message_count(i + j);
   if (count == 1)
    msg = str;
   else
    msg = format("%s <%dx>", str, count);
   /* Apply horizontal scroll */
   msg = ((int)strlen(msg) >= q) ? (msg + q) : "";
   /* Dump the messages, bottom to top */
   Term_putstr(0, hgt - 3 - j, -1, attr, msg);
   /* Highlight "shower" */
   if (strlen(shower)) {
    str = msg;
    /* Display matches */
    while ((str = my_stristr(str, shower)) != NULL) {
     int len = strlen(shower);
     /* Display the match */
     Term_putstr(str-msg, hgt - 3 - j, len, COLOUR_YELLOW, str);
     /* Advance */
     str += len;
    }
   }
  }
  /* Display header */
  prt(format("Message recall (%d-%d of %d), offset %d",
       i, i + j - 1, n, q), 0, 0);
  /* Display prompt (not very informative) */
  if (strlen(shower))
   prt("[Movement keys to navigate, '-' for next, '=' to find]",
    hgt - 1, 0);
  else
   prt("[Movement keys to navigate, '=' to find, or ESCAPE to exit]",
    hgt - 1, 0);
  /* Get a command */
  ke = inkey_ex();
  /* Scroll forwards or backwards using mouse clicks */
  if (ke.type == EVT_MOUSE) {
   if (ke.mouse.button == 1) {
    if (ke.mouse.y <= hgt / 2) {
     /* Go older if legal */
     if (i + 20 < n)
      i += 20;
    } else {
     /* Go newer */
     i = (i >= 20) ? (i - 20) : 0;
    }
   } else if (ke.mouse.button == 2) {
    more = false;
   }
  } else if (ke.type == EVT_KBRD) {
   switch (ke.key.code) {
    case ESCAPE:
    {
     more = false;
     break;
    }
    case '=':
    {
     /* Get the string to find */
     prt("Find: ", hgt - 1, 0);
     if (!askfor_aux(shower, sizeof shower, NULL)) continue;
     /* Set to find */
     ke.key.code = '-';
     break;
    }
    case ARROW_LEFT:
    case '4':
    case 'h':
     q = (q >= wid / 2) ? (q - wid / 2) : 0;
     break;
    case ARROW_RIGHT:
    case '6':
    case 'l':
     q = q + wid / 2;
     break;
    case ARROW_UP:
    case '8':
    case 'k':
     if (i + 1 < n) i += 1;
     break;
    case ARROW_DOWN:
    case '2':
    case 'j':
    case KC_ENTER:
     i = (i >= 1) ? (i - 1) : 0;
     break;
    case KC_PGUP:
    case 'p':
    case ' ':
     if (i + 20 < n) i += 20;
     break;
    case KC_PGDOWN:
    case 'n':
     i = (i >= 20) ? (i - 20) : 0;
     break;
   }
  }
  /* Find the next item */
  if (ke.key.code == '-' && strlen(shower)) {
   int16_t z;
   /* Scan messages */
   for (z = i + 1; z < n; z++) {
    /* Search for it */
    if (my_stristr(message_str(z), shower)) {
     /* New location */
     i = z;
     /* Done */
     break;
    }
   }
  }
 }
 /* Load screen */
 screen_load();
}
/**
 * Display inventory
 */
void do_cmd_inven(void)
{
 struct object *obj = NULL;
 int ret = 3;
 if (player->upkeep->inven[0] == NULL) {
  msg("You have nothing in your inventory.");
  return;
 }
 /* Start in "inventory" mode */
 player->upkeep->command_wrk = (USE_INVEN);
 /* Loop this menu until an object context menu says differently */
 while (ret == 3) {
  /* Save screen */
  screen_save();
  /* Get an item to use a context command on (Display the inventory) */
  if (get_item(&obj, "Select Item:",
    "Error in do_cmd_inven(), please report.",
    CMD_NULL, NULL, (USE_EQUIP | USE_INVEN | USE_QUIVER | USE_FLOOR | SHOW_EMPTY | IS_HARMLESS))) {
   /* Load screen */
   screen_load();
   if (obj && obj->kind) {
    /* Track the object */
    track_object(player->upkeep, obj);
    while ((ret = context_menu_object(obj)) == 2);
   }
  } else {
   /* Load screen */
   screen_load();
   ret = -1;
  }
 }
}
/**
 * Display equipment
 */
void do_cmd_equip(void)
{
 struct object *obj = NULL;
 int ret = 3;
 if (!player->upkeep->equip_cnt) {
  msg("You are not wielding or wearing anything.");
  return;
 }
 /* Start in "equipment" mode */
 player->upkeep->command_wrk = (USE_EQUIP);
 /* Loop this menu until an object context menu says differently */
 while (ret == 3) {
  /* Save screen */
  screen_save();
  /* Get an item to use a context command on (Display the equipment) */
  if (get_item(&obj, "Select Item:",
    "Error in do_cmd_equip(), please report.",
    CMD_NULL, NULL, (USE_EQUIP | USE_INVEN | USE_QUIVER | USE_FLOOR | SHOW_EMPTY | IS_HARMLESS))) {
   /* Load screen */
   screen_load();
   if (obj && obj->kind) {
    /* Track the object */
    track_object(player->upkeep, obj);
    while ((ret = context_menu_object(obj)) == 2);
    /* Stay in "equipment" mode */
    player->upkeep->command_wrk = (USE_EQUIP);
   }
  } else {
   /* Load screen */
   screen_load();
   ret = -1;
  }
 }
}
/**
 * Look command
 */
void do_cmd_look(void)
{
 /* Look around */
 if (target_set_interactive(TARGET_LOOK, loc(-1, -1), 0))
 {
  msg("Target Selected.");
 }
}
/**
 * Allow the player to examine other sectors on the map
 */
void do_cmd_locate(void)
{
 int panel_hgt, panel_wid;
 int y1, x1;
 /* Use dimensions that match those in ui-output.c. */
 if (Term == term_screen) {
  panel_hgt = SCREEN_HGT;
  panel_wid = SCREEN_WID;
 } else {
  panel_hgt = Term->hgt / tile_height;
  panel_wid = Term->wid / tile_width;
 }
 /* Bound below to avoid division by zero. */
 panel_hgt = MAX(panel_hgt, 1);
 panel_wid = MAX(panel_wid, 1);
 /* Start at current panel */
 y1 = Term->offset_y;
 x1 = Term->offset_x;
 /* Show panels until done */
 while (1) {
  char tmp_val[80];
  char out_val[160];
  /* Assume no direction */
  int dir = 0;
  /* Get the current panel */
  int y2 = Term->offset_y;
  int x2 = Term->offset_x;
  /* Describe the location */
  if ((y2 == y1) && (x2 == x1)) {
   tmp_val[0] = '\0';
  } else {
   strnfmt(tmp_val, sizeof(tmp_val), "%s%s of",
           ((y2 < y1) ? " north" : (y2 > y1) ? " south" : ""),
           ((x2 < x1) ? " west" : (x2 > x1) ? " east" : ""));
  }
  /* Prepare to ask which way to look */
  strnfmt(out_val, sizeof(out_val),
          "Map sector [%d,%d], which is%s your sector.  Direction?",
          (2 * y2) / panel_hgt, (2 * x2) / panel_wid, tmp_val);
  /* More detail */
  if (OPT(player, center_player)) {
   strnfmt(out_val, sizeof(out_val),
           "Map sector [%d(%02d),%d(%02d)], which is%s your sector.  Direction?",
     (2 * y2) / panel_hgt, (2 * y2) % panel_hgt,
     (2 * x2) / panel_wid, (2 * x2) % panel_wid, tmp_val);
  }
  /* Get a direction */
  while (!dir) {
   struct keypress command = KEYPRESS_NULL;
   /* Get a command (or Cancel) */
   if (!get_com(out_val, (char *)&command.code)) break;
   /* Extract direction */
   dir = target_dir(command);
   /* Error */
   if (!dir) bell();
  }
  /* No direction */
  if (!dir) break;
  /* Apply the motion */
  change_panel(dir);
  /* Handle stuff */
  handle_stuff(player);
 }
 /* Verify panel */
 verify_panel();
}
static int cmp_level(const void *a, const void *b)
{
 uint16_t ia = *(const uint16_t *)a;
 uint16_t ib = *(const uint16_t *)b;
 if (r_info[ia].level < r_info[ib].level)
  return -1;
 return 1;
}
static int cmp_tkill(const void *a, const void *b)
{
 uint16_t ia = *(const uint16_t *)a;
 uint16_t ib = *(const uint16_t *)b;
 if (l_list[ia].tkills < l_list[ib].tkills)
  return -1;
 if (l_list[ia].tkills > l_list[ib].tkills)
  return 1;
 return cmp_level(a, b);
}
static int cmp_pkill(const void *a, const void *b)
{
 uint16_t ia = *(const uint16_t *)a;
 uint16_t ib = *(const uint16_t *)b;
 if (l_list[ia].pkills < l_list[ib].pkills)
  return -1;
 if (l_list[ia].pkills > l_list[ib].pkills)
  return 1;
 return cmp_tkill(a, b);
}
int cmp_monsters(const void *a, const void *b)
{
 return cmp_level(a, b);
}
/**
 * Search the monster, item, and feature types to find the
 * meaning for the given symbol.
 *
 * Note: We currently search items first, then features, then
 * monsters, and we return the first hit for a symbol.
 * This is to prevent mimics and lurkers from matching
 * a symbol instead of the item or feature it is mimicking.
 *
 * Todo: concatenate all matches into buf. This will be much
 * easier once we can loop through item tvals instead of items
 * (see note below.)
 *
 * Todo: Should this take the user's pref files into account?
 */
static void lookup_symbol(char sym, char *buf, size_t max)
{
 int i;
 struct monster_base *base;
 struct monster_race *race;
 /* Look through items */
 /* Note: We currently look through all items, and grab the tval when we
	 * find a match.
	 * It would make more sense to loop through tvals, but then we need to
	 * associate a display character with each tval. */
 for (i = 0; i < z_info->k_max; i++) {
  if (char_matches_key(k_info[i].d_char, sym)) {
   strnfmt(buf, max, "%c - %s.", sym, tval_find_name(k_info[i].tval));
   return;
  }
 }
 /* Look through features */
 /* Note: We need a better way of doing this. Currently '#' matches secret
	 * door, and '^' matches trap door (instead of the more generic "trap"). */
 for (i = 1; i < FEAT_MAX; i++) {
  if (char_matches_key(f_info[i].d_char, sym)) {
   strnfmt(buf, max, "%c - %s.", sym, f_info[i].name);
   return;
  }
 }
 /* Look through monster base templates */
 for (base = rb_info; base; base = base->next) {
  /* Slight hack - P appears twice */
  if (streq(base->name, "Morgoth")) continue;
  if (char_matches_key(base->d_char, sym)) {
   strnfmt(buf, max, "%c - %s.", sym, base->text);
   return;
  }
 }
 /* Look through monster templates */
 for (race = r_info; race; race = race->next) {
  /* Slight hack - P appears twice */
  if (streq(race->name, "Morgoth")) continue;
  if (char_matches_key(race->d_char, sym)) {
   strnfmt(buf, max, "%c - %s.", sym, race->name);
   return;
  }
 }
 /* No matches */
        if (isprint(sym)) {
   strnfmt(buf, max, "%c - Unknown Symbol.", sym);
        } else {
   strnfmt(buf, max, "? - Unknown Symbol.");
        }
 return;
}
/**
 * Identify a character, allow recall of monsters
 *
 * Several "special" responses recall "multiple" monsters:
 *   ^A (all monsters)
 *   ^U (all unique monsters)
 *   ^N (all non-unique monsters)
 *
 * The responses may be sorted in several ways, see below.
 *
 * Note that the player ghosts are ignored, since they do not exist.
 */
void do_cmd_query_symbol(void)
{
 int idx, num;
 char buf[128];
 char sym;
 struct keypress query;
 bool all = false;
 bool uniq = false;
 bool norm = false;
 bool recall = false;
 uint16_t *who;
 /* Get a character, or abort */
 if (!get_com("Enter character to be identified, or control+[ANU]: ", &sym))
  return;
 /* Describe */
 if (sym == KTRL('A')) {
  all = true;
  my_strcpy(buf, "Full monster list.", sizeof(buf));
 } else if (sym == KTRL('U')) {
  all = uniq = true;
  my_strcpy(buf, "Unique monster list.", sizeof(buf));
 } else if (sym == KTRL('N')) {
  all = norm = true;
  my_strcpy(buf, "Non-unique monster list.", sizeof(buf));
 } else {
  lookup_symbol(sym, buf, sizeof(buf));
 }
 /* Display the result */
 prt(buf, 0, 0);
 /* Allocate the "who" array */
 who = mem_zalloc(z_info->r_max * sizeof(uint16_t));
 /* Collect matching monsters */
 for (num = 0, idx = 1; idx < z_info->r_max - 1; idx++) {
  struct monster_race *race = &r_info[idx];
  struct monster_lore *lore = &l_list[idx];
  /* Nothing to recall */
  if (!lore->all_known && !lore->psights)
   continue;
  /* Require non-unique monsters if needed */
  if (norm && rf_has(race->flags, RF_UNIQUE)) continue;
  /* Require unique monsters if needed */
  if (uniq && !rf_has(race->flags, RF_UNIQUE)) continue;
  /* Collect "appropriate" monsters */
  if (all || char_matches_key(race->d_char, sym)) who[num++] = idx;
 }
 /* No monsters to recall */
 if (!num) {
  /* Free the "who" array */
  mem_free(who);
  return;
 }
 /* Prompt */
 put_str("Recall details? (y/k/n): ", 0, 40);
 /* Query */
 query = inkey();
 /* Restore */
 prt(buf, 0, 0);
 /* Interpret the response */
 if (query.code == 'k') {
  /* Sort by kills (and level) */
  sort(who, num, sizeof(*who), cmp_pkill);
 } else if (query.code == 'y' || query.code == 'p') {
  /* Sort by level; accept 'p' as legacy */
  sort(who, num, sizeof(*who), cmp_level);
 } else {
  /* Any unsupported response is "nope, no history please" */
  mem_free(who);
  return;
 }
 /* Start at the end, as the array is sorted lowest to highest */
 idx = num - 1;
 /* Scan the monster memory */
 while (1) {
  textblock *tb;
  /* Extract a race */
  int r_idx = who[idx];
  struct monster_race *race = &r_info[r_idx];
  struct monster_lore *lore = &l_list[r_idx];
  /* Auto-recall */
  monster_race_track(player->upkeep, race);
  /* Do any necessary updates or redraws */
  handle_stuff(player);
  tb = textblock_new();
  lore_title(tb, race);
  textblock_append(tb, " [(r)ecall, ESC]");
  textui_textblock_place(tb, SCREEN_REGION, NULL);
  textblock_free(tb);
  /* Interact */
  while (1) {
   /* Ignore keys during recall presentation, otherwise, the 'r' key
			 * acts like a toggle and instead of a one-off command */
   if (recall)
    lore_show_interactive(race, lore);
   else
    query = inkey();
   /* Normal commands */
   if (query.code != 'r') break;
   /* Toggle recall */
   recall = !recall;
  }
  /* Stop scanning */
  if (query.code == ESCAPE) break;
  /* Move to previous or next monster */
  if (query.code == '-') {
   /* Previous is a step forward in the array */
   idx++;
   /* Wrap if we're at the end of the array */
   if (idx == num) {
    idx = 0;
   }
  } else {
   /* Next is a step back in the array */
   idx--;
   /* Wrap if we're at the start of the array */
   if (idx < 0) {
    idx = num - 1;
   }
  }
 }
 /* Re-display the identity */
 prt(buf, 0, 0);
 /* Free the "who" array */
 mem_free(who);
}
/**
 * Centers the map on the player
 */
void do_cmd_center_map(void)
{
 center_panel();
}
/**
 * Display the main-screen monster list.
 */
void do_cmd_monlist(void)
{
 /* Save the screen and display the list */
 screen_save();
    monster_list_show_interactive(Term->hgt, Term->wid);
 /* Return */
 screen_load();
}
/**
 * Display the main-screen item list.
 */
void do_cmd_itemlist(void)
{
 /* Save the screen and display the list */
 screen_save();
    object_list_show_interactive(Term->hgt, Term->wid);
 /* Return */
 screen_load();
}
/**
 * \file ui-map.c
 * \brief Writing level map info to the screen
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Graphics in a mini-screenshot array
 */
static wchar_t mini_screenshot_char[7][7];
static uint8_t mini_screenshot_attr[7][7];
/**
 * Hack -- Hallucinatory monster
 */
static void hallucinatory_monster(int midx, int *a, wchar_t *c)
{
 /* Get the image monster */
 struct monster_race *race = cave_monster(cave, midx)->image_race;
 /* Skip non-entries */
 if (!race->name) return;
 /* Retrieve attr/char */
 *a = monster_x_attr[race->ridx];
 *c = monster_x_char[race->ridx];
}
/**
 * Hack -- Hallucinatory monster
 */
static void image_monster(int *a, wchar_t *c)
{
 while (1) {
  /* Select a random monster */
  struct monster_race *race = &r_info[randint0(z_info->r_max)];
  /* Skip non-entries */
  if (!race->name) continue;
  /* Retrieve attr/char */
  *a = monster_x_attr[race->ridx];
  *c = monster_x_char[race->ridx];
  return;
 }
}
/**
 * Hack -- Hallucinatory object
 */
static void image_object(int *a, wchar_t *c)
{
 while (1) {
  /* Select a random object */
  struct object_kind *kind = &k_info[randint0(z_info->k_max - 1) + 1];
  /* Skip non-entries */
  if (!kind->name) continue;
  /* Retrieve attr/char (HACK - without flavors) */
  *a = kind_x_attr[kind->kidx];
  *c = kind_x_char[kind->kidx];
  /* HACK - Skip empty entries */
  if (*a == 0 || *c == 0) continue;
  return;
 }
}
/**
 * Get the graphics of a listed trap.
 *
 * We should probably have better handling of stacked traps, but that can
 * wait until we do, in fact, have stacked traps under normal conditions.
 */
static void get_trap_graphics(struct chunk *c, struct grid_data *g, int *a,
         wchar_t *w)
{
    /* Trap is visible */
    if (trf_has(g->trap->flags, TRF_VISIBLE) ||
  trf_has(g->trap->flags, TRF_GLYPH)) {
  /* Get the graphics */
  *a = trap_x_attr[g->lighting][g->trap->kind->tidx];
  *w = trap_x_char[g->lighting][g->trap->kind->tidx];
    }
}
/**
 * Apply text lighting effects
 */
static void grid_get_attr(struct grid_data *g, int *a)
{
 /* Save the high-bit, since it's used for attr inversion in GCU */
 int a0 = *a & 0x80;
 /* Remove the high bit so we can add it back again at the end */
 *a = (*a & 0x7F);
 /* Play with fg colours for terrain affected by torchlight */
 if (feat_is_torch(g->f_idx)) {
  /* Brighten if torchlit, darken if out of LoS, super dark for UNLIGHT */
  switch (g->lighting) {
   case LIGHTING_TORCH: *a = get_color(*a, ATTR_LIGHT, 1); break;
   case LIGHTING_LIT: *a = get_color(*a, ATTR_DARK, 1); break;
   case LIGHTING_DARK: *a = get_color(*a, ATTR_DARK, 2); break;
   default: break;
  }
 }
 /* Add the attr inversion back for GCU */
 if (a0) {
  *a = a0 | *a;
 }
 /* Hybrid or block walls */
 if (use_graphics == GRAPHICS_NONE &&
  (feat_is_wall(g->f_idx) || feat_is_chasm(g->f_idx))) {
  if (OPT(player, hybrid_walls))
   *a = *a + (MULT_BG * BG_DARK);
  else if (OPT(player, solid_walls))
   *a = *a + (MULT_BG * BG_SAME);
 }
}
/**
 * This function takes a pointer to a grid info struct describing the 
 * contents of a grid location (as obtained through the function map_info)
 * and fills in the character and attr pairs for display.
 *
 * ap and cp are filled with the attr/char pair for the monster, object or 
 * floor tile that is at the "top" of the grid (monsters covering objects, 
 * which cover floor, assuming all are present).
 *
 * tap and tcp are filled with the attr/char pair for the floor, regardless
 * of what is on it.  This can be used by graphical displays with
 * transparency to place an object onto a floor tile, is desired.
 *
 * Any lighting effects are also applied to these pairs, clear monsters allow
 * the underlying colour or feature to show through (ATTR_CLEAR and
 * CHAR_CLEAR), multi-hued colour-changing (ATTR_MULTI) is applied, and so on.
 * Technically, the flag "CHAR_MULTI" is supposed to indicate that a monster 
 * looks strange when examined, but this flag is currently ignored.
 *
 * NOTES:
 * This is called pretty frequently, whenever a grid on the map display
 * needs updating, so don't overcomplicate it.
 *
 * The "zero" entry in the feature/object/monster arrays are
 * used to provide "special" attr/char codes, with "monster zero" being
 * used for the player attr/char, "object zero" being used for the "pile"
 * attr/char, and "feature zero" being used for the "darkness" attr/char.
 *
 * TODO:
 * The transformations for tile colors, or brightness for the 16x16
 * tiles should be handled differently.  One possibility would be to
 * extend feature_type with attr/char definitions for the different states.
 * This will probably be done outside of the current text->graphics mappings
 * though.
 */
void grid_data_as_text(struct grid_data *g, int *ap, wchar_t *cp, int *tap,
        wchar_t *tcp)
{
 struct feature *feat = &f_info[g->f_idx];
 int a = feat_x_attr[g->lighting][feat->fidx];
 wchar_t c = feat_x_char[g->lighting][feat->fidx];
 /* Get the colour for ASCII */
 if (use_graphics == GRAPHICS_NONE) {
  grid_get_attr(g, &a);
  if (g->rage) a = COLOUR_RED + (MULT_BG * (a / MULT_BG));
 }
 /* Save the terrain info for the transparency effects */
 (*tap) = a;
 (*tcp) = c;
 /* There is a trap in this grid, and we are not hallucinating */
 if (g->trap && (!g->hallucinate)) {
     /* Change graphics to indicate visible traps */
     get_trap_graphics(cave, g, &a, &c);
 }
 /* If there's an object, deal with that. */
 if (g->first_kind) {
  if (g->hallucinate) {
   /* Just pick a random object to display. */
   image_object(&a, &c);
  } else if (g->multiple_objects) {
   /* Get the "pile" feature instead */
   a = object_kind_attr(pile_kind);
   c = object_kind_char(pile_kind);
  } else {
   /* Normal attr and char, check for glowing */
   a = (g->first_art) ? g->first_art->d_attr :
    object_kind_attr(g->first_kind);
   if (g->glow) {
    if (use_graphics == GRAPHICS_NONE
      || !(a & 0x80)) {
     a = COLOUR_L_BLUE;
    } else if (glow_x_attr & 0x80) {
     a |= GRAPHICS_GLOW_MASK;
    }
   }
   c = object_kind_char(g->first_kind);
  }
  if (g->rage && (use_graphics == GRAPHICS_NONE
    || !(a & 0x80))) a = COLOUR_RED;
 }
 /* Handle monsters, the player and trap borders */
 if (g->m_idx > 0) {
  struct monster *mon = cave_monster(cave, g->m_idx);
  if (g->hallucinate) {
   if (g->m_idx < z_info->r_max) {
    /* Show this monster's image race */
    hallucinatory_monster(g->m_idx, &a, &c);
   } else {
    /* Just pick a random monster to display. */
    image_monster(&a, &c);
   }
  } else if (monster_is_listened(mon)) {
   /* Simplest possible hack - NRM */
   a = COLOUR_SLATE;
   c = '*';
  } else {
   uint8_t da;
   wchar_t dc;
   /* Desired attr & char */
   da = monster_x_attr[mon->race->ridx];
   dc = monster_x_char[mon->race->ridx];
   /* Special handling of attrs and/or chars */
   if (da & 0x80) {
    /* Special attr/char codes */
    a = da;
    c = dc;
   } else if (rf_has(mon->race->flags, RF_ATTR_MULTI) ||
        rf_has(mon->race->flags, RF_ATTR_FLICKER)) {
    /* Multi-hued monster */
    a = mon->attr ? mon->attr : da;
    c = dc;
   } else if (!flags_test(mon->race->flags, RF_SIZE, RF_CHAR_CLEAR,
           FLAG_END)) {
    /* Normal monster (not "clear" in any way) */
    a = da;
    /* Desired attr & char. da is not used, should a be set to it?*/
    /*da = monster_x_attr[mon->race->ridx];*/
    dc = monster_x_char[mon->race->ridx];
    c = dc;
   } else if (a & 0x80) {
    /* Hack -- Bizarre grid under monster */
    a = da;
    c = dc;
   } else if (!rf_has(mon->race->flags, RF_CHAR_CLEAR)) {
    /* Normal char, Clear attr, monster */
    c = dc;
   }
   /* Store the drawing attr so we can use it elsewhere */
   mon->attr = a;
   if (use_graphics == GRAPHICS_NONE && OPT(player, highlight_unwary)
    && (mon->alertness < ALERTNESS_ALERT)) {
    a = a + (MULT_BG * BG_DARK);
   }
   if (use_graphics != GRAPHICS_NONE
     && (a & 0x80)
     && mon->alertness >= ALERTNESS_ALERT
     && alert_x_attr & 0x80) {
    a |= GRAPHICS_ALERT_MASK;
   }
   if (g->rage && (use_graphics == GRAPHICS_NONE
     || !(a & 0x80))) a = COLOUR_RED;
  }
 } else if (g->is_player) {
  struct monster_race *race = &r_info[0];
  /* Get the "player" attr */
  a = monster_x_attr[race->ridx];
  if (!(a & 0x80)) {
   a = health_attr(player->chp, player->mhp);
  }
  /* Get the "player" char */
  c = monster_x_char[race->ridx];
 }
 /* Result */
 (*ap) = a;
 (*cp) = c;
}
/**
 * Get dimensions of a small-scale map (i.e. display_map()'s result).
 * \param term Is the terminal displaying the map.
 * \param chunk Is the chunk to display.
 * \param tw Is the tile width in characters.
 * \param th Is the tile height in characters.
 * \param mw *mw is set to the width of the small-scale map.
 * \param mh *mh is set to the height of the small-scale map.
 */
static void get_minimap_dimensions(term *t, const struct chunk *c,
 int tw, int th, int *mw, int *mh)
{
 int map_height = t->hgt - 2;
 int map_width = t->wid - 2;
 int cave_height = c->height;
 int cave_width = c->width;
 int remainder;
 if (th > 1) {
  /*
		 * Round cave height up to a multiple of the tile height
		 * (ideally want no information truncated).
		 */
  remainder = cave_height % th;
  if (remainder > 0) {
   cave_height += th - remainder;
  }
  /*
		 * Round map height down to a multiple of the tile height
		 * (don't want partial tiles overwriting the map borders).
		 */
  map_height -= map_height % th;
 }
 if (tw > 1) {
  /* As above but for the width. */
  remainder = cave_width % tw;
  if (remainder > 0) {
   cave_width += tw - remainder;
  }
  map_width -= map_width % tw;
 }
 *mh = MIN(map_height, cave_height);
 *mw = MIN(map_width, cave_width);
}
/**
 * Move the cursor to a given map location.
 */
static void move_cursor_relative_map(int y, int x)
{
 int ky, kx;
 term *old;
 int j;
 /* Scan windows */
 for (j = 0; j < ANGBAND_TERM_MAX; j++) {
  term *t = angband_term[j];
  /* No window */
  if (!t) continue;
  /* No relevant flags */
  if (!(window_flag[j] & (PW_MAPS))) continue;
  if (window_flag[j] & PW_MAP) {
   /* Be consistent with display_map(). */
   int map_width, map_height;
   get_minimap_dimensions(t, cave, tile_width,
    tile_height, &map_width, &map_height);
   ky = (y * map_height) / cave->height;
   if (tile_height > 1) {
    ky = ky - (ky % tile_height) + 1;
   } else {
    ++ky;
   }
   kx = (x * map_width) / cave->width;
   if (tile_width > 1) {
    kx = kx - (kx % tile_width) + 1;
   } else {
    ++kx;
   }
  } else {
   /* Location relative to panel */
   ky = y - t->offset_y;
   if (tile_height > 1)
    ky = tile_height * ky;
   kx = x - t->offset_x;
   if (tile_width > 1)
    kx = tile_width * kx;
  }
  /* Verify location */
  if ((ky < 0) || (ky >= t->hgt)) continue;
  if ((kx < 0) || (kx >= t->wid)) continue;
  /* Go there */
  old = Term;
  Term_activate(t);
  (void)Term_gotoxy(kx, ky);
  Term_activate(old);
 }
}
/**
 * Move the cursor to a given map location.
 *
 * The main screen will always be at least 24x80 in size.
 */
void move_cursor_relative(int y, int x)
{
 int ky, kx;
 int vy, vx;
 /* Move the cursor on map sub-windows */
 move_cursor_relative_map(y, x);
 /* Location relative to panel */
 ky = y - Term->offset_y;
 /* Verify location */
 if ((ky < 0) || (ky >= SCREEN_HGT)) return;
 /* Location relative to panel */
 kx = x - Term->offset_x;
 /* Verify location */
 if ((kx < 0) || (kx >= SCREEN_WID)) return;
 /* Location in window */
 vy = ky + ROW_MAP;
 /* Location in window */
 vx = kx + COL_MAP;
 if (tile_width > 1)
  vx += (tile_width - 1) * kx;
 if (tile_height > 1)
  vy += (tile_height - 1) * ky;
 /* Go there */
 (void)Term_gotoxy(vx, vy);
}
/**
 * Display an attr/char pair at the given map location
 *
 * Note the inline use of "panel_contains()" for efficiency.
 *
 * Note the use of "Term_queue_char()" for efficiency.
 */
static void print_rel_map(wchar_t c, uint8_t a, int y, int x)
{
 int ky, kx;
 int j;
 /* Scan windows */
 for (j = 0; j < ANGBAND_TERM_MAX; j++) {
  term *t = angband_term[j];
  /* No window */
  if (!t) continue;
  /* No relevant flags */
  if (!(window_flag[j] & (PW_MAPS))) continue;
  if (window_flag[j] & PW_MAP) {
   /* Be consistent with display_map(). */
   int map_width, map_height;
   get_minimap_dimensions(t, cave, tile_width,
    tile_height, &map_width, &map_height);
   kx = (x * map_width) / cave->width;
   ky = (y * map_height) / cave->height;
   if (tile_width > 1) {
    kx = kx - (kx % tile_width) + 1;
   } else {
    ++kx;
   }
   if (tile_height > 1) {
    ky = ky - (ky % tile_height) + 1;
   } else {
    ++ky;
   }
  } else {
   /* Location relative to panel */
   ky = y - t->offset_y;
   if (tile_height > 1) {
    ky = tile_height * ky;
    if (ky + 1 >= t->hgt) continue;
   }
   kx = x - t->offset_x;
   if (tile_width > 1) {
    kx = tile_width * kx;
    if (kx + 1 >= t->wid) continue;
   }
  }
  /* Verify location */
  if ((ky < 0) || (ky >= t->hgt)) continue;
  if ((kx < 0) || (kx >= t->wid)) continue;
  /* Hack -- Queue it */
  Term_queue_char(t, kx, ky, a, c, 0, 0);
  if ((tile_width > 1) || (tile_height > 1))
   /*
			 * The overhead view can make use of the last row in
			 * the terminal.  Others leave it be.
			 */
   Term_big_queue_char(t, kx, ky, t->hgt -
    ((window_flag[j] & PW_OVERHEAD) ? 0 : ROW_BOTTOM_MAP),
    a, c, 0, 0);
 }
}
/**
 * Display an attr/char pair at the given map location
 *
 * Note the inline use of "panel_contains()" for efficiency.
 *
 * Note the use of "Term_queue_char()" for efficiency.
 *
 * The main screen will always be at least 24x80 in size.
 */
void print_rel(wchar_t c, uint8_t a, int y, int x)
{
 int ky, kx;
 int vy, vx;
 /* Print on map sub-windows */
 print_rel_map(c, a, y, x);
 /* Location relative to panel */
 ky = y - Term->offset_y;
 /* Verify location */
 if ((ky < 0) || (ky >= SCREEN_HGT)) return;
 /* Location relative to panel */
 kx = x - Term->offset_x;
 /* Verify location */
 if ((kx < 0) || (kx >= SCREEN_WID)) return;
 /* Get right position */
 vx = COL_MAP + (tile_width * kx);
 vy = ROW_MAP + (tile_height * ky);
 /* Hack -- Queue it */
 Term_queue_char(Term, vx, vy, a, c, 0, 0);
 if ((tile_width > 1) || (tile_height > 1))
  Term_big_queue_char(Term, vx, vy, ROW_MAP + SCREEN_ROWS,
   a, c, 0, 0);
}
static void prt_map_aux(void)
{
 int a, ta;
 wchar_t c, tc;
 struct grid_data g;
 int y, x;
 int vy, vx;
 int ty, tx;
 int j;
 /* Scan windows */
 for (j = 0; j < ANGBAND_TERM_MAX; j++) {
  term *t = angband_term[j];
  int clipy;
  /* No window */
  if (!t) continue;
  /* No relevant flags */
  if (!(window_flag[j] & (PW_MAPS))) continue;
  if (window_flag[j] & PW_MAP) {
   term *old = Term;
   Term_activate(t);
   display_map(NULL, NULL);
   Term_activate(old);
   continue;
  }
  /* Assume screen */
  ty = t->offset_y + (t->hgt / tile_height);
  tx = t->offset_x + (t->wid / tile_width);
  /*
		 * The overhead view can use the last row of the terminal.
		 * Others can not.
		 */
  clipy = t->hgt - ((window_flag[j] & PW_OVERHEAD) ? 0 : ROW_BOTTOM_MAP);
  /* Dump the map */
  for (y = t->offset_y, vy = 0; y < ty; vy += tile_height, y++) {
   for (x = t->offset_x, vx = 0; x < tx; vx += tile_width, x++) {
    /* Check bounds */
    if (!square_in_bounds(cave, loc(x, y))) {
     Term_queue_char(t, vx, vy,
      COLOUR_WHITE, ' ',
      0, 0);
     if (tile_width > 1 || tile_height > 1) {
      Term_big_queue_char(t, vx, vy,
       clipy, COLOUR_WHITE, ' ', 0, 0);
     }
     continue;
    }
    /* Determine what is there */
    map_info(loc(x, y), &g);
    grid_data_as_text(&g, &a, &c, &ta, &tc);
    Term_queue_char(t, vx, vy, a, c, ta, tc);
    if ((tile_width > 1) || (tile_height > 1))
     Term_big_queue_char(t, vx, vy, clipy,
      255, -1, 0, 0);
   }
   /* Clear partial tile at the end of each line. */
   for (; vx < t->wid; ++vx) {
    Term_queue_char(t, vx, vy, COLOUR_WHITE,
     ' ', 0, 0);
   }
  }
  /* Clear row of partial tiles at the bottom. */
  for (; vy < t->hgt; ++vy) {
   for (vx = 0; vx < t->wid; ++vx) {
    Term_queue_char(t, vx, vy, COLOUR_WHITE,
     ' ', 0, 0);
   }
  }
 }
}
/**
 * Redraw (on the screen) the current map panel
 *
 * Note the inline use of "light_spot()" for efficiency.
 *
 * The main screen will always be at least 24x80 in size.
 */
void prt_map(void)
{
 int a, ta;
 wchar_t c, tc;
 struct grid_data g;
 int y, x;
 int vy, vx;
 int ty, tx;
 int clipy;
 /* Redraw map sub-windows */
 prt_map_aux();
 /* Assume screen */
 ty = Term->offset_y + SCREEN_HGT;
 tx = Term->offset_x + SCREEN_WID;
 /* Avoid overwriting the last row with padding for big tiles. */
 clipy = ROW_MAP + SCREEN_ROWS;
 /* Dump the map */
 for (y = Term->offset_y, vy = ROW_MAP; y < ty; vy += tile_height, y++)
  for (x = Term->offset_x, vx = COL_MAP; x < tx; vx += tile_width, x++) {
   /* Check bounds */
   if (!square_in_bounds(cave, loc(x, y))) continue;
   /* Determine what is there */
   map_info(loc(x, y), &g);
   grid_data_as_text(&g, &a, &c, &ta, &tc);
   /* Hack -- Queue it */
   Term_queue_char(Term, vx, vy, a, c, ta, tc);
   if ((tile_width > 1) || (tile_height > 1))
    Term_big_queue_char(Term, vx, vy, clipy, a, c,
     COLOUR_WHITE, L' ');
  }
}
/**
 * Display a "small-scale" map of the dungeon in the active Term.
 *
 * Note that this function must "disable" the special lighting effects so
 * that the "priority" function will work.
 *
 * Note the use of a specialized "priority" function to allow this function
 * to work with any graphic attr/char mappings, and the attempts to optimize
 * this function where possible.
 *
 * If "cy" and "cx" are not NULL, then returns the screen location at which
 * the player was displayed, so the cursor can be moved to that location,
 * and restricts the horizontal map size to SCREEN_WID.  Otherwise, nothing
 * is returned (obviously), and no restrictions are enforced.
 */
void display_map(int *cy, int *cx)
{
 int map_hgt, map_wid;
 int row, col;
 int x, y;
 struct grid_data g;
 int a, ta;
 wchar_t c, tc;
 uint8_t tp;
 struct monster_race *race = &r_info[0];
 /* Priority array */
 uint8_t **mp = mem_zalloc(cave->height * sizeof(uint8_t*));
 for (y = 0; y < cave->height; y++)
  mp[y] = mem_zalloc(cave->width * sizeof(uint8_t));
 /* Desired map height */
 get_minimap_dimensions(Term, cave, tile_width, tile_height,
  &map_wid, &map_hgt);
 /* Prevent accidents */
 if ((map_wid < 1) || (map_hgt < 1)) {
  for (y = 0; y < cave->height; y++)
   mem_free(mp[y]);
  mem_free(mp);
  return;
 }
 /* Nothing here */
 a = COLOUR_WHITE;
    c = L' ';
 ta = COLOUR_WHITE;
 tc = L' ';
 /* Draw a box around the edge of the term */
 window_make(0, 0, map_wid + 1, map_hgt + 1);
 /* Clear outside that boundary. */
 if (map_wid + 1 < Term->wid - 1) {
  for (y = 0; y < map_hgt + 1; y++) {
   Term_erase(map_wid + 2, y, Term->wid - map_wid - 2);
  }
 }
 if (map_hgt + 1 < Term->hgt - 1) {
  for (y = map_hgt + 2; y < Term->hgt; y++) {
   Term_erase(0, y, Term->wid);
  }
 }
 /* Analyze the actual map */
 for (y = 0; y < cave->height; y++) {
  row = (y * map_hgt) / cave->height;
  if (tile_height > 1) row = row - (row % tile_height);
  for (x = 0; x < cave->width; x++) {
   col = (x * map_wid) / cave->width;
   if (tile_width > 1) col = col - (col % tile_width);
   /* Get the attr/char at that map location */
   map_info(loc(x, y), &g);
   grid_data_as_text(&g, &a, &c, &ta, &tc);
   /* Get the priority of that attr/char */
   tp = f_info[g.f_idx].priority;
   /* Stuff on top of terrain gets higher priority */
   if ((a != ta) || (c != tc)) tp = 20;
   /* Save "best" */
   if (mp[row][col] < tp) {
    /* Hack - make every grid on the map lit */
    g.lighting = LIGHTING_LIT;
    grid_data_as_text(&g, &a, &c, &ta, &tc);
    Term_queue_char(Term, col + 1, row + 1, a, c, ta, tc);
    if ((tile_width > 1) || (tile_height > 1))
     Term_big_queue_char(Term, col + 1,
      row + 1, Term->hgt - 1,
      255, -1, 0, 0);
    /* Save priority */
    mp[row][col] = tp;
   }
  }
 }
 /*** Display the player ***/
 /* Player location */
 row = (player->grid.y * map_hgt / cave->height);
 col = (player->grid.x * map_wid / cave->width);
 if (tile_width > 1)
  col = col - (col % tile_width);
 if (tile_height > 1)
  row = row - (row % tile_height);
 /* Get the terrain at the player's spot. */
 map_info(player->grid, &g);
 g.lighting = LIGHTING_LIT;
 grid_data_as_text(&g, &a, &c, &ta, &tc);
 /* Get the "player" tile */
 a = monster_x_attr[race->ridx];
 c = monster_x_char[race->ridx];
 /* Draw the player */
 Term_queue_char(Term, col + 1, row + 1, a, c, ta, tc);
 if ((tile_width > 1) || (tile_height > 1))
  Term_big_queue_char(Term, col + 1, row + 1, Term->hgt - 1,
   255, -1, 0, 0);
 /* Return player location */
 if (cy != NULL) (*cy) = row + 1;
 if (cx != NULL) (*cx) = col + 1;
 for (y = 0; y < cave->height; y++)
  mem_free(mp[y]);
 mem_free(mp);
}
/**
 * Display a "small-scale" map of the dungeon.
 *
 * Note that the "player" is always displayed on the map.
 */
void do_cmd_view_map(void)
{
 int cy, cx;
 uint8_t w, h;
 const char *prompt = "Hit any key to continue";
 if (Term->view_map_hook) {
  (*(Term->view_map_hook))(Term);
  return;
 }
 /* Save screen */
 screen_save();
 /* Note */
 prt("Please wait...", 0, 0);
 /* Flush */
 Term_fresh();
 /* Clear the screen */
 Term_clear();
 /* store the tile multipliers */
 w = tile_width;
 h = tile_height;
 tile_width = 1;
 tile_height = 1;
 /* Display the map */
 display_map(&cy, &cx);
 /* Show the prompt */
 put_str(prompt, Term->hgt - 1, Term->wid / 2 - strlen(prompt) / 2);
 /* Highlight the player */
 Term_gotoxy(cx, cy);
 /* Get any key */
 (void)anykey();
 /* Restore the tile multipliers */
 tile_width = w;
 tile_height = h;
 /* Load screen */
 screen_load();
}
/**
 * Record a mini screenshot
 */
void mini_screenshot(game_event_type type, game_event_data *data, void *user)
{
 int x, y;
 /* Populate the arrays */
 if (!player->escaped) {
  for (y = -3; y <= 3; y++) {
   for (x = -3; x <= 3; x++) {
    struct grid_data g;
    int a, ta;
    wchar_t c, tc;
    struct loc grid = loc(player->grid.x + x, player->grid.y + y);
    if (square_in_bounds(cave, grid)) {
     map_info(grid, &g);
     grid_data_as_text(&g, &a, &c, &ta, &tc);
     mini_screenshot_char[y + 3][x + 3] = c;
     mini_screenshot_attr[y + 3][x + 3] = a;
    } else {
     mini_screenshot_char[y + 3][x + 3] = ' ';
     mini_screenshot_attr[y + 3][x + 3] = COLOUR_DARK;
    }
   }
  }
 } else {
  for (y = -3; y <= 3; y++) {
   for (x = -3; x <= 3; x++) {
    /* Grass */
    mini_screenshot_char[y + 3][x + 3] = '.';
    mini_screenshot_attr[y + 3][x + 3] = COLOUR_L_GREEN;
   }
  }
  /* River */
  mini_screenshot_char[0][1] = '~';
  mini_screenshot_attr[0][1] = COLOUR_BLUE;
  mini_screenshot_char[0][2] = '~';
  mini_screenshot_attr[0][2] = COLOUR_BLUE;
  mini_screenshot_char[1][2] = '~';
  mini_screenshot_attr[1][2] = COLOUR_L_BLUE;
  mini_screenshot_char[1][3] = '~';
  mini_screenshot_attr[1][3] = COLOUR_BLUE;
  mini_screenshot_char[1][4] = '~';
  mini_screenshot_attr[1][4] = COLOUR_L_BLUE;
  mini_screenshot_char[2][4] = '~';
  mini_screenshot_attr[2][4] = COLOUR_BLUE;
  mini_screenshot_char[2][5] = '~';
  mini_screenshot_attr[2][5] = COLOUR_BLUE;
  mini_screenshot_char[3][5] = '~';
  mini_screenshot_attr[3][5] = COLOUR_L_BLUE;
  mini_screenshot_char[3][6] = '~';
  mini_screenshot_attr[3][6] = COLOUR_BLUE;
  /* Trees */
  mini_screenshot_char[4][1] = '+';
  mini_screenshot_attr[4][1] = COLOUR_GREEN;
  mini_screenshot_char[6][4] = '+';
  mini_screenshot_attr[6][4] = COLOUR_GREEN;
  /* Player */
  mini_screenshot_char[3][3] = '@';
  mini_screenshot_attr[3][3] = COLOUR_WHITE;
 }
}
void prt_mini_screenshot(int col, int row)
{
 int x, y;
 for (y = 0; y <= 6; y++) {
  for (x = 0; x <= 6; x++) {
   Term_putch(col + x, row + y, mini_screenshot_attr[y][x],
        mini_screenshot_char[y][x]);
  }
 }
}
void file_mini_screenshot(ang_file *fff)
{
 int x, y;
 for (y = 0; y <= 6; y++) {
  file_putf(fff, "  ");
  for (x = 0; x <= 6; x++) {
   /* Ugly hack to deal with floors */
   uint8_t c = (mini_screenshot_char[y][x] < 32) ?
    '.' : mini_screenshot_char[y][x];
   file_putf(fff, "%c", c);
  }
  file_putf(fff, "\n");
 }
}
/**
 * \file ui-menu.c
 * \brief Generic menu interaction functions
 *
 * Copyright (c) 2007 Pete Mack
 * Copyright (c) 2010 Andi Sidwell
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Cursor colours
 */
const uint8_t curs_attrs[3][2] =
{
 { COLOUR_SLATE, COLOUR_BLUE }, /* Greyed row */
 { COLOUR_WHITE, COLOUR_L_BLUE }, /* Valid row */
 { COLOUR_RED, COLOUR_L_RED } /* Valid row under extra conditions */
};
/**
 * Some useful constants
 */
const char lower_case[] = "abcdefghijklmnopqrstuvwxyz";
const char upper_case[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
const char all_letters[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
const char all_letters_nohjkl[] = "abcdefgimnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
/**
 * Forward declarations
 */
static void display_menu_row(struct menu *menu, int pos, int top,
        bool cursor, int row, int col, int width);
static bool menu_calc_size(struct menu *menu);
static bool is_valid_row(struct menu *menu, int cursor);
static bool no_valid_row(struct menu *menu, int count);
/**
 * Display an event, with possible preference overrides
 */
static void display_action_aux(menu_action *act, uint8_t color,
  int row, int col, int wid)
{
 /* TODO: add preference support */
 /* TODO: wizard mode should show more data */
 Term_erase(col, row, wid);
 if (act->name)
  Term_putstr(col, row, wid, color, act->name);
}
/* ------------------------------------------------------------------------
 * MN_ACTIONS HELPER FUNCTIONS
 *
 * MN_ACTIONS is the type of menu iterator that displays a simple list of
 * menu_actions.
 * ------------------------------------------------------------------------ */
static char menu_action_tag(struct menu *m, int oid)
{
 menu_action *acts = menu_priv(m);
 return acts[oid].tag;
}
static int menu_action_valid(struct menu *m, int oid)
{
 menu_action *acts = menu_priv(m);
 if (acts[oid].flags & MN_ACT_HIDDEN)
  return MN_ROW_HIDDEN;
 if (acts[oid].flags & MN_ACT_MAYBE)
  return MN_ROW_MAYBE;
 return acts[oid].name ? MN_ROW_VALID : MN_ROW_INVALID;
}
static void menu_action_display(struct menu *m, int oid, bool cursor, int row, int col, int width)
{
 menu_action *acts = menu_priv(m);
 uint8_t act = acts[oid].flags & MN_ACT_GRAYED ? 0 :
  (acts[oid].flags & MN_ACT_MAYBE ? 2 : 1);
 uint8_t color = curs_attrs[act][0 != cursor];
 display_action_aux(&acts[oid], color, row, col, width);
}
static bool menu_action_handle(struct menu *m, const ui_event *event, int oid)
{
 menu_action *acts = menu_priv(m);
 if (event->type == EVT_SELECT) {
  if (!(acts->flags & MN_ACT_GRAYED) && acts[oid].action) {
   acts[oid].action(acts[oid].name, m->cursor);
   return true;
  }
 } else if (m->keys_hook && event->type == EVT_KBRD) {
  return m->keys_hook(m, event, oid);
 }
 return false;
}
/**
 * Virtual function table for action_events
 */
static const menu_iter menu_iter_actions =
{
 menu_action_tag,
 menu_action_valid,
 menu_action_display,
 menu_action_handle,
 NULL
};
/* ------------------------------------------------------------------------
 * MN_STRINGS HELPER FUNCTIONS
 *
 * MN_STRINGS is the type of menu iterator that displays a simple list of 
 * strings - an action is associated, but only for cmd_keys and switch_keys
 * handling via keys_hook as selection will just return the index.
 * ------------------------------------------------------------------------ */
static void display_string(struct menu *m, int oid, bool cursor,
  int row, int col, int width)
{
 const char **items = menu_priv(m);
 uint8_t color = curs_attrs[CURS_KNOWN][0 != cursor];
 Term_putstr(col, row, width, color, items[oid]);
}
static bool handle_string(struct menu *m, const ui_event *event, int oid)
{
 if (m->keys_hook && event->type == EVT_KBRD) {
  return m->keys_hook(m, event, oid);
 }
 return false;
}
/* Virtual function table for displaying arrays of strings */
static const menu_iter menu_iter_strings =
{
 NULL, /* get_tag() */
 NULL, /* valid_row() */
 display_string, /* display_row() */
 handle_string, /* row_handler() */
 NULL
};
/* ================== SKINS ============== */
/*** Scrolling menu ***/
/**
 * Find the position of a cursor given a screen address
 */
static int scrolling_get_cursor(int row, int col, int n, int top, region *loc)
{
 int cursor = row - loc->row + top;
 if (cursor >= n) cursor = n - 1;
 return cursor;
}
/**
 * Display current view of a skin
 */
static void display_scrolling(struct menu *menu, int cursor, int *top, region *loc)
{
 int col = loc->col;
 int row = loc->row;
 int rows_per_page = loc->page_rows;
 int n = menu->filter_list ? menu->filter_count : menu->count;
 int i;
 /* Keep a certain distance from the top when possible */
 if ((cursor <= *top) && (*top > 0))
  *top = cursor - 1;
 /* Keep a certain distance from the bottom when possible */
 if (cursor >= *top + (rows_per_page - 1))
  *top = cursor - (rows_per_page - 1) + 1;
 /* Limit the top to legal places */
 *top = MIN(*top, n - rows_per_page);
 *top = MAX(*top, 0);
 for (i = 0; i < rows_per_page; i++) {
  /* Blank all lines */
  Term_erase(col, row + i, loc->width);
  if (i < n) {
   /* Redraw the line if it's within the number of menu items */
   bool is_curs = (i == cursor - *top);
   display_menu_row(menu, i + *top, *top, is_curs, row + i, col,
       loc->width);
  }
 }
 if (menu->cursor >= 0)
  Term_gotoxy(col + menu->cursor_x_offset, row + cursor - *top);
}
static char scroll_get_tag(struct menu *menu, int pos)
{
 if (menu->selections)
  return menu->selections[pos - menu->top];
 return 0;
}
static ui_event scroll_process_direction(struct menu *m, int dir)
{
 ui_event out = EVENT_EMPTY;
 /* Reject diagonals */
 if (ddx[dir] && ddy[dir])
  ;
 /* Forward/back */
 else if (ddx[dir])
  out.type = ddx[dir] < 0 ? EVT_ESCAPE : EVT_SELECT;
 /* Move up or down to the next valid & visible row */
 else if (ddy[dir]) {
  m->cursor += ddy[dir];
  out.type = EVT_MOVE;
 }
 return out;
}
/**
 * Virtual function table for scrollable menu skin
 */
static const menu_skin menu_skin_scroll =
{
 scrolling_get_cursor,
 display_scrolling,
 scroll_get_tag,
 scroll_process_direction
};
/*** Object menu skin ***/
/**
 * Find the position of a cursor given a screen address
 */
static int object_skin_get_cursor(int row, int col, int n, int top, region *loc)
{
 int cursor = row - loc->row + top;
 if (cursor >= n) cursor = n - 1;
 return cursor;
}
/**
 * Display current view of a skin
 */
static void object_skin_display(struct menu *menu, int cursor, int *top, region *loc)
{
 int col = loc->col;
 int row = loc->row;
 int rows_per_page = loc->page_rows;
 int n = menu->filter_list ? menu->filter_count : menu->count;
 int i;
 /* Keep a certain distance from the top when possible */
 if ((cursor <= *top) && (*top > 0))
  *top = cursor - 1;
 /* Keep a certain distance from the bottom when possible */
 if (cursor >= *top + (rows_per_page - 1))
  *top = cursor - (rows_per_page - 1) + 1;
 /* Limit the top to legal places */
 *top = MIN(*top, n - rows_per_page);
 *top = MAX(*top, 0);
 for (i = 0; i < rows_per_page; i++) {
  /* Blank all lines */
  Term_erase(col, row + i, loc->width);
  if (i < n) {
   /* Redraw the line if it's within the number of menu items */
   bool is_curs = (i == cursor - *top);
   display_menu_row(menu, i + *top, *top, is_curs, row + i, col,
       loc->width);
  }
 }
 if (menu->cursor >= 0)
  Term_gotoxy(col + menu->cursor_x_offset, row + cursor - *top);
}
static char object_skin_get_tag(struct menu *menu, int pos)
{
 if (menu->selections)
  return menu->selections[pos - menu->top];
 return 0;
}
static ui_event object_skin_process_direction(struct menu *m, int dir)
{
 ui_event out = EVENT_EMPTY;
 /* Reject diagonals */
 if (ddx[dir] && ddy[dir])
  ;
 /* Prepare to switch menus */
 else if (ddx[dir]) {
  out.type = EVT_SWITCH;
  out.key.code = ddx[dir] < 0 ? ARROW_LEFT : ARROW_RIGHT;
 }
 /* Move up or down to the next valid & visible row */
 else if (ddy[dir]) {
  m->cursor += ddy[dir];
  out.type = EVT_MOVE;
 }
 return out;
}
/**
 * Virtual function table for object menu skin
 */
static const menu_skin menu_skin_object =
{
 object_skin_get_cursor,
 object_skin_display,
 object_skin_get_tag,
 object_skin_process_direction
};
/*** Multi-column menus ***/
static int columns_get_cursor(int row, int col, int n, int top, region *loc)
{
 int w, h, cursor;
        int rows_per_page = loc->page_rows;
        int cols = (n + rows_per_page - 1) / rows_per_page;
 int colw = 23;
 Term_get_size(&w, &h);
 if ((colw * cols) > (w - col))
  colw = (w - col) / cols;
 cursor = (row - loc->row) + rows_per_page * ((col - loc->col) / colw);
 if (cursor < 0) cursor = 0; /* assert: This should never happen */
 if (cursor >= n) cursor = n - 1;
 return cursor;
}
static void display_columns(struct menu *menu, int cursor, int *top, region *loc)
{
 int c, r;
 int w, h;
 int n = menu->filter_list ? menu->filter_count : menu->count;
 int col = loc->col;
 int row = loc->row;
 int rows_per_page = loc->page_rows;
 int cols = (n + rows_per_page - 1) / rows_per_page;
 int colw = 23;
 Term_get_size(&w, &h);
 if ((colw * cols) > (w - col))
  colw = (w - col) / cols;
 for (c = 0; c < cols; c++) {
  for (r = 0; r < rows_per_page; r++) {
   int pos = c * rows_per_page + r;
   bool is_cursor = (pos == cursor);
   if (pos < n)
    display_menu_row(menu, pos, 0, is_cursor,
      row + r, col + c * colw, colw);
  }
 }
 if (menu->cursor >= 0)
  Term_gotoxy(col + (cursor / rows_per_page) * colw + menu->cursor_x_offset,
    row + (cursor % rows_per_page) - *top);
}
static char column_get_tag(struct menu *menu, int pos)
{
 if (menu->selections)
  return menu->selections[pos];
 return 0;
}
static ui_event column_process_direction(struct menu *m, int dir)
{
 ui_event out = EVENT_EMPTY;
 int n = m->filter_list ? m->filter_count : m->count;
 region *loc = &m->active;
 int rows_per_page = loc->page_rows;
 int cols = (n + rows_per_page - 1) / rows_per_page;
 if (ddx[dir])
  m->cursor += ddx[dir] * rows_per_page;
 if (ddy[dir])
  m->cursor += ddy[dir];
 /* Adjust to the correct locations (roughly) */
 if (m->cursor > n)
  m->cursor = m->cursor % rows_per_page;
 else if (m->cursor < 0)
  m->cursor = (rows_per_page * cols) + m->cursor;
 out.type = EVT_MOVE;
 return out;
}
/* Virtual function table for multi-column menu skin */
static const menu_skin menu_skin_column =
{
 columns_get_cursor,
 display_columns,
 column_get_tag,
 column_process_direction
};
/* ================== GENERIC HELPER FUNCTIONS ============== */
static bool is_valid_row(struct menu *menu, int cursor)
{
 int oid;
 int count = menu->filter_list ? menu->filter_count : menu->count;
 if (cursor < 0 || cursor >= count)
  return false;
 oid = menu->filter_list ? menu->filter_list[cursor] : cursor;
 if (menu->row_funcs->valid_row)
  return menu->row_funcs->valid_row(menu, oid);
 return true;
}
static bool no_valid_row(struct menu *menu, int count)
{
 int i;
 for (i = 0; i < count; i++)
  if (is_valid_row(menu, i))
   return false;
 return true;
}
/* 
 * Return a new position in the menu based on the key
 * pressed and the flags and various handler functions.
 */
static int get_cursor_key(struct menu *menu, int top, struct keypress key)
{
 int i;
 int n = menu->filter_list ? menu->filter_count : menu->count;
 if (menu->flags & MN_CASELESS_TAGS)
  key.code = toupper((unsigned char) key.code);
 if ((menu->flags & MN_INSCRIP_TAGS) && isdigit((unsigned char)key.code)
  && menu->inscriptions[D2I(key.code)])
  key.code = menu->inscriptions[D2I(key.code)];
 if (menu->flags & MN_NO_TAGS) {
  return -1;
 } else if (menu->flags & MN_REL_TAGS) {
  for (i = 0; i < n; i++) {
   char c = menu->skin->get_tag(menu, i);
   if ((menu->flags & MN_CASELESS_TAGS) && c)
    c = toupper((unsigned char) c);
   if (c && c == (char)key.code)
    return i + menu->top;
  }
 } else if (!(menu->flags & MN_PVT_TAGS) && menu->selections) {
  for (i = 0; menu->selections[i]; i++) {
   char c = menu->selections[i];
   if (menu->flags & MN_CASELESS_TAGS)
    c = toupper((unsigned char) c);
   if (c == (char)key.code)
    return i;
  }
 } else if (menu->row_funcs->get_tag) {
  for (i = 0; i < n; i++) {
   int oid = menu->filter_list ? menu->filter_list[i] : i;
   char c = menu->row_funcs->get_tag(menu, oid);
   if ((menu->flags & MN_CASELESS_TAGS) && c)
    c = toupper((unsigned char) c);
   if (c && c == (char)key.code)
    return i;
  }
 }
 return -1;
}
static menu_row_style_t menu_row_style_for_validity(menu_row_validity_t row_valid)
{
 menu_row_style_t style;
 switch (row_valid) {
  case MN_ROW_INVALID:
  case MN_ROW_HIDDEN:
   style = MN_ROW_STYLE_DISABLED;
   break;
  case MN_ROW_MAYBE:
   style = MN_ROW_STYLE_CONDITIONAL;
   break;
  case MN_ROW_VALID:
  default:
   style = MN_ROW_STYLE_ENABLED;
   break;
 }
 return style;
}
/**
 * Modal display of menu
 */
static void display_menu_row(struct menu *menu, int pos, int top,
                             bool cursor, int row, int col, int width)
{
 int flags = menu->flags;
 char sel = 0;
 int oid = pos;
 menu_row_validity_t row_valid = MN_ROW_VALID;
 if (menu->filter_list)
  oid = menu->filter_list[oid];
 if (menu->row_funcs->valid_row)
  row_valid = menu->row_funcs->valid_row(menu, oid);
 if (row_valid == MN_ROW_HIDDEN)
  return;
 if (!(flags & MN_NO_TAGS)) {
  if (flags & MN_REL_TAGS)
   sel = menu->skin->get_tag(menu, pos);
  else if (menu->selections && !(flags & MN_PVT_TAGS))
   sel = menu->selections[pos];
  else if (menu->row_funcs->get_tag)
   sel = menu->row_funcs->get_tag(menu, oid);
 }
 if (sel) {
  menu_row_style_t style = menu_row_style_for_validity(row_valid);
  uint8_t color = curs_attrs[style][0 != (cursor)];
  Term_putstr(col, row, 3, color, format("%c) ", sel));
  col += 3;
  width -= 3;
 }
 menu->row_funcs->display_row(menu, oid, cursor, row, col, width);
}
void menu_refresh(struct menu *menu, bool reset_screen)
{
 int oid = menu->cursor;
 region *loc = &menu->active;
 if (reset_screen) {
  screen_load();
  screen_save();
 }
 if (menu->filter_list && menu->cursor >= 0)
  oid = menu->filter_list[oid];
 if (menu->title)
  Term_putstr(menu->boundary.col, menu->boundary.row,
    loc->width, COLOUR_WHITE, menu->title);
 if (menu->header)
  Term_putstr(loc->col, loc->row - 1, loc->width,
    COLOUR_WHITE, menu->header);
 if (menu->prompt)
  Term_putstr(menu->boundary.col, loc->row + loc->page_rows,
    loc->width, COLOUR_WHITE, menu->prompt);
 if (menu->browse_hook && oid >= 0)
  menu->browse_hook(oid, menu->menu_data, loc);
 menu->skin->display_list(menu, menu->cursor, &menu->top, loc);
}
/*** MENU RUNNING AND INPUT HANDLING CODE ***/
/**
 * Handle mouse input in a menu.
 * 
 * Mouse output is either moving, selecting, escaping, or nothing.  Returns
 * true if something changes as a result of the click.
 */
bool menu_handle_mouse(struct menu *menu, const ui_event *in,
  ui_event *out)
{
 int new_cursor;
 if (in->mouse.button == 2) {
  out->type = EVT_ESCAPE;
 } else if (!region_inside(&menu->active, in)) {
  /* A click to the left of the active region is 'back' */
  if (!region_inside(&menu->active, in)
    && in->mouse.x < menu->active.col) {
   out->type = EVT_ESCAPE;
  } else if (menu->context_hook) {
   return (*menu->context_hook)(menu, in, out);
  }
 } else {
  int count = menu->filter_list ? menu->filter_count : menu->count;
  new_cursor = menu->skin->get_cursor(in->mouse.y, in->mouse.x,
    count, menu->top, &menu->active);
  if (is_valid_row(menu, new_cursor)) {
   if (new_cursor == menu->cursor || !(menu->flags & MN_DBL_TAP))
    out->type = EVT_SELECT;
   else
    out->type = EVT_MOVE;
   menu->cursor = new_cursor;
  } else if (menu->context_hook) {
   return (*menu->context_hook)(menu, in, out);
  }
 }
 return out->type != EVT_NONE;
}
/**
 * Handle any menu command keys / SELECT events.
 *
 * Returns true if the key was handled at all (including if it's not handled
 * and just ignored).
 */
static bool menu_handle_action(struct menu *m, const ui_event *in)
{
 if (m->row_funcs->row_handler) {
  int oid = m->cursor;
  if (m->filter_list)
   oid = m->filter_list[m->cursor];
  return m->row_funcs->row_handler(m, in, oid);
 }
 return false;
}
/**
 * Handle navigation keypresses.
 *
 * Returns true if they key was intelligible as navigation, regardless of
 * whether any action was taken.
 */
bool menu_handle_keypress(struct menu *menu, const ui_event *in,
  ui_event *out)
{
 bool eat = false;
 int count = menu->filter_list ? menu->filter_count : menu->count;
 /* Get the new cursor position from the menu item tags */
 int new_cursor = get_cursor_key(menu, menu->top, in->key);
 if (new_cursor >= 0 && is_valid_row(menu, new_cursor)) {
  if (!(menu->flags & MN_DBL_TAP) || new_cursor == menu->cursor)
   out->type = EVT_SELECT;
  else
   out->type = EVT_MOVE;
  menu->cursor = new_cursor;
 } else if (in->key.code == ESCAPE) {
  /* Escape stops us here */
  out->type = EVT_ESCAPE;
 } else if (count <= 0) {
  /* Menus with no rows can't be navigated or used, so eat keypresses */
  eat = true;
 } else if (in->key.code == ' ') {
  /* Try existing, known keys */
  int rows = menu->active.page_rows;
  int total = count;
  if (rows < total) {
   /* Go to start of next page */
   menu->cursor += menu->active.page_rows;
   if (menu->cursor >= total - 1) menu->cursor = 0;
   menu->top = menu->cursor;
   out->type = EVT_MOVE;
  } else {
   eat = true;
  }
 } else if (in->key.code == KC_ENTER) {
  out->type = EVT_SELECT;
 } else {
  /* Try directional movement */
  int dir = target_dir(in->key);
  if (dir && !no_valid_row(menu, count)) {
   *out = menu->skin->process_dir(menu, dir);
   if (out->type == EVT_MOVE) {
    while (!is_valid_row(menu, menu->cursor)) {
     /* Loop around */
     if (menu->cursor > count - 1)
      menu->cursor = 0;
     else if (menu->cursor < 0)
      menu->cursor = count - 1;
     else
      menu->cursor += ddy[dir];
    }
    assert(menu->cursor >= 0);
    assert(menu->cursor < count);
   }
  }
 }
 return eat;
}
/**
 * Run a menu.
 *
 * If popup is true, the screen is saved before the menu is drawn, and
 * restored afterwards. Each time a popup menu is redrawn, it resets the
 * screen before redrawing.
 */
ui_event menu_select(struct menu *menu, int notify, bool popup)
{
 ui_event in = EVENT_EMPTY;
 bool no_act = (menu->flags & MN_NO_ACTION) ? true : false;
 assert(menu->active.width != 0 && menu->active.page_rows != 0);
 notify |= (EVT_SELECT | EVT_ESCAPE | EVT_SWITCH);
 if (popup)
  screen_save();
 /* Stop on first unhandled event */
 while (!(in.type & notify)) {
  ui_event out = EVENT_EMPTY;
  int cursor = menu->cursor;
  menu_refresh(menu, popup);
  in = inkey_ex();
  /* Handle mouse & keyboard commands */
  if (in.type == EVT_MOUSE) {
   if (!no_act && menu_handle_action(menu, &in)) {
    continue;
   }
   menu_handle_mouse(menu, &in, &out);
  } else if (in.type == EVT_KBRD) {
   /* Command key */
   if (!no_act && menu->cmd_keys &&
    strchr(menu->cmd_keys, (char)in.key.code) &&
    menu_handle_action(menu, &in))
    continue;
   /* Switch key */
   if (!no_act && menu->switch_keys &&
    strchr(menu->switch_keys, (char)in.key.code)) {
    menu_handle_action(menu, &in);
    if (popup)
     screen_load();
    return in;
   }
   menu_handle_keypress(menu, &in, &out);
  } else if (in.type == EVT_RESIZE) {
   menu_calc_size(menu);
   if (menu->row_funcs->resize)
    menu->row_funcs->resize(menu);
  }
  /* Redraw menu here if cursor has moved */
  if (cursor != menu->cursor) {
   menu_refresh(menu, popup);
  }
  /* If we've selected an item, then send that event out */
  if (out.type == EVT_SELECT && !no_act && menu_handle_action(menu, &out))
   continue;
  /* Notify about the outgoing type */
  if (notify & out.type) {
   if (popup)
    screen_load();
   return out;
  }
 }
 if (popup)
  screen_load();
 return in;
}
/* ================== MENU ACCESSORS ================ */
/**
 * Return the menu iter struct for a given iter ID.
 */
const menu_iter *menu_find_iter(menu_iter_id id)
{
 switch (id)
 {
  case MN_ITER_ACTIONS:
   return &menu_iter_actions;
  case MN_ITER_STRINGS:
   return &menu_iter_strings;
 }
 return NULL;
}
/*
 * Return the skin behaviour struct for a given skin ID.
 */
static const menu_skin *menu_find_skin(skin_id id)
{
 switch (id)
 {
  case MN_SKIN_SCROLL:
   return &menu_skin_scroll;
  case MN_SKIN_OBJECT:
   return &menu_skin_object;
  case MN_SKIN_COLUMNS:
   return &menu_skin_column;
 }
 return NULL;
}
void menu_set_filter(struct menu *menu, const int filter_list[], int n)
{
 menu->filter_list = filter_list;
 menu->filter_count = n;
 menu_ensure_cursor_valid(menu);
}
void menu_release_filter(struct menu *menu)
{
 menu->filter_list = NULL;
 menu->filter_count = 0;
 menu_ensure_cursor_valid(menu);
}
void menu_ensure_cursor_valid(struct menu *m)
{
 int row;
 int count = m->filter_list ? m->filter_count : m->count;
 for (row = m->cursor; row < count; row++) {
  if (is_valid_row(m, row)) {
   m->cursor = row;
   return;
  }
 }
 /* If we've run off the end, without finding a valid row, put cursor
	 * on the last row */
 m->cursor = count - 1;
}
/* ======================== MENU INITIALIZATION ==================== */
static bool menu_calc_size(struct menu *menu)
{
 /* Calculate term-relative positions */
 menu->active = region_calculate(menu->boundary);
 if (menu->title) {
  menu->active.row += 2;
  menu->active.page_rows -= 2;
  menu->active.col += 4;
 }
 if (menu->header) {
  menu->active.row++;
  menu->active.page_rows--;
 }
 if (menu->prompt) {
  if (menu->active.page_rows > 1) {
   menu->active.page_rows--;
  } else {
   int offset = strlen(menu->prompt) + 2;
   menu->active.col += offset;
   menu->active.width -= offset;
  }
 }
 return (menu->active.width > 0 && menu->active.page_rows > 0);
}
bool menu_layout(struct menu *m, const region *loc)
{
 m->boundary = *loc;
 return menu_calc_size(m);
}
void menu_setpriv(struct menu *menu, int count, void *data)
{
 menu->count = count;
 menu->menu_data = data;
 menu_ensure_cursor_valid(menu);
}
void *menu_priv(struct menu *menu)
{
 return menu->menu_data;
}
void menu_init(struct menu *menu, skin_id id, const menu_iter *iter)
{
 const menu_skin *skin = menu_find_skin(id);
 assert(skin && "menu skin not found!");
 assert(iter && "menu iter not found!");
 /* Wipe the struct */
 memset(menu, 0, sizeof *menu);
 /* Menu-specific initialisation */
 menu->row_funcs = iter;
 menu->skin = skin;
 menu->cursor = 0;
 menu->cursor_x_offset = 0;
}
struct menu *menu_new(skin_id id, const menu_iter *iter)
{
 struct menu *m = mem_alloc(sizeof *m);
 menu_init(m, id, iter);
 return m;
}
struct menu *menu_new_action(menu_action *acts, size_t n)
{
 struct menu *m = menu_new(MN_SKIN_SCROLL, menu_find_iter(MN_ITER_ACTIONS));
 menu_setpriv(m, n, acts);
 return m;
}
void menu_free(struct menu *m)
{
 mem_free(m);
}
void menu_set_cursor_x_offset(struct menu *m, int offset)
{
 /* This value is used in the menu skin's display_list() function. */
 m->cursor_x_offset = offset;
}
/*** Dynamic menu handling ***/
struct menu_entry {
 char *text;
 int value;
 menu_row_validity_t valid;
 struct menu_entry *next;
};
static int dynamic_valid(struct menu *m, int oid)
{
 struct menu_entry *entry;
 for (entry = menu_priv(m); oid; oid--) {
  entry = entry->next;
  assert(entry);
 }
 return entry->valid;
}
static void dynamic_display(struct menu *m, int oid, bool cursor,
  int row, int col, int width)
{
 struct menu_entry *entry;
 uint8_t color = curs_attrs[MN_ROW_STYLE_ENABLED][0 != cursor];
 /* Hack? While row_funcs is private, we need to be consistent with what the menu will do. */
 if (m->row_funcs->valid_row) {
  menu_row_validity_t row_valid = m->row_funcs->valid_row(m, oid);
  menu_row_style_t style = menu_row_style_for_validity(row_valid);
  color = curs_attrs[style][0 != cursor];
 }
 for (entry = menu_priv(m); oid; oid--) {
  entry = entry->next;
  assert(entry);
 }
 Term_putstr(col, row, width, color, entry->text);
}
static const menu_iter dynamic_iter = {
 NULL, /* tag */
 dynamic_valid,
 dynamic_display,
 NULL, /* handler */
 NULL /* resize */
};
struct menu *menu_dynamic_new(void)
{
 struct menu *m = menu_new(MN_SKIN_SCROLL, &dynamic_iter);
 menu_setpriv(m, 0, NULL);
 return m;
}
void menu_dynamic_add_valid(struct menu *m, const char *text, int value, menu_row_validity_t valid)
{
 struct menu_entry *head = menu_priv(m);
 struct menu_entry *new = mem_zalloc(sizeof *new);
 assert(m->row_funcs == &dynamic_iter);
 new->text = string_make(text);
 new->value = value;
 new->valid = valid;
 if (head) {
  struct menu_entry *tail = head;
  while (1) {
   if (tail->next)
    tail = tail->next;
   else
    break;
  }
  tail->next = new;
  menu_setpriv(m, m->count + 1, head);
 } else {
  menu_setpriv(m, m->count + 1, new);
 }
}
void menu_dynamic_add(struct menu *m, const char *text, int value)
{
 menu_dynamic_add_valid(m, text, value, MN_ROW_VALID);
}
void menu_dynamic_add_label_valid(struct menu *m, const char *text, const char label, int value, char *label_list, menu_row_validity_t valid)
{
 if (label && m->selections && (m->selections == label_list)) {
  label_list[m->count] = label;
 }
 menu_dynamic_add_valid(m,text,value, valid);
}
void menu_dynamic_add_label(struct menu *m, const char *text, const char label, int value, char *label_list)
{
 menu_dynamic_add_label_valid(m, text, label, value, label_list, MN_ROW_VALID);
}
size_t menu_dynamic_longest_entry(struct menu *m)
{
 size_t biggest = 0;
 size_t current;
 struct menu_entry *entry;
 for (entry = menu_priv(m); entry; entry = entry->next) {
  current = strlen(entry->text);
  if (current > biggest)
   biggest = current;
 }
 return biggest;
}
void menu_dynamic_calc_location(struct menu *m, int mx, int my)
{
 region r;
 /* work out display region */
 r.width = menu_dynamic_longest_entry(m) + 3 + 2; /* +3 for tag, 2 for pad */
 if (mx > Term->wid - r.width - 1) {
  r.col = Term->wid - r.width - 1;
 } else {
  r.col = mx + 1;
 }
 r.page_rows = m->count;
 if (my > Term->hgt - r.page_rows - 1) {
  if (my - r.page_rows - 1 <= 0) {
   /* menu has too many items, so put in upper right corner */
   r.row = 1;
   r.col = Term->wid - r.width - 1;
  } else {
   r.row = Term->hgt - r.page_rows - 1;
  }
 } else {
  r.row = my + 1;
 }
 menu_layout(m, &r);
}
int menu_dynamic_select(struct menu *m)
{
 ui_event e = menu_select(m, 0, true);
 struct menu_entry *entry;
 int cursor = m->cursor;
 if (e.type == EVT_ESCAPE)
  return -1;
 for (entry = menu_priv(m); cursor; cursor--) {
  entry = entry->next;
  assert(entry);
 }
 return entry->value;
}
void menu_dynamic_free(struct menu *m)
{
 struct menu_entry *entry = menu_priv(m);
 while (entry) {
  struct menu_entry *next = entry->next;
  string_free(entry->text);
  mem_free(entry);
  entry = next;
 }
 mem_free(m);
}
/**
 * \file ui-mon-list.c
 * \brief Monster list UI.
 *
 * Copyright (c) 1997-2007 Ben Harrison, James E. Wilson, Robert A. Koeneke
 * Copyright (c) 2013 Ben Semmler
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Format a section of the monster list: a header followed by monster list
 * entry rows.
 *
 * This function will process each entry for the given section. It will display:
 * - monster char;
 * - number of monsters;
 * - monster name (truncated, if needed to fit the line);
 * - whether or not the monster is alert (and how many if in a group);
 * - monster distance from the player (aligned to the right side of the list).
 * By passing in a NULL textblock, the maximum line width of the section can be
 * found.
 *
 * \param list is the monster list to format.
 * \param tb is the textblock to produce or NULL if only the dimensions need to
 * be calculated.
 * \param section is the section of the monster list to format.
 * \param lines_to_display are the number of entries to display (not including
 * the header).
 * \param max_width is the maximum line width.
 * \param prefix is the beginning of the header; the remainder is appended with
 * the number of monsters.
 * \param show_others is used to append "other monsters" to the header,
 * after the number of monsters.
 * \param max_width_result is returned with the width needed to format the list
 * without truncation.
 */
static void monster_list_format_section(const monster_list_t *list, textblock *tb, monster_list_section_t section, int lines_to_display, int max_width, const char *prefix, bool show_others, size_t *max_width_result)
{
 int remaining_monster_total = 0;
 int line_count = 0;
 int index;
 int total;
 char line_buffer[200];
 const char *punctuation = (lines_to_display == 0) ? "." : ":";
 const char *others = (show_others) ? "other " : "";
 size_t max_line_length = 0;
 if (list == NULL || list->entries == NULL)
  return;
 total = list->distinct_entries;
 if (list->total_monsters[section] == 0) {
  max_line_length = strnfmt(line_buffer, sizeof(line_buffer),
          "%s no monsters.\n", prefix);
  if (tb != NULL)
   textblock_append(tb, "%s", line_buffer);
  /* Force a minimum width so that the prompt doesn't get cut off. */
  if (max_width_result != NULL)
   *max_width_result = MAX(max_line_length, 40);
  return;
 }
 max_line_length = strnfmt(line_buffer, sizeof(line_buffer),
         "%s %d %smonster%s%s\n",
         prefix,
         list->total_monsters[section],
         others,
         PLURAL(list->total_monsters[section]),
         punctuation);
 if (tb != NULL)
  textblock_append(tb, "%s", line_buffer);
 for (index = 0; index < total && line_count < lines_to_display; index++) {
  char alert[20] = { '\0' };
  char location[20] = { '\0' };
  int line_attr;
  size_t full_width;
  size_t name_width;
  uint16_t count_in_section = 0;
  uint16_t alert_in_section = 0;
  line_buffer[0] = '\0';
  if (list->entries[index].count[section] == 0)
   continue;
  /* Only display directions for the case of a single monster. */
  if (list->entries[index].count[section] == 1) {
   const char *direction1 =
    (list->entries[index].dy[section] <= 0) ? "N" : "S";
   const char *direction2 =
    (list->entries[index].dx[section] <= 0) ? "W" : "E";
   strnfmt(location, sizeof(location), " %d %s %d %s",
     abs(list->entries[index].dy[section]), direction1,
     abs(list->entries[index].dx[section]), direction2);
  }
  /* Get width available for monster name and sleep tag: 2 for char and
		 * space; location includes padding; last -1 for some reason? */
  full_width = max_width - 2 - utf8_strlen(location) - 1;
  alert_in_section = list->entries[index].alert[section];
  count_in_section = list->entries[index].count[section];
  if (alert_in_section > 0 && count_in_section > 1)
   strnfmt(alert, sizeof(alert), " (%d alert)", alert_in_section);
  else if (alert_in_section == 1 && count_in_section == 1)
   strnfmt(alert, sizeof(alert), " (alert)");
  /* Clip the monster name to fit, and append the sleep tag. */
  name_width = MIN(full_width - utf8_strlen(alert), sizeof(line_buffer));
  get_mon_name(line_buffer, sizeof(line_buffer),
      list->entries[index].race,
      list->entries[index].count[section]);
  utf8_clipto(line_buffer, name_width);
  my_strcat(line_buffer, alert, sizeof(line_buffer));
  /* Calculate the width of the line for dynamic sizing; use a fixed max
		 * width for location and monster char. */
  max_line_length = MAX(max_line_length,
         utf8_strlen(line_buffer) + 12 + 2);
  /* textblock_append_pict will safely add the monster symbol,
		 * regardless of ASCII/graphics mode. */
  if (tb != NULL && tile_width == 1 && tile_height == 1) {
   textblock_append_pict(tb, list->entries[index].attr, monster_x_char[list->entries[index].race->ridx]);
   textblock_append(tb, " ");
  }
  /* Add the left-aligned and padded monster name which will align the
		 * location to the right. */
  if (tb != NULL) {
   /* Hack - Because monster race strings are UTF8, we have to add
			 * additional padding for any raw bytes that might be consolidated
			 * into one displayed character. */
   full_width += strlen(line_buffer) - utf8_strlen(line_buffer);
   line_attr = monster_list_entry_line_color(&list->entries[index]);
   textblock_append_c(tb, line_attr, "%-*s%s\n",
    (int) full_width, line_buffer, location);
  }
  line_count++;
 }
 /* Don't worry about the "...others" line, since it's probably shorter
	 * than what's already printed. */
 if (max_width_result != NULL)
  *max_width_result = max_line_length;
 /* Bail since we don't have enough room to display the remaining count or
	 * since we've displayed them all. */
 if (lines_to_display <= 0 ||
  lines_to_display >= list->total_entries[section])
  return;
 /* Sum the remaining monsters; start where we left off in the above loop. */
 while (index < total) {
  remaining_monster_total += list->entries[index].count[section];
  index++;
 }
 if (tb != NULL)
  textblock_append(tb, "%6s...and %d others.\n", " ",
       remaining_monster_total);
}
/**
 * Allow the standard list formatted to be bypassed for special cases.
 *
 * Returning true will bypass any other formatteding in
 * monster_list_format_textblock().
 *
 * \param list is the monster list to format.
 * \param tb is the textblock to produce or NULL if only the dimensions need to
 * be calculated.
 * \param max_lines is the maximum number of lines that can be displayed.
 * \param max_width is the maximum line width that can be displayed.
 * \param max_height_result is returned with the number of lines needed to
 * format the list without truncation.
 * \param max_width_result is returned with the width needed to format the list
 * without truncation.
 * \return true if further formatting should be bypassed.
 */
static bool monster_list_format_special(const monster_list_t *list, textblock *tb, int max_lines, int max_width, size_t *max_height_result, size_t *max_width_result)
{
 if (player->timed[TMD_IMAGE] > 0) {
  /* Hack - message needs newline to calculate width properly. */
  const char *message = "Your hallucinations are too wild to see things clearly.\n";
  if (max_height_result != NULL)
   *max_height_result = 1;
  if (max_width_result != NULL)
   *max_width_result = strlen(message);
  if (tb != NULL)
   textblock_append_c(tb, COLOUR_ORANGE, "%s", message);
  return true;
 }
 return false;
}
/**
 * Format the entire monster list with the given parameters.
 *
 * This function can be used to calculate the preferred dimensions for the list
 * by passing in a NULL textblock. The LOS section of the list will always be
 * shown, while the other section will be added conditionally. Also, this
 * function calls monster_list_format_special() first; if that function returns
 * true, it will bypass normal list formatting.
 *
 * \param list is the monster list to format.
 * \param tb is the textblock to produce or NULL if only the dimensions need to
 * be calculated.
 * \param max_lines is the maximum number of lines that can be displayed.
 * \param max_width is the maximum line width that can be displayed.
 * \param max_height_result is returned with the number of lines needed to
 * format the list without truncation.
 * \param max_width_result is returned with the width needed to format the list
 * without truncation.
 */
static void monster_list_format_textblock(const monster_list_t *list, textblock *tb, int max_lines, int max_width, size_t *max_height_result, size_t *max_width_result)
{
 int header_lines = 1;
 int lines_remaining;
 int los_lines_to_display;
 int esp_lines_to_display;
 size_t max_los_line = 0;
 size_t max_esp_line = 0;
 if (list == NULL || list->entries == NULL)
  return;
 if (monster_list_format_special(list, tb, max_lines, max_width,
         max_height_result, max_width_result))
  return;
 los_lines_to_display = list->total_entries[MONSTER_LIST_SECTION_LOS];
 esp_lines_to_display = list->total_entries[MONSTER_LIST_SECTION_ESP];
 if (list->total_entries[MONSTER_LIST_SECTION_ESP] > 0)
  header_lines += 2;
 if (max_height_result != NULL)
  *max_height_result = header_lines + los_lines_to_display +
   esp_lines_to_display;
 lines_remaining = max_lines - header_lines -
  list->total_entries[MONSTER_LIST_SECTION_LOS];
 /* Remove ESP lines as needed. */
 if (lines_remaining < list->total_entries[MONSTER_LIST_SECTION_ESP])
  esp_lines_to_display = MAX(lines_remaining - 1, 0);
 /* If we don't even have enough room for the ESP header, start removing
	 * LOS lines, leaving one for the "...others". */
 if (lines_remaining < 0)
  los_lines_to_display = list->total_entries[MONSTER_LIST_SECTION_LOS] -
   abs(lines_remaining) - 1;
 /* Display only headers if we don't have enough space. */
 if (header_lines >= max_lines) {
  los_lines_to_display = 0;
  esp_lines_to_display = 0;
 }
 monster_list_format_section(list, tb, MONSTER_LIST_SECTION_LOS,
        los_lines_to_display, max_width,
        "You can see", false, &max_los_line);
 if (list->total_entries[MONSTER_LIST_SECTION_ESP] > 0) {
  bool show_others = list->total_monsters[MONSTER_LIST_SECTION_LOS] > 0;
  if (tb != NULL)
   textblock_append(tb, "\n");
  monster_list_format_section(list, tb, MONSTER_LIST_SECTION_ESP,
         esp_lines_to_display, max_width,
         "You are aware of", show_others,
         &max_esp_line);
 }
 if (max_width_result != NULL)
  *max_width_result = MAX(max_los_line, max_esp_line);
}
/**
 * Get correct monster glyphs.
 */
static void monster_list_get_glyphs(monster_list_t *list)
{
 int i;
 /* Run through all monsters in the list. */
 for (i = 0; i < (int)list->entries_size; i++) {
  monster_list_entry_t *entry = &list->entries[i];
  if (entry->race == NULL)
   continue;
  /* If no monster attribute use the standard UI picture. */
  if (!entry->attr)
   entry->attr = monster_x_attr[entry->race->ridx];
 }
}
/**
 * Display the monster list statically. This will force the list to be
 * displayed to the provided dimensions. Contents will be adjusted accordingly.
 *
 * In order to support more efficient monster flicker animations, this function
 * uses a shared list object so that it's not constantly allocating and freeing
 * the list.
 *
 * \param height is the height of the list.
 * \param width is the width of the list.
 */
void monster_list_show_subwindow(int height, int width)
{
 textblock *tb;
 monster_list_t *list;
 int i;
 if (height < 1 || width < 1)
  return;
 tb = textblock_new();
 list = monster_list_shared_instance();
 /* Force an update if detected monsters */
 for (i = 1; i < cave_monster_max(cave); i++) {
  if (mflag_has(cave_monster(cave, i)->mflag, MFLAG_MARK)) {
   list->creation_turn = -1;
   break;
  }
 }
 monster_list_reset(list);
 monster_list_collect(list);
 monster_list_get_glyphs(list);
 monster_list_sort(list, monster_list_standard_compare);
 /* Draw the list to exactly fit the subwindow. */
 monster_list_format_textblock(list, tb, height, width, NULL, NULL);
 textui_textblock_place(tb, SCREEN_REGION, NULL);
 textblock_free(tb);
}
/**
 * Display the monster list interactively. This will dynamically size the list
 * for the best appearance. This should only be used in the main term.
 *
 * \param height is the height limit for the list.
 * \param width is the width limit for the list.
 */
void monster_list_show_interactive(int height, int width)
{
 textblock *tb;
 monster_list_t *list;
 size_t max_width = 0, max_height = 0;
 int safe_height, safe_width;
 region r;
 int sort_exp = 0;
 struct keypress ch;
 if (height < 1 || width < 1)
  return;
 // Repeat
 do {
  tb = textblock_new();
  list = monster_list_new();
  monster_list_collect(list);
  monster_list_get_glyphs(list);
  monster_list_sort(list, sort_exp ? monster_list_compare_exp : monster_list_standard_compare);
  /* Figure out optimal display rect. Large numbers are passed as the height
		 * and width limit so that we can calculate the maximum number of rows and
		 * columns to display the list nicely. We then adjust those values as
		 * needed to fit in the main term. Height is adjusted to account for the
		 * texblock prompt. The list is positioned on the right side of the term
		 * underneath the status line.
		 */
  monster_list_format_textblock(list, NULL, 1000, 1000, &max_height,
           &max_width);
  safe_height = MIN(height - 3, (int) max_height + 3);
  safe_width = MIN(width - 40, (int) max_width);
  r.col = -safe_width;
  r.row = 1;
  r.width = safe_width;
  r.page_rows = safe_height;
  /*
		 * Actually draw the list. We pass in max_height to the format function so
		 * that all lines will be appended to the textblock. The textblock itself
		 * will handle fitting it into the region. However, we have to pass
		 * safe_width so that the format function will pad the lines properly so
		 * that the location string is aligned to the right edge of the list.
		 */
  monster_list_format_textblock(list, tb, (int) max_height, safe_width, NULL,
           NULL);
  region_erase_bordered(&r);
  char buf[300];
  if (sort_exp) {
   my_strcpy(buf, "Press 'x' to turn OFF 'sort by exp'", sizeof(buf));
  }
  else {
   my_strcpy(buf, "Press 'x' to turn ON 'sort by exp'", sizeof(buf));
  }
  ch = textui_textblock_show(tb, r, buf);
  // Toggle sort
  sort_exp = !sort_exp;
  textblock_free(tb);
  monster_list_free(list);
 }
 while (ch.code == 'x');
}
/**
 * Force an update to the monster list subwindow.
 *
 * There are conditions that monster_list_reset() can't catch, so we set the
 * turn an invalid value to force the list to update.
 */
void monster_list_force_subwindow_update(void)
{
 monster_list_t *list = monster_list_shared_instance();
 list->creation_turn = -1;
}
/**
 * \file ui-mon-lore.c
 * \brief Monster memory UI
 *
 * Copyright (c) 1997-2007 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Place a monster recall title into a textblock.
 *
 * If graphics are turned on, this appends the title with the appropriate tile.
 * Note: if the title is the only thing in the textblock, make sure to append a
 * newline so that the textui stuff works properly. 
 *
 * \param tb is the textblock we are placing the title into.
 * \param race is the monster race we are describing.
 */
void lore_title(textblock *tb, const struct monster_race *race)
{
 uint8_t standard_attr, optional_attr;
 wchar_t standard_char, optional_char;
 assert(race);
 /* Get the chars */
 standard_char = race->d_char;
 optional_char = monster_x_char[race->ridx];
 /* Get the attrs */
 standard_attr = race->d_attr;
 optional_attr = monster_x_attr[race->ridx];
 /* A title (use "The" for non-uniques) */
 if (!rf_has(race->flags, RF_UNIQUE)) {
  textblock_append(tb, "The ");
 }
 /* Dump the name and then append standard attr/char info */
 textblock_append(tb, "%s", race->name);
 textblock_append(tb, " ('");
 textblock_append_pict(tb, standard_attr, standard_char);
 textblock_append(tb, "')");
 if (((optional_attr != standard_attr) || (optional_char != standard_char))
  && (tile_width == 1) && (tile_height == 1)) {
  /* Append the "optional" attr/char info */
  textblock_append(tb, " ('");
  textblock_append_pict(tb, optional_attr, optional_char);
  textblock_append(tb, "')");
 }
}
/**
 * Place a full monster recall description (with title) into a textblock, with
 * or without spoilers.
 *
 * \param tb is the textblock we are placing the description into.
 * \param race is the monster race we are describing.
 * \param original_lore is the known information about the monster race.
 * \param spoilers indicates what information is used; `true` will display full
 *        information without subjective information and monster flavor,
 *        while `false` only shows what the player knows.
 */
void lore_description(textblock *tb, const struct monster_race *race,
       const struct monster_lore *original_lore, bool spoilers)
{
 struct monster_lore mutable_lore;
 struct monster_lore *lore = &mutable_lore;
 bitflag known_flags[RF_SIZE];
 assert(tb && race && original_lore);
 if (player->timed[TMD_IMAGE] > 0) {
  textblock_append(tb, "Your hallucinations are too wild to see things clearly.\n");
  return;
 }
 /* Hack -- create a copy of the monster-memory that we can modify */
 memcpy(lore, original_lore, sizeof(struct monster_lore));
 /* Spoilers -- know everything */
 if (spoilers || player_active_ability(player, "Lore-Master"))
  cheat_monster_lore(race, lore);
 /* Now get the known monster flags */
 monster_flags_known(race, lore, known_flags);
 /* Appending the title here simplifies code in the callers. It also causes
	 * a crash when generating spoilers (we don't need titles for them anwyay)*/
 if (!spoilers) {
  lore_title(tb, race);
  textblock_append(tb, "\n");
 }
 /* Show kills of monster vs. player(s) */
 if (!spoilers)
  lore_append_kills(tb, race, lore, known_flags);
 /* Monster description */
 lore_append_flavor(tb, race);
 /* Describe the monster type, speed, life, and armor */
 lore_append_movement(tb, race, lore, known_flags);
 /* Describe the spells and innate attacks */
 lore_append_spells(tb, race, lore, known_flags);
 /* Describe the abilities of the monster */
 lore_append_abilities(tb, race, lore, known_flags);
 /* Describe the known attacks */
 lore_append_attack(tb, race, lore, known_flags);
 /* Describe monster "toughness" */
 lore_append_toughness(tb, race, lore, known_flags);
 /* Describe the known skills */
 lore_append_skills(tb, race, lore, known_flags);
 /* Describe experience */
 lore_append_exp(tb, race, lore, known_flags);
 /* Describe the monster drop */
 lore_append_drop(tb, race, lore, known_flags);
 textblock_append(tb, "\n");
}
/**
 * Display monster recall modally and wait for a keypress.
 *
 * This is intended to be called when the main window is active (hence the
 * message flushing).
 *
 * \param race is the monster race we are describing.
 * \param lore is the known information about the monster race.
 */
void lore_show_interactive(const struct monster_race *race,
         const struct monster_lore *lore)
{
 textblock *tb;
 assert(race && lore);
 event_signal(EVENT_MESSAGE_FLUSH);
 tb = textblock_new();
 lore_description(tb, race, lore, false);
 textui_textblock_show(tb, SCREEN_REGION, NULL);
 textblock_free(tb);
}
/**
 * Display monster recall statically.
 *
 * This is intended to be called in a subwindow, since it clears the entire
 * window before drawing, and has no interactivity.
 *
 * \param race is the monster race we are describing.
 * \param lore is the known information about the monster race.
 */
void lore_show_subwindow(const struct monster_race *race,
       const struct monster_lore *lore)
{
 int y;
 textblock *tb;
 assert(race && lore);
 /* Erase the window, since textui_textblock_place() only clears what it
	 * needs */
 for (y = 0; y < Term->hgt; y++)
  Term_erase(0, y, 255);
 tb = textblock_new();
 lore_description(tb, race, lore, false);
 textui_textblock_place(tb, SCREEN_REGION, NULL);
 textblock_free(tb);
}
/**
 * \file ui-obj-list.c
 * \brief Object list UI.
 *
 * Copyright (c) 1997-2007 Ben Harrison, James E. Wilson, Robert A. Koeneke
 * Copyright (c) 2013 Ben Semmler
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Format a section of the object list: a header followed by object list entry
 * rows.
 *
 * This function will process each entry for the given section. It will display:
 * - object char;
 * - number of objects;
 * - object name (truncated, if needed to fit the line);
 * - object distance from the player (aligned to the right side of the list).
 * By passing in a NULL textblock, the maximum line width of the section can
 * be found.
 *
 * \param list is the object list to format.
 * \param tb is the textblock to produce or NULL if only the dimensions need to
 * be calculated.
 * \param lines_to_display are the number of entries to display (not including
 * the header).
 * \param max_width is the maximum line width.
 * \param prefix is the beginning of the header; the remainder is appended with
 * the number of objects.
 * \param max_width_result is returned with the width needed to format the list
 * without truncation.
 */
static void object_list_format_section(const object_list_t *list,
            textblock *tb,
            object_list_section_t section,
            int lines_to_display, int max_width,
            const char *prefix, bool show_others,
            size_t *max_width_result)
{
 int remaining_object_total = 0;
 int line_count = 0;
 int entry_index;
 int total;
 char line_buffer[200];
 const char *punctuation = (lines_to_display == 0) ? "." : ":";
 const char *others = (show_others) ? "other " : "";
 size_t max_line_length = 0;
 if (list == NULL || list->entries == NULL)
  return;
 total = list->distinct_entries;
 if (list->total_entries[section] == 0) {
  max_line_length = strnfmt(line_buffer, sizeof(line_buffer),
          "%s no objects.\n", prefix);
  if (tb != NULL)
   textblock_append(tb, "%s", line_buffer);
  /* Force a minimum width so that the prompt doesn't get cut off. */
  if (max_width_result != NULL)
   *max_width_result = MAX(max_line_length, 40);
  return;
 }
 max_line_length = strnfmt(line_buffer, sizeof(line_buffer),
         "%s %d %sobject%s%s\n", prefix,
         list->total_entries[section], others,
         PLURAL(list->total_entries[section]),
         punctuation);
 if (tb != NULL)
  textblock_append(tb, "%s", line_buffer);
 for (entry_index = 0; entry_index < total && line_count < lines_to_display;
   entry_index++) {
  char location[20] = { '\0' };
  int line_attr;
  size_t full_width;
  const char *direction_y = (list->entries[entry_index].dy <= 0) ? "N" : "S";
  const char *direction_x = (list->entries[entry_index].dx <= 0) ? "W" : "E";
  line_buffer[0] = '\0';
  if (list->entries[entry_index].count[section] == 0)
   continue;
  /* Build the location string. */
  strnfmt(location, sizeof(location), " %d %s %d %s",
    abs(list->entries[entry_index].dy), direction_y,
    abs(list->entries[entry_index].dx), direction_x);
  /* Get width available for object name: 2 for char and space; location
		 * includes padding; last -1 for some reason? */
  full_width = max_width - 2 - utf8_strlen(location) - 1;
  /* Add the object count and clip the object name to fit. */
  object_list_format_name(&list->entries[entry_index], line_buffer,
        sizeof(line_buffer));
  utf8_clipto(line_buffer, full_width);
  /* Calculate the width of the line for dynamic sizing; use a fixed max
		 * width for location and object char. */
  max_line_length = MAX(max_line_length,
         utf8_strlen(line_buffer) + 12 + 2);
  /* textblock_append_pict will safely add the object symbol, regardless
		 * of ASCII/graphics mode. */
  if (tb != NULL && tile_width == 1 && tile_height == 1) {
   uint8_t a = COLOUR_RED;
   wchar_t c = L'*';
   if (list->entries[entry_index].object->kind != NULL) {
    a = object_attr(list->entries[entry_index].object);
    c = object_char(list->entries[entry_index].object);
   }
   textblock_append_pict(tb, a, c);
   textblock_append(tb, " ");
  }
  /* Add the left-aligned and padded object name which will align the
		 * location to the right. */
  if (tb != NULL) {
   /*
			 * Hack - Because object name strings are UTF8, we have to add
			 * additional padding for any raw bytes that might be consolidated
			 * into one displayed character.
			 */
   full_width += strlen(line_buffer) - utf8_strlen(line_buffer);
   line_attr = object_list_entry_line_attribute(&list->entries[entry_index]);
   textblock_append_c(tb, line_attr, "%-*s%s\n",
    (int) full_width, line_buffer, location);
  }
  line_count++;
 }
 /* Don't worry about the "...others" line, since it's probably shorter than
	 * what's already printed. */
 if (max_width_result != NULL)
  *max_width_result = max_line_length;
 /* Bail since we don't have enough room to display the remaining count or
	 * since we've displayed them all. */
 if (lines_to_display <= 0 ||
  lines_to_display >= list->total_entries[section])
  return;
 /* Count the remaining objects, starting where we left off in the above
	 * loop. */
 remaining_object_total = total - entry_index;
 if (tb != NULL)
  textblock_append(tb, "%6s...and %d others.\n", " ", remaining_object_total);
}
/**
 * Allow the standard list formatted to be bypassed for special cases.
 *
 * Returning true will bypass any other formatteding in
 * object_list_format_textblock().
 *
 * \param list is the object list to format.
 * \param tb is the textblock to produce or NULL if only the dimensions need to
 * be calculated.
 * \param max_lines is the maximum number of lines that can be displayed.
 * \param max_width is the maximum line width that can be displayed.
 * \param max_height_result is returned with the number of lines needed to
 * format the list without truncation.
 * \param max_width_result is returned with the width needed to format the list
 * without truncation.
 * \return true if further formatting should be bypassed.
 */
static bool object_list_format_special(const object_list_t *list, textblock *tb,
            int max_lines, int max_width,
            size_t *max_height_result,
            size_t *max_width_result)
{
 return false;
}
/**
 * Format the entire object list with the given parameters.
 *
 * This function can be used to calculate the preferred dimensions for the list
 * by passing in a
 * NULL textblock. This function calls object_list_format_special() first; if
 * that function
 * returns true, it will bypass normal list formatting.
 *
 * \param list is the object list to format.
 * \param tb is the textblock to produce or NULL if only the dimensions need to
 * be calculated.
 * \param max_lines is the maximum number of lines that can be displayed.
 * \param max_width is the maximum line width that can be displayed.
 * \param max_height_result is returned with the number of lines needed to
 * format the list without truncation.
 * \param max_width_result is returned with the width needed to format the list
 * without truncation.
 */
static void object_list_format_textblock(const object_list_t *list,
           textblock *tb, int max_lines,
           int max_width,
           size_t *max_height_result,
           size_t *max_width_result)
{
 int header_lines = 1;
 int lines_remaining;
 int los_lines_to_display;
 int no_los_lines_to_display;
 size_t max_los_line = 0;
 size_t max_no_los_line = 0;
 if (list == NULL || list->entries == NULL)
  return;
 if (object_list_format_special(list, tb, max_lines, max_width,
           max_height_result, max_width_result))
  return;
 los_lines_to_display = list->total_entries[OBJECT_LIST_SECTION_LOS];
 no_los_lines_to_display = list->total_entries[OBJECT_LIST_SECTION_NO_LOS];
 if (list->total_entries[OBJECT_LIST_SECTION_NO_LOS] > 0)
  header_lines += 2;
  if (max_height_result != NULL)
  *max_height_result = header_lines + los_lines_to_display +
   no_los_lines_to_display;
 lines_remaining = max_lines - header_lines -
  list->total_entries[OBJECT_LIST_SECTION_LOS];
 /* Remove non-los lines as needed */
 if (lines_remaining < list->total_entries[OBJECT_LIST_SECTION_NO_LOS])
  no_los_lines_to_display = MAX(lines_remaining - 1, 0);
 /* If we don't even have enough room for the NO_LOS header, start removing
	 * LOS lines, leaving one for the "...others". */
 if (lines_remaining < 0)
  los_lines_to_display = list->total_entries[OBJECT_LIST_SECTION_LOS] -
                        abs(lines_remaining) - 1;
 /* Display only headers if we don't have enough space. */
 if (header_lines >= max_lines) {
  los_lines_to_display = 0;
  no_los_lines_to_display = 0;
 }
 object_list_format_section(list, tb, OBJECT_LIST_SECTION_LOS,
          los_lines_to_display, max_width,
          "You can see", false, &max_los_line);
 if (list->total_entries[OBJECT_LIST_SECTION_NO_LOS] > 0) {
         bool show_others = list->total_objects[OBJECT_LIST_SECTION_LOS] > 0;
         if (tb != NULL)
    textblock_append(tb, "\n");
         object_list_format_section(list, tb, OBJECT_LIST_SECTION_NO_LOS,
         no_los_lines_to_display, max_width,
         "You are aware of", show_others,
         &max_no_los_line);
 }
 if (max_width_result != NULL)
  *max_width_result = MAX(max_los_line, max_no_los_line);
}
/**
 * Display the object list statically. This will force the list to be displayed
 * to the provided dimensions. Contents will be adjusted accordingly.
 *
 * In order to be more efficient, this function uses a shared list object so
 * that it's not constantly allocating and freeing the list.
 *
 * \param height is the height of the list.
 * \param width is the width of the list.
 */
void object_list_show_subwindow(int height, int width)
{
 textblock *tb;
 object_list_t *list;
 if (height < 1 || width < 1)
  return;
 tb = textblock_new();
 list = object_list_shared_instance();
 object_list_reset(list);
 object_list_collect(list);
 object_list_sort(list, object_list_standard_compare);
 /* Draw the list to exactly fit the subwindow. */
 object_list_format_textblock(list, tb, height, width, NULL, NULL);
 textui_textblock_place(tb, SCREEN_REGION, NULL);
 textblock_free(tb);
}
/**
 * Display the object list interactively. This will dynamically size the list
 * for the best appearance. This should only be used in the main term.
 *
 * \param height is the height limit for the list.
 * \param width is the width limit for the list.
 */
void object_list_show_interactive(int height, int width)
{
 textblock *tb;
 object_list_t *list;
 size_t max_width = 0, max_height = 0;
 int safe_height, safe_width;
 region r;
 if (height < 1 || width < 1)
  return;
 tb = textblock_new();
 list = object_list_new();
 object_list_collect(list);
 object_list_sort(list, object_list_standard_compare);
 /*
	 * Figure out optimal display rect. Large numbers are passed as the height
	 * and width limit so that we can calculate the maximum number of rows and
	 * columns to display the list nicely. We then adjust those values as
	 * needed to fit in the main term. Height is adjusted to account for the
	 * texblock prompt. The list is positioned on the right side of the term
	 * underneath the status line.
	 */
 object_list_format_textblock(list, NULL, 1000, 1000, &max_height,
         &max_width);
 safe_height = MIN(height - 2, (int)max_height + 2);
 safe_width = MIN(width - 13, (int)max_width);
 r.col = -safe_width;
 r.row = 1;
 r.width = safe_width;
 r.page_rows = safe_height;
 /*
	 * Actually draw the list. We pass in max_height to the format function so
	 * that all lines will be appended to the textblock. The textblock itself
	 * will handle fitting it into the region. However, we have to pass
	 * safe_width so that the format function will pad the lines properly so
	 * that the location string is aligned to the right edge of the list.
	 */
 object_list_format_textblock(list, tb, (int)max_height, safe_width, NULL,
         NULL);
 region_erase_bordered(&r);
 textui_textblock_show(tb, r, NULL);
 textblock_free(tb);
 object_list_free(list);
}
/**
 * \file ui-object.c
 * \brief Object lists and selection, and other object-related UI functions
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 * Copyright (c) 2007-9 Andi Sidwell, Chris Carr, Ed Graham, Erik Osheim
 * Copyright (c) 2015 Nick McConnell
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * ------------------------------------------------------------------------
 * Variables for object display and selection
 * ------------------------------------------------------------------------ */
/**
 * Info about a particular object
 */
struct object_menu_data {
 char label[80];
 char equip_label[80];
 struct object *object;
 char o_name[80];
 char key;
};
static struct object_menu_data items[50];
static int num_obj;
static int num_head;
static size_t max_len;
static int ex_width;
static int ex_offset;
/**
 * ------------------------------------------------------------------------
 * Display of individual objects in lists or for selection
 * ------------------------------------------------------------------------ */
/**
 * Determine if the attr and char should consider the item's flavor
 */
static bool use_flavor_glyph(const struct object_kind *kind)
{
 return kind->flavor;
}
/**
 * Return the "attr" for a given item kind.
 * Use "flavor" if available.
 * Default to user definitions.
 */
uint8_t object_kind_attr(const struct object_kind *kind)
{
 return use_flavor_glyph(kind) ? flavor_x_attr[kind->flavor->fidx] :
  kind_x_attr[kind->kidx];
}
/**
 * Return the "char" for a given item kind.
 * Use "flavor" if available.
 * Default to user definitions.
 */
wchar_t object_kind_char(const struct object_kind *kind)
{
 return use_flavor_glyph(kind) ? flavor_x_char[kind->flavor->fidx] :
  kind_x_char[kind->kidx];
}
/**
 * Return the "attr" for a given item.
 * Use "flavor" if available.
 * Default to user definitions.
 */
uint8_t object_attr(const struct object *obj)
{
 return obj->artifact ?
  obj->artifact->d_attr : object_kind_attr(obj->kind);
}
/**
 * Return the "char" for a given item.
 * Use "flavor" if available.
 * Default to user definitions.
 */
wchar_t object_char(const struct object *obj)
{
 return object_kind_char(obj->kind);
}
/**
 * Display an object.  Each object may be prefixed with a label.
 * Used by show_inven(), show_equip() and show_floor().
 * Mode flags are documented in object.h
 */
static void show_obj(int obj_num, int row, int col, bool cursor,
      olist_detail_t mode)
{
 int attr;
 int label_attr = cursor ? COLOUR_L_BLUE : COLOUR_WHITE;
 int ex_offset_ctr;
 char buf[80];
 struct object *obj = items[obj_num].object;
 bool show_label = mode & (OLIST_WINDOW | OLIST_DEATH) ? true : false;
 int label_size = show_label ? strlen(items[obj_num].label) : 0;
 int equip_label_size = strlen(items[obj_num].equip_label);
 /* Clear the line */
 prt("", row + obj_num, MAX(col - 1, 0));
 /* If we have no label then we won't display anything */
 if (!strlen(items[obj_num].label)) return;
 /* Print the label */
 if (show_label)
  c_put_str(label_attr, items[obj_num].label, row + obj_num, col);
 /* Print the equipment label */
 c_put_str(label_attr, items[obj_num].equip_label, row + obj_num,
     col + label_size);
 /* Limit object name */
 if (label_size + equip_label_size + strlen(items[obj_num].o_name) >
  (size_t)ex_offset) {
  int truncate = ex_offset - label_size - equip_label_size;
  if (truncate < 0) truncate = 0;
  if ((size_t)truncate > sizeof(items[obj_num].o_name) - 1)
   truncate = sizeof(items[obj_num].o_name) - 1;
  items[obj_num].o_name[truncate] = '\0';
 }
 /* Item kind determines the color of the output */
 if (obj) {
  attr = obj->kind->base->attr;
 } else {
  attr = COLOUR_SLATE;
 }
 /* Object name */
 c_put_str(attr, items[obj_num].o_name, row + obj_num,
     col + label_size + equip_label_size);
 /* If we don't have an object, we can skip the rest of the output */
 if (!obj) return;
 /* Extra fields */
 ex_offset_ctr = ex_offset;
 /* Weight */
 if (mode & OLIST_WEIGHT) {
  int weight = obj->weight * obj->number;
  strnfmt(buf, sizeof(buf), "%4d.%1d lb", weight / 10, weight % 10);
  put_str(buf, row + obj_num, col + ex_offset_ctr);
 }
}
/**
 * ------------------------------------------------------------------------
 * Display of lists of objects
 * ------------------------------------------------------------------------ */
/**
 * Clear the object list.
 */
static void wipe_obj_list(void)
{
 int i;
 /* Zero the constants */
 num_obj = 0;
 num_head = 0;
 max_len = 0;
 ex_width = 0;
 ex_offset = 0;
 /* Clear the existing contents */
 for (i = 0; i < 50; i++) {
  my_strcpy(items[i].label, "", sizeof(items[i].label));
  my_strcpy(items[i].equip_label, "", sizeof(items[i].equip_label));
  items[i].object = NULL;
  my_strcpy(items[i].o_name, "", sizeof(items[i].o_name));
  items[i].key = '\0';
 }
}
/**
 * Build the object list.
 */
static void build_obj_list(int last, struct object **list, item_tester tester,
         olist_detail_t mode)
{
 int i;
 bool in_term = (mode & OLIST_WINDOW) ? true : false;
 bool show_empty = (mode & OLIST_SEMPTY) ? true : false;
 bool equip = list ? false : true;
 /* Build the object list */
 for (i = 0; i <= last; i++) {
  char buf[80];
  struct object *obj = equip ? slot_object(player, i) : list[i];
  /* Acceptable items get a label */
  if (object_test(tester, obj))
   strnfmt(items[num_obj].label, sizeof(items[num_obj].label), "%c) ",
    all_letters_nohjkl[i]);
  /* Unacceptable items are still sometimes shown */
  else if ((!obj && show_empty) || in_term)
   my_strcpy(items[num_obj].label, "   ",
       sizeof(items[num_obj].label));
  /* Unacceptable items are skipped in the main window */
  else continue;
  /* Show full slot labels for equipment */
  if (equip) {
   const char *mention = equip_mention(player, i);
   size_t u8len = utf8_strlen(mention);
   if (u8len < 14) {
    strnfmt(buf, sizeof(buf), "%s%*s", mention,
     (int)(14 - u8len), " ");
   } else {
    char *mention_copy = string_make(mention);
    if (u8len > 14) {
     utf8_clipto(mention_copy, 14);
    }
    strnfmt(buf, sizeof(buf), "%s", mention_copy);
    string_free(mention_copy);
   }
   my_strcpy(items[num_obj].equip_label, buf,
       sizeof(items[num_obj].equip_label));
  } else {
   strnfmt(items[num_obj].equip_label,
    sizeof(items[num_obj].equip_label), "%s", "");
  }
  /* Save the object */
  items[num_obj].object = obj;
  items[num_obj].key = (items[num_obj].label)[0];
  num_obj++;
 }
}
/**
 * Set object names and get their maximum length.
 * Only makes sense after building the object list.
 */
static void set_obj_names(bool terse, const struct player *p)
{
 int i;
 struct object *obj;
 /* Calculate name offset and max name length */
 for (i = 0; i < num_obj; i++) {
  obj = items[i].object;
  /* Null objects are used to skip lines, or display only a label */
  if (!obj) {
   if (i < num_head)
    strnfmt(items[i].o_name, sizeof(items[i].o_name), "%s", "");
   else
    strnfmt(items[i].o_name, sizeof(items[i].o_name), "(nothing)");
  } else {
   if (terse) {
    object_desc(items[i].o_name,
     sizeof(items[i].o_name), obj,
     ODESC_PREFIX | ODESC_FULL | ODESC_TERSE,
     p);
   } else {
    object_desc(items[i].o_name,
     sizeof(items[i].o_name), obj,
     ODESC_PREFIX | ODESC_FULL, p);
   }
  }
  /* Max length of label + object name */
  max_len = MAX(max_len,
       strlen(items[i].label) + strlen(items[i].equip_label) +
       strlen(items[i].o_name));
 }
}
/**
 * Display a list of objects.  Each object may be prefixed with a label.
 * Used by show_inven(), show_equip(), and show_floor().  Mode flags are
 * documented in object.h
 */
static void show_obj_list(olist_detail_t mode)
{
 int i, row = 0, col = 0;
 bool in_term = (mode & OLIST_WINDOW) ? true : false;
 bool terse = false;
 /* Initialize */
 max_len = 0;
 ex_width = 0;
 ex_offset = 0;
 if (in_term) max_len = 40;
 if (in_term && Term->wid < 40) mode &= ~(OLIST_WEIGHT);
 if (Term->wid < 50) terse = true;
 /* Set the names and get the max length */
 set_obj_names(terse, player);
 /* Width of extra fields */
 if (mode & OLIST_WEIGHT) ex_width += 9;
 /* Determine beginning row and column */
 if (in_term) {
  /* Term window */
  row = 0;
  col = 0;
 } else {
  /* Main window */
  row = 1;
  col = Term->wid - 1 - max_len - ex_width;
  if (col < 3) col = 0;
 }
 /* Column offset of the first extra field */
 ex_offset = MIN(max_len, (size_t)(Term->wid - 1 - ex_width - col));
 /* Output the list */
 for (i = 0; i < num_obj; i++)
  show_obj(i, row, col, false, mode);
 /* Clear term windows */
 if (in_term) {
  for (; i < Term->hgt; i++)
   prt("", row + i, MAX(col - 2, 0));
 } else if (i > 0 && row + i < 24) {
  /* Print a drop shadow for the main window if necessary */
  prt("", row + i, MAX(col - 2, 0));
 }
}
/**
 * Display the inventory.  Builds a list of objects and passes them
 * off to show_obj_list() for display.  Mode flags documented in
 * object.h
 */
void show_inven(int mode, item_tester tester)
{
 int i, last_slot = -1;
 int diff = weight_remaining(player);
 bool in_term = (mode & OLIST_WINDOW) ? true : false;
 /* Initialize */
 wipe_obj_list();
 /* Include burden for term windows */
 if (in_term) {
  strnfmt(items[num_obj].label, sizeof(items[num_obj].label),
          "Burden %d.%d lb (%d.%d lb %s) ",
          player->upkeep->total_weight / 10,
    player->upkeep->total_weight % 10,
          abs(diff) / 10, abs(diff) % 10,
          (diff < 0 ? "overweight" : "remaining"));
  items[num_obj].object = NULL;
  num_obj++;
 }
 /* Find the last occupied inventory slot */
 for (i = 0; i < z_info->pack_size; i++)
  if (player->upkeep->inven[i] != NULL) last_slot = i;
 /* Build the object list */
 build_obj_list(last_slot, player->upkeep->inven, tester, mode);
 /* Term window starts with a burden header */
 num_head = in_term ? 1 : 0;
 /* Display the object list */
 show_obj_list(mode);
}
/**
 * Display the equipment.  Builds a list of objects and passes them
 * off to show_obj_list() for display.  Mode flags documented in
 * object.h
 */
void show_equip(int mode, item_tester tester)
{
 /* Initialize */
 wipe_obj_list();
 /* Build the object list */
 build_obj_list(player->body.count - 1, NULL, tester, mode);
 /* Display the object list */
 num_head = 0;
 show_obj_list(mode);
}
/**
 * Display the floor.  Builds a list of objects and passes them
 * off to show_obj_list() for display.  Mode flags documented in
 * object.h
 */
void show_floor(struct object **floor_list, int floor_num, int mode,
    item_tester tester)
{
 /* Initialize */
 wipe_obj_list();
 if (floor_num > z_info->floor_size)
  floor_num = z_info->floor_size;
 /* Build the object list */
 build_obj_list(floor_num - 1, floor_list, tester, mode);
 /* Display the object list */
 num_head = 0;
 show_obj_list(mode);
}
/**
 * ------------------------------------------------------------------------
 * Variables for object selection
 * ------------------------------------------------------------------------ */
static item_tester tester_m;
static region area = { 20, 1, -1, -2 };
static struct object *selection;
static const char *prompt;
static char header[80];
static int i1, i2;
static int e1, e2;
static int f1, f2;
static int throwing_num;
static struct object **floor_list;
static struct object **throwing_list;
static olist_detail_t olist_mode = 0;
static int item_mode;
static cmd_code item_cmd;
static bool newmenu = false;
static bool allow_all = false;
/**
 * ------------------------------------------------------------------------
 * Object selection utilities
 * ------------------------------------------------------------------------ */
/**
 * Prevent certain choices depending on the inscriptions on the item.
 *
 * The item can be negative to mean "item on floor".
 */
bool get_item_allow(const struct object *obj, unsigned char ch, cmd_code cmd,
     bool is_harmless)
{
 char verify_inscrip[] = "!*";
 unsigned n;
 /* Hack - Only shift the command key if it actually needs to be shifted. */
 if (ch < 0x20)
  ch = UN_KTRL(ch);
 /* The inscription to look for */
 verify_inscrip[1] = ch;
 /* Look for the inscription */
 n = check_for_inscrip(obj, verify_inscrip);
 /* Also look for the inscription '!*' */
 if (!is_harmless)
  n += check_for_inscrip(obj, "!*");
 /* Choose string for the prompt */
 if (n) {
  char prompt_buf[1024];
  const char *verb = cmd_verb(cmd);
  if (!verb)
   verb = "do that with";
  strnfmt(prompt_buf, sizeof(prompt_buf), "Really %s", verb);
  /* Prompt for confirmation n times */
  while (n--) {
   if (!verify_object(prompt_buf, obj, player)) {
    return false;
   }
  }
 }
 /* Allow it */
 return (true);
}
/**
 * Find the first object in the object list with the given "tag".  The object
 * list needs to be built before this function is called.
 *
 * A "tag" is a char "n" appearing as "@n" anywhere in the
 * inscription of an object.
 *
 * Also, the tag "@xn" will work as well, where "n" is a tag-char,
 * and "x" is the action that tag will work for.
 */
static bool get_tag(struct object **tagged_obj, char tag, cmd_code cmd)
{
 int i;
 int mode = OPT(player, angband_keyset) ? KEYMAP_MODE_ANGBAND : KEYMAP_MODE_ORIG;
 if (OPT(player, hjkl_movement)) {
  mode |= KEYMAP_MODE_ROGUE;
 }
 /* Check every object in the object list */
 for (i = 0; i < num_obj; i++) {
  const char *s;
  struct object *obj = items[i].object;
  /* Skip non-objects */
  if (!obj) continue;
  /* Skip empty inscriptions */
  if (!obj->note) continue;
  /* Find a '@' */
  s = strchr(quark_str(obj->note), '@');
  /* Process all tags */
  while (s) {
   unsigned char cmdkey;
   /* Check the normal tags */
   if (s[1] == tag) {
    /* Save the actual object */
    *tagged_obj = obj;
    /* Success */
    return true;
   }
   cmdkey = cmd_lookup_key(cmd, mode);
   /* Hack - Only shift the command key if it actually needs to be. */
   if (cmdkey < 0x20)
    cmdkey = UN_KTRL(cmdkey);
   /* Check the special tags */
   if ((s[1] == cmdkey) && (s[2] == tag)) {
    /* Save the actual inventory ID */
    *tagged_obj = obj;
    /* Success */
    return true;
   }
   /* Find another '@' */
   s = strchr(s + 1, '@');
  }
 }
 /* No such tag */
 return false;
}
/**
 * ------------------------------------------------------------------------
 * Object selection menu
 * ------------------------------------------------------------------------ */
/**
 * Make the correct header for the selection menu
 */
static void menu_header(void)
{
 char tmp_val[75];
 char out_val[75];
 bool use_inven = ((item_mode & USE_INVEN) ? true : false);
 bool use_equip = ((item_mode & USE_EQUIP) ? true : false);
 bool allow_floor = ((f1 <= f2) || allow_all);
 /* Viewing inventory */
 if (player->upkeep->command_wrk == USE_INVEN) {
  /* Begin the header */
  strnfmt(out_val, sizeof(out_val), "Inven:");
  /* List choices */
  if (i1 <= i2) {
   /* Build the header */
   strnfmt(tmp_val, sizeof(tmp_val), " %c-%c,",
    all_letters_nohjkl[i1], all_letters_nohjkl[i2]);
   /* Append */
   my_strcat(out_val, tmp_val, sizeof(out_val));
  }
  /* Indicate legality of equipment */
  if (use_equip)
   my_strcat(out_val, " / for Equip,", sizeof(out_val));
  /* Indicate legality of the "floor" */
  if (allow_floor)
   my_strcat(out_val, " - for floor,", sizeof(out_val));
 }
 /* Viewing equipment */
 else if (player->upkeep->command_wrk == USE_EQUIP) {
  /* Begin the header */
  strnfmt(out_val, sizeof(out_val), "Equip:");
  /* List choices */
  if (e1 <= e2) {
   /* Build the header */
   strnfmt(tmp_val, sizeof(tmp_val), " %c-%c,",
    all_letters_nohjkl[e1], all_letters_nohjkl[e2]);
   /* Append */
   my_strcat(out_val, tmp_val, sizeof(out_val));
  }
  /* Indicate legality of inventory */
  if (use_inven)
   my_strcat(out_val, " / for Inven,", sizeof(out_val));
  /* Indicate legality of the "floor" */
  if (allow_floor)
   my_strcat(out_val, " - for floor,", sizeof(out_val));
 }
 /* Viewing throwing */
 else if (player->upkeep->command_wrk == SHOW_THROWING) {
  /* Begin the header */
  strnfmt(out_val, sizeof(out_val), "Throwing items:");
  /* List choices */
  if (throwing_num) {
   /* Build the header */
   strnfmt(tmp_val, sizeof(tmp_val), " a-%c,",
    all_letters_nohjkl[throwing_num - 1]);
   /* Append */
   my_strcat(out_val, tmp_val, sizeof(out_val));
  }
  /* Indicate legality of inventory */
  if (use_inven)
   my_strcat(out_val, " / for Inven,", sizeof(out_val));
  /* Indicate legality of the "floor" */
  if (allow_floor)
   my_strcat(out_val, " - for floor,", sizeof(out_val));
 }
 /* Viewing floor */
 else {
  /* Begin the header */
  strnfmt(out_val, sizeof(out_val), "Floor:");
  /* List choices */
  if (f1 <= f2) {
   /* Build the header */
   strnfmt(tmp_val, sizeof(tmp_val), " %c-%c,",
    all_letters_nohjkl[f1], all_letters_nohjkl[f2]);
   /* Append */
   my_strcat(out_val, tmp_val, sizeof(out_val));
  }
  /* Indicate legality of inventory or equipment */
  if (use_inven)
   my_strcat(out_val, " / for Inven,", sizeof(out_val));
  else if (use_equip)
   my_strcat(out_val, " / for Equip,", sizeof(out_val));
 }
 /* Finish the header */
 my_strcat(out_val, " ESC", sizeof(out_val));
 /* Build the header */
 strnfmt(header, sizeof(header), "(%s)", out_val);
}
/**
 * Get an item tag
 */
static char get_item_tag(struct menu *menu, int oid)
{
 struct object_menu_data *choice = menu_priv(menu);
 return choice[oid].key;
}
/**
 * Determine if an item is a valid choice
 */
static int get_item_validity(struct menu *menu, int oid)
{
 struct object_menu_data *choice = menu_priv(menu);
 return (choice[oid].object != NULL) ? 1 : 0;
}
/**
 * Display an entry on the item menu
 */
static void get_item_display(struct menu *menu, int oid, bool cursor, int row,
       int col, int width)
{
 /* Print it */
 show_obj(oid, row - oid, col, cursor, olist_mode);
}
/**
 * Deal with events on the get_item menu
 */
static bool get_item_action(struct menu *menu, const ui_event *event, int oid)
{
 struct object_menu_data *choice = menu_priv(menu);
 char key = event->key.code;
 bool is_harmless = item_mode & IS_HARMLESS ? true : false;
 int mode = OPT(player, angband_keyset) ? KEYMAP_MODE_ANGBAND : KEYMAP_MODE_ORIG;
 if (OPT(player, hjkl_movement)) {
  mode |= KEYMAP_MODE_ROGUE;
 }
 if (event->type == EVT_SELECT) {
  if (choice[oid].object && get_item_allow(choice[oid].object,
             cmd_lookup_key(item_cmd, mode),
             item_cmd, is_harmless))
   selection = choice[oid].object;
 }
 if (event->type == EVT_KBRD) {
  if (key == '/') {
   /* Toggle if allowed */
   if (((item_mode & USE_INVEN) || allow_all)
    && (player->upkeep->command_wrk != USE_INVEN)) {
    player->upkeep->command_wrk = USE_INVEN;
    newmenu = true;
   } else if (((item_mode & USE_EQUIP) || allow_all) &&
        (player->upkeep->command_wrk != USE_EQUIP)) {
    player->upkeep->command_wrk = USE_EQUIP;
    newmenu = true;
   } else {
    bell();
   }
  }
  else if (key == '-') {
   /* No toggle allowed */
   if ((f1 > f2) && !allow_all) {
    bell();
   } else {
    /* Toggle to floor */
    player->upkeep->command_wrk = (USE_FLOOR);
    newmenu = true;
   }
  }
 }
 return false;
}
/**
 * Display list items to choose from
 */
static struct object *item_menu(cmd_code cmd, int prompt_size, int mode)
{
 menu_iter menu_f = { get_item_tag, get_item_validity, get_item_display,
       get_item_action, 0 };
 struct menu *m = menu_new(MN_SKIN_OBJECT, &menu_f);
 ui_event evt = { 0 };
 int ex_offset_ctr = 0;
 int row, inscrip;
 struct object *obj = NULL;
 /* Set up the menu */
 menu_setpriv(m, num_obj, items);
 m->selections = all_letters_nohjkl;
 m->switch_keys = "/|-";
 m->flags = (MN_PVT_TAGS | MN_INSCRIP_TAGS);
 /* Get inscriptions */
 m->inscriptions = mem_zalloc(10 * sizeof(char));
 for (inscrip = 0; inscrip < 10; inscrip++) {
  /* Look up the tag */
  if (get_tag(&obj, (char)inscrip + '0', item_cmd)) {
   int i;
   for (i = 0; i < num_obj; i++)
    if (items[i].object == obj)
      break;
   if (i < num_obj)
    m->inscriptions[inscrip] = get_item_tag(m, i);
  }
 }
 /* Set up the item list variables */
 selection = NULL;
 set_obj_names(false, player);
 if (olist_mode & OLIST_WEIGHT) {
  ex_width += 9;
  ex_offset_ctr += 9;
 }
 /* Set up the menu region */
 area.page_rows = m->count;
 area.row = 1;
 area.col = MIN(Term->wid - 1 - (int) max_len - ex_width, prompt_size - 2);
 if (area.col <= 3)
  area.col = 0;
 ex_offset = MIN(max_len, (size_t)(Term->wid - 1 - ex_width - area.col));
 while (strlen(header) < max_len + ex_width + ex_offset_ctr) {
  my_strcat(header, " ", sizeof(header));
  if (strlen(header) > sizeof(header) - 2) break;
 }
 area.width = MAX(max_len, strlen(header));
 for (row = area.row; row < area.row + area.page_rows; row++)
  prt("", row, MAX(0, area.col - 1));
 menu_layout(m, &area);
 /* Choose */
 evt = menu_select(m, 0, true);
 /* Clean up */
 mem_free(m->inscriptions);
 mem_free(m);
 /* Deal with menu switch */
 if (evt.type == EVT_SWITCH && !newmenu) {
  bool left = evt.key.code == ARROW_LEFT;
  if (player->upkeep->command_wrk == USE_EQUIP) {
   if (left) {
    if (f1 <= f2) player->upkeep->command_wrk = USE_FLOOR;
    else if (i1 <= i2) player->upkeep->command_wrk = USE_INVEN;
   } else {
    if (i1 <= i2) player->upkeep->command_wrk = USE_INVEN;
    else if (f1 <= f2) player->upkeep->command_wrk = USE_FLOOR;
   }
  } else if (player->upkeep->command_wrk == USE_INVEN) {
   if (left) {
    if (e1 <= e2) player->upkeep->command_wrk = USE_EQUIP;
    else if (f1 <= f2) player->upkeep->command_wrk = USE_FLOOR;
   } else {
    if (f1 <= f2) player->upkeep->command_wrk = USE_FLOOR;
    else if (e1 <= e2) player->upkeep->command_wrk = USE_EQUIP;
   }
  } else if (player->upkeep->command_wrk == USE_FLOOR) {
   if (left) {
    if (i1 <= i2) player->upkeep->command_wrk = USE_INVEN;
    else if (e1 <= e2) player->upkeep->command_wrk = USE_EQUIP;
   } else {
    if (e1 <= e2) player->upkeep->command_wrk = USE_EQUIP;
    else if (i1 <= i2) player->upkeep->command_wrk = USE_INVEN;
   }
  } else if (player->upkeep->command_wrk == SHOW_THROWING) {
   if (left) {
    if (i1 <= i2) player->upkeep->command_wrk = USE_INVEN;
    else if (e1 <= e2) player->upkeep->command_wrk = USE_EQUIP;
   } else {
    if (e1 <= e2) player->upkeep->command_wrk = USE_EQUIP;
    else if (i1 <= i2) player->upkeep->command_wrk = USE_INVEN;
   }
  }
  newmenu = true;
 }
 /* Result */
 return selection;
}
/**
 * Let the user select an object, save its address
 *
 * Return true only if an acceptable item was chosen by the user.
 *
 * The user is allowed to choose acceptable items from the equipment,
 * inventory, or floor, respectively, if the proper flag was given,
 * and there are any acceptable items in that location.
 *
 * The equipment or inventory are displayed (even if no acceptable
 * items are in that location) if the proper flag was given.
 *
 * If there are no acceptable items available anywhere, and "str" is
 * not NULL, then it will be used as the text of a warning message
 * before the function returns.
 *
 * If a legal item is selected , we save it in "choice" and return true.
 *
 * If no item is available, we do nothing to "choice", and we display a
 * warning message, using "str" if available, and return false.
 *
 * If no item is selected, we do nothing to "choice", and return false.
 *
 * Global "player->upkeep->command_wrk" is used to choose between
 * equip/inven/floor listings.  It is equal to USE_INVEN or USE_EQUIP or
 * USE_FLOOR, except when this function is first called, when it
 * is equal to zero, which will cause it to be set to USE_INVEN.
 *
 * We always erase the prompt when we are done, leaving a blank line,
 * or a warning message, if appropriate, if no items are available.
 *
 * Note that only "acceptable" floor objects get indexes, so between two
 * commands, the indexes of floor objects may change.  XXX XXX XXX
 */
bool textui_get_item(struct object **choice, const char *pmt, const char *str,
      cmd_code cmd, item_tester tester, int mode)
{
 bool use_inven = ((mode & USE_INVEN) ? true : false);
 bool use_equip = ((mode & USE_EQUIP) ? true : false);
 bool use_floor = ((mode & USE_FLOOR) ? true : false);
 bool show_throwing = ((mode & SHOW_THROWING) ? true : false);
 bool allow_inven = false;
 bool allow_equip = false;
 bool allow_floor = false;
 bool toggle = false;
 int floor_max = z_info->floor_size;
 int floor_num;
 int throwing_max = z_info->pack_size + z_info->floor_size;
 floor_list = mem_zalloc(floor_max * sizeof(*floor_list));
 throwing_list = mem_zalloc(throwing_max * sizeof(*throwing_list));
 olist_mode = 0;
 item_mode = mode;
 item_cmd = cmd;
 tester_m = tester;
 prompt = pmt;
 allow_all = str ? false : true;
 /* Object list display modes */
 olist_mode |= OLIST_WEIGHT;
 if (mode & SHOW_EMPTY)
  olist_mode |= OLIST_SEMPTY;
 /* Paranoia XXX XXX XXX */
 event_signal(EVENT_MESSAGE_FLUSH);
 /* Full inventory */
 i1 = 0;
 i2 = z_info->pack_size - 1;
 /* Forbid inventory */
 if (!use_inven) i2 = -1;
 /* Restrict inventory indexes */
 while ((i1 <= i2) && (!object_test(tester, player->upkeep->inven[i1])))
  i1++;
 while ((i1 <= i2) && (!object_test(tester, player->upkeep->inven[i2])))
  i2--;
 /* Accept inventory */
 if ((i1 <= i2) || allow_all)
  allow_inven = true;
 else if (item_mode & USE_INVEN)
  item_mode -= USE_INVEN;
 /* Full equipment */
 e1 = 0;
 e2 = player->body.count - 1;
 /* Forbid equipment */
 if (!use_equip) e2 = -1;
 /* Restrict equipment indexes unless starting with no command */
 if ((cmd != CMD_NULL) || (tester != NULL)) {
  while ((e1 <= e2) && (!object_test(tester, slot_object(player, e1))))
   e1++;
  while ((e1 <= e2) && (!object_test(tester, slot_object(player, e2))))
   e2--;
 }
 /* Accept equipment */
 if ((e1 <= e2) || allow_all)
  allow_equip = true;
 else if (item_mode & USE_EQUIP)
  item_mode -= USE_EQUIP;
 /* Scan all non-gold objects in the grid */
 floor_num = scan_floor(floor_list, floor_max, player,
  OFLOOR_TEST | OFLOOR_SENSE | OFLOOR_VISIBLE, tester);
 /* Full floor */
 f1 = 0;
 f2 = floor_num - 1;
 /* Forbid floor */
 if (!use_floor) f2 = -1;
 /* Restrict floor indexes */
 while ((f1 <= f2) && (!object_test(tester, floor_list[f1]))) f1++;
 while ((f1 <= f2) && (!object_test(tester, floor_list[f2]))) f2--;
 /* Accept floor */
 if ((f1 <= f2) || allow_all)
  allow_floor = true;
 else if (item_mode & USE_FLOOR)
  item_mode -= USE_FLOOR;
 /* Scan all throwing objects in reach */
 throwing_num = scan_items(throwing_list, throwing_max, player,
  USE_INVEN | USE_FLOOR, obj_is_throwing);
 /* Require at least one legal choice */
 if (allow_inven || allow_equip || allow_floor) {
  /* Use throwing menu if at all possible */
  if (show_throwing && throwing_num) {
   player->upkeep->command_wrk = SHOW_THROWING;
   /* Start where requested if possible */
  } else if ((player->upkeep->command_wrk == USE_EQUIP) && allow_equip)
   player->upkeep->command_wrk = USE_EQUIP;
  else if ((player->upkeep->command_wrk == USE_INVEN) && allow_inven)
   player->upkeep->command_wrk = USE_INVEN;
  else if ((player->upkeep->command_wrk == USE_FLOOR) && allow_floor)
   player->upkeep->command_wrk = USE_FLOOR;
  /* Otherwise choose whatever is allowed */
  else if (use_inven && allow_inven)
   player->upkeep->command_wrk = USE_INVEN;
  else if (use_equip && allow_equip)
   player->upkeep->command_wrk = USE_EQUIP;
  else if (use_floor && allow_floor)
   player->upkeep->command_wrk = USE_FLOOR;
  /* If nothing to choose, use (empty) inventory */
  else
   player->upkeep->command_wrk = USE_INVEN;
  while (true) {
   int j;
   int ni = 0;
   int ne = 0;
   /* If inven or equip is on the main screen, and only one of them
			 * is slated for a subwindow, we should show the opposite there */
   for (j = 0; j < ANGBAND_TERM_MAX; j++) {
    /* Unused */
    if (!angband_term[j]) continue;
    /* Count windows displaying inven */
    if (window_flag[j] & (PW_INVEN)) ni++;
    /* Count windows displaying equip */
    if (window_flag[j] & (PW_EQUIP)) ne++;
   }
   /* Are we in the situation where toggling makes sense? */
   if ((ni && !ne) || (!ni && ne)) {
    if (player->upkeep->command_wrk == USE_EQUIP) {
     if ((ne && !toggle) || (ni && toggle)) {
      /* Main screen is equipment, so is subwindow */
      toggle_inven_equip();
      toggle = !toggle;
     }
    } else if (player->upkeep->command_wrk == USE_INVEN) {
     if ((ni && !toggle) || (ne && toggle)) {
      /* Main screen is inventory, so is subwindow */
      toggle_inven_equip();
      toggle = !toggle;
     }
    } else {
     /* Floor, go back to the original */
     if (toggle) {
      toggle_inven_equip();
      toggle = !toggle;
     }
    }
   }
   /* Redraw */
   player->upkeep->redraw |= (PR_INVEN | PR_EQUIP);
   /* Redraw windows */
   redraw_stuff(player);
   /* Save screen */
   screen_save();
   /* Build object list */
   wipe_obj_list();
   if (player->upkeep->command_wrk == USE_INVEN)
    build_obj_list(i2, player->upkeep->inven, tester_m, olist_mode);
   else if (player->upkeep->command_wrk == USE_EQUIP)
    build_obj_list(e2, NULL, tester_m, olist_mode);
   else if (player->upkeep->command_wrk == USE_FLOOR)
    build_obj_list(f2, floor_list, tester_m, olist_mode);
   else if (player->upkeep->command_wrk == SHOW_THROWING)
    build_obj_list(throwing_num, throwing_list, tester_m,
          olist_mode);
   /* Show the prompt */
   menu_header();
   if (pmt) {
    prt(pmt, 0, 0);
    prt(header, 0, strlen(pmt) + 1);
   }
   /* No menu change request */
   newmenu = false;
   /* Get an item choice */
   *choice = item_menu(cmd, MAX(pmt ? strlen(pmt) : 0, 15), mode);
   /* Fix the screen */
   screen_load();
   /* Update */
   player->upkeep->redraw |= (PR_INVEN | PR_EQUIP);
   redraw_stuff(player);
   /* Clear the prompt line */
   prt("", 0, 0);
   /* We have a selection, or are backing out */
   if (*choice || !newmenu) {
    if (toggle) toggle_inven_equip();
    break;
   }
  }
 } else {
  /* Warning if needed */
  if (str) msg("%s", str);
  *choice = NULL;
 }
 /* Clean up */
 player->upkeep->command_wrk = 0;
 mem_free(throwing_list);
 mem_free(floor_list);
 /* Result */
 return (*choice != NULL) ? true : false;
}
/**
 * ------------------------------------------------------------------------
 * Object recall
 * ------------------------------------------------------------------------ */
/**
 * This draws the Object Recall subwindow when displaying a particular object
 * (e.g. a helmet in the backpack, or a scroll on the ground)
 */
void display_object_recall(struct object *obj)
{
 char header_buf[120];
 textblock *tb = object_info(obj, OINFO_NONE);
 object_desc(header_buf, sizeof(header_buf), obj,
  ODESC_PREFIX | ODESC_FULL, player);
 clear_from(0);
 textui_textblock_place(tb, SCREEN_REGION, header_buf);
 textblock_free(tb);
}
/**
 * This draws the Object Recall subwindow when displaying a recalled item kind
 * (e.g. a generic ring of acid or a generic blade of chaos)
 */
void display_object_kind_recall(struct object_kind *kind)
{
 struct object object = OBJECT_NULL, known_obj = OBJECT_NULL;
 object_prep(&object, kind, 0, EXTREMIFY);
 if (kind->aware || !kind->flavor) {
  object_copy(&known_obj, &object);
 }
 object.known = &known_obj;
 display_object_recall(&object);
 object_wipe(&known_obj);
 object_wipe(&object);
}
/**
 * Display object recall modally and wait for a keypress.
 *
 * This is set up for use in look mode (see target_set_interactive_aux()).
 *
 * \param obj is the object to be described.
 */
void display_object_recall_interactive(struct object *obj)
{
 char header_buf[120];
 textblock *tb;
 event_signal(EVENT_MESSAGE_FLUSH);
 tb = object_info(obj, OINFO_NONE);
 object_desc(header_buf, sizeof(header_buf), obj,
  ODESC_PREFIX | ODESC_FULL, player);
 textui_textblock_show(tb, SCREEN_REGION, header_buf);
 textblock_free(tb);
}
/**
 * Examine an object
 */
void textui_obj_examine(void)
{
 char header_buf[120];
 textblock *tb;
 region local_area = { 0, 0, 0, 0 };
 struct object *obj;
 /* Select item */
 if (!get_item(&obj, "Examine which item?", "You have nothing to examine.",
   CMD_NULL, NULL, (USE_EQUIP | USE_INVEN | USE_FLOOR | IS_HARMLESS)))
  return;
 /* Track object for object recall */
 track_object(player->upkeep, obj);
 /* Display info */
 tb = object_info(obj, OINFO_NONE);
 object_desc(header_buf, sizeof(header_buf), obj,
  ODESC_PREFIX | ODESC_FULL | ODESC_CAPITAL, player);
 textui_textblock_show(tb, local_area, header_buf);
 textblock_free(tb);
}
/**
 * ------------------------------------------------------------------------
 * Object ignore interface
 * ------------------------------------------------------------------------ */
enum {
 IGNORE_THIS_ITEM,
 UNIGNORE_THIS_ITEM,
 IGNORE_THIS_FLAVOR,
 UNIGNORE_THIS_FLAVOR,
 IGNORE_THIS_EGO,
 UNIGNORE_THIS_EGO,
 IGNORE_THIS_QUALITY
};
void textui_cmd_ignore_menu(struct object *obj)
{
 char out_val[160];
 struct menu *m;
 region r;
 int selected;
 uint8_t value;
 int type;
 if (!obj)
  return;
 m = menu_dynamic_new();
 m->selections = lower_case;
 /* Basic ignore option */
 if (!(obj->known->notice & OBJ_NOTICE_IGNORE)) {
  menu_dynamic_add(m, "This item only", IGNORE_THIS_ITEM);
 } else {
  menu_dynamic_add(m, "Unignore this item", UNIGNORE_THIS_ITEM);
 }
 /* Flavour-aware ignore */
 if (ignore_tval(obj->tval) &&
   (!obj->artifact || !object_flavor_is_aware(obj))) {
  bool ignored = kind_is_ignored_aware(obj->kind) ||
    kind_is_ignored_unaware(obj->kind);
  char tmp[70];
  object_desc(tmp, sizeof(tmp), obj,
   ODESC_NOEGO | ODESC_BASE | ODESC_PLURAL, player);
  if (!ignored) {
   strnfmt(out_val, sizeof out_val, "All %s", tmp);
   menu_dynamic_add(m, out_val, IGNORE_THIS_FLAVOR);
  } else {
   strnfmt(out_val, sizeof out_val, "Unignore all %s", tmp);
   menu_dynamic_add(m, out_val, UNIGNORE_THIS_FLAVOR);
  }
 }
 type = ignore_type_of(obj);
 /* Ego ignoring */
 if (obj->known->ego && type != ITYPE_MAX) {
  struct ego_desc choice;
  struct ego_item *ego = obj->ego;
  char tmp[80] = "";
  choice.e_idx = ego->eidx;
  choice.itype = type;
  choice.short_name = "";
  (void) ego_item_name(tmp, sizeof(tmp), &choice);
  if (!ego_is_ignored(choice.e_idx, choice.itype)) {
   strnfmt(out_val, sizeof out_val, "All %s", tmp + 4);
   menu_dynamic_add(m, out_val, IGNORE_THIS_EGO);
  } else {
   strnfmt(out_val, sizeof out_val, "Unignore all %s", tmp + 4);
   menu_dynamic_add(m, out_val, UNIGNORE_THIS_EGO);
  }
 }
 /* Quality ignoring */
 value = ignore_level_of(obj);
 if (tval_is_jewelry(obj) && ignore_level_of(obj) != IGNORE_BAD)
  value = IGNORE_MAX;
 if (value != IGNORE_MAX && type != ITYPE_MAX) {
  strnfmt(out_val, sizeof out_val, "All %s %s",
    quality_values[value].name, ignore_name_for_type(type));
  menu_dynamic_add(m, out_val, IGNORE_THIS_QUALITY);
 }
 /* Work out display region */
 r.width = menu_dynamic_longest_entry(m) + 3 + 2; /* +3 for tag, 2 for pad */
 r.col = 80 - r.width;
 r.row = 1;
 r.page_rows = m->count;
 screen_save();
 menu_layout(m, &r);
 region_erase_bordered(&r);
 prt("(Enter to select, ESC) Ignore:", 0, 0);
 selected = menu_dynamic_select(m);
 screen_load();
 if (selected == IGNORE_THIS_ITEM) {
  obj->known->notice |= OBJ_NOTICE_IGNORE;
 } else if (selected == UNIGNORE_THIS_ITEM) {
  obj->known->notice &= ~(OBJ_NOTICE_IGNORE);
 } else if (selected == IGNORE_THIS_FLAVOR) {
  object_ignore_flavor_of(obj);
 } else if (selected == UNIGNORE_THIS_FLAVOR) {
  kind_ignore_clear(obj->kind);
 } else if (selected == IGNORE_THIS_EGO) {
  ego_ignore(obj);
 } else if (selected == UNIGNORE_THIS_EGO) {
  ego_ignore_clear(obj);
 } else if (selected == IGNORE_THIS_QUALITY) {
  uint8_t ignore_value = ignore_level_of(obj);
  int ignore_type = ignore_type_of(obj);
  ignore_level[ignore_type] = ignore_value;
 }
 player->upkeep->notice |= PN_IGNORE;
 menu_dynamic_free(m);
}
void textui_cmd_ignore(void)
{
 struct object *obj;
 /* Get an item */
 const char *q = "Ignore which item? ";
 const char *s = "You have nothing to ignore.";
 if (!get_item(&obj, q, s, CMD_IGNORE, NULL,
      USE_INVEN | USE_EQUIP | USE_FLOOR))
  return;
 textui_cmd_ignore_menu(obj);
}
void textui_cmd_toggle_ignore(void)
{
 player->unignoring = !player->unignoring;
 player->upkeep->notice |= PN_IGNORE;
 do_cmd_redraw();
}
/**
 * \file ui-options.c
 * \brief Text UI options handling code (everything accessible from '=')
 *
 * Copyright (c) 1997-2000 Robert A. Koeneke, James E. Wilson, Ben Harrison
 * Copyright (c) 2007 Pete Mack
 * Copyright (c) 2010 Andi Sidwell
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Prompt the user for a filename to save the pref file to.
 */
static bool get_pref_path(const char *what, int row, char *buf, size_t max)
{
 char ftmp[80];
 bool ok;
 screen_save();
 /* Prompt */
 if (row > 0) {
  prt("", row - 1, 0);
 }
 prt(format("%s to a pref file", what), row, 0);
 prt("", row + 1, 0);
 prt("File: ", row + 2, 0);
 prt("", row + 3, 0);
 /* Get the filesystem-safe name and append .prf */
 player_safe_name(ftmp, sizeof(ftmp), player->full_name, true);
 my_strcat(ftmp, ".prf", sizeof(ftmp));
 /* Get a filename */
 if(!arg_force_name)
  ok = askfor_aux(ftmp, sizeof ftmp, NULL);
 else
  ok = get_check(format("Confirm writing to %s? ", ftmp));
 screen_load();
 /* Build the filename */
 if (ok)
  path_build(buf, max, ANGBAND_DIR_USER, ftmp);
 return ok;
}
static void dump_pref_file(void (*dump)(ang_file *), const char *title, int row)
{
 char buf[1024];
 /* Get filename from user */
 if (!get_pref_path(title, row, buf, sizeof(buf)))
  return;
 /* Try to save */
 if (prefs_save(buf, dump, title))
  msg("Saved %s.", strstr(title, " ") + 1);
 else
  msg("Failed to save %s.", strstr(title, " ") + 1);
 event_signal(EVENT_MESSAGE_FLUSH);
 return;
}
static void do_cmd_pref_file_hack(long row);
/**
 * ------------------------------------------------------------------------
 * Options display and setting
 * ------------------------------------------------------------------------ */
/**
 * Displays an option entry.
 */
static void option_toggle_display(struct menu *m, int oid, bool cursor,
  int row, int col, int width)
{
 uint8_t attr = curs_attrs[CURS_KNOWN][cursor != 0];
 bool *options = menu_priv(m);
 const char *desc = option_desc(oid);
 size_t u8len = utf8_strlen(desc);
 if (u8len < 45) {
  c_prt(attr, format("%s%*s", desc, (int)(45 - u8len), " "), row,
   col);
 } else {
  char *desc_copy = string_make(desc);
  if (u8len > 45) {
   utf8_clipto(desc_copy, 45);
  }
  c_prt(attr, desc_copy, row, col);
  string_free(desc_copy);
 }
 c_prt(attr, format(": %s  (%s)", options[oid] ? "yes" : "no ",
  option_name(oid)), row, col + 45);
}
/**
 * Handle keypresses for an option entry.
 */
static bool option_toggle_handle(struct menu *m, const ui_event *event,
  int oid)
{
 bool next = false;
 int page = option_type(oid);
 if (event->type == EVT_SELECT) {
  /* Hack -- birth options can not be toggled after birth */
  /* At birth, m->flags == MN_DBL_TAP. */
  /* After birth, m->flags == MN_NO_TAGS */
  if (!((page == OP_BIRTH) && (m->flags == MN_NO_TAGS))) {
   option_set(option_name(oid), !player->opts.opt[oid]);
  }
 } else if (event->type == EVT_KBRD) {
  if (event->key.code == 'y' || event->key.code == 'Y') {
   option_set(option_name(oid), true);
   next = true;
  } else if (event->key.code == 'n' || event->key.code == 'N') {
   option_set(option_name(oid), false);
   next = true;
  } else if (event->key.code == 't' || event->key.code == 'T') {
   option_set(option_name(oid), !player->opts.opt[oid]);
  } else if (event->key.code == 's' || event->key.code == 'S') {
   char dummy;
   screen_save();
   if (options_save_custom(&player->opts, page)) {
    get_com("Successfully saved.  Press any key to continue.", &dummy);
   } else {
    get_com("Save failed.  Press any key to continue.", &dummy);
   }
   screen_load();
  /*
		 * For birth options, only allow restore from custom defaults
		 * at birth.
		 */
  } else if ((event->key.code == 'r' || event->key.code == 'R') &&
    (page != OP_BIRTH || m->flags == MN_DBL_TAP)) {
   screen_save();
   if (options_restore_custom(&player->opts, page)) {
    screen_load();
    menu_refresh(m, false);
   } else {
    char dummy;
    get_com("Restore failed.  Press any key to continue.", &dummy);
    screen_load();
   }
  /*
		 * For birth options, only allow restore to the maintainer's
		 * defaults at birth.
		 */
  } else if ((event->key.code == 'x' || event->key.code == 'X') &&
    (page != OP_BIRTH || m->flags == MN_DBL_TAP)) {
   options_restore_maintainer(&player->opts, page);
   menu_refresh(m, false);
  } else {
   return false;
  }
 } else {
  return false;
 }
 if (next) {
  m->cursor++;
  m->cursor = (m->cursor + m->filter_count) % m->filter_count;
 }
 return true;
}
/**
 * Present a context menu for the birth or interface options so what's
 * accessible via the keyboard can also be done if only using a mouse.
 *
 * \param m is the structure describing the menu for the options.
 * \param in is the event triggering the context menu.  in->type must be
 * EVT_MOUSE.
 * \param out is the event to be passed upstream (to internal handling in
 * menu_select() or, potentially, menu_select()'s caller).
 * \return true if the event was handled; otherwise, return false.
 *
 * Logic here overlaps with what's done in option_toggle_handle().
 */
static bool use_option_context_menu(struct menu *m, const ui_event *in,
  ui_event *out)
{
 enum {
  ACT_CTX_OPT_SAVE,
  ACT_CTX_OPT_RESTORE,
  ACT_CTX_OPT_RESET
 };
 /*
	 * As a bit of a hack, get the type of options involved from the first
	 * option selected by the menu's filter.
	 */
 int page = option_type(m->filter_list[0]);
 char *labels = string_make(lower_case);
 struct menu *cm = menu_dynamic_new();
 bool refresh = false;
 char save_label[40];
 int selected;
 char dummy;
 cm->selections = labels;
 strnfmt(save_label, sizeof(save_label), "Save as default %s options",
  option_type_name(page));
 menu_dynamic_add_label(cm, save_label, 's', ACT_CTX_OPT_SAVE, labels);
 if (m->flags == MN_DBL_TAP) {
  menu_dynamic_add_label(cm, "Restore from saved defaults", 'r',
   ACT_CTX_OPT_RESTORE, labels);
  menu_dynamic_add_label(cm, "Reset to factory defaults", 'x',
   ACT_CTX_OPT_RESET, labels);
 }
 screen_save();
 assert(in->type == EVT_MOUSE);
 menu_dynamic_calc_location(cm, in->mouse.x, in->mouse.y);
 region_erase_bordered(&cm->boundary);
 selected = menu_dynamic_select(cm);
 menu_dynamic_free(cm);
 string_free(labels);
 switch (selected) {
 case ACT_CTX_OPT_SAVE:
  if (options_save_custom(&player->opts, page)) {
   get_com("Successfully saved.  Press any key to "
    "continue.", &dummy);
  } else {
   get_com("Save failed.  Press any key to continue.",
    &dummy);
  }
  break;
 case ACT_CTX_OPT_RESTORE:
  if (options_restore_custom(&player->opts, page)) {
   refresh = true;
  } else {
   get_com("Restore failed.  Press any key to continue.",
    &dummy);
  }
  break;
 case ACT_CTX_OPT_RESET:
  options_restore_maintainer(&player->opts, page);
  refresh = true;
  break;
 default:
  /* There's nothing to do. */
  break;
 }
 screen_load();
 if (refresh) {
  menu_refresh(m, false);
 }
 return true;
}
/**
 * Toggle option menu display and handling functions
 */
static const menu_iter option_toggle_iter = {
 NULL,
 NULL,
 option_toggle_display,
 option_toggle_handle,
 NULL
};
/**
 * Interact with some options
 */
static void option_toggle_menu(const char *name, int page)
{
 static const char selections[] = "abcdefgimopquvwzABCDEFGHIJKLMOPQUVWZ";
 int i;
 struct menu *m = menu_new(MN_SKIN_SCROLL, &option_toggle_iter);
 /* for all menus */
 m->prompt = "Set option (y/n/t), select with movement keys or index";
 m->cmd_keys = "YyNnTt";
 m->selections = selections;
 m->flags = MN_DBL_TAP;
 /* We add 10 onto the page amount to indicate we're at birth */
 if (page == OPT_PAGE_BIRTH) {
  m->prompt = "You can only modify these options at character birth.";
  m->cmd_keys = "";
  m->flags = MN_NO_TAGS;
 } else if (page == OPT_PAGE_BIRTH + 10 || page == OP_INTERFACE) {
  m->prompt = "Set option (y/n/t), 's' to save, 'r' to restore, 'x' to reset";
  m->cmd_keys = "YyNnTtSsRrXx";
  /* Provide a context menu for equivalents to 's', 'r', .... */
  m->context_hook = use_option_context_menu;
  if (page == OPT_PAGE_BIRTH + 10) {
   page -= 10;
  }
 }
 /* for this particular menu */
 m->title = name;
 /* Find the number of valid entries */
 for (i = 0; i < OPT_PAGE_PER; i++) {
  if (option_page[page][i] == OPT_none)
   break;
 }
 /* Set the data to the player's options */
 menu_setpriv(m, OPT_MAX, &player->opts.opt);
 menu_set_filter(m, option_page[page], i);
 menu_layout(m, &SCREEN_REGION);
 /* Run the menu */
 screen_save();
 clear_from(0);
 menu_select(m, 0, false);
 screen_load();
 mem_free(m);
}
/**
 * Edit birth options.
 */
void do_cmd_options_birth(void)
{
 option_toggle_menu("Birth options", OPT_PAGE_BIRTH + 10);
}
/**
 * Modify the "window" options
 */
static void do_cmd_options_win(const char *name, int row)
{
 int i, j, d;
 int y = 0;
 int x = 0;
 ui_event ke;
 uint32_t new_flags[ANGBAND_TERM_MAX];
 /* Set new flags to the old values */
 for (j = 0; j < ANGBAND_TERM_MAX; j++)
  new_flags[j] = window_flag[j];
 /* Clear screen */
 screen_save();
 clear_from(0);
 /* Interact */
 while (1) {
  /* Prompt */
  prt("Window flags (<dir> to move, 't'/Enter to toggle, or ESC)", 0, 0);
  /* Display the windows */
  for (j = 0; j < ANGBAND_TERM_MAX; j++) {
   uint8_t a = COLOUR_WHITE;
   const char *s = angband_term_name[j];
   /* Use color */
   if (j == x) a = COLOUR_L_BLUE;
   /* Window name, staggered, centered */
   Term_putstr(35 + j * 5 - strlen(s) / 2, 2 + j % 2, -1, a, s);
  }
  /* Display the options */
  for (i = 0; i < PW_MAX_FLAGS; i++) {
   uint8_t a = COLOUR_WHITE;
   const char *str = window_flag_desc[i];
   /* Use color */
   if (i == y) a = COLOUR_L_BLUE;
   /* Unused option */
   if (!str) str = "(Unused option)";
   /* Flag name */
   Term_putstr(0, i + 5, -1, a, str);
   /* Display the windows */
   for (j = 0; j < ANGBAND_TERM_MAX; j++) {
    wchar_t c = L'.';
    a = COLOUR_WHITE;
    /* Use color */
    if ((i == y) && (j == x)) a = COLOUR_L_BLUE;
    /* Active flag */
    if (new_flags[j] & ((uint32_t) 1 << i)) c = L'X';
    /* Flag value */
    Term_putch(35 + j * 5, i + 5, a, c);
   }
  }
  /* Place Cursor */
  Term_gotoxy(35 + x * 5, y + 5);
  /* Get key */
  ke = inkey_ex();
  /* Mouse or keyboard interaction */
  if (ke.type == EVT_MOUSE) {
   int choicey = ke.mouse.y - 5;
   int choicex = (ke.mouse.x - 35)/5;
   if (ke.mouse.button == 2)
    break;
   if ((choicey >= 0) && (choicey < PW_MAX_FLAGS)
    && (choicex > 0) && (choicex < ANGBAND_TERM_MAX)
    && !(ke.mouse.x % 5)) {
    if ((choicey == y) && (choicex == x)) {
     uint32_t flag = ((uint32_t) 1) << y;
     /* Toggle flag (off) */
     if (new_flags[x] & flag)
      new_flags[x] &= ~flag;
     /* Toggle flag (on) */
     else
      new_flags[x] |= flag;
    } else {
     y = choicey;
     x = (ke.mouse.x - 35)/5;
    }
   }
  } else if (ke.type == EVT_KBRD) {
   if (ke.key.code == ESCAPE || ke.key.code == 'q')
    break;
   /* Toggle */
   else if (ke.key.code == '5' || ke.key.code == 't' ||
     ke.key.code == KC_ENTER) {
    /* Hack -- ignore the main window */
    if (x == 0)
     bell();
    /* Toggle flag (off) */
    else if (new_flags[x] & (((uint32_t) 1) << y))
     new_flags[x] &= ~(((uint32_t) 1) << y);
    /* Toggle flag (on) */
    else
     new_flags[x] |= (((uint32_t) 1) << y);
    /* Continue */
    continue;
   }
   /* Extract direction */
   d = target_dir(ke.key);
   /* Move */
   if (d != 0) {
    x = (x + ddx[d] + 8) % ANGBAND_TERM_MAX;
    y = (y + ddy[d] + 16) % PW_MAX_FLAGS;
   }
  }
 }
 /* Notice changes */
 subwindows_set_flags(new_flags, ANGBAND_TERM_MAX);
 screen_load();
}
/**
 * ------------------------------------------------------------------------
 * Interact with keymaps
 * ------------------------------------------------------------------------ */
/**
 * Current (or recent) keymap action
 */
static struct keypress keymap_buffer[KEYMAP_ACTION_MAX + 1];
/**
 * Ask for, and display, a keymap trigger.
 *
 * Returns the trigger input.
 *
 * Note that both "event_signal(EVENT_INPUT_FLUSH)" calls are extremely
 * important.  This may
 * no longer be true, since "util.c" is much simpler now.  XXX XXX XXX
 */
static struct keypress keymap_get_trigger(void)
{
 char tmp[80];
 struct keypress buf[2] = { KEYPRESS_NULL, KEYPRESS_NULL };
 /* Flush */
 event_signal(EVENT_INPUT_FLUSH);
 /* Get a key */
 buf[0] = inkey();
 /* Convert to ascii */
 keypress_to_text(tmp, sizeof(tmp), buf, false);
 /* Hack -- display the trigger */
 Term_addstr(-1, COLOUR_WHITE, tmp);
 /* Flush */
 event_signal(EVENT_INPUT_FLUSH);
 /* Return trigger */
 return buf[0];
}
/**
 * Keymap menu action functions
 */
static void ui_keymap_pref_load(const char *title, int row)
{
 do_cmd_pref_file_hack(16);
}
static void ui_keymap_pref_append(const char *title, int row)
{
 dump_pref_file(keymap_dump, "Dump keymaps", 13);
}
static void ui_keymap_query(const char *title, int row)
{
 char tmp[1024];
 int mode = OPT(player, angband_keyset) ? KEYMAP_MODE_ANGBAND : KEYMAP_MODE_ORIG;
 struct keypress c;
 const struct keypress *act;
 if (OPT(player, hjkl_movement)) {
  mode |= KEYMAP_MODE_ROGUE;
 }
 prt(title, 13, 0);
 prt("Key: ", 14, 0);
 /* Get a keymap trigger & mapping */
 c = keymap_get_trigger();
 act = keymap_find(mode, c);
 /* Keymap found? */
 if (!act) {
  /* Prompt */
  prt("No keymap with that trigger.  Press any key to continue.", 16, 0);
  inkey();
 } else {
  /* Analyze the current action */
  keypress_to_text(tmp, sizeof(tmp), act, false);
  /* Display the current action */
  prt("Found: ", 15, 0);
  Term_addstr(-1, COLOUR_WHITE, tmp);
  prt("Press any key to continue.", 17, 0);
  inkey();
 }
}
static void ui_keymap_create(const char *title, int row)
{
 bool done = false;
 size_t n = 0;
 struct keypress c;
 char tmp[1024];
 int mode = OPT(player, angband_keyset) ? KEYMAP_MODE_ANGBAND : KEYMAP_MODE_ORIG;
 if (OPT(player, hjkl_movement)) {
  mode |= KEYMAP_MODE_ROGUE;
 }
 prt(title, 13, 0);
 prt("Key: ", 14, 0);
 c = keymap_get_trigger();
 if (c.code == '=') {
  c_prt(COLOUR_L_RED, "The '=' key is reserved.", 16, 2);
  prt("Press any key to continue.", 18, 0);
  inkey();
  return;
 }
 /* Get an encoded action, with a default response */
 while (!done) {
  struct keypress kp = {EVT_NONE, 0, 0};
  int color = COLOUR_WHITE;
  if (n == 0) color = COLOUR_YELLOW;
  if (n == KEYMAP_ACTION_MAX) color = COLOUR_L_RED;
  keypress_to_text(tmp, sizeof(tmp), keymap_buffer, false);
  c_prt(color, format("Action: %s", tmp), 15, 0);
  c_prt(COLOUR_L_BLUE, "  Press '=' when finished.", 17, 0);
  c_prt(COLOUR_L_BLUE, "  Use 'CTRL-u' to reset.", 18, 0);
  c_prt(COLOUR_L_BLUE, format("(Maximum keymap length is %d keys.)",
         KEYMAP_ACTION_MAX), 19, 0);
  kp = inkey();
  if (kp.code == '=') {
   done = true;
   continue;
  }
  switch (kp.code) {
   case KC_DELETE:
   case KC_BACKSPACE: {
    if (n > 0) {
     n -= 1;
        keymap_buffer[n].type = 0;
     keymap_buffer[n].code = 0;
     keymap_buffer[n].mods = 0;
    }
    break;
   }
   case KTRL('U'): {
    memset(keymap_buffer, 0, sizeof keymap_buffer);
    n = 0;
    break;
   }
   default: {
    if (n == KEYMAP_ACTION_MAX) continue;
    if (n == 0) {
     memset(keymap_buffer, 0, sizeof keymap_buffer);
    }
    keymap_buffer[n++] = kp;
    break;
   }
  }
 }
 if (c.code && get_check("Keep this keymap? ")) {
  keymap_add(mode, c, keymap_buffer, true);
  prt("To use in other sessions, save the keymaps to a file.  Press a key to continue.", 17, 0);
  inkey();
 }
}
static void ui_keymap_remove(const char *title, int row)
{
 struct keypress c;
 int mode = OPT(player, angband_keyset) ? KEYMAP_MODE_ANGBAND : KEYMAP_MODE_ORIG;
 if (OPT(player, hjkl_movement)) {
  mode |= KEYMAP_MODE_ROGUE;
 }
 prt(title, 13, 0);
 prt("Key: ", 14, 0);
 c = keymap_get_trigger();
 if (keymap_remove(mode, c))
  prt("Removed.", 16, 0);
 else
  prt("No keymap to remove!", 16, 0);
 /* Prompt */
 prt("Press any key to continue.", 17, 0);
 inkey();
}
static void keymap_browse_hook(int oid, void *db, const region *loc)
{
 char tmp[1024];
 event_signal(EVENT_MESSAGE_FLUSH);
 clear_from(13);
 /* Show current action */
 prt("Current action (if any) shown below:", 13, 0);
 keypress_to_text(tmp, sizeof(tmp), keymap_buffer, false);
 prt(tmp, 14, 0);
}
static struct menu *keymap_menu;
static menu_action keymap_actions[] =
{
 { 0, 0, "Load a user pref file", ui_keymap_pref_load },
 { 0, 0, "Save keymaps to file", ui_keymap_pref_append },
 { 0, 0, "Query a keymap", ui_keymap_query },
 { 0, 0, "Create a keymap", ui_keymap_create },
 { 0, 0, "Remove a keymap", ui_keymap_remove },
};
static void do_cmd_keymaps(const char *title, int row)
{
 region loc = {0, 0, 0, 12};
 screen_save();
 clear_from(0);
 if (!keymap_menu) {
  keymap_menu = menu_new_action(keymap_actions,
    N_ELEMENTS(keymap_actions));
  keymap_menu->title = title;
  keymap_menu->selections = lower_case;
  keymap_menu->browse_hook = keymap_browse_hook;
 }
 menu_layout(keymap_menu, &loc);
 menu_select(keymap_menu, 0, false);
 screen_load();
}
/**
 * ------------------------------------------------------------------------
 * Interact with visuals
 * ------------------------------------------------------------------------ */
static void visuals_pref_load(const char *title, int row)
{
 do_cmd_pref_file_hack(15);
}
static void visuals_dump_monsters(const char *title, int row)
{
 dump_pref_file(dump_monsters, title, 15);
}
static void visuals_dump_objects(const char *title, int row)
{
 dump_pref_file(dump_objects, title, 15);
}
static void visuals_dump_features(const char *title, int row)
{
 dump_pref_file(dump_features, title, 15);
}
static void visuals_dump_flavors(const char *title, int row)
{
 dump_pref_file(dump_flavors, title, 15);
}
static void visuals_reset(const char *title, int row)
{
 /* Reset */
 reset_visuals(true);
 /* Message */
 prt("", 0, 0);
 msg("Visual attr/char tables reset.");
 event_signal(EVENT_MESSAGE_FLUSH);
}
static struct menu *visual_menu;
static menu_action visual_menu_items [] =
{
 { 0, 0, "Load a user pref file", visuals_pref_load },
 { 0, 0, "Save monster attr/chars", visuals_dump_monsters },
 { 0, 0, "Save object attr/chars", visuals_dump_objects },
 { 0, 0, "Save feature attr/chars", visuals_dump_features },
 { 0, 0, "Save flavor attr/chars", visuals_dump_flavors },
 { 0, 0, "Reset visuals", visuals_reset },
};
static void visuals_browse_hook(int oid, void *db, const region *loc)
{
 event_signal(EVENT_MESSAGE_FLUSH);
 clear_from(1);
}
/**
 * Interact with "visuals"
 */
static void do_cmd_visuals(const char *title, int row)
{
 screen_save();
 clear_from(0);
 if (!visual_menu)
 {
  visual_menu = menu_new_action(visual_menu_items,
    N_ELEMENTS(visual_menu_items));
  visual_menu->title = title;
  visual_menu->selections = lower_case;
  visual_menu->browse_hook = visuals_browse_hook;
  visual_menu->header = "To edit visuals, use the knowledge menu";
 }
 menu_layout(visual_menu, &SCREEN_REGION);
 menu_select(visual_menu, 0, false);
 screen_load();
}
/**
 * ------------------------------------------------------------------------
 * Interact with colours
 * ------------------------------------------------------------------------ */
static void colors_pref_load(const char *title, int row)
{
 /* Ask for and load a user pref file */
 do_cmd_pref_file_hack(8);
 /* XXX should probably be a cleaner way to tell UI about
	 * colour changes - how about doing this in the pref file
	 * loading code too? */
 Term_xtra(TERM_XTRA_REACT, 0);
 Term_redraw_all();
}
static void colors_pref_dump(const char *title, int row)
{
 dump_pref_file(dump_colors, title, 15);
}
static void colors_modify(const char *title, int row)
{
 int i;
 static uint8_t a = 0;
 /* Prompt */
 prt("Command: Modify colors", 8, 0);
 /* Hack -- query until done */
 while (1) {
  const char *name;
  char index;
  struct keypress cx;
  /* Clear */
  clear_from(10);
  /* Exhibit the normal colors */
  for (i = 0; i < BASIC_COLORS; i++) {
   /* Exhibit this color */
   Term_putstr(i*3, 20, -1, a, "##");
   /* Exhibit character letter */
   Term_putstr(i*3, 21, -1, (uint8_t)i,
      format(" %c", color_table[i].index_char));
   /* Exhibit all colors */
   Term_putstr(i*3, 22, -1, (uint8_t)i, format("%2d", i));
  }
  /* Describe the color */
  name = ((a < BASIC_COLORS) ? color_table[a].name : "undefined");
  index = ((a < BASIC_COLORS) ? color_table[a].index_char : '?');
  /* Describe the color */
  Term_putstr(5, 10, -1, COLOUR_WHITE,
     format("Color = %d, Name = %s, Index = %c",
         a, name, index));
  /* Label the Current values */
  Term_putstr(5, 12, -1, COLOUR_WHITE,
    format("K = 0x%02x / R,G,B = 0x%02x,0x%02x,0x%02x",
       angband_color_table[a][0],
       angband_color_table[a][1],
       angband_color_table[a][2],
       angband_color_table[a][3]));
  /* Prompt */
  Term_putstr(0, 14, -1, COLOUR_WHITE,
    "Command (n/N/k/K/r/R/g/G/b/B): ");
  /* Get a command */
  cx = inkey();
  /* All done */
  if (cx.code == ESCAPE) break;
  /* Analyze */
  if (cx.code == 'n') {
   a = (uint8_t)(a + 1);
   if (a >= MAX_COLORS) {
    a = 0;
   }
  }
  if (cx.code == 'N') {
   a = (uint8_t)(a - 1);
   if (a >= MAX_COLORS) {
    a = MAX_COLORS - 1;
   }
  }
  if (cx.code == 'k')
   angband_color_table[a][0] =
    (uint8_t)(angband_color_table[a][0] + 1);
  if (cx.code == 'K')
   angband_color_table[a][0] =
    (uint8_t)(angband_color_table[a][0] - 1);
  if (cx.code == 'r')
   angband_color_table[a][1] =
    (uint8_t)(angband_color_table[a][1] + 1);
  if (cx.code == 'R')
   angband_color_table[a][1] =
    (uint8_t)(angband_color_table[a][1] - 1);
  if (cx.code == 'g')
   angband_color_table[a][2] =
    (uint8_t)(angband_color_table[a][2] + 1);
  if (cx.code == 'G')
   angband_color_table[a][2] =
    (uint8_t)(angband_color_table[a][2] - 1);
  if (cx.code == 'b')
   angband_color_table[a][3] =
    (uint8_t)(angband_color_table[a][3] + 1);
  if (cx.code == 'B')
   angband_color_table[a][3] =
    (uint8_t)(angband_color_table[a][3] - 1);
  /* Hack -- react to changes */
  Term_xtra(TERM_XTRA_REACT, 0);
  /* Hack -- redraw */
  Term_redraw();
 }
}
static void colors_browse_hook(int oid, void *db, const region *loc)
{
 event_signal(EVENT_MESSAGE_FLUSH);
 clear_from(1);
}
static struct menu *color_menu;
static menu_action color_events [] =
{
 { 0, 0, "Load a user pref file", colors_pref_load },
 { 0, 0, "Dump colors", colors_pref_dump },
 { 0, 0, "Modify colors", colors_modify }
};
/**
 * Interact with "colors"
 */
static void do_cmd_colors(const char *title, int row)
{
 screen_save();
 clear_from(0);
 if (!color_menu)
 {
  color_menu = menu_new_action(color_events,
   N_ELEMENTS(color_events));
  color_menu->title = title;
  color_menu->selections = lower_case;
  color_menu->browse_hook = colors_browse_hook;
 }
 menu_layout(color_menu, &SCREEN_REGION);
 menu_select(color_menu, 0, false);
 screen_load();
}
/**
 * ------------------------------------------------------------------------
 * Non-complex menu actions
 * ------------------------------------------------------------------------ */
static bool askfor_aux_numbers(char *buf, size_t buflen, size_t *curs, size_t *len, struct keypress keypress, bool firsttime)
{
 switch (keypress.code)
 {
  case ESCAPE:
  case KC_ENTER:
  case ARROW_LEFT:
  case ARROW_RIGHT:
  case KC_DELETE:
  case KC_BACKSPACE:
  case '0':
  case '1':
  case '2':
  case '3':
  case '4':
  case '5':
  case '6':
  case '7':
  case '8':
  case '9':
   return askfor_aux_keypress(buf, buflen, curs, len, keypress,
            firsttime);
 }
 return false;
}
/**
 * Set base delay factor
 */
static void do_cmd_delay(const char *name, int unused)
{
 char tmp[4] = "";
 int msec = player->opts.delay_factor;
 strnfmt(tmp, sizeof(tmp), "%i", player->opts.delay_factor);
 screen_save();
 /* Prompt */
 prt("", 19, 0);
 prt("Command: Base Delay Factor", 20, 0);
 prt("New base delay factor (0-255): ", 21, 0);
 prt(format("Current base delay factor: %d msec", msec), 22, 0);
 prt("", 23, 0);
 /* Ask for a numeric value */
 if (askfor_aux(tmp, sizeof(tmp), askfor_aux_numbers)) {
  uint16_t val = (uint16_t) strtoul(tmp, NULL, 0);
  player->opts.delay_factor = MIN(val, 255);
 }
 screen_load();
}
/**
 * Set sidebar mode
 */
static void do_cmd_sidebar_mode(const char *name, int unused)
{
 char tmp[20] = "";
 const char *names[SIDEBAR_MAX] = {"Left", "Top", "None"};
 struct keypress cx = KEYPRESS_NULL;
 screen_save();
 while (true) {
  // Get the name
  my_strcpy(tmp, names[SIDEBAR_MODE % SIDEBAR_MAX], sizeof(tmp));
  /* Prompt */
  prt("", 19, 0);
  prt("Command: Sidebar Mode", 20, 0);
  prt(format("Current mode: %s", tmp), 21, 0);
  prt("ESC: go back, other: cycle", 22, 0);
  prt("", 23, 0);
  /* Get a command */
  cx = inkey();
  /* All done */
  if (cx.code == ESCAPE) break;
  // Cycle
  SIDEBAR_MODE = (SIDEBAR_MODE + 1) % SIDEBAR_MAX;
 }
 screen_load();
}
/**
 * Set hitpoint warning level
 */
static void do_cmd_hp_warn(const char *name, int unused)
{
 bool res;
 char tmp[4] = "";
 uint8_t warn;
 strnfmt(tmp, sizeof(tmp), "%i", player->opts.hitpoint_warn);
 screen_save();
 /* Prompt */
 prt("", 19, 0);
 prt("Command: Hitpoint Warning", 20, 0);
 prt("New hitpoint warning (0-9): ", 21, 0);
 prt(format("Current hitpoint warning: %d (%d%%)",
  player->opts.hitpoint_warn, player->opts.hitpoint_warn * 10),
  22, 0);
 prt("", 23, 0);
 /* Ask the user for a string */
 res = askfor_aux(tmp, sizeof(tmp), askfor_aux_numbers);
 /* Process input */
 if (res) {
  warn = (uint8_t) strtoul(tmp, NULL, 0);
  /* Reset nonsensical warnings */
  if (warn > 9)
   warn = 0;
  player->opts.hitpoint_warn = warn;
 }
 screen_load();
}
/**
 * Set "lazy-movement" delay
 */
static void do_cmd_lazymove_delay(const char *name, int unused)
{
 bool res;
 char tmp[4] = "";
 strnfmt(tmp, sizeof(tmp), "%i", player->opts.lazymove_delay);
 screen_save();
 /* Prompt */
 prt("", 19, 0);
 prt("Command: Movement Delay Factor", 20, 0);
 prt("New movement delay: ", 21, 0);
 prt(format("Current movement delay: %d (%d msec)",
  player->opts.lazymove_delay, player->opts.lazymove_delay * 10),
  22, 0);
 prt("", 23, 0);
 /* Ask the user for a string */
 res = askfor_aux(tmp, sizeof(tmp), askfor_aux_numbers);
 /* Process input */
 if (res) {
  unsigned long delay = strtoul(tmp, NULL, 0);
  player->opts.lazymove_delay = (uint8_t) MIN(delay, 255);
 }
 screen_load();
}
/**
 * Ask for a "user pref file" and process it.
 *
 * This function should only be used by standard interaction commands,
 * in which a standard "Command:" prompt is present on the given row.
 *
 * Allow absolute file names?  XXX XXX XXX
 */
static void do_cmd_pref_file_hack(long row)
{
 char ftmp[80];
 bool ok;
 screen_save();
 /* Prompt */
 if (row > 0) {
  prt("", row - 1, 0);
 }
 prt("Command: Load a user pref file", row, 0);
 prt("", row + 1, 0);
 prt("File: ", row + 2, 0);
 prt("", row + 3, 0);
 /* Get the filesystem-safe name and append .prf */
 player_safe_name(ftmp, sizeof(ftmp), player->full_name, true);
 my_strcat(ftmp, ".prf", sizeof(ftmp));
 if(!arg_force_name)
  ok = askfor_aux(ftmp, sizeof ftmp, NULL);
 else
  ok = get_check(format("Confirm loading %s? ", ftmp));
 /* Ask for a file (or cancel) */
 if(ok) {
  /* Process the given filename */
  if (process_pref_file(ftmp, false, true) == false) {
   /* Mention failure */
   prt("", 0, 0);
   msg("Failed to load '%s'!", ftmp);
  } else {
   /* Mention success */
   prt("", 0, 0);
   msg("Loaded '%s'.", ftmp);
  }
 }
 screen_load();
}
/**
 * Write options to a file.
 */
static void do_dump_options(const char *title, int row) {
 dump_pref_file(option_dump, "Dump window settings", 20);
}
/**
 * Write autoinscriptions to a file.
 */
static void do_dump_autoinsc(const char *title, int row) {
 dump_pref_file(dump_autoinscriptions, "Dump autoinscriptions", 20);
}
/**
 * Load a pref file.
 */
static void options_load_pref_file(const char *n, int row)
{
 do_cmd_pref_file_hack(20);
}
/**
 * ------------------------------------------------------------------------
 * Ego item ignore menu
 * ------------------------------------------------------------------------ */
/**
 * Skip common prefixes in ego-item names.
 */
const char *strip_ego_name(const char *name)
{
 if (prefix(name, "of the "))
  return name + 7;
 if (prefix(name, "of "))
  return name + 3;
 return name;
}
/**
 * Display an ego-item type on the screen.
 */
int ego_item_name(char *buf, size_t buf_size, struct ego_desc *desc)
{
 size_t i;
 int end;
 size_t prefix_size;
 const char *long_name;
 struct ego_item *ego = &e_info[desc->e_idx];
 /* Find the ignore type */
 for (i = 0; i < N_ELEMENTS(quality_choices); i++)
  if (desc->itype == i) break;
 if (i == N_ELEMENTS(quality_choices)) return 0;
 /* Initialize the buffer */
 end = my_strcat(buf, "[ ] ", buf_size);
 /* Append the name */
 end += my_strcat(buf, quality_choices[i].name, buf_size);
 /* Append an extra space */
 end += my_strcat(buf, " ", buf_size);
 /* Get the full ego-item name */
 long_name = ego->name;
 /* Get the length of the common prefix, if any */
 prefix_size = (desc->short_name - long_name);
 /* Found a prefix? */
 if (prefix_size > 0) {
  char prefix[100];
  /* Get a copy of the prefix */
  my_strcpy(prefix, long_name, prefix_size + 1);
  /* Append the prefix */
  end += my_strcat(buf, prefix, buf_size);
 }
 /* Set the name to the right length */
 return end;
}
/**
 * Utility function used for sorting an array of ego-item indices by
 * ego-item name.
 */
static int ego_comp_func(const void *a_ptr, const void *b_ptr)
{
 const struct ego_desc *a = a_ptr;
 const struct ego_desc *b = b_ptr;
 /* Note the removal of common prefixes */
 return (strcmp(a->short_name, b->short_name));
}
/**
 * Display an entry on the sval menu
 */
static void ego_display(struct menu * menu, int oid, bool cursor, int row,
      int col, int width)
{
 char buf[80] = "";
 struct ego_desc *choice = (struct ego_desc *) menu->menu_data;
 bool ignored = ego_is_ignored(choice[oid].e_idx, choice[oid].itype);
 uint8_t attr = (cursor ? COLOUR_L_BLUE : COLOUR_WHITE);
 uint8_t sq_attr = (ignored ? COLOUR_L_RED : COLOUR_L_GREEN);
 /* Acquire the "name" of object "i" */
 (void) ego_item_name(buf, sizeof(buf), &choice[oid]);
 /* Print it */
 c_put_str(attr, format("%s", buf), row, col);
 /* Show ignore mark, if any */
 if (ignored)
  c_put_str(COLOUR_L_RED, "*", row, col + 1);
 /* Show the stripped ego-item name using another colour */
 c_put_str(sq_attr, choice[oid].short_name, row, col + strlen(buf));
}
/**
 * Deal with events on the sval menu
 */
static bool ego_action(struct menu * menu, const ui_event * event, int oid)
{
 struct ego_desc *choice = menu->menu_data;
 /* Toggle */
 if (event->type == EVT_SELECT) {
  ego_ignore_toggle(choice[oid].e_idx, choice[oid].itype);
  return true;
 }
 return false;
}
/**
 * Display list of ego items to be ignored.
 */
static void ego_menu(const char *unused, int also_unused)
{
 int max_num = 0;
 struct ego_item *ego;
 struct ego_desc *choice;
 struct menu menu;
 menu_iter menu_f = { 0, 0, ego_display, ego_action, 0 };
 region area = { 1, 5, -1, -1 };
 int cursor = 0;
 int i;
 /* Create the array */
 choice = mem_zalloc(z_info->e_max * ITYPE_MAX * sizeof(struct ego_desc));
 /* Get the valid ego-items */
 for (i = 0; i < z_info->e_max; i++) {
  int itype;
  ego = &e_info[i];
  /* Only valid known ego-items allowed */
  if (!ego->name || !ego->everseen)
   continue;
  /* Find appropriate ignore types */
  for (itype = ITYPE_NONE + 1; itype < ITYPE_MAX; itype++)
   if (ego_has_ignore_type(ego, itype)) {
    /* Fill in the details */
    choice[max_num].e_idx = i;
    choice[max_num].itype = itype;
    choice[max_num].short_name = strip_ego_name(ego->name);
    ++max_num;
   }
 }
 /* Quickly sort the array by ego-item name */
 qsort(choice, max_num, sizeof(choice[0]), ego_comp_func);
 /* Return here if there are no objects */
 if (!max_num) {
  mem_free(choice);
  return;
 }
 /* Save the screen and clear it */
 screen_save();
 clear_from(0);
 /* Help text */
 prt("Ego item ignore menu", 0, 0);
 /* Output to the screen */
 text_out_hook = text_out_to_screen;
 /* Indent output */
 text_out_indent = 1;
 text_out_wrap = 79;
 Term_gotoxy(1, 1);
 /* Display some helpful information */
 text_out_e("{light green}Movement keys{/} scroll the list\n{light red}ESC{/} returns to the previous menu\n{light blue}Enter{/} toggles the current setting.");
 text_out_indent = 0;
 /* Set up the menu */
 memset(&menu, 0, sizeof(menu));
 menu_init(&menu, MN_SKIN_SCROLL, &menu_f);
 menu_setpriv(&menu, max_num, choice);
 menu_layout(&menu, &area);
 /* Select an entry */
 (void) menu_select(&menu, cursor, false);
 /* Free memory */
 mem_free(choice);
 /* Load screen */
 screen_load();
 return;
}
/**
 * ------------------------------------------------------------------------
 * Quality ignore menu
 * ------------------------------------------------------------------------ */
/**
 * Menu struct for differentiating aware from unaware ignore
 */
typedef struct
{
 struct object_kind *kind;
 bool aware;
} ignore_choice;
/**
 * Ordering function for ignore choices.
 * Aware comes before unaware, and then sort alphabetically.
 */
static int cmp_ignore(const void *a, const void *b)
{
 char bufa[80];
 char bufb[80];
 const ignore_choice *x = a;
 const ignore_choice *y = b;
 if (!x->aware && y->aware)
  return 1;
 if (x->aware && !y->aware)
  return -1;
 object_kind_name(bufa, sizeof(bufa), x->kind, x->aware);
 object_kind_name(bufb, sizeof(bufb), y->kind, y->aware);
 return strcmp(bufa, bufb);
}
/**
 * Determine if an item is a valid choice
 */
static int quality_validity(struct menu *menu, int oid)
{
 return oid ? 1 : 0;
}
/**
 * Display an entry in the menu.
 */
static void quality_display(struct menu *menu, int oid, bool cursor, int row,
       int col, int width)
{
 if (oid) {
  /* Note: the order of the values in quality_choices do not
			align with the ignore_type_t enum order. - fix? NRM*/
  const char *name = quality_choices[oid].name;
  uint8_t level = ignore_level[oid];
  const char *level_name = quality_values[level].name;
  uint8_t attr = (cursor ? COLOUR_L_BLUE : COLOUR_WHITE);
  size_t u8len = utf8_strlen(name);
  if (u8len < 30) {
   c_put_str(attr, format("%s%*s", name, (int)(30 - u8len),
    " "), row, col);
  } else {
   char *name_copy = string_make(name);
   if (u8len > 30) {
    utf8_clipto(name_copy, 30);
   }
   c_put_str(attr, name_copy, row, col);
   string_free(name_copy);
  }
  c_put_str(attr, format(" : %s", level_name), row, col + 30);
 }
}
/**
 * Display the quality ignore subtypes.
 */
static void quality_subdisplay(struct menu *menu, int oid, bool cursor, int row,
          int col, int width)
{
 const char *name = quality_values[oid].name;
 uint8_t attr = (cursor ? COLOUR_L_BLUE : COLOUR_WHITE);
 c_put_str(attr, name, row, col);
}
/**
 * Handle keypresses.
 */
static bool quality_action(struct menu *m, const ui_event *event, int oid)
{
 struct menu menu;
 menu_iter menu_f = { NULL, NULL, quality_subdisplay, NULL, NULL };
 region area = { 37, 2, 29, IGNORE_MAX };
 ui_event evt;
 int count;
 /* Display at the right point */
 area.row += oid;
 /* Save */
 screen_save();
 /* Work out how many options we have */
 count = IGNORE_MAX;
 if ((oid == ITYPE_RING) || (oid == ITYPE_AMULET))
  count = area.page_rows = IGNORE_BAD + 1;
 /* Run menu */
 menu_init(&menu, MN_SKIN_SCROLL, &menu_f);
 menu_setpriv(&menu, count, quality_values);
 /* Stop menus from going off the bottom of the screen */
 if (area.row + menu.count > Term->hgt - 1)
  area.row += Term->hgt - 1 - area.row - menu.count;
 menu_layout(&menu, &area);
 window_make(area.col - 2, area.row - 1, area.col + area.width + 2,
    area.row + area.page_rows);
 evt = menu_select(&menu, 0, true);
 /* Set the new value appropriately */
 if (evt.type == EVT_SELECT)
  ignore_level[oid] = menu.cursor;
 /* Load and finish */
 screen_load();
 return true;
}
/**
 * Display quality ignore menu.
 */
static void quality_menu(const char *unused, int also_unused)
{
 struct menu menu;
 menu_iter menu_f = { NULL, quality_validity, quality_display,
       quality_action, NULL };
 region area = { 0, 0, 0, 0 };
 /* Save screen */
 screen_save();
 clear_from(0);
 /* Set up the menu */
 menu_init(&menu, MN_SKIN_SCROLL, &menu_f);
 menu.title = "Quality ignore menu";
 menu_setpriv(&menu, ITYPE_MAX, quality_values);
 menu_layout(&menu, &area);
 /* Select an entry */
 menu_select(&menu, 0, false);
 /* Load screen */
 screen_load();
 return;
}
/**
 * ------------------------------------------------------------------------
 * Sval ignore menu
 * ------------------------------------------------------------------------ */
/**
 * Structure to describe tval/description pairings.
 */
typedef struct
{
 int tval;
 const char *desc;
} tval_desc;
/**
 * Categories for sval-dependent ignore.
 */
static tval_desc sval_dependent[] =
{
 { TV_STAFF, "Staffs" },
 { TV_HORN, "Horns" },
 { TV_POTION, "Potions" },
 { TV_RING, "Rings" },
 { TV_AMULET, "Amulets" },
 { TV_FOOD, "Food" },
 { TV_HERB, "Herbs" },
 { TV_LIGHT, "Lights" },
 { TV_FLASK, "Flasks of oil" },
};
/**
 * Determines whether a tval is eligible for sval-ignore.
 */
bool ignore_tval(int tval)
{
 size_t i;
 /* Only ignore if the tval's allowed */
 for (i = 0; i < N_ELEMENTS(sval_dependent); i++) {
  if (kb_info[tval].num_svals == 0) continue;
  if (tval == sval_dependent[i].tval)
   return true;
 }
 return false;
}
/**
 * Display an entry on the sval menu
 */
static void ignore_sval_menu_display(struct menu *menu, int oid, bool cursor,
          int row, int col, int width)
{
 char buf[80];
 const ignore_choice *choice = menu_priv(menu);
 struct object_kind *kind = choice[oid].kind;
 bool aware = choice[oid].aware;
 uint8_t attr = curs_attrs[(int)aware][0 != cursor];
 /* Acquire the "name" of object "i" */
 object_kind_name(buf, sizeof(buf), kind, aware);
 /* Print it */
 c_put_str(attr, format("[ ] %s", buf), row, col);
 if ((aware && (kind->ignore & IGNORE_IF_AWARE)) ||
   (!aware && (kind->ignore & IGNORE_IF_UNAWARE)))
  c_put_str(COLOUR_L_RED, "*", row, col + 1);
}
/**
 * Deal with events on the sval menu
 */
static bool ignore_sval_menu_action(struct menu *m, const ui_event *event,
         int oid)
{
 const ignore_choice *choice = menu_priv(m);
 if (event->type == EVT_SELECT ||
   (event->type == EVT_KBRD && tolower(event->key.code) == 't')) {
  struct object_kind *kind = choice[oid].kind;
  /* Toggle the appropriate flag */
  if (choice[oid].aware)
   kind->ignore ^= IGNORE_IF_AWARE;
  else
   kind->ignore ^= IGNORE_IF_UNAWARE;
  player->upkeep->notice |= PN_IGNORE;
  return true;
 }
 return false;
}
static const menu_iter ignore_sval_menu =
{
 NULL,
 NULL,
 ignore_sval_menu_display,
 ignore_sval_menu_action,
 NULL,
};
/**
 * Collect all tvals in the big ignore_choice array
 */
static int ignore_collect_kind(int tval, ignore_choice **ch)
{
 ignore_choice *choice;
 int num = 0;
 int i;
 /* Create the array, with entries both for aware and unaware ignore */
 choice = mem_alloc(2 * z_info->k_max * sizeof *choice);
 for (i = 1; i < z_info->k_max; i++) {
  struct object_kind *kind = &k_info[i];
  /* Skip empty objects, unseen objects, and incorrect tvals */
  if (!kind->name || kind->tval != tval)
   continue;
  if (!kind->aware) {
   /* can unaware ignore anything */
   choice[num].kind = kind;
   choice[num++].aware = false;
  }
  if (kind->everseen && !kf_has(kind->kind_flags, KF_INSTA_ART)) {
   /* Do not display the artifact base kinds in this list 
			 * aware ignore requires everseen 
			 * do not require awareness for aware ignore, so people can set 
			 * at game start */
   choice[num].kind = kind;
   choice[num++].aware = true;
  }
 }
 if (num == 0)
  mem_free(choice);
 else
  *ch = choice;
 return num;
}
/**
 * Display list of svals to be ignored.
 */
static bool sval_menu(int tval, const char *desc)
{
 struct menu *menu;
 region area = { 1, 2, -1, -1 };
 ignore_choice *choices;
 int n_choices = ignore_collect_kind(tval, &choices);
 if (!n_choices)
  return false;
 /* Sort by name in ignore menus except for categories of items that are
	 * aware from the start */
 switch (tval)
 {
  case TV_LIGHT:
   /* leave sorted by sval */
   break;
  default:
   /* sort by name */
   sort(choices, n_choices, sizeof(*choices), cmp_ignore);
 }
 /* Save the screen and clear it */
 screen_save();
 clear_from(0);
 /* Help text */
 prt(format("Ignore the following %s:", desc), 0, 0);
 /* Run menu */
 menu = menu_new(MN_SKIN_COLUMNS, &ignore_sval_menu);
 menu_setpriv(menu, n_choices, choices);
 menu->cmd_keys = "Tt";
 menu_layout(menu, &area);
 menu_set_cursor_x_offset(menu, 1); /* Place cursor in brackets. */
 menu_select(menu, 0, false);
 /* Free memory */
 mem_free(menu);
 mem_free(choices);
 /* Load screen */
 screen_load();
 return true;
}
/**
 * Returns true if there's anything to display a menu of
 */
static bool seen_tval(int tval)
{
 int i;
 for (i = 1; i < z_info->k_max; i++) {
  struct object_kind *kind = &k_info[i];
  /* Skip empty objects, unseen objects, and incorrect tvals */
  if (!kind->name) continue;
  if (!kind->everseen) continue;
  if (kind->tval != tval) continue;
   return true;
 }
 return false;
}
/**
 * Extra options on the "item options" menu
 */
static struct
{
 char tag;
 const char *name;
 void (*action)(const char*, int);
} extra_item_options[] = {
 { 'Q', "Quality ignoring options", quality_menu },
 { 'E', "Ego ignoring options", ego_menu},
 { '{', "Autoinscription setup", textui_browse_object_knowledge },
};
static char tag_options_item(struct menu *menu, int oid)
{
 size_t line = (size_t) oid;
 if (line < N_ELEMENTS(sval_dependent))
  return all_letters_nohjkl[oid];
 /* Separator - blank line. */
 if (line == N_ELEMENTS(sval_dependent))
  return 0;
 line = line - N_ELEMENTS(sval_dependent) - 1;
 if (line < N_ELEMENTS(extra_item_options))
  return extra_item_options[line].tag;
 return 0;
}
static int valid_options_item(struct menu *menu, int oid)
{
 size_t line = (size_t) oid;
 if (line < N_ELEMENTS(sval_dependent))
  return 1;
 /* Separator - blank line. */
 if (line == N_ELEMENTS(sval_dependent))
  return 0;
 line = line - N_ELEMENTS(sval_dependent) - 1;
 if (line < N_ELEMENTS(extra_item_options))
  return 1;
 return 0;
}
static void display_options_item(struct menu *menu, int oid, bool cursor,
         int row, int col, int width)
{
 size_t line = (size_t) oid;
 /* Most of the menu is svals, with a small "extra options" section below */
 if (line < N_ELEMENTS(sval_dependent)) {
  bool known = seen_tval(sval_dependent[line].tval);
  uint8_t attr = curs_attrs[known ? CURS_KNOWN: CURS_UNKNOWN][(int)cursor];
  c_prt(attr, sval_dependent[line].desc, row, col);
 } else {
  uint8_t attr = curs_attrs[CURS_KNOWN][(int)cursor];
  line = line - N_ELEMENTS(sval_dependent) - 1;
  if (line < N_ELEMENTS(extra_item_options))
   c_prt(attr, extra_item_options[line].name, row, col);
 }
}
static bool handle_options_item(struct menu *menu, const ui_event *event,
        int oid)
{
 if (event->type == EVT_SELECT) {
  if ((size_t) oid < N_ELEMENTS(sval_dependent))
  {
   sval_menu(sval_dependent[oid].tval, sval_dependent[oid].desc);
  } else {
   oid = oid - (int)N_ELEMENTS(sval_dependent) - 1;
   assert((size_t) oid < N_ELEMENTS(extra_item_options));
   extra_item_options[oid].action(NULL, 0);
  }
  return true;
 }
 return false;
}
static const menu_iter options_item_iter =
{
 tag_options_item,
 valid_options_item,
 display_options_item,
 handle_options_item,
 NULL
};
/**
 * Display and handle the main ignoring menu.
 */
void do_cmd_options_item(const char *title, int row)
{
 struct menu menu;
 menu_init(&menu, MN_SKIN_SCROLL, &options_item_iter);
 menu_setpriv(&menu, N_ELEMENTS(sval_dependent) +
     N_ELEMENTS(extra_item_options) + 1, NULL);
 menu.title = title;
 menu_layout(&menu, &SCREEN_REGION);
 screen_save();
 clear_from(0);
 menu_select(&menu, 0, false);
 screen_load();
 player->upkeep->notice |= PN_IGNORE;
 return;
}
/**
 * ------------------------------------------------------------------------
 * Main menu definitions and display
 * ------------------------------------------------------------------------ */
static struct menu *option_menu;
static menu_action option_actions[] =
{
 { 0, 'a', "User interface options", option_toggle_menu },
 { 0, 'b', "Birth (difficulty) options", option_toggle_menu },
 { 0, 'x', "Cheat options", option_toggle_menu },
 { 0, 'w', "Subwindow setup", do_cmd_options_win },
 { 0, 'i', "Item ignoring setup", do_cmd_options_item },
 { 0, '{', "Auto-inscription setup", textui_browse_object_knowledge },
 { 0, 0, NULL, NULL },
 { 0, 'd', "Set base delay factor", do_cmd_delay },
 { 0, 'h', "Set hitpoint warning", do_cmd_hp_warn },
 { 0, 'm', "Set movement delay", do_cmd_lazymove_delay },
 { 0, 'o', "Set sidebar mode", do_cmd_sidebar_mode },
 { 0, 0, NULL, NULL },
 { 0, 's', "Save subwindow setup to pref file", do_dump_options },
 { 0, 't', "Save autoinscriptions to pref file", do_dump_autoinsc },
 { 0, 0, NULL, NULL },
 { 0, 'p', "Load a user pref file", options_load_pref_file },
 { 0, 'e', "Edit keymaps (advanced)", do_cmd_keymaps },
 { 0, 'c', "Edit colours (advanced)", do_cmd_colors },
 { 0, 'v', "Save visuals (advanced)", do_cmd_visuals },
};
/**
 * Display the options main menu.
 */
void do_cmd_options(void)
{
 if (!option_menu) {
  /* Main option menu */
  option_menu = menu_new_action(option_actions,
    N_ELEMENTS(option_actions));
  option_menu->title = "Options Menu";
  option_menu->flags = MN_CASELESS_TAGS;
 }
 screen_save();
 clear_from(0);
 menu_layout(option_menu, &SCREEN_REGION);
 menu_select(option_menu, 0, false);
 screen_load();
}
void cleanup_options(void)
{
 if (keymap_menu) menu_free(keymap_menu);
 if (visual_menu) menu_free(visual_menu);
 if (color_menu) menu_free(color_menu);
 if (option_menu) menu_free(option_menu);
}
/**
 * \file ui-output.c
 * \brief Putting text on the screen, screen saving and loading, panel handling
 *
 * Copyright (c) 2007 Pete Mack and others.
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * ------------------------------------------------------------------------
 * Regions
 * ------------------------------------------------------------------------ */
/**
 * These functions are used for manipulating regions on the screen, used 
 * mostly (but not exclusively) by the menu functions.
 */
region region_calculate(region loc)
{
 int w, h;
 Term_get_size(&w, &h);
 if (loc.col < 0)
  loc.col += w;
 if (loc.row < 0)
  loc.row += h;
 if (loc.width <= 0)
  loc.width += w - loc.col;
 if (loc.page_rows <= 0)
  loc.page_rows += h - loc.row;
 return loc;
}
void region_erase_bordered(const region *loc)
{
 region calc = region_calculate(*loc);
 int i = 0;
 calc.col = MAX(calc.col - 1, 0);
 calc.row = MAX(calc.row - 1, 0);
 calc.width += 2;
 calc.page_rows += 2;
 for (i = 0; i < calc.page_rows; i++)
  Term_erase(calc.col, calc.row + i, calc.width);
}
void region_erase(const region *loc)
{
 region calc = region_calculate(*loc);
 int i = 0;
 for (i = 0; i < calc.page_rows; i++)
  Term_erase(calc.col, calc.row + i, calc.width);
}
bool region_inside(const region *loc, const ui_event *key)
{
 if ((loc->col > key->mouse.x) || (loc->col + loc->width <= key->mouse.x))
  return false;
 if ((loc->row > key->mouse.y) ||
  (loc->row + loc->page_rows <= key->mouse.y))
  return false;
 return true;
}
/**
 * ------------------------------------------------------------------------
 * Text display
 * ------------------------------------------------------------------------ */
/**
 * These functions are designed to display large blocks of text on the screen
 * all at once.  They are the ui-term specific layer on top of the z-textblock.c
 * functions.
 */
/**
 * Utility function
 */
static void display_area(const wchar_t *text, const int *attrs,
  size_t *line_starts, size_t *line_lengths,
  size_t n_lines,
  region area, size_t line_from)
{
 size_t i, j;
 n_lines = MIN(n_lines, (size_t) area.page_rows);
 for (i = 0; i < n_lines; i++) {
  Term_erase(area.col, area.row + i, area.width);
  for (j = 0; j < line_lengths[line_from + i]; j++) {
   Term_putch(area.col + j, area.row + i,
     attrs[line_starts[line_from + i] + j],
     text[line_starts[line_from + i] + j]);
  }
 }
}
/**
 * Plonk a textblock on the screen in a certain bounding box.
 */
void textui_textblock_place(textblock *tb, region orig_area, const char *header)
{
 /* xxx on resize this should be recalculated */
 region area = region_calculate(orig_area);
 size_t *line_starts = NULL, *line_lengths = NULL;
 size_t n_lines;
 n_lines = textblock_calculate_lines(tb,
   &line_starts, &line_lengths, area.width);
 if (header != NULL) {
  area.page_rows--;
  Term_erase(area.col, area.row, area.width);
  c_put_str(COLOUR_L_BLUE, header, area.row, area.col);
  area.row++;
 }
 if (n_lines > (size_t) area.page_rows)
  n_lines = area.page_rows;
 display_area(textblock_text(tb), textblock_attrs(tb), line_starts,
              line_lengths, n_lines, area, 0);
 mem_free(line_starts);
 mem_free(line_lengths);
}
/**
 * Show a textblock interactively
 */
struct keypress textui_textblock_show(textblock *tb, region orig_area, const char *header)
{
 /* xxx on resize this should be recalculated */
 region area = region_calculate(orig_area);
 size_t *line_starts = NULL, *line_lengths = NULL;
 size_t n_lines;
 struct keypress ch = KEYPRESS_NULL;
 n_lines = textblock_calculate_lines(tb,
   &line_starts, &line_lengths, area.width);
 screen_save();
 /* make room for the footer */
 area.page_rows -= 2;
 if (header != NULL) {
  area.page_rows--;
  Term_erase(area.col, area.row, area.width);
  c_put_str(COLOUR_L_BLUE, header, area.row, area.col);
  area.row++;
 }
 if (n_lines > (size_t) area.page_rows) {
  int start_line = 0;
  Term_erase(area.col, area.row + area.page_rows, area.width);
  Term_erase(area.col, area.row + area.page_rows + 1, area.width);
  c_put_str(COLOUR_L_BLUE, "(Up/down or ESCAPE to exit.)",
    area.row + area.page_rows + 1, area.col);
  /* Pager mode */
  while (1) {
   display_area(textblock_text(tb), textblock_attrs(tb), line_starts,
     line_lengths, n_lines, area, start_line);
   ch = inkey();
   if (ch.code == ARROW_UP)
    start_line--;
   else if (ch.code == ESCAPE || ch.code == 'q' || ch.code == 'x')
    break;
   else if (ch.code == ']' || ch.code == '[')
    /* Special case to deal with monster and object lists -
				 * see bug #2120 */
    break;
   else if (ch.code == ARROW_DOWN)
    start_line++;
   else if (ch.code == ' ')
    start_line += area.page_rows;
   if (start_line < 0)
    start_line = 0;
   if (start_line + (size_t) area.page_rows > n_lines)
    start_line = n_lines - area.page_rows;
  }
 } else {
  display_area(textblock_text(tb), textblock_attrs(tb), line_starts,
    line_lengths, n_lines, area, 0);
  Term_erase(area.col, area.row + n_lines, area.width);
  Term_erase(area.col, area.row + n_lines + 1, area.width);
  c_put_str(COLOUR_L_BLUE, "(Press any key to continue.)",
    area.row + n_lines + 1, area.col);
  ch = inkey();
 }
 mem_free(line_starts);
 mem_free(line_lengths);
 screen_load();
 return (ch);
}
/**
 * ------------------------------------------------------------------------
 * text_out hook for screen display
 * ------------------------------------------------------------------------ */
/**
 * Print some (colored) text to the screen at the current cursor position,
 * automatically "wrapping" existing text (at spaces) when necessary to
 * avoid placing any text into the last column, and clearing every line
 * before placing any text in that line.  Also, allow "newline" to force
 * a "wrap" to the next line.  Advance the cursor as needed so sequential
 * calls to this function will work correctly.
 *
 * Once this function has been called, the cursor should not be moved
 * until all the related "text_out()" calls to the window are complete.
 *
 * This function will correctly handle any width up to the maximum legal
 * value of 256, though it works best for a standard 80 character width.
 */
void text_out_to_screen(int a, const char *str)
{
 int x, y;
 int wid, h;
 int wrap;
 const wchar_t *s;
 wchar_t buf[1024];
 /* Obtain the size */
 (void)Term_get_size(&wid, &h);
 /* Obtain the cursor */
 (void)Term_locate(&x, &y);
 /* Copy to a rewriteable string */
 text_mbstowcs(buf, str, 1024);
 /* Use special wrapping boundary? */
 if ((text_out_wrap > 0) && (text_out_wrap < wid))
  wrap = text_out_wrap;
 else
  wrap = wid;
 /* Process the string */
 for (s = buf; *s; s++) {
  wchar_t ch;
  /* Force wrap */
  if (*s == L'\n') {
   /* Wrap */
   x = text_out_indent;
   y++;
   /* Clear line, move cursor */
   Term_erase(x, y, 255);
   x += text_out_pad;
   Term_gotoxy(x, y);
   continue;
  }
  /* Clean up the char */
  ch = (text_iswprint(*s) ? *s : L' ');
  /* Wrap words as needed */
  if ((x >= wrap - 1) && (ch != L' ')) {
   int i, n = 0;
   int av[256];
   wchar_t cv[256];
   /* Wrap word */
   if (x < wrap) {
    /* Scan existing text */
    for (i = wrap - 2; i >= 0; i--) {
     /* Grab existing attr/char */
     Term_what(i, y, &av[i], &cv[i]);
     /* Break on space */
     if (cv[i] == L' ') break;
     /* Track current word */
     n = i;
    }
   }
   /* Special case */
   if (n == 0) n = wrap;
   /* Clear line */
   Term_erase(n, y, 255);
   /* Wrap */
   x = text_out_indent;
   y++;
   /* Clear line, move cursor */
   Term_erase(x, y, 255);
   x += text_out_pad;
   Term_gotoxy(x, y);
   /* Wrap the word (if any) */
   for (i = n; i < wrap - 1; i++) {
    /* Dump */
    Term_addch(av[i], cv[i]);
    /* Advance (no wrap) */
    if (++x > wrap) x = wrap;
   }
  }
  /* Dump */
  Term_addch(a, ch);
  /* Advance */
  if (++x > wrap) x = wrap;
 }
}
/**
 * ------------------------------------------------------------------------
 * Simple text display
 * ------------------------------------------------------------------------ */
/**
 * Display a string on the screen using an attribute.
 *
 * At the given location, using the given attribute, if allowed,
 * add the given string.  Do not clear the line.
 */
void c_put_str(uint8_t attr, const char *str, int row, int col) {
 /* Position cursor, Dump the attr/text */
 Term_putstr(col, row, -1, attr, str);
}
/**
 * As above, but in white
 */
void put_str(const char *str, int row, int col) {
 c_put_str(COLOUR_WHITE, str, row, col);
}
/**
 * Display a string on the screen using an attribute, and clear to the
 * end of the line.
 */
void c_prt(uint8_t attr, const char *str, int row, int col) {
 /* Clear line, position cursor */
 Term_erase(col, row, 255);
 /* Dump the attr/text */
 Term_addstr(-1, attr, str);
}
/**
 * As above, but in white
 */
void prt(const char *str, int row, int col) {
 c_prt(COLOUR_WHITE, str, row, col);
}
/**
 * ------------------------------------------------------------------------
 * Screen loading/saving
 * ------------------------------------------------------------------------ */
/**
 * Screen loading and saving can be done to an arbitrary depth but it's
 * important that every call to screen_save() is balanced by a call to
 * screen_load() or screen_load_all() later on.  'screen_save_depth' is used
 * by the game to keep track of whether it should try to update the map and
 * sidebar or not, so if you miss out a screen_load or screen_load_all you will
 * not get proper game updates.
 *
 * Term_save() / Term_load() / Term_load_all() do all the heavy lifting here.
 */
/**
 * Depth of the screen_save() stack
 */
int16_t screen_save_depth;
/**
 * Save the screen, and increase the "icky" depth.
 */
void screen_save(void)
{
 player->upkeep->redraw |= PR_MAP;
 redraw_stuff(player);
 event_signal(EVENT_MESSAGE_FLUSH);
 Term_save();
 screen_save_depth++;
}
/**
 * Load the screen, and decrease the "icky" depth.
 */
void screen_load(void)
{
 event_signal(EVENT_MESSAGE_FLUSH);
 Term_load();
 screen_save_depth--;
}
/**
 * Load the screen by replaying all the saves in reverse order with a redraw
 * for each and decrease the "icky" depth.
 */
void screen_load_all(void)
{
 event_signal(EVENT_MESSAGE_FLUSH);
 Term_load_all();
 screen_save_depth--;
}
bool textui_map_is_visible(void)
{
 /* Special case for post-death dungeon viewing */
 if (player->is_dead) return true;
 return (cave && screen_save_depth == 0);
}
/**
 * ------------------------------------------------------------------------
 * Miscellaneous things
 * ------------------------------------------------------------------------ */
/**
 * A Hengband-like 'window' function, that draws a surround box in ASCII art.
 */
void window_make(int origin_x, int origin_y, int end_x, int end_y)
{
 int n;
 region to_clear;
 to_clear.col = origin_x;
 to_clear.row = origin_y;
 to_clear.width = end_x - origin_x;
 to_clear.page_rows = end_y - origin_y;
 region_erase(&to_clear);
 Term_putch(origin_x, origin_y, COLOUR_WHITE, L'+');
 Term_putch(end_x, origin_y, COLOUR_WHITE, L'+');
 Term_putch(origin_x, end_y, COLOUR_WHITE, L'+');
 Term_putch(end_x, end_y, COLOUR_WHITE, L'+');
 for (n = 1; n < (end_x - origin_x); n++) {
  Term_putch(origin_x + n, origin_y, COLOUR_WHITE, L'-');
  Term_putch(origin_x + n, end_y, COLOUR_WHITE, L'-');
 }
 for (n = 1; n < (end_y - origin_y); n++) {
  Term_putch(origin_x, origin_y + n, COLOUR_WHITE, L'|');
  Term_putch(end_x, origin_y + n, COLOUR_WHITE, L'|');
 }
}
bool panel_should_modify(term *t, int wy, int wx)
{
 int dungeon_hgt = cave->height;
 int dungeon_wid = cave->width;
 int screen_hgt = (t == angband_term[0]) ?
  SCREEN_HGT : t->hgt / tile_height;
 int screen_wid = (t == angband_term[0]) ?
  SCREEN_WID : t->wid / tile_width;
 /* Verify wy, adjust if needed */
 if (wy > dungeon_hgt - screen_hgt) wy = dungeon_hgt - screen_hgt;
 if (wy < 0) wy = 0;
 /* Verify wx, adjust if needed */
 if (wx > dungeon_wid - screen_wid) wx = dungeon_wid - screen_wid;
 if (wx < 0) wx = 0;
 /* Needs changes? */
 return ((t->offset_y != wy) || (t->offset_x != wx));
}
/**
 * Modify the current panel to the given coordinates, adjusting only to
 * ensure the coordinates are legal, and return true if anything done.
 *
 * The town should never be scrolled around.
 *
 * Note that monsters are no longer affected in any way by panel changes.
 *
 * As a total hack, whenever the current panel changes, we assume that
 * the "overhead view" window should be updated.
 */
bool modify_panel(term *t, int wy, int wx)
{
 int dungeon_hgt = cave->height;
 int dungeon_wid = cave->width;
 int screen_hgt = (t == angband_term[0]) ?
  SCREEN_HGT : t->hgt / tile_height;
 int screen_wid = (t == angband_term[0]) ?
  SCREEN_WID : t->wid / tile_width;
 /* Verify wy, adjust if needed */
 if (wy > dungeon_hgt - screen_hgt) wy = dungeon_hgt - screen_hgt;
 if (wy < 0) wy = 0;
 /* Verify wx, adjust if needed */
 if (wx > dungeon_wid - screen_wid) wx = dungeon_wid - screen_wid;
 if (wx < 0) wx = 0;
 /* React to changes */
 if (panel_should_modify(t, wy, wx)) {
  /* Save wy, wx */
  t->offset_y = wy;
  t->offset_x = wx;
  /* Redraw map */
  player->upkeep->redraw |= (PR_MAP);
  /* Changed */
  return (true);
 }
 /* No change */
 return (false);
}
static void verify_panel_int(bool centered, bool avoid_center)
{
 int wy, wx;
 int screen_hgt, screen_wid;
 int panel_wid, panel_hgt;
 int py = player->grid.y;
 int px = player->grid.x;
 int j;
 /* Scan windows */
 for (j = 0; j < ANGBAND_TERM_MAX; j++) {
  term *t = angband_term[j];
  /* No window */
  if (!t) continue;
  /* No relevant flags */
  if ((j > 0) && !(window_flag[j] & (PW_OVERHEAD))) continue;
  wy = t->offset_y;
  wx = t->offset_x;
  screen_hgt = (j == 0) ? SCREEN_HGT : t->hgt / tile_height;
  screen_wid = (j == 0) ? SCREEN_WID : t->wid / tile_width;
  panel_wid = screen_wid / 2;
  panel_hgt = screen_hgt / 2;
  /* Scroll screen vertically when off-center */
  if (centered && (!player->upkeep->running || !avoid_center) &&
   (py != wy + panel_hgt))
   wy = py - panel_hgt;
  /* Scroll screen vertically when 3 grids from top/bottom edge */
  else if ((py < wy + 3) || (py >= wy + screen_hgt - 3))
   wy = py - panel_hgt;
  /* Scroll screen horizontally when off-center */
  if (centered && (!player->upkeep->running || !avoid_center) &&
   (px != wx + panel_wid))
   wx = px - panel_wid;
  /* Scroll screen horizontally when 3 grids from left/right edge */
  else if ((px < wx + 3) || (px >= wx + screen_wid - 3))
   wx = px - panel_wid;
  /* Scroll if needed */
  modify_panel(t, wy, wx);
 }
}
/**
 * Change the current panel to the panel lying in the given direction.
 *
 * Return true if the panel was changed.
 */
bool change_panel(int dir)
{
 bool changed = false;
 int j;
 /* Scan windows */
 for (j = 0; j < ANGBAND_TERM_MAX; j++) {
  int screen_hgt, screen_wid;
  int wx, wy;
  term *t = angband_term[j];
  /* No window */
  if (!t) continue;
  /* No relevant flags */
  if ((j > 0) && !(window_flag[j] & PW_OVERHEAD)) continue;
  screen_hgt = (j == 0) ? SCREEN_HGT : t->hgt / tile_height;
  screen_wid = (j == 0) ? SCREEN_WID : t->wid / tile_width;
  /* Shift by half a panel */
  wy = t->offset_y + ddy[dir] * screen_hgt / 2;
  wx = t->offset_x + ddx[dir] * screen_wid / 2;
  /* Use "modify_panel" */
  if (modify_panel(t, wy, wx)) changed = true;
 }
 return (changed);
}
/**
 * Verify the current panel (relative to the player location).
 *
 * By default, when the player gets "too close" to the edge of the current
 * panel, the map scrolls one panel in that direction so that the player
 * is no longer so close to the edge.
 *
 * The "OPT(player, center_player)" option allows the current panel to always be
 * centered around the player, which is very expensive, and also has some
 * interesting gameplay ramifications.
 */
void verify_panel(void)
{
 verify_panel_int(OPT(player, center_player), OPT(player, run_avoid_center));
}
void center_panel(void)
{
 verify_panel_int(true, OPT(player, run_avoid_center));
}
void textui_get_panel(int *min_y, int *min_x, int *max_y, int *max_x)
{
 term *t = term_screen;
 if (!t) return;
 *min_y = t->offset_y;
 *min_x = t->offset_x;
 *max_y = t->offset_y + SCREEN_HGT;
 *max_x = t->offset_x + SCREEN_WID;
}
bool textui_panel_contains(unsigned int y, unsigned int x)
{
 unsigned int hgt;
 unsigned int wid;
 if (!Term)
  return true;
 if (Term == term_screen) {
  hgt = SCREEN_HGT;
  wid = SCREEN_WID;
 } else {
  hgt = Term->hgt / tile_height;
  wid = Term->wid / tile_width;
 }
 return (y - Term->offset_y) < hgt && (x - Term->offset_x) < wid;
}
/**
 * \file ui-player.c
 * \brief character screens and dumps
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * ------------------------------------------------------------------------
 * Panel utilities
 * ------------------------------------------------------------------------ */
/**
 * Panel line type
 */
struct panel_line {
 uint8_t attr;
 const char *label;
 char value[20];
};
/**
 * Panel holder type
 */
struct panel {
 size_t len;
 size_t max;
 struct panel_line *lines;
};
/**
 * Allocate some panel lines
 */
static struct panel *panel_allocate(int n) {
 struct panel *p = mem_zalloc(sizeof *p);
 p->len = 0;
 p->max = n;
 p->lines = mem_zalloc(p->max * sizeof *p->lines);
 return p;
}
/**
 * Free up panel lines
 */
static void panel_free(struct panel *p) {
 assert(p);
 mem_free(p->lines);
 mem_free(p);
}
/**
 * Add a new line to the panel
 */
static void panel_line(struct panel *p, uint8_t attr, const char *label,
  const char *fmt, ...) {
 va_list vp;
 struct panel_line *pl;
 /* Get the next panel line */
 assert(p);
 assert(p->len != p->max);
 pl = &p->lines[p->len++];
 /* Set the basics */
 pl->attr = attr;
 pl->label = label;
 /* Set the value */
 va_start(vp, fmt);
 vstrnfmt(pl->value, sizeof pl->value, fmt, vp);
 va_end(vp);
}
/**
 * Add a spacer line in a panel
 */
static void panel_space(struct panel *p) {
 assert(p);
 assert(p->len != p->max);
 p->len++;
}
/**
 * Special display, part 2b
 */
void display_player_stat_info(void)
{
 int i, row = 2, col = 41;
 char buf[80];
 /* Display the stats */
 for (i = 0; i < STAT_MAX; i++) {
  /* Reduced or normal */
  if (player->stat_drain[i] < 0)
   /* Use lowercase stat name */
   put_str(stat_names_reduced[i], row + i, col);
  else
   /* Assume uppercase stat name */
   put_str(stat_names[i], row+i, col);
  /* Resulting "modified" maximum value */
  strnfmt(buf, sizeof(buf), "%2d", player->state.stat_use[i]);
  if (player->stat_drain[i] < 0)
   c_put_str(COLOUR_YELLOW, buf, row + i, col + 5);
  else
   c_put_str(COLOUR_L_GREEN, buf, row + i, col + 5);
  /* Only display stat_equip_mod if not zero */
  if (player->state.stat_equip_mod[i] != 0) {
   c_put_str(COLOUR_SLATE, "=", row + i, col + 8);
   /* Internal "natural" maximum value */
   strnfmt(buf, sizeof(buf), "%2d", player->stat_base[i]);
   c_put_str(COLOUR_GREEN, buf, row+i, col + 10);
   /* Equipment Bonus */
   strnfmt(buf, sizeof(buf), "%+3d", player->state.stat_equip_mod[i]);
   c_put_str(COLOUR_SLATE, buf, row + i, col + 13);
  }
  /* Only display stat_drain if not zero */
  if (player->stat_drain[i] != 0) {
   c_put_str(COLOUR_SLATE, "=", row + i, col + 8);
   /* Internal "natural" maximum value */
   strnfmt(buf, sizeof(buf), "%2d", player->stat_base[i]);
   c_put_str(COLOUR_GREEN, buf, row+i, col + 10);
   /* Reduction */
   strnfmt(buf, sizeof(buf), "%+3d", player->stat_drain[i]);
   c_put_str(COLOUR_SLATE, buf, row + i, col + 17);
  }
  /* Only display stat_misc_mod if not zero */
  if (player->state.stat_misc_mod[i] != 0) {
   c_put_str(COLOUR_SLATE, "=", row + i, col + 8);
   /* Internal "natural" maximum value */
   strnfmt(buf, sizeof(buf), "%2d", player->stat_base[i]);
   c_put_str(COLOUR_GREEN, buf, row+i, col + 10);
   /* Modifier */
   strnfmt(buf, sizeof(buf), "%+3d", player->state.stat_misc_mod[i]);
   c_put_str(COLOUR_SLATE, buf, row + i, col + 21);
  }
 }
}
/**
 * Skill breakdown
 */
void display_player_skill_info(void)
{
 int skill, row, col = 41;
 /* Display the skills */
 for (skill = 0; skill < SKILL_MAX; skill++) {
  int stat = player->state.skill_stat_mod[skill];
  int equip = player->state.skill_equip_mod[skill];
  int misc = player->state.skill_misc_mod[skill];
  row = 7 + skill;
  put_str(skill_names[skill], row, col);
  c_put_str(COLOUR_L_GREEN, format("%3d", player->state.skill_use[skill]),
      row, col + 11);
  c_put_str(COLOUR_SLATE, "=", row, col + 15);
  c_put_str(COLOUR_GREEN, format("%2d", player->skill_base[skill]), row,
      col+17);
  if (stat != 0)
   c_put_str(COLOUR_SLATE, format("%+3d", stat), row, col + 20);
  if (equip != 0)
   c_put_str(COLOUR_SLATE, format("%+3d", equip), row, col + 24);
  if (misc != 0)
   c_put_str(COLOUR_SLATE, format("%+3d", misc), row, col + 28);
 }
}
static void display_panel(const struct panel *p, bool left_adj,
  const region *bounds)
{
 size_t i;
 int col = bounds->col;
 int row = bounds->row;
 int w = bounds->width;
 int offset = 0;
 region_erase(bounds);
 if (left_adj) {
  for (i = 0; i < p->len; i++) {
   struct panel_line *pl = &p->lines[i];
   int len = pl->label ? strlen(pl->label) : 0;
   if (offset < len) offset = len;
  }
  offset += 2;
 }
 for (i = 0; i < p->len; i++, row++) {
  int len;
  struct panel_line *pl = &p->lines[i];
  if (!pl->label)
   continue;
  Term_putstr(col, row, strlen(pl->label), COLOUR_WHITE, pl->label);
  len = strlen(pl->value);
  len = len < w - offset ? len : w - offset - 1;
  if (left_adj)
   Term_putstr(col+offset, row, len, pl->attr, pl->value);
  else
   Term_putstr(col+w-len, row, len, pl->attr, pl->value);
 }
}
static uint8_t max_color(int val, int max)
{
 return val < max ? COLOUR_YELLOW : COLOUR_L_GREEN;
}
static struct panel *get_panel_topleft(void) {
 struct panel *p = panel_allocate(4);
 panel_line(p, COLOUR_L_BLUE, "Name", "%s", player->full_name);
 panel_line(p, COLOUR_L_BLUE, "Sex", "%s", player->sex->name);
 panel_line(p, COLOUR_L_BLUE, "Race", "%s", player->race->name);
 panel_line(p, COLOUR_L_BLUE, "House", "%s", player->house->short_name);
 return p;
}
static struct panel *get_panel_midleft(void) {
 struct panel *p = panel_allocate(8);
 panel_line(p, COLOUR_L_GREEN, "Game Turn", "%d", player->turn);
 panel_line(p, COLOUR_L_GREEN, "Exp Pool", "%d", player->new_exp);
 panel_line(p, COLOUR_L_GREEN, "Total Exp", "%d", player->exp);
 panel_line(p, max_color(weight_limit(player->state),
       player->upkeep->total_weight),
      "Burden", "%.1f", player->upkeep->total_weight / 10.0F);
 panel_line(p, COLOUR_L_GREEN, "Max Burden", "%.1f",
      weight_limit(player->state) / 10.0F);
 if (turn > 0) {
  panel_line(p, max_color(player->depth, player_min_depth(player)),
       "Depth", "%3d'", player->depth * 50);
  panel_line(p, COLOUR_L_GREEN, "Min Depth", "%3d'",
       player_min_depth(player) * 50);
 } else {
  panel_space(p);
  panel_space(p);
 }
 panel_line(p, COLOUR_L_GREEN, "Light Radius", "%3d",
      player->upkeep->cur_light);
 return p;
}
static struct panel *get_panel_combat(void) {
 struct panel *p = panel_allocate(9);
 int mel, arc;
 int add_lines = 3;
 /* Melee */
 mel = player->state.skill_use[SKILL_MELEE];
 panel_line(p, COLOUR_L_BLUE, "Melee", "(%+d,%dd%d)", mel, player->state.mdd,
      player->state.mds);
 if (player_active_ability(player, "Rapid Attack")) {
  add_lines--;
  panel_line(p, COLOUR_L_BLUE, "", "(%+d,%dd%d)", mel, player->state.mdd,
       player->state.mds);
 }
 if (player->state.mds2 > 0) {
  add_lines--;
  mel += player->state.offhand_mel_mod;
  panel_line(p, COLOUR_L_BLUE, "", "(%+d,%dd%d)", mel, player->state.mdd2,
       player->state.mds2);
 }
 /* Ranged */
 arc = player->state.skill_use[SKILL_ARCHERY];
 panel_line(p, COLOUR_L_BLUE, "Bows", "(%+d,%dd%d)", arc, player->state.add,
      player->state.ads);
 if (player_active_ability(player, "Rapid Fire")) {
  add_lines--;
  panel_line(p, COLOUR_L_BLUE, "", "(%+d,%dd%d)", arc, player->state.add,
      player->state.ads);
 }
 /* Armor */
 panel_line(p, COLOUR_L_BLUE, "Armor", "[%+d,%d-%d]",
      player->state.skill_use[SKILL_EVASION],
      protection_roll(player, PROJ_HURT, true, MINIMISE),
      protection_roll(player, PROJ_HURT, true, MAXIMISE));
 if (add_lines) {
  panel_space(p);
  add_lines--;
 }
 /* Health */
 panel_line(p, COLOUR_L_BLUE, "Health", "%d:%d", player->chp, player->mhp);
 /* Voice */
 panel_line(p, COLOUR_L_BLUE, "Voice", "%d:%d", player->csp, player->msp);
 /* Song */
 if (player->song[SONG_MAIN]) {
  panel_line(p, COLOUR_L_BLUE, "Song", "%s",
       player->song[SONG_MAIN]->name);
  if (player->song[SONG_MINOR]) {
   panel_line(p, COLOUR_L_BLUE, "", "%s",
        player->song[SONG_MINOR]->name);
  }
 }
 /* Note potential trouble if two songs and two or three extra lines - NRM */
 return p;
}
static struct panel *get_panel_misc(void) {
 struct panel *p = panel_allocate(3);
 uint8_t attr = COLOUR_L_BLUE;
 panel_line(p, attr, "Age", "%d", player->age);
 panel_line(p, attr, "Height", "%d'%d\"", player->ht / 12, player->ht % 12);
 panel_line(p, attr, "Weight", "%d", player->wt);
 return p;
}
/**
 * Panels for main character screen
 */
static const struct {
 region bounds;
 bool align_left;
 struct panel *(*panel)(void);
} panels[] = {
 /*   x  y wid rows */
 { { 1, 1, 18, 4 }, true, get_panel_topleft }, /* Name, Class, ... */
 { { 22, 1, 12, 3 }, false, get_panel_misc }, /* Age, ht, wt, ... */
 { { 1, 6, 18, 9 }, false, get_panel_midleft }, /* Cur Exp, Max Exp, ... */
 { { 22, 6, 16, 9 }, false, get_panel_combat },
};
void display_player_xtra_info(void)
{
 size_t i;
 for (i = 0; i < N_ELEMENTS(panels); i++) {
  struct panel *p = panels[i].panel();
  display_panel(p, panels[i].align_left, &panels[i].bounds);
  panel_free(p);
 }
 /* Indent output by 1 character, and wrap at column 72 */
 text_out_wrap = 72;
 text_out_indent = 1;
 /* History */
 Term_gotoxy(text_out_indent, 19);
 text_out_to_screen(COLOUR_WHITE, player->history);
 /* Reset text_out() vars */
 text_out_wrap = 0;
 text_out_indent = 0;
 return;
}
/**
 * Display the character on the screen (two different modes)
 *
 * The top two lines, and the bottom line (or two) are left blank.
 *
 * Mode 0 = standard display with skills/history
 * Mode 1 = special display with equipment flags
 */
void display_player(int mode)
{
 /* Erase screen */
 clear_from(0);
 /* When not playing, do not display in subwindows */
 if (Term != angband_term[0] && !player->upkeep->playing) return;
 /* Stat info */
 display_player_stat_info();
 if (mode) {
  struct panel *p = panels[0].panel();
  display_panel(p, panels[0].align_left, &panels[0].bounds);
  panel_free(p);
 } else {
  /* Extra info */
  display_player_xtra_info();
  /* Skill info */
  display_player_skill_info();
 }
}
/**
 * Write a character dump
 */
void write_character_dump(ang_file *fff)
{
 int i, x, y;
 int a;
 wchar_t c;
 char o_name[80];
 int n;
 char buf[1024];
 char *p;
 /* Begin dump */
 file_putf(fff, "  [%s Character Dump]\n\n", buildid);
 /* Display player basics */
 display_player(0);
 /* Dump part of the screen */
 for (y = 1; y < 23; y++) {
  p = buf;
  /* Dump each row */
  for (x = 0; x < 79; x++) {
   /* Get the attr/char */
   (void)(Term_what(x, y, &a, &c));
   /* Dump it */
   n = text_wctomb(p, c);
   if (n > 0) {
    p += n;
   } else {
    *p++ = ' ';
   }
  }
  /* Back up over spaces */
  while ((p > buf) && (p[-1] == ' ')) --p;
  /* Terminate */
  *p = '\0';
  /* End the row */
  file_putf(fff, "%s\n", buf);
 }
 /* Skip some lines */
 file_putf(fff, "\n\n");
 /* If dead, dump last messages -- Prfnoff */
 if (player->is_dead) {
  i = messages_num();
  if (i > 15) i = 15;
  file_putf(fff, "  [Last Messages]\n\n");
  while (i-- > 0)
  {
   file_putf(fff, "> %s\n", message_str((int16_t)i));
  }
  if (streq(player->died_from, "Retiring")) {
   file_putf(fff, "\nRetired.\n\n");
  } else {
   file_putf(fff, "\nKilled by %s.\n\n",
    player->died_from);
  }
  file_putf(fff, "\n  [Screenshot]\n\n");
  file_mini_screenshot(fff);
  file_putf(fff, "\n");
 }
 /* Dump the equipment */
 file_putf(fff, "  [Character Equipment]\n\n");
 for (i = 0; i < player->body.count; i++) {
  struct object *obj = slot_object(player, i);
  if (!obj) continue;
  object_desc(o_name, sizeof(o_name), obj,
   ODESC_PREFIX | ODESC_FULL, player);
  file_putf(fff, "%c) %s\n", gear_to_label(player, obj), o_name);
  object_info_chardump(fff, obj, 5, 72);
 }
 file_putf(fff, "\n\n");
 /* Dump the inventory */
 file_putf(fff, "\n\n  [Character Inventory]\n\n");
 for (i = 0; i < z_info->pack_size; i++) {
  struct object *obj = player->upkeep->inven[i];
  if (!obj) break;
  object_desc(o_name, sizeof(o_name), obj,
   ODESC_PREFIX | ODESC_FULL, player);
  file_putf(fff, "%c) %s\n", gear_to_label(player, obj), o_name);
  object_info_chardump(fff, obj, 5, 72);
 }
 file_putf(fff, "\n\n");
 /* Dump character history */
 dump_history(fff);
 file_putf(fff, "\n\n");
 /* Dump options */
 file_putf(fff, "  [Options]\n\n");
 /* Dump options */
 for (i = 0; i < OP_MAX; i++) {
  int opt;
  const char *title = "";
  switch (i) {
   case OP_INTERFACE: title = "User interface"; break;
   case OP_BIRTH: title = "Birth"; break;
      default: continue;
  }
  file_putf(fff, "  [%s]\n\n", title);
  for (opt = 0; opt < OPT_MAX; opt++) {
   const char *desc;
   size_t u8len;
   if (option_type(opt) != i) continue;
   desc = option_desc(opt);
   u8len = utf8_strlen(desc);
   if (u8len < 45) {
    file_putf(fff, "%s%*s", desc,
     (int)(45 - u8len), " ");
   } else {
    file_putf(fff, "%s", desc);
   }
   file_putf(fff, ": %s (%s)\n",
           player->opts.opt[opt] ? "yes" : "no ",
           option_name(opt));
  }
  /* Skip some lines */
  file_putf(fff, "\n");
 }
 /*
	 * Display the randart seed, if applicable.  Use the same format as is
	 * used when constructing the randart file name.
	 */
 if (player->self_made_arts) {
  file_putf(fff, "  [Artefact label]\n\n");
  file_putf(fff, "%08lx\n\n", (unsigned long)seed_randart);
 }
}
/**
 * Save the lore to a file in the user directory.
 *
 * \param path is the path to the filename
 *
 * \returns true on success, false otherwise.
 */
bool dump_save(const char *path)
{
 if (text_lines_to_file(path, write_character_dump)) {
  msg("Failed to create file %s.new", path);
  return false;
 }
 return true;
}
/**
 * Hack -- change name
 */
void do_cmd_change_name(void)
{
 ui_event ke;
 int mode = 0;
 bool more = true;
 /* Save screen */
 screen_save();
 /* Forever */
 while (more) {
  /* Display the player */
  display_player(mode);
  /* Prompt */
  Term_putstr(1, 23, -1, COLOUR_SLATE, "history   change name   save to a file   abilities   increase skills   ESC");
  Term_putstr(1, 23, -1, COLOUR_L_WHITE, "h");
  Term_putstr(11, 23, -1, COLOUR_L_WHITE, "c");
  Term_putstr(25, 23, -1, COLOUR_L_WHITE, "s");
  Term_putstr(42, 23, -1, COLOUR_L_WHITE, "a");
  Term_putstr(54, 23, -1, COLOUR_L_WHITE, "i");
  Term_putstr(72, 23, -1, COLOUR_L_WHITE, "ESC");
  /* Query */
  ke = inkey_ex();
  if ((ke.type == EVT_KBRD)||(ke.type == EVT_BUTTON)) {
   switch (ke.key.code) {
    case ESCAPE: more = false; break;
    case 'h': {
     history_display();
     break;
    }
    case 'c': {
     if(arg_force_name)
      msg("You are not allowed to change your name!");
     else {
     char namebuf[32] = "";
     /* Set player name */
     if (get_character_name(namebuf, sizeof namebuf))
      my_strcpy(player->full_name, namebuf,
          sizeof(player->full_name));
     }
     break;
    }
    case 's': {
     char buf[1024];
     char fname[80];
     /* Get the filesystem-safe name and append .txt */
     player_safe_name(fname, sizeof(fname), player->full_name, false);
     my_strcat(fname, ".txt", sizeof(fname));
     if (get_file(fname, buf, sizeof buf)) {
      if (dump_save(buf))
       msg("Character dump successful.");
      else
       msg("Character dump failed!");
     }
     break;
    }
    case 'a': {
     do_cmd_abilities();
     /*
					 * In case an ability was added, update
					 * the player's state.
					 */
     update_stuff(player);
     break;
    }
    case 'i': {
     (void) gain_skills(CTX_GAME, true);
     break;
    }
   }
  } else if (ke.type == EVT_MOUSE) {
   if (ke.mouse.button == 1) {
    /* Flip through the screens */
    mode = (mode + 1) % 2;
   } else if (ke.mouse.button == 2) {
    /* exit the screen */
    more = false;
   } else {
    /* Flip backwards through the screens */
    mode = (mode - 1) % 2;
   }
  }
  /* Flush messages */
  event_signal(EVENT_MESSAGE_FLUSH);
 }
 /* Load screen */
 screen_load();
}
/**
 * \file ui-prefs.c
 * \brief Pref file handling code
 *
 * Copyright (c) 2003 Takeshi Mogami, Robert Ruehlmann
 * Copyright (c) 2007 Pete Mack
 * Copyright (c) 2010 Andi Sidwell
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
char arg_name[PLAYER_NAME_LEN]; /* Command arg -- request character name */
int arg_graphics; /* Command arg -- Request graphics mode */
bool arg_graphics_nice; /* Command arg -- Request nice graphics mode */
int use_graphics; /* The "graphics" mode is enabled */
uint8_t *monster_x_attr;
wchar_t *monster_x_char;
uint8_t *kind_x_attr;
wchar_t *kind_x_char;
uint8_t *feat_x_attr[LIGHTING_MAX];
wchar_t *feat_x_char[LIGHTING_MAX];
uint8_t *trap_x_attr[LIGHTING_MAX];
wchar_t *trap_x_char[LIGHTING_MAX];
uint8_t *flavor_x_attr;
wchar_t *flavor_x_char;
uint8_t alert_x_attr = 0;
wchar_t alert_x_char = 0;
uint8_t glow_x_attr = 0;
wchar_t glow_x_char = 0;
uint8_t damage_x_attr[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
wchar_t damage_x_char[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
static size_t flavor_max = 0;
/**
 * ------------------------------------------------------------------------
 * Pref file saving code
 * ------------------------------------------------------------------------ */
/**
 * Header and footer marker string for pref file dumps
 */
static const char *dump_separator = "#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#";
/**
 * Remove old lines from pref files
 *
 * If you are using setgid, make sure privileges were raised prior
 * to calling this.
 */
static void remove_old_dump(const char *cur_fname, const char *mark)
{
 bool between_marks = false;
 bool changed = false;
 bool skip_one = false;
 char buf[1024];
 char start_line[1024];
 char end_line[1024];
 char new_fname[1024];
 ang_file *new_file;
 ang_file *cur_file;
 /* Format up some filenames */
 strnfmt(new_fname, sizeof(new_fname), "%s.new", cur_fname);
 /* Work out what we expect to find */
 strnfmt(start_line, sizeof(start_line), "%s begin %s",
   dump_separator, mark);
 strnfmt(end_line, sizeof(end_line), "%s end %s",
   dump_separator, mark);
 /* Open current file */
 cur_file = file_open(cur_fname, MODE_READ, FTYPE_TEXT);
 if (!cur_file) return;
 /* Open new file */
 new_file = file_open(new_fname, MODE_WRITE, FTYPE_TEXT);
 if (!new_file) {
  file_close(cur_file);
  msg("Failed to create file %s", new_fname);
  return;
 }
 /* Loop for every line */
 while (file_getl(cur_file, buf, sizeof(buf))) {
  /* Turn on at the start line, turn off at the finish line */
  if (streq(buf, start_line))
   between_marks = true;
  else if (streq(buf, end_line)) {
   between_marks = false;
   skip_one = true;
   changed = true;
  }
  if (!between_marks && !skip_one)
   file_putf(new_file, "%s\n", buf);
  skip_one = false;
 }
 /* Close files */
 file_close(cur_file);
 file_close(new_file);
 /* If there are changes use the new file. otherwise just destroy it */
 if (changed) {
  char old_fname[1024];
  strnfmt(old_fname, sizeof(old_fname), "%s.old", cur_fname);
  if (file_move(cur_fname, old_fname)) {
   file_move(new_fname, cur_fname);
   file_delete(old_fname);
  }
 } else {
  file_delete(new_fname);
 }
}
/**
 * Output the header of a pref-file dump
 */
static void pref_header(ang_file *fff, const char *mark)
{
 /* Start of dump */
 file_putf(fff, "%s begin %s\n", dump_separator, mark);
 file_putf(fff, "# *Warning!*  The lines below are an automatic dump.\n");
 file_putf(fff, "# Don't edit them; changes will be deleted and replaced automatically.\n");
}
/**
 * Output the footer of a pref-file dump
 */
static void pref_footer(ang_file *fff, const char *mark)
{
 file_putf(fff, "# *Warning!*  The lines above are an automatic dump.\n");
 file_putf(fff, "# Don't edit them; changes will be deleted and replaced automatically.\n");
 /* End of dump */
 file_putf(fff, "%s end %s\n", dump_separator, mark);
}
/**
 * Dump monsters
 */
void dump_monsters(ang_file *fff)
{
 int i;
 for (i = 0; i < z_info->r_max; i++) {
  struct monster_race *race = &r_info[i];
  uint8_t attr = monster_x_attr[i];
  wint_t chr = monster_x_char[i];
  /* Skip non-entries */
  if (!race->name) continue;
  file_putf(fff, "monster:%s:0x%02X:0x%02X\n", race->name, attr, chr);
 }
}
/**
 * Dump objects
 */
void dump_objects(ang_file *fff)
{
 int i;
 file_putf(fff, "# Objects\n");
 for (i = 0; i < z_info->k_max; i++) {
  struct object_kind *kind = &k_info[i];
  char name[120] = "";
  if (!kind->name || !kind->tval) continue;
  object_short_name(name, sizeof name, kind->name);
  file_putf(fff, "object:%s:%s:%d:%d\n", tval_find_name(kind->tval),
    name, kind_x_attr[i], kind_x_char[i]);
 }
}
/**
 * Dump autoinscriptions
 */
void dump_autoinscriptions(ang_file *f) {
 int i;
 for (i = 0; i < z_info->k_max; i++) {
  struct object_kind *k = &k_info[i];
  char name[120];
  const char *note;
  if (!k->name || !k->tval) continue;
  /* Only aware autoinscriptions go to the prefs file */
  note = get_autoinscription(k, true);
  if (note) {
   object_short_name(name, sizeof name, k->name);
   file_putf(f, "inscribe:%s:%s:%s\n", tval_find_name(k->tval), name, note);
  }
 }
}
/**
 * Dump features
 */
void dump_features(ang_file *fff)
{
 int i;
 for (i = 0; i < FEAT_MAX; i++) {
  struct feature *feat = &f_info[i];
  size_t j;
  /* Skip non-entries */
  if (!feat->name) continue;
  /* Skip mimic entries  */
  if (feat->mimic) continue;
  file_putf(fff, "# Terrain: %s\n", feat->name);
  for (j = 0; j < LIGHTING_MAX; j++) {
   uint8_t attr = feat_x_attr[j][i];
   wint_t chr = feat_x_char[j][i];
   const char *light = NULL;
   if (j == LIGHTING_TORCH)
    light = "torch";
   if (j == LIGHTING_LOS)
    light = "los";
   else if (j == LIGHTING_LIT)
    light = "lit";
   else if (j == LIGHTING_DARK)
    light = "dark";
   assert(light);
   file_putf(fff, "feat:%s:%s:%d:%d\n",
    get_feat_code_name(i), light, attr, chr);
  }
 }
}
/**
 * Dump flavors
 */
void dump_flavors(ang_file *fff)
{
 struct flavor *f;
 for (f = flavors; f; f = f->next) {
  uint8_t attr = flavor_x_attr[f->fidx];
  wint_t chr = flavor_x_char[f->fidx];
  file_putf(fff, "# Item flavor: %s\n", f->text);
  file_putf(fff, "flavor:%d:%d:%d\n\n", f->fidx, attr, chr);
 }
}
/**
 * Dump colors
 */
void dump_colors(ang_file *fff)
{
 int i;
 for (i = 0; i < MAX_COLORS; i++) {
  int kv = angband_color_table[i][0];
  int rv = angband_color_table[i][1];
  int gv = angband_color_table[i][2];
  int bv = angband_color_table[i][3];
  const char *name = "unknown";
  /* Skip non-entries, except those in the basic colors */
  if (!kv && !rv && !gv && !bv && i >= BASIC_COLORS) continue;
  /* Extract the color name */
  if (i < BASIC_COLORS) name = color_table[i].name;
  file_putf(fff, "# Color: %s\n", name);
  file_putf(fff, "color:%d:%d:%d:%d:%d\n\n", i, kv, rv, gv, bv);
 }
}
/**
 * Write all current options to a user preference file.
 */
void option_dump(ang_file *fff)
{
 int i, j;
 file_putf(fff, "# Options\n\n");
 /* Dump window flags */
 for (i = 1; i < ANGBAND_TERM_MAX; i++) {
  /* Require a real window */
  if (!angband_term[i]) continue;
  /* Check each flag */
  for (j = 0; j < (int)N_ELEMENTS(window_flag_desc); j++) {
   /* Require a real flag */
   if (!window_flag_desc[j]) continue;
   /* Only dump the flag if true */
   if (window_flag[i] & (((uint32_t) 1) << j)) {
    file_putf(fff, "# Window '%s', Flag '%s'\n",
        angband_term_name[i], window_flag_desc[j]);
    file_putf(fff, "window:%d:%d:1\n", i, j);
    /* Skip a line */
    file_putf(fff, "\n");
   }
  }
 }
}
/**
 * Save a set of preferences to file, overwriting any old preferences with the
 * same title.
 *
 * \param path is the filename to dump to
 * \param dump is a pointer to the function that does the writing to file
 * \param title is the name of this set of preferences
 *
 * \returns true on success, false otherwise.
 */
bool prefs_save(const char *path, void (*dump)(ang_file *), const char *title)
{
 ang_file *fff;
 /* Remove old keymaps */
 remove_old_dump(path, title);
 fff = file_open(path, MODE_APPEND, FTYPE_TEXT);
 if (!fff) {
  return false;
 }
 /* Append the header */
 pref_header(fff, title);
 file_putf(fff, "\n");
 dump(fff);
 file_putf(fff, "\n");
 pref_footer(fff, title);
 file_close(fff);
 return true;
}
/**
 * ------------------------------------------------------------------------
 * Pref file parser
 * ------------------------------------------------------------------------ */
/**
 * Load another file.
 */
static enum parser_error parse_prefs_load(struct parser *p)
{
 struct prefs_data *d = parser_priv(p);
 const char *file;
 assert(d != NULL);
 if (d->bypass) return PARSE_ERROR_NONE;
 file = parser_getstr(p, "file");
 (void)process_pref_file(file, true, d->user);
 return PARSE_ERROR_NONE;
}
/**
 * Helper function for "process_pref_file()"
 *
 * Input:
 *   v: output buffer array
 *   f: final character
 *
 * Output:
 *   result
 */
static const char *process_pref_file_expr(char **sp, char *fp)
{
 const char *v;
 char *b;
 char *s;
 char f = ' ';
 /* Initial */
 s = (*sp);
 /* Skip spaces */
 while (isspace((unsigned char)*s)) s++;
 /* Save start */
 b = s;
 /* Default */
 v = "?o?o?";
 /* Either the string starts with a [ or it doesn't */
 if (*s == '[') {
  const char *p;
  const char *t;
  /* Skip [ */
  s++;
  /* First */
  t = process_pref_file_expr(&s, &f);
  /* Check all the different types of connective */
  if (!*t) {
   /* Nothing */
  } else if (streq(t, "IOR")) {
   v = "0";
   while (*s && (f != ']')) {
    t = process_pref_file_expr(&s, &f);
    if (*t && !streq(t, "0")) v = "1";
   }
  } else if (streq(t, "AND")) {
   v = "1";
   while (*s && (f != ']')) {
    t = process_pref_file_expr(&s, &f);
    if (*t && streq(t, "0")) v = "0";
   }
  } else if (streq(t, "NOT")) {
   v = "1";
   while (*s && (f != ']')) {
    t = process_pref_file_expr(&s, &f);
    if (*t && !streq(t, "0")) v = "0";
   }
  } else if (streq(t, "EQU")) {
   v = "1";
   if (*s && (f != ']')) {
    t = process_pref_file_expr(&s, &f);
   }
   while (*s && (f != ']')) {
    p = t;
    t = process_pref_file_expr(&s, &f);
    if (*t && !streq(p, t)) v = "0";
   }
  } else if (streq(t, "LEQ")) {
   v = "1";
   if (*s && (f != ']')) {
    t = process_pref_file_expr(&s, &f);
   }
   while (*s && (f != ']')) {
    p = t;
    t = process_pref_file_expr(&s, &f);
    if (*t && (strcmp(p, t) >= 0)) v = "0";
   }
  } else if (streq(t, "GEQ")) {
   v = "1";
   if (*s && (f != ']')) {
    t = process_pref_file_expr(&s, &f);
   }
   while (*s && (f != ']')) {
    p = t;
    t = process_pref_file_expr(&s, &f);
    if (*t && (strcmp(p, t) <= 0)) v = "0";
   }
  } else {
   while (*s && (f != ']')) {
    (void) process_pref_file_expr(&s, &f);
   }
  }
  /* Verify ending */
  if (f != ']') v = "?x?x?";
  /* Extract final and Terminate */
  if ((f = *s) != '\0') *s++ = '\0';
 } else {
  /* Accept all printables except spaces and brackets */
  while (isprint((unsigned char)*s) && !strchr(" []", *s)) ++s;
  /* Extract final and Terminate */
  if ((f = *s) != '\0') *s++ = '\0';
  /* Variables start with $, otherwise it's a constant */
  if (*b == '$') {
   if (streq(b+1, "SYS"))
    v = ANGBAND_SYS;
   else if (streq(b+1, "RACE"))
    v = player->race->name;
   else if (streq(b+1, "HOUSE"))
    v = player->house->name;
   else if (streq(b+1, "SEX"))
    v = player->sex->name;
  } else {
   v = b;
  }
 }
 /* Save */
 (*fp) = f;
 (*sp) = s;
 return v;
}
/**
 * Parse one of the prefix-based logical expressions used in pref files
 */
static enum parser_error parse_prefs_expr(struct parser *p)
{
 struct prefs_data *d = parser_priv(p);
 const char *v;
 char *str;
 char *expr;
 char f;
 assert(d != NULL);
 /* XXX this can be avoided with a rewrite of process_pref_file_expr */
 str = expr = string_make(parser_getstr(p, "expr"));
 /* Parse the expr */
 v = process_pref_file_expr(&expr, &f);
 /* Set flag */
 d->bypass = streq(v, "0");
 string_free(str);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_prefs_object(struct parser *p)
{
 int tvi, svi;
 struct object_kind *kind;
 const char *tval, *sval;
 struct prefs_data *d = parser_priv(p);
 assert(d != NULL);
 if (d->bypass) return PARSE_ERROR_NONE;
 tval = parser_getsym(p, "tval");
 sval = parser_getsym(p, "sval");
 if (streq(tval, "*")) {
  /* object:*:* means handle all objects and flavors */
  uint8_t attr = parser_getint(p, "attr");
  wchar_t chr = parser_getint(p, "char");
  size_t i;
  struct flavor *flavor;
  if (!streq(sval, "*"))
   return PARSE_ERROR_UNRECOGNISED_SVAL;
  for (i = 0; i < z_info->k_max; i++) {
   struct object_kind *kind_local = &k_info[i];
   kind_x_attr[kind_local->kidx] = attr;
   kind_x_char[kind_local->kidx] = chr;
  }
  for (flavor = flavors; flavor; flavor = flavor->next) {
   flavor_x_attr[flavor->fidx] = attr;
   flavor_x_char[flavor->fidx] = chr;
  }
 } else {
  tvi = tval_find_idx(tval);
  if (tvi < 0)
   return PARSE_ERROR_UNRECOGNISED_TVAL;
  /* object:tval:* means handle all objects and flavors with this tval */
  if (streq(sval, "*")) {
   uint8_t attr = parser_getint(p, "attr");
   wchar_t chr = parser_getint(p, "char");
   size_t i;
   struct flavor *flavor;
   for (i = 0; i < z_info->k_max; i++) {
    struct object_kind *kind_local = &k_info[i];
    if (kind_local->tval != tvi)
     continue;
    kind_x_attr[kind_local->kidx] = attr;
    kind_x_char[kind_local->kidx] = chr;
   }
   for (flavor = flavors; flavor; flavor = flavor->next)
    if (flavor->tval == tvi) {
     flavor_x_attr[flavor->fidx] = attr;
     flavor_x_char[flavor->fidx] = chr;
    }
  } else {
   /* No error at incorrect sval to stop failure due to outdated
			 * pref files and enable switching between old and new classes */
   svi = lookup_sval(tvi, sval);
   if (svi < 0)
    return PARSE_ERROR_NONE;
   kind = lookup_kind(tvi, svi);
   if (!kind)
    return PARSE_ERROR_NONE;
   kind_x_attr[kind->kidx] = (uint8_t)parser_getint(p, "attr");
   kind_x_char[kind->kidx] = (wchar_t)parser_getint(p, "char");
  }
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_prefs_monster(struct parser *p)
{
 const char *name;
 struct monster_race *monster;
 struct prefs_data *d = parser_priv(p);
 assert(d != NULL);
 if (d->bypass) return PARSE_ERROR_NONE;
 name = parser_getsym(p, "name");
 monster = lookup_monster(name);
 if (!monster)
  return PARSE_ERROR_NO_KIND_FOUND;
 monster_x_attr[monster->ridx] = (uint8_t)parser_getint(p, "attr");
 monster_x_char[monster->ridx] = (wchar_t)parser_getint(p, "char");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_prefs_monster_base(struct parser *p)
{
 const char *name;
 struct monster_base *mb;
 size_t i;
 uint8_t a;
 wchar_t c;
 struct prefs_data *d = parser_priv(p);
 assert(d != NULL);
 if (d->bypass) return PARSE_ERROR_NONE;
 name = parser_getsym(p, "name");
 mb = lookup_monster_base(name);
 if (!mb)
  return PARSE_ERROR_NO_KIND_FOUND;
 a = (uint8_t)parser_getint(p, "attr");
 c = (wchar_t)parser_getint(p, "char");
 for (i = 0; i < z_info->r_max; i++) {
  struct monster_race *race = &r_info[i];
  if (race->base != mb) continue;
  monster_x_attr[race->ridx] = a;
  monster_x_char[race->ridx] = c;
 }
 return PARSE_ERROR_NONE;
}
static void set_trap_graphic(int trap_idx, int light_idx, uint8_t attr, wchar_t ch) {
 if (light_idx < LIGHTING_MAX) {
  trap_x_attr[light_idx][trap_idx] = attr;
  trap_x_char[light_idx][trap_idx] = ch;
 } else {
  for (light_idx = 0; light_idx < LIGHTING_MAX; light_idx++) {
   trap_x_attr[light_idx][trap_idx] = attr;
   trap_x_char[light_idx][trap_idx] = ch;
  }
 }
}
static enum parser_error parse_prefs_trap(struct parser *p)
{
 const char *idx_sym;
 const char *lighting;
 int trap_idx;
 int light_idx;
 struct prefs_data *d = parser_priv(p);
 assert(d != NULL);
 if (d->bypass) return PARSE_ERROR_NONE;
 /* idx can be "*" or a name */
 idx_sym = parser_getsym(p, "idx");
 if (streq(idx_sym, "*")) {
  trap_idx = -1;
 } else {
  struct trap_kind *trap = lookup_trap(idx_sym);
  if (!trap) {
   return PARSE_ERROR_UNRECOGNISED_TRAP;
  } else {
   trap_idx = trap->tidx;
  }
 }
 lighting = parser_getsym(p, "lighting");
 if (streq(lighting, "torch"))
  light_idx = LIGHTING_TORCH;
 else if (streq(lighting, "los"))
  light_idx = LIGHTING_LOS;
 else if (streq(lighting, "lit"))
  light_idx = LIGHTING_LIT;
 else if (streq(lighting, "dark"))
  light_idx = LIGHTING_DARK;
 else if (streq(lighting, "*"))
  light_idx = LIGHTING_MAX;
 else
  return PARSE_ERROR_INVALID_LIGHTING;
 if (trap_idx == -1) {
  size_t i;
  for (i = 0; i < z_info->trap_max; i++) {
   set_trap_graphic(i, light_idx,
     parser_getint(p, "attr"), parser_getint(p, "char"));
  }
 } else {
  set_trap_graphic(trap_idx, light_idx,
    parser_getint(p, "attr"), parser_getint(p, "char"));
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_prefs_feat(struct parser *p)
{
 const char *sym = parser_getsym(p, "idx");
 int idx;
 const char *lighting;
 int light_idx;
 struct prefs_data *d = parser_priv(p);
 assert(d != NULL);
 if (d->bypass) return PARSE_ERROR_NONE;
 idx = lookup_feat_code(sym);
 if (idx < 0) {
  /*
		 * To tolerate user preference files written before the
		 * change that introduced terrain codes (made between
		 * NarSil 1.3 and 1.3.1), try looking up the feature's
		 * printable name.  This could be dropped when a future
		 * version drops save file compatibility.
		 */
  idx = lookup_feat(sym);
 }
 if (idx < 0 || idx >= FEAT_MAX) {
  return PARSE_ERROR_OUT_OF_BOUNDS;
 }
 lighting = parser_getsym(p, "lighting");
 if (streq(lighting, "torch"))
  light_idx = LIGHTING_TORCH;
 else if (streq(lighting, "los"))
  light_idx = LIGHTING_LOS;
 else if (streq(lighting, "lit"))
  light_idx = LIGHTING_LIT;
 else if (streq(lighting, "dark"))
  light_idx = LIGHTING_DARK;
 else if (streq(lighting, "*"))
  light_idx = LIGHTING_MAX;
 else
  return PARSE_ERROR_INVALID_LIGHTING;
 if (light_idx < LIGHTING_MAX) {
  feat_x_attr[light_idx][idx] = (uint8_t)parser_getint(p, "attr");
  feat_x_char[light_idx][idx] = (wchar_t)parser_getint(p, "char");
 } else {
  for (light_idx = 0; light_idx < LIGHTING_MAX; light_idx++) {
   feat_x_attr[light_idx][idx] = (uint8_t)parser_getint(p, "attr");
   feat_x_char[light_idx][idx] = (wchar_t)parser_getint(p, "char");
  }
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_prefs_gf(struct parser *p)
{
 bool types[PROJ_MAX] = { 0 };
 const char *direction;
 int motion;
 char *s, *t;
 size_t i;
 struct prefs_data *d = parser_priv(p);
 assert(d != NULL);
 if (d->bypass) return PARSE_ERROR_NONE;
 /* Parse the type, which is a | separated list of PROJ_ constants */
 s = string_make(parser_getsym(p, "type"));
 t = strtok(s, "| ");
 while (t) {
  if (streq(t, "*")) {
   memset(types, true, sizeof types);
  } else {
   int idx = proj_name_to_idx(t);
   if (idx == -1)
    return PARSE_ERROR_INVALID_VALUE;
   types[idx] = true;
  }
  t = strtok(NULL, "| ");
 }
 string_free(s);
 direction = parser_getsym(p, "direction");
 if (streq(direction, "static"))
  motion = BOLT_NO_MOTION;
 else if (streq(direction, "0"))
  motion = BOLT_0;
 else if (streq(direction, "45"))
  motion = BOLT_45;
 else if (streq(direction, "90"))
  motion = BOLT_90;
 else if (streq(direction, "135"))
  motion = BOLT_135;
 else
  return PARSE_ERROR_INVALID_VALUE;
 for (i = 0; i < PROJ_MAX; i++) {
  if (!types[i]) continue;
  proj_to_attr[i][motion] = (uint8_t)parser_getuint(p, "attr");
  proj_to_char[i][motion] = (wchar_t)parser_getuint(p, "char");
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_prefs_gs(struct parser *p)
{
 struct prefs_data *d = parser_priv(p);
 const char *name = parser_getsym(p, "type");
 int x_attr = parser_getint(p, "attr");
 int x_char = parser_getint(p, "char");
 assert(d != NULL);
 if (d->bypass) return PARSE_ERROR_NONE;
 if (streq(name, "ALERT")) {
  alert_x_attr = (uint8_t)x_attr;
  alert_x_char = (wchar_t)x_char;
 } else if (streq(name, "GLOW")) {
  glow_x_attr = (uint8_t)x_attr;
  glow_x_char = (wchar_t)x_char;
 } else {
  char *ep;
  long l = strtol(name, &ep, 10);
  if (l >= 0 && l <= 9 && contains_only_spaces(ep)
    && !contains_only_spaces(name)) {
   damage_x_attr[l] = (uint8_t)x_attr;
   damage_x_char[l] = (wchar_t)x_char;
  } else {
   return PARSE_ERROR_UNRECOGNISED_PARAMETER;
  }
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_prefs_flavor(struct parser *p)
{
 unsigned int idx;
 struct flavor *flavor;
 struct prefs_data *d = parser_priv(p);
 assert(d != NULL);
 if (d->bypass) return PARSE_ERROR_NONE;
 idx = parser_getuint(p, "idx");
 for (flavor = flavors; flavor; flavor = flavor->next)
  if (flavor->fidx == idx)
   break;
 if (flavor) {
  flavor_x_attr[idx] = (uint8_t)parser_getint(p, "attr");
  flavor_x_char[idx] = (wchar_t)parser_getint(p, "char");
 }
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_prefs_inscribe(struct parser *p)
{
 int tvi, svi;
 struct object_kind *kind;
 struct prefs_data *d = parser_priv(p);
 assert(d != NULL);
 if (d->bypass) return PARSE_ERROR_NONE;
 tvi = tval_find_idx(parser_getsym(p, "tval"));
 if (tvi < 0)
  return PARSE_ERROR_UNRECOGNISED_TVAL;
 svi = lookup_sval(tvi, parser_getsym(p, "sval"));
 if (svi < 0)
  return PARSE_ERROR_UNRECOGNISED_SVAL;
 kind = lookup_kind(tvi, svi);
 if (!kind)
  return PARSE_ERROR_UNRECOGNISED_SVAL;
 add_autoinscription(kind->kidx, parser_getstr(p, "text"), true);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_prefs_keymap_action(struct parser *p)
{
 const char *act = "";
 struct prefs_data *d = parser_priv(p);
 assert(d != NULL);
 if (d->bypass) return PARSE_ERROR_NONE;
 if (parser_hasval(p, "act")) {
  act = parser_getstr(p, "act");
 }
 keypress_from_text(d->keymap_buffer, N_ELEMENTS(d->keymap_buffer), act);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_prefs_keymap_input(struct parser *p)
{
 int mode;
 struct keypress tmp[2];
 struct prefs_data *d = parser_priv(p);
 assert(d != NULL);
 if (d->bypass) return PARSE_ERROR_NONE;
 mode = parser_getint(p, "mode");
 if (mode < 0 || mode >= KEYMAP_MODE_MAX)
  return PARSE_ERROR_OUT_OF_BOUNDS;
 keypress_from_text(tmp, N_ELEMENTS(tmp), parser_getstr(p, "key"));
 if (tmp[0].type != EVT_KBRD || tmp[1].type != EVT_NONE)
  return PARSE_ERROR_FIELD_TOO_LONG;
 keymap_add(mode, tmp[0], d->keymap_buffer, d->user);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_prefs_message(struct parser *p)
{
 int a, msg_index;
 const char *attr;
 const char *type;
 struct prefs_data *d = parser_priv(p);
 assert(d != NULL);
 if (d->bypass) return PARSE_ERROR_NONE;
 type = parser_getsym(p, "type");
 attr = parser_getsym(p, "attr");
 msg_index = message_lookup_by_name(type);
 if (msg_index < 0)
  return PARSE_ERROR_INVALID_MESSAGE;
 if (strlen(attr) > 1)
  a = color_text_to_attr(attr);
 else
  a = color_char_to_attr(attr[0]);
 if (a < 0)
  return PARSE_ERROR_INVALID_COLOR;
 message_color_define(msg_index, (uint8_t)a);
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_prefs_color(struct parser *p)
{
 int idx;
 struct prefs_data *d = parser_priv(p);
 assert(d != NULL);
 if (d->bypass) return PARSE_ERROR_NONE;
 idx = parser_getuint(p, "idx");
 if (idx >= MAX_COLORS) {
  /*
		 * Silently ignore indices that would have been in bounds when
		 * the color table had 256 entries for backwards compatibility
		 * with existing preference files.  Flag indices that would be
		 * out of bounds even with the bigger color table.
		 */
  return (idx < 256) ?
   PARSE_ERROR_NONE : PARSE_ERROR_OUT_OF_BOUNDS;
 }
 angband_color_table[idx][0] = parser_getint(p, "k");
 angband_color_table[idx][1] = parser_getint(p, "r");
 angband_color_table[idx][2] = parser_getint(p, "g");
 angband_color_table[idx][3] = parser_getint(p, "b");
 return PARSE_ERROR_NONE;
}
static enum parser_error parse_prefs_window(struct parser *p)
{
 int window;
 size_t flag;
 struct prefs_data *d = parser_priv(p);
 assert(d != NULL);
 if (d->bypass) return PARSE_ERROR_NONE;
 window = parser_getint(p, "window");
 if (window <= 0 || window >= ANGBAND_TERM_MAX)
  return PARSE_ERROR_OUT_OF_BOUNDS;
 flag = parser_getuint(p, "flag");
 if (flag >= N_ELEMENTS(window_flag_desc))
  return PARSE_ERROR_OUT_OF_BOUNDS;
 if (window_flag_desc[flag])
 {
  int value = parser_getuint(p, "value");
  if (value)
   d->window_flags[window] |= (((uint32_t) 1) << flag);
  else
   d->window_flags[window] &= ~(((uint32_t) 1) << flag);
 }
 d->loaded_window_flag[window] = true;
 return PARSE_ERROR_NONE;
}
enum parser_error parse_prefs_dummy(struct parser *p)
{
 return PARSE_ERROR_NONE;
}
static struct parser *init_parse_prefs(bool user)
{
 struct parser *p = parser_new();
 struct prefs_data *pd = mem_zalloc(sizeof *pd);
 int i;
 parser_setpriv(p, pd);
 pd->user = user;
 for (i = 0; i < ANGBAND_TERM_MAX; i++) {
  pd->loaded_window_flag[i] = false;
 }
 parser_reg(p, "% str file", parse_prefs_load);
 parser_reg(p, "? str expr", parse_prefs_expr);
 parser_reg(p, "object sym tval sym sval int attr int char", parse_prefs_object);
 parser_reg(p, "monster sym name int attr int char", parse_prefs_monster);
 parser_reg(p, "monster-base sym name int attr int char", parse_prefs_monster_base);
 parser_reg(p, "feat sym idx sym lighting int attr int char", parse_prefs_feat);
 parser_reg(p, "trap sym idx sym lighting int attr int char", parse_prefs_trap);
 parser_reg(p, "GF sym type sym direction uint attr uint char", parse_prefs_gf);
 parser_reg(p, "GS sym type int attr int char", parse_prefs_gs);
 parser_reg(p, "flavor uint idx int attr int char", parse_prefs_flavor);
 parser_reg(p, "inscribe sym tval sym sval str text", parse_prefs_inscribe);
 parser_reg(p, "keymap-act ?str act", parse_prefs_keymap_action);
 parser_reg(p, "keymap-input int mode str key", parse_prefs_keymap_input);
 parser_reg(p, "message sym type sym attr", parse_prefs_message);
 parser_reg(p, "color uint idx int k int r int g int b", parse_prefs_color);
 parser_reg(p, "window int window uint flag uint value", parse_prefs_window);
 register_sound_pref_parser(p);
 return p;
}
static errr finish_parse_prefs(struct parser *p)
{
 struct prefs_data *d = parser_priv(p);
 int i;
 /* Update sub-windows based on the newly read-in prefs.
	 *
	 * The window_flag[] array cannot be updated directly during
	 * parsing since the changes between the existing flags and the new
	 * are used to set/unset the event handlers that update the windows.
	 *
	 * Build a complete set to pass to subwindows_set_flags() by loading
	 * any that weren't read in by the parser from the existing set.
	 */
 for (i = 0; i < ANGBAND_TERM_MAX; i++) {
  if (!d->loaded_window_flag[i])
   d->window_flags[i] = window_flag[i];
 }
 subwindows_set_flags(d->window_flags, ANGBAND_TERM_MAX);
 /*
	 * If all of the damage indicators have not been set, ensure
	 * damage_x_attr[0] is zero so that can be tested to choose between
	 * plain digits or tiles for the damage indicators.
	 */
 for (i = 0; i < 10; ++i) {
  if (!(damage_x_attr[i] & 0x80)) {
   damage_x_attr[0] = 0;
   break;
  }
 }
 return PARSE_ERROR_NONE;
}
errr process_pref_file_command(const char *s)
{
 struct parser *p = init_parse_prefs(true);
 errr e = parser_parse(p, s);
 mem_free(parser_priv(p));
 parser_destroy(p);
 return e;
}
static void ui_print_error(const char *name, struct parser *p) {
 struct parser_state s;
 parser_getstate(p, &s);
 msg("Parse error in %s line %d column %d: %s: %s", name,
            s.line, s.col, s.msg, parser_error_str[s.error]);
 event_signal(EVENT_MESSAGE_FLUSH);
}
/**
 * Process the user pref file with a given path.
 *
 * \param path is the name of the pref file.
 * \param quiet means "don't complain about not finding the file".
 * \param user should be true if the pref file is user-specific and not a game
 * default.
 */
static bool process_pref_file_named(const char *path, bool quiet, bool user) {
 ang_file *f = file_open(path, MODE_READ, -1);
 errr e = 0;
 if (!f) {
  if (!quiet)
   msg("Cannot open '%s'.", path);
  e = PARSE_ERROR_INTERNAL; /* signal failure to callers */
 } else {
  char line[1024];
  struct parser *p = init_parse_prefs(user);
  while (file_getl(f, line, sizeof line)) {
   e = parser_parse(p, line);
   if (e != PARSE_ERROR_NONE) {
    ui_print_error(path, p);
    break;
   }
  }
  finish_parse_prefs(p);
  file_close(f);
  mem_free(parser_priv(p));
  parser_destroy(p);
 }
 /* Result */
 return e == PARSE_ERROR_NONE;
}
/**
 * Process the user pref file with a given name and search paths.
 *
 * \param name is the name of the pref file.
 * \param quiet means "don't complain about not finding the file".
 * \param user should be true if the pref file is user-specific and not a game
 * default.
 * \param base_search_path is the first path that should be checked for the file
 * \param fallback_search_path is the path that should be checked if the file
 * couldn't be found at the base path.
 * \param used_fallback will be set on return to true if the fallback path was
 * used, false otherwise.
 * \returns true if everything worked OK, false otherwise.
 */
static bool process_pref_file_layered(const char *name, bool quiet, bool user,
           const char *base_search_path,
           const char *fallback_search_path,
           bool *used_fallback)
{
 char buf[1024];
 assert(base_search_path != NULL);
 /* Build the filename */
 path_build(buf, sizeof(buf), base_search_path, name);
 if (used_fallback != NULL)
  *used_fallback = false;
 if (!file_exists(buf) && fallback_search_path != NULL) {
  path_build(buf, sizeof(buf), fallback_search_path, name);
  if (used_fallback != NULL)
   *used_fallback = true;
 }
 return process_pref_file_named(buf, quiet, user);
}
/**
 * Look for a pref file at its base location (falling back to another path if
 * needed) and then in the user location. This effectively will layer a user
 * pref file on top of a default pref file.
 *
 * Because of the way this function works, there might be some unexpected
 * effects when a pref file triggers another pref file to be loaded.
 * For example, lib/customize/pref.prf causes message.prf to load. This means
 * that the game will load lib/customize/pref.prf, then
 * lib/customize/message.prf, then message.prf from the user location, and
 * finally pref.prf from the user location.
 *
 * \param name is the name of the pref file.
 * \param quiet means "don't complain about not finding the file".
 * \param user should be true if the pref file is user-specific and not a game
 * default.
 * \returns true if everything worked OK, false otherwise.
 */
bool process_pref_file(const char *name, bool quiet, bool user)
{
 bool root_success = false;
 bool user_success = false;
 bool used_fallback = false;
 /* This supports the old behavior: first load from lib/customize then
         * from the user location. */
 root_success = process_pref_file_layered(name, quiet, user,
            ANGBAND_DIR_CUSTOMIZE,
            ANGBAND_DIR_USER,
            &used_fallback);
 /* If not found, do a check of the current graphics directory */
 if (!root_success && current_graphics_mode)
  root_success = process_pref_file_layered(name, quiet, user,
             current_graphics_mode->path,
             NULL, NULL);
 /* Next, we want to force a check for the file in the user location.
	 * However, since we used the user directory as a fallback in the previous
	 * check, we only want to do this if the fallback wasn't used. This cuts
	 * down on unnecessary parsing. */
 if (!used_fallback) {
  /* Force quiet (since this is an optional file) and force user
		 * (since this should always be considered user-specific). */
  user_success = process_pref_file_layered(name, true, true,
             ANGBAND_DIR_USER, NULL,
             &used_fallback);
 }
 /* If only one load was successful, that's okay; we loaded something. */
 return root_success || user_success;
}
/**
 * Reset the "visual" lists
 *
 * This involves resetting various things to their "default" state.
 *
 * If the "prefs" flag is true, then we will also load the appropriate
 * "user pref file" based on the current setting of the "use_graphics"
 * flag.  This is useful for switching "graphics" on/off.
 */
void reset_visuals(bool load_prefs)
{
 int i, j;
 struct flavor *f;
 /* Extract default attr/char code for features */
 for (i = 0; i < FEAT_MAX; i++) {
  struct feature *feat = &f_info[i];
  /* Assume we will use the underlying values */
  for (j = 0; j < LIGHTING_MAX; j++) {
   feat_x_attr[j][i] = feat->d_attr;
   feat_x_char[j][i] = feat->d_char;
  }
 }
 /* Extract default attr/char code for objects */
 for (i = 0; i < z_info->k_max; i++) {
  struct object_kind *kind = &k_info[i];
  /* Default attr/char */
  kind_x_attr[i] = kind->d_attr;
  kind_x_char[i] = kind->d_char;
 }
 /* Extract default attr/char code for monsters */
 for (i = 0; i < z_info->r_max; i++) {
  struct monster_race *race = &r_info[i];
  /* Default attr/char */
  monster_x_attr[i] = race->d_attr;
  monster_x_char[i] = race->d_char;
 }
 /* Extract default attr/char code for traps */
 for (i = 0; i < z_info->trap_max; i++) {
  struct trap_kind *trap = &trap_info[i];
  /* Default attr/char */
  for (j = 0; j < LIGHTING_MAX; j++) {
   trap_x_attr[j][i] = trap->d_attr;
   trap_x_char[j][i] = trap->d_char;
  }
 }
 /* Extract default attr/char code for flavors */
 for (f = flavors; f; f = f->next) {
  flavor_x_attr[f->fidx] = f->d_attr;
  flavor_x_char[f->fidx] = f->d_char;
 }
 if (!load_prefs)
  return;
 /* Graphic symbols */
 if (use_graphics) {
  /* if we have a graphics mode, see if the mode has a pref file name */
  graphics_mode *mode = get_graphics_mode(use_graphics);
  char buf[2014];
  assert(mode);
  /* Build path to the pref file */
  path_build(buf, sizeof buf, mode->path, mode->pref);
  process_pref_file_named(buf, false, false);
 } else {
  /* Normal symbols */
  process_pref_file("font.prf", false, false);
 }
}
/**
 * Initialise the glyphs for monsters, objects, traps, flavors and terrain
 */
void textui_prefs_init(void)
{
 int i;
 struct flavor *f;
 monster_x_attr = mem_zalloc(z_info->r_max * sizeof(uint8_t));
 monster_x_char = mem_zalloc(z_info->r_max * sizeof(wchar_t));
 kind_x_attr = mem_zalloc(z_info->k_max * sizeof(uint8_t));
 kind_x_char = mem_zalloc(z_info->k_max * sizeof(wchar_t));
 for (i = 0; i < LIGHTING_MAX; i++) {
  feat_x_attr[i] = mem_zalloc(FEAT_MAX * sizeof(uint8_t));
  feat_x_char[i] = mem_zalloc(FEAT_MAX * sizeof(wchar_t));
 }
 for (i = 0; i < LIGHTING_MAX; i++) {
  trap_x_attr[i] = mem_zalloc(z_info->trap_max * sizeof(uint8_t));
  trap_x_char[i] = mem_zalloc(z_info->trap_max * sizeof(wchar_t));
 }
 for (f = flavors; f; f = f->next)
  if (flavor_max < f->fidx)
   flavor_max = f->fidx;
 flavor_x_attr = mem_zalloc((flavor_max + 1) * sizeof(uint8_t));
 flavor_x_char = mem_zalloc((flavor_max + 1) * sizeof(wchar_t));
 alert_x_attr = 0;
 alert_x_char = 0;
 glow_x_attr = 0;
 glow_x_char = 0;
 for (i = 0; i < 10; ++i) {
  damage_x_attr[i] = 0;
  damage_x_char[i] = 0;
 }
 reset_visuals(false);
}
/**
 * Free the glyph arrays for monsters, objects, traps, flavors and terrain
 */
void textui_prefs_free(void)
{
 int i;
 mem_free(monster_x_attr);
 mem_free(monster_x_char);
 mem_free(kind_x_attr);
 mem_free(kind_x_char);
 for (i = 0; i < LIGHTING_MAX; i++) {
  mem_free(feat_x_attr[i]);
  mem_free(feat_x_char[i]);
 }
 for (i = 0; i < LIGHTING_MAX; i++) {
  mem_free(trap_x_attr[i]);
  mem_free(trap_x_char[i]);
 }
 mem_free(flavor_x_attr);
 mem_free(flavor_x_char);
}
/**
 * Ask for a "user pref line" and process it
 */
void do_cmd_pref(void)
{
 char tmp[80];
 /* Default */
 my_strcpy(tmp, "", sizeof(tmp));
 /* Ask for a "user pref command" */
 if (!get_string("Pref: ", tmp, 80)) return;
 /* Process that pref command */
 (void)process_pref_file_command(tmp);
}
/**
 * ------------------------------------------------------------------------
 * Utility functions
 * ------------------------------------------------------------------------ */
/**
 * Return the first active subwindow with the given flag enabled or NULL if
 * there isn't an active subwindow with that flag enabled.
 *
 * \param flag is the flag to test.
 */
term *find_first_subwindow(uint32_t flag)
{
 int i = 1;
 while (1) {
  if (i >= ANGBAND_TERM_MAX) {
   return NULL;
  }
  if ((window_flag[i] & flag) && angband_term[i]) {
   return angband_term[i];
  }
  ++i;
 }
}
/**
 * \file ui-score.c
 * \brief Highscore display for Angband
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Prints a nice comma spaced natural number
 */
static void comma_number(char *output, int number, int len)
{
 if (number >= 1000000) {
  strnfmt(output, len, "%d,%03d,%03d", number / 1000000,
    (number % 1000000) / 1000, number % 1000);
 } else if (number >= 1000) {
  strnfmt(output, len, "%d,%03d", number / 1000, number % 1000);
 } else {
  strnfmt(output, len, "%d", number);
 }
}
/*
 * Converts a number into the three letter code of a month
 */
static void atomonth(int number, char *output, int len)
{
 switch (number)
 {
  case 1:
   strnfmt(output, len, "Jan");
   break;
  case 2:
   strnfmt(output, len, "Feb");
   break;
  case 3:
   strnfmt(output, len, "Mar");
   break;
  case 4:
   strnfmt(output, len, "Apr");
   break;
  case 5:
   strnfmt(output, len, "May");
   break;
  case 6:
   strnfmt(output, len, "Jun");
   break;
  case 7:
   strnfmt(output, len, "Jul");
   break;
  case 8:
   strnfmt(output, len, "Aug");
   break;
  case 9:
   strnfmt(output, len, "Sep");
   break;
  case 10:
   strnfmt(output, len, "Oct");
   break;
  case 11:
   strnfmt(output, len, "Nov");
   break;
  case 12:
   strnfmt(output, len, "Dec");
   break;
  default:
   break;
 }
}
/**
 * Display a page of scores
 */
void display_single_score(const struct high_score *score, int row, int place,
        int attr)
{
 int aged, depth;
 const char *user, *when;
 struct player_house *h;
 struct player_sex *s;
 char out_val[160];
 char tmp_val[160];
 char aged_commas[15];
 char depth_commas[15];
 bool alive = streq(score->how, "(alive and well)");
 h = player_id2house(atoi(score->p_h));
 s = player_id2sex(atoi(score->p_s));
 /* Hack -- extract the gold and such */
 for (user = score->uid; isspace((unsigned char)*user); user++)
  /* loop */;
 for (when = score->day; isspace((unsigned char)*when); when++)
  /* loop */;
 aged = atoi(score->turns);
 depth = atoi(score->cur_dun) * 50;
 comma_number(aged_commas, aged, sizeof(aged_commas));
 comma_number(depth_commas, depth, sizeof(depth_commas));
 /* Clean up standard encoded form of "when" */
 if ((*when == '@') && strlen(when) == 9) {
  char month[4];
  strnfmt(month, sizeof(month), "%.2s", when + 5);
  atomonth(atoi(month), month, sizeof(month));
  if (*(when + 7) == '0') {
   strnfmt(tmp_val, sizeof(tmp_val), "%.1s %.3s %.4s",
    when + 8, month, when + 1);
  } else {
   strnfmt(tmp_val, sizeof(tmp_val), "%.2s %.3s %.4s",
    when + 7, month, when + 1);
  }
  when = tmp_val;
 }
 /* If not displayed in a place, then don't write the place number */
 if (place == 0) {
  /* Prepare the first line, with the house only */
  strnfmt(out_val, sizeof(out_val),
    "     %5s ft  %s of %s",
    depth_commas, score->who, h->alt_name);
 } else {
  /* Prepare the first line, with the house only */
  strnfmt(out_val, sizeof(out_val),
    "%3d. %5s ft  %s of %s",
    place, depth_commas, score->who, h->alt_name);
 }
 /* Possibly amend the first line */
 if (score->morgoth_slain[0] == 't') {
  my_strcat(out_val, ", who defeated Morgoth in his dark halls",
      sizeof(out_val));
 } else {
  if (score->silmarils[0] == '1') {
   my_strcat(out_val, ", who freed a Silmaril", sizeof(out_val));
  }
  if (score->silmarils[0] == '2') {
   my_strcat(out_val, ", who freed two Silmarils",
       sizeof(out_val));
  }
  if (score->silmarils[0] == '3') {
   my_strcat(out_val, ", who freed all three Silmarils",
       sizeof(out_val));
  }
  if (score->silmarils[0] > '3') {
   my_strcat(out_val, ", who freed suspiciously many Silmarils",
       sizeof(out_val));
  }
 }
 /* Dump the first line */
 c_put_str(attr, out_val, row + 3, 0);
 /* Prepare the second line for escapees */
 if (score->escaped[0] == 't') {
  strnfmt(out_val, sizeof(out_val),
    "               Escaped the iron hells");
  if ((score->morgoth_slain[0] == 't') ||
   (score->silmarils[0] > '0')) {
   my_strcat(out_val, " and brought back the light of Valinor",
       sizeof(out_val));
  } else {
   my_strcat(out_val, format(" with %s task unfulfilled",
           s->possessive), sizeof(out_val));
  }
 } else if (alive) {
  /* If character is still alive, display differently */
  strnfmt(out_val, sizeof(out_val),
    "               Lives still, deep within Angband's vaults");
 } else {
  /* Prepare the second line for those slain */
  strnfmt(out_val, sizeof(out_val),
    "               Slain by %s",
    score->how);
  /* Mark those with a silmaril */
  if (score->silmarils[0] > '0') {
   my_strcat(out_val, format(" during %s escape", s->possessive),
       sizeof(out_val));
  }
 }
 /* Dump the info */
 c_put_str(attr, out_val, row + 4, 0);
 /* Don't print date for living characters */
 if (alive) {
  strnfmt(out_val, sizeof(out_val),
    "               after %s turns.",
    aged_commas);
  c_put_str(attr, out_val, row + 5, 0);
 } else {
  strnfmt(out_val, sizeof(out_val),
    "               after %s turns.  (%s)",
    aged_commas, when);
  c_put_str(attr, out_val, row + 5, 0);
 }
 /* Print symbols for silmarils / slaying Morgoth */
 if (score->escaped[0] == 't') {
  c_put_str(attr, "  escaped", row + 3, 4);
 }
 if (score->silmarils[0] == '1') {
  c_put_str(attr, "         *", row + 5, 0);
 }
 if (score->silmarils[0] == '2') {
  c_put_str(attr, "        * *", row + 5, 0);
 }
 if (score->silmarils[0] > '2') {
  c_put_str(attr, "       * * *", row + 5, 0);
 }
 if (score->morgoth_slain[0] == 't') {
  c_put_str(COLOUR_L_DARK, "         V", row + 4, 0);
 }
}
/**
 * Display a page of scores
 */
static void display_score_page(const struct high_score scores[], int start,
          int count, int highlight)
{
 int n;
 /* Dump 5 entries */
 for (n = 0; start < count && n < 5; start++, n++) {
  const struct high_score *score = &scores[start];
  bool alive = streq(score->how, "(alive and well)");
  uint8_t attr = alive ? COLOUR_WHITE : COLOUR_SLATE;
  display_single_score(score, n * 4, start, attr);
 }
}
/**
 * Display the scores in a given range.
 */
static void display_scores_aux(const struct high_score scores[], int from,
          int to, int highlight, bool allow_scrolling)
{
 struct keypress ch;
 int k, count;
 /* Assume we will show the first 10 */
 if (from < 0) from = 0;
 if (to < 0) to = allow_scrolling ? 5 : 10;
 if (to > MAX_HISCORES) to = MAX_HISCORES;
 /* Hack -- Count the high scores */
 for (count = 0; count < MAX_HISCORES; count++)
  if (!scores[count].what[0])
   break;
 /* Forget about the last entries */
 if ((count > to) && !allow_scrolling) count = to;
 /*
	 * Move 5 entries at a time.  Unless scrolling is allowed, only
	 * move forward and stop once the end is reached.
	 */
 k = from;
 while (1) {
  /* Clear screen */
  Term_clear();
  /* Title */
  if (k > 0) {
   put_str(format("Names of the Fallen (from position %d)",
    k + 1), 0, 21);
  } else {
   put_str("Names of the Fallen", 0, 30);
  }
  display_score_page(scores, k, count, highlight);
  /* Wait for response; prompt centered on 80 character line */
  if (allow_scrolling) {
   prt("[Press ESC to exit, up for prior page, any other key for next page.]", 23, 6);
  } else {
   prt("[Press ESC to exit, any other key to page forward till done.]", 23, 9);
  }
  ch = inkey();
  prt("", 23, 0);
  if (ch.code == ESCAPE) {
   break;
  } else if (ch.code == ARROW_UP && allow_scrolling) {
   if (k == 0) {
    k = count - 5;
    while (k % 5) k++;
   } else if (k < 5) {
    k = 0;
   } else {
    k = k - 5;
   }
  } else {
   k += 5;
   if (k >= count) {
    if (allow_scrolling) {
     k = 0;
    } else {
     break;
    }
   }
  }
 }
 return;
}
/**
 * Predict the players location, and display it.
 */
void predict_score(bool allow_scrolling)
{
 int j;
 struct high_score the_score;
 struct high_score scores[MAX_HISCORES];
 /* Read scores, place current score */
 highscore_read(scores, N_ELEMENTS(scores));
 build_score(&the_score, player, "nobody (yet!)", NULL);
 if (player->is_dead)
  j = highscore_where(&the_score, scores, N_ELEMENTS(scores));
 else
  j = highscore_add(&the_score, scores, N_ELEMENTS(scores));
 /* Top fifteen scores if on the top ten, otherwise ten surrounding */
 if (j < 10) {
  display_scores_aux(scores, 0, 15, j, allow_scrolling);
 } else {
  display_scores_aux(scores, j - 2, j + 7, j, allow_scrolling);
 }
}
/**
 * Show scores.
 */
void show_scores(void)
{
 screen_save();
 /* Display the scores */
 if (character_generated) {
  predict_score(true);
 } else {
  /* Currently unused, but leaving in in case we re-implement looking
		 * at the scores without loading a character */
  struct high_score scores[MAX_HISCORES];
  highscore_read(scores, N_ELEMENTS(scores));
  display_scores_aux(scores, 0, MAX_HISCORES, -1, true);
 }
 screen_load();
 /* Hack - Flush it */
 Term_fresh();
}
/**
 * \file ui-signals.c
 * \brief Handle various OS signals
 *
 * Copyright (c) 1997 Ben Harrison
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
int16_t signal_count; /* Count interrupts ("I'm going to count to five") */
typedef void (*Signal_Handler_t)(int);
/**
 * Wrapper around signal() which it is safe to take the address
 * of, in case signal itself is hidden by some some macro magic.
 */
static Signal_Handler_t wrap_signal(int sig, Signal_Handler_t handler)
{
 return signal(sig, handler);
}
/* Call this instead of calling signal() directly. */
static Signal_Handler_t (*signal_aux)(int, Signal_Handler_t) = wrap_signal;
/**
 * Handle signals -- simple (interrupt and quit)
 *
 * This function was causing a *huge* number of problems, so it has
 * been simplified greatly.  We keep a global variable which counts
 * the number of times the user attempts to kill the process, and
 * we commit suicide if the user does this a certain number of times.
 *
 * We attempt to give "feedback" to the user as he approaches the
 * suicide thresh-hold, but without penalizing accidental keypresses.
 *
 * To prevent messy accidents, we should reset this global variable
 * whenever the user enters a keypress, or something like that.
 */
static void handle_signal_simple(int sig)
{
 /* Protect errno from library calls in signal handler */
 int save_errno = errno;
 /*
	 * Use own buffer to avoid interactions with the static variables
	 * used to implement vformat() (and thus quit_fmt() and format()).
	 */
 char msg[48];
 /* Disable handler */
 (void)(*signal_aux)(sig, SIG_IGN);
 /* Construct the exit message in case it is needed */
 (void)strnfmt(msg, sizeof(msg), "Exiting on signal %d!", sig);
 /* Nothing to save, just quit */
 if (!character_generated || character_saved) quit(msg);
 /* Count the signals */
 signal_count++;
 /*
	 * Terminate dead characters; quit without saving (non-setgid
	 * installations) or suicide (setgid installations) from interrupts
	 * (after warnings)
	 */
 if (player->is_dead) {
  /* Mark the savefile */
  my_strcpy(player->died_from, "Abortion", sizeof(player->died_from));
  close_game(false);
  /* Quit */
  quit(msg);
 } else if (signal_count >= 5) {
  /* Quit */
  quit(msg);
 } else if (signal_count >= 4) {
  /*
		 * Remember where the cursor was so it can be restored after
		 * the message is displayed.
		 */
  int cx, cy;
  errr cbad = Term_locate(&cx, &cy);
  /* Make a noise */
  Term_xtra(TERM_XTRA_NOISE, 0);
  /* Clear the top line */
  Term_erase(0, 0, 255);
  /* Display the cause */
  Term_putstr(0, 0, -1, COLOUR_WHITE, "Another interrupt (CTRL-c) will quit without saving!");
  /* Restore the cursor position. */
  if (!cbad) {
   Term_gotoxy(cx, cy);
  }
  /* Flush */
  Term_fresh();
 } else if (signal_count >= 2) {
  /* Make a noise */
  Term_xtra(TERM_XTRA_NOISE, 0);
 }
 /* Restore handler */
 (void)(*signal_aux)(sig, handle_signal_simple);
 /* Restore errno */
 errno = save_errno;
}
/**
 * Handle signal -- abort, kill, etc
 */
static void handle_signal_abort(int sig)
{
 /*
	 * Use own buffer to avoid interactions with the static variables
	 * used to implement vformat() (and thus quit_fmt() and format()).
	 */
 char msg[48];
 /* Disable handler */
 (void)(*signal_aux)(sig, SIG_IGN);
 /* Construct the exit message */
 (void)strnfmt(msg, sizeof(msg), "Exiting on signal %d!", sig);
 /* Nothing to save, just quit */
 if (!character_generated || character_saved) quit(msg);
 /* Clear the bottom line */
 Term_erase(0, 23, 255);
 /* Give a warning */
 Term_putstr(0, 23, -1, COLOUR_RED,
             "A gruesome software bug LEAPS out at you!");
 /* Message */
 Term_putstr(45, 23, -1, COLOUR_RED, "Panic save...");
 /* Flush output */
 Term_fresh();
 /* Panic save */
 my_strcpy(player->died_from, "(panic save)", sizeof(player->died_from));
 savefile_get_panic_name(panicfile, sizeof(panicfile), savefile);
 /* Forbid suspend */
 signals_ignore_tstp();
 /* Attempt to save */
 if (panicfile[0] && savefile_save(panicfile))
  Term_putstr(45, 23, -1, COLOUR_RED, "Panic save succeeded!");
 else
  Term_putstr(45, 23, -1, COLOUR_RED, "Panic save failed!");
 /* Flush output */
 Term_fresh();
 /* Quit */
 quit(msg);
}
/**
 * Ignore SIGTSTP signals (keyboard suspend)
 */
void signals_ignore_tstp(void)
{
}
/**
 * Handle SIGTSTP signals (keyboard suspend)
 */
void signals_handle_tstp(void)
{
}
/**
 * Prepare to handle the relevant signals
 */
void signals_init(void)
{
/* Set to 0 to suppress signal handlers when debugging */
/**
 * SIGDANGER:
 * This is not a common (POSIX, SYSV, BSD) signal, it is used by AIX(?) to
 * signal that the system will soon be out of memory.
 */
}
/**
 * \file ui-skills.c
 * \brief Text-based user interface for skill point allocation
 *
 * Copyright (c) 1987 - 2023 Angband contributors
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * ------------------------------------------------------------------------
 * Point-based skill allocation.
 * ------------------------------------------------------------------------ */
int skill_idx = 0;
/*
 * Remember what's possible for a given skill.  0 means can't buy or sell.
 * 1 means can sell.  2 means can buy.  3 means can buy or sell.
 */
static int skbuysell[SKILL_MAX];
/**
 * This is called whenever a skill changes.  We take the easy road, and just
 * redisplay them all using the standard function.
 */
static void point_skills(game_event_type type, game_event_data *data,
         void *user)
{
 display_player_skill_info();
}
/**
 * This is called whenever any of the other miscellaneous skill-dependent things
 * changed.  We redisplay everything because it's easier.
 */
static void sk_point_misc(game_event_type type, game_event_data *data,
        void *user)
{
 display_player_xtra_info();
}
/**
 * This is called whenever the points totals are changed (in birth.c), so
 * that we can update our display of how many points have been spent and
 * are available.
 */
static void skill_points(game_event_type type, game_event_data *data,
       void *user)
{
 int i;
 int sum = 0;
 const int *spent = data->exp.exp;
 const int *inc = data->exp.inc_exp;
 int remaining = data->exp.remaining;
 /* Display the costs header */
 put_str("Cost", 7 - 1, (42 + 32));
 for (i = 0; i < SKILL_MAX; i++) {
  /* Remember what's allowed. */
  skbuysell[i] = 0;
  if (spent[i] > 0) {
   skbuysell[i] |= 1;
  }
  if (inc[i] <= remaining) {
   skbuysell[i] |= 2;
  }
  /* Display cost */
  put_str(format("%4d", spent[i]), 7 + i, (42 + 32));
  sum += spent[i];
 }
 put_str(format("Total Cost: %4d/%4d", sum, remaining + sum),
  7 + SKILL_MAX, (42 + 15));
}
static void skill_points_start(cmd_context context, bool reset)
{
 const char *prompt = "[up/down to move, left/right to modify, 'r' to reset, 'Enter' to accept]";
 int i;
 /* Clear */
 Term_clear();
 /* Display the player */
 display_player_xtra_info();
 display_player_stat_info();
 display_player_skill_info();
 prt(prompt, Term->hgt - 1, Term->wid / 2 - strlen(prompt) / 2);
 for (i = 0; i < SKILL_MAX; ++i) {
  skbuysell[i] = 0;
 }
 /* Register handlers for various events - cheat a bit because we redraw
	   the lot at once rather than each bit at a time. */
 event_add_handler(EVENT_SKILLPOINTS, skill_points, NULL);
 event_add_handler(EVENT_SKILLS, point_skills, NULL);
 event_add_handler(EVENT_EXP_CHANGE, sk_point_misc, NULL);
 init_skills(false, reset);
}
static void skill_points_stop(void)
{
 event_remove_handler(EVENT_SKILLPOINTS, skill_points, NULL);
 event_remove_handler(EVENT_SKILLS, point_skills, NULL);
 event_remove_handler(EVENT_EXP_CHANGE, sk_point_misc, NULL);
}
static int skill_points_command(void)
{
 enum {
  ACT_CTX_SKILL_PTS_NONE,
  ACT_CTX_SKILL_PTS_BUY,
  ACT_CTX_SKILL_PTS_SELL,
  ACT_CTX_SKILL_PTS_ESCAPE,
  ACT_CTX_SKILL_PTS_RESET,
  ACT_CTX_SKILL_PTS_ACCEPT,
  ACT_CTX_SKILL_PTS_QUIT
 };
 int action = ACT_CTX_SKILL_PTS_NONE;
 ui_event in;
 int next = 0;
 /* Place cursor just after cost of current skill */
 Term_gotoxy((42 + 32) + 4, 7 + skill_idx);
 /*
	 * Get input.  Emulate what inkey() does without coercing mouse events
	 * to look like keystrokes.
	 */
 while (1) {
  in = inkey_ex();
  if (in.type == EVT_KBRD || in.type == EVT_MOUSE) {
   break;
  }
  if (in.type == EVT_BUTTON) {
   in.type = EVT_KBRD;
  }
  if (in.type == EVT_ESCAPE) {
   in.type = EVT_KBRD;
   in.key.code = ESCAPE;
   in.key.mods = 0;
   break;
  }
 }
 /* Figure out what to do. */
 if (in.type == EVT_KBRD) {
  if (in.key.code == KTRL('X')) {
   action = ACT_CTX_SKILL_PTS_QUIT;
  } else if (in.key.code == ESCAPE) {
   action = ACT_CTX_SKILL_PTS_ESCAPE;
  } else if (in.key.code == 'r' || in.key.code == 'R') {
   action = ACT_CTX_SKILL_PTS_RESET;
  } else if (in.key.code == KC_ENTER) {
   action = ACT_CTX_SKILL_PTS_ACCEPT;
  } else {
   int dir;
   if (in.key.code == '-') {
    dir = 4;
   } else if (in.key.code == '+') {
    dir = 6;
   } else {
    dir = target_dir(in.key);
   }
   /*
			 * Go to previous skill.  Loop back to the last if at
			 * the first.
			 */
   if (dir == 8) {
    skill_idx = (skill_idx + SKILL_MAX - 1) % SKILL_MAX;
   }
   /*
			 * Go to next skill.  Loop back to the first if at the
			 * last.
			 */
   if (dir == 2) {
    skill_idx = (skill_idx + 1) % SKILL_MAX;
   }
   /* Decrease skill (if possible). */
   if (dir == 4) {
    action = ACT_CTX_SKILL_PTS_SELL;
   }
   /* Increase skill (if possible). */
   if (dir == 6) {
    action = ACT_CTX_SKILL_PTS_BUY;
   }
  }
 } else if (in.type == EVT_MOUSE) {
  assert(skill_idx >= 0 && skill_idx < SKILL_MAX);
  if (in.mouse.button == 2) {
   action = ACT_CTX_SKILL_PTS_ESCAPE;
  } else if (in.mouse.y >= 7
    && in.mouse.y < 7 + SKILL_MAX
    && in.mouse.y != 7 + skill_idx) {
   /*
			 * Make that skill the current one if buying or selling.
			 */
   skill_idx = in.mouse.y - 7;
  } else {
   /* Present a context menu with the other actions. */
   char *labels = string_make(lower_case);
   struct menu *m = menu_dynamic_new();
   m->selections = labels;
   if (in.mouse.y == 7 + skill_idx
     && (skbuysell[skill_idx] & 1)) {
    menu_dynamic_add_label(m, "Sell", 's',
     ACT_CTX_SKILL_PTS_SELL, labels);
   }
   if (in.mouse.y == 7 + skill_idx
     && (skbuysell[skill_idx] & 2)) {
    menu_dynamic_add_label(m, "Buy", 'b',
     ACT_CTX_SKILL_PTS_BUY, labels);
   }
   menu_dynamic_add_label(m, "Accept", 'a',
    ACT_CTX_SKILL_PTS_ACCEPT, labels);
   menu_dynamic_add_label(m, "Reset", 'r',
    ACT_CTX_SKILL_PTS_RESET, labels);
   menu_dynamic_add_label(m, "Quit", 'q',
    ACT_CTX_SKILL_PTS_QUIT, labels);
   screen_save();
   menu_dynamic_calc_location(m, in.mouse.x, in.mouse.y);
   region_erase_bordered(&m->boundary);
   action = menu_dynamic_select(m);
   menu_dynamic_free(m);
   string_free(labels);
   screen_load();
  }
 }
 /* Do it. */
 switch (action) {
 case ACT_CTX_SKILL_PTS_SELL:
  assert(skill_idx >= 0 && skill_idx < SKILL_MAX);
  cmdq_push(CMD_SELL_SKILL);
  cmd_set_arg_choice(cmdq_peek(), "choice", skill_idx);
  break;
 case ACT_CTX_SKILL_PTS_BUY:
  assert(skill_idx >= 0 && skill_idx < SKILL_MAX);
  cmdq_push(CMD_BUY_SKILL);
  cmd_set_arg_choice(cmdq_peek(), "choice", skill_idx);
  break;
 case ACT_CTX_SKILL_PTS_ESCAPE:
  /* Undo any changes made and then exit from skill buying. */
  cmdq_push(CMD_RESET_SKILLS);
  cmd_set_arg_choice(cmdq_peek(), "choice", false);
  next = -1;
  break;
 case ACT_CTX_SKILL_PTS_RESET:
  cmdq_push(CMD_RESET_SKILLS);
  cmd_set_arg_choice(cmdq_peek(), "choice", false);
  break;
 case ACT_CTX_SKILL_PTS_ACCEPT:
  /* Finalise that we are buying the skills as allocated. */
  next = 1;
  break;
 case ACT_CTX_SKILL_PTS_QUIT:
  if (character_dungeon) {
   next = -1;
  } else {
   quit(NULL);
  }
  break;
 default:
  /* Do nothing and remain at this stage. */
  break;
 }
 return next;
}
/**
 * Increase your skills by spending experience points
 */
int gain_skills(cmd_context context, bool reset)
{
 int next = 0;
 skill_points_start(context, reset);
 while (!next) {
  next = skill_points_command();
  cmdq_push(CMD_REFRESH_SKILLS);
  cmdq_execute(context);
 }
 skill_points_stop();
 if (context == CTX_GAME) {
  finalise_skills();
  player->upkeep->redraw |= (PR_EXP);
 }
 return next;
}
/**
 * \file ui-smith.c
 * \brief Text-based user interface for object smithing
 *
 * Copyright (c) 1987 - 2022 Angband contributors
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * ------------------------------------------------------------------------
 * The various "menu" bits of the smithing process - item type, item sub-type,
 * special type, artefact flags, artefact abilities, artefact, number
 * modification, melting.
 * ------------------------------------------------------------------------ */
/**
 * The smithed object
 */
static struct object smith_obj_body;
static struct object *smith_obj = &smith_obj_body;
static struct object smith_obj_known_body;
static struct object *smith_obj_known = &smith_obj_known_body;
/**
 * Backup of the smithed object.
 *
 * For most purposes we can and do use a local backup, but we need one external
 * to the include/exclude pval functions as including a 0 pval destroys
 * information about modifiers.
 */
static struct object smith_obj_body_backup;
static struct object *smith_obj_backup = &smith_obj_body_backup;
/**
 * The smithed artifact
 */
static struct artifact smith_art_body;
static struct artifact *smith_art = &smith_art_body;
static char smith_art_name[50];
/**
 * Current smithing cost
 */
static struct smithing_cost current_cost;
/**
 * Smithing menu data struct
 */
struct smithing_menu_data {
 struct object *obj;
};
static struct menu *smithing_menu;
static bool no_forge;
static bool exhausted;
static bool create_smithed_item;
static bool numbers_changed;
/**
 * Locations of the menus, etc. on the screen
 */
/**
 * Current special bonus value.
 * This is stored here, and only included in the necessary places in objects
 * when we're doing calculations that need it.
 */
static int pval = 0;
static bool pval_included = false;
static void include_pval(struct object *obj)
{
 if (!pval_included) {
  object_wipe(smith_obj_backup);
  object_copy(smith_obj_backup, smith_obj);
 }
 if (pval_valid(obj)) {
  int i;
  obj->pval = pval;
  for (i = 0; i < OBJ_MOD_MAX; i++) {
   if (obj->modifiers[i]) {
    obj->modifiers[i] = (obj->modifiers[i] < 0) ?
     -pval : pval;
    obj->known->modifiers[i] = obj->modifiers[i];
   }
  }
 }
 pval_included = true;
}
static void exclude_pval(struct object *obj)
{
 if (pval_included) {
  object_wipe(smith_obj);
  object_copy(smith_obj, smith_obj_backup);
 }
 pval_included = false;
}
static void wipe_smithing_objects(void)
{
 object_wipe(smith_obj);
 object_wipe(smith_obj_backup);
 mem_free(smith_art->slays);
 mem_free(smith_art->brands);
 release_ability_list(smith_art->abilities);
 memset(smith_art, 0, sizeof(*smith_art));
}
/**
 * Know the smithing object
 */
static void know_smith_obj(void)
{
 object_copy(smith_obj_known, smith_obj);
 smith_obj_known->known = NULL;
 smith_obj->known = smith_obj_known;
}
/**
 * Reset all the smithing objects
 */
static void reset_smithing_objects(struct object_kind *kind)
{
 object_wipe(smith_obj);
 object_wipe(smith_obj_backup);
 mem_free(smith_art->slays);
 mem_free(smith_art->brands);
 release_ability_list(smith_art->abilities);
 memset(smith_art, 0, sizeof(*smith_art));
 create_base_object(kind, smith_obj);
 know_smith_obj();
 object_copy(smith_obj_backup, smith_obj);
 pval = pval_valid(smith_obj) ? pval_default(smith_obj) : 0;
}
/**
 * Show smithing object data
 */
static void show_smith_obj(void)
{
 int effective_skill = player->state.skill_use[SKILL_SMITHING] +
  square_forge_bonus(cave, player->grid);
  //TODO allow for masterpiece, probably by adding effective_skill to data
 int dif;
 uint8_t attr;
 bool affordable = true;
 int costs = 0;
 char o_desc[80];
 int mode = ODESC_FULL | ODESC_CAPITAL | ODESC_SPOIL;
 textblock *tb;
 region bottom = { 16, MAX_SMITHING_TVALS + 3, 0, 0};
 region right = { 62, 2, 0, 0};
 const struct object_kind *kind = smith_obj->kind;
 /* Abort if there is no object to display */
 if (!kind) return;
 /* Evaluate difficulty */
 include_pval(smith_obj);
 dif = object_difficulty(smith_obj, &current_cost);
 attr = effective_skill < dif ? COLOUR_SLATE : COLOUR_L_DARK;
 exclude_pval(smith_obj);
 /* Redirect output to the screen */
 text_out_hook = text_out_to_screen;
 text_out_wrap = 80;
 /* Object difficulty */
 text_out_indent = 62;
 region_erase(&bottom);
 region_erase(&right);
 Term_gotoxy(62, 2);
 text_out_c(attr, "Difficulty:\n\n");
 if (current_cost.drain) {
  attr = COLOUR_BLUE;
 }
 text_out_c(attr, "%3d", dif);
 text_out_c(COLOUR_L_DARK, "  (max %d)", effective_skill);
 /* Object costs */
 Term_gotoxy(62, 8);
 if (affordable) {
  attr = COLOUR_SLATE;
 } else {
  attr = COLOUR_L_DARK;
 }
 text_out_c(attr, "Cost:");
 Term_gotoxy(62 + 2, 10);
 if (current_cost.weaponsmith) {
  text_out_c(COLOUR_RED, "Weaponsmith\n");
  costs++;
  Term_gotoxy(62 + 2, 10 + costs);
 }
 if (current_cost.armoursmith) {
  text_out_c(COLOUR_RED, "Armoursmith\n");
  costs++;
  Term_gotoxy(62 + 2, 10 + costs);
 }
 if (current_cost.jeweller) {
  text_out_c(COLOUR_RED, "Jeweller\n");
  costs++;
  Term_gotoxy(62 + 2, 10 + costs);
 }
 if (current_cost.enchantment) {
  text_out_c(COLOUR_RED, "Enchantment\n");
  costs++;
  Term_gotoxy(62 + 2, 10 + costs);
 }
 if (current_cost.artistry) {
  text_out_c(COLOUR_RED, "Artistry\n");
  costs++;
  Term_gotoxy(62 + 2, 10 + costs);
 }
 if (current_cost.artifice) {
  text_out_c(COLOUR_RED, "Artifice\n");
  costs++;
  Term_gotoxy(62 + 2, 10 + costs);
 }
 if (current_cost.uses > 0) {
  if (square_forge_uses(cave, player->grid) >= current_cost.uses) {
   attr = COLOUR_SLATE;
  } else {
   affordable = false;
   attr = COLOUR_L_DARK;
  }
  if (current_cost.uses == 1) {
   text_out_c(attr, "1 Use");
  } else {
   text_out_c(attr, "%d Uses", current_cost.uses);
  }
  text_out_c(COLOUR_L_DARK, " (of %d)",
       square_forge_uses(cave, player->grid));
  costs++;
  Term_gotoxy(62 + 2, 10 + costs);
 }
 if (current_cost.drain > 0) {
  if (current_cost.drain <= player->skill_base[SKILL_SMITHING]) {
   attr = COLOUR_BLUE;
  } else {
   attr = COLOUR_L_DARK;
   affordable = false;
  }
  text_out_c(attr, "%d Smithing", current_cost.drain);
  costs++;
  Term_gotoxy(62 + 2, 10 + costs);
 }
 if (current_cost.mithril > 0) {
  if (current_cost.mithril <= mithril_carried(player)) {
   attr = COLOUR_SLATE;
  } else {
   attr = COLOUR_L_DARK;
   affordable = false;
  }
  text_out_c(attr, "%d.%d lb Mithril", current_cost.mithril / 10,
       current_cost.mithril % 10);
  costs++;
  Term_gotoxy(62 + 2, 10 + costs);
 }
 if (current_cost.stat[STAT_STR] > 0) {
  if (player->stat_base[STAT_STR] + player->stat_drain[STAT_STR]
   - current_cost.stat[STAT_STR] >= -5) {
   attr = COLOUR_SLATE;
  } else {
   attr = COLOUR_L_DARK;
   affordable = false;
  }
  text_out_c(attr, "%d Str", current_cost.stat[STAT_STR]);
  costs++;
  Term_gotoxy(62 + 2, 10 + costs);
 }
 if (current_cost.stat[STAT_DEX] > 0) {
  if (player->stat_base[STAT_DEX] + player->stat_drain[STAT_DEX]
   - current_cost.stat[STAT_DEX] >= -5) {
   attr = COLOUR_SLATE;
  } else {
   attr = COLOUR_L_DARK;
   affordable = false;
  }
  text_out_c(attr, "%d Dex", current_cost.stat[STAT_DEX]);
  costs++;
  Term_gotoxy(62 + 2, 10 + costs);
 }
 if (current_cost.stat[STAT_CON] > 0) {
  if (player->stat_base[STAT_CON] + player->stat_drain[STAT_CON]
   - current_cost.stat[STAT_CON] >= -5) {
   attr = COLOUR_SLATE;
  } else {
   attr = COLOUR_L_DARK;
   affordable = false;
  }
  text_out_c(attr, "%d Con", current_cost.stat[STAT_CON]);
  costs++;
  Term_gotoxy(62 + 2, 10 + costs);
 }
 if (current_cost.stat[STAT_GRA] > 0) {
  if (player->stat_base[STAT_GRA] + player->stat_drain[STAT_GRA]
   - current_cost.stat[STAT_GRA] >= -5) {
   attr = COLOUR_SLATE;
  } else {
   attr = COLOUR_L_DARK;
   affordable = false;
  }
  text_out_c(attr, "%d Gra", current_cost.stat[STAT_GRA]);
  costs++;
  Term_gotoxy(62 + 2, 10 + costs);
 }
 if (current_cost.exp > 0) {
  if (player->new_exp >= current_cost.exp) {
   attr = COLOUR_SLATE;
  } else {
   attr = COLOUR_L_DARK;
   affordable = false;
  }
  text_out_c(attr, "%d Exp", current_cost.exp);
  costs++;
  Term_gotoxy(62 + 2, 10 + costs);
 }
 attr = COLOUR_SLATE;
 text_out_c(attr, "%d Turns", MAX(10, dif * 10));
 /* Object description */
 clear_from(MAX_SMITHING_TVALS + 3);
 if (player->smithing_leftover) {
  Term_gotoxy(2, MAX_SMITHING_TVALS + 3);
  text_out_c(COLOUR_L_BLUE, "In progress:");
  Term_gotoxy(2 - 1, MAX_SMITHING_TVALS + 5);
  text_out_c(COLOUR_BLUE, "%3d turns left", player->smithing_leftover);
 }
 if (smith_obj->number > 1) {
  mode |= ODESC_PREFIX;
 }
 include_pval(smith_obj);
 know_smith_obj();
 object_desc(o_desc, sizeof(o_desc), smith_obj, mode, player);
 my_strcat(o_desc, format("   %d.%d lb",
        smith_obj->weight * smith_obj->number / 10,
        (smith_obj->weight * smith_obj->number) % 10),
     sizeof(o_desc));
 tb = object_info(smith_obj, OINFO_SMITH);
 exclude_pval(smith_obj);
 textui_textblock_place(tb, bottom, o_desc);
 textblock_free(tb);
 /* Reset indent/wrap */
 text_out_indent = 0;
 text_out_wrap = 0;
}
/**
 * Show smithing object data
 */
static void smith_obj_browser(int oid, void *data, const region *loc)
{
 show_smith_obj();
}
/**
 * ------------------------------------------------------------------------
 * Base items menu
 * ------------------------------------------------------------------------ */
static struct object_kind *smithing_svals[20];
static int get_smithing_svals(int tval)
{
 int i, count = 0;
 for (i = 0; i < z_info->k_max; i++) {
  struct object_kind *kind = &k_info[i];
  if (kind->tval != tval) continue;
  if (kf_has(kind->kind_flags, KF_INSTA_ART)) continue;
  if (of_has(kind->flags, OF_NO_SMITHING)) continue;
  smithing_svals[count++] = kind;
 }
 return count;
}
/**
 * Display the subtypes.
 */
static void sval_display(struct menu *menu, int oid, bool cursor, int row,
          int col, int width)
{
 char name[40];
 struct object_kind **choice = (struct object_kind **) menu->menu_data;
 uint8_t attr = (cursor ? COLOUR_L_BLUE : COLOUR_WHITE);
 struct object object_body, object_known_body;
 struct object *obj = &object_body, *known_obj = &object_known_body;
 struct smithing_cost local_cost;
 struct smithing_cost *cost = &local_cost;
 if (cursor) {
  obj = smith_obj;
  known_obj = smith_obj_known;
  cost = &current_cost;
 }
 create_base_object(choice[oid], obj);
 object_copy(known_obj, obj);
 known_obj->known = NULL;
 obj->known = known_obj;
 if (cursor) {
  object_wipe(smith_obj_backup);
  object_copy(smith_obj_backup, smith_obj);
 }
 include_pval(obj);
 (void)object_difficulty(obj, cost);
 attr = smith_affordable(obj, cost) ? COLOUR_WHITE : COLOUR_SLATE;
 if (cursor) {
  know_smith_obj();
  show_smith_obj();
 }
 exclude_pval(obj);
 object_kind_name(name, sizeof(name), choice[oid], true);
 c_put_str(attr, name, row, col);
}
/**
 * Handle keypresses.
 */
static bool sval_action(struct menu *m, const ui_event *event, int oid)
{
 return (event->type == EVT_SELECT) ? false : true;
}
/**
 * Display an entry in the menu.
 */
static void tval_display(struct menu *menu, int oid, bool cursor, int row,
       int col, int width)
{
 const char *name = smithing_tvals[oid].desc;
 uint8_t attr = COLOUR_RED;
 if (((smithing_tvals[oid].category == SMITH_TYPE_WEAPON) &&
   player_active_ability(player, "Weaponsmith")) ||
  ((smithing_tvals[oid].category == SMITH_TYPE_JEWELRY) &&
   player_active_ability(player, "Jeweller")) ||
  ((smithing_tvals[oid].category == SMITH_TYPE_ARMOUR) &&
   player_active_ability(player, "Armoursmith"))) {
  attr = COLOUR_WHITE;
 }
 c_put_str(attr, name, row, col);
}
/**
 * Handle keypresses.
 */
static bool tval_action(struct menu *m, const ui_event *event, int oid)
{
 struct menu menu;
 menu_iter menu_f = { NULL, NULL, sval_display, sval_action, NULL };
 region area = { 34, 2, 62 - 34, MAX_SMITHING_TVALS };
 ui_event evt;
 int count = 0;
 bool selected = false;
 /* Save */
 screen_save();
 /* Work out how many options we have */
 count = get_smithing_svals(smithing_tvals[oid].tval);
 /* Run menu */
 menu_init(&menu, MN_SKIN_SCROLL, &menu_f);
 menu.selections = lower_case;
 menu.flags = MN_CASELESS_TAGS;
 menu.browse_hook = smith_obj_browser;
 menu_setpriv(&menu, count, smithing_svals);
 menu_layout(&menu, &area);
 evt = menu_select(&menu, 0, true);
 /* Set the new value appropriately */
 if (evt.type == EVT_SELECT) {
  smith_obj->kind = smithing_svals[menu.cursor];
  pval = pval_valid(smith_obj) ? pval_default(smith_obj) : 0;
  selected = true;
 }
 menu_refresh(smithing_menu, false);
 /* Load and finish */
 screen_load();
 return !selected;
}
/**
 * Display tval menu.
 */
static void tval_menu(const char *name, int row)
{
 struct menu menu;
 menu_iter menu_f = { NULL, NULL, tval_display, tval_action, NULL };
 ui_event evt = EVENT_EMPTY;
 region area = { 16, 2, 34 - 16, MAX_SMITHING_TVALS };
 region big = { 16, 2, 0, 0 };
 /* Reset everything */
 wipe_smithing_objects();
 pval = 0;
 /* Set up the menu */
 menu_init(&menu, MN_SKIN_SCROLL, &menu_f);
 menu.selections = lower_case;
 menu.flags = MN_CASELESS_TAGS;
 menu.browse_hook = smith_obj_browser;
 menu_setpriv(&menu, MAX_SMITHING_TVALS, (void *)smithing_tvals);
 region_erase(&big);
 numbers_changed = false;
 menu_layout(&menu, &area);
 /* Select an entry */
 while (evt.type != EVT_ESCAPE) {
  evt = menu_select(&menu, 0, false);
  if ((evt.type == EVT_SELECT) && smith_obj->kind)
   break;
 }
 return;
}
/**
 * ------------------------------------------------------------------------
 * Special items menu
 * ------------------------------------------------------------------------ */
struct ego_item **smithing_specials;
bool *affordable_specials;
static int get_smithing_specials(struct object_kind *kind)
{
 int i, count = 0, pval_old = pval;
 struct object dummy_body, dummy_body_known;
 struct smithing_cost dummy_cost;
 if (!kind) return 0;
 for (i = 0; i < z_info->e_max; i++) {
  struct ego_item *ego = &e_info[i];
  struct poss_item *poss;
  for (poss = ego->poss_items; poss; poss = poss->next) {
   if (kind->kidx == poss->kidx) break;
  }
  if (!poss) continue;
  smithing_specials[count] = ego;
  object_copy(&dummy_body, smith_obj);
  create_special(&dummy_body, ego);
  object_copy(&dummy_body_known, &dummy_body);
  dummy_body_known.known = NULL;
  dummy_body.known = &dummy_body_known;
  pval = pval_valid(&dummy_body) ? pval_default(&dummy_body) : 0;
  include_pval(&dummy_body);
  (void)object_difficulty(&dummy_body, &dummy_cost);
  affordable_specials[count] = smith_affordable(&dummy_body,
   &dummy_cost);
  exclude_pval(&dummy_body);
  object_wipe(&dummy_body_known);
  object_wipe(&dummy_body);
  ++count;
 }
 pval = pval_old;
 return count;
}
/**
 * Display an entry in the menu.
 */
static void special_display(struct menu *menu, int oid, bool cursor, int row,
       int col, int width)
{
 struct ego_item **choice = (struct ego_item **) menu->menu_data;
 uint8_t attr = affordable_specials[oid] ? COLOUR_WHITE : COLOUR_SLATE;
 if (cursor) {
  create_special(smith_obj, choice[oid]);
  know_smith_obj();
  pval = pval_valid(smith_obj) ? smith_obj->pval : 0;
  include_pval(smith_obj);
  show_smith_obj();
  exclude_pval(smith_obj);
 }
 c_put_str(attr, strip_ego_name(choice[oid]->name), row, col);
}
/**
 * Handle keypresses.
 */
static bool special_action(struct menu *m, const ui_event *event, int oid)
{
 return (event->type == EVT_SELECT) ? false : true;
}
/**
 * Display special item menu.
 */
static void special_menu(const char *name, int row)
{
 struct object_kind *kind = smith_obj->kind;
 struct menu menu;
 menu_iter menu_f = { NULL, NULL, special_display, special_action, NULL };
 int count;
 region area = { 16, 2, 62 - 16, MAX_SMITHING_TVALS };
 ui_event evt;
 /* Remove any artefact info */
 if (smith_obj->artifact) reset_smithing_objects(kind);
 /* Set up the menu */
 menu_init(&menu, MN_SKIN_SCROLL, &menu_f);
 smithing_specials = mem_zalloc(z_info->e_max * sizeof(smithing_specials));
 affordable_specials = mem_zalloc(z_info->e_max * sizeof(affordable_specials));
 count = get_smithing_specials(smith_obj->kind);
 if (!count) {
  mem_free(affordable_specials);
  mem_free(smithing_specials);
  return;
 }
 menu.selections = lower_case;
 menu.flags = MN_CASELESS_TAGS;
 menu_setpriv(&menu, count, smithing_specials);
 menu_layout(&menu, &area);
 /* Select an entry */
 evt = menu_select(&menu, 0, false);
 /* Set the new value appropriately */
 if (evt.type == EVT_SELECT)
  smith_obj->ego = smithing_specials[menu.cursor];
 menu_refresh(&menu, false);
 mem_free(affordable_specials);
 mem_free(smithing_specials);
 return;
}
/**
 * ------------------------------------------------------------------------
 * Artefact menu
 * ------------------------------------------------------------------------ */
static const char *smithing_art_cats[] =
{
 "Stat bonuses",
 "Sustains",
 "Skill bonuses",
 "Melee powers",
 "Slays",
 "Resistances",
 "Curses",
 "Misc",
/**
 * \file src/list-skills.h
 * \brief player skills
 *
 * Changing skill order or making new ones will break savefiles. Skills
 * below start from 0 on line 11, so a skill's sequence number is its line
 * number minus 11.
 *
 * Skill properties are not defined in lib/gamedata/object_property.txt
 */
"Melee",
"Archery",
"Evasion",
"Stealth",
"Perception",
"Will",
"Smithing",
"Song",

 "Name Artefact"
};
static int *smithing_art_cat_counts = NULL;
struct property_info {
 struct obj_property *prop;
 bool negative;
};
static struct property_info *smith_art_properties;
static struct ability **smith_art_abilities;
static bool negative;
static int get_smith_properties(enum smithing_category cat)
{
 int i, count = 0;
 for (i = 0; i < z_info->property_max; i++) {
  struct obj_property *prop = &obj_properties[i];
  if (prop->smith_cat != (int) cat) continue;
  if (!applicable_property(prop, smith_obj)) continue;
  negative = false;
  smith_art_properties[count].prop = prop;
  smith_art_properties[count++].negative = false;
  if (cat == SMITH_CAT_STAT) {
   smith_art_properties[count].prop = prop;
   smith_art_properties[count++].negative = true;
  }
 }
 return count;
}
static int get_smith_art_abilities(int skill)
{
 struct ability *a;
 int count = 0;
 for (a = abilities; a; a = a->next) {
  struct poss_item *poss = a->poss_items;
  if (a->skill != skill) continue;
  while (poss) {
   if (poss->kidx == smith_obj->kind->kidx) break;
   poss = poss->next;
  }
  if (!poss) continue;
  smith_art_abilities[count++] = a;
 }
 return count;
}
/**
 * Allows the player to choose a new name for an artefact.
 */
static void rename_artefact(void)
{
 char tmp[20];
 char o_desc[30];
 bool name_selected = false;
 /* Clear the name */
 tmp[0] = '\0';
 /* Use old name as a default */
 my_strcpy(tmp, smith_art->name, sizeof(tmp));
 my_strcpy(smith_art_name, "", sizeof(smith_art_name));
 /* Determine object name */
 object_desc(o_desc, sizeof(o_desc), smith_obj, ODESC_BASE, player);
 /* Display shortened object name */
 Term_putstr(16, MAX_SMITHING_TVALS + 3, -1, COLOUR_L_WHITE, o_desc);
 /* Prompt for a new name */
 Term_gotoxy(16 + strlen(o_desc), MAX_SMITHING_TVALS + 3);
 while (!name_selected) {
  if (askfor_aux(tmp, sizeof(tmp), NULL)) {
   my_strcpy(smith_art->name, tmp, 30);
   player->upkeep->redraw |= (PR_MISC);
  } else {
   strnfmt(smith_art_name, sizeof(smith_art_name), "of %s",
    player->full_name);
   return;
  }
  if (tmp[0] != '\0') {
   name_selected = true;
  } else {
   strnfmt(smith_art_name, sizeof(smith_art_name), "of %s",
    player->full_name);
  }
 }
}
/**
 * Display an entry in the menu.
 */
static void ui_skill_display(struct menu *menu, int oid, bool cursor, int row,
       int col, int width)
{
 struct ability **choice = menu->menu_data;
 bool chosen = !!locate_ability(smith_obj->abilities, choice[oid]);
 uint8_t attr = chosen ? COLOUR_BLUE : COLOUR_SLATE;
 struct object backup;
 if (!applicable_ability(choice[oid], smith_obj)) {
  attr = COLOUR_L_DARK;
 } else {
  include_pval(smith_obj);
  object_copy(&backup, smith_obj);
  if (!chosen) {
   add_ability(&smith_obj->abilities, choice[oid]);
   if (smith_affordable(smith_obj, &current_cost) && cursor) {
    attr = COLOUR_BLUE;
   }
  }
  if (!chosen) {
   remove_ability(&smith_obj->abilities, choice[oid]);
  }
  object_wipe(smith_obj);
  object_copy(smith_obj, &backup);
  (void) smith_affordable(smith_obj, &current_cost);
  exclude_pval(smith_obj);
 }
 c_put_str(attr, choice[oid]->name, row, col);
}
/**
 * Handle keypresses.
 */
static bool ui_skill_action(struct menu *m, const ui_event *event, int oid)
{
 struct ability **choice = m->menu_data;
 if (event->type == EVT_SELECT) {
  if (!applicable_ability(choice[oid], smith_obj)) return false;
  if (!locate_ability(smith_obj->abilities, choice[oid])) {
   add_ability(&smith_obj->abilities, choice[oid]);
  } else {
   remove_ability(&smith_obj->abilities, choice[oid]);
  }
  return true;
 }
 return false;
}
/**
 * Display an entry in the menu.
 */
static void prop_display(struct menu *menu, int oid, bool cursor, int row,
       int col, int width)
{
 struct property_info *choice = menu->menu_data;
 bool chosen = object_has_property(choice[oid].prop, smith_obj, false);
 uint8_t attr;
 char *name;
 if (choice[oid].prop->smith_cat == SMITH_CAT_STAT) {
  if (choice[oid].negative) {
   chosen = object_has_property(choice[oid].prop, smith_obj, true);
   name = format("%s penalty", choice[oid].prop->name);
  } else {
   name = format("%s bonus", choice[oid].prop->name);
  }
 } else {
  name = choice[oid].prop->name;
 }
 attr = chosen ? COLOUR_BLUE : COLOUR_SLATE;
 c_put_str(attr, name, row, col);
}
/**
 * Handle keypresses.
 */
static bool prop_action(struct menu *m, const ui_event *event, int oid)
{
 struct property_info *choice = m->menu_data;
 if (event->type == EVT_SELECT) {
  if (!object_has_property(choice[oid].prop, smith_obj,
         choice[oid].negative)) {
   add_object_property(choice[oid].prop, smith_obj,
          choice[oid].negative);
  } else {
   remove_object_property(choice[oid].prop, smith_obj);
  }
  return true;
 }
 return false;
}
/**
 * Display an entry in the menu.
 */
static void artefact_display(struct menu *menu, int oid, bool cursor, int row,
       int col, int width)
{
 char **choice = menu->menu_data;
 uint8_t attr;
 assert(oid >= 0 && oid < SMITH_CAT_MAX + SKILL_MAX + 1
  && smithing_art_cat_counts);
 attr = smithing_art_cat_counts[oid] > 0 ?
  (cursor ? COLOUR_L_BLUE : COLOUR_WHITE) : COLOUR_L_DARK;
 if (cursor) {
  know_smith_obj();
  include_pval(smith_obj);
  show_smith_obj();
  exclude_pval(smith_obj);
 }
 c_put_str(attr, choice[oid], row, col);
}
/**
 * Display artefact menu.
 */
static bool artefact_action(struct menu *m, const ui_event *event, int oid)
{
 struct menu menu;
 region area = { 34, 2, 62 - 34, MAX_SMITHING_TVALS };
 int count;
 if (event->type == EVT_SELECT) {
  /* Get the different data types and run the appropriate menu */
  if (oid < SMITH_CAT_MAX) {
   menu_iter menu_f = { NULL, NULL, prop_display, prop_action, NULL };
   menu_init(&menu, MN_SKIN_SCROLL, &menu_f);
   smith_art_properties = mem_zalloc(z_info->property_max
    * sizeof(struct property_info));
   count = get_smith_properties(oid);
   if (!count) {
    mem_free(smith_art_properties);
    smith_art_properties = NULL;
    return true;
   }
   menu.selections = lower_case;
   menu.flags = MN_CASELESS_TAGS;
   menu_setpriv(&menu, count, smith_art_properties);
   menu_layout(&menu, &area);
   menu_select(&menu, 0, true);
   mem_free(smith_art_properties);
   smith_art_properties = NULL;
  } else if (oid < SMITH_CAT_MAX + SKILL_MAX) {
   menu_iter menu_f = { NULL, NULL, ui_skill_display, ui_skill_action, NULL};
   menu_init(&menu, MN_SKIN_SCROLL, &menu_f);
   smith_art_abilities =
    mem_zalloc(100 * sizeof(struct ability*));
   count = get_smith_art_abilities(oid - SMITH_CAT_MAX);
   if (!count) {
    mem_free(smith_art_abilities);
    smith_art_abilities = NULL;
    return true;
   }
   menu.flags = MN_CASELESS_TAGS;
   menu.selections = lower_case;
   menu_setpriv(&menu, count, smith_art_abilities);
   menu_layout(&menu, &area);
   menu_select(&menu, 0, true);
   mem_free(smith_art_abilities);
   smith_art_abilities = NULL;
  } else {
   rename_artefact();
  }
 }
 return true;
}
/**
 * Display artefact menu.
 */
static void artefact_menu(const char *name, int row)
{
 struct object_kind *kind;
 struct menu menu;
 menu_iter menu_f = { NULL, NULL, artefact_display, artefact_action, NULL };
 region area = { 16, 2, 62 - 16, MAX_SMITHING_TVALS };
 int i;
 if (!smith_obj->kind) return;
 /*
	 * Some types of objects use a special base for all smithed artefacts.
	 * All others use the base item already selected.
	 */
 kind = lookup_selfmade_kind(smith_obj->kind->tval);
 if (!kind) {
  kind = smith_obj->kind;
 }
 /* Mark as an artefact, remove any special item info */
 if (smith_obj->ego || kind != smith_obj->kind) {
  reset_smithing_objects(kind);
 }
 smith_obj->artifact = smith_art;
 strnfmt(smith_art_name, sizeof(smith_art_name), "of %s",
  player->full_name);
 smith_art->name = smith_art_name;
 /*
	 * So the category entries can be colored appropriately, remember
	 * what categories have applicable entries for this type of object.
	 */
 smithing_art_cat_counts = mem_alloc((SMITH_CAT_MAX + SKILL_MAX + 1)
  * sizeof(smithing_art_cat_counts));
 for (i = 0; i < SMITH_CAT_MAX; ++i) {
  smith_art_properties = mem_zalloc(z_info->property_max
   * sizeof(*smith_art_properties));
  smithing_art_cat_counts[i] = get_smith_properties(i);
  mem_free(smith_art_properties);
  smith_art_properties = NULL;
 }
 for (i = SMITH_CAT_MAX; i < SMITH_CAT_MAX + SKILL_MAX; ++i) {
  smith_art_abilities =
   mem_zalloc(100 * sizeof(*smith_art_abilities));
  smithing_art_cat_counts[i] =
   get_smith_art_abilities(i - SMITH_CAT_MAX);
  mem_free(smith_art_abilities);
  smith_art_abilities = NULL;
 }
 /* Renaming is always possible. */
 smithing_art_cat_counts[SMITH_CAT_MAX + SKILL_MAX] = 1;
 /* Set up the menu */
 menu_init(&menu, MN_SKIN_SCROLL, &menu_f);
 menu.selections = lower_case;
 menu.flags = MN_CASELESS_TAGS;
 menu.browse_hook = smith_obj_browser;
 menu_setpriv(&menu, SMITH_CAT_MAX + SKILL_MAX + 1, smithing_art_cats);
 menu_layout(&menu, &area);
 /* Select an entry */
 menu_select(&menu, 0, false);
 mem_free(smithing_art_cat_counts);
 smithing_art_cat_counts = NULL;
}
/**
 * ------------------------------------------------------------------------
 * Mithril menu
 * ------------------------------------------------------------------------ */
/**
 * Display an entry in the menu.
 */
static void melt_display(struct menu *menu, int oid, bool cursor, int row,
       int col, int width)
{
 struct object **choice = menu->menu_data;
 char o_name[80];
 uint8_t attr = (cursor ? COLOUR_L_BLUE : COLOUR_WHITE);
 object_desc(o_name, sizeof(o_name), choice[oid], ODESC_PREFIX | ODESC_FULL,
    player);
 c_put_str(attr, o_name, row, col);
}
/**
 * Handle keypresses.
 */
static bool melt_action(struct menu *m, const ui_event *event, int oid)
{
 struct object **choice = m->menu_data;
 if (event->type == EVT_SELECT) {
  melt_mithril_item(player, choice[oid]);
 }
 return false;
}
/**
 * Display mithril melting menu.
 */
static void melt_menu(const char *name, int row)
{
 struct menu menu;
 menu_iter menu_f = { NULL, NULL, melt_display, melt_action, NULL };
 int count = 0;
 region area = { 16, 2, 0, 0 };
 struct object *obj;
 struct object **melt_menu_info = NULL;
 /* Fill the melt menu */
 for (obj = player->gear; obj; obj = obj->next) {
  if (object_is_mithril(obj)) {
   melt_menu_info = mem_realloc(melt_menu_info,
    (count + 1) * sizeof(struct object*));
   melt_menu_info[count++] = obj;
  }
 }
 /* Set up the menu */
 if (!count) return;
 menu_init(&menu, MN_SKIN_SCROLL, &menu_f);
 menu.selections = lower_case;
 menu.flags = MN_CASELESS_TAGS;
 menu.browse_hook = smith_obj_browser;
 menu_setpriv(&menu, count, melt_menu_info);
 menu_layout(&menu, &area);
 /* Select an entry */
 menu_select(&menu, 0, false);
 mem_free(melt_menu_info);
 return;
}
/**
 * ------------------------------------------------------------------------
 * Numbers menu
 * ------------------------------------------------------------------------ */
struct numbers_menu_entry {
 enum smithing_numbers_mod_index index;
 const char *name;
};
struct numbers_menu_entry numbers_menu_info[SMITH_NUM_MAX] =
{
 { SMITH_NUM_INC_ATT, "increase attack bonus" },
 { SMITH_NUM_DEC_ATT, "decrease attack bonus" },
 { SMITH_NUM_INC_DS, "increase damage sides" },
 { SMITH_NUM_DEC_DS, "decrease damage sides" },
 { SMITH_NUM_INC_EVN, "increase evasion bonus" },
 { SMITH_NUM_DEC_EVN, "decrease evasion bonus" },
 { SMITH_NUM_INC_PS, "increase protection sides" },
 { SMITH_NUM_DEC_PS, "decrease protection sides" },
 { SMITH_NUM_INC_PVAL, "increase special bonus" },
 { SMITH_NUM_DEC_PVAL, "decrease special bonus" },
 { SMITH_NUM_INC_WGT, "increase weight" },
 { SMITH_NUM_DEC_WGT, "decrease weight" }
};
/**
 * Validity and affordability for numbers changes
 * Note that numbers_can_afford[] and numbers_need_artistry[] should only be
 * used when numbers_valid[] is true
 */
bool numbers_valid[SMITH_NUM_MAX];
bool numbers_can_afford[SMITH_NUM_MAX] = { false };
bool numbers_needs_artistry[SMITH_NUM_MAX] = { false };
/**
 * Set validity status for each of the numbers changes
 */
static void numbers_set_validity(void)
{
 struct object backup;
 int old_pval = pval;
 int i;
 /* Attack */
 numbers_valid[SMITH_NUM_INC_ATT] = att_valid(smith_obj) &&
  (smith_obj->att < att_max(smith_obj, true));
 numbers_needs_artistry[SMITH_NUM_INC_ATT] = att_valid(smith_obj) &&
  !(smith_obj->att < att_max(smith_obj, false));
 numbers_valid[SMITH_NUM_DEC_ATT] = att_valid(smith_obj) &&
  (smith_obj->att > att_min(smith_obj));
 /* Damage sides */
 numbers_valid[SMITH_NUM_INC_DS] = ds_valid(smith_obj) &&
  (smith_obj->ds < ds_max(smith_obj, true));
 numbers_needs_artistry[SMITH_NUM_INC_DS] = ds_valid(smith_obj) &&
  !(smith_obj->ds < ds_max(smith_obj, false));
 numbers_valid[SMITH_NUM_DEC_DS] = ds_valid(smith_obj) &&
  (smith_obj->ds > ds_min(smith_obj));
 /* Evasion */
 numbers_valid[SMITH_NUM_INC_EVN] = evn_valid(smith_obj) &&
  (smith_obj->evn < evn_max(smith_obj, true));
 numbers_needs_artistry[SMITH_NUM_INC_EVN] = evn_valid(smith_obj) &&
  !(smith_obj->evn < evn_max(smith_obj, false));
 numbers_valid[SMITH_NUM_DEC_EVN] = evn_valid(smith_obj) &&
  (smith_obj->evn > evn_min(smith_obj));
 /* Protection sides */
 numbers_valid[SMITH_NUM_INC_PS] = ps_valid(smith_obj) &&
  (smith_obj->ps < ps_max(smith_obj, true));
 numbers_needs_artistry[SMITH_NUM_INC_PS] = ps_valid(smith_obj) &&
  !(smith_obj->ps < ps_max(smith_obj, false));
 numbers_valid[SMITH_NUM_DEC_PS] = ps_valid(smith_obj) &&
  (smith_obj->ps > ps_min(smith_obj));
 /* Special bonus */
 numbers_valid[SMITH_NUM_INC_PVAL] = pval_valid(smith_obj) &&
  (pval < pval_max(smith_obj));
 numbers_valid[SMITH_NUM_DEC_PVAL] = pval_valid(smith_obj) &&
  (pval > pval_min(smith_obj));
 /* Weight */
 numbers_valid[SMITH_NUM_INC_WGT] = wgt_valid(smith_obj) &&
  (smith_obj->weight < wgt_max(smith_obj));
 numbers_valid[SMITH_NUM_DEC_WGT] = wgt_valid(smith_obj) &&
  (smith_obj->weight > wgt_min(smith_obj));
 /* Affordability */
 for (i = 0; i < SMITH_NUM_MAX; i++) {
  if (numbers_valid[i]) {
   /* Back up the object */
   object_copy(&backup, smith_obj);
   /* See if we can afford the change */
   modify_numbers(smith_obj, i, &pval);
   include_pval(smith_obj);
   numbers_can_afford[i] = smith_affordable(smith_obj, &current_cost);
   /* Restore the object */
   pval = old_pval;
   exclude_pval(smith_obj);
   object_wipe(smith_obj);
   object_copy(smith_obj, &backup);
  }
 }
}
/**
 * Display an entry in the menu.
 */
static void numbers_display(struct menu *menu, int oid, bool cursor, int row,
       int col, int width)
{
 struct numbers_menu_entry *choice = menu->menu_data;
 uint8_t attr = numbers_valid[oid] ? COLOUR_SLATE : COLOUR_L_DARK;
 if (numbers_valid[oid] && numbers_can_afford[oid]) attr = COLOUR_WHITE;
 if (numbers_valid[oid] && numbers_needs_artistry[oid]) attr = COLOUR_RED;
 show_smith_obj();
 c_put_str(attr, choice[oid].name, row, col);
}
/**
 * Handle keypresses.
 */
static bool numbers_action(struct menu *m, const ui_event *event, int oid)
{
 if (event->type == EVT_SELECT) {
  if (numbers_valid[oid]) {
   modify_numbers(smith_obj, oid, &pval);
   numbers_changed = true;
   /* Update whan can be changed. */
   numbers_set_validity();
   menu_refresh(m, false);
  }
 }
 return false;
}
/**
 * Display numbers menu.
 */
static void numbers_menu(const char *name, int row)
{
 struct menu menu;
 menu_iter menu_f = { NULL, NULL, numbers_display, numbers_action, NULL };
 ui_event evt = EVENT_EMPTY;
 region area = { 16, 2, 34 - 16, MAX_SMITHING_TVALS };
 region old = { 16, 2, 62 - 16,
     MAX_SMITHING_TVALS };
 if (!smith_obj->kind) return;
 /* Set validity status */
 numbers_set_validity();
 /* Set up the menu */
 region_erase(&old);
 menu_init(&menu, MN_SKIN_SCROLL, &menu_f);
 menu.selections = lower_case;
 menu.flags = MN_CASELESS_TAGS;
 menu_setpriv(&menu, SMITH_NUM_MAX, numbers_menu_info);
 menu_layout(&menu, &area);
 /* Select an entry */
 while (evt.type != EVT_ESCAPE) {
  evt = menu_select(&menu, 0, false);
 }
 return;
}
static void accept_item(const char *name, int row)
{
 include_pval(smith_obj);
 if (!smith_affordable(smith_obj, &current_cost) ||
  !square_isforge(cave, player->grid) ||
  !square_forge_uses(cave, player->grid)) {
  exclude_pval(smith_obj);
  return;
 }
 exclude_pval(smith_obj);
 if (current_cost.drain > 0) {
  char buf[80];
  strnfmt(buf, sizeof(buf), "This will drain your smithing "
   "skill by %d points. Proceed? ", current_cost.drain);
  if (!get_check(buf)) return;
 }
 create_smithed_item = true;
 /* Add the details to the artefact type if applicable */
 include_pval(smith_obj);
 if (smith_obj->artifact) add_artefact_details(smith_art, smith_obj);
 exclude_pval(smith_obj);
}
/**
 * ------------------------------------------------------------------------
 * Main smithing menu functions
 * ------------------------------------------------------------------------ */
static menu_action smithing_actions[] =
{
 { 0, 'a', "Base Item", tval_menu },
 { 0, 'b', "Enchant", special_menu },
 { 0, 'c', "Artifice", artefact_menu },
 { 0, 'd', "Numbers", numbers_menu },
 { 0, 'e', "Melt", melt_menu },
 { 0, 'f', "Accept", accept_item },
};
/**
 * Show smithing object data
 */
static void smithing_menu_browser(int oid, void *data, const region *loc)
{
 uint8_t attr = COLOUR_SLATE;
 const char *desc[] = { "Start with a new base item.               ",
         "                                          ",
         "Choose a special enchantment to add to the",
         "base item. (not compatible with Artifice) ",
         "Design your own artefact.                 ",
         "(not compatible with Enchant)             ",
         "Change the item's key numbers.            ",
         "                                          ",
         "Choose a mithril item to melt down.       ",
         "                                          ",
         "Create the item you have designed.        ",
         "(to cancel it instead, just press Escape) "
 };
 const char *extra[] = { "(Enchantment cannot be changed after     ",
       "using the Numbers menu)                  ",
       "This forge has no resources, so you cannot",
       "create items. To exit, press Escape.     ",
       "You are not at a forge and thus cannot   ",
       "create items. To exit, press Escape.     "
 };
 region area = { 16, 2, 62 - 16,
     MAX_SMITHING_TVALS + 2 };
 /* Redirect output to the screen */
 text_out_hook = text_out_to_screen;
 text_out_wrap = 62;
 /* Object difficulty */
 text_out_indent = 16;
 region_erase(&area);
 Term_gotoxy(16, 2);
 if (no_forge && (oid == 5)) {
  text_out_c(attr, "%s", extra[4]);
 } else if (exhausted && (oid == 5)) {
  text_out_c(attr, "%s", extra[2]);
 } else if (numbers_changed && (oid == 1)) {
  text_out_c(attr, "%s", extra[0]);
 } else {
  text_out_c(attr, "%s", desc[oid * 2]);
 }
 Term_gotoxy(16, 2 + 1);
 if (no_forge && (oid == 5)) {
  text_out_c(attr, "%s", extra[5]);
 } else if (exhausted && (oid == 5)) {
  text_out_c(attr, "%s", extra[3]);
 } else if (numbers_changed && (oid == 1)) {
  text_out_c(attr, "%s", extra[1]);
 } else {
  text_out_c(attr, "%s", desc[oid * 2 + 1]);
 }
 if (smith_obj->kind) {
  show_smith_obj();
 }
}
static void check_smithing_menu_row_colors(void)
{
 size_t i;
 /* Recognise which actions are valid, and which need a new ability */
 for (i = 0; i < N_ELEMENTS(smithing_actions); i++) {
  if (i == 0) {
   if (player_active_ability(player, "Weaponsmith") ||
    player_active_ability(player, "Armoursmith") ||
    player_active_ability(player, "Jeweller")) {
    smithing_actions[i].flags = 0;
   } else {
    smithing_actions[i].flags = MN_ACT_MAYBE;
   }
  }
  if (i == 1) {
   if (!smith_obj->kind || smith_obj->artifact || numbers_changed ||
    tval_is_jewelry(smith_obj) || tval_is_horn(smith_obj) ||
    strstr(smith_obj->kind->name, "Shovel")) {
    smithing_actions[i].flags = MN_ACT_GRAYED;
   } else if (player_active_ability(player, "Enchantment")) {
    smithing_actions[i].flags = 0;
   } else {
    smithing_actions[i].flags = MN_ACT_MAYBE;
   }
  }
  if (i == 2) {
   if (!smith_obj->kind || smith_obj->ego || tval_is_horn(smith_obj) ||
    (player->self_made_arts >= z_info->self_arts_max)) {
    smithing_actions[i].flags = MN_ACT_GRAYED;
   } else if (player_active_ability(player, "Artifice")) {
    smithing_actions[i].flags = 0;
   } else {
    smithing_actions[i].flags = MN_ACT_MAYBE;
   }
  }
  if (i == 3) {
   if (!smith_obj->kind) {
    smithing_actions[i].flags = MN_ACT_GRAYED;
   } else {
    smithing_actions[i].flags = 0;
   }
  }
  if (i == 4) {
   if (!mithril_items_carried(player) ||
     !square_isforge(cave, player->grid) ||
     !square_forge_uses(cave, player->grid)) {
    smithing_actions[i].flags = MN_ACT_GRAYED;
   } else {
    smithing_actions[i].flags = 0;
   }
  }
  if (i == 5) {
   include_pval(smith_obj);
   if (!smith_obj->kind ||
    !smith_affordable(smith_obj, &current_cost) ||
    !square_isforge(cave, player->grid) ||
    !square_forge_uses(cave, player->grid)) {
    smithing_actions[i].flags = MN_ACT_GRAYED;
   } else {
    smithing_actions[i].flags = 0;
   }
   exclude_pval(smith_obj);
  }
 }
}
/**
 * Display the smithing main menu.
 */
struct object *textui_smith_object(struct smithing_cost *cost)
{
 region area = {2, 2, 16 - 2,
       8 - 2};
 /* Deal with previous interruptions */
 if (player->smithing_leftover > 0) {
  if (square_isforge(cave, player->grid)) {
   /* Add the cost */
   *cost = current_cost;
   /* Return the smithing item */
   return smith_obj;
  }
  if (!get_check(format("A forge has an unfinished %s.  Abandon it to see smithing options? ", smith_obj->artifact ? "artifact" : "item"))) {
   return NULL;
  }
  player->smithing_leftover = 0;
 }
 /* Otherwise wipe the smithing item and artefact */
 wipe_smithing_objects();
 screen_save();
 clear_from(0);
 /* Main smithing menu */
 create_smithed_item = false;
 smithing_menu = menu_new_action(smithing_actions,
         N_ELEMENTS(smithing_actions));
 /* Prepare some menu details */
 check_smithing_menu_row_colors();
 if (!square_isforge(cave, player->grid)) {
  no_forge = true;
  exhausted = false;
  prt("Exploration mode:  Smithing requires a forge.", 0, 0);
 } else if (!square_forge_uses(cave, player->grid)) {
  no_forge = false;
  exhausted = true;
  prt("Exploration mode:  Smithing requires a forge with resources left.", 0, 0);
 } else {
  no_forge = false;
  exhausted = false;
 }
 smithing_menu->flags = MN_CASELESS_TAGS;
 smithing_menu->browse_hook = smithing_menu_browser;
 menu_layout(smithing_menu, &area);
 while (!create_smithed_item) {
  ui_event evt = EVENT_EMPTY;
  check_smithing_menu_row_colors();
  evt = menu_select(smithing_menu, EVT_KBRD, false);
  if (evt.type == EVT_ESCAPE) {
   /* Wipe the smithing object and artefact */
   wipe_smithing_objects();
   create_smithed_item = false;
   break;
  }
 }
 menu_free(smithing_menu);
 screen_load();
 include_pval(smith_obj);
 *cost = current_cost;
 return create_smithed_item ? smith_obj : NULL;
}
/**
 * \file ui-songs.c
 * \brief Selection of player songs
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
struct song_menu_info {
 struct song *song;
 bool swap;
};
static struct song_menu_info *songlist;
static char labels[25];
static int get_songs(void)
{
 struct ability *a = abilities;
 int count = 0;
 /* Find available songs */
 while (a) {
  if ((a->skill == SKILL_SONG) && strstr(a->name, "Song of") &&
   player_active_ability(player, a->name)) {
   labels[count] = 'a' + count;
   songlist[count].swap = false;
   songlist[count++].song = lookup_song(a->name + strlen("Song of "));
  }
  a = a->next;
 }
 /* Add the chance to stop singing */
 if (player->song[SONG_MAIN]) {
  labels[count] = 's';
  songlist[count].swap = false;
  songlist[count++].song = NULL;
 }
 /* Add the chance to exchange themes */
 if (player->song[SONG_MINOR]) {
  labels[count] = 'x';
  songlist[count].swap = true;
  songlist[count++].song = NULL;
 }
 labels[count] = '\0';
 return count;
}
/**
 * Get the tag for an entry in the song menu.
 */
static char song_tag(struct menu *menu, int oid)
{
 struct song_menu_info *choice = menu->menu_data;
 struct song *song = choice[oid].song;
 if (song) {
  return 'a' + oid;
 } else if (choice[oid].swap) {
  return 'x';
 } else {
  return 's';
 }
}
/**
 * Display an entry in the song menu.
 */
static void song_display(struct menu *menu, int oid, bool cursor, int row,
       int col, int width)
{
 struct song_menu_info *choice = menu->menu_data;
 struct song *song = choice[oid].song;
 const char *str;
 uint8_t attr = (cursor ? COLOUR_L_BLUE : COLOUR_WHITE);
 if (song) {
  str = format("Song of %s", song->name);
 } else if (choice[oid].swap) {
  str = "Exchange themes";
 } else {
  str = "Stop singing";
 }
 c_put_str(attr, str, row, col);
}
/**
 * Handle keypresses in the song menu.
 */
static bool song_action(struct menu *m, const ui_event *event, int oid)
{
 struct song_menu_info *choice = m->menu_data;
 struct song *song = choice[oid].song;
 if (event->type == EVT_SELECT) {
  if (song == NULL) {
   if (choice[oid].swap) {
    /* Exchange themes */
    player_change_song(player, NULL, true);
   } else {
    /* End the song */
    player_change_song(player, NULL, false);
   }
  } else {
   /* Start singing */
   player_change_song(player, song, false);
  }
  return false;
 }
 return true;
}
void textui_change_song(void)
{
 struct menu menu;
 menu_iter menu_f = { song_tag, NULL, song_display, song_action, NULL };
 region area = { 10, 2, 0, 0 };
 int count;
 songlist = mem_zalloc(100 * sizeof(struct song_menu_info));
 count = get_songs();
 if (!count) {
  msg("You do not know any songs of power.");
  mem_free(songlist);
  return;
 }
 menu_init(&menu, MN_SKIN_SCROLL, &menu_f);
 menu.title = "Songs";
 menu.selections = labels;
 menu.flags = MN_CASELESS_TAGS;
 menu_setpriv(&menu, count, songlist);
 menu_layout(&menu, &area);
 menu_select(&menu, 0, true);
 mem_free(songlist);
}
/**
 * \file ui-spoil.c
 * \brief Create menu for spoiler file generation
 *
 * Copyright (c) 2021 Eric Branlund
 * Copyright (c) 1997 Ben Harrison, and others
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
static void spoiler_menu_act(const char *title, int row)
{
 if (row == 0) {
  cmdq_push(CMD_SPOIL_OBJ);
 } else if (row == 1) {
  cmdq_push(CMD_SPOIL_ARTIFACT);
 } else if (row == 2) {
  cmdq_push(CMD_SPOIL_MON_BRIEF);
 } else if (row == 3) {
  cmdq_push(CMD_SPOIL_MON);
 } else {
  assert(0);
 }
 cmdq_execute((player->is_dead) ? CTX_DEATH : CTX_GAME);
 event_signal(EVENT_MESSAGE_FLUSH);
}
static struct menu *spoil_menu = NULL;
static menu_action spoil_actions[] =
{
 { 0, 0, "Brief Object Info (obj-desc.spo)", spoiler_menu_act },
 { 0, 0, "Brief Artifact Info (artifact.spo)", spoiler_menu_act },
 { 0, 0, "Brief Monster Info (mon-desc.spo)", spoiler_menu_act },
 { 0, 0, "Full Monster Info (mon-info.spo)", spoiler_menu_act },
};
/**
 * Display menu for generating spoiler files.
 */
void do_cmd_spoilers(void)
{
 if (!spoil_menu) {
  spoil_menu = menu_new_action(spoil_actions,
   N_ELEMENTS(spoil_actions));
  spoil_menu->selections = all_letters_nohjkl;
  spoil_menu->title = "Create spoilers";
 }
 screen_save();
 clear_from(0);
 menu_layout(spoil_menu, &SCREEN_REGION);
 menu_select(spoil_menu, 0, false);
 screen_load();
}
/**
 * \file ui-target.c
 * \brief UI for targetting code
 *
 * Copyright (c) 1997-2014 Angband contributors
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/*
 * Holds state passed between target_set_interactive_aux() and the handlers
 * that help it handle different types of grids or situations.  In general,
 * the handlers should only modify press (passed back from
 * target_set_interactive_aux() to target_set_interactive()) and boring
 * (modulates how later handlers act).
 */
struct target_aux_state {
 char coord_desc[20];
 const char *phrase1;
 const char *phrase2;
 struct loc grid;
 ui_event press;
 int mode;
 bool boring;
};
typedef bool (*target_aux_handler)(struct chunk *c, struct player *p,
 struct target_aux_state *auxst);
/**
 * Extract a direction (or zero) from a character
 */
int target_dir(struct keypress ch)
{
 return target_dir_allow(ch, false);
}
int target_dir_allow(struct keypress ch, bool allow_5)
{
 int d = 0;
 /* Already a direction? */
 if (isdigit((unsigned char)ch.code)) {
  d = D2I(ch.code);
 } else if (isarrow(ch.code)) {
  switch (ch.code) {
   case ARROW_DOWN: d = 2; break;
   case ARROW_LEFT: d = 4; break;
   case ARROW_RIGHT: d = 6; break;
   case ARROW_UP: d = 8; break;
  }
 } else {
  int mode;
  const struct keypress *act;
  if (OPT(player, angband_keyset))
   mode = KEYMAP_MODE_ANGBAND;
  else
   mode = KEYMAP_MODE_ORIG;
  if (OPT(player, hjkl_movement)) {
   mode |= KEYMAP_MODE_ROGUE;
  }
  /* XXX see if this key has a digit in the keymap we can use */
  act = keymap_find(mode, ch);
  if (act) {
   const struct keypress *cur;
   for (cur = act; cur->type == EVT_KBRD; cur++) {
    if (isdigit((unsigned char) cur->code))
     d = D2I(cur->code);
   }
  }
 }
 /* Paranoia */
 if (d == 5 && !allow_5) d = 0;
 /* Return direction */
 return (d);
}
/**
 * Display targeting help at the bottom of the screen.
 */
void target_display_help(bool monster, bool object, bool free)
{
 /* Determine help location */
 int wid, hgt, help_loc;
 int mode = OPT(player, angband_keyset) ? KEYMAP_MODE_ANGBAND :
  KEYMAP_MODE_ORIG;
 if (OPT(player, hjkl_movement)) {
  mode |= KEYMAP_MODE_ROGUE;
 }
 Term_get_size(&wid, &hgt);
 help_loc = hgt - HELP_HEIGHT;
 /* Clear */
 clear_from(help_loc);
 /* Prepare help hooks */
 text_out_hook = text_out_to_screen;
 text_out_indent = 1;
 Term_gotoxy(1, help_loc);
 /* Display help */
 text_out_c(COLOUR_L_GREEN, "<dir>");
 text_out(" and ");
 text_out_c(COLOUR_L_GREEN, "<click>");
 text_out(" look around. '");
 text_out_c(COLOUR_L_GREEN, "g");
 text_out("' moves to selection. '");
 text_out_c(COLOUR_L_GREEN, "p");
 text_out("' selects player. '");
 text_out_c(COLOUR_L_GREEN, "q");
 text_out("' exits. '");
 text_out_c(COLOUR_L_GREEN, "r");
 text_out("' displays details. '");
 if (free) {
  text_out_c(COLOUR_L_GREEN, "m");
  text_out("' restricts to interesting places.");
 } else {
  text_out_c(COLOUR_L_GREEN, "+");
  text_out("' and '");
  text_out_c(COLOUR_L_GREEN, "-");
  text_out("' cycle through places. '");
  text_out_c(COLOUR_L_GREEN, "o");
  text_out("' allows free selection.");
 }
 if (monster || free) {
  text_out(" '");
  text_out_c(COLOUR_L_GREEN, "t");
  text_out("' targets selection.");
 }
 if (object) {
  unsigned char key = cmd_lookup_key(CMD_IGNORE, mode);
  char label[3];
  if (KTRL(key) == key) {
   label[0] = '^';
   label[1] = UN_KTRL(key);
   label[2] = '\0';
  } else {
   label[0] = key;
   label[1] = '\0';
  }
  text_out(" '");
  text_out_c(COLOUR_L_GREEN, "%s", label);
  text_out("' ignores selection.");
 }
 /* Reset */
 text_out_indent = 0;
}
/**
 * Return whether a key triggers a running action.
 */
static bool is_running_keymap(struct keypress ch)
{
 int mode = (OPT(player, angband_keyset)) ?
  KEYMAP_MODE_ANGBAND : KEYMAP_MODE_ORIG;
 const struct keypress *act = keymap_find(mode, ch);
 if (OPT(player, hjkl_movement)) {
  mode |= KEYMAP_MODE_ROGUE;
 }
 if (act) {
  unsigned char run_key = cmd_lookup_key(CMD_RUN, mode);
  const struct keypress *cur;
  for (cur = act; cur->type == EVT_KBRD; cur++) {
   if ((unsigned char)cur->code == run_key) {
    return true;
   }
  }
 }
 return false;
}
/**
 * Perform the minimum "whole panel" adjustment to ensure that the given
 * location is contained inside the current panel, and return true if any
 * such adjustment was performed. Optionally accounts for the targeting
 * help window.
 */
static bool adjust_panel_help(struct loc grid, bool help)
{
 bool changed = false;
 int j;
 int screen_hgt_main = help ? (Term->hgt - ROW_MAP - ROW_BOTTOM_MAP - 2)
    : (Term->hgt - ROW_MAP - ROW_BOTTOM_MAP);
 /* Scan windows */
 for (j = 0; j < ANGBAND_TERM_MAX; j++)
 {
  int wx, wy;
  int screen_hgt, screen_wid;
  term *t = angband_term[j];
  /* No window */
  if (!t) continue;
  /* No relevant flags */
  if ((j > 0) && !(window_flag[j] & PW_OVERHEAD)) continue;
  wy = t->offset_y;
  wx = t->offset_x;
  screen_hgt = (j == 0) ? screen_hgt_main : t->hgt;
  screen_wid = (j == 0) ? (Term->wid - COL_MAP - 1) : t->wid;
  /* Bigtile panels need adjustment */
  screen_wid = screen_wid / tile_width;
  screen_hgt = screen_hgt / tile_height;
  /* Adjust as needed */
  while (grid.y >= wy + screen_hgt) wy += screen_hgt / 2;
  while (grid.y < wy) wy -= screen_hgt / 2;
  /* Adjust as needed */
  while (grid.x >= wx + screen_wid) wx += screen_wid / 2;
  while (grid.x < wx) wx -= screen_wid / 2;
  /* Use "modify_panel" */
  if (modify_panel(t, wy, wx)) changed = true;
 }
 return (changed);
}
/**
 * Display the object name of the selected object and allow for full object
 * recall. Returns an event that occurred display.
 *
 * This will only work for a single object on the ground and not a pile. This
 * loop is similar to the monster recall loop in target_set_interactive_aux().
 * The out_val array size needs to match the size that is passed in (since
 * this code was extracted from there).
 *
 * \param obj is the object to describe.
 * \param y is the cave row of the object.
 * \param x is the cave column of the object.
 * \param out_val is the string that holds the name of the object and is
 * returned to the caller.
 * \param s1 is part of the output string.
 * \param s2 is part of the output string.
 * \param s3 is part of the output string.
 * \param coords is part of the output string
 */
static ui_event target_recall_loop_object(struct object *obj, int y, int x,
  char out_val[TARGET_OUT_VAL_SIZE],
  const char *s1,
  const char *s2,
  const char *s3,
  const char *coords,
  const struct player *p)
{
 bool recall = false;
 ui_event press;
 while (1) {
  if (recall) {
   display_object_recall_interactive(cave->objects[obj->oidx]);
   press = inkey_m();
  } else {
   char o_name[80];
   /* Obtain an object description */
   object_desc(o_name, sizeof(o_name),
    cave->objects[obj->oidx],
    ODESC_PREFIX | ODESC_FULL, p);
   /* Describe the object */
   if (p->wizard) {
    strnfmt(out_val, TARGET_OUT_VAL_SIZE,
      "%s%s%s%s, %s (%d:%d, noise=%d, scent=%d).", s1, s2, s3,
      o_name, coords, y, x,
      (int)cave->player_noise.grids[y][x],
      (int)cave->scent.grids[y][x]);
   } else {
    strnfmt(out_val, TARGET_OUT_VAL_SIZE,
      "%s%s%s%s, %s.", s1, s2, s3, o_name, coords);
   }
   prt(out_val, 0, 0);
   move_cursor_relative(y, x);
   press = inkey_m();
  }
  if ((press.type == EVT_MOUSE) && (press.mouse.button == 1) &&
   (KEY_GRID_X(press) == x) && (KEY_GRID_Y(press) == y))
   recall = !recall;
  else if ((press.type == EVT_KBRD) && (press.key.code == 'r'))
   recall = !recall;
  else
   break;
 }
 return press;
}
/**
 * Help target_set_interactive_aux():  reset the state for another pass
 * through the handlers.
 */
static bool aux_reinit(struct chunk *c, struct player *p,
  struct target_aux_state *auxst)
{
 struct monster *mon;
 /* Set the default event to focus on the player. */
 auxst->press.type = EVT_KBRD;
 auxst->press.key.code = 'p';
 auxst->press.key.mods = 0;
 /* Bail if looking at a forbidden grid.  Don't run any more handlers. */
 if (!square_in_bounds(c, auxst->grid)) return true;
 /* Assume boring. */
 auxst->boring = true;
 if (square(c, auxst->grid)->mon < 0) {
  /* Looking at the player's grid */
  auxst->phrase1 = "You are ";
  auxst->phrase2 = "on ";
 } else {
  /* Default */
  if (square_isseen(c, auxst->grid)) {
   auxst->phrase1 = "You see ";
  } else {
   mon = square_monster(c, auxst->grid);
   if (mon && monster_is_listened(mon)) {
    auxst->phrase1 = "You sense ";
   } else {
    auxst->phrase1 = "You recall ";
   }
  }
  auxst->phrase2 = "";
 }
 return false;
}
/**
 * Help target_set_interactive_aux():  handle hallucination.
 */
static bool aux_hallucinate(struct chunk *c, struct player *p,
  struct target_aux_state *auxst)
{
 const char *name_strange = "something strange";
 char out_val[TARGET_OUT_VAL_SIZE];
 if (!p->timed[TMD_IMAGE]) return false;
 /* Hallucination messes things up */
 /* Display a message */
 if (p->wizard) {
  strnfmt(out_val, sizeof(out_val),
   "%s%s%s, %s (%d:%d, noise=%d, scent=%d).",
   auxst->phrase1,
   auxst->phrase2,
   name_strange,
   auxst->coord_desc,
   auxst->grid.y,
   auxst->grid.x,
   (int)c->player_noise.grids[auxst->grid.y][auxst->grid.x],
   (int)c->scent.grids[auxst->grid.y][auxst->grid.x]);
 } else {
  strnfmt(out_val, sizeof(out_val), "%s%s%s, %s.",
   auxst->phrase1,
   auxst->phrase2,
   name_strange,
   auxst->coord_desc);
 }
 prt(out_val, 0, 0);
 move_cursor_relative(auxst->grid.y, auxst->grid.x);
 auxst->press.key = inkey();
 /* Stop on everything but "return" */
 return auxst->press.key.code != KC_ENTER;
}
/**
 * Help target_set_interactive_aux():  handle monsters.
 *
 * Note that if a monster is in the grid, we update both the monster
 * recall info and the health bar info to track that monster.
 */
static bool aux_monster(struct chunk *c, struct player *p,
  struct target_aux_state *auxst)
{
 struct monster *mon;
 const struct monster_lore *lore;
 char m_name[80];
 char out_val[TARGET_OUT_VAL_SIZE];
 bool recall;
 if (square(c, auxst->grid)->mon <= 0) return false;
 mon = square_monster(c, auxst->grid);
 if (!monster_is_visible(mon)) return false;
 /* Actual visible monsters */
 lore = get_lore(mon->race);
 /* Not boring */
 auxst->boring = false;
 /* Get the monster name ("a kobold") */
 if (p->timed[TMD_RAGE]) {
  my_strcpy(m_name, "an enemy", sizeof(m_name));
 } else {
  monster_desc(m_name, sizeof(m_name), mon, MDESC_IND_VIS);
 }
 /* Track this monster's race and health */
 monster_race_track(p->upkeep, mon->race);
 health_track(p->upkeep, mon);
 handle_stuff(p);
 /* Interact */
 recall = false;
 while (1) {
  /* Recall or target */
  if (recall && !p->timed[TMD_RAGE]) {
   lore_show_interactive(mon->race, lore);
   auxst->press = inkey_m();
  } else {
   char buf[80];
   /* Describe the monster */
   look_mon_desc(buf, sizeof(buf),
    square(c, auxst->grid)->mon);
   /* Describe, and prompt for recall */
   if (p->wizard) {
    strnfmt(out_val, sizeof(out_val),
     "%s%s%s%s, %s (%d:%d, noise=%d, scent=%d).",
     auxst->phrase1,
     auxst->phrase2,
     m_name,
     buf,
     auxst->coord_desc,
     auxst->grid.y,
     auxst->grid.x,
     (int)c->player_noise.grids[auxst->grid.y][auxst->grid.x],
     (int)c->scent.grids[auxst->grid.y][auxst->grid.x]);
   } else {
    strnfmt(out_val, sizeof(out_val),
     "%s%s%s%s, %s.",
     auxst->phrase1,
     auxst->phrase2,
     m_name,
     buf,
     auxst->coord_desc);
   }
   prt(out_val, 0, 0);
   /* Place cursor */
   move_cursor_relative(auxst->grid.y, auxst->grid.x);
   /* Command */
   auxst->press = inkey_m();
  }
  /* Normal commands */
  if (auxst->press.type == EVT_MOUSE
    && auxst->press.mouse.button == 1
    && KEY_GRID_X(auxst->press) == auxst->grid.x
    && KEY_GRID_Y(auxst->press) == auxst->grid.y) {
   recall = !recall;
  } else if (auxst->press.type == EVT_KBRD
    && auxst->press.key.code == 'r') {
   recall = !recall;
  } else {
   break;
  }
 }
 if (auxst->press.type == EVT_MOUSE) {
  /* Stop on right click */
  if (auxst->press.mouse.button == 2) return true;
  /* Sometimes stop at "space" key */
  if (auxst->press.mouse.button
    && !(auxst->mode & (TARGET_LOOK))) return true;
 } else {
  /* Stop on everything but "return"/"space" */
  if (auxst->press.key.code != KC_ENTER
    && auxst->press.key.code != ' ') return true;
  /* Sometimes stop at "space" key */
  if (auxst->press.key.code == ' '
    && !(auxst->mode & (TARGET_LOOK))) return true;
 }
 /* Describe carried objects (wizards only) */
 if (p->wizard) {
  const char *lphrase1;
  const char *lphrase2;
  struct object *obj;
  /* Take account of gender */
  if (rf_has(mon->race->flags, RF_FEMALE)) {
   lphrase1 = "She is ";
  } else if (rf_has(mon->race->flags, RF_MALE)) {
   lphrase1 = "He is ";
  } else {
   lphrase1 = "It is ";
  }
  /* Use a verb */
  lphrase2 = "carrying ";
  /* Scan all objects being carried */
  for (obj = mon->held_obj; obj; obj = obj->next) {
   char o_name[80];
   /* Obtain an object description */
   object_desc(o_name, sizeof(o_name), obj,
    ODESC_PREFIX | ODESC_FULL, p);
   strnfmt(out_val, sizeof(out_val),
    "%s%s%s, %s (%d:%d, noise=%d, scent=%d).",
    lphrase1,
    lphrase2,
    o_name,
    auxst->coord_desc,
    auxst->grid.y,
    auxst->grid.x,
    (int)c->player_noise.grids[auxst->grid.y][auxst->grid.x],
    (int)c->scent.grids[auxst->grid.y][auxst->grid.x]);
   prt(out_val, 0, 0);
   move_cursor_relative(auxst->grid.y, auxst->grid.x);
   auxst->press = inkey_m();
   if (auxst->press.type == EVT_MOUSE) {
    /* Stop on right click */
    if (auxst->press.mouse.button == 2) break;
    /* Sometimes stop at "space" key */
    if (auxst->press.mouse.button
      && !(auxst->mode & (TARGET_LOOK)))
     break;
   } else {
    /* Stop on everything but "return"/"space" */
    if (auxst->press.key.code != KC_ENTER
      && auxst->press.key.code != ' ')
     break;
    /* Sometimes stop at "space" key */
    if (auxst->press.key.code == ' '
      && !(auxst->mode & (TARGET_LOOK)))
     break;
   }
   /* Change the intro */
   lphrase2 = "also carrying ";
  }
  /* Double break */
  if (obj) return true;
 }
 return false;
}
/**
 * Help target_set_interactive_aux():  handle visible traps.
 */
static bool aux_trap(struct chunk *c, struct player *p,
  struct target_aux_state *auxst)
{
 struct trap *trap;
 char out_val[TARGET_OUT_VAL_SIZE];
 const char *lphrase3;
 if (!square_isvisibletrap(p->cave, auxst->grid)) return false;
 if (square_isforge(p->cave, auxst->grid)) return false;
 /* A trap */
 trap = square(p->cave, auxst->grid)->trap;
 /* Not boring */
 auxst->boring = false;
 /* Pick proper indefinite article */
 lphrase3 = (is_a_vowel(trap->kind->desc[0])) ? "an " : "a ";
 /* Interact */
 while (1) {
  /* Describe, and prompt for recall */
  if (p->wizard) {
   strnfmt(out_val, sizeof(out_val),
    "%s%s%s%s, %s (%d:%d, noise=%d, scent=%d).",
    auxst->phrase1,
    auxst->phrase2,
    lphrase3,
    trap->kind->name,
    auxst->coord_desc,
    auxst->grid.y,
    auxst->grid.x,
    (int)c->player_noise.grids[auxst->grid.y][auxst->grid.x],
    (int)c->scent.grids[auxst->grid.y][auxst->grid.x]);
  } else {
   strnfmt(out_val, sizeof(out_val), "%s%s%s%s, %s.",
    auxst->phrase1,
    auxst->phrase2,
    lphrase3,
    trap->kind->desc,
    auxst->coord_desc);
  }
  prt(out_val, 0, 0);
  /* Place cursor */
  move_cursor_relative(auxst->grid.y, auxst->grid.x);
  /* Command */
  auxst->press = inkey_m();
  /* Stop on everything but "return"/"space" */
  if (auxst->press.key.code != KC_ENTER
    && auxst->press.key.code != ' ')
   break;
  /* Sometimes stop at "space" key */
  if (auxst->press.key.code == ' '
    && !(auxst->mode & (TARGET_LOOK)))
   break;
 }
 return true;
}
/**
 * Help target_set_interactive_aux():  handle objects.
 */
static bool aux_object(struct chunk *c, struct player *p,
  struct target_aux_state *auxst)
{
 int floor_max = z_info->floor_size;
 struct object **floor_list =
  mem_zalloc(floor_max * sizeof(*floor_list));
 bool result = false;
 char out_val[TARGET_OUT_VAL_SIZE];
 int floor_num;
 /* Scan all sensed objects in the grid */
 floor_num = scan_distant_floor(floor_list, floor_max, p, auxst->grid);
 if (floor_num <= 0) {
  mem_free(floor_list);
  return result;
 }
 /* Not boring */
 auxst->boring = false;
 track_object(p->upkeep, floor_list[0]);
 handle_stuff(p);
 /* If there is more than one item... */
 if (floor_num > 1) {
  while (1) {
   /* Describe the pile */
   if (p->wizard) {
    strnfmt(out_val, sizeof(out_val),
     "%s%sa pile of %d objects, %s (%d:%d, noise=%d, scent=%d).",
     auxst->phrase1,
     auxst->phrase2,
     floor_num,
     auxst->coord_desc,
     auxst->grid.y,
     auxst->grid.x,
     (int)c->player_noise.grids[auxst->grid.y][auxst->grid.x],
     (int)c->scent.grids[auxst->grid.y][auxst->grid.x]);
   } else {
    strnfmt(out_val, sizeof(out_val),
     "%s%sa pile of %d objects, %s.",
     auxst->phrase1,
     auxst->phrase2,
     floor_num,
     auxst->coord_desc);
   }
   prt(out_val, 0, 0);
   move_cursor_relative(auxst->grid.y, auxst->grid.x);
   auxst->press = inkey_m();
   /* Display objects */
   if ((auxst->press.type == EVT_MOUSE
     && auxst->press.mouse.button == 1
     && KEY_GRID_X(auxst->press) ==
     auxst->grid.x
     && KEY_GRID_Y(auxst->press) ==
     auxst->grid.y)
     || (auxst->press.type == EVT_KBRD
     && auxst->press.key.code == 'r')) {
    int pos;
    while (1) {
     /* Save screen */
     screen_save();
     /*
					 * Use OLIST_DEATH to show item labels
					 */
     show_floor(floor_list, floor_num,
      (OLIST_DEATH | OLIST_WEIGHT), NULL);
     /* Describe the pile */
     prt(out_val, 0, 0);
     auxst->press = inkey_m();
     /* Load screen */
     screen_load();
     if (auxst->press.type == EVT_MOUSE) {
      pos = auxst->press.mouse.y - 1;
     } else {
      pos = auxst->press.key.code -
       'a';
     }
     if (0 <= pos && pos < floor_num) {
      track_object(p->upkeep,
       floor_list[pos]);
      handle_stuff(p);
      continue;
     }
     break;
    }
    /*
				 * Now that the user's done with the display
				 * loop, let's do the outer loop over again.
				 */
    continue;
   }
   /* Done */
   break;
  }
 } else {
  /* Only one object to display */
  /* Get the single object in the list */
  struct object *obj_local = floor_list[0];
  /* Allow user to recall an object */
  auxst->press = target_recall_loop_object(obj_local,
   auxst->grid.y, auxst->grid.x, out_val, auxst->phrase1,
   auxst->phrase2, "", auxst->coord_desc, p);
  /* Stop on everything but "return"/"space" */
  if (auxst->press.key.code != KC_ENTER
    && auxst->press.key.code != ' ') result = true;
  /* Sometimes stop at "space" key */
  if (auxst->press.key.code == ' '
    && !(auxst->mode & (TARGET_LOOK))) result = true;
 }
 mem_free(floor_list);
 return result;
}
/**
 * Help target_set_interactive_aux():  handle terrain.
 */
static bool aux_terrain(struct chunk *c, struct player *p,
  struct target_aux_state *auxst)
{
 const char *lphrase2, *lphrase3;
 char name[50];
 char out_val[TARGET_OUT_VAL_SIZE];
 if (!auxst->boring && !square_isinteresting(p->cave, auxst->grid))
  return false;
 /* Terrain feature if needed */
 square_apparent_name(p->cave, auxst->grid, name, sizeof(name));
 /* Pick a preposition if needed */
 lphrase2 = (*auxst->phrase2) ?
  square_apparent_look_in_preposition(p->cave, auxst->grid) : "";
 /* Pick prefix for the name */
 lphrase3 = square_apparent_look_prefix(p->cave, auxst->grid);
 /* Display a message */
 if (p->wizard) {
  strnfmt(out_val, sizeof(out_val),
   "%s%s%s%s, %s (%d:%d, noise=%d, scent=%d).",
   auxst->phrase1,
   lphrase2,
   lphrase3,
   name,
   auxst->coord_desc,
   auxst->grid.y,
   auxst->grid.x,
   (int)c->player_noise.grids[auxst->grid.y][auxst->grid.x],
   (int)c->scent.grids[auxst->grid.y][auxst->grid.x]);
 } else {
  strnfmt(out_val, sizeof(out_val),
   "%s%s%s%s, %s.",
   auxst->phrase1,
   lphrase2,
   lphrase3,
   name,
   auxst->coord_desc);
 }
 prt(out_val, 0, 0);
 move_cursor_relative(auxst->grid.y, auxst->grid.x);
 auxst->press = inkey_m();
 /*
	 * Stop on right click of mouse or everything but "return"/"space" for
	 * a key.
	 */
 return (auxst->press.type == EVT_MOUSE
   && auxst->press.mouse.button == 2)
  || (auxst->press.type != EVT_MOUSE
   && auxst->press.key.code != KC_ENTER
   && auxst->press.key.code != ' ');
}
/**
 * Help target_set_interactive_aux():  check what's in press to decide whether
 * to do another pass through the handlers.
 */
static bool aux_wrapup(struct chunk *c, struct player *p,
  struct target_aux_state *auxst)
{
 if (auxst->press.type == EVT_MOUSE) {
  /* Stop on right click. */
  return auxst->press.mouse.button != 2;
 }
 /* Stop on everything but "return". */
 return auxst->press.key.code != KC_ENTER;
}
/**
 * Examine a grid, return a keypress.
 *
 * The "mode" argument contains the "TARGET_LOOK" bit flag, which
 * indicates that the "space" key should scan through the contents
 * of the grid, instead of simply returning immediately.  This lets
 * the "look" command get complete information, without making the
 * "target" command annoying.
 *
 * This function correctly handles multiple objects per grid, and objects
 * and terrain features in the same grid, though the latter never happens.
 *
 * This function must handle blindness/hallucination.
 */
static ui_event target_set_interactive_aux(struct loc grid, int mode)
{
 /*
	 * If there's other types to be handled, insert a function to do so
	 * between aux_hallucinate and aux_wrapup.  Because each handler
	 * can signal that the sequence be halted, these are ordered in
	 * decreasing order of precedence.
	 */
 target_aux_handler handlers[] = {
  aux_reinit,
  aux_hallucinate,
  aux_monster,
  aux_trap,
  aux_object,
  aux_terrain,
  aux_wrapup
 };
 struct target_aux_state auxst;
 int ihandler;
 auxst.mode = mode;
 /* Describe the square location */
 auxst.grid = grid;
 coords_desc(auxst.coord_desc, sizeof(auxst.coord_desc), grid);
 /* Apply the handlers in order until done */
 ihandler = 0;
 while (1) {
  if ((*handlers[ihandler])(cave, player, &auxst)) break;
  ++ihandler;
  if (ihandler >= (int) N_ELEMENTS(handlers)) ihandler = 0;
 }
 /* Keep going */
 return auxst.press;
}
/**
 * Target command
 */
void textui_target(void)
{
 if (target_set_interactive(TARGET_KILL, loc(-1, -1), 0))
  msg("Target Selected.");
 else
  msg("Target Aborted.");
}
/**
 * Target closest monster.
 *
 * XXX: Move to using CMD_TARGET_CLOSEST at some point instead of invoking
 * target_set_closest() directly.
 */
void textui_target_closest(void)
{
 if (target_set_closest(TARGET_KILL, NULL)) {
  bool visibility;
  struct loc target;
  target_get(&target);
  /* Visual cue */
  Term_fresh();
  Term_get_cursor(&visibility);
  (void)Term_set_cursor(true);
  move_cursor_relative(target.y, target.x);
  /* TODO: what's an appropriate amount of time to spend highlighting */
  Term_xtra(TERM_XTRA_DELAY, 150);
  (void)Term_set_cursor(visibility);
 }
}
/**
 * Draw a visible path over the squares between (x1,y1) and (x2,y2).
 *
 * The path consists of "*", which are white except where there is a
 * monster, object or feature in the grid.
 *
 * This routine has (at least) three weaknesses:
 * - remembered objects/walls which are no longer present are not shown,
 * - squares which (e.g.) the player has walked through in the dark are
 *   treated as unknown space.
 * - walls which appear strange due to hallucination aren't treated correctly.
 *
 * The first two result from information being lost from the dungeon arrays,
 * which requires changes elsewhere
 */
static int draw_path(uint16_t path_n, struct loc *path_g, wchar_t *c, int *a,
      struct loc grid1)
{
 int i;
 bool on_screen;
 bool pastknown = false;
 /* No path, so do nothing. */
 if (path_n < 1) return 0;
 /* The starting square is never drawn, but notice if it is being
     * displayed. In theory, it could be the last such square.
     */
 on_screen = panel_contains(grid1.y, grid1.x);
 /* Draw the path. */
 for (i = 0; i < path_n; i++) {
  uint8_t colour;
  /* Find the co-ordinates on the level. */
  struct loc grid = path_g[i];
  struct monster *mon = square_monster(cave, grid);
  struct object *obj = square_object(player->cave, grid);
  /*
		 * As path[] is a straight line and the screen is oblong,
		 * there is only section of path[] on-screen.
		 * If the square being drawn is visible, this is part of it.
		 * If none of it has been drawn, continue until some of it
		 * is found or the last square is reached.
		 * If some of it has been drawn, finish now as there are no
		 * more visible squares to draw.
		 */
   if (panel_contains(grid.y, grid.x)) on_screen = true;
   else if (on_screen) break;
   else continue;
   /* Find the position on-screen */
  move_cursor_relative(grid.y, grid.x);
  /* This square is being overwritten, so save the original. */
  Term_what(Term->scr->cx, Term->scr->cy, a + i, c + i);
  /* Choose a colour. */
  if (pastknown) {
   /* Once we pass an unknown square, we no longer know
			 * if we will reach later squares */
   colour = COLOUR_L_DARK;
  } else if (mon && monster_is_visible(mon)) {
   /* Visible monsters are red. */
   colour = COLOUR_L_RED;
  } else if (obj)
   /* Known objects are yellow. */
   colour = COLOUR_YELLOW;
  else if (!square_isprojectable(player->cave, grid) &&
     (square_isknown(cave, grid) || square_isseen(cave, grid)))
   /* Known walls are blue. */
   colour = COLOUR_BLUE;
  else if (!square_isknown(cave, grid) && !square_isseen(cave, grid)) {
   /* Unknown squares are grey. */
   pastknown = true;
   colour = COLOUR_L_DARK;
  } else
   /* Unoccupied squares are white. */
   colour = COLOUR_WHITE;
  /* Draw the path segment */
  (void)Term_addch(colour, L'*');
 }
 return i;
}
/**
 * Load the attr/char at each point along "path" which is on screen from
 * "a" and "c". This was saved in draw_path().
 */
static void load_path(uint16_t path_n, struct loc *path_g, wchar_t *c, int *a)
{
 int i;
 for (i = 0; i < path_n; i++) {
  int y = path_g[i].y;
  int x = path_g[i].x;
  if (!panel_contains(y, x)) continue;
  move_cursor_relative(y, x);
  Term_addch(a[i], c[i]);
 }
 Term_fresh();
}
/**
 * Return true if the object pile contains the player's tracked object
 */
static bool pile_is_tracked(const struct object *obj) {
 for (const struct object *o = obj; o != NULL; o = o->next) {
  if (player->upkeep->object == o) {
   return true;
  }
 }
 return false;
}
/**
 * Return true if the object pile contains at least 1 known item
 */
static bool pile_has_known(const struct object *obj) {
 for (const struct object *o = obj; o != NULL; o = o->next) {
  struct object *base_obj = cave->objects[o->oidx];
  if (base_obj->known) {
   return true;
  }
 }
 return false;
}
/**
 * Handle "target" and "look". May be called from commands or "get_aim_dir()".
 *
 * Currently, when "interesting" grids are being used, and a directional key is
 * pressed, we only scroll by a single panel, in the direction requested, and
 * check for any interesting grids on that panel.  The "correct" solution would
 * actually involve scanning a larger set of grids, including ones in panels
 * which are adjacent to the one currently scanned, but this is overkill for
 * this function.
 *
 * Targetting/observing an "outer border grid" may induce problems, so this is
 * not currently allowed.
 *
 * The player can use the direction keys to move among "interesting"
 * grids in a heuristic manner, or the "space", "+", and "-" keys to
 * move through the "interesting" grids in a sequential manner, or
 * can enter "location" mode, and use the direction keys to move one
 * grid at a time in any direction.  The "t" (set target) command will
 * only target a monster (as opposed to a location) if the monster is
 * target_able and the "interesting" mode is being used.
 *
 * The current grid is described using the "look" method above, and
 * a new command may be entered at any time, but note that if the
 * "TARGET_LOOK" bit flag is set (or if we are in "location" mode,
 * where "space" has no obvious meaning) then "space" will scan
 * through the description of the current grid until done, instead
 * of immediately jumping to the next "interesting" grid.  This
 * allows the "target" command to retain its old semantics.
 *
 * The "*", "+", and "-" keys may always be used to jump immediately
 * to the next (or previous) interesting grid, in the proper mode.
 *
 * The "return" key may always be used to scan through a complete
 * grid description (forever).
 *
 * This command will cancel any old target, even if used from
 * inside the "look" command.
 *
 *
 * 'mode' is one of TARGET_LOOK or TARGET_KILL.
 * 'x' and 'y' are the initial position of the target to be highlighted,
 * or -1 if no location is specified.
 * Returns true if a target has been successfully set, false otherwise.
 */
bool target_set_interactive(int mode, struct loc grid, int range)
{
 int path_n;
 struct loc path_g[256];
 int wid, hgt, help_prompt_loc;
 int adjusted_range = range ? range : z_info->max_range;
 int key_mode = OPT(player, angband_keyset) ? KEYMAP_MODE_ANGBAND :
  KEYMAP_MODE_ORIG;
 bool done = false;
 bool show_interesting = true;
 bool help = false;
 keycode_t ignore_key;
 /* These are used for displaying the path to the target */
 wchar_t *path_char = mem_zalloc(adjusted_range * sizeof(wchar_t));
 int *path_attr = mem_zalloc(adjusted_range * sizeof(int));
 if (OPT(player, hjkl_movement)) {
  key_mode |= KEYMAP_MODE_ROGUE;
 }
 ignore_key = cmd_lookup_key(CMD_IGNORE, key_mode);
 /* If we haven't been given an initial location, start on the
	   player, otherwise  honour it by going into "free targetting" mode. */
 if (!square_in_bounds_fully(cave, grid)) {
  grid = player->grid;
 } else {
  show_interesting = false;
 }
 /* Cancel target */
 target_set_monster(0);
 /* Prevent animations */
 disallow_animations();
 /* Calculate the window location for the help prompt */
 Term_get_size(&wid, &hgt);
 help_prompt_loc = hgt - 1;
 /* Display the help prompt */
 prt("Press '?' for help.", help_prompt_loc, 0);
 /* Prepare the target set */
 struct point_set *targets = target_get_monsters(mode, NULL, true);
 int target_index = 0;
 /* Interact */
 while (!done) {
  bool path_drawn = false;
  bool use_interesting_mode = show_interesting && point_set_size(targets);
  bool use_free_mode = !use_interesting_mode;
  /* Use an interesting grid if requested and there are any */
  if (use_interesting_mode) {
   grid = targets->pts[target_index];
   /* Adjust panel if needed */
   if (adjust_panel_help(grid, help)) handle_stuff(player);
  }
  /* Update help */
  if (help) {
   bool has_target = target_able(square_monster(cave, grid));
   bool has_object = !(mode & TARGET_KILL)
     && pile_has_known(square_object(cave, grid));
   target_display_help(has_target, has_object, use_free_mode);
  }
  /* Find the path. */
  path_n = ABS(project_path(cave, path_g, adjusted_range, player->grid,
          &grid,
          PROJECT_THRU | PROJECT_INFO | PROJECT_LEAVE));
  /* Draw the path in "target" mode. If there is one */
  if (mode & (TARGET_KILL))
   path_drawn = draw_path(path_n, path_g, path_char, path_attr,
     player->grid);
  /* Describe and Prompt */
  ui_event press = target_set_interactive_aux(grid, mode | (use_free_mode ? TARGET_LOOK : 0));
  /* Remove the path */
  if (path_drawn) load_path(path_n, path_g, path_char, path_attr);
  /* Handle an input event */
  if (event_is_mouse_m(press, 2, KC_MOD_CONTROL) || event_is_mouse(press, 3)) {
   /* Set a target and done */
   grid = KEY_GRID(press);
   if (use_free_mode) {
    /* Free mode: Target a location */
    target_set_location(grid);
    done = true;
   } else {
    /* Interesting mode: Try to target a monster and done, or bell */
    struct monster *m_local = square_monster(cave, grid);
    if (target_able(m_local)) {
     /* Monster race and health tracked by target_set_interactive_aux() */
     target_set_monster(m_local);
     done = true;
    } else {
     bell();
     if (!square_in_bounds(cave, grid)) {
      grid = player->grid;
     }
    }
   }
  } else if (event_is_mouse_m(press, 2, KC_MOD_ALT)) {
   /* Navigate to location and done */
   grid = KEY_GRID(press);
   cmdq_push(CMD_PATHFIND);
   cmd_set_arg_point(cmdq_peek(), "point", grid);
   done = true;
  } else if (event_is_mouse(press, 2)) {
   /* Cancel and done */
   if (use_free_mode && (mode & TARGET_KILL)
    && loc_eq(grid, KEY_GRID(press))) {
    /* Free/kill mode: Clicked current location, set target */
    target_set_location(grid);
   }
   done = true;
  } else if (event_is_mouse(press, 1)) {
   /* Relocate cursor */
   grid = KEY_GRID(press);
   /* If they clicked on an edge of the map, drag the cursor further
			   to trigger a panel scroll */
   if (press.mouse.y <= 1) {
    grid.y--;
   } else if (press.mouse.y >= Term->hgt - 2) {
    grid.y++;
   } else if (press.mouse.x <= COL_MAP) {
    grid.x--;
   } else if (press.mouse.x >= Term->wid - 2) {
    grid.x++;
   }
   /* Restrict cursor to inbounds */
   grid.x = MAX(0, MIN(grid.x, cave->width - 1));
   grid.y = MAX(0, MIN(grid.y, cave->height - 1));
   /* Adjust panel if needed */
   if (adjust_panel_help(grid, help)) {
    handle_stuff(player);
    /* Recalculate interesting grids */
    point_set_dispose(targets);
    targets = target_get_monsters(mode, NULL, true);
   }
   /* Turn interesting mode off if they clicked a boring spot... */
   show_interesting = false;
   /* ...but turn it on if they clicked an interesting spot */
   for (int i = 0; i < point_set_size(targets); i++) {
    if (loc_eq(grid, targets->pts[i])) {
     target_index = i;
     show_interesting = true;
     break;
    }
   }
  } else if (event_is_key(press, ESCAPE) || event_is_key(press, 'q')) {
   /* Cancel */
   done = true;
  } else if (event_is_key(press, ' ') || event_is_key(press, '*')
    || event_is_key(press, '+')) {
   /* Cycle interesting target forward */
   if (use_interesting_mode && ++target_index == point_set_size(targets)) {
    target_index = 0;
   }
  } else if (event_is_key(press, '-')) {
   /* Cycle interesting target backwards */
   if (use_interesting_mode && target_index-- == 0) {
    target_index = point_set_size(targets) - 1;
   }
  } else if (event_is_key(press, 'p')) {
   /* Focus the player and switch to free mode */
   grid = player->grid;
   show_interesting = false;
   /* Recenter around player */
   verify_panel();
   handle_stuff(player);
  } else if (event_is_key(press, 'o')) {
   /* Switch to free mode */
   show_interesting = false;
  } else if (event_is_key(press, 'm')) {
   /* Switch to interesting mode */
   if (use_free_mode && point_set_size(targets) > 0) {
    show_interesting = true;
    target_index = 0;
    int min_dist = 999;
    /* Pick the nearest interesting target */
    for (int i = 0; i < point_set_size(targets); i++) {
     int dist = distance(grid, targets->pts[i]);
     if (dist < min_dist) {
      target_index = i;
      min_dist = dist;
     }
    }
   }
  } else if (event_is_key(press, 't') || event_is_key(press, '5')
    || event_is_key(press, '0') || event_is_key(press, '.')) {
   /* Set a target and done */
   if (use_interesting_mode) {
    struct monster *m_local = square_monster(cave, grid);
    if (target_able(m_local)) {
     /* Monster race and health tracked by target_set_interactive_aux() */
     target_set_monster(m_local);
     done = true;
    } else {
     bell();
    }
   } else {
    target_set_location(grid);
    done = true;
   }
  } else if (event_is_key(press, 'g')) {
   /* Navigate to a location and done */
   cmdq_push(CMD_PATHFIND);
   cmd_set_arg_point(cmdq_peek(), "point", grid);
   done = true;
  } else if (event_is_key(press, ignore_key)) {
   /* Ignore the tracked object, set by target_set_interactive_aux() */
   if (!(mode & TARGET_KILL)
     && pile_is_tracked(square_object(cave, grid))) {
    textui_cmd_ignore_menu(player->upkeep->object);
    handle_stuff(player);
    /* Recalculate interesting grids */
    point_set_dispose(targets);
    targets = target_get_monsters(mode, NULL, true);
   }
  } else if (event_is_key(press, '?')) {
   /* Toggle help text */
   help = !help;
   /* Redraw main window */
   player->upkeep->redraw |= (PR_BASIC | PR_EXTRA | PR_MAP | PR_EQUIP);
   Term_clear();
   handle_stuff(player);
   if (!help)
    prt("Press '?' for help.", help_prompt_loc, 0);
  } else {
   /* Try to extract a direction from the key press */
   int dir = target_dir(press.key);
   if (!dir) {
    bell();
   } else if (use_interesting_mode) {
    /* Interesting mode direction: Pick new interesting grid */
    int old_y = targets->pts[target_index].y;
    int old_x = targets->pts[target_index].x;
    int new_index;
    /* Look for a new interesting grid */
    new_index = target_pick(old_y, old_x, ddy[dir], ddx[dir], targets);
    /* If none found, try in the next panel */
    if (new_index < 0) {
     int old_wy = Term->offset_y;
     int old_wx = Term->offset_x;
     if (change_panel(dir)) {
      /* Recalculate interesting grids */
      point_set_dispose(targets);
      targets = target_get_monsters(mode, NULL, true);
      /* Look for a new interesting grid again */
      new_index = target_pick(old_y, old_x, ddy[dir], ddx[dir], targets);
      /* If none found again, reset the panel and do nothing */
      if (new_index < 0 && modify_panel(Term, old_wy, old_wx)) {
       /* Recalculate interesting grids */
       point_set_dispose(targets);
       targets = target_get_monsters(mode, NULL, true);
      }
      handle_stuff(player);
     }
    }
    /* Use interesting grid if found */
    if (new_index >= 0) target_index = new_index;
   } else {
    int step = (is_running_keymap(press.key)) ?
     10 : 1;
    /* Free mode direction: Move cursor */
    grid.x += step * ddx[dir];
    grid.y += step * ddy[dir];
    /* Keep 1 away from the edge */
    grid.x = MAX(1, MIN(grid.x, cave->width - 2));
    grid.y = MAX(1, MIN(grid.y, cave->height - 2));
    /* Adjust panel if needed */
    if (adjust_panel_help(grid, help)) {
     handle_stuff(player);
     /* Recalculate interesting grids */
     point_set_dispose(targets);
     targets = target_get_monsters(mode, NULL, true);
    }
   }
  }
  /* End of while finally */
 }
 /* Forget */
 point_set_dispose(targets);
 /* Redraw as necessary */
 if (help) {
  player->upkeep->redraw |= (PR_BASIC | PR_EXTRA | PR_MAP | PR_EQUIP);
  Term_clear();
 } else {
  prt("", 0, 0);
  prt("", help_prompt_loc, 0);
  player->upkeep->redraw |= (PR_DEPTH | PR_STATUS);
 }
 /* Recenter around player */
 verify_panel();
 handle_stuff(player);
 mem_free(path_attr);
 mem_free(path_char);
 /* Allow animations again */
 allow_animations();
 return target_is_set();
}
/**
 * \file ui-term.c
 * \brief A generic, efficient, terminal window package
 *
 * Copyright (c) 1997 Ben Harrison
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * This file provides a generic, efficient, terminal window package,
 * which can be used not only on standard terminal environments such
 * as dumb terminals connected to a Unix box, but also in more modern
 * "graphic" environments, such as the Macintosh or Unix/X11.
 *
 * Each "window" works like a standard "dumb terminal", that is, it
 * can display a two dimensional array of grids containing colored
 * textual symbols, plus an optional cursor, and it can be used to
 * get keypress events from the user.
 *
 * In fact, this package can simply be used, if desired, to support
 * programs which will look the same on a dumb terminal as they do
 * on a graphic platform such as the Macintosh.
 *
 * This package was designed to help port the game "Angband" to a wide
 * variety of different platforms.  Angband, like many other games in
 * the "rogue-like" heirarchy, requires, at the minimum, the ability
 * to display "colored textual symbols" in a standard 80x24 "window",
 * such as that provided by most dumb terminals, and many old personal
 * computers, and to check for "keypresses" from the user.  The major
 * concerns were thus portability and efficiency, so Angband could be
 * easily ported to many different systems, with minimal effort, and
 * yet would run quickly on each of these systems, no matter what kind
 * of underlying hardware/software support was being used.
 *
 * It is important to understand the differences between the older
 * "dumb terminals" and the newer "graphic interface" machines, since
 * this package was designed to work with both types of systems.
 *
 * New machines:
 *   waiting for a keypress is complex
 *   checking for a keypress is often cheap
 *   changing "colors" may be expensive
 *   the "color" of a "blank" is rarely important
 *   moving the "cursor" is relatively cheap
 *   use a "software" cursor (only moves when requested)
 *   drawing characters normally will not erase old ones
 *   drawing a character on the cursor often erases it
 *   may have fast routines for "clear a region"
 *   the bottom right corner is usually not special
 *
 * Old machines:
 *   waiting for a keypress is simple
 *   checking for a keypress is often expensive
 *   changing "colors" is usually cheap
 *   the "color" of a "blank" may be important
 *   moving the "cursor" may be expensive
 *   use a "hardware" cursor (moves during screen updates)
 *   drawing new symbols automatically erases old ones
 *   characters may only be drawn at the cursor location
 *   drawing a character on the cursor will move the cursor
 *   may have fast routines for "clear entire window"
 *   may have fast routines for "clear to end of line"
 *   the bottom right corner is often dangerous
 *
 *
 * This package provides support for multiple windows, each of an
 * arbitrary size (up to 255x255), each with its own set of flags,
 * and its own hooks to handle several low-level procedures which
 * differ from platform to platform.  Then the main program simply
 * creates one or more "term" structures, setting the various flags
 * and hooks in a manner appropriate for the current platform, and
 * then it can use the various "term" structures without worrying
 * about the underlying platform.
 *
 *
 * This package allows each "grid" in each window to hold an attr/char
 * pair, with each ranging from 0 to 255, and makes very few assumptions
 * about the meaning of any attr/char values.  Normally, we assume that
 * "attr 0" is "black", with the semantics that "black" text should be
 * sent to "Term_wipe()" instead of "Term_text()", but this sematics is
 * modified if either the "always_pict" or the "always_text" flags are
 * set.  We assume that "char 0" is "dangerous", since placing such a
 * "char" in the middle of a string "terminates" the string, and usually
 * we prevent its use.
 *
 * Finally, we use a special attr/char pair, defaulting to "attr 0" and
 * "char 32", also known as "black space", when we "erase" or "clear"
 * any window, but this pair can be redefined to any pair, including
 * the standard "white space", or the bizarre "emptiness" ("attr 0"
 * and "char 0"), as long as various obscure restrictions are met.
 *
 *
 * This package provides several functions which allow a program to
 * interact with the "term" structures.  Most of the functions allow
 * the program to "request" certain changes to the current "term",
 * such as moving the cursor, drawing an attr/char pair, erasing a
 * region of grids, hiding the cursor, etc.  Then there is a special
 * function which causes all of the "pending" requests to be performed
 * in an efficient manner.  There is another set of functions which
 * allow the program to query the "requested state" of the current
 * "term", such as asking for the cursor location, or what attr/char
 * is at a given location, etc.  There is another set of functions
 * dealing with "keypress" events, which allows the program to ask if
 * the user has pressed any keys, or to forget any keys the user pressed.
 * There is a pair of functions to allow this package to memorize the
 * contents of the current "term", and to restore these contents at
 * a later time.  There is a special function which allows the program
 * to specify which "term" structure should be the "current" one.  At
 * the lowest level, there is a set of functions which allow a new
 * "term" to be initialized or destroyed, and which allow this package,
 * or a program, to access the special "hooks" defined for the current
 * "term", and a set of functions which those "hooks" can use to inform
 * this package of the results of certain occurances, for example, one
 * such function allows this package to learn about user keypresses,
 * detected by one of the special "hooks".
 *
 * We provide, among other things, the functions "Term_keypress()"
 * to "react" to keypress events, and "Term_redraw()" to redraw the
 * entire window, plus "Term_resize()" to note a new size.
 *
 *
 * Note that the current "term" contains two "window images".  One of
 * these images represents the "requested" contents of the "term", and
 * the other represents the "actual" contents of the "term", at the time
 * of the last performance of pending requests.  This package uses these
 * two images to determine the "minimal" amount of work needed to make
 * the "actual" contents of the "term" match the "requested" contents of
 * the "term".  This method is not perfect, but it often reduces the
 * amount of work needed to perform the pending requests, which thus
 * increases the speed of the program itself.  This package promises
 * that the requested changes will appear to occur either "all at once"
 * or in a "top to bottom" order.  In addition, a "cursor" is maintained,
 * and this cursor is updated along with the actual window contents.
 *
 * Currently, the "Term_fresh()" routine attempts to perform the "minimum"
 * number of physical updates, in terms of total "work" done by the hooks
 * Term_wipe(), Term_text(), and Term_pict(), making use of the fact that
 * adjacent characters of the same color can both be drawn together using
 * the "Term_text()" hook, and that "black" text can often be sent to the
 * "Term_wipe()" hook instead of the "Term_text()" hook, and if something
 * is already displayed in a window, then it is not necessary to display
 * it again.  Unfortunately, this may induce slightly non-optimal results
 * in some cases, in particular, those in which, say, a string of ten
 * characters needs to be written, but the fifth character has already
 * been displayed.  Currently, this will cause the "Term_text()" routine
 * to be called once for each half of the string, instead of once for the
 * whole string, which, on some machines, may be non-optimal behavior.
 *
 * The new formalism includes a "displayed" screen image (old) which
 * is actually seen by the user, a "requested" screen image (scr)
 * which is being prepared for display, a "memorized" screen image
 * (mem) which is used to save and restore screen images, and a
 * "temporary" screen image (tmp) which is currently unused.
 *
 *
 * Several "flags" are available in each "term" to allow the underlying
 * visual system (which initializes the "term" structure) to "optimize"
 * the performance of this package for the given system, or to request
 * certain behavior which is helpful/required for the given system.
 *
 * The "soft_cursor" flag indicates the use of a "soft" cursor, which
 * only moves when explicitly requested,and which is "erased" when
 * any characters are drawn on top of it.  This flag is used for all
 * "graphic" systems which handle the cursor by "drawing" it.
 *
 * The "icky_corner" flag indicates that the bottom right "corner"
 * of the windows are "icky", and "printing" anything there may
 * induce "messy" behavior, such as "scrolling".  This flag is used
 * for most old "dumb terminal" systems.
 *
 *
 * The "term" structure contains the following function "hooks":
 *
 *   Term->init_hook = Init the term
 *   Term->nuke_hook = Nuke the term
 *   Term->xtra_hook = Perform extra actions
 *   Term->curs_hook = Draw (or Move) the cursor
 *   Term->bigcurs_hook = Draw (or Move) the big cursor (bigtile mode)
 *   Term->wipe_hook = Draw some blank spaces
 *   Term->text_hook = Draw some text in the window
 *   Term->pict_hook = Draw some attr/chars in the window
 *   Term->dblh_hook = Test if attr/char pair represents a double-height tile
 *
 * The "Term->xtra_hook" hook provides a variety of different functions,
 * based on the first parameter (which should be taken from the various
 * TERM_XTRA_* defines) and the second parameter (which may make sense
 * only for some first parameters).  It is available to the program via
 * the "Term_xtra()" function, though some first parameters are only
 * "legal" when called from inside this package.
 *
 * The "Term->curs_hook" hook provides this package with a simple way
 * to "move" or "draw" the cursor to the grid "x,y", depending on the
 * setting of the "soft_cursor" flag.  Note that the cursor is never
 * redrawn if "nothing" has happened to the screen (even temporarily).
 * This hook is required.
 *
 * The "Term->wipe_hook" hook provides this package with a simple way
 * to "erase", starting at "x,y", the next "n" grids.  This hook assumes
 * that the input is valid.  This hook is required, unless the setting
 * of the "always_pict" or "always_text" flags makes it optional.
 *
 * The "Term->text_hook" hook provides this package with a simple way
 * to "draw", starting at "x,y", the "n" chars contained in "cp", using
 * the attr "a".  This hook assumes that the input is valid, and that
 * "n" is between 1 and 256 inclusive, but it should NOT assume that
 * the contents of "cp" are null-terminated.  This hook is required,
 * unless the setting of the "always_pict" flag makes it optional.
 *
 * The "Term->pict_hook" hook provides this package with a simple way
 * to "draw", starting at "x,y", the "n" attr/char pairs contained in
 * the arrays "ap" and "cp".  This hook assumes that the input is valid,
 * and that "n" is between 1 and 256 inclusive, but it should NOT assume
 * that the contents of "cp" are null-terminated.  This hook is optional,
 * unless the setting of the "always_pict" or "higher_pict" flags make
 * it required.  Note that recently, this hook was changed from taking
 * a int "a" and a char "c" to taking a length "n", an array of ints
 * "ap" and an array of chars "cp".  Old implementations of this hook
 * should now iterate over all "n" attr/char pairs.
 * The two new arrays "tap" and "tcp" can contain the attr/char pairs
 * of the terrain below the values in "ap" and "cp".  These values can
 * be used to implement transparency when using graphics by drawing
 * the terrain values as a background and the "ap", "cp" values in
 * the foreground.
 *
 * The "Term->dblh_hook" hook provides this package a way to query whether
 * an attr/char pair corresponds to a double-height tile when it determines what
 * has changed and needs to be redrawn.  This hook is optional.  Set to NULL,
 * if no pairs correspond to a double-height tile.  Non-NULL values will only
 * be used if either the "always_pict" or "higher_pict" flags are are on.
 * Another, less efficient way to handle double-height tiles is to use
 * Term_mark() to force a position affected by a double-height tile to be
 * redrawn at the next refresh.
 *
 * The game "Angband" uses a set of files called "main-xxx.c", for
 * various "xxx" suffixes.  Most of these contain a function called
 * "init_xxx()", that will prepare the underlying visual system for
 * use with Angband, and then create one or more "term" structures,
 * using flags and hooks appropriate to the given platform, so that
 * the "main()" function can call one (or more) of the "init_xxx()"
 * functions, as appropriate, to prepare the required "term" structs
 * (one for each desired sub-window), and these "init_xxx()" functions
 * are called from a centralized "main()" function in "main.c".  Other
 * "main-xxx.c" systems contain their own "main()" function which, in
 * addition to doing everything needed to initialize the actual program,
 * also does everything that the normal "init_xxx()" functions would do.
 *
 * The game "Angband" defines, in addition to "attr 0", all of the
 * attr codes from 1 to 15, using definitions in "defines.h", and
 * thus the "main-xxx.c" files used by Angband must handle these
 * attr values correctly.  Also, they must handle all other attr
 * values, though they may do so in any way they wish, for example,
 * by always taking every attr code mod 16.  Many of the "main-xxx.c"
 * files use "white space" ("attr 1" / "char 32") to "erase" or "clear"
 * any window, for efficiency.
 *
 * See "main-xxx.c" for a simple skeleton file which can be used to
 * create a "visual system" for a new platform when porting Angband.
 */
/**
 * The array[ANGBAND_TERM_MAX] of window pointers
 */
term *angband_term[ANGBAND_TERM_MAX];
/**
 * The array[ANGBAND_TERM_MAX] of window names (modifiable?)
 *
 * ToDo: Make the names independent of ANGBAND_TERM_MAX.
 */
char angband_term_name[ANGBAND_TERM_MAX][16] =
{
 VERSION_NAME,
 "Term-1",
 "Term-2",
 "Term-3",
 "Term-4",
 "Term-5",
 "Term-6",
 "Term-7"
};
uint32_t window_flag[ANGBAND_TERM_MAX];
int row_top_map[SIDEBAR_MAX] = {1, 4, 1};
int row_bottom_map[SIDEBAR_MAX] = {1, 0, 0};
int col_map[SIDEBAR_MAX] = {13, 0, 0};
/**
 * The current "term"
 */
term *Term = NULL;
/* grumbles */
int log_i = 0;
int log_size = 0;
struct keypress keylog[KEYLOG_SIZE];
/**
 * ------------------------------------------------------------------------
 * Local routines
 * ------------------------------------------------------------------------ */
/**
 * Nuke a term_win (see below)
 */
static errr term_win_nuke(term_win *s)
{
 /* Free the window access arrays */
 mem_free_alt(s->a);
 mem_free_alt(s->c);
 /* Free the window content arrays */
 mem_free_alt(s->va);
 mem_free_alt(s->vc);
 /* Free the terrain access arrays */
 mem_free_alt(s->ta);
 mem_free_alt(s->tc);
 /* Free the terrain content arrays */
 mem_free_alt(s->vta);
 mem_free_alt(s->vtc);
 /* Success */
 return (0);
}
/**
 * Initialize a "term_win" (using the given window size)
 */
static errr term_win_init(term_win *s, int w, int h)
{
 int y;
 /* Make the window access arrays */
 s->a = mem_zalloc_alt(h * sizeof(int*));
 s->c = mem_zalloc_alt(h * sizeof(wchar_t*));
 /* Make the window content arrays */
 s->va = mem_zalloc_alt(h * w * sizeof(int));
 s->vc = mem_zalloc_alt(h * w * sizeof(wchar_t));
 /* Make the terrain access arrays */
 s->ta = mem_zalloc_alt(h * sizeof(int*));
 s->tc = mem_zalloc_alt(h * sizeof(wchar_t*));
 /* Make the terrain content arrays */
 s->vta = mem_zalloc_alt(h * w * sizeof(int));
 s->vtc = mem_zalloc_alt(h * w * sizeof(wchar_t));
 /* Prepare the window access arrays */
 for (y = 0; y < h; y++) {
  s->a[y] = s->va + w * y;
  s->c[y] = s->vc + w * y;
  s->ta[y] = s->vta + w * y;
  s->tc[y] = s->vtc + w * y;
 }
 /* Success */
 return (0);
}
/**
 * Copy a "term_win" from another
 */
static errr term_win_copy(term_win *s, term_win *f, int w, int h)
{
 int x, y;
 /* Copy contents */
 for (y = 0; y < h; y++) {
  int *f_aa = f->a[y];
  wchar_t *f_cc = f->c[y];
  int *s_aa = s->a[y];
  wchar_t *s_cc = s->c[y];
  int *f_taa = f->ta[y];
  wchar_t *f_tcc = f->tc[y];
  int *s_taa = s->ta[y];
  wchar_t *s_tcc = s->tc[y];
  for (x = 0; x < w; x++) {
   *s_aa++ = *f_aa++;
   *s_cc++ = *f_cc++;
   *s_taa++ = *f_taa++;
   *s_tcc++ = *f_tcc++;
  }
 }
 /* Copy cursor */
 s->cnx = f->cnx;
 s->cny = f->cny;
 s->cx = f->cx;
 s->cy = f->cy;
 s->cu = f->cu;
 s->cv = f->cv;
 /* Success */
 return (0);
}
/**
 * ------------------------------------------------------------------------
 * Public functions operating on all terminals
 * ------------------------------------------------------------------------
 */
/**
 * Redraw all the terminals.
 */
extern errr Term_redraw_all(void)
{
 term *old = Term;
 errr combined = 0;
 int j;
 for (j = 0; j < ANGBAND_TERM_MAX; j++) {
  errr one_result;
  if (!angband_term[j]) continue;
  (void) Term_activate(angband_term[j]);
  one_result = Term_redraw();
  if (!one_result) {
   combined = one_result;
  }
 }
 (void) Term_activate(old);
 return combined;
}
/**
 * ------------------------------------------------------------------------
 * External hooks
 * ------------------------------------------------------------------------ */
/**
 * Execute the "Term->xtra_hook" hook, if available (see above).
 */
errr Term_xtra(int n, int v)
{
 /* Verify the hook */
 if (!Term->xtra_hook) return (-1);
 /* Call the hook */
 return ((*Term->xtra_hook)(n, v));
}
/**
 * ------------------------------------------------------------------------
 * Fake hooks
 * ------------------------------------------------------------------------ */
/**
 * Hack -- fake hook for "Term_curs()" (see above)
 */
static errr Term_curs_hack(int x, int y)
{
 /* Compiler silliness */
 if (x || y) return (-2);
 /* Oops */
 return (-1);
}
/**
 * Hack -- fake hook for "Term_wipe()" (see above)
 */
static errr Term_wipe_hack(int x, int y, int n)
{
 /* Compiler silliness */
 if (x || y || n) return (-2);
 /* Oops */
 return (-1);
}
/**
 * Hack -- fake hook for "Term_text()" (see above)
 */
static errr Term_text_hack(int x, int y, int n, int a, const wchar_t *cp)
{
 /* Compiler silliness */
 if (x || y || n || a || cp) return (-2);
 /* Oops */
 return (-1);
}
/**
 * Hack -- fake hook for "Term_pict()" (see above)
 */
static errr Term_pict_hack(int x, int y, int n, const int *ap,
         const wchar_t *cp, const int *tap,
         const wchar_t *tcp)
{
 /* Compiler silliness */
 if (x || y || n || ap || cp || tap || tcp) return (-2);
 /* Oops */
 return (-1);
}
/**
 * ------------------------------------------------------------------------
 * Efficient routines
 * ------------------------------------------------------------------------ */
/**
 * Mentally draw an attr/char at a given location
 *
 * Assumes given location and values are valid.
 */
void Term_queue_char(term *t, int x, int y, int a, wchar_t c, int ta,
      wchar_t tc)
{
 int *scr_aa = t->scr->a[y];
 wchar_t *scr_cc = t->scr->c[y];
 int oa = scr_aa[x];
 wchar_t oc = scr_cc[x];
 int *scr_taa = t->scr->ta[y];
 wchar_t *scr_tcc = t->scr->tc[y];
 int ota = scr_taa[x];
 wchar_t otc = scr_tcc[x];
 /* Don't change is the terrain value is 0 */
 if (!ta) ta = ota;
 if (!tc) tc = otc;
 /* Hack -- Ignore non-changes */
 if ((oa == a) && (oc == c) && (ota == ta) && (otc == tc)) return;
 /* Save the "literal" information */
 scr_aa[x] = a;
 scr_cc[x] = c;
 scr_taa[x] = ta;
 scr_tcc[x] = tc;
 /* Check for new min/max row info */
 if (y < t->y1) t->y1 = y;
 if (y > t->y2) t->y2 = y;
 /* Check for new min/max col info for this row */
 if (x < t->x1[y]) t->x1[y] = x;
 if (x > t->x2[y]) t->x2[y] = x;
 if (t->dblh_hook) {
  /*
		 * If the previous contents are a double-height tile also
		 * adjust the modified bounds to encompass the position on
		 * the previous row of tiles so it can be included when
		 * redrawing at the next refresh.
		 */
  if (y >= tile_height) {
   int ofg_dbl = (*t->dblh_hook)(oa, oc);
   int obg_dbl = (*t->dblh_hook)(ota, otc);
   if (ofg_dbl || obg_dbl) {
    int yp = y - tile_height;
    if (yp < t->y1) t->y1 = yp;
    if (x < t->x1[yp]) t->x1[yp] = x;
    if (x > t->x2[yp]) t->x2[yp] = x;
   }
  }
  /*
		 * If the next row had a double-height tile, expand the modified
		 * bounds to encompass it as well since at least its upper
		 * half will need to be redrawn for the change here.
		 */
  if (y < t->hgt - tile_height) {
   int yn = y + tile_height;
   int ofg_dbl_nr = (*t->dblh_hook)(
    t->old->a[yn][x], t->old->c[yn][x]);
   int obg_dbl_nr = (*t->dblh_hook)(
    t->old->ta[yn][x], t->old->tc[yn][x]);
   if (ofg_dbl_nr || obg_dbl_nr) {
    if (yn > t->y2) t->y2 = yn;
    if (x < t->x1[yn]) t->x1[yn] = x;
    if (x > t->x2[yn]) t->x2[yn] = x;
   }
  }
 }
}
/**
 * Queue a large-sized tile.
 * \param x Is the column for the upper left corner of the tile.
 * \param y Is the row for the upper left corner of the tile.
 * \param clipy Is the lower bound for rows that should not be modified when
 * writing the large-sized tile.
 * \param a Is the foreground attribute.
 * \param c Is the foreground character.
 * \param a1 Is the background attribute.
 * \param c1 Is the background character.
 */
void Term_big_queue_char(term *t, int x, int y, int clipy,
 int a, wchar_t c, int a1, wchar_t c1)
{
 int vmax;
 int hor, vert;
 /* Avoid warning */
 (void)c;
 /* Leave space on bottom if requested */
 vmax = (y + tile_height <= clipy) ? tile_height : clipy - y;
 /* No tall skinny tiles */
 if (tile_width > 1) {
         /* Horizontal first; skip already marked upper left corner */
         for (hor = 1; hor < tile_width; hor++) {
          /* Queue dummy character */
   if (a & 0x80)
    Term_queue_char(t, x + hor, y, 255, -1, 0, 0);
   else
    Term_queue_char(t, x + hor, y, COLOUR_WHITE, L' ', a1, c1);
  }
  /* Now vertical */
  for (vert = 1; vert < vmax; vert++) {
   for (hor = 0; hor < tile_width; hor++) {
    /* Queue dummy character */
    if (a & 0x80)
     Term_queue_char(t, x + hor, y + vert, 255, -1, 0, 0);
    else
     Term_queue_char(t, x + hor, y + vert, COLOUR_WHITE, L' ', a1, c1);
   }
  }
 } else {
  /* Only vertical */
  for (vert = 1; vert < vmax; vert++) {
   /* Queue dummy character */
   if (a & 0x80)
    Term_queue_char(t, x, y + vert, 255, -1, 0, 0);
   else
    Term_queue_char(t, x, y + vert, COLOUR_WHITE, L' ', a1, c1);
  }
 }
}
/**
 * Mentally draw some attr/chars at a given location
 *
 * Assumes that (x,y) is a valid location, that the first "n" characters
 * of the string "s" are all valid (non-zero), and that (x+n-1,y) is also
 * a valid location, so the first "n" characters of "s" can all be added
 * starting at (x,y) without causing any illegal operations.
 */
void Term_queue_chars(int x, int y, int n, int a, const wchar_t *s)
{
 int x1 = -1, x2 = -1;
 int *scr_aa = Term->scr->a[y];
 wchar_t *scr_cc = Term->scr->c[y];
 int *scr_taa = Term->scr->ta[y];
 wchar_t *scr_tcc = Term->scr->tc[y];
 /* Queue the attr/chars */
 for ( ; n; x++, s++, n--) {
  int oa = scr_aa[x];
  wchar_t oc = scr_cc[x];
  int ota = scr_taa[x];
  wchar_t otc = scr_tcc[x];
  /* Hack -- Ignore non-changes */
  if ((oa == a) && (oc == *s) && (ota == 0) && (otc == 0)) continue;
  /* Save the "literal" information */
  scr_aa[x] = a;
  scr_cc[x] = *s;
  scr_taa[x] = 0;
  scr_tcc[x] = 0;
  /* Note the "range" of window updates */
  if (x1 < 0) x1 = x;
  x2 = x;
 }
 /* Expand the "change area" as needed */
 if (x1 >= 0) {
  /* Check for new min/max row info */
  if (y < Term->y1) Term->y1 = y;
  if (y > Term->y2) Term->y2 = y;
  /* Check for new min/max col info in this row */
  if (x1 < Term->x1[y]) Term->x1[y] = x1;
  if (x2 > Term->x2[y]) Term->x2[y] = x2;
 }
}
/**
 * ------------------------------------------------------------------------
 * Refresh routines
 * ------------------------------------------------------------------------ */
/**
 * Flush a row of the current window (see "Term_fresh")
 *
 * Display text using "Term_pict()"
 */
static void Term_fresh_row_pict(int y, int x1, int x2)
{
 int x;
 int *old_aa = Term->old->a[y];
 wchar_t *old_cc = Term->old->c[y];
 int *scr_aa = Term->scr->a[y];
 wchar_t *scr_cc = Term->scr->c[y];
 int *old_taa = Term->old->ta[y];
 wchar_t *old_tcc = Term->old->tc[y];
 int *scr_taa = Term->scr->ta[y];
 wchar_t *scr_tcc = Term->scr->tc[y];
 int ota;
 wchar_t otc;
 int nta;
 wchar_t ntc;
 /* Pending length */
 int fn = 0;
 /* Pending start */
 int fx = 0;
 int oa;
 wchar_t oc;
 int na;
 wchar_t nc;
 /* Scan "modified" columns */
 for (x = x1; x <= x2; x++) {
  /* See what is currently here */
  oa = old_aa[x];
  oc = old_cc[x];
  /* See what is desired there */
  na = scr_aa[x];
  nc = scr_cc[x];
  ota = old_taa[x];
  otc = old_tcc[x];
  nta = scr_taa[x];
  ntc = scr_tcc[x];
  /* Handle unchanged grids */
  if ((na == oa) && (nc == oc) && (nta == ota) && (ntc == otc)) {
   /* Flush */
   if (fn) {
    /* Draw pending attr/char pairs */
    (void)((*Term->pict_hook)(fx, y, fn, &scr_aa[fx], &scr_cc[fx],
            &scr_taa[fx], &scr_tcc[fx]));
    /* Forget */
    fn = 0;
   }
   /* Skip */
   continue;
  }
  /* Save new contents */
  old_aa[x] = na;
  old_cc[x] = nc;
  old_taa[x] = nta;
  old_tcc[x] = ntc;
  /* Restart and Advance */
  if (fn++ == 0) fx = x;
 }
 /* Flush */
 if (fn) {
  /* Draw pending attr/char pairs */
  (void)((*Term->pict_hook)(fx, y, fn, &scr_aa[fx], &scr_cc[fx],
          &scr_taa[fx], &scr_tcc[fx]));
 }
}
/**
 * Flush a row of the current window when checking for double-height tiles
 * (see "Term_fresh")
 *
 * Display text using "Term_pict()"
 */
static void Term_fresh_row_pict_dblh(int y, int x1, int x2, int *pr_drw)
{
 int x;
 int *old_aa = Term->old->a[y];
 wchar_t *old_cc = Term->old->c[y];
 const int *scr_aa = Term->scr->a[y];
 const wchar_t *scr_cc = Term->scr->c[y];
 int *old_taa = Term->old->ta[y];
 wchar_t *old_tcc = Term->old->tc[y];
 const int *scr_taa = Term->scr->ta[y];
 const wchar_t *scr_tcc = Term->scr->tc[y];
 const int *scr_aa_nr;
 const wchar_t *scr_cc_nr;
 const int *scr_taa_nr;
 const wchar_t *scr_tcc_nr;
 const int *old_aa_nr;
 const wchar_t *old_cc_nr;
 const int *old_taa_nr;
 const wchar_t *old_tcc_nr;
 /* Pending length */
 int fn = 0;
 /* Pending start */
 int fx = 0;
 if (y < Term->hgt - tile_height) {
  scr_aa_nr = Term->scr->a[y + tile_height];
  scr_cc_nr = Term->scr->c[y + tile_height];
  scr_taa_nr = Term->scr->ta[y + tile_height];
  scr_tcc_nr = Term->scr->tc[y + tile_height];
  old_aa_nr = Term->old->a[y + tile_height];
  old_cc_nr = Term->old->c[y + tile_height];
  old_taa_nr = Term->old->ta[y + tile_height];
  old_tcc_nr = Term->old->tc[y + tile_height];
 } else {
  /*
		 * Can't examine the next row of tiles because it would be
		 * out of bounds.  To avoid writing much the same code but
		 * with the checks on the next row skipped, fake it so the
		 * next row looks unmodified.
		 */
  scr_aa_nr = scr_aa;
  scr_cc_nr = scr_cc;
  scr_taa_nr = scr_taa;
  scr_tcc_nr = scr_tcc;
  old_aa_nr = scr_aa_nr;
  old_cc_nr = scr_cc_nr;
  old_taa_nr = scr_taa_nr;
  old_tcc_nr = scr_tcc_nr;
 }
 /*
	 * For unmodified columns at the start, set flags so processing of the
	 * next row knows they were not redrawn.
	 */
 for (x = 0; x < x1; x++) {
  pr_drw[x] = 0;
 }
 /* Scan "modified" columns */
 for (x = x1; x <= x2; x++) {
  /* See what is currently here. */
  int oa = old_aa[x];
  wchar_t oc = old_cc[x];
  int ota = old_taa[x];
  wchar_t otc = old_tcc[x];
  /* See what is desired here. */
  int na = scr_aa[x];
  wchar_t nc = scr_cc[x];
  int nta = scr_taa[x];
  wchar_t ntc = scr_tcc[x];
  int draw;
  if (na == oa && nc == oc && nta == ota && ntc == otc) {
   /*
			 * That element did not change.  If it is double-height
			 * and the previous row was drawn will have to redraw
			 * to get the upper half of this one drawn correctly.
			 */
   if (pr_drw[x] &&
     ((*Term->dblh_hook)(na, nc) ||
     (*Term->dblh_hook)(nta, ntc))) {
    draw = 1;
   } else {
    /*
				 * If the next row had double-height tiles and
				 * those have changed, also have to redraw
				 * (either to clear what was there if now gone
				 * or to get the correct backdrop for the new
				 * double-height tile there now).
				 */
    /* See what is in the next row. */
    int oa_nr = old_aa_nr[x];
    wchar_t oc_nr = old_cc_nr[x];
    int ota_nr = old_taa_nr[x];
    wchar_t otc_nr = old_tcc_nr[x];
    /* See what is desired in the next row. */
    int na_nr = scr_aa_nr[x];
    wchar_t nc_nr = scr_cc_nr[x];
    int nta_nr = scr_taa_nr[x];
    wchar_t ntc_nr = scr_tcc_nr[x];
    if (((*Term->dblh_hook)(oa_nr, oc_nr) ||
      (*Term->dblh_hook)(ota_nr, otc_nr)) &&
      (na_nr != oa_nr ||
      nc_nr != oc_nr ||
      nta_nr != ota_nr ||
      ntc_nr != otc_nr)) {
     draw = 1;
    } else {
     draw = 0;
    }
   }
   /* Remember if this element was redrawn or not. */
   pr_drw[x] = draw;
  } else {
   draw = 1;
   /* Remember that this element was redrawn. */
   pr_drw[x] = 1;
  }
  /* Handle grids that don't have to be drawn. */
  if (!draw) {
   /* Flush */
   if (fn) {
    /* Draw pending attr/char pairs */
    (void)((*Term->pict_hook)(fx, y, fn,
     &scr_aa[fx], &scr_cc[fx], &scr_taa[fx],
     &scr_tcc[fx]));
    /* Forget */
    fn = 0;
   }
   /* Skip */
   continue;
  }
  /* Save new contents */
  old_aa[x] = na;
  old_cc[x] = nc;
  old_taa[x] = nta;
  old_tcc[x] = ntc;
  /* Restart and Advance */
  if (fn++ == 0) fx = x;
 }
 /* Flush */
 if (fn) {
  /* Draw pending attr/char pairs */
  (void)((*Term->pict_hook)(fx, y, fn, &scr_aa[fx], &scr_cc[fx],
   &scr_taa[fx], &scr_tcc[fx]));
 }
 /*
	 * For unmodified columns at the end, set flags so processing of the
	 * next row knows they weren't redrawn.
	 */
 for (x = x2 + 1; x < Term->wid; x++) {
  pr_drw[x] = 0;
 }
}
/**
 * Helper function for Term_fresh_row_both() and Term_fresh_row_both_dblh():
 * check padding of big tile for changes.
 * \param t Is the terminal to check.
 * \param y Is the row coordinate for the upper left corner of the big tile.
 * \param x Is the column coordinate for the upper left corner of the big tile.
 * \return Returns a nonzero value if there is a change in one or more grids
 * whose desired contents are padding for the big tile.
 */
static int is_padding_changed(term *t, int y, int x)
{
 int xsl = MIN(x + tile_width, t->wid);
 int ysl = MIN(y + tile_height, t->hgt);
 int xs, ys;
 for (xs = x + 1; xs < xsl; ++xs) {
  if (t->scr->a[y][xs] == 255 &&
    (t->scr->a[y][xs] != t->old->a[y][xs] ||
    t->scr->c[y][xs] != t->old->c[y][xs] ||
    t->scr->ta[y][xs] != t->old->ta[y][xs] ||
    t->scr->tc[y][xs] != t->old->tc[y][xs])) {
   return 1;
  }
 }
 for (ys = y + 1; ys < ysl; ++ys) {
  for (xs = x; xs < xsl; ++xs) {
   if (t->scr->a[ys][xs] == 255 &&
     (t->scr->a[ys][xs] != t->old->a[ys][xs] ||
     t->scr->c[ys][xs] != t->old->c[ys][xs] ||
     t->scr->ta[ys][xs] != t->old->ta[ys][xs] ||
     t->scr->tc[ys][xs] != t->old->tc[ys][xs])) {
    return 1;
   }
  }
 }
 return 0;
}
/**
 * Flush a row of the current window (see "Term_fresh")
 *
 * Display text using "Term_text()" and "Term_wipe()",
 * but use "Term_pict()" for high-bit attr/char pairs
 */
static void Term_fresh_row_both(int y, int x1, int x2)
{
 int x;
 int *old_aa = Term->old->a[y];
 wchar_t *old_cc = Term->old->c[y];
 int *scr_aa = Term->scr->a[y];
 wchar_t *scr_cc = Term->scr->c[y];
 int *old_taa = Term->old->ta[y];
 wchar_t *old_tcc = Term->old->tc[y];
 int *scr_taa = Term->scr->ta[y];
 wchar_t *scr_tcc = Term->scr->tc[y];
 int ota;
 wchar_t otc;
 int nta;
 wchar_t ntc;
 /* The "always_text" flag */
 int always_text = Term->always_text;
 /* Pending length */
 int fn = 0;
 /* Pending start */
 int fx = 0;
 /* Pending attr */
 int fa = COLOUR_WHITE;
 int oa;
 wchar_t oc;
 int na;
 wchar_t nc;
 /* Scan "modified" columns */
 for (x = x1; x <= x2; x++) {
  /* See what is currently here */
  oa = old_aa[x];
  oc = old_cc[x];
  /* See what is desired there */
  na = scr_aa[x];
  nc = scr_cc[x];
  ota = old_taa[x];
  otc = old_tcc[x];
  nta = scr_taa[x];
  ntc = scr_tcc[x];
  /* Handle unchanged grids */
  if ((na == oa) && (nc == oc) && (nta == ota) && (ntc == otc)) {
   int draw;
   /*
			 * If (x,y) is the upper left corner of a big tile,
			 * check for change in its padded area.
			 */
   if ((na & 0x80) && na != 255) {
    draw = is_padding_changed(Term, y, x);
   } else {
    draw = 0;
   }
   /* Flush */
   if (fn) {
    /* Draw pending chars (normal or black) */
    if (fa || always_text)
     (void)((*Term->text_hook)(fx, y, fn, fa, &scr_cc[fx]));
    else
     (void)((*Term->wipe_hook)(fx, y, fn));
    /* Forget */
    fn = 0;
   }
   if (draw) {
    /*
				 * Since a change occurred in the padded area,
				 * redraw the whole tile even though the upper
				 * left is unchanged.
				 */
    (void)((*Term->pict_hook)(x, y, 1, &na, &nc,
     &nta, &ntc));
   }
   /* Skip */
   continue;
  }
  /* Save new contents */
  old_aa[x] = na;
  old_cc[x] = nc;
  old_taa[x] = nta;
  old_tcc[x] = ntc;
  /* Handle high-bit attr/chars */
  if ((na & 0x80)) {
   /* Flush */
   if (fn) {
    /* Draw pending chars (normal or black) */
    if (fa || always_text)
     (void)((*Term->text_hook)(fx, y, fn, fa, &scr_cc[fx]));
    else
     (void)((*Term->wipe_hook)(fx, y, fn));
    /* Forget */
    fn = 0;
   }
   /* 2nd byte of bigtile */
   if (na == 255) continue;
   /* Hack -- Draw the special attr/char pair */
   (void)((*Term->pict_hook)(x, y, 1, &na, &nc, &nta, &ntc));
   /* Skip */
   continue;
  }
  /* Notice new color */
  if (fa != na) {
   /* Flush */
   if (fn) {
    /* Draw the pending chars, erase leading spaces */
    if (fa || always_text)
     (void)((*Term->text_hook)(fx, y, fn, fa, &scr_cc[fx]));
    else
     (void)((*Term->wipe_hook)(fx, y, fn));
    /* Forget */
    fn = 0;
   }
   /* Save the new color */
   fa = na;
  }
  /* Restart and Advance */
  if (fn++ == 0) fx = x;
 }
 /* Flush */
 if (fn) {
  /* Draw pending chars (normal or black) */
  if (fa || always_text)
   (void)((*Term->text_hook)(fx, y, fn, fa, &scr_cc[fx]));
  else
   (void)((*Term->wipe_hook)(fx, y, fn));
 }
}
/**
 * Flush a row of the current window when checking for double-height tiles
 * (see "Term_fresh")
 *
 * Display text using "Term_text()" and "Term_wipe()",
 * but use "Term_pict()" for high-bit attr/char pairs
 */
static void Term_fresh_row_both_dblh(int y, int x1, int x2, int *pr_drw)
{
 int x;
 int *old_aa = Term->old->a[y];
 wchar_t *old_cc = Term->old->c[y];
 const int *scr_aa = Term->scr->a[y];
 const wchar_t *scr_cc = Term->scr->c[y];
 int *old_taa = Term->old->ta[y];
 wchar_t *old_tcc = Term->old->tc[y];
 const int *scr_taa = Term->scr->ta[y];
 const wchar_t *scr_tcc = Term->scr->tc[y];
 const int *scr_aa_nr;
 const wchar_t *scr_cc_nr;
 const int *scr_taa_nr;
 const wchar_t *scr_tcc_nr;
 const int *old_aa_nr;
 const wchar_t *old_cc_nr;
 const int *old_taa_nr;
 const wchar_t *old_tcc_nr;
 /* The "always_text" flag */
 int always_text = Term->always_text;
 /* Pending length */
 int fn = 0;
 /* Pending start */
 int fx = 0;
 /* Pending attr */
 int fa = COLOUR_WHITE;
 if (y < Term->hgt - tile_height) {
  scr_aa_nr = Term->scr->a[y + tile_height];
  scr_cc_nr = Term->scr->c[y + tile_height];
  scr_taa_nr = Term->scr->ta[y + tile_height];
  scr_tcc_nr = Term->scr->tc[y + tile_height];
  old_aa_nr = Term->old->a[y + tile_height];
  old_cc_nr = Term->old->c[y + tile_height];
  old_taa_nr = Term->old->ta[y + tile_height];
  old_tcc_nr = Term->old->tc[y + tile_height];
 } else {
  /*
		 * Can't examine the next row of tiles because it would be
		 * out of bounds.  To avoid writing much the same code but
		 * with the checks on the next row skipped, fake it so the
		 * next row looks unmodified.
		 */
  scr_aa_nr = scr_aa;
  scr_cc_nr = scr_cc;
  scr_taa_nr = scr_taa;
  scr_tcc_nr = scr_tcc;
  old_aa_nr = scr_aa_nr;
  old_cc_nr = scr_cc_nr;
  old_taa_nr = scr_taa_nr;
  old_tcc_nr = scr_tcc_nr;
 }
 /*
	 * For unmodified columns at the start, set flags so processing of the
	 * next row knows they weren't redrawn.
	 */
 for (x = 0; x < x1; x++) {
  pr_drw[x] = 0;
 }
 /* Scan "modified" columns */
 for (x = x1; x <= x2; x++) {
  /* See what is currently here. */
  int oa = old_aa[x];
  wchar_t oc = old_cc[x];
  int ota = old_taa[x];
  wchar_t otc = old_tcc[x];
  /* See what is desired here. */
  int na = scr_aa[x];
  wchar_t nc = scr_cc[x];
  int nta = scr_taa[x];
  wchar_t ntc = scr_tcc[x];
  int draw;
  if (na == oa && nc == oc && nta == ota && ntc == otc) {
   /*
			 * That element did not change.  If it is double-height
			 * and the previous row was drawn, still have to redraw
			 * to get the upper half of this one drawn correctly.
			 */
   if (pr_drw[x] &&
     ((*Term->dblh_hook)(na, nc) ||
     (*Term->dblh_hook)(nta, ntc))) {
    draw = 1;
   } else {
    /*
				 * If the next row had double-height tiles and
				 * those have changed, also have to redraw
				 * (either to clear what was where if now gone
				 * or to get the correct background for the new
				 * double-height tile there now).
				 */
    /* See what is in the next row. */
    int oa_nr = old_aa_nr[x];
    wchar_t oc_nr = old_cc_nr[x];
    int ota_nr = old_taa_nr[x];
    wchar_t otc_nr = old_tcc_nr[x];
    /* See what is desired in the next row. */
    int na_nr = scr_aa_nr[x];
    wchar_t nc_nr = scr_cc_nr[x];
    int nta_nr = scr_taa_nr[x];
    wchar_t ntc_nr = scr_tcc_nr[x];
    if (((*Term->dblh_hook)(oa_nr, oc_nr) ||
      (*Term->dblh_hook)(ota_nr, otc_nr)) &&
      (na_nr != oa_nr ||
      nc_nr != oc_nr ||
      nta_nr != ota_nr ||
      ntc_nr != otc_nr)) {
     draw = 1;
    } else {
     /*
					 * If (x,y) is the upper left corner of
					 * a big tile, check for change in its
					 * padded area.
					 */
     if ((na & 0x80) && na != 255) {
      draw = is_padding_changed(
       Term, y, x);
     } else {
      draw = 0;
     }
    }
   }
   /* Remember if this element was redrawn or not. */
   pr_drw[x] = draw;
  } else {
   draw = 1;
   /* Remember that this element was redrawn. */
   pr_drw[x] = 1;
  }
  /* Handle grids that don't have to be drawn. */
  if (!draw) {
   /* Flush */
   if (fn) {
    /* Draw pending chars (normal or black) */
    if (fa || always_text) {
     (void)((*Term->text_hook)(fx, y, fn, fa,
      &scr_cc[fx]));
    } else {
     (void)((*Term->wipe_hook)(fx, y, fn));
    }
    /* Forget */
    fn = 0;
   }
   /* Skip */
   continue;
  }
  /* Save new contents */
  old_aa[x] = na;
  old_cc[x] = nc;
  old_taa[x] = nta;
  old_tcc[x] = ntc;
  /* Handle high-bit attr/chars */
  if ((na & 0x80)) {
   /* Flush */
   if (fn) {
    /* Draw pending chars (normal or black) */
    if (fa || always_text) {
     (void)((*Term->text_hook)(fx, y, fn, fa,
      &scr_cc[fx]));
    } else {
     (void)((*Term->wipe_hook)(fx, y, fn));
    }
    /* Forget */
    fn = 0;
   }
   /* Skip padding element for big tiles. */
   if (na == 255) continue;
   /* Hack -- Draw the special attr/char pair */
   (void)((*Term->pict_hook)(x, y, 1, &na, &nc, &nta,
    &ntc));
   /* Skip */
   continue;
  }
  /* Notice new color */
  if (fa != na) {
   /* Flush */
   if (fn) {
    /*
				 * Draw the pending chars, erase leading spaces
				 */
    if (fa || always_text) {
     (void)((*Term->text_hook)(fx, y, fn, fa,
      &scr_cc[fx]));
    } else {
     (void)((*Term->wipe_hook)(fx, y, fn));
    }
    /* Forget */
    fn = 0;
   }
   /* Save the new color */
   fa = na;
  }
  /* Restart and Advance */
  if (fn++ == 0) fx = x;
 }
 /* Flush */
 if (fn) {
  /* Draw pending chars (normal or black) */
  if (fa || always_text) {
   (void)((*Term->text_hook)(fx, y, fn, fa, &scr_cc[fx]));
  } else {
   (void)((*Term->wipe_hook)(fx, y, fn));
  }
 }
 /*
	 * For unmodified columns at end, set flags so processing of the next
	 * knows they weren't redrawn.
	 */
 for (x = x2 + 1; x < Term->wid; x++) {
  pr_drw[x] = 0;
 }
}
/**
 * Flush a row of the current window (see "Term_fresh")
 *
 * Display text using "Term_text()" and "Term_wipe()"
 */
static void Term_fresh_row_text(int y, int x1, int x2)
{
 int x;
 int *old_aa = Term->old->a[y];
 wchar_t *old_cc = Term->old->c[y];
 int *scr_aa = Term->scr->a[y];
 wchar_t *scr_cc = Term->scr->c[y];
 /* The "always_text" flag */
 int always_text = Term->always_text;
 /* Pending length */
 int fn = 0;
 /* Pending start */
 int fx = 0;
 /* Pending attr */
 int fa = COLOUR_WHITE;
 int oa;
 wchar_t oc;
 int na;
 wchar_t nc;
 /* Scan "modified" columns */
 for (x = x1; x <= x2; x++) {
  /* See what is currently here */
  oa = old_aa[x];
  oc = old_cc[x];
  /* See what is desired there */
  na = scr_aa[x];
  nc = scr_cc[x];
  /* Handle unchanged grids */
  if ((na == oa) && (nc == oc)) {
   /* Flush */
   if (fn) {
    /* Draw pending chars (normal or black) */
    if (fa || always_text)
     (void)((*Term->text_hook)(fx, y, fn, fa, &scr_cc[fx]));
    else
     (void)((*Term->wipe_hook)(fx, y, fn));
    /* Forget */
    fn = 0;
   }
   /* Skip */
   continue;
  }
  /* Save new contents */
  old_aa[x] = na;
  old_cc[x] = nc;
  /* Notice new color */
  if (fa != na) {
   /* Flush */
   if (fn) {
    /* Draw the pending chars, erase leading spaces */
    if (fa || always_text)
     (void)((*Term->text_hook)(fx, y, fn, fa, &scr_cc[fx]));
    else
     (void)((*Term->wipe_hook)(fx, y, fn));
    /* Forget */
    fn = 0;
   }
   /* Save the new color */
   fa = na;
  }
  /* Restart and Advance */
  if (fn++ == 0) fx = x;
 }
 /* Flush */
 if (fn) {
  /* Draw pending chars (normal or black) */
  if (fa || always_text)
   (void)((*Term->text_hook)(fx, y, fn, fa, &scr_cc[fx]));
  else
   (void)((*Term->wipe_hook)(fx, y, fn));
 }
}
/**
 * Mark a spot as needing refresh (see "Term_fresh")
 */
errr Term_mark(int x, int y)
{
 int *old_aa = Term->old->a[y];
 wchar_t *old_cc = Term->old->c[y];
 int *old_taa = Term->old->ta[y];
 wchar_t *old_tcc = Term->old->tc[y];
 /*
	 * using 0x80 as the blank attribute and an impossible value for
	 * the blank char is ok since this function is only called by tile
	 * functions, but ideally there should be a test to use the blank text
	 * attr/char pair
	 */
 old_aa[x] = 0x80;
 old_cc[x] = 0;
 old_taa[x] = 0x80;
 old_tcc[x] = 0;
 /* Update bounds for modified region. */
 if (y < Term->y1) Term->y1 = y;
 if (y > Term->y2) Term->y2 = y;
 if (x < Term->x1[y]) Term->x1[y] = x;
 if (x > Term->x2[y]) Term->x2[y] = x;
 return (0);
}
uint8_t tile_width = 1; /* Tile width in units of font width */
uint8_t tile_height = 1; /* Tile height in units of font height */
/**
 * Helper variables for large cursor
 */
bool bigcurs = false;
bool smlcurs = true;
/**
 * Actually perform all requested changes to the window
 *
 * If absolutely nothing has changed, not even temporarily, or if the
 * current "Term" is not mapped, then this function will return 1 and
 * do absolutely nothing.
 *
 * Note that when "soft_cursor" is true, we erase the cursor (if needed)
 * whenever anything has changed, and redraw it (if needed) after all of
 * the screen updates are complete.  This will induce a small amount of
 * "cursor flicker" but only when the screen has been updated.  If the
 * screen is updated and then restored, you may still get this flicker.
 *
 * When "soft_cursor" is not true, we make the cursor invisible before
 * doing anything else if it is supposed to be invisible by the time we
 * are done, and we make it visible after moving it to its final location
 * after all of the screen updates are complete.
 *
 * Note that "Term_xtra(TERM_XTRA_CLEAR,0)" must erase the entire screen,
 * including the cursor, if needed, and may place the cursor anywhere.
 *
 * Note that "Term_xtra(TERM_XTRA_FROSH,y)" will be always be called
 * after any row "y" has been "flushed", unless the "Term->never_frosh"
 * flag is set, and "Term_xtra(TERM_XTRA_FRESH,0)" will be called after
 * all of the rows have been "flushed".
 *
 * Note the use of three different functions to handle the actual flush,
 * based on the settings of the "Term->always_pict" and "Term->higher_pict"
 * flags (see below).
 *
 * The three helper functions (above) work by collecting similar adjacent
 * grids into stripes, and then sending each stripe to "Term->pict_hook",
 * "Term->text_hook", or "Term->wipe_hook", based on the settings of the
 * "Term->always_pict" and "Term->higher_pict" flags, which select which
 * of the helper functions to call to flush each row.
 *
 * The helper functions currently "skip" any grids which already contain
 * the desired contents.  This may or may not be the best method, especially
 * when the desired content fits nicely into the current stripe.  For example,
 * it might be better to go ahead and queue them while allowed, but keep a
 * count of the "trailing skipables", then, when time to flush, or when a
 * "non skippable" is found, force a flush if there are too many skippables.
 *
 * Perhaps an "initialization" stage, where the "text" (and "attr")
 * buffers are "filled" with information, converting "blanks" into
 * a convenient representation, and marking "skips" with "zero chars",
 * and then some "processing" is done to determine which chars to skip.
 *
 * Currently, the helper functions are optimal for systems which prefer
 * to "print a char + move a char + print a char" to "print three chars",
 * and for applications that do a lot of "detailed" color printing.
 *
 * In the two "queue" functions, total "non-changes" are "pre-skipped".
 * The helper functions must also handle situations in which the contents
 * of a grid are changed, but then changed back to the original value,
 * and situations in which two grids in the same row are changed, but
 * the grids between them are unchanged.
 *
 * If the "Term->always_pict" flag is set, then "Term_fresh_row_pict()"
 * will be used instead of "Term_fresh_row_text()".  This allows all the
 * modified grids to be collected into stripes of attr/char pairs, which
 * are then sent to the "Term->pict_hook" hook, which can draw these pairs
 * in whatever way it would like.
 *
 * If the "Term->higher_pict" flag is set, then "Term_fresh_row_both()"
 * will be used instead of "Term_fresh_row_text()".  This allows all the
 * "special" attr/char pairs (in which both the attr and char have the
 * high-bit set) to be sent (one pair at a time) to the "Term->pict_hook"
 * hook, which can draw these pairs in whatever way it would like.
 *
 * Normally, the "Term_wipe()" function is used only to display "blanks" that
 * were induced by "Term_clear()" or "Term_erase()". Actually, the
 * "Term_wipe()" function is used to display all "black" text, such as the
 * default "spaces" created by "Term_clear()" and "Term_erase()".
 *
 * Note that the "Term->always_text" flag will disable the use of the
 * "Term_wipe()" function hook entirely, and force all text, even text
 * drawn in the color "black", to be explicitly drawn.  This is useful
 * for machines which implement "Term_wipe()" by just drawing spaces.
 *
 * Note that the "Term->always_pict" flag will disable the use of the
 * "Term_wipe()" function entirely, and force everything, even text
 * drawn in the attr "black", to be explicitly drawn.
 *
 * This function does nothing unless the "Term" is "mapped", which allows
 * certain systems to optimize the handling of "closed" windows.
 *
 * On systems with a "soft" cursor, we must explicitly erase the cursor
 * before flushing the output, if needed, to prevent a "jumpy" refresh.
 * The actual method for this is horrible, but there is very little that
 * we can do to simplify it efficiently.  XXX XXX XXX
 *
 * On systems with a "hard" cursor, we will "hide" the cursor before
 * flushing the output, if needed, to avoid a "flickery" refresh.  It
 * would be nice to *always* hide the cursor during the refresh, but
 * this might be expensive (and/or ugly) on some machines.
 *
 * The "Term->icky_corner" flag is used to avoid calling "Term_wipe()"
 * or "Term_pict()" or "Term_text()" on the bottom right corner of the
 * window, which might induce "scrolling" or other nasty stuff on old
 * dumb terminals.  This flag is handled very efficiently.  We assume
 * that the "Term_curs()" call will prevent placing the cursor in the
 * corner, if needed, though I doubt such placement is ever a problem.
 * Currently, the use of "Term->icky_corner" and "Term->soft_cursor"
 * together may result in undefined behavior.
 */
errr Term_fresh(void)
{
 int x, y;
 int w = Term->wid;
 int h = Term->hgt;
 int y1 = Term->y1;
 int y2 = Term->y2;
 term_win *old = Term->old;
 term_win *scr = Term->scr;
 /* Do nothing unless "mapped" */
 if (!Term->mapped_flag) return (1);
 /* Trivial Refresh */
 if ((y1 > y2) &&
     (scr->cu == old->cu) &&
     (scr->cv == old->cv) &&
     (scr->cx == old->cx) &&
     (scr->cy == old->cy) &&
     (scr->cnx == old->cnx) &&
     (scr->cny == old->cny) &&
     !(Term->total_erase)) {
  /* Nothing */
  return (1);
 }
 /* Paranoia -- use "fake" hooks to prevent core dumps */
 if (!Term->curs_hook) Term->curs_hook = Term_curs_hack;
 if (!Term->bigcurs_hook) Term->bigcurs_hook = Term->curs_hook;
 if (!Term->wipe_hook) Term->wipe_hook = Term_wipe_hack;
 if (!Term->text_hook) Term->text_hook = Term_text_hack;
 if (!Term->pict_hook) Term->pict_hook = Term_pict_hack;
 /* Handle "total erase" */
 if (Term->total_erase) {
  /* Physically erase the entire window */
  Term_xtra(TERM_XTRA_CLEAR, 0);
  /* Hack -- clear all "cursor" data */
  old->cv = old->cu = false;
  old->cx = old->cy = 0;
  old->cnx = old->cny = 1;
  /* Wipe each row */
  for (y = 0; y < h; y++) {
   int *aa = old->a[y];
   wchar_t *cc = old->c[y];
   int *taa = old->ta[y];
   wchar_t *tcc = old->tc[y];
   /* Wipe each column */
   for (x = 0; x < w; x++) {
    /* Wipe each grid */
    *aa++ = COLOUR_WHITE;
    *cc++ = ' ';
    *taa++ = COLOUR_WHITE;
    *tcc++ = ' ';
   }
  }
  /* Redraw every row */
  Term->y1 = y1 = 0;
  Term->y2 = y2 = h - 1;
  /* Redraw every column */
  for (y = 0; y < h; y++) {
   Term->x1[y] = 0;
   Term->x2[y] = w - 1;
  }
  /* Forget "total erase" */
  Term->total_erase = false;
 }
 /* Cursor update -- Erase old Cursor */
 if (Term->soft_cursor) {
  /* Cursor was visible */
  if (!old->cu && old->cv) {
          /*
		         * Fake a change at the old cursor position so that
		         * position will be redrawn along with any other
			 * changes.
			 */
   int mty = MAX(old->cy,
    MIN(old->cy + old->cny - 1, h - 1));
   int mtx = MAX(old->cx,
    MIN(old->cx + old->cnx - 1, w - 1));
   int ty;
   for (ty = old->cy; ty <= mty; ++ty) {
    int tx;
    for (tx = old->cx; tx <= mtx; ++tx) {
     old->c[ty][tx] = ~scr->c[ty][tx];
    }
    if (Term->x1[ty] > old->cx) {
     Term->x1[ty] = old->cx;
    }
    if (Term->x2[ty] < mtx) {
     Term->x2[ty] = mtx;
    }
   }
   if (y1 > old->cy) {
       y1 = old->cy;
   }
   if (y2 < mty) {
       y2 = mty;
   }
  }
 } else {
  /* Cursor will be invisible */
  if (scr->cu || !scr->cv)
   Term_xtra(TERM_XTRA_SHAPE, 0);
 }
 /* Something to update */
 if (y1 <= y2) {
  int **pr_drw;
  int ipr;
  if (Term->dblh_hook && (Term->always_pict ||
    Term->higher_pict)) {
   /*
			 * Have to track whether each location in the previous
			 * tile_height rows was redrawn.  First dimension in
			 * pr_drw will be treated circularly so there's no
			 * need for copying or swapping pointers.
			 */
   pr_drw = mem_alloc(tile_height * sizeof(*pr_drw));
   for (y = 0; y < tile_height; ++y) {
    pr_drw[y] = mem_zalloc(w * sizeof(**pr_drw));
   }
  } else {
   pr_drw = NULL;
  }
  /* Handle "icky corner" */
  if ((Term->icky_corner) && (y2 >= h - 1) && (Term->x2[h - 1] > w - 2))
   Term->x2[h - 1] = w - 2;
  /*
		 * Make the stored y bounds for the modified region empty.
		 * Do so before drawing so that Term_mark() calls from within
		 * the drawing hooks will adjust the bounds on the modified
		 * region for the next update.
		 */
  Term->y1 = h;
  Term->y2 = 0;
  /* Scan the "modified" rows */
  ipr = 0;
  for (y = y1; y <= y2; ++y) {
   int x1 = Term->x1[y];
   int x2 = Term->x2[y];
   /* Flush each "modified" row */
   if (x1 <= x2) {
    /*
				 * As above, set the bounds for the modified
				 * region to be empty before drawing.
				 */
    Term->x1[y] = w;
    Term->x2[y] = 0;
    /* Use "Term_pict()" - always, sometimes or never */
    if (Term->always_pict) {
     /* Flush the row */
     if (Term->dblh_hook) {
      Term_fresh_row_pict_dblh(
       y, x1, x2, pr_drw[ipr]);
      ipr = (ipr + 1) % tile_height;
     } else {
      Term_fresh_row_pict(y, x1, x2);
     }
    } else if (Term->higher_pict) {
     /* Flush the row */
     if (Term->dblh_hook) {
      Term_fresh_row_both_dblh(
       y, x1, x2, pr_drw[ipr]);
      ipr = (ipr + 1) % tile_height;
     } else {
      Term_fresh_row_both(y, x1, x2);
     }
    } else {
     /* Flush the row */
     Term_fresh_row_text(y, x1, x2);
    }
    /* Hack -- Flush that row (if allowed) */
    if (!Term->never_frosh) Term_xtra(TERM_XTRA_FROSH, y);
   } else if (pr_drw) {
    /*
				 * Remember that nothing was redrawn on that
				 * row.
				 */
    for (x = 0; x < w; ++x) {
     pr_drw[ipr][x] = 0;
    }
    ipr = (ipr + 1) % tile_height;
   }
  }
  if (pr_drw) {
   for (y = 0; y < tile_height; ++y) {
    mem_free(pr_drw[y]);
   }
   mem_free(pr_drw);
  }
 }
 /* Cursor update -- Show new Cursor */
 if (Term->soft_cursor) {
  /* Draw the (large or small) cursor */
  if (!scr->cu && scr->cv) {
   if ((((tile_width > 1)||(tile_height > 1)) &&
        (!smlcurs) && (Term->saved == 0) && (scr->cy > 0))
       || bigcurs) {
    (void)((*Term->bigcurs_hook)(scr->cx, scr->cy));
    scr->cnx = tile_width;
    scr->cny = tile_height;
   } else {
    (void)((*Term->curs_hook)(scr->cx, scr->cy));
    scr->cnx = 1;
    scr->cny = 1;
   }
  } else {
   scr->cnx = 1;
   scr->cny = 1;
  }
 } else {
  /* The cursor is useless or invisible ignore it, otherwise display */
  if (scr->cu) {
   /* Paranoia -- Put the cursor NEAR where it belongs */
   (void)((*Term->curs_hook)(w - 1, scr->cy));
  } else if (!scr->cv) {
   /* Paranoia -- Put the cursor where it belongs */
   (void)((*Term->curs_hook)(scr->cx, scr->cy));
  } else {
   /* Put the cursor where it belongs */
   (void)((*Term->curs_hook)(scr->cx, scr->cy));
   /* Make the cursor visible */
   Term_xtra(TERM_XTRA_SHAPE, 1);
  }
  scr->cnx = 1;
  scr->cny = 1;
 }
 /* Save the "cursor state" */
 old->cu = scr->cu;
 old->cv = scr->cv;
 old->cx = scr->cx;
 old->cy = scr->cy;
 old->cnx = scr->cnx;
 old->cny = scr->cny;
 /* Actually flush the output */
 Term_xtra(TERM_XTRA_FRESH, 0);
 /* Success */
 return (0);
}
/**
 * ------------------------------------------------------------------------
 * Output routines
 * ------------------------------------------------------------------------ */
/**
 * Set the cursor visibility
 */
errr Term_set_cursor(bool v)
{
 /* Already done */
 if (Term->scr->cv == v) return (1);
 /* Change */
 Term->scr->cv = v;
 /* Success */
 return (0);
}
/**
 * Place the cursor at a given location
 *
 * Note -- "illegal" requests do not move the cursor.
 */
errr Term_gotoxy(int x, int y)
{
 int w = Term->wid;
 int h = Term->hgt;
 /* Verify */
 if ((x < 0) || (x >= w)) return (-1);
 if ((y < 0) || (y >= h)) return (-1);
 /* Remember the cursor */
 Term->scr->cx = x;
 Term->scr->cy = y;
 /* The cursor is not useless */
 Term->scr->cu = 0;
 /* Success */
 return (0);
}
/**
 * At a given location, place an attr/char
 * Do not change the cursor position
 * No visual changes until "Term_fresh()".
 */
errr Term_draw(int x, int y, int a, wchar_t c)
{
 int w = Term->wid;
 int h = Term->hgt;
 /* Verify location */
 if ((x < 0) || (x >= w)) return (-1);
 if ((y < 0) || (y >= h)) return (-1);
 /* Paranoia -- illegal char */
 if (!c) return (-2);
 /* Queue it for later */
 Term_queue_char(Term, x, y, a, c, 0, 0);
 /* Success */
 return (0);
}
/**
 * Using the given attr, add the given char at the cursor.
 *
 * We return "-2" if the character is "illegal". XXX XXX
 *
 * We return "-1" if the cursor is currently unusable.
 *
 * We queue the given attr/char for display at the current
 * cursor location, and advance the cursor to the right,
 * marking it as unusable and returning "1" if it leaves
 * the screen, and otherwise returning "0".
 *
 * So when this function, or the following one, return a
 * positive value, future calls to either function will
 * return negative ones.
 */
errr Term_addch(int a, wchar_t c)
{
 int w = Term->wid;
 /* Handle "unusable" cursor */
 if (Term->scr->cu) return (-1);
 /* Paranoia -- no illegal chars */
 if (!c) return (-2);
 /* Queue the given character for display */
 Term_queue_char(Term, Term->scr->cx, Term->scr->cy, a, c, 0, 0);
 /* Advance the cursor */
 Term->scr->cx++;
 /* Success */
 if (Term->scr->cx < w) return (0);
 /* Note "Useless" cursor */
 Term->scr->cu = 1;
 /* Note "Useless" cursor */
 return (1);
}
/**
 * At the current location, using an attr, add a string
 *
 * We also take a length "n", using negative values to imply
 * the largest possible value, and then we use the minimum of
 * this length and the "actual" length of the string as the
 * actual number of characters to attempt to display, never
 * displaying more characters than will actually fit, since
 * we do NOT attempt to "wrap" the cursor at the screen edge.
 *
 * We return "-1" if the cursor is currently unusable.
 * We return "N" if we were "only" able to write "N" chars,
 * even if all of the given characters fit on the screen,
 * and mark the cursor as unusable for future attempts.
 *
 * So when this function, or the preceding one, return a
 * positive value, future calls to either function will
 * return negative ones.
 */
errr Term_addstr(int n, int a, const char *buf)
{
 int k;
 int w = Term->wid;
 errr res = 0;
 wchar_t s[1024];
 /* Copy to a rewriteable string */
  text_mbstowcs(s, buf, 1024);
 /* Handle "unusable" cursor */
 if (Term->scr->cu) return (-1);
 /* Obtain maximal length */
 k = (n < 0) ? (w + 1) : n;
 /* Obtain the usable string length */
 for (n = 0; (n < k) && s[n]; n++) /* loop */;
 /* React to reaching the edge of the screen */
 if (Term->scr->cx + n >= w) res = n = w - Term->scr->cx;
 /* Queue the first "n" characters for display */
 Term_queue_chars(Term->scr->cx, Term->scr->cy, n, a, s);
 /* Advance the cursor */
 Term->scr->cx += n;
 /* Hack -- Notice "Useless" cursor */
 if (res) Term->scr->cu = 1;
 /* Success (usually) */
 return (res);
}
/**
 * Move to a location and, using an attr, add a char
 */
errr Term_putch(int x, int y, int a, wchar_t c)
{
 errr res;
 /* Move first */
 if ((res = Term_gotoxy(x, y)) != 0) return (res);
 /* Then add the char */
 if ((res = Term_addch(a, c)) != 0) return (res);
 /* Success */
 return (0);
}
/**
 * Move to a location and, using an attr, add a big tile
 */
void Term_big_putch(int x, int y, int a, wchar_t c)
{
 int hor, vert;
 /* Avoid warning */
 (void)c;
 /* No tall skinny tiles */
 if (tile_width > 1) {
  /* Horizontal first */
  for (hor = 0; hor < tile_width; hor++) {
   /* Queue dummy character */
   if (hor != 0) {
    if (a & 0x80)
     Term_putch(x + hor, y, 255, -1);
    else
     Term_putch(x + hor, y, COLOUR_WHITE, L' ');
   }
   /* Now vertical */
   for (vert = 1; vert < tile_height; vert++) {
    /* Queue dummy character */
    if (a & 0x80)
     Term_putch(x + hor, y + vert, 255, -1);
    else
     Term_putch(x + hor, y + vert, COLOUR_WHITE, L' ');
   }
  }
 } else {
  /* Only vertical */
  for (vert = 1; vert < tile_height; vert++) {
   /* Queue dummy character */
   if (a & 0x80)
    Term_putch(x, y + vert, 255, -1);
   else
    Term_putch(x, y + vert, COLOUR_WHITE, L' ');
  }
 }
}
/**
 * Move to a location and, using an attr, add a string
 */
errr Term_putstr(int x, int y, int n, int a, const char *s)
{
 errr res;
 if (!Term)
  return 0;
 /* Move first */
 if ((res = Term_gotoxy(x, y)) != 0) return (res);
 /* Then add the string */
 if ((res = Term_addstr(n, a, s)) != 0) return (res);
 /* Success */
 return (0);
}
/**
 * Place cursor at (x,y), and clear the next "n" chars
 */
errr Term_erase(int x, int y, int n)
{
 int i;
 int w = Term->wid;
 /* int h = Term->hgt; */
 int x1 = -1;
 int x2 = -1;
 int *scr_aa;
 wchar_t *scr_cc;
 int *scr_taa;
 wchar_t *scr_tcc;
 /* Place cursor */
 if (Term_gotoxy(x, y)) return (-1);
 /* Force legal size */
 if (x + n > w) n = w - x;
 /* Fast access */
 scr_aa = Term->scr->a[y];
 scr_cc = Term->scr->c[y];
 scr_taa = Term->scr->ta[y];
 scr_tcc = Term->scr->tc[y];
 /* Scan every column */
 for (i = 0; i < n; i++, x++) {
  int oa = scr_aa[x];
  wchar_t oc = scr_cc[x];
  /* Hack -- Ignore "non-changes" */
  if ((oa == COLOUR_WHITE) && (oc == ' ')) continue;
  /* Save the "literal" information */
  scr_aa[x] = COLOUR_WHITE;
  scr_cc[x] = ' ';
  scr_taa[x] = 0;
  scr_tcc[x] = 0;
  /* Track minimum changed column */
  if (x1 < 0) x1 = x;
  /* Track maximum changed column */
  x2 = x;
 }
 /* Expand the "change area" as needed */
 if (x1 >= 0) {
  /* Check for new min/max row info */
  if (y < Term->y1) Term->y1 = y;
  if (y > Term->y2) Term->y2 = y;
  /* Check for new min/max col info in this row */
  if (x1 < Term->x1[y]) Term->x1[y] = x1;
  if (x2 > Term->x2[y]) Term->x2[y] = x2;
 }
 /* Success */
 return (0);
}
/**
 * Clear the entire window, and move to the top left corner
 *
 * Note the use of the special "total_erase" code
 */
errr Term_clear(void)
{
 int x, y;
 int w = Term->wid;
 int h = Term->hgt;
 /* Cursor usable */
 Term->scr->cu = 0;
 /* Cursor to the top left */
 Term->scr->cx = Term->scr->cy = 0;
 /* Wipe each row */
 for (y = 0; y < h; y++) {
  int *scr_aa = Term->scr->a[y];
  wchar_t *scr_cc = Term->scr->c[y];
  int *scr_taa = Term->scr->ta[y];
  wchar_t *scr_tcc = Term->scr->tc[y];
  /* Wipe each column */
  for (x = 0; x < w; x++) {
   scr_aa[x] = COLOUR_WHITE;
   scr_cc[x] = ' ';
   scr_taa[x] = 0;
   scr_tcc[x] = 0;
  }
  /* This row has changed */
  Term->x1[y] = 0;
  Term->x2[y] = w - 1;
 }
 /* Every row has changed */
 Term->y1 = 0;
 Term->y2 = h - 1;
 /* Force "total erase" */
 Term->total_erase = true;
 /* Success */
 return (0);
}
/**
 * Redraw (and refresh) the whole window.
 */
errr Term_redraw(void)
{
 /* Force "total erase" */
 Term->total_erase = true;
 /* Hack -- Refresh */
 Term_fresh();
 /* Success */
 return (0);
}
/**
 * Redraw part of a window.
 */
errr Term_redraw_section(int x1, int y1, int x2, int y2)
{
 int i, j;
 wchar_t *c_ptr;
 /* Bounds checking */
 if (y2 >= Term->hgt) y2 = Term->hgt - 1;
 if (x2 >= Term->wid) x2 = Term->wid - 1;
 if (y1 < 0) y1 = 0;
 if (x1 < 0) x1 = 0;
 /* Set y limits */
 Term->y1 = y1;
 Term->y2 = y2;
 /* Set the x limits */
 for (i = Term->y1; i <= Term->y2; i++) {
  if ((x1 > 0) && (Term->old->a[i][x1] == 255))
   x1--;
  Term->x1[i] = x1;
  Term->x2[i] = x2;
  c_ptr = Term->old->c[i];
  /* Clear the section so it is redrawn */
  for (j = x1; j <= x2; j++) {
   /* Hack - set the old character to "none" */
   c_ptr[j] = 0;
  }
 }
 /* Hack -- Refresh */
 Term_fresh();
 /* Success */
 return (0);
}
/**
 * ------------------------------------------------------------------------
 * Access routines
 * ------------------------------------------------------------------------ */
/**
 * Extract the cursor visibility
 */
errr Term_get_cursor(bool *v)
{
 /* Extract visibility */
 (*v) = Term->scr->cv;
 /* Success */
 return (0);
}
/**
 * Extract the current window size
 */
errr Term_get_size(int *w, int *h)
{
 *w = Term ? Term->wid : 80;
 *h = Term ? Term->hgt : 24;
 return 0;
}
/**
 * Extract the current cursor location
 */
errr Term_locate(int *x, int *y)
{
 /* Access the cursor */
 (*x) = Term->scr->cx;
 (*y) = Term->scr->cy;
 /* Warn about "useless" cursor */
 if (Term->scr->cu) return (1);
 /* Success */
 return (0);
}
/**
 * At a given location, determine the "current" attr and char
 * Note that this refers to what will be on the window after the
 * next call to "Term_fresh()".  It may or may not already be there.
 */
errr Term_what(int x, int y, int *a, wchar_t *c)
{
 int w = Term->wid;
 int h = Term->hgt;
 /* Verify location */
 if ((x < 0) || (x >= w)) return (-1);
 if ((y < 0) || (y >= h)) return (-1);
 /* Direct access */
 (*a) = Term->scr->a[y][x];
 (*c) = Term->scr->c[y][x];
 /* Success */
 return (0);
}
/**
 * ------------------------------------------------------------------------
 * Input routines
 * ------------------------------------------------------------------------ */
/**
 * Flush and forget the input
 */
errr Term_flush(void)
{
 if (!Term)
  return 0;
 /* Hack -- Flush all events */
 Term_xtra(TERM_XTRA_FLUSH, 0);
 /* Forget all keypresses */
 Term->key_head = Term->key_tail = 0;
 /* Success */
 return (0);
}
/**
 * sketchy keylogging pt. 2
 */
static void log_keypress(ui_event e)
{
 if (e.type != EVT_KBRD) return;
 if (!e.key.code) return;
 keylog[log_i] = e.key;
 if (log_size < KEYLOG_SIZE) log_size++;
 log_i = (log_i + 1) % KEYLOG_SIZE;
}
/**
 * Add a keypress to the "queue"
 */
errr Term_keypress(keycode_t k, uint8_t mods)
{
 /* Hack -- Refuse to enqueue non-keys */
 if (!k) return (-1);
 if(!Term->complex_input) {
  switch (k)
  {
   case '\r':
   case '\n':
      k = KC_ENTER;
      break;
   case 8:
      k = KC_BACKSPACE;
      break;
   case 9:
      k = KC_TAB;
      break;
   case 27:
      k = ESCAPE;
      break;
  }
 }
 /* Store the char, advance the queue */
 Term->key_queue[Term->key_head].type = EVT_KBRD;
 Term->key_queue[Term->key_head].key.code = k;
 Term->key_queue[Term->key_head].key.mods = mods;
 Term->key_head++;
 /* Circular queue, handle wrap */
 if (Term->key_head == Term->key_size) Term->key_head = 0;
 /* Success (unless overflow) */
 if (Term->key_head != Term->key_tail) return (0);
 /* Problem */
 return (1);
}
/**
 * Add a mouse event to the "queue"
 */
errr Term_mousepress(int x, int y, char button)/*, uint8_t mods);*/
{
 /* Store the char, advance the queue */
 Term->key_queue[Term->key_head].type = EVT_MOUSE;
 Term->key_queue[Term->key_head].mouse.x = x;
 Term->key_queue[Term->key_head].mouse.y = y;
 /* XXX for now I encode the mods into the button number, so I would
	 * not have to worry about the other platforms, when all platforms set
	 * mods, this code should be replaced with :
	 * Term->key_queue[Term->key_head].mouse.button = button;
	 * Term->key_queue[Term->key_head].mouse.mods = mods;
	 */
 Term->key_queue[Term->key_head].mouse.button = (button & 0x0F);
 Term->key_queue[Term->key_head].mouse.mods = ((button & 0xF0)>>4);
 Term->key_head++;
 /* Circular queue, handle wrap */
 if (Term->key_head == Term->key_size) Term->key_head = 0;
 /* Success (unless overflow) */
 if (Term->key_head != Term->key_tail) return (0);
 /* Problem */
 return (1);
}
/**
 * Add a keypress to the FRONT of the "queue"
 */
errr Term_key_push(int k)
{
 ui_event ke;
 if (!k) return (-1);
 ke.type = EVT_KBRD;
 ke.key.code = k;
 ke.key.mods = 0;
 return Term_event_push(&ke);
}
errr Term_event_push(const ui_event *ke)
{
 /* Hack -- Refuse to enqueue non-keys */
 if (!ke) return (-1);
 /* Hack -- Overflow may induce circular queue */
 if (Term->key_tail == 0) Term->key_tail = Term->key_size;
 /* Back up, Store the char */
 /* Store the char, advance the queue */
 Term->key_queue[--Term->key_tail] = *ke;
 /* Success (unless overflow) */
 if (Term->key_head != Term->key_tail) return (0);
 /* Problem */
 return (1);
}
/**
 * Check for a pending keypress on the key queue.
 *
 * Store the keypress, if any, in "ch", and return "0".
 * Otherwise store "zero" in "ch", and return "1".
 *
 * Wait for a keypress if "wait" is true.
 *
 * Remove the keypress if "take" is true.
 */
errr Term_inkey(ui_event *ch, bool wait, bool take)
{
 /* Assume no key */
 memset(ch, 0, sizeof *ch);
 /* Hack -- get bored */
 if (!Term->never_bored)
  /* Process random events */
  Term_xtra(TERM_XTRA_BORED, 0);
 /* Wait or not */
 if (wait)
  /* Process pending events while necessary */
  while (Term->key_head == Term->key_tail)
   /* Process events (wait for one) */
   Term_xtra(TERM_XTRA_EVENT, true);
 else
  /* Process pending events if necessary */
  if (Term->key_head == Term->key_tail)
   /* Process events (do not wait) */
   Term_xtra(TERM_XTRA_EVENT, false);
 /* No keys are ready */
 if (Term->key_head == Term->key_tail) return (1);
 /* Extract the next keypress */
 (*ch) = Term->key_queue[Term->key_tail];
 /* sketchy key loggin */
 log_keypress(*ch);
 /* If requested, advance the queue, wrap around if necessary */
 if (take && (++Term->key_tail == Term->key_size)) Term->key_tail = 0;
 /* Success */
 return (0);
}
/**
 * ------------------------------------------------------------------------
 * Extra routines
 * ------------------------------------------------------------------------ */
/**
 * Save the "requested" screen into the "memorized" screen
 *
 * Every "Term_save()" should match exactly one "Term_load()" or
 * "Term_load_all()"
 */
errr Term_save(void)
{
 int w = Term->wid;
 int h = Term->hgt;
 term_win *mem;
 /* Allocate window */
 mem = mem_zalloc(sizeof(term_win));
 /* Initialize window */
 term_win_init(mem, w, h);
 /* Grab */
 term_win_copy(mem, Term->scr, w, h);
 /* Front of the queue */
 mem->next = Term->mem;
 Term->mem = mem;
 /* One more saved */
 Term->saved++;
 /* Success */
 return (0);
}
/**
 * Restore the "requested" contents (see above).
 *
 * Every "Term_save()" should match exactly one "Term_load()" or
 * "Term_load_all()"
 */
errr Term_load(void)
{
 int y;
 int w = Term->wid;
 int h = Term->hgt;
 term_win *tmp;
 /* Pop off window from the list */
 if (Term->mem) {
  /* Save pointer to old mem */
  tmp = Term->mem;
  /* Forget it */
  Term->mem = Term->mem->next;
  /* Load */
  term_win_copy(Term->scr, tmp, w, h);
  /* Free the old window */
  (void)term_win_nuke(tmp);
  /* Kill it */
  mem_free(tmp);
 }
 /* Assume change */
 for (y = 0; y < h; y++) {
  /* Assume change */
  Term->x1[y] = 0;
  Term->x2[y] = w - 1;
 }
 /* Assume change */
 Term->y1 = 0;
 Term->y2 = h - 1;
 /* One less saved */
 Term->saved--;
 /* Success */
 return (0);
}
/**
 * Restore the "requested" contents (see above).  Differs from Term_load() in
 * that all the previous saves are replayed from earliest to latest with a
 * redraw for each.  That is useful for accurately restoring the display if
 * the saves include partially overwritten big tiles.
 *
 * Every "Term_save()" should match exactly one "Term_load()" or
 * "Term_load_all()"
 */
errr Term_load_all(void)
{
 int w = Term->wid;
 int h = Term->hgt;
 struct reversed_save {
  term_win *saved_mem; struct reversed_save *next;
 } *reversed_list = NULL;
 struct term_win *cursor;
 for (cursor = Term->mem; cursor; cursor = cursor->next) {
  struct reversed_save *new_head = mem_alloc(sizeof(*new_head));
  new_head->saved_mem = cursor;
  new_head->next = reversed_list;
  reversed_list = new_head;
 }
 while (reversed_list) {
  struct reversed_save *tgt = reversed_list;
  int y;
  reversed_list = reversed_list->next;
  term_win_copy(Term->scr, tgt->saved_mem, w, h);
  mem_free(tgt);
  /* Assume change */
  for (y = 0; y < h; y++) {
   /* Assume change */
   Term->x1[y] = 0;
   Term->x2[y] = w - 1;
  }
  Term->y1 = 0;
  Term->y2 = h - 1;
  /* Force a redraw with those contents. */
  Term_fresh();
 }
 /* Drop the most recent save. */
 if (Term->mem) {
  cursor = Term->mem;
  Term->mem = Term->mem->next;
  term_win_nuke(cursor);
  mem_free(cursor);
 }
 Term->saved--;
 /* Success */
 return (0);
}
/**
 * React to a new physical window size.
 */
errr Term_resize(int w, int h)
{
 int i;
 int wid, hgt;
 int *hold_x1;
 int *hold_x2;
 term_win *hold_old;
 term_win *hold_scr;
 term_win *hold_mem;
 term_win **hold_mem_dest;
 term_win *hold_tmp;
 ui_event evt = EVENT_EMPTY;
 evt.type = EVT_RESIZE;
 /* Resizing is forbidden */
 if (Term->fixed_shape) return (-1);
 /* Ignore illegal changes */
 if ((w < 1) || (h < 1)) return (-1);
 /* Ignore non-changes */
 if ((Term->wid == w) && (Term->hgt == h)) return (1);
 /* Minimum dimensions */
 wid = MIN(Term->wid, w);
 hgt = MIN(Term->hgt, h);
 /* Save scanners */
 hold_x1 = Term->x1;
 hold_x2 = Term->x2;
 /* Save old window */
 hold_old = Term->old;
 /* Save old window */
 hold_scr = Term->scr;
 /* Save old window */
 hold_mem = Term->mem;
 /* Save old window */
 hold_tmp = Term->tmp;
 /* Create new scanners */
 Term->x1 = mem_zalloc(h * sizeof(int));
 Term->x2 = mem_zalloc(h * sizeof(int));
 /* Create new window */
 Term->old = mem_zalloc(sizeof(term_win));
 /* Initialize new window */
 term_win_init(Term->old, w, h);
 /* Save the contents */
 term_win_copy(Term->old, hold_old, wid, hgt);
 /* Create new window */
 Term->scr = mem_zalloc(sizeof(term_win));
 /* Initialize new window */
 term_win_init(Term->scr, w, h);
 /* Save the contents */
 term_win_copy(Term->scr, hold_scr, wid, hgt);
 /* If needed */
 hold_mem_dest = &Term->mem;
 while (hold_mem != 0) {
  term_win* trash;
  /* Create new window */
  *hold_mem_dest = mem_zalloc(sizeof(term_win));
  /* Initialize new window */
  term_win_init(*hold_mem_dest, w, h);
  /* Save the contents */
  term_win_copy(*hold_mem_dest, hold_mem, wid, hgt);
  trash = hold_mem;
  hold_mem = hold_mem->next;
  if ((*hold_mem_dest)->cx >= w) (*hold_mem_dest)->cu = 1;
  if ((*hold_mem_dest)->cy >= h) (*hold_mem_dest)->cu = 1;
  hold_mem_dest = &((*hold_mem_dest)->next);
  term_win_nuke(trash);
  mem_free(trash);
 }
 /* If needed */
 if (hold_tmp) {
  /* Create new window */
  Term->tmp = mem_zalloc(sizeof(term_win));
  /* Initialize new window */
  term_win_init(Term->tmp, w, h);
  /* Save the contents */
  term_win_copy(Term->tmp, hold_tmp, wid, hgt);
 }
 /* Free some arrays */
 mem_free(hold_x1);
 mem_free(hold_x2);
 /* Nuke */
 term_win_nuke(hold_old);
 /* Kill */
 mem_free(hold_old);
 /* Illegal cursor */
 if (Term->old->cx >= w) Term->old->cu = 1;
 if (Term->old->cy >= h) Term->old->cu = 1;
 /* Nuke */
 term_win_nuke(hold_scr);
 /* Kill */
 mem_free(hold_scr);
 /* Illegal cursor */
 if (Term->scr->cx >= w) Term->scr->cu = 1;
 if (Term->scr->cy >= h) Term->scr->cu = 1;
 /* If needed */
 if (hold_tmp) {
  /* Nuke */
  term_win_nuke(hold_tmp);
  /* Kill */
  mem_free(hold_tmp);
  /* Illegal cursor */
  if (Term->tmp->cx >= w) Term->tmp->cu = 1;
  if (Term->tmp->cy >= h) Term->tmp->cu = 1;
 }
 /* Save new size */
 Term->wid = w;
 Term->hgt = h;
 /* Force "total erase" */
 Term->total_erase = true;
 /* Assume change */
 for (i = 0; i < h; i++) {
  /* Assume change */
  Term->x1[i] = 0;
  Term->x2[i] = w - 1;
 }
 /* Assume change */
 Term->y1 = 0;
 Term->y2 = h - 1;
 /* Push a resize event onto the stack */
 Term_event_push(&evt);
 /* Success */
 return (0);
}
/**
 * Activate a new Term (and deactivate the current Term)
 *
 * This function is extremely important, and also somewhat bizarre.
 * It is the only function that should "modify" the value of "Term".
 *
 * To "create" a valid "term", one should do "term_init(t)", then
 * set the various flags and hooks, and then do "Term_activate(t)".
 */
errr Term_activate(term *t)
{
 /* Hack -- already done */
 if (Term == t) return (1);
 /* Deactivate the old Term */
 if (Term) Term_xtra(TERM_XTRA_LEVEL, 0);
 /* Hack -- Call the special "init" hook */
 if (t && !t->active_flag) {
  /* Call the "init" hook */
  if (t->init_hook) (*t->init_hook)(t);
  /* Remember */
  t->active_flag = true;
  /* Assume mapped */
  t->mapped_flag = true;
 }
 /* Remember the Term */
 Term = t;
 /* Activate the new Term */
 if (Term) Term_xtra(TERM_XTRA_LEVEL, 1);
 /* Success */
 return (0);
}
/**
 * Nuke a term
 */
errr term_nuke(term *t)
{
 /* Hack -- Call the special "nuke" hook */
 if (t->active_flag) {
  /* Call the "nuke" hook */
  if (t->nuke_hook) (*t->nuke_hook)(t);
  /* Remember */
  t->active_flag = false;
  /* Assume not mapped */
  t->mapped_flag = false;
 }
 /* Nuke "displayed" */
 term_win_nuke(t->old);
 /* Kill "displayed" */
 mem_free(t->old);
 /* Nuke "requested" */
 term_win_nuke(t->scr);
 /* Kill "requested" */
 mem_free(t->scr);
 /* If needed */
 if (t->mem) {
  /* Nuke "memorized" */
  term_win_nuke(t->mem);
  /* Kill "memorized" */
  mem_free(t->mem);
 }
 /* If needed */
 if (t->tmp) {
  /* Nuke "temporary" */
  term_win_nuke(t->tmp);
  /* Kill "temporary" */
  mem_free(t->tmp);
 }
 /* Free some arrays */
 mem_free(t->x1);
 mem_free(t->x2);
 /* Free the input queue */
 mem_free(t->key_queue);
 /* Success */
 return (0);
}
/**
 * Initialize a term, using a window of the given size.
 * Also prepare the "input queue" for "k" keypresses
 * By default, the cursor starts out "invisible"
 * By default, we "erase" using "black spaces"
 */
errr term_init(term *t, int w, int h, int k)
{
 int y;
 /* Wipe it */
 memset(t, 0, sizeof(term));
 /* Prepare the input queue */
 t->key_head = t->key_tail = 0;
 /* Determine the input queue size */
 t->key_size = k;
 /* Allocate the input queue */
 t->key_queue = mem_zalloc(t->key_size * sizeof(ui_event));
 /* Save the size */
 t->wid = w;
 t->hgt = h;
 /* Allocate change arrays */
 t->x1 = mem_zalloc(h * sizeof(int));
 t->x2 = mem_zalloc(h * sizeof(int));
 /* Allocate "displayed" */
 t->old = mem_zalloc(sizeof(term_win));
 /* Initialize "displayed" */
 term_win_init(t->old, w, h);
 /* Allocate "requested" */
 t->scr = mem_zalloc(sizeof(term_win));
 /* Initialize "requested" */
 term_win_init(t->scr, w, h);
 /* Assume change */
 for (y = 0; y < h; y++) {
  /* Assume change */
  t->x1[y] = 0;
  t->x2[y] = w - 1;
 }
 /* Assume change */
 t->y1 = 0;
 t->y2 = h - 1;
 /* Force "total erase" */
 t->total_erase = true;
 /* No saves yet */
 t->saved = 0;
 t->sidebar_mode = SIDEBAR_LEFT;
 /* Success */
 return (0);
}
/**
 * Emit a 'graphical' symbol and a padding character if appropriate
 */
int big_pad(int col, int row, uint8_t a, wchar_t c)
{
 Term_putch(col, row, a, c);
 if ((tile_width > 1) || (tile_height > 1))
  Term_big_putch(col, row, a, c);
 return tile_width;
}
/**
 * For the given terminal, return the first row where tiles may be rendered.
 * \param t Is the terminal to be queried.
 */
int Term_get_first_tile_row(term *t)
{
 int result;
 if (t == angband_term[0]) {
  /*
		 * In the main window, there's no tiles in the top bar, does
		 * not account for the case where the main window is used as
		 * the target for display_map() or displays tiles in the
		 * knowledge menus.
		 */
  result = ROW_MAP;
 } else {
  /* In other windows, have to check the flags. */
  int i = 1;
  while (1) {
   if (i >= ANGBAND_TERM_MAX) {
    /*
				 * Don't know the flags.  Err on the side of
				 * drawing too few tiles.
				 */
    result = 1;
    break;
   }
   if (t == angband_term[i]) {
    if (window_flag[i] & PW_OVERHEAD) {
     /*
					 * All rows are valid targets for
					 * tiles.
					 */
     result = 0;
    } else {
     /*
					 * It's presumably a minimap view where
					 * the first row has a non-tile border.
					 */
     result = 1;
    }
    break;
   }
   ++i;
  }
 }
 return result;
}
/**
 * \file ui-tutorial.c
 * \brief Implement starting the tutorial and tutorial hooks into the UI layer.
 *
 * Copyright (c) 2022 Eric Branlund
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
static void textui_tutorial_textblock_show(textblock *tb, const char *header)
{
 region orig_area = { COL_MAP, ROW_MAP, 60, 18 };
 (void) textui_textblock_show(tb, orig_area, header);
}
static void textui_tutorial_textblock_append_command_phrase(textblock *tb,
  const char *command_name, bool capital, bool gerund)
{
 int i = 0;
 while (1) {
  size_t j;
  if (!cmds_all[i].list) {
   break;
  }
  j = 0;
  while (1) {
   if (j >= cmds_all[i].len) {
    break;
   }
   if (streq(cmds_all[i].list[j].desc, command_name)) {
    int mode = OPT(player, hjkl_movement) ?
     KEYMAP_MODE_ROGUE : KEYMAP_MODE_ORIG;
    keycode_t code = cmds_all[i].list[j].key[mode];
    /*
				 * If a keymap doesn't specify a key, use the
				 * default keymap.
				 */
    if (!code && mode != KEYMAP_MODE_ORIG) {
     code = cmds_all[i].list[j].key[KEYMAP_MODE_ORIG];
    }
    if (code) {
     const char *desc =
      keycode_find_desc(code);
     textblock_append(tb, "%s%s ",
      (capital) ? "Press" : "press",
      (gerund) ? "ing" : "");
     if (desc) {
      textblock_append(tb, "'%s'",
       desc);
     } else if (KTRL(code) == code) {
      textblock_append(tb, "'ctrl-%c'",
       UN_KTRL(code));
     } else {
      textblock_append(tb, "'%c'",
       code);
     }
    }
    return;
   }
   ++j;
  }
  ++i;
 }
}
static void textui_tutorial_textblock_append_direction_phrase(textblock *tb,
  int dirnum, bool capital, bool gerund)
{
 int mode = OPT(player, hjkl_movement) ?
  KEYMAP_MODE_ROGUE : KEYMAP_MODE_ORIG;
 char keys[2][9] = {
  { '1', '2', '3', '4', '5', '6', '7', '8', '9' },
  { 'b', 'j', 'n', 'h', '.', 'l', 'y', 'k', 'u' }
 };
 if (dirnum > 0 && dirnum < 10) {
  textblock_append(tb, "%s%s '%c'", (capital) ? "Press" : "press",
   (gerund) ? "ing" : "", keys[mode][dirnum - 1]);
 }
}
static void textui_tutorial_textblock_append_direction_rose(textblock *tb)
{
 if (OPT(player, hjkl_movement)) {
  textblock_append(tb,
   "\nUse the keyboard to move (or stay still) as follows:\n\n"
   "y (northeast)  k (north)   u (northeast)\n"
   "             \\    |      /\n"
   "   h (west)  -    .      -   l (east)\n"
   "             /    |      \\\n"
   "b (southeast)  j (south)   n (southeast)\n"
   "\nIn most environments, the numeric keypad or "
   "pointing and clicking with the mouse may also be "
   "used.\n");
 } else {
  textblock_append(tb,
   "\nUse the keyboard to move (or stay still) as follows:\n\n"
   "7 (northeast)  8 (north)   9 (northeast)\n"
   "             \\    |      /\n"
   "   4 (west)  -    5      -   6 (east)\n"
   "             /    |      \\\n"
   "1 (southeast)  2 (south)   3 (southeast)\n"
   "\nIn most environments, the numeric keypad or "
   "pointing and clicking with the mouse may also be "
   "used.  If you don't have a numeric keypad, you may "
   "want to enable the rogue-like keys (press =, select "
   "a for the interface options, then turn on the first "
   "option there) for a more convenient set of movement "
   "controls.\n");
 }
}
static void textui_tutorial_textblock_append_feature_symbol(textblock *tb,
  int feat)
{
 int attr = feat_x_attr[LIGHTING_LIT][feat];
 if (use_graphics == GRAPHICS_NONE && feat_is_wall(feat)) {
  if (OPT(player, hybrid_walls)) {
   attr += (MULT_BG * BG_DARK);
  } else if (OPT(player, solid_walls)) {
   attr += (MULT_BG * BG_SAME);
  }
 }
 textblock_append(tb, "('");
 textblock_append_pict(tb, attr, feat_x_char[LIGHTING_LIT][feat]);
 textblock_append(tb, "')");
}
static void textui_tutorial_textblock_append_monster_symbol(textblock *tb,
  const struct monster_race *race)
{
 textblock_append(tb, "('");
 textblock_append_pict(tb, monster_x_attr[race->ridx],
  monster_x_char[race->ridx]);
 textblock_append(tb, "')");
}
static void textui_tutorial_textblock_append_object_symbol(textblock *tb,
  const struct object_kind *kind)
{
 textblock_append(tb, "('");
 textblock_append_pict(tb, object_kind_attr(kind),
  object_kind_char(kind));
 textblock_append(tb, "')");
}
/**
 * Load the tutorial definitions and start the tutorial.
 */
void start_tutorial(void)
{
 char name[PLAYER_NAME_LEN];
 tutorial_parse_data();
 if (tutorial_parsed_data.default_archetype) {
  struct tutorial_dict_val_type *a =
   tutorial_parsed_data.default_archetype;
  const struct player_race *rpick = NULL;
  int i, exp;
  character_generated = false;
  cmdq_push(CMD_BIRTH_INIT);
  cmdq_push(CMD_BIRTH_RESET);
  if (!races) {
   quit_fmt("No races specified prior to loading tutorial.");
  }
  cmdq_push(CMD_CHOOSE_RACE);
  if (a->v.archetype.race_name) {
   if (streq(a->v.archetype.race_name, "*")) {
    /* Choose one at random. */
    const struct player_race *rc = races;
    int nr = 0;
    while (rc) {
     ++nr;
     if (one_in_(nr)) {
      rpick = rc;
     }
     rc = rc->next;
    }
   } else {
    rpick = races;
    while (1) {
     if (!rpick) {
      quit_fmt("Unknown race, %s, "
       "specified for "
       "tutorial archetype.",
       a->v.archetype.race_name);
      break;
     }
     if (streq(rpick->name, a->v.archetype.race_name)) {
      break;
     }
     rpick = rpick->next;
    }
   }
  } else {
   /* Use the first race. */
   rpick = races;
  }
  cmd_set_arg_choice(cmdq_peek(), "choice", rpick->ridx);
  cmdq_push(CMD_CHOOSE_HOUSE);
  if (a->v.archetype.house_name) {
   const struct player_house *hpick = NULL;
   unsigned int hmin = UINT_MAX;
   if (streq(a->v.archetype.house_name, "*")) {
    /* Choose one at random. */
    const struct player_house *hc = houses;
    int nh = 0;
    while (hc) {
     if (hc->race == rpick) {
      ++nh;
      if (hmin > hc->hidx) {
       hmin = hc->hidx;
      }
      if (one_in_(nh)) {
       hpick = hc;
      }
     }
     hc = hc->next;
    }
    if (!hpick) {
     quit_fmt("No houses available for the "
      "race, %s, specified in the "
      "tutorial.", rpick->name);
    }
   } else {
    const struct player_house *hc = houses;
    while (hc) {
     if (hc->race == rpick
       && hmin > hc->hidx) {
      hmin = hc->hidx;
     }
     if (streq(hc->short_name, a->v.archetype.house_name)) {
      if (hc->race != rpick) {
       quit_fmt("House, %s, "
        "selected for "
        "tutorial does "
        "not match the "
        "selected race, "
        "%s.",
        a->v.archetype.house_name,
        rpick->name);
      }
      hpick = hc;
     }
     hc = hc->next;
    }
    if (!hpick) {
     quit_fmt("Unknown house, %s, "
      "specified for the tutorial.",
      a->v.archetype.house_name);
    }
   }
   cmd_set_arg_choice(cmdq_peek(), "choice",
    hpick->hidx - hmin);
  } else {
   cmd_set_arg_choice(cmdq_peek(), "choice", 0);
  }
  if (!sexes) {
   quit_fmt("No sexes specified prior to loading tutorial.");
  }
  cmdq_push(CMD_CHOOSE_SEX);
  if (a->v.archetype.sex_name) {
   const struct player_sex *spick = NULL;
   if (streq(a->v.archetype.sex_name, "*")) {
    /* Choose one at random. */
    const struct player_sex *sc = sexes;
    int ns = 0;
    while (sc) {
     ++ns;
     if (one_in_(ns)) {
      spick = sc;
     }
     sc = sc->next;
    }
   } else {
    spick = sexes;
    while (1) {
     if (!spick) {
      quit_fmt("Unknown sex, %s, "
       "specified for "
       "tutorial archetype.",
       a->v.archetype.sex_name);
      break;
     }
     if (streq(spick->name, a->v.archetype.sex_name)) {
      break;
     }
     spick = spick->next;
    }
   }
   cmd_set_arg_choice(cmdq_peek(), "choice", spick->sidx);
  } else {
   cmd_set_arg_choice(cmdq_peek(), "choice", sexes->sidx);
  }
  cmdq_push(CMD_NAME_CHOICE);
  if (a->v.archetype.character_name
    && !streq(a->v.archetype.character_name, "*")) {
   my_strcpy(name, a->v.archetype.character_name,
    sizeof(name));
  } else {
   (void) player_random_name(name, sizeof(name));
  }
  cmd_set_arg_string(cmdq_peek(), "name", name);
  if (a->v.archetype.history
    && !streq(a->v.archetype.history, "*")) {
   char history[240];
   /*
			 * Limit the size to what the user interface can
			 * display.
			 */
   my_strcpy(history, a->v.archetype.history,
    sizeof(history));
   cmdq_push(CMD_HISTORY_CHOICE);
   cmd_set_arg_string(cmdq_peek(), "history", history);
  }
  cmdq_push(CMD_ACCEPT_CHARACTER);
  cmdq_execute(CTX_BIRTH);
  /* Adjust the starting stats. */
  for (i = 0; i < STAT_MAX; ++i) {
   if (a->v.archetype.stat_adj[i] >= 0) {
    if (player->stat_base[i] <= BASE_STAT_MAX
      - a->v.archetype.stat_adj[i]) {
     player->stat_base[i] +=
      a->v.archetype.stat_adj[i];
    } else {
     player->stat_base[i] = BASE_STAT_MAX;
    }
   } else {
    if (player->stat_base[i] >= BASE_STAT_MIN
      - a->v.archetype.stat_adj[i]) {
     player->stat_base[i] +=
      a->v.archetype.stat_adj[i];
    } else {
     player->stat_base[i] = BASE_STAT_MIN;
    }
   }
  }
  /*
		 * Adjust the starting skills.  In first pass, get the amount
		 * of additional experience needed and cap, if necessary the
		 * adjustment from the data file.
		 */
  exp = 0;
  for (i = 0; i < SKILL_MAX; ++i) {
   /*
			 * The experience cost calculations assumed here
			 * duplicate logic in player-abilities.c's skill_cost().
			 */
   int max_exp, cskill, inc_lo, inc_hi;
   if (a->v.archetype.skill_adj[i] == 0) {
    continue;
   }
   assert(a->v.archetype.skill_adj[i] > 0);
   /*
			 * Avoid the experience total overflowing PY_MAX_EXP.
			 * The experience to get from a skill level of n to
			 * n + m is 100 * (((n + m) * (n + m + 1)) / 2) -
			 * 100 * ((n * (n + 1)) / 2) = 50 * m * (m + 2 * n + 1).
			 */
   max_exp = PY_MAX_EXP - player->exp;
   assert(max_exp >= 0);
   cskill = player->skill_base[i];
   inc_lo = 0;
   if (cskill > max_exp / 100 - 1) {
    inc_hi = 1;
   } else {
    inc_hi = max_exp / ((cskill > 0) ?
      100 * cskill : 50);
   }
   while (1) {
    int inc_try, exp_try;
    /*
				 * Done if have determined the maximum increment
				 * or if it won't affect the value from the
				 * data file.
				 */
    if (inc_lo == inc_hi - 1
      || inc_lo >= a->v.archetype.skill_adj[i]) {
     break;
    }
    inc_try = (inc_lo + inc_hi) / 2;
    if (inc_try > max_exp / 50) {
     inc_hi = inc_try;
    } else if (inc_try + cskill + cskill >=
      max_exp / (50 * inc_try)) {
     inc_hi = inc_try;
    } else {
     exp_try = 50 * inc_try * (inc_try
      + cskill + cskill + 1);
     if (exp_try <= max_exp) {
      inc_lo = inc_try;
     } else {
      inc_hi = inc_try;
     }
    }
   }
   if (a->v.archetype.skill_adj[i] > inc_lo) {
    a->v.archetype.skill_adj[i] = inc_lo;
   }
   exp += 50 * a->v.archetype.skill_adj[i]
    * (a->v.archetype.skill_adj[i] + cskill
    + cskill + 1);
   if (player->new_exp < exp) {
    /*
				 * Give the necessary experience for free.
				 */
    player_exp_gain(player, exp - player->new_exp);
   }
  }
  /* Now apply the adjustments. */
  init_skills(false, false);
  for (i = 0; i < SKILL_MAX; ++i) {
   int inc = a->v.archetype.skill_adj[i];
   if (inc == 0) {
    continue;
   }
   assert(a->v.archetype.skill_adj[i] > 0);
   while (inc) {
    cmdq_push(CMD_BUY_SKILL);
    cmd_set_arg_choice(cmdq_peek(), "choice", i);
    cmdq_execute(CTX_GAME);
    --inc;
   }
  }
  finalise_skills();
  /* Add the additional abilities. */
  for (i = 0; i < a->v.archetype.ability_count; ++i) {
   struct ability *anew;
   if (!player_has_prereq_abilities(player,
     a->v.archetype.added_abilities[i])) {
    msg("Missing prerequisites for ability, %s, "
     "specified for the tutorial archetype.",
     a->v.archetype.added_abilities[i]->name);
    continue;
   }
   exp = player_ability_cost(player,
    a->v.archetype.added_abilities[i]);
   if (player->new_exp < exp) {
    /*
				 * Give the necessary experience for free.
				 */
    player_exp_gain(player, exp - player->new_exp);
   }
   /*
			 * Mimic player_gain_ability() but omit checks that
			 * are not necessary.
			 */
   player->new_exp -= exp;
   add_ability(&player->abilities,
    a->v.archetype.added_abilities[i]);
   anew = locate_ability(player->abilities,
    a->v.archetype.added_abilities[i]);
   assert(anew);
   anew->active = true;
  }
  /* Adjust the pool of unspent experience if necesary. */
  if (a->v.archetype.unspent_experience >= 0) {
   if (player->new_exp
     < a->v.archetype.unspent_experience) {
    player_exp_gain(player,
     a->v.archetype.unspent_experience
     - player->new_exp);
   } else if (player->new_exp >
     a->v.archetype.unspent_experience) {
    /*
				 * If it needs to decrease; simply coerce it to
				 * the requested value.  Do not bother to keep
				 * other tabulations (player->exp, for
				 * instance) consistent with that.
				 */
    player->new_exp =
     a->v.archetype.unspent_experience;
   }
  }
  if (a->v.archetype.purge_kit) {
   /*
			 * Do it in two passes.  The first takes care of pack
			 * and quiver.  Then there's slots available to take
			 * off and delete equipment without overflowing the
			 * pack.
			 */
   struct object *curr = player->gear;
   int pass = 0;
   while (1) {
    struct object *next;
    int slot;
    bool none_left;
    if (curr == NULL) {
     if (pass == 0) {
      curr = player->gear;
      if (curr == NULL) {
       break;
      }
      ++pass;
     } else {
      break;
     }
    }
    next = curr->next;
    slot = equipped_item_slot(player->body, curr);
    if (slot != player->body.count) {
     if (pass == 0) {
      curr = next;
      continue;
     }
     /*
					 * inven_takeoff() always generates
					 * messages; do it ourselves without
					 * those.
					 */
     player->body.slots[slot].obj = NULL;
     --player->upkeep->equip_cnt;
    }
    none_left = false;
    curr = gear_object_for_use(player, curr,
     curr->number, false, &none_left);
    assert(none_left);
    /*
				 * Not checking if it's an artifact, that may
				 * be an issue if the birth process allows
				 * artifacts in the starting kit.
				 */
    object_free(curr->known);
    object_free(curr);
    curr = next;
   }
  }
  if (a->v.archetype.kit_count > 0) {
   /* Add to the starting kit. */
   assert(a->v.archetype.kit);
   for (i = 0; i < a->v.archetype.kit_count; ++i) {
    const struct tutorial_kit_item *kit =
     a->v.archetype.kit + i;
    struct object *obj;
    if (!kit->equipped && pack_is_full()) {
     continue;
    }
    obj = (kit->item.is_artifact) ?
     tutorial_create_artifact(kit->item.v.art) :
     tutorial_create_object(&kit->item);
    if (!obj) {
     continue;
    }
    obj->origin = ORIGIN_BIRTH;
    obj->known = object_new();
    object_set_base_known(player, obj);
    object_flavor_aware(player, obj);
    if (kit->equipped) {
     /*
					 * Wield what can be wielded; put the
					 * rest in the pack if possible.
					 */
     int slot = wield_slot(obj);
     struct object *eobj = (slot == -1) ?
      NULL : slot_object(player, slot);
     if (slot != -1 && eobj == NULL) {
      if (obj->number > 1) {
       eobj = object_split(
        obj, 1);
      } else {
       eobj = obj;
      }
      player->body.slots[slot].obj =
       eobj;
      object_learn_on_wield(player, eobj);
      player->upkeep->total_weight +=
       eobj->weight;
      ++player->upkeep->equip_cnt;
      if (obj == eobj) {
       continue;
      }
     }
     if (pack_is_full()) {
      if (obj->artifact) {
       mark_artifact_created(
        obj->artifact,
        false);
      }
      object_free(obj->known);
      object_free(obj);
      continue;
     }
    }
    inven_carry(player, obj, true, false);
   }
   update_player_object_knowledge(player);
  }
 } else {
  /* Use the first race and class with a random name. */
  bool result;
  (void) player_random_name(name, sizeof(name));
  result = player_make_simple(NULL, NULL, NULL, name);
  if (!result) {
   assert(false);
  }
 }
 /* Mark player as in the tutorial; disable autosaving. */
 player->game_type = -1;
 player->upkeep->autosave = false;
 /* Install event handlers so notes and triggers work. */
 event_add_handler(EVENT_ENTER_WORLD, tutorial_handle_enter_world, NULL);
 event_add_handler(EVENT_LEAVE_WORLD, tutorial_handle_leave_world, NULL);
 /* Set up UI hooks for the tutorial. */
 tutorial_textblock_show_hook = textui_tutorial_textblock_show;
 tutorial_textblock_append_command_phrase_hook =
  textui_tutorial_textblock_append_command_phrase;
 tutorial_textblock_append_direction_phrase_hook =
  textui_tutorial_textblock_append_direction_phrase;
 tutorial_textblock_append_direction_rose_hook =
  textui_tutorial_textblock_append_direction_rose;
 tutorial_textblock_append_feature_symbol_hook =
  textui_tutorial_textblock_append_feature_symbol;
 tutorial_textblock_append_monster_symbol_hook =
  textui_tutorial_textblock_append_monster_symbol;
 tutorial_textblock_append_object_symbol_hook =
  textui_tutorial_textblock_append_object_symbol;
 /* Tell the UI, we've started.  Mimics start_game(). */
 event_signal(EVENT_LEAVE_INIT);
 event_signal(EVENT_ENTER_GAME);
 event_signal(EVENT_ENTER_WORLD);
 /* Enter the default tutorial section. */
 tutorial_prepare_section(NULL, player);
 on_new_level();
}
/**
 * \file ui-visuals.c
 * \brief Appearance for screen elements.
 *
 * Copyright (c) 2016 Ben Semmler
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/** Max color cycle groups per cycler. */
static size_t const VISUALS_GROUPS_MAX = 8;
/** Max color cycles per group. */
static size_t const VISUALS_CYCLES_MAX = 64;
/** Max colors per color cycle. */
static size_t const VISUALS_STEPS_MAX = 32;
/** Value to mark unused or otherwise invalid colors in a color cycle. */
static uint8_t const VISUALS_INVALID_COLOR = 0xFF;
/* ----- Fancy Color Cycling ----- */
/**
 * A set of colors to rotate between.
 */
struct visuals_color_cycle {
 uint8_t *steps; /**< An array of color indexes. Colors will be cycled in this order. */
 size_t max_steps; /**< The size of the \c steps array. */
 char *cycle_name; /**< The identifier of the color cycle. */
 uint8_t invalid_color; /**< A value to mark locations in \c steps that should not be considered a valid color. */
};
/**
 * Create a new color cycle.
 *
 * \param name The identifier for the new color cycle.
 * \param step_count The maximum number of steps in the cycle.
 * \param invalid_color A value used to mark steps that should not be considered
 *        valid colors. This is also used as the initial value for each value in
 *        the \c steps array.
 * \return A new color cycle instance or NULL if an error occurred.
 */
static struct visuals_color_cycle *visuals_color_cycle_new(const char *name,
                 size_t const step_count,
                 uint8_t const invalid_color)
{
 struct visuals_color_cycle *ccycle = NULL;
 if (step_count == 0) {
  return NULL;
 }
 ccycle = mem_zalloc(sizeof(*ccycle));
 if (ccycle == NULL) {
  return NULL;
 }
 ccycle->steps = mem_zalloc(step_count * sizeof(*(ccycle->steps)));
 if (ccycle->steps == NULL) {
  mem_free(ccycle);
  return NULL;
 }
 memset(ccycle->steps, invalid_color, step_count);
 ccycle->invalid_color = invalid_color;
 ccycle->max_steps = step_count;
 ccycle->cycle_name = string_make(name);
 return ccycle;
}
/**
 * Deallocate a color cycle.
 *
 * \param cycle The color cycle to deallocate.
 */
static void visuals_color_cycle_free(struct visuals_color_cycle *ccycle)
{
 if (ccycle == NULL) {
  return;
 }
 if (ccycle->steps != NULL) {
  mem_free(ccycle->steps);
  ccycle->steps = NULL;
 }
 if (ccycle->cycle_name != NULL) {
  string_free(ccycle->cycle_name);
  ccycle->cycle_name = NULL;
 }
 mem_free(ccycle);
 ccycle = NULL;
}
/**
 * Copy a given color cycle by creating a new instance with the same values. If
 * there are any invalid colors in the original, the copy will contain only the
 * valid colors in the original (preserving the original order).
 *
 * \param original The color cycle to copy.
 * \return A new color cycle instance, containing the same cycle information as
 *         \c original. NULL is returned on error.
 */
static struct visuals_color_cycle *visuals_color_cycle_copy(struct visuals_color_cycle const *original)
{
 struct visuals_color_cycle *copy = NULL;
 size_t step = 0;
 size_t valid_colors = 0;
 size_t copy_step = 0;
 if (original == NULL) {
  return NULL;
 }
 /* Find the actual number of colors being used by the original cycle. */
 for (step = 0; step < original->max_steps; step++) {
  if (original->steps[step] != original->invalid_color ) {
   valid_colors++;
  }
 }
 copy = visuals_color_cycle_new(original->cycle_name,
           valid_colors,
           original->invalid_color);
 if (copy == NULL) {
  return NULL;
 }
 for (step = 0; step < original->max_steps && copy_step < valid_colors; step++) {
  if (original->steps[step] != original->invalid_color) {
   copy->steps[copy_step] = original->steps[step];
   copy_step++;
  }
 }
 return copy;
}
/**
 * Return the next color in the cycle for a given frame.
 *
 * \param cycle The color cycle to select a color from.
 * \param frame An arbitrary value used to select the color step.
 * \return A color or \c BASIC_COLORS if an error occurred.
 */
static uint8_t visuals_color_cycle_attr_for_frame(struct visuals_color_cycle const *ccycle,
              size_t const frame)
{
 size_t step = 0;
 if (ccycle == NULL) {
  return BASIC_COLORS;
 }
 step = frame % ccycle->max_steps;
 return ccycle->steps[step];
}
/**
 * A group of color cycles. This is a way of keeping related color cycles
 * together, to provide more flexibility in the color cycling system.
 */
struct visuals_cycle_group {
 struct visuals_color_cycle **cycles; /**< An array of color cycle references. */
 size_t max_cycles; /**< The size of the \c cycles array. */
 char *group_name; /**< The identifier of the group. */
};
/**
 * Create a new color cycle group.
 *
 * \param name The identifier for the group.
 * \param cycle_count The maximum number of color cycles that will be in the
 *        group.
 * \return A new color cycle group or NULL if an error occurred.
 */
static struct visuals_cycle_group *visuals_cycle_group_new(const char *name,
                 size_t const cycle_count)
{
 struct visuals_cycle_group *group = NULL;
 if (cycle_count == 0) {
  return NULL;
 }
 group = mem_zalloc(sizeof(*group));
 if (group == NULL) {
  return NULL;
 }
 group->cycles = mem_zalloc(cycle_count * sizeof(*(group->cycles)));
 if (group->cycles == NULL) {
  mem_free(group);
  return NULL;
 }
 group->max_cycles = cycle_count;
 group->group_name = string_make(name);
 return group;
}
/**
 * Deallocate a color cycle group.
 *
 * \param group The group to deallocate.
 */
static void visuals_cycle_group_free(struct visuals_cycle_group *group)
{
 size_t i = 0;
 if (group == NULL) {
  return;
 }
 if (group->cycles != NULL) {
  for (i = 0; i < group->max_cycles; i++) {
   visuals_color_cycle_free(group->cycles[i]);
  }
  mem_free(group->cycles);
  group->cycles = NULL;
 }
 if (group->group_name != NULL) {
  string_free(group->group_name);
  group->group_name = NULL;
 }
 mem_free(group);
 group = NULL;
}
/**
 * A color cycling table, made up of groups of actual color cycles.
 */
struct visuals_cycler {
 struct visuals_cycle_group **groups; /**< An array of references to groups of color cyclers. */
 size_t max_groups; /**< Size of the \c groups array. */
};
/**
 * Module color cycling table instance.
 */
static struct visuals_cycler *visuals_cycler_table = NULL;
/**
 * Create a new color cycling table.
 *
 * \param group_count The maximum number of groups that the table will contain.
 * \return A new color cycling table or NULL if an error occurred.
 */
static struct visuals_cycler *visuals_cycler_new(size_t const group_count)
{
 struct visuals_cycler *cycler = NULL;
 if (group_count == 0) {
  return NULL;
 }
 cycler = mem_zalloc(sizeof(*cycler));
 if (cycler == NULL) {
  return NULL;
 }
 cycler->groups = mem_zalloc(group_count * sizeof(*(cycler->groups)));
 if (cycler->groups == NULL) {
  mem_free(cycler);
  return NULL;
 }
 cycler->max_groups = group_count;
 return cycler;
}
/**
 * Deallocate a color cycler.
 *
 * \param cycler The cycler to deallocate.
 */
static void visuals_cycler_free(struct visuals_cycler *cycler)
{
 size_t i = 0;
 if (cycler == NULL) {
  return;
 }
 if (cycler->groups != NULL) {
  for (i = 0; i < cycler->max_groups; i++) {
   visuals_cycle_group_free(cycler->groups[i]);
  }
  mem_free(cycler->groups);
  cycler->groups = NULL;
 }
 mem_free(cycler);
 cycler = NULL;
}
/**
 * Search for a color cycle with the given group and name.
 *
 * \param cycler The cycler to search.
 * \param group_name The name of the group to search.
 * \param cycle_name The name of the color cycle to find.
 * \return A color cycle or NULL if an error occurred.
 */
static struct visuals_color_cycle *visuals_cycler_cycle_by_name(struct visuals_cycler const *cycler,
                const char *group_name,
                const char *cycle_name)
{
 struct visuals_cycle_group *group = NULL;
 struct visuals_color_cycle *ccycle = NULL;
 size_t i = 0;
 if (group_name == NULL || strlen(group_name) == 0) {
  return NULL;
 }
 if (cycle_name == NULL || strlen(cycle_name) == 0) {
  return NULL;
 }
 for (i = 0; i < cycler->max_groups; i++) {
  if (streq(cycler->groups[i]->group_name, group_name)) {
   group = cycler->groups[i];
   break;
  }
 }
 if (group == NULL) {
  return NULL;
 }
 for (i = 0; i < group->max_cycles; i++) {
  if (streq(group->cycles[i]->cycle_name, cycle_name)) {
   ccycle = group->cycles[i];
   break;
  }
 }
 return ccycle;
}
/**
 * Get an attribute for a color cycle in a color cycle group from the module
 * table.
 *
 * \param group_name The color cycle group to search.
 * \param cycle_name The color cycle to use.
 * \param frame An arbitrary value used to select which color in the flicker
 *        cycle to return.
 * \return An attribute in the color cycle, or \c BASIC_COLORS if an error
 *         occurred.
 */
uint8_t visuals_cycler_get_attr_for_frame(const char *group_name,
            const char *cycle_name,
            size_t const frame)
{
 struct visuals_cycler *table = visuals_cycler_table;
 struct visuals_color_cycle *ccycle = NULL;
 ccycle = visuals_cycler_cycle_by_name(table, group_name, cycle_name);
 if (ccycle == NULL) {
  return BASIC_COLORS;
 }
 return visuals_color_cycle_attr_for_frame(ccycle, frame);
}
/** A table to quickly map monster races to color cycles. */
struct {
 struct visuals_color_cycle **race;
 size_t max_entries;
 size_t alloc_size;
} *visuals_color_cycles_by_race = NULL;
/**
 * Set a color cycle for a monster race. If a matching color cycle cannot be
 * found, the monster race will not be color cycled.
 *
 * When this module is set up, we don't know how many monster races there will
 * be, nor is there a maximum permitted number of races. This function will
 * reallocate the \c visuals_color_cycles_by_race table as needed, using its
 * allocation increment. This table is initially created in the module init
 * function.
 *
 * \param race The monster race to set the color cycle for.
 * \param group_name The group of the preferred color cycle.
 * \param cycle_name The name of the preferred color cycle.
 */
void visuals_cycler_set_cycle_for_race(struct monster_race const *race,
            const char *group_name,
            const char *cycle_name)
{
 struct visuals_cycler *table = visuals_cycler_table;
 struct visuals_color_cycle *ccycle = NULL;
 if (race == NULL || group_name == NULL || cycle_name == NULL) {
  return;
 }
 if (visuals_color_cycles_by_race == NULL) {
  return;
 }
 while (race->ridx >= visuals_color_cycles_by_race->max_entries) {
  /* Keep reallocating until we can fit the index. This for the case when
		 * indexes may not be parsed in numerical order. */
  size_t old_count = visuals_color_cycles_by_race->max_entries;
  size_t new_count = old_count + visuals_color_cycles_by_race->alloc_size;
  size_t new_size = new_count * sizeof(*(visuals_color_cycles_by_race->race));
  visuals_color_cycles_by_race->race = mem_realloc(visuals_color_cycles_by_race->race, new_size);
  visuals_color_cycles_by_race->max_entries = new_count;
  if (new_count >= 10000) {
   /* Prevent the list from growing to a ridiculous size. */
   quit("Allocated too many color cycle/race refs. Check monster info?");
  }
 }
 ccycle = visuals_cycler_cycle_by_name(table, group_name, cycle_name);
 if (ccycle == NULL) {
  return;
 }
 visuals_color_cycles_by_race->race[race->ridx] = ccycle;
}
/**
 * Get an attribute from a monster race's color cycle.
 *
 * \param race The race to get an attribute for.
 * \param frame An arbitrary value used to select which color in the flicker
 *        cycle to return.
 * \return An attribute in the color cycle, or \c BASIC_COLORS if an error
 *         occurred.
 */
uint8_t visuals_cycler_get_attr_for_race(struct monster_race const *race,
           size_t const frame)
{
 struct visuals_color_cycle *ccycle = NULL;
 if (race == NULL) {
  return BASIC_COLORS;
 }
 if (visuals_color_cycles_by_race == NULL ||
  race->ridx >= visuals_color_cycles_by_race->max_entries) {
  return BASIC_COLORS;
 }
 ccycle = visuals_color_cycles_by_race->race[race->ridx];
 if (ccycle == NULL) {
  return BASIC_COLORS;
 }
 return visuals_color_cycle_attr_for_frame(ccycle, frame);
}
/* ----- Legacy Flicker Cycling ----- */
/**
 * Table to contain all of the color info for the flicker-style cycling.
 */
struct visuals_flicker {
 uint8_t *cycles; /**< Array of \c max_cycles * \c colors_per_cycle colors. */
 size_t max_cycles; /**< Maximum number of cycles in this table; not all may be used. */
 size_t colors_per_cycle; /**< Maximum number of steps in each cycle. */
};
/**
 * Module flicker color table instance.
 */
static struct visuals_flicker *visuals_flicker_table = NULL;
/**
 * Allocate a new flicker color table to hold a fixed number of entries.
 *
 * \param max_cycles The maximum number of cycles to allow for this table.
 * \param colors_per_cycle The maximum number of color steps in each cycle.
 * \return A new flicker color table instance, or NULL if one could not be
 *         created.
 */
static struct visuals_flicker *visuals_flicker_new(size_t const max_cycles,
               size_t const colors_per_cycle)
{
 struct visuals_flicker *table = NULL;
 size_t cycles_size = 0;
 if (max_cycles < BASIC_COLORS || colors_per_cycle == 0) {
  /* Make sure we can at least support the basic color table. */
  return NULL;
 }
 table = mem_zalloc(sizeof(*table));
 if (table == NULL) {
  return NULL;
 }
 cycles_size = max_cycles * colors_per_cycle * sizeof(*(table->cycles));
 table->cycles = mem_zalloc(cycles_size);
 if (table->cycles == NULL) {
  mem_free(table);
  return NULL;
 }
 table->max_cycles = max_cycles;
 table->colors_per_cycle = colors_per_cycle;
 return table;
}
/**
 * Deallocate a flicker color table.
 *
 * \param table The color table to deallocate.
 */
static void visuals_flicker_free(struct visuals_flicker *table)
{
 if (table == NULL) {
  return;
 }
 if (table->cycles != NULL) {
  mem_free(table->cycles);
  table->cycles = NULL;
 }
 mem_free(table);
 table = NULL;
}
/**
 * Set the color that should appear at a particular step in a cycle. If any of
 * the indexes are out of range, the color is ignored.
 *
 * \param table The color table to update.
 * \param cycle_index The index of the cycle to update.
 * \param color_index The step in the given cycle to update.
 * \param attr The actual color to use.
 */
static void visuals_flicker_set_color(struct visuals_flicker *table,
  size_t const cycle_index,
  size_t const color_index,
  uint8_t const attr)
{
 if (table == NULL) {
  return;
 }
 if (cycle_index >= table->max_cycles) {
  return;
 }
 if (color_index >= table->colors_per_cycle) {
  return;
 }
 table->cycles[(cycle_index * table->colors_per_cycle) + color_index] = attr;
}
/**
 * Get the color that should appear at a particular step in a cycle. If any of
 * the indexes are out of range, the color with index 0 is returned.
 *
 * \param table The color table to use.
 * \param cycle_index The index of the desired cycle.
 * \param color_index The desired step in the cycle.
 * \return The color at the given step in the given cycle.
 */
static uint8_t visuals_flicker_get_color(struct visuals_flicker *table,
           size_t const cycle_index,
           size_t const color_index)
{
 if (table == NULL) {
  return 0;
 }
 if (cycle_index >= table->max_cycles) {
  return 0;
 }
 if (color_index >= table->colors_per_cycle) {
  return 0;
 }
 return table->cycles[(cycle_index * table->colors_per_cycle) + color_index];
}
/**
 * Get an attribute for the flicker cycle for a base attribute from the module
 * color table.
 *
 * \param selection_attr The attribute used to select which flicker cycle to
 *        use.
 * \param frame An arbitrary value used to select which color in the flicker
 *        cycle to return.
 * \return An attribute in the flicker cycle, or \c BASIC_COLORS if an error
 *         occurred.
 */
uint8_t visuals_flicker_get_attr_for_frame(uint8_t const selection_attr,
  size_t const frame)
{
 size_t color_index = 0;
 if (visuals_flicker_table == NULL) {
  return BASIC_COLORS;
 }
 if (selection_attr >= visuals_flicker_table->max_cycles) {
  return BASIC_COLORS;
 }
 color_index = frame % visuals_flicker_table->colors_per_cycle;
 return visuals_flicker_get_color(visuals_flicker_table,
          selection_attr,
          color_index);
}
/* ----- Visuals Parsing ----- */
/**
 * Context data for file parsing.
 */
struct visuals_parse_context {
 size_t flicker_cycle_index;
 size_t flicker_color_index;
 struct visuals_color_cycle **cycles; /**< Newly allocated cycle instances. */
 size_t max_cycles;
 size_t cycles_index;
 size_t cycle_step_index;
 char **group_names;
 size_t max_groups;
 struct visuals_color_cycle **group_cycles; /**< References to cycles in the group. */
 size_t max_group_cycles;
};
/**
 * Allocate a visuals parser context.
 *
 * \return A parser context or NULL if one could not be created.
 */
static struct visuals_parse_context *visuals_parse_context_new(void)
{
 struct visuals_parse_context *context = mem_zalloc(sizeof(*context));
 if (context == NULL) {
  return NULL;
 }
 /* Add some extra capacity, since this array will start at 1 instead of 0. */
 context->max_cycles = VISUALS_GROUPS_MAX * VISUALS_CYCLES_MAX + 1;
 context->cycles = mem_zalloc(context->max_cycles * sizeof(*(context->cycles)));
 if (context->cycles == NULL) {
  mem_free(context);
  return NULL;
 }
 context->max_groups = VISUALS_GROUPS_MAX;
 context->group_names = mem_zalloc(context->max_groups * sizeof(*(context->group_names)));
 if (context->group_names == NULL) {
  mem_free(context->cycles);
  mem_free(context);
  return NULL;
 }
 context->max_group_cycles = context->max_groups * VISUALS_CYCLES_MAX;
 context->group_cycles = mem_zalloc(context->max_group_cycles * sizeof(*(context->group_cycles)));
 if (context->group_cycles == NULL) {
  mem_free(context->group_names);
  mem_free(context->cycles);
  mem_free(context);
  return NULL;
 }
 context->cycles_index = 0;
 context->cycle_step_index = 0;
 context->flicker_color_index = 0;
 context->flicker_cycle_index = 0;
 return context;
}
/**
 * Deallocate parser context.
 *
 * \param context The parser context to free.
 */
static void visuals_parse_context_free(struct visuals_parse_context *context)
{
 size_t i = 0;
 if (context == NULL) {
  return;
 }
 if (context->cycles != NULL) {
  for (i = 0; i < context->max_cycles; i++) {
   visuals_color_cycle_free(context->cycles[i]);
  }
  mem_free(context->cycles);
  context->cycles = NULL;
 }
 if (context->group_names != NULL) {
  for (i = 0; i < context->max_groups; i++) {
   string_free(context->group_names[i]) ;
  }
  mem_free(context->group_names);
  context->group_names = NULL;
 }
 if (context->group_cycles != NULL) {
  /* This array is only references and not instances. */
  mem_free(context->group_cycles);
  context->group_cycles = NULL;
 }
 mem_free(context);
 context = NULL;
}
/**
 * Create a cycler instance from the parser context.
 *
 * \param context The current visuals parser context.
 * \return A new cycler instance or NULL if an error occurred.
 */
static struct visuals_cycler *visuals_parse_context_convert(struct visuals_parse_context const *context)
{
 size_t group_count = 0;
 size_t group = 0;
 struct visuals_cycler *cycler = NULL;
 if (context == NULL) {
  return NULL;
 }
 /* Count the number of groups, based only on group name. */
 while (context->group_names[group_count] != NULL) {
  group_count++;
 }
 cycler = visuals_cycler_new(group_count);
 if (cycler == NULL) {
  return NULL;
 }
 for (group = 0; group < group_count; group++) {
  size_t cycle_count = 0;
  size_t const cycle_offset = group * VISUALS_CYCLES_MAX;
  struct visuals_cycle_group *cycle_group = NULL;
  size_t ccycle = 0;
  /* Create a new group based with the number of actual cyles we have. */
  while(context->group_cycles[cycle_offset + cycle_count] != NULL) {
   cycle_count++;
  }
  cycle_group = visuals_cycle_group_new(context->group_names[group], cycle_count);
  if (cycle_group == NULL) {
   return NULL;
  }
  /* Copy all of the cycles over to the group. */
  for (ccycle = 0; ccycle < cycle_count; ccycle++) {
   struct visuals_color_cycle *old_cycle = context->group_cycles[cycle_offset + ccycle];
   cycle_group->cycles[ccycle] = visuals_color_cycle_copy(old_cycle);
   if (cycle_group->cycles[ccycle] == NULL) {
    return NULL;
   }
  }
  cycler->groups[group] = cycle_group;
 }
 return cycler;
}
/**
 * Handle a "flicker" row.
 *
 * \param parser The visuals parser.
 * \return A parser error code.
 */
static enum parser_error visuals_parse_flicker(struct parser *parser)
{
 struct visuals_parse_context *context = parser_priv(parser);
 const char *color_code = NULL;
 int attr = 0;
 if (context == NULL) {
  return PARSE_ERROR_INTERNAL;
 }
 color_code = parser_getsym(parser, "color");
 if (color_code == NULL || strlen(color_code) == 0) {
  return PARSE_ERROR_INVALID_COLOR;
 }
 attr = color_char_to_attr(color_code[0]);
 if (attr < 0) {
  return PARSE_ERROR_INVALID_COLOR;
 }
 /* Set the search attribute for the following colors. */
 context->flicker_cycle_index = (uint8_t)attr;
 context->flicker_color_index = 0;
 return PARSE_ERROR_NONE;
}
/**
 * Handle a "flicker-color" row.
 *
 * \param parser The visuals parser.
 * \return A parser error code.
 */
static enum parser_error visuals_parse_flicker_color(struct parser *parser)
{
 struct visuals_parse_context *context = parser_priv(parser);
 const char *color_code = NULL;
 int attr = 0;
 if (context == NULL) {
  return PARSE_ERROR_INTERNAL;
 }
 color_code = parser_getsym(parser, "color");
 if (color_code == NULL || strlen(color_code) == 0) {
  return PARSE_ERROR_INVALID_COLOR;
 }
 attr = color_char_to_attr(color_code[0]);
 if (attr < 0) {
  return PARSE_ERROR_INVALID_COLOR;
 }
 visuals_flicker_set_color(visuals_flicker_table,
         context->flicker_cycle_index,
         context->flicker_color_index,
         (uint8_t)attr);
 context->flicker_color_index++;
 return PARSE_ERROR_NONE;
}
/**
 * Handle a "cycle" row.
 *
 * \param parser The visuals parser.
 * \return A parser error code.
 */
static enum parser_error visuals_parse_cycle(struct parser *parser)
{
 struct visuals_parse_context *context = parser_priv(parser);
 const char *parsed_group = NULL;
 const char *parsed_name = NULL;
 size_t i = 0;
 size_t current_group_index = 0;
 if (context == NULL) {
  return PARSE_ERROR_INTERNAL;
 }
 /* Move to the next available slot in the cycle list. This will start the
	 * list at 1 (instead of zero), but we need to use cycles_index to keep
	 * track of which cycle we will be adding colors to. */
 context->cycles_index++;
 if (context->cycles_index >= context->max_cycles) {
  return PARSE_ERROR_TOO_MANY_ENTRIES;
 }
 parsed_group = parser_getsym(parser, "group");
 if (parsed_group == NULL || strlen(parsed_group) == 0) {
  return PARSE_ERROR_INVALID_VALUE;
 }
 parsed_name = parser_getsym(parser, "name");
 if (parsed_name == NULL || strlen(parsed_name) == 0) {
  return PARSE_ERROR_INVALID_VALUE;
 }
 /* Create a new cycle with the maximum number of steps (if we can),
	 * otherwise bail. */
 if (context->cycles[context->cycles_index] == NULL) {
  context->cycles[context->cycles_index] = visuals_color_cycle_new(parsed_name,
                   VISUALS_STEPS_MAX,
                   VISUALS_INVALID_COLOR);
  if (context->cycles[context->cycles_index] == NULL) {
   return PARSE_ERROR_INTERNAL;
  }
 }
 /* Find the group that matches the parsed cycle's group or create a new one
	 * if not found. */
 current_group_index = context->max_groups;
 for (i = 0; i < context->max_groups; i++) {
  if (context->group_names[i] == NULL) {
   context->group_names[i] = string_make(parsed_group);
   current_group_index = i;
   break;
  }
  else {
   const char *existing_group = context->group_names[i];
   if (existing_group != NULL && streq(parsed_group, existing_group)) {
    current_group_index = i;
    break;
   }
  }
 }
 /* Assign the parsed cycle to its group. If a cycle with a matching name is
	 * found, the parsed cycle replaces that one, otherwise, it is added to the
	 * end of the group. */
 for (i = 0; i < VISUALS_CYCLES_MAX; i++) {
  size_t offset = current_group_index * VISUALS_CYCLES_MAX + i;
  if (offset >= context->max_group_cycles) {
   continue;
  }
  if (context->group_cycles[offset] == NULL) {
   context->group_cycles[offset] = context->cycles[context->cycles_index];
   break;
  }
  else {
   const char *existing_name = context->group_cycles[offset]->cycle_name;
   if (existing_name != NULL && streq(parsed_name, existing_name)) {
    context->group_cycles[offset] = context->cycles[context->cycles_index];
    break;
   }
  }
 }
 /* Reset the step index before we start adding colors to the cycle. */
 context->cycle_step_index = 0;
 return PARSE_ERROR_NONE;
}
/**
 * Handle a "cycle-color" row.
 *
 * \param parser The visuals parser.
 * \return A parser error code.
 */
static enum parser_error visuals_parse_cycle_color(struct parser *parser)
{
 struct visuals_parse_context *context = parser_priv(parser);
 const char *color_code = NULL;
 int attr = 0;
 if (context == NULL) {
  return PARSE_ERROR_INTERNAL;
 }
 if (context->cycle_step_index >= context->cycles[context->cycles_index]->max_steps) {
  return PARSE_ERROR_TOO_MANY_ENTRIES;
 }
 color_code = parser_getsym(parser, "color");
 if (color_code == NULL || strlen(color_code) == 0) {
  return PARSE_ERROR_INVALID_COLOR;
 }
 attr = color_char_to_attr(color_code[0]);
 if (attr < 0) {
  return PARSE_ERROR_INVALID_COLOR;
 }
 context->cycles[context->cycles_index]->steps[context->cycle_step_index] = attr;
 context->cycle_step_index++;
 return PARSE_ERROR_NONE;
}
/**
 * Create a new instance of the visuals parser.
 *
 * \return A parser or NULL if one could not be created.
 */
static struct parser *visuals_file_parser_init(void)
{
 struct visuals_parse_context *context = visuals_parse_context_new();
 struct parser *parser = parser_new();
 if (context == NULL || parser == NULL) {
  return NULL;
 }
 parser_setpriv(parser, context);
 parser_reg(parser, "flicker sym color str name", visuals_parse_flicker);
 parser_reg(parser, "flicker-color sym color", visuals_parse_flicker_color);
 parser_reg(parser, "cycle sym group sym name", visuals_parse_cycle);
 parser_reg(parser, "cycle-color sym color", visuals_parse_cycle_color);
 return parser;
}
/**
 * Run a parser for a file parser.
 *
 * \param parser The visuals parser.
 * \return A parser error code.
 */
static errr visuals_file_parser_run(struct parser *parser)
{
 return parse_file_quit_not_found(parser, "visuals");
}
/**
 * Clean up the visuals parser itself.
 *
 * \param parser The visuals parser.
 * \return A parser error code.
 */
static errr visuals_file_parser_finish(struct parser *parser)
{
 struct visuals_parse_context *context = parser_priv(parser);
 visuals_cycler_table = visuals_parse_context_convert(context);
 visuals_parse_context_free(context);
 parser_destroy(parser);
 return (visuals_cycler_table == NULL) ? PARSE_ERROR_INTERNAL : PARSE_ERROR_NONE;
}
/**
 * Perform any final things needed after parsing the visuals file.
 */
static void visuals_file_parser_cleanup(void)
{
 /* Stub for now. */
}
/**
 * File parser instance for the visuals file.
 */
static struct file_parser visuals_file_parser = {
 .name = "visuals",
 .init = visuals_file_parser_init,
 .run = visuals_file_parser_run,
 .finish = visuals_file_parser_finish,
 .cleanup = visuals_file_parser_cleanup
};
/* ----- UI Visuals Module ----- */
/**
 * Set up the visuals module. This includes parsing the visuals file.
 */
static void ui_visuals_module_init(void)
{
 event_signal_message(EVENT_INITSTATUS, 0, "Initializing visuals");
 /* Use the same values as the legacy flicker table. */
 visuals_flicker_table = visuals_flicker_new(MAX_COLORS, 3);
 if (visuals_flicker_table == NULL) {
  quit("Unable to allocate flicker table");
 }
 /* Allocate a lookup table for race to color cycles. */
 visuals_color_cycles_by_race = mem_zalloc(sizeof(*visuals_color_cycles_by_race));
 if (visuals_color_cycles_by_race == NULL) {
  quit("Unable to allocate race/color cycle table");
 }
 /* At this point, we don't know how many entries we'll need, so the table
	 * will be resized dynamically. */
 visuals_color_cycles_by_race->max_entries = 0;
 visuals_color_cycles_by_race->alloc_size = 100;
 /* Parsing will result in the cycler table being set up. */
 if (run_parser(&visuals_file_parser)) {
  quit("Cannot initialize visuals");
 }
 if (visuals_file_parser.cleanup) {
  visuals_file_parser.cleanup();
 }
}
/**
 * Tear down the visuals module.
 */
static void ui_visuals_module_cleanup(void)
{
 visuals_flicker_free(visuals_flicker_table);
 visuals_cycler_free(visuals_cycler_table);
 if (visuals_color_cycles_by_race != NULL) {
  if (visuals_color_cycles_by_race->race != NULL) {
   mem_free(visuals_color_cycles_by_race->race);
   visuals_color_cycles_by_race->race = NULL;
  }
  mem_free(visuals_color_cycles_by_race);
  visuals_color_cycles_by_race = NULL;
 }
}
/**
 * Visuals module registration.
 */
struct init_module ui_visuals_module = {
 .name = "ui-visuals",
 .init = ui_visuals_module_init,
 .cleanup = ui_visuals_module_cleanup
};
/**
 * \file ui-wizard.c
 * \brief Implements menus and ui-game.c shims related to debug commands
 *
 * Copyright (c) 2021 Eric Branlund
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
static void proj_display(struct menu *m, int type, bool cursor,
  int row, int col, int wid)
{
 size_t i;
 uint8_t attr = curs_attrs[CURS_KNOWN][(int)cursor];
 const char *proj_name = proj_idx_to_name(type);
 if (type % 2) c_prt(attr, ".........................", row, col);
 c_put_str(attr, proj_name, row, col);
 col += 25;
 if (tile_height == 1) {
  for (i = 0; i < BOLT_MAX; i++) {
   if (use_graphics == GRAPHICS_NONE) {
    /* ASCII is simple */
    wchar_t chars[] = L"*|/-\\";
    col += big_pad(col, row,
     projections[type].color, chars[i]);
   } else {
    col += big_pad(col, row, proj_to_attr[type][i],
     proj_to_char[type][i]);
   }
  }
 } else {
  prt("Change tile_height to 1 to see graphics.", row, col);
 }
}
static const menu_iter proj_iter = {
 NULL, /* get_tag */
 NULL, /* validity */
 proj_display,
 NULL, /* action */
 NULL /* resize */
};
void wiz_proj_demo(void)
{
 struct menu *m = menu_new(MN_SKIN_SCROLL, &proj_iter);
 region loc = { 0, 0, 0, 0 };
 menu_setpriv(m, PROJ_MAX, NULL);
 m->title = "PROJ_ types display";
 menu_layout(m, &loc);
 screen_save();
 clear_from(0);
 menu_select(m, 0, false);
 screen_load();
 mem_free(m);
}
/** Object creation code **/
static bool choose_artifact = false;
static const region wiz_create_item_area = { 0, 0, 0, 0 };
/**
 * Build an "artifact name" and transfer it into a buffer.
 */
static void get_art_name(char *buf, int max, int a_idx)
{
 struct object *obj, *known_obj;
 struct object_kind *kind;
 const struct artifact *art = &a_info[a_idx];
 /* Get object */
 obj = object_new();
 /* Acquire the "kind" index */
 kind = lookup_kind(art->tval, art->sval);
 /* Oops */
 if (!kind) return;
 /* Create the base object */
 object_prep(obj, kind, 0, RANDOMISE);
 /* Mark it as an artifact */
 obj->artifact = art;
 /* Make it known to us */
 known_obj = object_new();
 obj->known = known_obj;
 object_copy(known_obj, obj);
 known_obj->notice |= OBJ_NOTICE_IMAGINED;
 /* Create the artifact description */
 object_desc(buf, max, obj, ODESC_SINGULAR | ODESC_SPOIL, NULL);
 object_delete(NULL, NULL, &known_obj);
 obj->known = NULL;
 object_delete(NULL, NULL, &obj);
}
/**
 * Artifact or object kind selection
 */
static void wiz_create_item_subdisplay(struct menu *m, int oid, bool cursor,
 int row, int col, int width)
{
 int *choices = menu_priv(m);
 int selected = choices[oid];
 char buf[70];
 if (selected == -9999) {
  /*
		 * Super big hack: the special flag should be the last menu
		 * item, with the selected tval stored in the next element.
		 */
  int current_tval = choices[oid + 1];
  char name[70];
  object_base_name(name, sizeof(name), current_tval, true);
  if (choose_artifact) {
   strnfmt(buf, sizeof(buf), "All artifact %s", name);
  } else {
   strnfmt(buf, sizeof(buf), "All %s", name);
  }
 } else {
  if (choose_artifact) {
   get_art_name(buf, sizeof(buf), selected);
  } else {
   object_kind_name(buf, sizeof(buf), &k_info[selected],
    true);
  }
 }
 c_prt(curs_attrs[CURS_KNOWN][0 != cursor], buf, row, col);
}
static bool wiz_create_item_subaction(struct menu *m, const ui_event *e,
 int oid)
{
 int *choices = menu_priv(m);
 int selected = choices[oid];
 if (e->type != EVT_SELECT) return true;
 if (selected == -9999 && !choose_artifact) {
  cmdq_push(CMD_WIZ_CREATE_ALL_OBJ_FROM_TVAL);
  /* Same hack as in wiz_create_item_subdisplay() to get tval. */
  cmd_set_arg_number(cmdq_peek(), "tval", choices[oid + 1]);
  cmd_set_arg_choice(cmdq_peek(), "choice", 0);
 } else if (selected == -9999 && choose_artifact) {
  cmdq_push(CMD_WIZ_CREATE_ALL_ARTIFACT_FROM_TVAL);
  cmd_set_arg_number(cmdq_peek(), "tval", choices[oid + 1]);
 } else if (selected != -9999 && !choose_artifact) {
  cmdq_push(CMD_WIZ_CREATE_OBJ);
  cmd_set_arg_number(cmdq_peek(), "index", choices[oid]);
 } else if (selected != -9999 && choose_artifact) {
  cmdq_push(CMD_WIZ_CREATE_ARTIFACT);
  cmd_set_arg_number(cmdq_peek(), "index", choices[oid]);
 }
 return false;
}
static menu_iter wiz_create_item_submenu = {
 NULL,
 NULL,
 wiz_create_item_subdisplay,
 wiz_create_item_subaction,
 NULL
};
/**
 * Object base kind selection
 */
static void wiz_create_item_display(struct menu *m, int oid, bool cursor,
 int row, int col, int width)
{
 char buf[80];
 if (oid == -9999) {
  if (choose_artifact) {
   my_strcpy(buf, "All artifacts", sizeof(buf));
  } else {
   my_strcpy(buf, "All objects", sizeof(buf));
  }
 } else {
  object_base_name(buf, sizeof(buf), oid, true);
 }
 c_prt(curs_attrs[CURS_KNOWN][0 != cursor], buf, row, col);
}
static bool wiz_create_item_action(struct menu *m, const ui_event *e, int oid)
{
 ui_event ret;
 struct menu *menu;
 char buf[80];
 char title[80];
 int choice[70];
 int num;
 int i;
 if (e->type != EVT_SELECT) return true;
 if (oid == -9999) {
  cmdq_push((choose_artifact) ? CMD_WIZ_CREATE_ALL_ARTIFACT :
   CMD_WIZ_CREATE_ALL_OBJ);
  return false;
 }
 /* Artifacts */
 if (choose_artifact) {
  /* ...We have to search the whole artifact list. */
  for (num = 0, i = 1; (num < 60) && (i < z_info->a_max); i++) {
   const struct artifact *art = &a_info[i];
   if (art->tval != oid) continue;
   choice[num++] = i;
  }
 } else {
  /* Regular objects */
  for (num = 0, i = 1; (num < 60) && (i < z_info->k_max); i++) {
   struct object_kind *kind = &k_info[i];
   if (kind->tval != oid ||
     kf_has(kind->kind_flags, KF_INSTA_ART))
    continue;
   choice[num++] = i;
  }
 }
 /*
	 * Add a flag for an "All <tval>" item to create all svals of that
	 * tval. The tval is stored (in a super hacky way) beyond the end of
	 * the valid menu items. The menu won't render it, but we can still
	 * get to it without doing a bunch of work.
	 */
 choice[num++] = -9999;
 choice[num] = oid;
 screen_save();
 clear_from(0);
 menu = menu_new(MN_SKIN_COLUMNS, &wiz_create_item_submenu);
 menu->selections = all_letters;
 object_base_name(buf, sizeof(buf), oid, true);
 if (choose_artifact) {
  strnfmt(title, sizeof(title), "Which artifact %s? ", buf);
 } else {
  strnfmt(title, sizeof(title), "What kind of %s?", buf);
 }
 menu->title = title;
 menu_setpriv(menu, num, choice);
 menu_layout(menu, &wiz_create_item_area);
 ret = menu_select(menu, 0, false);
 screen_load();
 mem_free(menu);
 return (ret.type == EVT_ESCAPE);
}
static const menu_iter wiz_create_item_menu = {
 NULL,
 NULL,
 wiz_create_item_display,
 wiz_create_item_action,
 NULL
};
/**
 * Choose and create an instance of an artifact or object kind
 */
void wiz_create_item(bool art)
{
 int tvals[TV_MAX];
 int i, n;
 struct menu *menu = menu_new(MN_SKIN_COLUMNS, &wiz_create_item_menu);
 choose_artifact = art;
 menu->selections = all_letters;
 menu->title = art ? "What kind of artifact?" : "What kind of object?";
 /* Make a list of all tvals for the filter */
 for (i = 0, n = 0; i < TV_MAX; i++) {
  /* Only real object bases */
  if (!kb_info[i].name) continue;
  /*
		 * For artifact creation, only include tvals which have an
		 * artifact.
		 */
  if (art) {
   int j;
   for (j = 1; j < z_info->a_max; j++) {
    const struct artifact *art_local = &a_info[j];
    if (art_local->tval == i) break;
   }
   if (j == z_info->a_max) continue;
  }
  tvals[n++] = i;
 }
 tvals[n++] = -9999;
 screen_save();
 clear_from(0);
 menu_setpriv(menu, TV_MAX, kb_info);
 menu_set_filter(menu, tvals, n);
 menu_layout(menu, &wiz_create_item_area);
 menu_select(menu, 0, false);
 screen_load();
 mem_free(menu);
 /* Redraw map */
 player->upkeep->redraw |= (PR_MAP | PR_ITEMLIST);
 handle_stuff(player);
}
/**
 * Confirm before quitting without a save.
 */
void wiz_confirm_quit_no_save(void)
{
 if (get_check("Really quit without saving? ")) {
  cmdq_push(CMD_WIZ_QUIT_NO_SAVE);
 }
}
/**
 * Shim for ui-game.c to call wiz_create_item(true).
 */
void wiz_create_artifact(void)
{
 wiz_create_item(true);
}
/**
 * Shim for ui-game.c to call wiz_create_item(false).
 */
void wiz_create_nonartifact(void)
{
 wiz_create_item(false);
}
/**
 * Shim for ui-game.c to set up CMD_WIZ_ACQUIRE for good objects.
 */
void wiz_acquire_good(void)
{
 cmdq_push(CMD_WIZ_ACQUIRE);
 cmd_set_arg_choice(cmdq_peek(), "choice", 0);
}
/**
 * Shim for ui-game.c to set up CMD_WIZ_ACQUIRE for great objects.
 */
void wiz_acquire_great(void)
{
 cmdq_push(CMD_WIZ_ACQUIRE);
 cmd_set_arg_choice(cmdq_peek(), "choice", 1);
}
/**
 * Shim for ui-game.c to set up CMD_WIZ_CREATE_ALL_OBJ_FROM_TVAL with
 * instant artifacts included.
 */
void wiz_create_all_for_tval(void)
{
 cmdq_push(CMD_WIZ_CREATE_ALL_OBJ_FROM_TVAL);
 cmd_set_arg_choice(cmdq_peek(), "choice", 1);
}
/**
 * Shim for ui-game.c to set up CMD_WIZ_LEARN_OBJECT_KINDS for all levels.
 */
void wiz_learn_all_object_kinds(void)
{
 cmdq_push(CMD_WIZ_LEARN_OBJECT_KINDS);
 cmd_set_arg_number(cmdq_peek(), "level", 100);
}
/**
 * \file wiz-debug.c
 * \brief Implement miscellaneous debug mode functions
 *
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * What happens when you cheat death.  Tsk, tsk.
 */
void wiz_cheat_death(void)
{
 /* Mark social class, reset age, if needed */
 player->age = 1;
 player->noscore |= NOSCORE_WIZARD;
 player->is_dead = false;
 /* Restore hit & spell points */
 player->chp = player->mhp;
 player->csp = player->msp;
 /* Healing */
 (void)player_clear_timed(player, TMD_BLIND, true, false);
 (void)player_clear_timed(player, TMD_CONFUSED, true, false);
 (void)player_clear_timed(player, TMD_POISONED, true, false);
 (void)player_clear_timed(player, TMD_AFRAID, true, false);
 (void)player_clear_timed(player, TMD_ENTRANCED, true, false);
 (void)player_clear_timed(player, TMD_IMAGE, true, false);
 (void)player_clear_timed(player, TMD_STUN, true, false);
 (void)player_clear_timed(player, TMD_CUT, true, false);
 /* Prevent starvation */
 player_set_timed(player, TMD_FOOD, PY_FOOD_FULL - 1, false, false);
 /* Note cause of death XXX XXX XXX */
 my_strcpy(player->died_from, "Cheating death", sizeof(player->died_from));
 /* Back to the start */
 dungeon_change_level(player, 1);
}
/**
 * \file wiz-spoil.c
 * \brief Spoiler generation
 *
 * Copyright (c) 1997 Ben Harrison, and others
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * ------------------------------------------------------------------------
 * Item Spoilers by Ben Harrison (benh@phial.com)
 * ------------------------------------------------------------------------ */
/**
 * The spoiler file being created
 */
static ang_file *fh = NULL;
/**
 * Write out `n' of the character `c' to the spoiler file
 */
static void spoiler_out_n_chars(int n, char c)
{
 while (--n >= 0) file_writec(fh, c);
}
/**
 * Write out `n' blank lines to the spoiler file
 */
static void spoiler_blanklines(int n)
{
 spoiler_out_n_chars(n, '\n');
}
/**
 * Write a line to the spoiler file and then "underline" it with hypens
 */
static void spoiler_underline(const char *str, char c)
{
 text_out("%s", str);
 text_out("\n");
 spoiler_out_n_chars(strlen(str), c);
 text_out("\n");
}
/**
 * The basic items categorized by type
 */
static const grouper group_item[] =
{
 { TV_ARROW, "Ammo" },
 { TV_BOW, "Bows" },
 { TV_SWORD, "Weapons" },
 { TV_POLEARM, NULL },
 { TV_HAFTED, NULL },
 { TV_DIGGING, NULL },
 { TV_SOFT_ARMOR,"Armour (Body)" },
 { TV_MAIL, NULL },
 { TV_CLOAK, "Armour (Misc)" },
 { TV_SHIELD, NULL },
 { TV_HELM, NULL },
 { TV_CROWN, NULL },
 { TV_GLOVES, NULL },
 { TV_BOOTS, NULL },
 { TV_AMULET, "Amulets" },
 { TV_RING, "Rings" },
 { TV_POTION, "Potions" },
 { TV_FOOD, "Food" },
 { TV_HERB, "Herbs" },
 { TV_HORN, "Horns" },
 { TV_CHEST, "Chests" },
 { TV_LIGHT, "Lights and fuel" },
 { TV_FLASK, NULL },
 { 0, "" }
};
/**
 * Describe the kind
 */
static void kind_info(char *buf, size_t buf_len, char *dam, size_t dam_len,
  char *wgt, size_t wgt_len, int *lev, int32_t *val, int k)
{
 struct object_kind *kind = &k_info[k];
 struct object *obj = object_new(), *known_obj = object_new();
 int i;
 /* Prepare a fake item */
 object_prep(obj, kind, 0, MAXIMISE);
 /* Cancel bonuses */
 for (i = 0; i < OBJ_MOD_MAX; i++)
  obj->modifiers[i] = 0;
 obj->att = 0;
 obj->evn = 0;
 /* Level */
 (*lev) = kind->level;
 /* Make known */
 object_copy(known_obj, obj);
 obj->known = known_obj;
 /* Value */
 (*val) = object_value(obj);
 /* Description (too brief) */
 if (buf) {
  object_desc(buf, buf_len, obj, ODESC_BASE | ODESC_SPOIL, NULL);
 }
 /* Weight */
 if (wgt)
  strnfmt(wgt, wgt_len, "%3d.%d", obj->weight / 10, obj->weight % 10);
 /* Hack */
 if (!dam) {
  object_delete(NULL, NULL, &known_obj);
  object_delete(NULL, NULL, &obj);
  return;
 }
 /* Misc info */
 dam[0] = '\0';
 /* Damage */
 if (tval_is_ammo(obj) || tval_is_melee_weapon(obj))
  strnfmt(dam, dam_len, "%dd%d", obj->dd, obj->ds);
 else if (tval_is_armor(obj))
  strnfmt(dam, dam_len, "%dd%d", obj->pd, obj->ps);
 object_delete(NULL, NULL, &known_obj);
 object_delete(NULL, NULL, &obj);
}
/**
 * Create a spoiler file for items
 */
void spoil_obj_desc(const char *fname)
{
 int i, k, s, t, n = 0;
 uint16_t *who;
 char buf[1024];
 char wgt[80];
 char dam[80];
 const char *format = "%-51s  %7s%6s%4s%9s\n";
 /* Open the file */
 path_build(buf, sizeof(buf), ANGBAND_DIR_USER, fname);
 fh = file_open(buf, MODE_WRITE, FTYPE_TEXT);
 /* Oops */
 if (!fh) {
  msg("Cannot create spoiler file.");
  return;
 }
 /* Allocate the "who" array */
 who = mem_zalloc(z_info->r_max * sizeof(uint16_t));
 /* Header */
 file_putf(fh, "Spoiler File -- Basic Items (%s)\n\n\n", buildid);
 /* More Header */
 file_putf(fh, format, "Description", "Dam/AC", "Wgt", "Lev", "Cost");
 file_putf(fh, format, "----------------------------------------",
         "------", "---", "---", "----");
 /* List the groups */
 for (i = 0; true; i++) {
  /* Write out the group title */
  if (group_item[i].name) {
   /* Hack -- bubble-sort by cost and then level */
   for (s = 0; s < n - 1; s++) {
    for (t = 0; t < n - 1; t++) {
     int i1 = t;
     int i2 = t + 1;
     int e1;
     int e2;
     int32_t t1;
     int32_t t2;
     kind_info(NULL, 0, NULL, 0, NULL, 0, &e1, &t1, who[i1]);
     kind_info(NULL, 0, NULL, 0, NULL, 0, &e2, &t2, who[i2]);
     if ((t1 > t2) || ((t1 == t2) && (e1 > e2))) {
      int tmp = who[i1];
      who[i1] = who[i2];
      who[i2] = tmp;
     }
    }
   }
   /* Spoil each item */
   for (s = 0; s < n; s++) {
    int e;
    int32_t v;
    size_t u8len;
    /* Describe the kind */
    kind_info(buf, sizeof(buf), dam, sizeof(dam), wgt, sizeof(wgt),
        &e, &v, who[s]);
    /* Dump it */
    /*
				 * Per C99, width specifications to %s measure
				 * bytes.  To align the columns if the
				 * description has characters that take
				 * multiple bytes, handle the first column
				 * separately.  If the description has
				 * decomposed characters (ones where multiple
				 * Unicode code points combine to form one
				 * printed character), the following columns
				 * will still be out of alignment, but they'll
				 * be closer to aligned than what the standard
				 * library functions would do.
				 */
    u8len = utf8_strlen(buf);
    if (u8len < 51) {
     file_putf(fh, "  %s%*s", buf,
      (int) (51 - u8len), " ");
    } else {
     if (u8len > 51) {
      utf8_clipto(buf, 51);
     }
     file_putf(fh, "  %s", buf);
    }
    file_putf(fh, "%7s%6s%4d%9ld\n", dam, wgt, e,
        (long)(v));
   }
   /* Start a new set */
   n = 0;
   /* Notice the end */
   if (!group_item[i].tval) break;
   /* Start a new set */
   file_putf(fh, "\n\n%s\n\n", group_item[i].name);
  }
  /* Get legal item types */
  for (k = 1; k < z_info->k_max; k++) {
   struct object_kind *kind = &k_info[k];
   /* Skip wrong tvals */
   if (kind->tval != group_item[i].tval) continue;
   /* Hack -- Skip instant-artifacts */
   if (kf_has(kind->kind_flags, KF_INSTA_ART)) continue;
   /* Save the index */
   who[n++] = k;
  }
 }
 /* Free the "who" array */
 mem_free(who);
 /* Check for errors */
 if (!file_close(fh)) {
  msg("Cannot close spoiler file.");
  return;
 }
 /* Message */
 msg("Successfully created a spoiler file.");
}
/**
 * ------------------------------------------------------------------------
 * Artifact Spoilers by: randy@PICARD.tamu.edu (Randy Hutson)
 *
 * (Mostly) rewritten in 2002 by Andi Sidwell and Robert Ruehlmann.
 * ------------------------------------------------------------------------ */
/**
 * The artifacts categorized by type
 */
static const grouper group_artifact[] =
{
 { TV_SWORD, "Edged Weapons" },
 { TV_POLEARM, "Polearms" },
 { TV_HAFTED, "Hafted Weapons" },
 { TV_BOW, "Bows" },
 { TV_DIGGING, "Diggers" },
 { TV_SOFT_ARMOR, "Body Armor" },
 { TV_MAIL, NULL },
 { TV_CLOAK, "Cloaks" },
 { TV_SHIELD, "Shields" },
 { TV_HELM, "Helms/Crowns" },
 { TV_CROWN, NULL },
 { TV_GLOVES, "Gloves" },
 { TV_BOOTS, "Boots" },
 { TV_LIGHT, "Light Sources" },
 { TV_AMULET, "Amulets" },
 { TV_RING, "Rings" },
 { 0, NULL }
};
/**
 * Create a spoiler file for artifacts
 */
void spoil_artifact(const char *fname)
{
 int i, j;
 char buf[1024];
 /* Build the filename */
 path_build(buf, sizeof(buf), ANGBAND_DIR_USER, fname);
 fh = file_open(buf, MODE_WRITE, FTYPE_TEXT);
 /* Oops */
 if (!fh) {
  msg("Cannot create spoiler file.");
  return;
 }
 /* Dump to the spoiler file */
 text_out_hook = text_out_to_file;
 text_out_file = fh;
 /* Dump the header */
 spoiler_underline(format("Artifact Spoilers for %s", buildid), '=');
 text_out("\n Randart seed is %lu\n", (unsigned long)seed_randart);
 /* List the artifacts by tval */
 for (i = 0; group_artifact[i].tval; i++) {
  /* Write out the group title */
  if (group_artifact[i].name) {
   spoiler_blanklines(2);
   spoiler_underline(group_artifact[i].name, '=');
   spoiler_blanklines(1);
  }
  /* Now search through all of the artifacts */
  for (j = 1; j < z_info->a_max; ++j) {
   const struct artifact *art = &a_info[j];
   struct artifact artc;
   char buf2[80];
   struct object *obj, *known_obj;
   /* We only want objects in the current group */
   if (art->tval != group_artifact[i].tval) continue;
   /* Get local object */
   obj = object_new();
   known_obj = object_new();
   /*
			 * Make a copy of the artifact state; hide the
			 * flavour text:  spoilers spoil the mechanics, not
			 * the atmosphere.
			 */
   memcpy(&artc, art, sizeof(artc));
   artc.text = NULL;
   /* Attempt to "forge" the artifact */
   if (!make_fake_artifact(obj, &artc)) {
    object_delete(NULL, NULL, &known_obj);
    object_delete(NULL, NULL, &obj);
    continue;
   }
   /* Grab artifact name */
   object_copy(known_obj, obj);
   obj->known = known_obj;
   object_desc(buf2, sizeof(buf2), obj, ODESC_PREFIX |
    ODESC_COMBAT | ODESC_EXTRA | ODESC_SPOIL, NULL);
   /* Print name and underline */
   spoiler_underline(buf2, '-');
   /* Write out the artifact description to the spoiler file */
   object_info_spoil(fh, obj, 80);
   /*
			 * Determine the minimum and maximum depths an
			 * artifact can appear, its rarity, its weight, and
			 * its power rating.
			 */
   text_out("\nLevel %u, Rarity %u, %d.%d lbs\n",
      art->level, art->rarity, (art->weight / 10),
      (art->weight % 10));
   /* Terminate the entry */
   spoiler_blanklines(2);
   object_delete(NULL, NULL, &known_obj);
   object_delete(NULL, NULL, &obj);
  }
 }
 /* Check for errors */
 if (!file_close(fh)) {
  msg("Cannot close spoiler file.");
  return;
 }
 /* Message */
 msg("Successfully created a spoiler file.");
}
/**
 * ------------------------------------------------------------------------
 * Brief monster spoilers
 * ------------------------------------------------------------------------ */
/**
 * Create a brief spoiler file for monsters
 */
void spoil_mon_desc(const char *fname)
{
 int i, n = 0;
 char buf[1024];
 char nam[80];
 char lev[80];
 char rar[80];
 char health[80];
 char prot[80];
 char graphics[80];
 uint16_t *who;
 /* Build the filename */
 path_build(buf, sizeof(buf), ANGBAND_DIR_USER, fname);
 fh = file_open(buf, MODE_WRITE, FTYPE_TEXT);
 /* Oops */
 if (!fh) {
  msg("Cannot create spoiler file.");
  return;
 }
 /* Dump the header */
 file_putf(fh, "Monster Spoilers for %s\n", buildid);
 file_putf(fh, "------------------------------------------\n\n");
 /* Dump the header */
 file_putf(fh, "%-40.40s%4s%4s%8s%8s  %11.11s\n",
         "Name", "Lev", "Rar", "Hit", "Prot", "Visual Info");
 file_putf(fh, "%-40.40s%4s%4s%8s%8s  %11.11s\n",
         "----", "---", "---", "---", "----", "-----------");
 /* Allocate the "who" array */
 who = mem_zalloc(z_info->r_max * sizeof(uint16_t));
 /* Scan the monsters (except the ghost) */
 for (i = 1; i < z_info->r_max - 1; i++) {
  struct monster_race *race = &r_info[i];
  /* Use that monster */
  if (race->name) who[n++] = (uint16_t)i;
 }
 /* Sort the array by dungeon depth of monsters */
 sort(who, n, sizeof(*who), cmp_monsters);
 /* Scan again */
 for (i = 0; i < n; i++) {
  struct monster_race *race = &r_info[who[i]];
  const char *name = race->name;
  size_t u8len;
  /* Get the "name" */
  if (rf_has(race->flags, RF_QUESTOR))
   strnfmt(nam, sizeof(nam), "[Q] %s", name);
  else if (rf_has(race->flags, RF_UNIQUE))
   strnfmt(nam, sizeof(nam), "[U] %s", name);
  else
   strnfmt(nam, sizeof(nam), "The %s", name);
  /* Level */
  strnfmt(lev, sizeof(lev), "%d", race->level);
  /* Rarity */
  strnfmt(rar, sizeof(rar), "%d", race->rarity);
  /* Hit Dice */
  strnfmt(health, sizeof(health), "%dd%d", race->hdice, race->hside);
  /* Protection Dice */
  strnfmt(prot, sizeof(prot), "%d:%dd%d", race->evn, race->pd, race->ps);
  /* Hack -- use visual instead */
  strnfmt(graphics, sizeof(graphics), "%s '%c'",
    attr_to_text(race->d_attr), race->d_char);
  /*
		 * Dump the info.  The rationale for handling the first column
		 * separately is the same as in spoil_obj_desc():  better
		 * alignment if there are multibyte characters in the name.
		 */
  u8len = utf8_strlen(nam);
  if (u8len < 40) {
   file_putf(fh, "%s%*s", nam, (int) (40 - u8len), " ");
  } else {
   if (u8len > 40) {
    utf8_clipto(nam, 40);
   }
   file_putf(fh, "%s", nam);
  }
  file_putf(fh, "%4s%4s%8s%8s  %11.11s\n",
          lev, rar, health, prot, graphics);
 }
 /* End it */
 file_putf(fh, "\n");
 /* Free the "who" array */
 mem_free(who);
 /* Check for errors */
 if (!file_close(fh)) {
  msg("Cannot close spoiler file.");
  return;
 }
 /* Worked */
 msg("Successfully created a spoiler file.");
}
/**
 * ------------------------------------------------------------------------
 * Monster spoilers originally by: smchorse@ringer.cs.utsa.edu (Shawn McHorse)
 * ------------------------------------------------------------------------ */
/**
 * Create a spoiler file for monsters (-SHAWN-)
 */
void spoil_mon_info(const char *fname)
{
 char buf[1024];
 int i, n;
 uint16_t *who;
 int count = 0;
 textblock *tb = NULL;
 /* Open the file */
 path_build(buf, sizeof(buf), ANGBAND_DIR_USER, fname);
 fh = file_open(buf, MODE_WRITE, FTYPE_TEXT);
 if (!fh) {
  msg("Cannot create spoiler file.");
  return;
 }
 /* Dump the header */
 tb = textblock_new();
 textblock_append(tb, "Monster Spoilers for %s\n", buildid);
 textblock_append(tb, "------------------------------------------\n\n");
 textblock_to_file(tb, fh, 0, 75);
 textblock_free(tb);
 tb = NULL;
 /* Allocate the "who" array */
 who = mem_zalloc(z_info->r_max * sizeof(uint16_t));
 /* Scan the monsters */
 for (i = 1; i < z_info->r_max; i++) {
  struct monster_race *race = &r_info[i];
  /* Use that monster */
  if (race->name) who[count++] = (uint16_t)i;
 }
 sort(who, count, sizeof(*who), cmp_monsters);
 /* List all monsters in order. */
 for (n = 0; n < count; n++) {
  int r_idx = who[n];
  const struct monster_race *race = &r_info[r_idx];
  const struct monster_lore *lore = &l_list[r_idx];
  tb = textblock_new();
  /* Line 1: prefix, name, color, and symbol */
  if (rf_has(race->flags, RF_QUESTOR))
   textblock_append(tb, "[Q] ");
  else if (rf_has(race->flags, RF_UNIQUE))
   textblock_append(tb, "[U] ");
  else
   textblock_append(tb, "The ");
  /* As of 3.5, race->name and race->text are stored as UTF-8 strings;
		 * there is no conversion from the source edit files. */
  textblock_append(tb, "%s", race->name);
  textblock_append(tb, "  ("); /* ---)--- */
  textblock_append(tb, "%s", attr_to_text(race->d_attr));
  textblock_append(tb, " '%c')\n", race->d_char);
  /* Line 2: number, level, rarity, speed, HP, AC, exp */
  textblock_append(tb, "=== ");
  textblock_append(tb, "Num:%d  ", r_idx);
  textblock_append(tb, "Lev:%d  ", race->level);
  textblock_append(tb, "Rar:%d  ", race->rarity);
  if (race->speed >= 110)
   textblock_append(tb, "Spd:+%d  ", (race->speed - 110));
  else
   textblock_append(tb, "Spd:-%d  ", (110 - race->speed));
  textblock_append(tb, "Hp:%dd%d  ", race->hdice, race->hside);
  textblock_append(tb, "Prot:%d:%dd%d  ", race->evn, race->pd, race->ps);
  /* Normal description (with automatic line breaks) */
  lore_description(tb, race, lore, true);
  textblock_append(tb, "\n");
  textblock_to_file(tb, fh, 0, 75);
  textblock_free(tb);
  tb = NULL;
 }
 /* Free the "who" array */
 mem_free(who);
 /* Check for errors */
 if (!file_close(fh)) {
  msg("Cannot close spoiler file.");
  return;
 }
 msg("Successfully created a spoiler file.");
}
/**
 * \file wiz-stats.c
 * \brief Statistics collection on dungeon generation
 *
 * Copyright (c) 2008 Andi Sidwell
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/**
 * The stats programs here will provide information on the dungeon, the monsters
 * in it, and the items that they drop.  Statistics are gotten from a given
 * level by generating a new level, collecting all the items (noting if they
 * were generated in a vault).  Then all non-unique monsters are killed and
 * their stats are tracked.
 * The items from these monster drops are then collected and analyzed.  Lastly,
 * all unique monsters are killed, and their drops are analyzed.  In this way,
 * it is possible to separate unique drops and normal monster drops.
 *
 * There are two options for simulating the entirety of the dungeon.  There is
 * a "diving" option that begins each level with all artifacts and uniques
 * available; and there is a "level-clearing" option that simulates all 100
 * levels of the dungeon, removing artifacts and uniques as they are
 * discovered/killed.  "diving" option only catalogues every 5 levels.
 *
 * At the end of the "level-clearing" log file, extra post-processing is done
 * to find the mean and standard deviation for the level you are likely to
 * first gain an item with a key resistance or item.
 * 
 * In addition to these sims there is a shorter sim that tests for dungeon
 * connectivity.
*/
bool stats_are_enabled(void)
{
 msg("Statistics generation not turned on in this build.");
 return false;
}
void stats_collect(int nsim, int simtype)
{
}
void disconnect_stats(int nsim, bool stop_on_disconnect)
{
}
/**
 * Visit all grids in a chunk and report requested counts.
 * \param c Is the chunk to use.
 * \param gpreds Is a n_gpred element array.  For each element in the array,
 * the in_vault_count, in_room_count, and in_other_count fields are set to
 * zero at the start of this function.  Then for each grid in the chunk where
 * the pred field evaluates to be true, the following is done: if
 * square_isvault() is also true for that grid, in_vault_count is incremented;
 * if square_isvault() is not true but square_isroom() is true for that grid,
 * in_room_count is incremented; if both square_isvault() and square_isroom()
 * ar false for that grid, in_other_count is incremented.
 * \param n_gpred Is the number of elements in gpreds.
 * \param npreds Is a n_npred element array.  For each element in the array,
 * all elmeents of vault_histogram, room_histogram, and other_histogram are
 * set to zero as the start of this function.  Then for each grid in the chunk
 * where the pred field evaluates to be true, count the number of immediate
 * neighbors where the neigh field evaluates to be true.  If square_isvault()
 * is true for the grid, increment the vault_histogram element corresponding to
 * that count; if square_isvault() is not true but square_isroom() is true for
 * the grid, increment the room_histogram element correspoding to that count;
 * if both square_isvault() and square_isroom() are false for the grid,
 * increment the other_histogram element corresponding to that count.
 * \param n_npred Is the number of elements in npreds.
 */
void stat_grid_counter(struct chunk *c, struct grid_counter_pred *gpreds,
  int n_gpred, struct neighbor_counter_pred *npreds, int n_npred)
{
 int i;
 struct loc grid;
 /* Initialize counts. */
 for (i = 0; i < n_gpred; ++i) {
  gpreds[i].in_vault_count = 0;
  gpreds[i].in_room_count = 0;
  gpreds[i].in_other_count = 0;
 }
 for (i = 0; i < n_npred; ++i) {
  int j;
  for (j = 0; j < 9; ++j) {
   npreds[i].vault_histogram[j] = 0;
   npreds[i].room_histogram[j] = 0;
   npreds[i].other_histogram[j] = 0;
  }
 }
 /* Visit every grid. */
 for (grid.y = 0; grid.y < c->height; ++grid.y) {
  for (grid.x = 0; grid.x < c->width; ++grid.x) {
   if (square_isvault(c, grid)) {
    for (i = 0; i < n_gpred; ++i) {
     if ((*gpreds[i].pred)(c, grid)) {
      ++gpreds[i].in_vault_count;
     }
    }
    for (i = 0; i < n_npred; ++i) {
     if ((npreds[i].pred)(c, grid)) {
      int count = count_neighbors(
       NULL, c, grid,
       npreds[i].neigh, false);
      assert(count >= 0 &&
       count <= 8);
      ++npreds[i].vault_histogram[count];
     }
    }
   } else if (square_isroom(c, grid)) {
    for (i = 0; i < n_gpred; ++i) {
     if ((*gpreds[i].pred)(c, grid)) {
      ++gpreds[i].in_room_count;
     }
    }
    for (i = 0; i < n_npred; ++i) {
     if ((npreds[i].pred)(c, grid)) {
      int count = count_neighbors(
       NULL, c, grid,
       npreds[i].neigh, false);
      assert(count >= 0 &&
       count <= 8);
      ++npreds[i].room_histogram[count];
     }
    }
   } else {
    for (i = 0; i < n_gpred; ++i) {
     if ((*gpreds[i].pred)(c, grid)) {
      ++gpreds[i].in_other_count;
     }
    }
    for (i = 0; i < n_npred; ++i) {
     if ((npreds[i].pred)(c, grid)) {
      int count = count_neighbors(
       NULL, c, grid,
       npreds[i].neigh, false);
      assert(count >= 0 &&
       count <= 8);
      ++npreds[i].other_histogram[count];
     }
    }
   }
  }
 }
}
static bool is_easily_traversed(struct chunk *c, struct loc grid)
{
 return square_ispassable(c, grid) || square_isdoor(c, grid) ||
  square_isrubble(c, grid);
}
static bool is_floor_trap(struct chunk *c, struct loc grid)
{
 /* Using square_istrap by itself will include locked doors. */
 return square_istrap(c, grid) && !square_iscloseddoor(c, grid);
}
/**
 * Use stat_grid_counter() to get the grid counts and immediate neighborhood
 * characteristics most likely to be useful for assessing map quality and
 * balance.
 * \param c Is the chunk to use.
 * \param counts Is a three element array of the count structures.  The first
 * element will hold the count of the features in vaults.  The second element
 * will hold the count of the features in rooms that are not also vaults.  The
 * third element will hold the count of features that are neither in vaults nor
 * rooms.  For all three, the traversable_neighbor_histogram field has the
 * histogram of the number of immediate neighbors that are fairly easily
 * traversed by the player (square_ispassable(), square_isdoor(), or
 * square_isrubble()) for all easily traversable grids in the respective
 * category (vault, room, other).  For the other category, that's a measure of
 * how often corridors bend, intersect, or bunch up into wide corridors.
 */
void stat_grid_counter_simple(struct chunk *c, struct grid_counts counts[3])
{
 struct grid_counter_pred gpreds[] = {
  { square_isfloor, 0, 0, 0 },
  { square_isupstairs, 0, 0, 0 },
  { square_isdownstairs, 0, 0, 0 },
  { is_floor_trap, 0, 0, 0 },
  { square_isforge, 0, 0, 0 },
  { square_isrubble, 0, 0, 0 },
  { square_isopendoor, 0, 0, 0 },
  { square_iscloseddoor, 0, 0, 0 },
  { square_isbrokendoor, 0, 0, 0 },
  { square_issecretdoor, 0, 0, 0 },
 };
 struct neighbor_counter_pred npreds[] = {
  { is_easily_traversed, is_easily_traversed,
   { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
   { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
   { 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
 };
 int i;
 stat_grid_counter(c, gpreds, (int) N_ELEMENTS(gpreds),
  npreds, (int) N_ELEMENTS(npreds));
 counts[0].floor = gpreds[0].in_vault_count;
 counts[0].upstair = gpreds[1].in_vault_count;
 counts[0].downstair = gpreds[2].in_vault_count;
 counts[0].trap = gpreds[3].in_vault_count;
 counts[0].forge = gpreds[4].in_vault_count;
 counts[0].rubble = gpreds[5].in_vault_count;
 counts[0].open_door = gpreds[6].in_vault_count;
 counts[0].closed_door = gpreds[7].in_vault_count;
 counts[0].broken_door = gpreds[8].in_vault_count;
 counts[0].secret_door = gpreds[9].in_vault_count;
 for (i = 0; i < 9; ++i) {
  counts[0].traversable_neighbor_histogram[i] =
   npreds[0].vault_histogram[i];
 }
 counts[1].floor = gpreds[0].in_room_count;
 counts[1].upstair = gpreds[1].in_room_count;
 counts[1].downstair = gpreds[2].in_room_count;
 counts[1].trap = gpreds[3].in_room_count;
 counts[1].forge = gpreds[4].in_room_count;
 counts[1].rubble = gpreds[5].in_room_count;
 counts[1].open_door = gpreds[6].in_room_count;
 counts[1].closed_door = gpreds[7].in_room_count;
 counts[1].broken_door = gpreds[8].in_room_count;
 counts[1].secret_door = gpreds[9].in_room_count;
 for (i = 0; i < 9; ++i) {
  counts[1].traversable_neighbor_histogram[i] =
   npreds[0].room_histogram[i];
 }
 counts[2].floor = gpreds[0].in_other_count;
 counts[2].upstair = gpreds[1].in_other_count;
 counts[2].downstair = gpreds[2].in_other_count;
 counts[2].trap = gpreds[3].in_other_count;
 counts[2].forge = gpreds[4].in_other_count;
 counts[2].rubble = gpreds[5].in_other_count;
 counts[2].open_door = gpreds[6].in_other_count;
 counts[2].closed_door = gpreds[7].in_other_count;
 counts[2].broken_door = gpreds[8].in_other_count;
 counts[2].secret_door = gpreds[9].in_other_count;
 for (i = 0; i < 9; ++i) {
  counts[2].traversable_neighbor_histogram[i] =
   npreds[0].other_histogram[i];
 }
}
/**
 * \file buildid.c
 * \brief Compile in build details
 *
 * Copyright (c) 2011 Andi Sidwell
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/*
 * Allow the build system to generate version.h (and define
 * the HAVE_VERSION_H preprocessor macro) or get the version via the BUILD_ID
 * preprocessor macro.  If neither is available, use a sensible default.
 */
const char *buildid = VERSION_NAME " " "1.4.0";
const char *buildver = "1.4.0";
/**
 * Hack -- Link a copyright message into the executable
 */
const char *copyright =
 "Copyright (c) 1987-2024 Angband contributors.\n"
 "\n"
 "This work is free software; you can redistribute it and/or modify it\n"
 "under the terms of either:\n"
 "\n"
 "a) the GNU General Public License as published by the Free Software\n"
 "   Foundation, version 2, or\n"
 "\n"
 "b) the Angband licence:\n"
 "   This software may be copied and distributed for educational, research,\n"
 "   and not for profit purposes provided that this copyright and statement\n"
 "   are included in all such copies.  Other copyrights may also apply.\n";
/**
 * \file z-bitflag.c
 * \brief Low-level bit vector manipulation
 *
 * Copyright (c) 2010 William L Moore
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Tests if a flag is "on" in a bitflag set.
 *
 * true is returned when `flag` is on in `flags`, and false otherwise.
 * The flagset size is supplied in `size`.
 */
bool flag_has(const bitflag *flags, const size_t size, const int flag)
{
 const size_t flag_offset = FLAG_OFFSET(flag);
 const int flag_binary = FLAG_BINARY(flag);
 if (flag == FLAG_END) return false;
 assert(flag_offset < size);
 if (flags[flag_offset] & flag_binary) return true;
 return false;
}
bool flag_has_dbg(const bitflag *flags, const size_t size, const int flag,
      const char *fi, const char *fl)
{
 const size_t flag_offset = FLAG_OFFSET(flag);
 const int flag_binary = FLAG_BINARY(flag);
 if (flag == FLAG_END) return false;
 if (flag_offset >= size) {
  quit_fmt("Error in flag_has(%s, %s): FlagID[%d] Size[%u] FlagOff[%u] FlagBV[%d]\n",
           fi, fl, flag, (unsigned int) size, (unsigned int) flag_offset, flag_binary);
 }
 if (flags[flag_offset] & flag_binary) return true;
 return false;
}
/**
 * Iterates over the flags which are "on" in a bitflag set.
 *
 * Returns the next on flag in `flags`, starting from (and including)
 * `flag`. FLAG_END will be returned when the end of the flag set is reached.
 * Iteration will start at the beginning of the flag set when `flag` is
 * FLAG_END. The bitfield size is supplied in `size`.
 */
int flag_next(const bitflag *flags, const size_t size, const int flag)
{
 const int max_flags = FLAG_MAX(size);
 int f, flag_offset, flag_binary;
 for (f = flag; f < max_flags; f++) {
  flag_offset = FLAG_OFFSET(f);
  flag_binary = FLAG_BINARY(f);
  if (flags[flag_offset] & flag_binary) return f;
 }
 return FLAG_END;
}
/**
 * Counts the flags which are "on" in a bitflag set.
 *
 * The bitfield size is supplied in `size`.
 */
int flag_count(const bitflag *flags, const size_t size)
{
 size_t i, j;
 int count = 0;
 for (i = 0; i < size; i++) {
  for (j = 1; j <= FLAG_WIDTH; j++) {
   if (flags[i] & FLAG_BINARY(j)) {
    count++;
   }
  }
 }
 return count;
}
/**
 * Tests a bitfield for emptiness.
 *
 * true is returned when no flags are set in `flags`, and false otherwise.
 * The bitfield size is supplied in `size`.
 */
bool flag_is_empty(const bitflag *flags, const size_t size)
{
 size_t i;
 for (i = 0; i < size; i++)
  if (flags[i] > 0) return false;
 return true;
}
/**
 * Tests a bitfield for fullness.
 *
 * true is returned when all flags are set in `flags`, and false otherwise.
 * The bitfield size is supplied in `size`.
 */
bool flag_is_full(const bitflag *flags, const size_t size)
{
 size_t i;
 for (i = 0; i < size; i++)
  if (flags[i] != (bitflag) -1) return false;
 return true;
}
/**
 * Tests two bitfields for intersection.
 *
 * true is returned when any flag is set in both `flags1` and `flags2`, and
 * false otherwise. The size of the bitfields is supplied in `size`.
 */
bool flag_is_inter(const bitflag *flags1, const bitflag *flags2,
       const size_t size)
{
 size_t i;
 for (i = 0; i < size; i++)
  if (flags1[i] & flags2[i]) return true;
 return false;
}
/**
 * Test if one bitfield is a subset of another.
 *
 * true is returned when every set flag in `flags2` is also set in `flags1`,
 * and false otherwise. The size of the bitfields is supplied in `size`.
 */
bool flag_is_subset(const bitflag *flags1, const bitflag *flags2,
     const size_t size)
{
 size_t i;
 for (i = 0; i < size; i++)
  if (~flags1[i] & flags2[i]) return false;
 return true;
}
/**
 * Tests two bitfields for equality.
 *
 * true is returned when the flags set in `flags1` and `flags2` are identical,
 * and false otherwise. the size of the bitfields is supplied in `size`.
 */
bool flag_is_equal(const bitflag *flags1, const bitflag *flags2,
       const size_t size)
{
 return (!memcmp(flags1, flags2, size * sizeof(bitflag)));
}
/**
 * Sets one bitflag in a bitfield.
 *
 * The bitflag identified by `flag` is set in `flags`. The bitfield size is
 * supplied in `size`.  true is returned when changes were made, false
 * otherwise.
 */
bool flag_on(bitflag *flags, const size_t size, const int flag)
{
 const size_t flag_offset = FLAG_OFFSET(flag);
 const int flag_binary = FLAG_BINARY(flag);
 assert(flag_offset < size);
 if (flags[flag_offset] & flag_binary) return false;
 flags[flag_offset] |= flag_binary;
 return true;
}
bool flag_on_dbg(bitflag *flags, const size_t size, const int flag,
     const char *fi, const char *fl)
{
 const size_t flag_offset = FLAG_OFFSET(flag);
 const int flag_binary = FLAG_BINARY(flag);
 if (flag_offset >= size) {
  quit_fmt("Error in flag_on(%s, %s): FlagID[%d] Size[%u] FlagOff[%u] FlagBV[%d]\n",
           fi, fl, flag, (unsigned int) size, (unsigned int) flag_offset, flag_binary);
 }
 assert(flag_offset < size);
 if (flags[flag_offset] & flag_binary) return false;
 flags[flag_offset] |= flag_binary;
 return true;
}
/**
 * Clears one flag in a bitfield.
 *
 * The bitflag identified by `flag` is cleared in `flags`. The bitfield size
 * is supplied in `size`.  true is returned when changes were made, false
 * otherwise.
 */
bool flag_off(bitflag *flags, const size_t size, const int flag)
{
 const size_t flag_offset = FLAG_OFFSET(flag);
 const int flag_binary = FLAG_BINARY(flag);
 assert(flag_offset < size);
 if (!(flags[flag_offset] & flag_binary)) return false;
 flags[flag_offset] &= ~flag_binary;
 return true;
}
/**
 * Clears all flags in a bitfield.
 *
 * All flags in `flags` are cleared. The bitfield size is supplied in `size`.
 */
void flag_wipe(bitflag *flags, const size_t size)
{
 memset(flags, 0, size * sizeof(bitflag));
}
/**
 * Sets all flags in a bitfield.
 *
 * All flags in `flags` are set. The bitfield size is supplied in `size`.
 */
void flag_setall(bitflag *flags, const size_t size)
{
 memset(flags, 255, size * sizeof(bitflag));
}
/**
 * Negates all flags in a bitfield.
 *
 * All flags in `flags` are toggled. The bitfield size is supplied in `size`.
 */
void flag_negate(bitflag *flags, const size_t size)
{
 size_t i;
 for (i = 0; i < size; i++)
  flags[i] = ~flags[i];
}
/**
 * Copies one bitfield into another.
 *
 * All flags in `flags2` are copied into `flags1`. The size of the bitfields is
 * supplied in `size`.
 */
void flag_copy(bitflag *flags1, const bitflag *flags2, const size_t size)
{
 memcpy(flags1, flags2, size * sizeof(bitflag));
}
/**
 * Computes the union of two bitfields.
 *
 * For every set flag in `flags2`, the corresponding flag is set in `flags1`.
 * The size of the bitfields is supplied in `size`. true is returned when
 * changes were made, and false otherwise.
 */
bool flag_union(bitflag *flags1, const bitflag *flags2, const size_t size)
{
 size_t i;
 bool delta = false;
 for (i = 0; i < size; i++) {
  /* !flag_is_subset() */
  if (~flags1[i] & flags2[i]) delta = true;
  flags1[i] |= flags2[i];
 }
 return delta;
}
/**
 * Computes the intersection of two bitfields.
 *
 * For every unset flag in `flags2`, the corresponding flag is cleared in
 * `flags1`. The size of the bitfields is supplied in `size`. true is returned
 * when changes were made, and false otherwise.
 */
bool flag_inter(bitflag *flags1, const bitflag *flags2, const size_t size)
{
 size_t i;
 bool delta = false;
 for (i = 0; i < size; i++) {
  /* !flag_is_equal() */
  if (!(flags1[i] == flags2[i])) delta = true;
  flags1[i] &= flags2[i];
 }
 return delta;
}
/**
 * Computes the difference of two bitfields.
 *
 * For every set flag in `flags2`, the corresponding flag is cleared in
 * `flags1`. The size of the bitfields is supplied in `size`. true is returned
 * when changes were made, and false otherwise.
 */
bool flag_diff(bitflag *flags1, const bitflag *flags2, const size_t size)
{
 size_t i;
 bool delta = false;
 for (i = 0; i < size; i++) {
  /* flag_is_inter() */
  if (flags1[i] & flags2[i]) delta = true;
  flags1[i] &= ~flags2[i];
 }
 return delta;
}
/**
 * Tests if any of multiple bitflags are set in a bitfield.
 *
 * true is returned if any of the flags specified in `...` are set in `flags`,
 * false otherwise. The bitfield size is supplied in `size`.
 *
 * WARNING: FLAG_END must be the final argument in the `...` list.
 */
bool flags_test(const bitflag *flags, const size_t size, ...)
{
 size_t flag_offset;
 int flag_binary;
 int f;
 va_list args;
 bool delta = false;
 va_start(args, size);
 /* Process each flag in the va-args */
 for (f = va_arg(args, int); f != FLAG_END; f = va_arg(args, int)) {
  flag_offset = FLAG_OFFSET(f);
  flag_binary = FLAG_BINARY(f);
  assert(flag_offset < size);
  /* flag_has() */
  if (flags[flag_offset] & flag_binary) {
   delta = true;
   break;
  }
 }
 va_end(args);
 return delta;
}
/**
 * Tests if all of the multiple bitflags are set in a bitfield.
 *
 * true is returned if all of the flags specified in `...` are set in `flags`,
 * false otherwise. The bitfield size is supplied in `size`. 
 *
 * WARNING: FLAG_END must be the final argument in the `...` list.
 */
bool flags_test_all(const bitflag *flags, const size_t size, ...)
{
 size_t flag_offset;
 int flag_binary;
 int f;
 va_list args;
 bool delta = true;
 va_start(args, size);
 /* Process each flag in the va-args */
 for (f = va_arg(args, int); f != FLAG_END; f = va_arg(args, int)) {
  flag_offset = FLAG_OFFSET(f);
  flag_binary = FLAG_BINARY(f);
  assert(flag_offset < size);
  /* !flag_has() */
  if (!(flags[flag_offset] & flag_binary)) {
   delta = false;
   break;
  }
 }
 va_end(args);
 return delta;
}
/**
 * Clears multiple bitflags in a bitfield.
 *
 * The flags specified in `...` are cleared in `flags`. The bitfield size is
 * supplied in `size`. true is returned when changes were made, false
 * otherwise.
 *
 * WARNING: FLAG_END must be the final argument in the `...` list.
 */
bool flags_clear(bitflag *flags, const size_t size, ...)
{
 size_t flag_offset;
 int flag_binary;
 int f;
 va_list args;
 bool delta = false;
 va_start(args, size);
 /* Process each flag in the va-args */
 for (f = va_arg(args, int); f != FLAG_END; f = va_arg(args, int)) {
  flag_offset = FLAG_OFFSET(f);
  flag_binary = FLAG_BINARY(f);
  assert(flag_offset < size);
  /* flag_has() */
  if (flags[flag_offset] & flag_binary) delta = true;
  /* flag_off() */
  flags[flag_offset] &= ~flag_binary;
 }
 va_end(args);
 return delta;
}
/**
 * Sets multiple bitflags in a bitfield.
 *
 * The flags specified in `...` are set in `flags`. The bitfield size is
 * supplied in `size`. true is returned when changes were made, false
 * otherwise.
 *
 * WARNING: FLAG_END must be the final argument in the `...` list.
 */
bool flags_set(bitflag *flags, const size_t size, ...)
{
 size_t flag_offset;
 int flag_binary;
 int f;
 va_list args;
 bool delta = false;
 va_start(args, size);
 /* Process each flag in the va-args */
 for (f = va_arg(args, int); f != FLAG_END; f = va_arg(args, int)) {
  flag_offset = FLAG_OFFSET(f);
  flag_binary = FLAG_BINARY(f);
  assert(flag_offset < size);
  /* !flag_has() */
  if (!(flags[flag_offset] & flag_binary)) delta = true;
  /* flag_on() */
  flags[flag_offset] |= flag_binary;
 }
 va_end(args);
 return delta;
}
/**
 * Wipes a bitfield, and then sets multiple bitflags.
 *
 * The flags specified in `...` are set in `flags`, while all other flags are
 * cleared. The bitfield size is supplied in `size`.
 *
 * WARNING: FLAG_END must be the final argument in the `...` list.
 */
void flags_init(bitflag *flags, const size_t size, ...)
{
 int f;
 va_list args;
 flag_wipe(flags, size);
 va_start(args, size);
 /* Process each flag in the va-args */
 for (f = va_arg(args, int); f != FLAG_END; f = va_arg(args, int))
  flag_on(flags, size, f);
 va_end(args);
}
/**
 * Computes the intersection of a bitfield and multiple bitflags.
 *
 * The flags not specified in `...` are cleared in `flags`. The bitfield size
 * is supplied in `size`. true is returned when changes were made, false
 * otherwise.
 *
 * WARNING: FLAG_END must be the final argument in the `...` list.
 */
bool flags_mask(bitflag *flags, const size_t size, ...)
{
 int f;
 va_list args;
 bool delta = false;
 bitflag *mask;
 /* Build the mask */
 mask = mem_zalloc(size * sizeof(bitflag));
 va_start(args, size);
 /* Process each flag in the va-args */
 for (f = va_arg(args, int); f != FLAG_END; f = va_arg(args, int))
  flag_on(mask, size, f);
 va_end(args);
 delta = flag_inter(flags, mask, size);
 /* Free the mask */
 mem_free(mask);
 return delta;
}
/**
 * \file z-color.c
 * \brief Generic color definitions
 *
 * Copyright (c) 1997 Ben Harrison
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * ------------------------------------------------------------------------
 * Colour constants
 * ------------------------------------------------------------------------ */
/**
 * Global table of color definitions (mostly zeros)
 */
uint8_t angband_color_table[MAX_COLORS][4] =
{
 {0x00, 0x00, 0x00, 0x00}, /* 0  COLOUR_DARK */
 {0x00, 0xff, 0xff, 0xff}, /* 1  COLOUR_WHITE */
 {0x00, 0x80, 0x80, 0x80}, /* 2  COLOUR_SLATE */
 {0x00, 0xff, 0x80, 0x00}, /* 3  COLOUR_ORANGE */
 {0x00, 0xc0, 0x00, 0x00}, /* 4  COLOUR_RED */
 {0x00, 0x00, 0x80, 0x40}, /* 5  COLOUR_GREEN */
 {0x00, 0x00, 0x40, 0xff}, /* 6  COLOUR_BLUE */
 {0x00, 0x80, 0x40, 0x00}, /* 7  COLOUR_UMBER */
 {0x00, 0x60, 0x60, 0x60}, /* 8  COLOUR_L_DARK */
 {0x00, 0xc0, 0xc0, 0xc0}, /* 9  COLOUR_L_WHITE */
 {0x00, 0xff, 0x00, 0xff}, /* 10 COLOUR_L_PURPLE */
 {0x00, 0xff, 0xff, 0x00}, /* 11 COLOUR_YELLOW */
 {0x00, 0xff, 0x40, 0x40}, /* 12 COLOUR_L_RED */
 {0x00, 0x00, 0xff, 0x00}, /* 13 COLOUR_L_GREEN */
 {0x00, 0x00, 0xff, 0xff}, /* 14 COLOUR_L_BLUE */
 {0x00, 0xc0, 0x80, 0x40}, /* 15 COLOUR_L_UMBER */
 {0x00, 0x90, 0x00, 0x90}, /* 16 COLOUR_PURPLE */
 {0x00, 0x90, 0x20, 0xff}, /* 17 COLOUR_VIOLET */
 {0x00, 0x00, 0xa0, 0xa0}, /* 18 COLOUR_TEAL */
 {0x00, 0x6c, 0x6c, 0x30}, /* 19 COLOUR_MUD */
 {0x00, 0xff, 0xff, 0x90}, /* 20 COLOUR_L_YELLOW */
 {0x00, 0xff, 0x00, 0xa0}, /* 21 COLOUR_MAGENTA */
 {0x00, 0x20, 0xff, 0xdc}, /* 22 COLOUR_L_TEAL */
 {0x00, 0xb8, 0xa8, 0xff}, /* 23 COLOUR_L_VIOLET */
 {0x00, 0xff, 0x80, 0x80}, /* 24 COLOUR_L_PINK */
 {0x00, 0xb4, 0xb4, 0x00}, /* 25 COLOUR_MUSTARD */
 {0x00, 0xa0, 0xc0, 0xd0}, /* 26 COLOUR_BLUE_SLATE */
 {0x00, 0x00, 0xb0, 0xff}, /* 27 COLOUR_DEEP_L_BLUE */
 {0x00, 0x28, 0x28, 0x28}, /* 28 COLOUR_SHADE */
};
/**
 * Global array of color names and translations.
 */
color_type color_table[MAX_COLORS] =
{
 /* full mono vga blind lighter darker highlight metallic misc */
 {'d', "Dark", {0, 0, 0, COLOUR_DARK, COLOUR_L_DARK, COLOUR_DARK,
       COLOUR_L_DARK, COLOUR_L_DARK, COLOUR_DARK}},
 {'w', "White", {1, 1, 1, COLOUR_WHITE, COLOUR_YELLOW, COLOUR_L_WHITE,
     COLOUR_L_BLUE, COLOUR_YELLOW, COLOUR_WHITE}},
 {'s', "Slate", {2, 1, 2, COLOUR_SLATE, COLOUR_L_WHITE, COLOUR_L_DARK,
     COLOUR_L_WHITE, COLOUR_L_WHITE, COLOUR_SLATE}},
 {'o', "Orange", {3, 1, 3, COLOUR_L_WHITE, COLOUR_YELLOW, COLOUR_SLATE,
      COLOUR_YELLOW, COLOUR_YELLOW, COLOUR_ORANGE}},
 {'r', "Red", {4, 1, 4, COLOUR_SLATE, COLOUR_L_RED, COLOUR_SLATE,
      COLOUR_L_RED, COLOUR_L_RED, COLOUR_RED}},
 {'g', "Green", {5, 1, 5, COLOUR_SLATE, COLOUR_L_GREEN, COLOUR_SLATE,
     COLOUR_L_GREEN, COLOUR_L_GREEN, COLOUR_GREEN}},
 {'b', "Blue", {6, 1, 6, COLOUR_SLATE, COLOUR_L_BLUE, COLOUR_SLATE,
       COLOUR_L_BLUE, COLOUR_L_BLUE, COLOUR_BLUE}},
 {'u', "Umber", {7, 1, 7, COLOUR_L_DARK, COLOUR_L_UMBER, COLOUR_L_DARK,
     COLOUR_L_UMBER, COLOUR_L_UMBER, COLOUR_UMBER}},
 {'D', "Light Dark", {8, 1, 8, COLOUR_L_DARK, COLOUR_SLATE, COLOUR_L_DARK,
       COLOUR_SLATE, COLOUR_SLATE, COLOUR_L_DARK}},
 {'W', "Light Slate", {9, 1, 9, COLOUR_L_WHITE, COLOUR_WHITE, COLOUR_SLATE,
        COLOUR_WHITE, COLOUR_WHITE, COLOUR_SLATE}},
 {'P', "Light Purple", {10, 1, 10, COLOUR_SLATE, COLOUR_YELLOW, COLOUR_SLATE,
         COLOUR_YELLOW, COLOUR_YELLOW, COLOUR_L_PURPLE}},
 {'y', "Yellow", {11, 1, 11, COLOUR_L_WHITE, COLOUR_L_YELLOW, COLOUR_L_WHITE,
      COLOUR_WHITE, COLOUR_WHITE, COLOUR_YELLOW}},
 {'R', "Light Red", {12, 1, 12, COLOUR_L_WHITE, COLOUR_YELLOW, COLOUR_RED,
      COLOUR_YELLOW, COLOUR_YELLOW, COLOUR_L_RED}},
 {'G', "Light Green", {13, 1, 13, COLOUR_L_WHITE, COLOUR_YELLOW, COLOUR_GREEN,
        COLOUR_YELLOW, COLOUR_YELLOW, COLOUR_L_GREEN}},
 {'B', "Light Blue", {14, 1, 14, COLOUR_L_WHITE, COLOUR_YELLOW, COLOUR_BLUE,
       COLOUR_YELLOW, COLOUR_YELLOW, COLOUR_L_BLUE}},
 {'U', "Light Umber", {15, 1, 15, COLOUR_L_WHITE, COLOUR_YELLOW, COLOUR_UMBER,
        COLOUR_YELLOW, COLOUR_YELLOW, COLOUR_L_UMBER}},
 /* "new" colors */
 {'p', "Purple", {16, 1, 10,COLOUR_SLATE, COLOUR_L_PURPLE, COLOUR_SLATE,
      COLOUR_L_PURPLE, COLOUR_L_PURPLE, COLOUR_L_PURPLE}},
 {'v', "Violet", {17, 1, 10,COLOUR_SLATE, COLOUR_L_PURPLE, COLOUR_SLATE,
      COLOUR_L_PURPLE, COLOUR_L_PURPLE, COLOUR_L_PURPLE}},
 {'t', "Teal", {18, 1, 6, COLOUR_SLATE, COLOUR_L_TEAL, COLOUR_SLATE,
       COLOUR_L_TEAL, COLOUR_L_TEAL, COLOUR_L_BLUE}},
 {'m', "Mud", {19, 1, 5, COLOUR_SLATE, COLOUR_MUSTARD, COLOUR_SLATE,
      COLOUR_MUSTARD, COLOUR_MUSTARD, COLOUR_UMBER}},
 {'Y', "Light Yellow", {20, 1, 11, COLOUR_WHITE, COLOUR_WHITE, COLOUR_YELLOW,
         COLOUR_WHITE, COLOUR_WHITE, COLOUR_L_YELLOW}},
 {'i', "Magenta-Pink", {21, 1, 12, COLOUR_SLATE, COLOUR_L_PINK, COLOUR_RED,
         COLOUR_L_PINK, COLOUR_L_PINK, COLOUR_L_PURPLE}},
 {'T', "Light Teal", {22, 1, 14, COLOUR_L_WHITE, COLOUR_YELLOW, COLOUR_TEAL,
       COLOUR_YELLOW, COLOUR_YELLOW, COLOUR_L_BLUE}},
 {'V', "Light Violet", {23, 1, 10, COLOUR_L_WHITE, COLOUR_YELLOW, COLOUR_VIOLET,
         COLOUR_YELLOW, COLOUR_YELLOW, COLOUR_L_PURPLE}},
 {'I', "Light Pink", {24, 1, 12, COLOUR_L_WHITE, COLOUR_YELLOW, COLOUR_MAGENTA,
       COLOUR_YELLOW, COLOUR_YELLOW, COLOUR_L_PURPLE}},
 {'M', "Mustard", {25, 1, 11, COLOUR_SLATE, COLOUR_YELLOW, COLOUR_SLATE,
       COLOUR_YELLOW, COLOUR_YELLOW, COLOUR_YELLOW}},
 {'z', "Blue Slate", {26, 1, 9, COLOUR_SLATE, COLOUR_DEEP_L_BLUE, COLOUR_SLATE,
        COLOUR_DEEP_L_BLUE, COLOUR_DEEP_L_BLUE, COLOUR_L_WHITE}},
 {'Z', "Deep Light Blue", {27, 1, 14, COLOUR_L_WHITE, COLOUR_L_BLUE, COLOUR_BLUE_SLATE,
         COLOUR_L_BLUE, COLOUR_L_BLUE, COLOUR_L_BLUE}},
 /* Rest to be filled in when the game loads */
};
/**
 * Accept a color index character; if legal, return the color.  -LM-
 *
 * Unlike Sangband, we don't translate these colours here.
 */
/* XXX: having color_{char,text}_to_attr() separately is moronic. */
int color_char_to_attr(char c)
{
 int a;
 /* Is negative -- spit it right back out */
 if (c < 0) return (c);
 /* Is a space or '\0' -- return black */
 if (c == '\0' || c == ' ') return (COLOUR_DARK);
 /* Search the color table */
 for (a = 0; a < BASIC_COLORS; a++)
 {
  /* Look for the index */
  if (color_table[a].index_char == c) break;
 }
 /* If we don't find the color, we assume white */
 if (a == BASIC_COLORS) return (COLOUR_WHITE);
 /* Return the color */
 return (a);
}
/**
 * Converts a string to a terminal color byte.
 */
int color_text_to_attr(const char *name)
{
 int a;
 for (a = 0; a < MAX_COLORS; a++)
 {
  if (my_stricmp(name, color_table[a].name) == 0) return (a);
 }
 /* Default to white */
 return (COLOUR_WHITE);
}
/**
 * Extract a textual representation of an attribute
 */
const char *attr_to_text(uint8_t a)
{
 if (a < BASIC_COLORS)
  return (color_table[a].name);
 else
  return ("Icky");
}
/**
 * Translate text colours.
 *
 * This translates a color based on the attribute. We use this to set terrain to
 * be lighter or darker, make metallic monsters shimmer, highlight text under
 * the mouse, and reduce the colours on mono colour or 16 colour terms to the
 * correct colour space.
 *
 * TODO: Honour the attribute for the term (full color, mono, 16 color) but
 * ensure that e.g. the lighter version of yellow becomes white in a 16 color
 * term, but light yellow in a full colour term.
 */
uint8_t get_color(uint8_t a, int attr, int n)
{
 /* Accept any graphical attr (high bit set) */
 if (a & (0x80))
  return (a);
 /* TODO: Honour the attribute for the term (full color, mono, 16 color) */
 if (!attr)
  return (a);
 /* Translate the color N times */
 while (n > 0) {
  a = color_table[a].color_translate[attr];
  n--;
 }
 /* Return the modified color */
 return (a);
}
/**
 * XXX XXX XXX Important note about "colors" XXX XXX XXX
 *
 * The "COLOUR_*" color definitions list the "composition" of each
 * "Angband color" in terms of "quarters" of each of the three color
 * components (Red, Green, Blue), for example, COLOUR_UMBER is defined
 * as 2/4 Red, 1/4 Green, 0/4 Blue.
 *
 * These values are NOT gamma-corrected.  On most machines (with the
 * Macintosh being an important exception), you must "gamma-correct"
 * the given values, that is, "correct for the intrinsic non-linearity
 * of the phosphor", by converting the given intensity levels based
 * on the "gamma" of the target screen, which is usually 1.7 (or 1.5).
 *
 * The actual formula for conversion is unknown to me at this time,
 * but you can use the table below for the most common gamma values.
 *
 * So, on most machines, simply convert the values based on the "gamma"
 * of the target screen, which is usually in the range 1.5 to 1.7, and
 * usually is closest to 1.7.  The converted value for each of the five
 * different "quarter" values is given below:
 *
 *  Given     Gamma 1.0       Gamma 1.5       Gamma 1.7     Hex 1.7
 *  -----       ----            ----            ----          ---
 *   0/4        0.00            0.00            0.00          #00
 *   1/4        0.25            0.27            0.28          #47
 *   2/4        0.50            0.55            0.56          #8f
 *   3/4        0.75            0.82            0.84          #d7
 *   4/4        1.00            1.00            1.00          #ff
 */
/**
 * Table of gamma values
 */
uint8_t gamma_table[256];
/**
 * Table of ln(x / 256) * 256 for x going from 0 -> 255
 */
static const int16_t gamma_helper[256] =
{
 0, -1420, -1242, -1138, -1065, -1007, -961, -921, -887, -857, -830,
 -806, -783, -762, -744, -726, -710, -694, -679, -666, -652, -640,
 -628, -617, -606, -596, -586, -576, -567, -577, -549, -541, -532,
 -525, -517, -509, -502, -495, -488, -482, -475, -469, -463, -457,
 -451, -455, -439, -434, -429, -423, -418, -413, -408, -403, -398,
 -394, -389, -385, -380, -376, -371, -367, -363, -359, -355, -351,
 -347, -343, -339, -336, -332, -328, -325, -321, -318, -314, -311,
 -308, -304, -301, -298, -295, -291, -288, -285, -282, -279, -276,
 -273, -271, -268, -265, -262, -259, -257, -254, -251, -248, -246,
 -243, -241, -238, -236, -233, -231, -228, -226, -223, -221, -219,
 -216, -214, -212, -209, -207, -205, -203, -200, -198, -196, -194,
 -192, -190, -188, -186, -184, -182, -180, -178, -176, -174, -172,
 -170, -168, -166, -164, -162, -160, -158, -156, -155, -153, -151,
 -149, -147, -146, -144, -142, -140, -139, -137, -135, -134, -132,
 -130, -128, -127, -125, -124, -122, -120, -119, -117, -116, -114,
 -112, -111, -109, -108, -106, -105, -103, -102, -100, -99, -97, -96,
 -95, -93, -92, -90, -89, -87, -86, -85, -83, -82, -80, -79, -78,
 -76, -75, -74, -72, -71, -70, -68, -67, -66, -65, -63, -62, -61,
 -59, -58, -57, -56, -54, -53, -52, -51, -50, -48, -47, -46, -45,
 -44, -42, -41, -40, -39, -38, -37, -35, -34, -33, -32, -31, -30,
 -29, -27, -26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16,
 -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1
};
/**
 * Build the gamma table so that floating point isn't needed.
 *
 * Note gamma goes from 0->256.  The old value of 100 is now 128.
 */
void build_gamma_table(int gamma)
{
 int i, n;
 /*
	 * value is the current sum.
	 * diff is the new term to add to the series.
	 */
 long value, diff;
 /* Hack - convergence is bad in these cases. */
 gamma_table[0] = 0;
 gamma_table[255] = 255;
 for (i = 1; i < 255; i++) {
  /*
		 * Initialise the Taylor series
		 *
		 * value and diff have been scaled by 256
		 */
  n = 1;
  value = 256L * 256L;
  diff = ((long)gamma_helper[i]) * (gamma - 256);
  while (diff) {
   value += diff;
   n++;
   /*
			 * Use the following identiy to calculate the gamma table.
			 * exp(x) = 1 + x + x^2/2 + x^3/(2*3) + x^4/(2*3*4) +...
			 *
			 * n is the current term number.
			 *
			 * The gamma_helper array contains a table of
			 * ln(x/256) * 256
			 * This is used because a^b = exp(b*ln(a))
			 *
			 * In this case:
			 * a is i / 256
			 * b is gamma.
			 *
			 * Note that everything is scaled by 256 for accuracy,
			 * plus another factor of 256 for the final result to
			 * be from 0-255.  Thus gamma_helper[] * gamma must be
			 * divided by 256*256 each itteration, to get back to
			 * the original power series.
			 */
   diff = (((diff / 256) * gamma_helper[i]) *
     (gamma - 256)) / (256 * n);
  }
  /*
		 * Store the value in the table so that the
		 * floating point pow function isn't needed.
		 */
  gamma_table[i] = (uint8_t)(((long)(value / 256) * i) / 256);
 }
}
/**
 * \file z-dice.c
 * \brief Represent more complex dice than random_value
 *
 * Copyright (c) 2013 Ben Semmler
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
typedef struct dice_expression_entry_s {
 const char *name;
 const expression_t *expression;
} dice_expression_entry_t;
struct dice_s {
 int b, x, y, m;
 bool ex_b, ex_x, ex_y, ex_m;
 dice_expression_entry_t *expressions;
};
/**
 * String parser states.
 */
typedef enum dice_state_e {
 DICE_STATE_START,
 DICE_STATE_BASE_DIGIT,
 DICE_STATE_FLUSH_BASE,
 DICE_STATE_DICE_DIGIT,
 DICE_STATE_FLUSH_DICE,
 DICE_STATE_SIDE_DIGIT,
 DICE_STATE_FLUSH_SIDE,
 DICE_STATE_BONUS,
 DICE_STATE_BONUS_DIGIT,
 DICE_STATE_FLUSH_BONUS,
 DICE_STATE_VAR,
 DICE_STATE_VAR_CHAR,
 DICE_STATE_FLUSH_ALL,
 DICE_STATE_MAX,
} dice_state_t;
/**
 * Input types for the parser state table.
 */
typedef enum dice_input_e {
 DICE_INPUT_AMP,
 DICE_INPUT_MINUS,
 DICE_INPUT_BASE,
 DICE_INPUT_DICE,
 DICE_INPUT_BONUS,
 DICE_INPUT_VAR,
 DICE_INPUT_DIGIT,
 DICE_INPUT_UPPER,
 DICE_INPUT_NULL,
 DICE_INPUT_MAX,
} dice_input_t;
/**
 * Hard limit on the number of variables/expressions. Shouldn't need more than
 * the possible values.
 */
/**
 * Max size for a token/number to be parsed. Longer strings will be truncated.
 */
/**
 * Return the appropriate input type based on the given character.
 */
static dice_input_t dice_input_for_char(char c)
{
 /* Catch specific characters before checking bigger char categories. */
 switch (c) {
  case '&':
   return DICE_INPUT_AMP;
  case '-':
   return DICE_INPUT_MINUS;
  case '+':
   return DICE_INPUT_BASE;
  case 'd':
   return DICE_INPUT_DICE;
  case 'M':
  case 'm':
   return DICE_INPUT_BONUS;
  case '$':
   return DICE_INPUT_VAR;
  case '\0':
   return DICE_INPUT_NULL;
  default:
   break;
 }
 if (isdigit(c))
  return DICE_INPUT_DIGIT;
 if (isupper(c))
  return DICE_INPUT_UPPER;
 return DICE_INPUT_MAX;
}
/**
 * Perform a state transition for the given state and input.
 *
 * The state table is contained within this function, using a compact
 * char-based format.
 *
 * \param state is the current state.
 * \param input is the input type to transition with.
 * \return The next state for the input, Or DICE_STATE_MAX for an invalid transition.
 */
static dice_state_t dice_parse_state_transition(dice_state_t state,
            dice_input_t input)
{
 static unsigned char state_table[DICE_STATE_MAX][DICE_INPUT_MAX] = {
  /* Input:								&-+dm$DU0 */
  /*[DICE_STATE_START] = */ /* A */ ".B.EHKB..",
  /*[DICE_STATE_BASE_DIGIT] = */ /* B */ "..CE..B.C",
  /*[DICE_STATE_FLUSH_BASE] = */ /* C */ "...EHKD..",
  /*[DICE_STATE_DICE_DIGIT] = */ /* D */ "...E..D..",
  /*[DICE_STATE_FLUSH_DICE] = */ /* E */ ".....KF..",
  /*[DICE_STATE_SIDE_DIGIT] = */ /* F */ "G...H.F.G",
  /*[DICE_STATE_FLUSH_SIDE] = */ /* G */ "....H....",
  /*[DICE_STATE_BONUS] = */ /* H */ ".....KI..",
  /*[DICE_STATE_BONUS_DIGIT] = */ /* I */ "......I.J",
  /*[DICE_STATE_FLUSH_BONUS] = */ /* J */ ".........",
  /*[DICE_STATE_VAR] = */ /* K */ ".......L.",
  /*[DICE_STATE_VAR_CHAR] = */ /* L */ "G.CEH..LM",
  /*[DICE_STATE_FLUSH_ALL] = */ /* M */ "........."
 };
 if (state == DICE_STATE_MAX || input == DICE_INPUT_MAX)
  return DICE_STATE_MAX;
 if (state_table[state][input] == '.')
  return DICE_STATE_MAX;
 return state_table[state][input] - 'A';
}
/**
 * Zero out the internal state of the dice object. This will only deallocate
 * entries in the expressions table; it will not deallocate the table itself.
 */
static void dice_reset(dice_t *dice)
{
 int i;
 dice->b = 0;
 dice->x = 0;
 dice->y = 0;
 dice->m = 0;
 dice->ex_b = false;
 dice->ex_x = false;
 dice->ex_y = false;
 dice->ex_m = false;
 if (dice->expressions == NULL)
  return;
 for (i = 0; i < 4; i++) {
  if (dice->expressions[i].name != NULL) {
   string_free((char *)dice->expressions[i].name);
   dice->expressions[i].name = NULL;
  }
  if (dice->expressions[i].expression != NULL) {
   expression_free((expression_t *)dice->expressions[i].expression);
   dice->expressions[i].expression = NULL;
  }
 }
}
/**
 * Allocate and initialize a new dice object. Returns NULL if it was unable to
 * be created.
 */
dice_t *dice_new(void)
{
 dice_t *dice = mem_zalloc(sizeof(dice_t));
 if (dice == NULL)
  return NULL;
 dice_reset(dice);
 return dice;
}
/**
 * Deallocate a dice object.
 */
void dice_free(dice_t *dice)
{
 if (dice == NULL)
  return;
 /* Free any variable names and expression objects. */
 dice_reset(dice);
 if (dice->expressions != NULL) {
  mem_free(dice->expressions);
  dice->expressions = NULL;
 }
 mem_free(dice);
}
/**
 * Add an entry to the dice object's symbol list.
 *
 * \param dice is the object the variable is being added to.
 * \param name is the name of the variable.
 * \return The index of the variable name (if added or already found), or -1 for error.
 */
static int dice_add_variable(dice_t *dice, const char *name)
{
 int i;
 if (dice->expressions == NULL) {
  dice->expressions = mem_zalloc(4 *
            sizeof(dice_expression_entry_t));
 }
 for (i = 0; i < 4; i++) {
  if (dice->expressions[i].name == NULL) {
   /* Add the variable to an empty slot. */
   dice->expressions[i].name = string_make(name);
   return i;
  }
  else if (my_stricmp(dice->expressions[i].name, name) == 0) {
   /* We already have the variable and will use this expression. */
   return i;
  }
 }
 /* No space left for variables. */
 return -1;
}
/**
 * Bind an expression to a variable name.
 *
 * This function creates a deep copy of the expression that the dice object owns
 *
 * \param dice is the object that will use the expression..
 * \param name is the variable that the expression should be bound to.
 * \param expression is the expression to bind.
 * \return The index of the expression or -1 for error.
 */
int dice_bind_expression(dice_t *dice, const char *name,
       const expression_t *expression)
{
 int i;
 if (dice->expressions == NULL)
  return -1;
 for (i = 0; i < 4; i++) {
  if (dice->expressions[i].name == NULL)
   continue;
  if (my_stricmp(name, dice->expressions[i].name) == 0) {
   dice->expressions[i].expression = expression_copy(expression);
   if (dice->expressions[i].expression == NULL)
    return -1;
   return i;
  }
 }
 /* Couldn't find variable name to bind to. */
 return -1;
}
/**
 * Parse a formatted string for values and variables to represent a dice roll.
 *
 * This function can parse a number of formats in the general style of "1+2d3M4"
 * (base, dice, sides, and bonus). Varibles (to which expressions can be bound)
 * can be subsitituted for numeric values by using an all-uppercase name
 * starting with $.
 * Spaces are ignored, concatenating the strings on either side of the space
 * character. Tokens (numbers and variable names) longer than the maximum will
 * be truncated. The unit test demonstrates the variety of valid strings.
 *
 * \param dice is the dice object to parse the string into.
 * \param string is the string to be parsed.
 * \return true if parsing was successful, false if not.
 */
bool dice_parse_string(dice_t *dice, const char *string)
{
 char token[16 + 1] = { '\0' };
 size_t token_end = 0;
 size_t current = 0;
 dice_state_t state = 0;
 /* We need to keep track of the last thing we saw, since the parser isn't complex. */
 enum last_seen_e {
  DICE_SEEN_NONE,
  DICE_SEEN_BASE,
  DICE_SEEN_DICE,
  DICE_SEEN_SIDE,
  DICE_SEEN_BONUS,
 } last_seen = DICE_SEEN_NONE;
 if (dice == NULL || string == NULL)
  return false;
 /* Reset all internal state, since this object might be reused. */
 dice_reset(dice);
 /* Note that we are including the string terminator as part of the parse. */
 for (current = 0; current <= strlen(string); current++) {
  bool flush;
  dice_input_t input_type = DICE_INPUT_MAX;
  /* Skip spaces; this will concatenate digits and variable names. */
  if (isspace(string[current]))
   continue;
  input_type = dice_input_for_char(string[current]);
  /*
		 * Get the next state, based on the type of input char. If it's a
		 * possible number or varible name, we'll store the character in the
		 * token buffer.
		 */
  switch (input_type) {
   case DICE_INPUT_AMP:
   case DICE_INPUT_BASE:
   case DICE_INPUT_DICE:
   case DICE_INPUT_VAR:
   case DICE_INPUT_NULL:
    state = dice_parse_state_transition(state, input_type);
    break;
   case DICE_INPUT_MINUS:
   case DICE_INPUT_DIGIT:
   case DICE_INPUT_UPPER:
    /* Truncate tokens if they are too long to fit. */
    if (token_end < 16) {
     token[token_end] = string[current];
     token_end++;
    }
    state = dice_parse_state_transition(state, input_type);
    break;
   default:
    break;
  }
  /*
		 * Allow 'M' to be used as the bonus marker and to be used in variable
		 * names.
		 * Ideally, 'm' should be the only marker and this could go away by
		 * adding a case to the switch above for DICE_INPUT_BONUS
		 * (underneath DICE_INPUT_NULL).
		 */
  if (string[current] == 'M') {
   if (state == DICE_STATE_VAR || state == DICE_STATE_VAR_CHAR) {
    if (token_end < 16) {
     token[token_end] = string[current];
     token_end++;
    }
    state = dice_parse_state_transition(state, DICE_INPUT_UPPER);
   }
   else
    state = dice_parse_state_transition(state, DICE_INPUT_BONUS);
  }
  else if (string[current] == 'm') {
   state = dice_parse_state_transition(state, DICE_INPUT_BONUS);
  }
  /* Illegal transition. */
  if (state >= DICE_STATE_MAX)
   return false;
  /*
		 * Default flushing to true, since there are more states that don't
		 * need to be flushed. For some states, we need to do a bit of extra
		 * work, since the parser isn't that complex. A more complex parser
		 * would have more explicit states for variable names.
		 */
  flush = true;
  switch (state) {
   case DICE_STATE_FLUSH_BASE:
    last_seen = DICE_SEEN_BASE;
    break;
   case DICE_STATE_FLUSH_DICE:
    last_seen = DICE_SEEN_DICE;
    /* If we see a 'd' without a number before it, we assume it
				 * to be one die. */
    if (strlen(token) == 0) {
     token[0] = '1';
     token[1] = '\0';
    }
    break;
   case DICE_STATE_FLUSH_SIDE:
    last_seen = DICE_SEEN_SIDE;
    break;
   case DICE_STATE_FLUSH_BONUS:
    last_seen = DICE_SEEN_BONUS;
    break;
   case DICE_STATE_FLUSH_ALL:
    /* Flushing all means that we are flushing whatever comes after
				 * it was that we last saw. */
    if (last_seen < DICE_SEEN_BONUS)
     last_seen++;
    break;
   case DICE_STATE_BONUS:
    /* The bonus state is weird, so if we last saw dice, we're now
				 * seeing sides. */
    if (last_seen == DICE_SEEN_DICE)
     last_seen = DICE_SEEN_SIDE;
    else
     last_seen = DICE_SEEN_BONUS;
    break;
   default:
    /* We're in a state that shouldn't flush anything. */
    flush = false;
    break;
  }
  /*
		 * If we have a token that we need to flush, put it where it needs to
		 * go in the dice object. If the token is an uppercase letter, it's
		 * a variable and needs to go in the expression table. Otherwise, we
		 * try to parse it as a number, where it is set directly as a value.
		 */
  if (flush && strlen(token) > 0) {
   int value = 0;
   bool is_variable = false;
   if (isupper(token[0])) {
    value = dice_add_variable(dice, token);
    is_variable = true;
   }
   else {
    value = (int)strtol(token, NULL, 0);
    is_variable = false;
   }
   switch (last_seen) {
    case DICE_SEEN_BASE:
     dice->b = value;
     dice->ex_b = is_variable;
     break;
    case DICE_SEEN_DICE:
     dice->x = value;
     dice->ex_x = is_variable;
     break;
    case DICE_SEEN_SIDE:
     dice->y = value;
     dice->ex_y = is_variable;
     break;
    case DICE_SEEN_BONUS:
     dice->m = value;
     dice->ex_m = is_variable;
     break;
    default:
     break;
   }
   memset(token, 0, 16 + 1);
   token_end = 0;
  }
 }
 return true;
}
/**
 * Extract a random_value by evaluating any bound expressions.
 *
 * \param dice is the object to get the random_value from.
 * \param v is the random_value to place the values into.
 */
void dice_random_value(const dice_t *dice, random_value *v)
{
 if (v == NULL)
  return;
 if (dice->ex_b) {
  if (dice->expressions != NULL && dice->expressions[dice->b].expression != NULL)
   v->base = expression_evaluate(dice->expressions[dice->b].expression);
  else
   v->base = 0;
 }
 else
  v->base = dice->b;
 if (dice->ex_x) {
  if (dice->expressions != NULL && dice->expressions[dice->x].expression != NULL)
   v->dice = expression_evaluate(dice->expressions[dice->x].expression);
  else
   v->dice = 0;
 }
 else
  v->dice = dice->x;
 if (dice->ex_y) {
  if (dice->expressions != NULL && dice->expressions[dice->y].expression != NULL)
   v->sides = expression_evaluate(dice->expressions[dice->y].expression);
  else
   v->sides = 0;
 }
 else
  v->sides = dice->y;
 if (dice->ex_m) {
  if (dice->expressions != NULL && dice->expressions[dice->m].expression != NULL)
   v->m_bonus = expression_evaluate(dice->expressions[dice->m].expression);
  else
   v->m_bonus = 0;
 }
 else
  v->m_bonus = dice->m;
}
/**
 * Fully evaluates the dice object, using randcalc(). The random_value used is
 * returned if desired.
 *
 * \param dice is the dice object to evaluate.
 * \param level is the level value that is passed to randcalc().
 * \param asp is the aspect that is passed to randcalc().
 * \param v is a pointer used to return the random_value used.
 */
int dice_evaluate(const dice_t *dice, int level, aspect asp, random_value *v)
{
 random_value rv;
 dice_random_value(dice, &rv);
 if (v != NULL) {
  v->base = rv.base;
  v->dice = rv.dice;
  v->sides = rv.sides;
  v->m_bonus = rv.m_bonus;
 }
 return randcalc(rv, level, asp);
}
/**
 * Evaluates the dice object, using damroll() (base + XdY). The random_value
 * used is returned if desired.
 *
 * \param dice is the dice object to evaluate.
 * \param v is a pointer used to return the random_value used.
 */
int dice_roll(const dice_t *dice, random_value *v)
{
 random_value rv;
 dice_random_value(dice, &rv);
 if (v != NULL) {
  v->base = rv.base;
  v->dice = rv.dice;
  v->sides = rv.sides;
  v->m_bonus = rv.m_bonus;
 }
 return rv.base + damroll(rv.dice, rv.sides);
}
/**
 * Test the dice object against the given values.
 */
bool dice_test_values(const dice_t *dice, int base, int dice_count, int sides,
  int bonus)
{
 bool success = true;
 success &= dice->b == base;
 success &= dice->x == dice_count;
 success &= dice->y == sides;
 success &= dice->m == bonus;
 return success;
}
/**
 * Check that the dice object has the given variables for the component.
 */
bool dice_test_variables(const dice_t *dice, const char *base,
  const char *dice_name, const char *sides, const char *bonus)
{
 bool success = true;
 if (dice->expressions == NULL)
  return false;
 if (base == NULL)
  success &= !dice->ex_b;
 else
  success &= (dice->ex_b && dice->b >= 0 && my_stricmp(dice->expressions[dice->b].name, base) == 0);
 if (dice_name == NULL)
  success &= !dice->ex_x;
 else
  success &= (dice->ex_x && dice->x >= 0 && my_stricmp(dice->expressions[dice->x].name, dice_name) == 0);
 if (sides == NULL)
  success &= !dice->ex_y;
 else
  success &= (dice->ex_y && dice->y >= 0 && my_stricmp(dice->expressions[dice->y].name, sides) == 0);
 if (bonus == NULL)
  success &= !dice->ex_m;
 else
  success &= (dice->ex_m && dice->m >= 0 && my_stricmp(dice->expressions[dice->m].name, bonus) == 0);
 return success;
}
/**
 * \file z-dict.c
 * \brief Implement a generic dictionary type.
 *
 * Copyright (c) 2022 Eric Branlund
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
struct dict_list_entry {
 void *key;
 void *value;
 struct dict_list_entry *next;
};
struct dict_impl {
 uint32_t (*key_hasher)(const void *key);
 int (*key_comparer)(const void *a, const void *b);
 void (*key_freer)(void *key);
 void (*value_freer)(void *value);
 struct dict_list_entry* lists[512];
};
/**
 * Recurse through the dictionary depth first.
 *
 * \param element_visitor is a pointer to a function to call for each key/value
 * pair in the dictionary.  It must take three arguments:  the dictionary,
 * a pointer to the structure holding the key/value pair, and a void*.  The
 * latter is the element_closure argument passed to dict_depth_first_recurse().
 * \param element_closure is passed as is as the second argument to
 * element_visitor.
 */
static void dict_depth_first_recurse(dict_type d,
  void (*element_visitor)(dict_type d, struct dict_list_entry *e, void *closure),
  void *element_closure)
{
 int i;
 for (i = 0; i < (int)N_ELEMENTS(d->lists); ++i) {
  struct dict_list_entry *entry = d->lists[i];
  while (entry) {
   struct dict_list_entry *next_entry = entry->next;
   (*element_visitor)(d, entry, element_closure);
   entry = next_entry;
  }
 }
}
/**
 * Help dict_destroy():  release the resources for one key/value pair.
 */
static void dict_free_element(dict_type d, struct dict_list_entry *e,
  void *closure)
{
 if (d->value_freer) {
  (*d->value_freer)(e->value);
 }
 if (d->key_freer) {
  (*d->key_freer)(e->key);
 }
 mem_free(e);
}
/**
 * Create a new dictionary.
 *
 * \param key_hasher points to a function to compute a 32-bit unsigned hash
 * from a key.  It must not be NULL.  Invoking the function on a key with the
 * same internal details must always give the same result.
 * \param key_comparer points to a function to compare two keys.  It must
 * not be NULL.  That function must return zero if the keys are equal and
 * return a non-zero value if the keys are not equal.
 * \param key_freer points to a function to release the resouces associated
 * with a key.  When a key/value pair is released, the key will always be
 * freed after the value.  It may be NULL.
 * \param value_freer points to a function to release the resources associated
 * with a value.  When a key/value pair is released, the key will always be
 * freed after the value.  It may be NULL.
 * \return the created dictionary.  That should be passed to dict_destroy()
 * when it is no longer needed.
 */
dict_type dict_create(uint32_t (*key_hasher)(const void *key),
  int (*key_comparer)(const void *a, const void *b),
  void (*key_freer)(void *key), void (*value_freer)(void *value))
{
 dict_type d = (struct dict_impl*) mem_zalloc(sizeof(struct dict_impl));
 d->key_hasher = key_hasher;
 d->key_comparer = key_comparer;
 d->key_freer = key_freer;
 d->value_freer = value_freer;
 return d;
}
/**
 * Release the resources for a dictionary created by dict_create().
 *
 * \param d is NULL or a dictionary created by dict_create().
 */
void dict_destroy(dict_type d)
{
 if (d) {
  dict_depth_first_recurse(d, dict_free_element, NULL);
  mem_free(d);
 }
}
/**
 * Insert a key value pair into a dictionary.
 *
 * \param key is the key.
 * \param value is the value.  This must not be NULL.
 * \return true if the key is not already present in the dictionary and the
 * insertion was successful.  In that case, the dictionary assumes ownership
 * of key and value and will release their resources when necessary.  Otherwise,
 * return false.  In that case, the caller is responsible for releasing
 * whatever resources are associated with key and value.
 */
bool dict_insert(dict_type d, void *key, void *value)
{
 uint32_t hash, ind;
 struct dict_list_entry *entry;
 if (!d || !value) {
  return false;
 }
 hash = (*d->key_hasher)(key);
 ind = hash % (uint32_t)N_ELEMENTS(d->lists);
 /* Determine if the key is already present. */
 entry = d->lists[ind];
 while (entry) {
  if (!(*d->key_comparer)(key, entry->key)) {
   return false;
  }
  entry = entry->next;
 }
 /* Insert the entry. */
 entry = mem_alloc(sizeof(*entry));
 entry->key = key;
 entry->value = value;
 entry->next = d->lists[ind];
 d->lists[ind] = entry;
 return true;
}
/**
 * Get the corresponding value in a dictionary for the given key.
 *
 * \param key is the key to look for.
 * \return the value corresponding to key.  If key is not present, the
 * return value will be NULL.
 */
void *dict_has(dict_type d, const void *key)
{
 uint32_t hash, ind;
 struct dict_list_entry *entry;
 if (!d) {
  return NULL;
 }
 hash = (*d->key_hasher)(key);
 ind = hash % (uint32_t)N_ELEMENTS(d->lists);
 /* Determine if the key is there. */
 entry = d->lists[ind];
 while (entry) {
  if (!(*d->key_comparer)(key, entry->key)) {
   return entry->value;
  }
  entry = entry->next;
 }
 return NULL;
}
/**
 * \file z-expression.c
 * \brief Creating, storing, and deserializing simple math expressions
 *
 * Copyright (c) 2013 Ben Semmler
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
struct expression_operation_s {
 uint8_t operator;
 int16_t operand;
};
struct expression_s {
 expression_base_value_f base_value;
 size_t operation_count;
 size_t operations_size;
 expression_operation_t *operations;
 int32_t fixed_base;
};
/**
 * Operator types.
 */
typedef enum expression_operator_e {
 OPERATOR_NONE,
 OPERATOR_ADD,
 OPERATOR_SUB,
 OPERATOR_MUL,
 OPERATOR_DIV,
 OPERATOR_NEG,
} expression_operator_t;
/**
 * States for parser state table.
 */
typedef enum expression_state_e {
 EXPRESSION_STATE_START,
 EXPRESSION_STATE_OPERATOR,
 EXPRESSION_STATE_OPERAND,
 EXPRESSION_STATE_MAX,
} expression_state_t;
/**
 * Input types for parser state table.
 */
typedef enum expression_input_e {
 EXPRESSION_INPUT_INVALID,
 EXPRESSION_INPUT_NEEDS_OPERANDS,
 EXPRESSION_INPUT_UNARY_OPERATOR,
 EXPRESSION_INPUT_VALUE,
 EXPRESSION_INPUT_MAX,
} expression_input_t;
/**
 * Allocation block size for the operations array in expression_t.
 */
/**
 * Token delimiter for the parser.
 */
/**
 * Maximum number of operations in an expression. This number is used in the
 * parser to allocate an array of expression_operation_t.
 */
/**
 * Return an operator type based on the input token.
 */
static expression_operator_t expression_operator_from_token(const char *token)
{
 expression_operator_t result;
 switch (token[0]) {
  case '+':
   result = OPERATOR_ADD;
   break;
  case '-':
   result = OPERATOR_SUB;
   break;
  case '*':
   result = OPERATOR_MUL;
   break;
  case '/':
   result = OPERATOR_DIV;
   break;
  case 'n':
  case 'N':
   result = OPERATOR_NEG;
   break;
  default:
   return OPERATOR_NONE;
 }
 /* Reject if there's additional junk in the token after the operator. */
 return (token[1]) ? OPERATOR_NONE : result;
}
/**
 * Return the state table input type for a given operator type.
 */
static expression_input_t expression_input_for_operator(expression_operator_t operator)
{
 switch (operator) {
  case OPERATOR_NONE:
   return EXPRESSION_INPUT_INVALID;
  case OPERATOR_ADD:
  case OPERATOR_SUB:
  case OPERATOR_MUL:
  case OPERATOR_DIV:
   return EXPRESSION_INPUT_NEEDS_OPERANDS;
  case OPERATOR_NEG:
   return EXPRESSION_INPUT_UNARY_OPERATOR;
 }
 return EXPRESSION_INPUT_INVALID;
}
/**
 * Allocate and initialize a new expression object. Returns NULL if it was
 * unable to be created.
 */
expression_t *expression_new(void)
{
 expression_t *expression = mem_alloc(sizeof(expression_t));
 if (expression == NULL)
  return NULL;
 expression->base_value = NULL;
 expression->operation_count = 0;
 expression->operations_size = 5;
 expression->operations = mem_zalloc(expression->operations_size
  * sizeof(expression_operation_t));
 expression->fixed_base = 0;
 if (expression->operations == NULL) {
  mem_free(expression);
  return NULL;
 }
 return expression;
}
/**
 * Deallocate an expression object.
 */
void expression_free(expression_t *expression)
{
 if (expression == NULL)
  return;
 if (expression->operations != NULL) {
  mem_free(expression->operations);
  expression->operations = NULL;
 }
 mem_free(expression);
}
/**
 * Return a deep copy of the given expression.
 */
expression_t *expression_copy(const expression_t *source)
{
 size_t i;
 expression_t *copy = mem_zalloc(sizeof(expression_t));
 if (copy == NULL)
  return NULL;
 copy->base_value = source->base_value;
 copy->operation_count = source->operation_count;
 copy->operations_size = source->operations_size;
 copy->fixed_base = source->fixed_base;
 if (copy->operations_size == 0) {
  copy->operations = NULL;
  return copy;
 }
 copy->operations = mem_zalloc(copy->operations_size *
          sizeof(expression_operation_t));
 if (copy->operations == NULL && source->operations != NULL) {
  mem_free(copy);
  return NULL;
 }
 for (i = 0; i < copy->operation_count; i++) {
  copy->operations[i].operand = source->operations[i].operand;
  copy->operations[i].operator = source->operations[i].operator;
 }
 return copy;
}
/**
 * Set a fixed value for the base that'll be used if a function is not
 * provided with expression_set_base_value().
 */
void expression_set_fixed_base(expression_t *expression, int32_t value)
{
 expression->fixed_base = value;
}
/**
 * Set the base value function that the operations operate on.
 */
void expression_set_base_value(expression_t *expression,
          expression_base_value_f function)
{
 expression->base_value = function;
}
/**
 * Evaluate the given expression. If the base value function is NULL,
 * expression is evaluated from zero.
 */
int32_t expression_evaluate(expression_t const * const expression)
{
 size_t i;
 int32_t value = expression->fixed_base;
 if (expression->base_value != NULL)
  value = expression->base_value();
 for (i = 0; i < expression->operation_count; i++) {
  switch (expression->operations[i].operator) {
   case OPERATOR_ADD:
    value += expression->operations[i].operand;
    break;
   case OPERATOR_SUB:
    value -= expression->operations[i].operand;
    break;
   case OPERATOR_MUL:
    value *= expression->operations[i].operand;
    break;
   case OPERATOR_DIV:
    value /= expression->operations[i].operand;
    break;
   case OPERATOR_NEG:
    value = -value;
    break;
   default:
    break;
  }
 }
 return value;
}
/**
 * Add an operation to an expression, allocating more memory as needed.
 */
static void expression_add_operation(expression_t *expression,
          const expression_operation_t operation)
{
 if (expression->operation_count >= expression->operations_size) {
  expression->operations_size += 5;
  expression->operations = mem_realloc(expression->operations, expression->operations_size * sizeof(expression_operation_t));
 }
 expression->operations[expression->operation_count] = operation;
 expression->operation_count++;
}
/**
 * Parse a string and add operations and operands to an expression.
 *
 * The string must be in prefix notation and must start with an operator.
 * Basic operators (add, subtract, multiply, and divide) can have multiple
 * operands after the operator. Unary operators (negation) must be followed
 * by another operator. Parsing is done using a state table which is
 * contained in the function.
 *
 * \param expression is an initialized expression object.
 * \param string is the string to be parsed.
 * \return The number of operations added to the expression or an error (expression_err_e).
 */
int16_t expression_add_operations_string(expression_t *expression,
           const char *string)
{
 char *parse_string;
 expression_operation_t operations[50];
 int16_t count = 0, i = 0, nmax = 50;
 char *token = NULL;
 expression_operator_t parsed_operator = OPERATOR_NONE;
 expression_operator_t current_operator = OPERATOR_NONE;
 expression_input_t current_input = EXPRESSION_INPUT_INVALID;
 int state = EXPRESSION_STATE_START;
 /* The named initializers are left commented out for when this all goes
	 * to C99. */
 static int state_table[EXPRESSION_STATE_MAX][EXPRESSION_INPUT_MAX] = {
  /*[EXPRESSION_STATE_START] = */{
   /*[EXPRESSION_INPUT_INVALID] = */ EXPRESSION_ERR_INVALID_OPERATOR,
   /*[EXPRESSION_INPUT_NEEDS_OPERANDS] = */ EXPRESSION_STATE_OPERATOR,
   /*[EXPRESSION_INPUT_UNARY_OPERATOR] = */ EXPRESSION_STATE_START,
   /*[EXPRESSION_INPUT_VALUE] = */ EXPRESSION_ERR_EXPECTED_OPERATOR,
  },
  /* found operator */
  /*[EXPRESSION_STATE_OPERATOR] = */{
   /*[EXPRESSION_INPUT_INVALID] = */ EXPRESSION_ERR_INVALID_OPERATOR,
   /*[EXPRESSION_INPUT_NEEDS_OPERANDS] = */ EXPRESSION_ERR_EXPECTED_OPERAND,
   /*[EXPRESSION_INPUT_UNARY_OPERATOR] = */ EXPRESSION_ERR_EXPECTED_OPERAND,
   /*[EXPRESSION_INPUT_VALUE] = */ EXPRESSION_STATE_OPERAND,
  },
  /* found one operand */
  /*[EXPRESSION_STATE_OPERAND] = */{
   /*[EXPRESSION_INPUT_INVALID] = */ EXPRESSION_ERR_INVALID_OPERATOR,
   /*[EXPRESSION_INPUT_NEEDS_OPERANDS] = */ EXPRESSION_STATE_OPERATOR,
   /*[EXPRESSION_INPUT_UNARY_OPERATOR] = */ EXPRESSION_STATE_START,
   /*[EXPRESSION_INPUT_VALUE] = */ EXPRESSION_STATE_OPERAND,
  },
 };
 if (expression == NULL || string == NULL)
  return EXPRESSION_ERR_GENERIC;
 /* Empty string is an identity operation. */
 if (my_stricmp(string, "") == 0)
  return 0;
 parse_string = string_make(string);
 token = strtok(parse_string, " ");
 while (token != NULL) {
  char *end = NULL;
  long value = strtol(token, &end, 0);
  if (end == token) {
   parsed_operator = expression_operator_from_token(token);
   current_input = expression_input_for_operator(parsed_operator);
   state = state_table[state][current_input];
  }
  else {
   state = state_table[state][EXPRESSION_INPUT_VALUE];
  }
  /* Perform actions based on the new state. */
  if (state < EXPRESSION_STATE_START) {
   /* An error occurred, according to the state table. */
   string_free(parse_string);
   return state;
  }
  else if (state == EXPRESSION_STATE_START) {
   /* Flush the operation, since we are restarting or using a
			 * unary operator. */
   operations[count].operator = parsed_operator;
   operations[count].operand = 0;
   count++;
  }
  else if (state == EXPRESSION_STATE_OPERATOR) {
   /* Remember the operator, since we found an operator which needs
			 * operands. */
   current_operator = parsed_operator;
  }
  else if (state == EXPRESSION_STATE_OPERAND) {
   if (value < -32768 || value > 32767) {
    string_free(parse_string);
    return EXPRESSION_ERR_OPERAND_OUT_OF_BOUNDS;
   }
   /* Try to catch divide by zero. */
   if (current_operator == OPERATOR_DIV && value == 0) {
    string_free(parse_string);
    return EXPRESSION_ERR_DIVIDE_BY_ZERO;
   }
   /* Flush the operator and operand pair. */
   operations[count].operator = current_operator;
   operations[count].operand = (int16_t)value;
   count++;
  }
  /* Limit the number of expressions, saving what we have. */
  if (count >= nmax)
   break;
  token = strtok(NULL, " ");
 }
 for (i = 0; i < count; i++) {
  expression_add_operation(expression, operations[i]);
 }
 string_free(parse_string);
 return count;
}
/**
 * Test to make sure that the deep copy from expression_copy() is equal in value
 */
bool expression_test_copy(const expression_t *a, const expression_t *b)
{
 size_t i;
 bool success = true;
 if (a == NULL || b == NULL)
  return false;
 success &= (a != b);
 success &= (a->base_value == b->base_value);
 success &= (a->operation_count == b->operation_count);
 success &= (a->operations_size == b->operations_size);
 success &= (a->operations != b->operations);
 success &= (a->fixed_base == b->fixed_base);
 if (a->operation_count != b->operation_count)
  return false;
 for (i = 0; i < a->operation_count; i++) {
  success &= (a->operations[i].operand == b->operations[i].operand);
  success &= (a->operations[i].operator == b->operations[i].operator);
 }
 return success;
}
/**
 * \file z-file.c
 * \brief Low-level file (and directory) handling
 *
 * Copyright (c) 1997-2007 Ben Harrison, pelpel, Andi Sidwell, Matthew Jones
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/* Suppress MSC C4996 error */
/**
 * Player info
 */
int player_uid;
int player_egid;
/**
 * Drop permissions
 */
void safe_setuid_drop(void)
{
}
/**
 * Grab permissions
 */
void safe_setuid_grab(void)
{
}
/**
 * Apply special system-specific processing before dealing with a filename.
 */
static void path_parse(char *buf, size_t max, const char *file)
{
 /* Accept the filename */
 my_strcpy(buf, file, max);
}
static void path_process(char *buf, size_t len, size_t *cur_len,
       const char *path)
{
 /* Home directory on Unixes */
 if (path[0] == '~') {
  const char *s;
  const char *username = path + 1;
  struct passwd *pw;
  char user[128];
  /* Look for non-user portion of the file */
  s = strstr(username, PATH_SEP);
  if (s) {
   int i;
   /* Keep username a decent length */
   if (s >= username + sizeof(user)) return;
   for (i = 0; username < s; ++i) user[i] = *username++;
   user[i] = '\0';
   username = user;
  }
  /* Look up a user (or "current" user) */
  pw = username[0] ? getpwnam(username) : getpwuid(getuid());
  if (!pw) return;
  /* Copy across */
  strnfcat(buf, len, cur_len, "%s%s", pw->pw_dir, PATH_SEP);
  if (s) strnfcat(buf, len, cur_len, "%s", s);
 } else
  strnfcat(buf, len, cur_len, "%s", path);
}
/**
 * Create a new path string by appending a 'leaf' to 'base'.
 *
 * On Unixes, we convert a tidle at the beginning of a basename to mean the
 * directory, complicating things a little, but better now than later.
 */
size_t path_build(char *buf, size_t len, const char *base, const char *leaf)
{
 size_t cur_len = 0;
 int starts_with_separator;
 buf[0] = '\0';
 if (!leaf || !leaf[0]) {
  if (base && base[0])
   path_process(buf, len, &cur_len, base);
  return cur_len;
 }
 /*
	 * If the leafname starts with the separator,
	 *   or with the tilde (on Unix),
	 *   or there's no base path,
	 * We use the leafname only.
	 */
 starts_with_separator = (!base || !base[0]) || prefix(leaf, PATH_SEP);
 starts_with_separator = starts_with_separator || leaf[0] == '~';
 if (starts_with_separator) {
  path_process(buf, len, &cur_len, leaf);
  return cur_len;
 }
 /* There is both a relative leafname and a base path from which it is
	 * relative */
 path_process(buf, len, &cur_len, base);
 if (!suffix(base, PATH_SEP)) {
  /* Append separator if it isn't already in the string. */
  strnfcat(buf, len, &cur_len, "%s", PATH_SEP);
 }
 path_process(buf, len, &cur_len, leaf);
 return cur_len;
}
/**
 * Converts path_in to an absolute path without redundant path separators.
 *
 * \param buf is the buffer to hold the result.  If len is greater than zero,
 * it will always be null terminated.  buf may be NULL if len is zero.
 * \param len is the size of the buffer.
 * \param path_in is the null-terminated string with the path to normalize.
 * \param trailing_sep will, if true, cause the normalized path to have a
 * trailing path separator if it does not already have one.
 * \param req_len if not NULL, will be dereferenced and set to the required
 * buffer size needed to hold the normalized result or to zero if it was not
 * possible to compute the normalized result.
 * \param root_len if not NULL, will be dereferenced and set to the length
 * of the root portion (the part that will always remain after repeatedly
 * going up the directory tree) of the path or to zero if it was not possible
 * to compute the normalized result.
 * \return zero if the normalization operation succeeded and the untruncated
 * result was stored in buf.  Returns 1 if the normalized result was
 * truncated.  Returns 2 if the normalized result could not be determined.
 *
 * On Unixes, deals with the tilde as representing home directories.
 */
int path_normalize(char *buf, size_t len, const char *path_in,
  bool trailing_sep, size_t *req_len, size_t *root_len)
{
 size_t oidx_high = 0, oidx, iidx, root_size;
 int result;
 if (path_in[0] != PATH_SEPC) {
  /*
		 * Input path is relative to the current working directory
		 * or in a user's home directory.
		 */
  if (path_in[0] == '~') {
   /* It's in a user's home directory. */
   struct passwd *pw;
   if (!path_in[1] || path_in[1] == PATH_SEPC) {
    /*
				 * It's not qualified by a user name, use
				 * the current user.
				 */
    pw = getpwuid(getuid());
    iidx = 1;
   } else {
    const char *s = strchr(path_in + 1, PATH_SEPC);
    if (s) {
     size_t nlen = s - path_in;
     char *work = mem_alloc(nlen);
     (void) memcpy(work, path_in + 1,
      nlen - 1);
     work[nlen - 1] = '\0';
     pw = getpwnam(work);
     mem_free(work);
     iidx = nlen;
    } else {
     pw = getpwnam(path_in + 1);
     iidx = strlen(path_in);
    }
   }
   /*
			 * If that user's directory isn't available or it
			 * begins with '~', give up.
			 */
   if (!pw || !pw->pw_dir || pw->pw_dir[0] == '~') {
    goto ABNORMAL_RETURN;
   }
   /*
			 * Process the user's directory through path_normalize()
			 * to guarantee that it is normalized.
			 */
   result = path_normalize(buf, len, pw->pw_dir,
    (path_in[iidx]) ? true : false, &oidx_high,
    NULL);
   if ((result != 0 && result != 1) || oidx_high <= 1) {
    goto ABNORMAL_RETURN;
   }
   /* Backup over the trailing null. */
   oidx = oidx_high - 1;
   /*
			 * Skip the '/' in the input since it's already been
			 * passed to the output.
			 */
   if (path_in[iidx]) {
    assert(path_in[iidx] == PATH_SEPC);
    ++iidx;
   }
  } else {
   /*
			 * It's relative to the current working directory.
			 * Put the current working directory at the start
			 * of the output.
			 */
   size_t work_sz = 1024;
   char *work = mem_alloc(work_sz);
   /*
			 * Determine what size of buffer is necessary to
			 * hold the working directory.
			 */
   while (1) {
    if (getcwd(work, work_sz)) {
     /*
					 * getcwd() is supposed to return an
					 * absolute path name.  Process it
					 * through path_normalize() in case
					 * doesn't exclude having redundant
					 * path separators or things like "/./"
					 * or "/../" in it.
					 */
     if (work[0] != PATH_SEPC) {
      /*
						 * Got a relative path.  Give
						 * up.
						 */
      mem_free(work);
      goto ABNORMAL_RETURN;
     }
     result = path_normalize(buf, len, work,
      (path_in[0]) ? true : false,
      &oidx_high, NULL);
     mem_free(work);
     if ((result != 0 && result != 1)
       || oidx_high <= 1) {
      goto ABNORMAL_RETURN;
     }
     /* Backup over the trailing null. */
     oidx = oidx_high - 1;
     break;
    } else if (errno != ERANGE) {
     /*
					 * Increasing the buffer size won't
					 * help resolve the error so give up.
					 */
     mem_free(work);
     goto ABNORMAL_RETURN;
    }
    if (work_sz < ((size_t) -1) / 2) {
     work_sz *= 2;
    } else if (work_sz < (size_t) -1) {
     work_sz = (size_t) -1;
    } else {
     /* Give up. */
     mem_free(work);
     goto ABNORMAL_RETURN;
    }
    work = mem_realloc(work, work_sz);
   }
   iidx = 0;
  }
 } else {
  /* Copy the leading path separator. */
  if (len) {
   buf[0] = PATH_SEPC;
  }
  oidx = 1;
  iidx = 1;
 }
 root_size = 1;
 while (1) {
  if (!path_in[iidx]) {
   break;
  }
  /*
		 * The output path generated so far should end with a path
		 * separator, unless it was necessary to truncate the result.
		 */
  assert((oidx <= len && oidx > 0 && buf[oidx - 1] == PATH_SEPC)
   || (oidx >= len));
  if (path_in[iidx] == PATH_SEPC) {
   /* Strip redundant path separator. */
   ++iidx;
   continue;
  }
  if (path_in[iidx] == '.') {
   if (!path_in[iidx + 1]) {
    /*
				 * Trailing, PATH_SEPC + "." strips off the
				 * PATH_SEPC, if possible.
				 */
    if (oidx > root_size) {
     /*
					 * Remember what the size was before
					 * removing the path separator since
					 * that can affect the length of the
					 * buffer needed to for the
					 * normalization.
					 */
     oidx_high = MAX(oidx, oidx_high);
     --oidx;
     ++iidx;
    }
    break;
   }
   if (path_in[iidx + 1] == PATH_SEPC) {
    /*
				 * Interstitial PATH_SEPC + "." + PATH_SEPC
				 * turns into PATH_SEPC which has already been
				 * transferred to the output.
				 */
    iidx += 2;
    continue;
   }
   if (path_in[iidx + 1] == '.') {
    if (!path_in[iidx + 2] || path_in[iidx + 2]
      == PATH_SEPC) {
     /*
					 * Trailing or interstitial PATH_SEPC +
					 * ".." + PATH_SEPC removes the last
					 * path component (if already at the
					 * root of the path, remain there).  In
					 * this implementation, don't try to
					 * remove that component if have already
					 * exceeded the size of the output
					 * buffer.
					 */
     if (oidx > root_size && oidx <= len) {
      /*
						 * Remember what the size was
						 * before removing the last
						 * component since that can
						 * influence what buffer
						 * size is needed to do the
						 * normalization with this
						 * implementation.
						 */
      oidx_high = MAX(oidx,
       oidx_high);
      /*
						 * Back over the trailing path
						 * separator already in the
						 * output buffer.
						 */
      --oidx;
      /*
						 * Remove the last path
						 * component.  Leaving a
						 * trailing separator.
						 */
      while (1) {
       assert(oidx > 0);
       if (buf[oidx - 1] == PATH_SEPC) {
        break;
       }
       --oidx;
      }
     }
     if (!path_in[iidx + 2]) {
      /*
						 * Since ".." is at the end of
						 * the path, remove the trailing
						 * separator, unless that
						 * would cut into the root
						 * portion.
						 */
      if (oidx > root_size) {
       --oidx;
       /*
							 * Leave at the end
							 * of the string for
							 * handling of
							 * trailing_sep.
							 */
       iidx += 2;
      }
      break;
     }
     /* Skip over the ".." + PATH_SEPC. */
     iidx += 3;
     continue;
    }
   }
  }
  /*
		 * Copy up to and including the next path separator or the
		 * end, whichever comes first.
		 */
  while (1) {
   if (!path_in[iidx]) {
    break;
   }
   if (path_in[iidx] == PATH_SEPC) {
    if (oidx < len) {
     buf[oidx] = path_in[iidx];
    }
    ++oidx;
    ++iidx;
    break;
   }
   if (oidx < len) {
    buf[oidx] = path_in[iidx];
   }
   ++oidx;
   ++iidx;
  }
 }
 /*
	 * Add trailing path separator if requested, needed, and there's room.
	 */
 if (trailing_sep) {
  /*
		 * The input doesn't end in a path separator so the output
		 * so far won't have one at the end as well.
		 */
  if (iidx == 0 || path_in[iidx - 1] != PATH_SEPC) {
   if (oidx < len) {
    buf[oidx] = PATH_SEPC;
   }
   ++oidx;
  }
 }
 /* Guarantee null termination if len is greater than zero. */
 if (oidx < len) {
  buf[oidx] = '\0';
  result = 0;
 } else {
  if (len > 0) {
   buf[len - 1] = '\0';
  }
  result = 1;
 }
 ++oidx;
 if (req_len) {
  *req_len = MAX(oidx, oidx_high);
 }
 if (root_len) {
  *root_len = root_size;
 }
 return result;
ABNORMAL_RETURN:
 if (len > 0) {
  buf[0] = '\0';
 }
 if (req_len) {
  *req_len = 0;
 }
 if (root_len) {
  *root_len = 0;
 }
 return 2;
}
/**
 * Return the index of the filename in a path, using PATH_SEPC. If no path
 * separator is found, return 0.
 */
size_t path_filename_index(const char *path)
{
 int i;
 if (strlen(path) == 0)
  return 0;
 for (i = strlen(path) - 1; i >= 0; i--) {
  if (path[i] == PATH_SEPC)
   return i + 1;
 }
 return 0;
}
/**
 * ------------------------------------------------------------------------
 * File-handling API
 * ------------------------------------------------------------------------ */
/* Some defines for compatibility between various build platforms */
/* if the flag O_BINARY is not defined, it is not needed , but we still
 * need it defined so it will compile */
/* Avoid a compiler warning when cross compiling for windows */
/* Private structure to hold file pointers and useful info. */
struct ang_file
{
 FILE *fh;
 char *fname;
 file_mode mode;
};
/** Utility functions **/
/**
 * Delete file 'fname'.
 */
bool file_delete(const char *fname)
{
 char buf[1024];
 /* Get the system-specific paths */
 path_parse(buf, sizeof(buf), fname);
 return (remove(buf) == 0);
}
/**
 * Move file 'fname' to 'newname'.
 */
bool file_move(const char *fname, const char *newname)
{
 char buf[1024];
 char aux[1024];
 /* Get the system-specific paths */
 path_parse(buf, sizeof(buf), fname);
 path_parse(aux, sizeof(aux), newname);
 return (rename(buf, aux) == 0);
}
/**
 * Decide whether a file exists or not.
 */
bool file_exists(const char *fname)
{
 struct stat st;
 return (stat(fname, &st) == 0);
}
/**
 * Return true if first is newer than second, false otherwise.
 */
bool file_newer(const char *first, const char *second)
{
 struct stat stat1, stat2;
 /* If the first doesn't exist, the first is not newer. */
 if (stat(first, &stat1) != 0) return false;
 /* If the second doesn't exist, the first is always newer. */
 if (stat(second, &stat2) != 0) return true;
 /* Compare modification times. */
 return stat1.st_mtime > stat2.st_mtime ? true : false;
}
/** File-handle functions **/
void (*file_open_hook)(const char *path, file_type ftype);
/**
 * Open file 'fname', in mode 'mode', with filetype 'ftype'.
 * Returns file handle or NULL.
 */
ang_file *file_open(const char *fname, file_mode mode, file_type ftype)
{
 ang_file *f = mem_zalloc(sizeof(ang_file));
 char buf[1024];
 (void)ftype;
 /* Get the system-specific path */
 path_parse(buf, sizeof(buf), fname);
 switch (mode) {
  case MODE_WRITE: {
   if (ftype == FTYPE_SAVE) {
    /* open only if the file does not exist */
    int fd;
    fd = open(buf, O_CREAT | O_EXCL | O_WRONLY | 0, S_IREAD | S_IWRITE);
    if (fd < 0) {
     /* there was some error */
     f->fh = NULL;
    } else {
     f->fh = fdopen(fd, "wb");
    }
   } else {
    f->fh = fopen(buf, "wb");
   }
   break;
  }
  case MODE_READ:
   f->fh = fopen(buf, "rb");
   break;
  case MODE_APPEND:
   f->fh = fopen(buf, "a+");
   break;
  default:
   assert(0);
 }
 if (f->fh == NULL) {
  mem_free(f);
  return NULL;
 }
 f->fname = string_make(buf);
 f->mode = mode;
 if (mode != MODE_READ && file_open_hook)
  file_open_hook(buf, ftype);
 return f;
}
/**
 * Close file handle 'f'.
 */
bool file_close(ang_file *f)
{
 if (fclose(f->fh) != 0)
  return false;
 mem_free(f->fname);
 mem_free(f);
 return true;
}
/** Locking functions **/
/**
 * Lock a file using POSIX locks, on platforms where this is supported.
 */
void file_lock(ang_file *f)
{
 struct flock lock;
 lock.l_type = (f->mode == MODE_READ ? F_RDLCK : F_WRLCK);
 lock.l_whence = SEEK_SET;
 lock.l_start = 0;
 lock.l_len = 0;
 lock.l_pid = 0;
 fcntl(fileno(f->fh), F_SETLKW, &lock);
}
/**
 * Unlock a file locked using file_lock().
 */
void file_unlock(ang_file *f)
{
 struct flock lock;
 lock.l_type = F_UNLCK;
 lock.l_whence = SEEK_SET;
 lock.l_start = 0;
 lock.l_len = 0;
 lock.l_pid = 0;
 fcntl(fileno(f->fh), F_SETLK, &lock);
}
/** Byte-based IO and functions **/
/**
 * Seek to location 'pos' in file 'f'.
 */
bool file_skip(ang_file *f, int bytes)
{
 return (fseek(f->fh, bytes, SEEK_CUR) == 0);
}
/**
 * Read a single, 8-bit character from file 'f'.
 */
bool file_readc(ang_file *f, uint8_t *b)
{
 int i = fgetc(f->fh);
 if (i == EOF)
  return false;
 *b = (uint8_t)i;
 return true;
}
/**
 * Write a single, 8-bit character 'b' to file 'f'.
 */
bool file_writec(ang_file *f, uint8_t b)
{
 return file_write(f, (const char *)&b, 1);
}
/**
 * Read 'n' bytes from file 'f' into array 'buf'.
 */
int file_read(ang_file *f, char *buf, size_t n)
{
 size_t read = fread(buf, 1, n, f->fh);
 if (read == 0 && ferror(f->fh))
  return -1;
 else
  return read;
}
/**
 * Append 'n' bytes of array 'buf' to file 'f'.
 */
bool file_write(ang_file *f, const char *buf, size_t n)
{
 return fwrite(buf, 1, n, f->fh) == n;
}
/** Line-based IO **/
/**
 * Read a line of text from file 'f' into buffer 'buf' of size 'n' bytes.
 *
 * Support both \r\n and \n as line endings, but not the outdated \r that used
 * to be used on Macs.  Replace non-printables with '?', and \ts with ' '.
 */
bool file_getl(ang_file *f, char *buf, size_t len)
{
 bool seen_cr = false;
 uint8_t b;
 size_t i = 0;
 /* Leave a byte for the terminating 0 */
 size_t max_len = len - 1;
 while (i < max_len) {
  char c;
  if (!file_readc(f, &b)) {
   buf[i] = '\0';
   return (i == 0) ? false : true;
  }
  c = (char) b;
  if (c == '\r') {
   seen_cr = true;
   continue;
  }
  if (seen_cr && c != '\n') {
   fseek(f->fh, -1, SEEK_CUR);
   buf[i] = '\0';
   return true;
  }
  if (c == '\n') {
   buf[i] = '\0';
   return true;
  }
  /* Expand tabs */
  if (c == '\t') {
   /* Next tab stop */
   size_t tabstop = ((i + 4) / 4) * 4;
   if (tabstop >= len) break;
   /* Convert to spaces */
   while (i < tabstop)
    buf[i++] = ' ';
   continue;
  }
  buf[i++] = c;
 }
 buf[i] = '\0';
 return true;
}
/**
 * Append a line of text 'buf' to the end of file 'f', using system-dependent
 * line ending.
 */
bool file_put(ang_file *f, const char *buf)
{
 return file_write(f, buf, strlen(buf));
}
/*
 * The comp.lang.c FAQ recommends this pairing for varargs functions.
 * See <http://c-faq.com/varargs/handoff.html>
 */
/**
 * Append a formatted line of text to the end of file 'f'.
 *
 * file_putf() is the ellipsis version. Most file output will call this
 * version. It calls file_vputf() to do the real work. It returns true
 * if the write was successful and false otherwise.
 */
bool file_putf(ang_file *f, const char *fmt, ...)
{
 va_list vp;
 bool status;
 if (!f) return false;
 va_start(vp, fmt);
 status = file_vputf(f, fmt, vp);
 va_end(vp);
 return status;
}
/**
 * Append a formatted line of text to the end of file 'f'.
 *
 * file_vputf() is the va_list version. It returns true if the write was
 * successful and false otherwise.
 */
bool file_vputf(ang_file *f, const char *fmt, va_list vp)
{
 char buf[1024];
 if (!f) return false;
 (void)vstrnfmt(buf, sizeof(buf), fmt, vp);
 return file_put(f, buf);
}
bool dir_exists(const char *path)
{
 struct stat buf;
 if (stat(path, &buf) != 0)
  return false;
 else if (buf.st_mode & S_IFDIR)
  return true;
 else
  return false;
}
bool dir_create(const char *path)
{
 const char *ptr;
 char buf[512];
 /* If the directory already exists then we're done */
 if (dir_exists(path)) return true;
 /* Iterate through the path looking for path segments. At each step,
	 * create the path segment if it doesn't already exist. */
 for (ptr = path; *ptr; ptr++) {
  if (*ptr == PATH_SEPC) {
   /* Find the length of the parent path string */
   size_t len = (size_t)(ptr - path);
   /* Skip the initial slash */
   if (len == 0) continue;
   /* If this is a duplicate path separator, continue */
   if (*(ptr - 1) == PATH_SEPC) continue;
   /* We can't handle really big filenames */
   if (len - 1 > 512) return false;
   /* Create the parent path string, plus null-padding */
   my_strcpy(buf, path, len + 1);
   /* Skip if the parent exists */
   if (dir_exists(buf)) continue;
   /* The parent doesn't exist, so create it or fail */
   if (false != 0) return false;
  }
 }
 return false == 0 ? true : false;
}
/**
 * ------------------------------------------------------------------------
 * Directory scanning API
 * ------------------------------------------------------------------------ */
/*
 * For information on what these are meant to do, please read the header file.
 */
/* Define our ang_dir type */
struct ang_dir
{
 DIR *d;
 char *dirname;
 bool only_files;
};
ang_dir *my_dopen(const char *dirname)
{
 ang_dir *dir;
 DIR *d;
 /* Try to open the directory */
 d = opendir(dirname);
 if (!d) return NULL;
 /* Allocate memory for the handle */
 dir = mem_zalloc(sizeof(ang_dir));
 if (!dir) {
  closedir(d);
  return NULL;
 }
 /* Set up the handle */
 dir->d = d;
 dir->dirname = string_make(dirname);
 dir->only_files = true;
 /* Success */
 return dir;
}
bool alter_ang_dir_only_files(ang_dir *dir, bool newval)
{
 bool oldval = dir->only_files;
 dir->only_files = newval;
 return oldval;
}
bool my_dread(ang_dir *dir, char *fname, size_t len)
{
 struct dirent *entry;
 struct stat filedata;
 char path[1024];
 assert(dir != NULL);
 /* Try reading another entry */
 while (1) {
  entry = readdir(dir->d);
  if (!entry) return false;
  path_build(path, sizeof path, dir->dirname, entry->d_name);
  /* Check to see if it exists */
  if (stat(path, &filedata) != 0)
   continue;
  /* Check to see if it's a directory */
  if (dir->only_files && S_ISDIR(filedata.st_mode))
   continue;
  /* We've found something worth returning */
  break;
 }
 /* Copy the filename */
 my_strcpy(fname, entry->d_name, len);
 return true;
}
void my_dclose(ang_dir *dir)
{
 /* Close directory */
 if (dir->d)
  closedir(dir->d);
 /* Free memory */
 mem_free(dir->dirname);
 mem_free(dir);
}
/**
 * \file z-form.c
 * \brief Low-level text formatting (snprintf() replacement)
 *
 * Copyright (c) 1997 Ben Harrison
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Here is some information about the routines in this file.
 *
 * In general, the following routines take a "buffer", a "max length",
 * a "format string", and some "arguments", and use the format string
 * and the arguments to create a (terminated) string in the buffer
 * (using only the first "max length" bytes), and return the "length"
 * of the resulting string, not including the (mandatory) terminator.
 *
 * The format strings allow the basic "sprintf()" format sequences, though
 * some of them are processed slightly more carefully or portably, as well
 * as a few "special" sequences, including the "capilitization" sequences of
 * "%C" and "%S".
 *
 * Note that some "limitations" are enforced by the current implementation,
 * for example, no "format sequence" can exceed 100 characters, including any
 * "length" restrictions, and the result of combining and "format sequence"
 * with the relevent "arguments" must not exceed 1000 characters.
 *
 * These limitations could be fixed by stealing some of the code from,
 * say, "vsprintf()" and placing it into my "vstrnfmt()" function.
 *
 * Legal format characters: %,b,n,p,c,s,d,i,o,u,X,x,E,e,F,f,G,g,r,v.
 *
 * Format("%%")
 *   Append the literal "%".
 *   No legal modifiers.
 *
 * Format("%n", size_t *np)
 *   Save the current length into (*np).
 *   No legal modifiers.
 *
 * Format("%p", void *v)
 *   Append the pointer "v" (implementation varies).
 *   No legal modifiers.
 *
 * Format("%E", double r)
 * Format("%F", double r)
 * Format("%G", double r)
 * Format("%e", double r)
 * Format("%f", double r)
 * Format("%g", double r)
 *   Append the double "r", in various formats.
 *
 * Format("%ld", long int i)
 *   Append the long integer "i".
 *
 * Format("%d", int i)
 *   Append the integer "i".
 *
 * Format("%lu", unsigned long int i)
 *   Append the unsigned long integer "i".
 *
 * Format("%u", unsigned int i)
 *   Append the unsigned integer "i".
 *
 * Format("%lo", unsigned long int i)
 *   Append the unsigned long integer "i", in octal.
 *
 * Format("%o", unsigned int i)
 *   Append the unsigned integer "i", in octal.
 *
 * Format("%lX", unsigned long int i)
 *   Note -- use all capital letters
 * Format("%lx", unsigned long int i)
 *   Append the unsigned long integer "i", in hexidecimal.
 *
 * Format("%X", unsigned int i)
 *   Note -- use all capital letters
 * Format("%x", unsigned int i)
 *   Append the unsigned integer "i", in hexidecimal.
 *
 * Format("%c", char c)
 *   Append the character "c".
 *   Do not use the "+" or "0" flags.
 *
 * Format("%s", const char *s)
 *   Append the string "s".
 *   Do not use the "+" or "0" flags.
 *   Note that a "NULL" value of "s" is converted to the empty string.
 *
 * Format("%y", type_union *y). Use any of the above patterns; 
 * z is interpreted as one of c, d, f, or s in the patterns above,
 * as appropriate for the type of the corresponding argument.
 * (There is currently no way to render a typeunion in octal or hex.)
 * 
 * For examples below, assume "int n = 0; int m = 100; char buf[100];",
 * plus "char *s = NULL;", and unknown values "char *txt; int i;".
 *
 * For example: "n = strnfmt(buf, -1, "(Max %d)", i);" will have a
 * similar effect as "sprintf(buf, "(Max %d)", i); n = strlen(buf);".
 *
 * For example: "(void)strnfmt(buf, 16, "%s", txt);" will have a similar
 * effect as "strncpy(buf, txt, 16); buf[15] = '\0';".
 *
 * For example: "if (strnfmt(buf, 16, "%s", txt) < 16) ..." will have
 * a similar effect as "strcpy(buf, txt)" but with bounds checking.
 *
 * For example: "s = buf; s += vstrnfmt(s, -1, ...); ..." will allow
 * multiple "appends" to "buf" (at the cost of losing the max-length info).
 *
 * For example: "s = buf; n = vstrnfmt(s+n, 100-n, ...); ..." will allow
 * multiple bounded "appends" to "buf", with constant access to "strlen(buf)".
 *
 * For example: "format("%-.*s", i, txt)" will produce a string containing
 * the first "i" characters of "txt", left justified.
 */
/**
 * Basic "vararg" format function.
 *
 * This function takes a buffer, a max byte count, a format string, and
 * a va_list of arguments to the format string, and uses the format string
 * and the arguments to create a string to the buffer.  The string is
 * derived from the format string and the arguments in the manner of the
 * "sprintf()" function, but with some extra "format" commands.  Note that
 * this function will never use more than the given number of bytes in the
 * buffer, preventing messy invalid memory references.  This function then
 * returns the total number of non-null bytes written into the buffer.
 *
 * Method: Let "str" be the (unlimited) created string, and let "len" be the
 * smaller of "max-1" and "strlen(str)".  We copy the first "len" chars of
 * "str" into "buf", place "\0" into buf[len], and return "len".
 *
 * In English, we do a sprintf() into "buf", a buffer with size "max",
 * and we return the resulting value of "strlen(buf)", but we allow some
 * special format commands, and we are more careful than "sprintf()".
 *
 * Typically, "max" is in fact the "size" of "buf", and thus represents
 * the "number" of chars in "buf" which are ALLOWED to be used.  An
 * alternative definition would have required "buf" to hold at least
 * "max+1" characters, and would have used that extra character only
 * in the case where "buf" was too short for the result.  This would
 * give an easy test for "overflow", but a less "obvious" semantics.
 *
 * Note that if the buffer was "too short" to hold the result, we will
 * always return "max-1", but we also return "max-1" if the buffer was
 * "just long enough".  We could have returned "max" if the buffer was
 * too short, not written a null, and forced the programmer to deal with
 * this special case, but I felt that it is better to at least give a
 * "usable" result when the buffer was too long instead of either giving
 * a memory overwrite like "sprintf()" or a non-terminted string like
 * "strncpy()".  Note that "strncpy()" also "null-pads" the result.
 *
 * Note that in most cases "just long enough" is probably "too short".
 *
 * As of 4.0, we use snprintf (for safety, and to quieten picky compilers)
 *
 * We should also consider extracting and processing the "width" and other
 * "flags" by hand, it might be more "accurate", and it would allow us to
 * remove the limit (1000 chars) on the result of format sequences.
 *
 * Also, some sequences, such as "%+d" by hand, do not work on all machines,
 * and could thus be correctly handled here.
 *
 * Error detection in this routine is not very graceful, in particular,
 * if an error is detected in the format string, we simply "pre-terminate"
 * the given buffer to a length of zero, and return a "length" of zero.
 * The contents of "buf", except for "buf[0]", may then be undefined.
 */
size_t vstrnfmt(char *buf, size_t max, const char *fmt, va_list vp)
{
 const char *s;
 int i = 0, len = 0;
 /* The argument is "long" */
 bool do_long;
 /* Bytes used in buffer */
 size_t n;
 /* Bytes used in format sequence */
 size_t q;
 /* Format sequence */
 char aux[128];
 /* Resulting string */
 char tmp[1024];
 assert(max);
 assert(fmt);
 /* Begin the buffer */
 n = 0;
 /* Begin the format string */
 s = fmt;
 /* Scan the format string */
 while (true) {
  /* All done */
  if (!*s) break;
  /* Normal character */
  if (*s != '%') {
   /* Check total length */
   if (n == max-1) break;
   /* Save the character */
   buf[n++] = *s++;
   /* Continue */
   continue;
  }
  /* Skip the "percent" */
  s++;
  /* Pre-process "%%" */
  if (*s == '%') {
   /* Check total length */
   if (n == max-1) break;
   /* Save the percent */
   buf[n++] = '%';
   /* Skip the "%" */
   s++;
   /* Continue */
   continue;
  }
  /* Pre-process "%n" */
  if (*s == 'n') {
   size_t *arg;
   /* Get the next argument */
   arg = va_arg(vp, size_t *);
   /* Save the current length */
   (*arg) = n;
   /* Skip the "n" */
   s++;
   /* Continue */
   continue;
  }
  /* Begin the "aux" string */
  q = 0;
  /* Save the "percent" */
  aux[q++] = '%';
  do_long = false;
  /* Build the "aux" string */
  while (true) {
   /* Error -- format sequence is not terminated */
   if (!*s) {
    /* Terminate the buffer */
    buf[0] = '\0';
    /* Return "error" */
    return (0);
   }
   /* Error -- format sequence may be too long */
   if (q > 100) {
    /* Terminate the buffer */
    buf[0] = '\0';
    /* Return "error" */
    return (0);
   }
   /* Handle "alphabetic" or "non-alphabetic"chars */
   if (isalpha((unsigned char)*s)) {
    /* Hack -- handle "long" request */
    if (*s == 'l') {
     /* Save the character */
     aux[q++] = *s++;
     /* Note the "long" flag */
     do_long = true;
    } else {
     /* Save the character */
     aux[q++] = *s++;
     /* Stop processing the format sequence */
     break;
    }
   } else {
    /* Hack -- Handle 'star' (for "variable length" argument) */
    if (*s == '*') {
     int arg;
     /* Get the next argument */
     arg = va_arg(vp, int);
     /* Hack -- append the "length" */
     snprintf(aux + q, sizeof(aux) - q, "%d", arg);
     /* Hack -- accept the "length" */
     while (aux[q]) q++;
     /* Skip the "*" */
     s++;
    } else {
     /* Save the normal character (digits, "-", "+", ".", etc) */
     aux[q++] = *s++;
    }
   }
  }
  /* Terminate "aux" */
  aux[q] = '\0';
  /* Clear "tmp" */
  tmp[0] = '\0';
  /* Process the "format" symbol */
  switch (aux[q - 1]) {
   /* Simple Character -- standard format */
   case 'c':
   {
    int arg;
    /* Get the next argument */
    arg = va_arg(vp, int);
    /* Format the argument */
    snprintf(tmp, sizeof(tmp), aux, arg);
    /* Done */
    break;
   }
   /* Signed Integers -- standard format */
   case 'd': case 'i':
   {
    if (do_long) {
     long arg;
     /* Get the next argument */
     arg = va_arg(vp, long);
     /* Format the argument */
     snprintf(tmp, sizeof(tmp), aux, arg);
    } else {
     int arg;
     /* Get the next argument */
     arg = va_arg(vp, int);
     /* Format the argument */
     snprintf(tmp, sizeof(tmp), aux, arg);
    }
    /* Done */
    break;
   }
   /* Unsigned Integers -- various formats */
   case 'u': case 'o': case 'x': case 'X':
   {
    if (do_long) {
     unsigned long arg;
     /* Get the next argument */
     arg = va_arg(vp, unsigned long);
     /* Format the argument */
     snprintf(tmp, sizeof(tmp), aux, arg);
    } else {
     unsigned int arg;
     /* Get the next argument */
     arg = va_arg(vp, unsigned int);
     /* Format the argument */
     snprintf(tmp, sizeof(tmp), aux, arg);
    }
    /* Done */
    break;
   }
   /* Floating Point -- various formats */
   case 'f':
   case 'e': case 'E':
   case 'g': case 'G':
   {
    double arg;
    /* Get the next argument */
    arg = va_arg(vp, double);
    /* Format the argument */
    snprintf(tmp, sizeof(tmp), aux, arg);
    /* Done */
    break;
   }
   /* Pointer -- implementation varies */
   case 'p':
   {
    void *arg;
    /* Get the next argument */
    arg = va_arg(vp, void*);
    /* Format the argument */
    snprintf(tmp, sizeof(tmp), aux, arg);
    /* Done */
    break;
   }
   /* String */
   case 's':
   {
    if (do_long) {
     const wchar_t *arg;
     char arg2[1024];
     /* XXX There is a big bug here: if one
					 * passes "%.0s" to strnfmt, then really we
					 * should not dereference the arg at all.
					 * But it does.  See bug #666.
					 */
     /* Get the next argument */
     arg = va_arg(vp, const wchar_t *);
     /* Hack -- convert NULL to EMPTY */
     if (!arg) arg = L"";
     /* Prevent buffer overflows and convert string to char */
     /* this really should use a wcstombs type function */
     len = wcslen(arg);
     if (len >= 768) {
      len = 767;
     }
     for (i = 0; i < len; ++i) {
      arg2[i] = (char)arg[i];
     }
     arg2[len] = '\0';
     /* Remove the l from aux, since we no longer have wchar_t
					 * as input */
     aux[q-2] = 's';
     aux[q-1] = '\0';
     /* Format the argument */
     snprintf(tmp, sizeof(tmp), aux, arg2);
     /* Done */
     break;
    } else {
     const char *arg;
     char arg2[1024];
     /* XXX There is a big bug here: if one
					 * passes "%.0s" to strnfmt, then really we
					 * should not dereference the arg at all.
					 * But it does.  See bug #666.
					 */
     /* Get the next argument */
     arg = va_arg(vp, const char *);
     /* Hack -- convert NULL to EMPTY */
     if (!arg) arg = "";
     /* Prevent buffer overflows */
     (void)my_strcpy(arg2, arg, sizeof(arg2));
     /* Format the argument */
     snprintf(tmp, sizeof(tmp), aux, arg2);
     /* Done */
     break;
    }
   }
   /* Oops */
   default:
   {
    /* Error -- illegal format char */
    buf[0] = '\0';
    /* Return "error" */
    return (0);
   }
  }
  /* Now append "tmp" to "buf" */
  for (q = 0; tmp[q]; q++) {
   /* Check total length */
   if (n == max-1) break;
   /* Save the character */
   buf[n++] = tmp[q];
  }
 }
 /* Terminate buffer */
 buf[n] = '\0';
 /* Return length */
 return (n);
}
/**
 * Add a formatted string to the end of a string
 */
void strnfcat(char *str, size_t max, size_t *end, const char *fmt, ...)
{
 size_t len;
 va_list vp;
 /* Paranoia */
 if (*end >= max) return;
 /* Begin the Varargs Stuff */
 va_start(vp, fmt);
 /* Build the string */
 len = vstrnfmt(&str[*end], max - *end, fmt, vp);
 /* End the Varargs Stuff */
 va_end(vp);
 /* Change the end value */
 *end += len;
}
static char *format_buf = NULL;
static size_t format_len = 0;
/**
 * Do a vstrnfmt (see above) into a (growable) static buffer.
 * This buffer is usable for very short term formatting of results.
 */
char *vformat(const char *fmt, va_list vp)
{
 /* Initial allocation */
 if (!format_buf) {
  format_len = 1024;
  format_buf = mem_zalloc(format_len);
  format_buf[0] = 0;
 }
 /* Null format yields last result */
 if (!fmt) return (format_buf);
 /* Keep going until successful */
 while (1) {
  va_list args;
  size_t len;
  /* Build the string */
  va_copy(args, vp);
  len = vstrnfmt(format_buf, format_len, fmt, args);
  va_end(args);
  /* Success */
  if (len < format_len-1) break;
  /* Grow the buffer */
  format_len = format_len * 2;
  format_buf = mem_realloc(format_buf, format_len);
 }
 /* Return the new buffer */
 return (format_buf);
}
void vformat_kill(void)
{
 mem_free(format_buf);
}
/**
 * Do a vstrnfmt (see above) into a buffer of a given size.
 */
size_t strnfmt(char *buf, size_t max, const char *fmt, ...)
{
 size_t len;
 va_list vp;
 /* Begin the Varargs Stuff */
 va_start(vp, fmt);
 /* Do the va_arg fmt to the buffer */
 len = vstrnfmt(buf, max, fmt, vp);
 /* End the Varargs Stuff */
 va_end(vp);
 /* Return the number of bytes written */
 return (len);
}
/**
 * Do a vstrnfmt() into (see above) into a (growable) static buffer.
 * This buffer is usable for very short term formatting of results.
 * Note that the buffer is (technically) writable, but only up to
 * the length of the string contained inside it.
 */
char *format(const char *fmt, ...)
{
 char *res;
 va_list vp;
 /* Begin the Varargs Stuff */
 va_start(vp, fmt);
 /* Format the args */
 res = vformat(fmt, vp);
 /* End the Varargs Stuff */
 va_end(vp);
 /* Return the result */
 return (res);
}
/**
 * Vararg interface to plog()
 */
void plog_fmt(const char *fmt, ...)
{
 char *res;
 va_list vp;
 /* Begin the Varargs Stuff */
 va_start(vp, fmt);
 /* Format the args */
 res = vformat(fmt, vp);
 /* End the Varargs Stuff */
 va_end(vp);
 /* Call plog */
 plog(res);
}
/**
 * Vararg interface to quit()
 */
void quit_fmt(const char *fmt, ...)
{
 char *res;
 va_list vp;
 /* Begin the Varargs Stuff */
 va_start(vp, fmt);
 /* Format */
 res = vformat(fmt, vp);
 /* End the Varargs Stuff */
 va_end(vp);
 /* Call quit() */
 quit(res);
}
/**
 * \file z-quark.c
 * \brief Save memory by storing strings in a global array, ensuring
 * that each is only allocated once.
 *
 * Copyright (c) 1997 Ben Harrison
 * Copyright (c) 2007 "Elly"
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
static char **quarks;
static size_t nr_quarks = 1;
static size_t alloc_quarks = 0;
quark_t quark_add(const char *str)
{
 quark_t q;
 for (q = 1; q < nr_quarks; q++) {
  if (streq(quarks[q], str))
   return q;
 }
 if (nr_quarks == alloc_quarks) {
  alloc_quarks *= 2;
  quarks = mem_realloc(quarks, alloc_quarks * sizeof(char *));
 }
 q = nr_quarks++;
 quarks[q] = string_make(str);
 return q;
}
const char *quark_str(quark_t q)
{
 return (q >= nr_quarks ? NULL : quarks[q]);
}
void quarks_init(void)
{
 nr_quarks = 1;
 alloc_quarks = 16;
 quarks = mem_zalloc(alloc_quarks * sizeof(char*));
}
void quarks_free(void)
{
 size_t i;
 /* quarks[0] is special */
 for (i = 1; i < nr_quarks; i++)
  string_free(quarks[i]);
 mem_free(quarks);
}
struct init_module z_quark_module = {
 .name = "z-quark",
 .init = quarks_init,
 .cleanup = quarks_free
};
/**
 * \file z-queue.c
 * \brief Simple circular integer queue.
 *
 * Copyright (c) 2011 Erik Osheim
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
struct queue *q_new(size_t size) {
    struct queue *q = (struct queue*)malloc(sizeof(struct queue));
 if (!q) return NULL;
    q->data = (uintptr_t*)malloc(sizeof(uintptr_t) * (size + 1));
    q->size = size + 1;
    q->head = 0;
    q->tail = 0;
    return q;
}
int q_len(struct queue *q) {
    int len;
    if (q->tail >= q->head) {
        len = q->tail - q->head;
    } else {
        len = q->size - q->head + q->tail;
    }
    return len;
}
void q_push(struct queue *q, uintptr_t item) {
    q->data[q->tail] = item;
    q->tail = (q->tail + 1) % q->size;
    if (q->tail == q->head) abort();
}
uintptr_t q_pop(struct queue *q) {
    uintptr_t item = q->data[q->head];
    if (q->head == q->tail) abort();
    q->head = (q->head + 1) % q->size;
    return item;
}
void q_free(struct queue *q) {
    free(q->data);
    free(q);
}
/**
 * \file z-rand.c
 * \brief A Random Number Generator for Angband
 *
 * Copyright (c) 1997 Ben Harrison, Randy Hutson
 * 
 * See below for copyright on the WELL random number generator.
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * This file provides a pseudo-random number generator.
 *
 * This code provides both a "quick" random number generator (4 bytes of
 * state), and a "complex" random number generator (128 + 4 bytes of state).
 *
 * The complex RNG (used for most game entropy) is provided by the WELL102a
 * algorithm, used with permission. See below for copyright information
 * about the WELL implementation.
 *
 * To use of the "simple" RNG, activate it via "Rand_quick = true" and
 * "Rand_value = seed". After that it will be automatically used instead of
 * the "complex" RNG. When you are done, you can de-activate it via
 * "Rand_quick = false". You can also choose a new seed.
 */
/* begin WELL RNG
 * *************************************************************************
 * Copyright:  Francois Panneton and Pierre L'Ecuyer, University of Montreal
 *             Makoto Matsumoto, Hiroshima University                       
 * *************************************************************************
 * Code was modified slightly by Erik Osheim to work on unsigned integers.  
 */
uint32_t state_i = 0;
uint32_t STATE[RAND_DEG] = {0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0};
uint32_t z0, z1, z2;
static uint32_t WELLRNG1024a (void){
 z0 = STATE[(state_i + 31) & 0x0000001fU];
 z1 = (STATE[state_i]) ^ (STATE[(state_i + 3) & 0x0000001fU] ^ (STATE[(state_i + 3) & 0x0000001fU] >> 8));
 z2 = (STATE[(state_i + 24) & 0x0000001fU] ^ (STATE[(state_i + 24) & 0x0000001fU] << (-(-19)))) ^ (STATE[(state_i + 10) & 0x0000001fU] ^ (STATE[(state_i + 10) & 0x0000001fU] << (-(-14))));
 STATE[state_i] = z1 ^ z2;
 STATE[(state_i + 31) & 0x0000001fU] = (z0 ^ (z0 << (-(-11)))) ^ (z1 ^ (z1 << (-(-7)))) ^ (z2 ^ (z2 << (-(-13))));
 state_i = (state_i + 31) & 0x0000001fU;
 return STATE[state_i];
}
/* end WELL RNG */
/**
 * Simple RNG, implemented with a linear congruent algorithm.
 */
/**
 * Whether to use the simple RNG or not.
 */
bool Rand_quick = true;
/**
 * The current "seed" of the simple RNG.
 */
uint32_t Rand_value;
static bool rand_fixed = false;
static uint32_t rand_fixval = 0;
/**
 * Initialize the complex RNG using a new seed.
 */
void Rand_state_init(uint32_t seed)
{
 int i, j;
 /* Seed the table */
 STATE[0] = seed;
 /* Propagate the seed */
 for (i = 1; i < RAND_DEG; i++)
  STATE[i] = ((STATE[i - 1]) * 1103515245 + 12345);
 /* Cycle the table ten times per degree */
 for (i = 0; i < RAND_DEG * 10; i++) {
  /* Acquire the next index */
  j = (state_i + 1) % RAND_DEG;
  /* Update the table, extract an entry */
  STATE[j] += STATE[state_i];
  /* Advance the index */
  state_i = j;
 }
}
/**
 * Initialise the RNG
 */
void Rand_init(void)
{
 /* Init RNG */
 if (Rand_quick) {
  uint32_t seed;
  /* Basic seed */
  seed = (uint32_t)(time(NULL));
  /* Mutate the seed on Unix machines */
  seed = ((seed >> 3) * (getpid() << 1));
  /* Use the complex RNG */
  Rand_quick = false;
  /* Seed the "complex" RNG */
  Rand_state_init(seed);
 }
}
/**
 * Extract a "random" number from 0 to m - 1, via division.
 *
 * This method selects "random" 28-bit numbers, and then uses division to drop
 * those numbers into "m" different partitions, plus a small non-partition to
 * reduce bias, taking as the final value the first "good" partition that a
 * number falls into.
 *
 * This method has no bias, and is much less affected by patterns in the "low"
 * bits of the underlying RNG's. However, it is potentially non-terminating.
 */
uint32_t Rand_div(uint32_t m)
{
 uint32_t n, r = 0;
 /* Division by zero will result if m is larger than 0x10000000 */
 assert(m <= 0x10000000);
 /* Hack -- simple case */
 if (m <= 1) return (0);
 if (rand_fixed)
  return (rand_fixval * 1000 * (m - 1)) / (100 * 1000);
 /* Partition size */
 n = (0x10000000 / m);
 if (Rand_quick) {
  /* Use a simple RNG */
  /* Wait for it */
  while (1) {
   /* Cycle the generator */
   r = (Rand_value = ((Rand_value) * 1103515245 + 12345));
   /* Mutate a 28-bit "random" number */
   r = ((r >> 4) & 0x0FFFFFFF) / n;
   /* Done */
   if (r < m) break;
  }
 } else {
  /* Use a complex RNG */
  while (1) {
   /* Get the next pseudorandom number */
   r = WELLRNG1024a();
   /* Mutate a 28-bit "random" number */
   r = ((r >> 4) & 0x0FFFFFFF) / n;
   /* Done */
   if (r < m) break;
  }
 }
 /* Use the value */
 return (r);
}
/**
 * The number of entries in the "Rand_normal_table"
 */
/**
 * The standard deviation of the "Rand_normal_table"
 */
/**
 * The normal distribution table for the "Rand_normal()" function (below)
 */
static int16_t Rand_normal_table[256] = {
 206, 613, 1022, 1430, 1838, 2245, 2652, 3058,
 3463, 3867, 4271, 4673, 5075, 5475, 5874, 6271,
 6667, 7061, 7454, 7845, 8234, 8621, 9006, 9389,
 9770, 10148, 10524, 10898, 11269, 11638, 12004, 12367,
 12727, 13085, 13440, 13792, 14140, 14486, 14828, 15168,
 15504, 15836, 16166, 16492, 16814, 17133, 17449, 17761,
 18069, 18374, 18675, 18972, 19266, 19556, 19842, 20124,
 20403, 20678, 20949, 21216, 21479, 21738, 21994, 22245,
 22493, 22737, 22977, 23213, 23446, 23674, 23899, 24120,
 24336, 24550, 24759, 24965, 25166, 25365, 25559, 25750,
 25937, 26120, 26300, 26476, 26649, 26818, 26983, 27146,
 27304, 27460, 27612, 27760, 27906, 28048, 28187, 28323,
 28455, 28585, 28711, 28835, 28955, 29073, 29188, 29299,
 29409, 29515, 29619, 29720, 29818, 29914, 30007, 30098,
 30186, 30272, 30356, 30437, 30516, 30593, 30668, 30740,
 30810, 30879, 30945, 31010, 31072, 31133, 31192, 31249,
 31304, 31358, 31410, 31460, 31509, 31556, 31601, 31646,
 31688, 31730, 31770, 31808, 31846, 31882, 31917, 31950,
 31983, 32014, 32044, 32074, 32102, 32129, 32155, 32180,
 32205, 32228, 32251, 32273, 32294, 32314, 32333, 32352,
 32370, 32387, 32404, 32420, 32435, 32450, 32464, 32477,
 32490, 32503, 32515, 32526, 32537, 32548, 32558, 32568,
 32577, 32586, 32595, 32603, 32611, 32618, 32625, 32632,
 32639, 32645, 32651, 32657, 32662, 32667, 32672, 32677,
 32682, 32686, 32690, 32694, 32698, 32702, 32705, 32708,
 32711, 32714, 32717, 32720, 32722, 32725, 32727, 32729,
 32731, 32733, 32735, 32737, 32739, 32740, 32742, 32743,
 32745, 32746, 32747, 32748, 32749, 32750, 32751, 32752,
 32753, 32754, 32755, 32756, 32757, 32757, 32758, 32758,
 32759, 32760, 32760, 32761, 32761, 32761, 32762, 32762,
 32763, 32763, 32763, 32764, 32764, 32764, 32764, 32765,
 32765, 32765, 32765, 32766, 32766, 32766, 32766, 32767,
};
/**
 * Generate a random integer number of NORMAL distribution
 *
 * The table above is used to generate a psuedo-normal distribution, in a
 * manner which is much faster than calling a transcendental function to
 * calculate a true normal distribution.
 *
 * Basically, entry 64 * N in the table above represents the number of times
 * out of 32767 that a random variable with normal distribution will fall
 * within N standard deviations of the mean.  That is, about 68 percent of the
 * time for N=1 and 95 percent of the time for N=2.
 *
 * The table above contains a "faked" final entry which allows us to pretend
 * that all values in a normal distribution are strictly less than four
 * standard deviations away from the mean.  This results in "conservative"
 * distribution of approximately 1/32768 values.
 *
 * Note that the binary search takes up to 16 quick iterations.
 */
int16_t Rand_normal(int mean, int stand)
{
 int16_t tmp, offset;
 int16_t low = 0;
 int16_t high = 256;
 /* Paranoia */
 if (stand < 1) return (mean);
 /* Roll for probability */
 tmp = (int16_t)randint0(32768);
 /* Binary Search */
 while (low < high) {
  int mid = (low + high) >> 1;
  /* Move right if forced */
  if (Rand_normal_table[mid] < tmp) {
   low = mid + 1;
  } else {
   high = mid;
  }
 }
 /* Convert the index into an offset */
 offset = (int16_t)((long)stand * (long)low / 64);
 /* One half should be negative */
 if (one_in_(2)) return (mean - offset);
 /* One half should be positive */
 return (mean + offset);
}
/**
 * Choose an integer from a distribution where we know the mean and approximate
 * upper and lower bounds.
 *
 * We divide the imagined distribution into two halves, above and below the
 * mean, and then treat the bounds as if they are the given number of
 * standard deviations from the mean in the appropriate direction.  Note that
 * `stand_u` and `stand_l` are 10 times the number of standart deviations we
 * are asking for.
 * The function chooses an integer from a normal distribution, and then scales
 * it to fit the target distribution.
 */
int Rand_sample(int mean, int upper, int lower, int stand_u, int stand_l)
{
 int pick = Rand_normal(0, 1000);
 /* Scale to fit */
 if (pick > 0) {
  /* Positive pick, scale up */
  pick *= (upper - mean);
  pick /= (100 * stand_u);
 } else if (pick < 0) {
  /* Negative pick, scale down */
  pick *= (mean - lower);
  pick /= (100 * stand_l);
 }
 return mean + pick;
}
/**
 * Generates damage for "2d6" style dice rolls
 */
int damroll(int num, int sides)
{
 int i;
 int sum = 0;
 if (sides <= 0) return 0;
 for (i = 0; i < num; i++)
  sum += randint1(sides);
 return sum;
}
/**
 * Calculation helper function for damroll
 */
int damcalc(int num, int sides, aspect dam_aspect)
{
 switch (dam_aspect) {
  case MAXIMISE:
  case EXTREMIFY: return num * sides;
  case RANDOMISE: return damroll(num, sides);
  case MINIMISE: return num;
  case AVERAGE: return num * (sides + 1) / 2;
 }
 assert(0 && "Should never reach here");
 return 0;
}
/**
 * Generates a random signed long integer X where `A` <= X <= `B`.
 * The integer X falls along a uniform distribution.
 *
 * Note that "rand_range(0, N-1)" == "randint0(N)".
 */
int rand_range(int A, int B)
{
 if (A == B) return A;
 assert(A < B);
 return A + (int32_t)Rand_div(1 + B - A);
}
/**
 * Help determine an "enchantment bonus" for an object.
 */
int16_t m_bonus(int divisor, int level)
{
 if (!divisor) return 0;
 return (level + randint1(10)) / divisor;
}
/**
 * Calculation helper function for m_bonus
 */
int16_t m_bonus_calc(int divisor, int level, aspect bonus_aspect)
{
 if (!divisor) return 0;
 switch (bonus_aspect) {
  case EXTREMIFY:
  case MAXIMISE: return (level + 10) / divisor;
  case RANDOMISE: return m_bonus(divisor, level);
  case MINIMISE: return 0;
  case AVERAGE: return (2 * level + 11) / (2 * divisor);
 }
 assert(0 && "Should never reach here");
 return 0;
}
/**
 * Calculation helper function for random_value structs
 */
int randcalc(random_value v, int level, aspect rand_aspect)
{
 if (rand_aspect == EXTREMIFY) {
  int min = randcalc(v, level, MINIMISE);
  int max = randcalc(v, level, MAXIMISE);
  return abs(min) > abs(max) ? min : max;
 } else {
  int dmg = damcalc(v.dice, v.sides, rand_aspect);
  int bonus = m_bonus_calc(v.m_bonus, level, rand_aspect);
  return v.base + dmg + bonus;
 }
}
/**
 * Test to see if a value is within a random_value's range
 */
bool randcalc_valid(random_value v, int test)
{
 if (test < randcalc(v, 0, MINIMISE))
  return false;
 else if (test > randcalc(v, 0, MAXIMISE))
  return false;
 else
  return true;
}
/**
 * Test to see if a random_value actually varies
 */
bool randcalc_varies(random_value v)
{
 return randcalc(v, 0, MINIMISE) != randcalc(v, 0, MAXIMISE);
}
/**
 * Roll on a random chance and check for success.
 *
 * \param c The random_chance to roll on
 */
bool random_chance_check(random_chance c)
{
 /* Calculated so that high rolls pass the check */
 return randint0(c.denominator) >= c.denominator - c.numerator;
}
/**
 * Scales a random chance to use the denominator provided in the scale argument
 * and returns the appropriate numerator. For example, a chance of 7 / 13 (53.8%)
 * with scale 100 would be 53. For extra integer precision, a scale of 1000 would
 * yield 538.
 *
 * \param c The random_chance to scale
 * \param scale The scale by which the ratio is multiplied
 */
int random_chance_scaled(random_chance c, int scale)
{
 return scale * c.numerator / c.denominator;
}
/**
 * Cause the output from Rand_div() to be fixed rather than random.
 *
 * \param val Is the percent of the maximum value that Rand_div() will
 * return.  val should be between 0 and 100, inclusive.
 */
void rand_fix(uint32_t val)
{
 rand_fixed = true;
 rand_fixval = val;
}
/**
 * Another simple RNG that does not use any of the above state
 * (so can be used without disturbing the game's RNG state)
 */
uint32_t Rand_simple(uint32_t m)
{
 static time_t seed;
 time_t v = time(NULL);
 seed = ((seed % m) * 1103515245 + 12345) + ((v << 16) ^ v ^ getpid());
 return (seed % m);
}
/**
 * \file z-textblock.c
 * \brief Text output bugger (?NRM) code
 *
 * Copyright (c) 2010 Andi Sidwell
 * Copyright (c) 2011 Peter Denison
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/**
 * Text blocks now use the internal representation of display characters, i.e.
 * wchar_t, since they are expected to display straight to screen. Conversion
 * from the incoming locale-encoded format is done in textblock_vappend_c().
 */
struct textblock {
 wchar_t *text;
 int *attrs;
 size_t strlen;
 size_t size;
};
/**
 * Create a new textblock object and return it.
 */
textblock *textblock_new(void)
{
 textblock *tb = mem_zalloc(sizeof *tb);
 tb->size = 128;
 tb->text = mem_zalloc(tb->size * sizeof(*tb->text));
 tb->attrs = mem_zalloc(tb->size * sizeof(*tb->attrs));
 return tb;
}
/**
 * Free a textblock object.
 */
void textblock_free(textblock *tb)
{
 mem_free(tb->text);
 mem_free(tb->attrs);
 mem_free(tb);
}
/**
 * Resize the internal textblock storage (if needed) to hold additional
 * characters.
 *
 * \param tb is the textblock we need to resize.
 * \param additional_size is how many characters we want to add.
 */
static void textblock_resize_if_needed(textblock *tb, size_t additional_size)
{
 size_t remaining = tb->size - tb->strlen;
 /* If we need more room, reallocate it */
 if (remaining < additional_size) {
  tb->size = ((tb->strlen + additional_size) + 128);
  tb->text = mem_realloc(tb->text, tb->size * sizeof(*tb->text));
  tb->attrs = mem_realloc(tb->attrs, tb->size
   * sizeof(*tb->attrs));
 }
}
static void textblock_vappend_c(textblock *tb, int attr, const char *fmt,
  va_list vp)
{
 size_t temp_len = 128;
 char *temp_space = mem_zalloc(temp_len);
 int new_length, i;
 /* We have to format the incoming string in native (external) format
	 * re-allocating the temporary space as necessary. Once it's been
	 * successfully formatted, we can then do the conversion to wide chars
	 */
 while (1) {
  va_list args;
  size_t len;
  va_copy(args, vp);
  len = vstrnfmt(temp_space, temp_len, fmt, args);
  va_end(args);
  if (len < temp_len - 1) {
   /* Not using all space, therefore it completed */
   break;
  }
  temp_len = ((temp_len) + 128);
  temp_space = mem_realloc(temp_space, temp_len * sizeof *temp_space);
 }
 /* Get extent of addition in wide chars */
 new_length = text_mbstowcs(NULL, temp_space, 0);
 assert(new_length >= 0); /* If this fails, the string was badly formed */
 textblock_resize_if_needed(tb, new_length + 1);
 /* Convert to wide chars, into the text block buffer */
 text_mbstowcs(tb->text + tb->strlen, temp_space, tb->size - tb->strlen);
 for (i = 0; i < new_length; ++i) {
  tb->attrs[i + tb->strlen] = attr;
 }
 tb->strlen += new_length;
 mem_free(temp_space);
}
/**
 * Add a graphics tile to a text block.
 */
void textblock_append_pict(textblock *tb, int attr, int c)
{
 textblock_resize_if_needed(tb, 1);
 tb->text[tb->strlen] = (wchar_t)c;
 tb->attrs[tb->strlen] = attr;
 tb->strlen += 1;
}
/**
 * Append one textblock to another.
 *
 * \param tb is the textblock we are appending to.
 * \param tba is the textblock to append.
 */
void textblock_append_textblock(textblock *tb, const textblock *tba)
{
 textblock_resize_if_needed(tb, tba->strlen);
 (void) memcpy(tb->text + tb->strlen, tba->text,
  tba->strlen * sizeof(*tb->text));
 (void) memcpy(tb->attrs + tb->strlen, tba->attrs,
  tba->strlen * sizeof(*tb->attrs));
 tb->strlen += tba->strlen;
}
/**
 * Add text to a text block, formatted.
 */
void textblock_append(textblock *tb, const char *fmt, ...)
{
 va_list vp;
 va_start(vp, fmt);
 textblock_vappend_c(tb, COLOUR_WHITE, fmt, vp);
 va_end(vp);
}
/**
 * Add coloured text to a text block, formatted.
 */
void textblock_append_c(textblock *tb, int attr, const char *fmt, ...)
{
 va_list vp;
 va_start(vp, fmt);
 textblock_vappend_c(tb, attr, fmt, vp);
 va_end(vp);
}
/**
 * Return a pointer to the text inputted thus far.
 */
const wchar_t *textblock_text(textblock *tb)
{
 return tb->text;
}
/**
 * Return a pointer to the text attrs.
 */
const int *textblock_attrs(textblock *tb)
{
 return tb->attrs;
}
static void new_line(size_t **line_starts, size_t **line_lengths,
  size_t *n_lines, size_t *cur_line,
  size_t start, size_t len)
{
 if (*cur_line == *n_lines) {
  /* this number is not arbitrary: it's the height of a "standard" term */
  (*n_lines) += 24;
  *line_starts = mem_realloc(*line_starts,
    *n_lines * sizeof **line_starts);
  *line_lengths = mem_realloc(*line_lengths,
    *n_lines * sizeof **line_lengths);
 }
 (*line_starts)[*cur_line] = start;
 (*line_lengths)[*cur_line] = len;
 (*cur_line)++;
}
/**
 * Given a certain width, split a textblock into wrapped lines of text. Trailing
 * empty lines are trimmed.
 *
 * \param tb The textblock to wrap.
 * \param line_starts On return, an array (indexed by line number) of character
 *		  indexes to the text of \c tb where each line begins.
 * \param line_lengths On return, an array (indexed by line number) of line
 *		  lengths.
 * \param width The maximum permitted width of each line.
 * \return Number of lines in output.
 */
size_t textblock_calculate_lines(textblock *tb, size_t **line_starts, size_t **line_lengths, size_t width)
{
 const wchar_t *text = NULL;
 size_t text_offset = 0;
 size_t alloc_lines = 0;
 size_t total_lines = 0;
 size_t current_line_index = 0;
 size_t current_line_length = 0;
 size_t breaking_char_offset = 0;
 if (tb == NULL || line_starts == NULL || line_lengths == NULL || width == 0)
  return 0;
 text = textblock_text(tb);
 if (text == NULL || tb->strlen == 0)
  return 0;
 /* Start a line, since we have at least one. */
 new_line(line_starts, line_lengths, &alloc_lines, &total_lines, 0, 0);
 while (text_offset < tb->strlen) {
  if (text[text_offset] == L'\n') {
   (*line_lengths)[current_line_index] = current_line_length;
   new_line(line_starts, line_lengths, &alloc_lines, &total_lines, text_offset + 1, 0);
   current_line_index++;
   current_line_length = 0;
  }
  else if (text[text_offset] == L' ') {
   breaking_char_offset = text_offset;
   current_line_length++;
  }
  else {
   current_line_length++;
  }
  if (current_line_length == width) {
   /* We're out of space on the line and need to break it. */
   size_t const current_line_start = (*line_starts)[current_line_index];
   size_t next_line_start_offset = 0;
   size_t adjusted_line_length = 0;
   if (breaking_char_offset > current_line_start) {
    /* If we found a breaking character on the current line, break
				 * there and start the next line on the next character. The loop
				 * then backtracks to add the already-processed characters to
				 * the next line. */
    adjusted_line_length = breaking_char_offset - current_line_start;
    next_line_start_offset = breaking_char_offset + 1;
    text_offset = breaking_char_offset + 1;
   }
   else {
    /* There was no breaking character on the current line, so we
				 * just break at the current character. This can happen with a 
				 * word that takes up the whole line, for example. */
    adjusted_line_length = width;
    next_line_start_offset = text_offset + 1;
    text_offset++;
   }
   (*line_lengths)[current_line_index] = adjusted_line_length;
   new_line(line_starts, line_lengths, &alloc_lines, &total_lines, next_line_start_offset, 0);
   current_line_index++;
   current_line_length = 0;
  }
  else {
   /* There is still space on the line, so just add the character. */
   (*line_lengths)[current_line_index] = current_line_length;
   text_offset++;
  }
 }
 /* Trim the last line if it doesn't contain any characters. */
 if ((*line_lengths)[total_lines - 1] == 0)
  total_lines--;
 return total_lines;
}
/**
 * Output a textblock to file.
 */
void textblock_to_file(textblock *tb, ang_file *f, int indent, int wrap_at)
{
 size_t *line_starts = NULL;
 size_t *line_lengths = NULL;
 size_t n_lines, i, j;
 char *mbbuf;
 int width = wrap_at - indent;
 assert(width > 0);
 n_lines = textblock_calculate_lines(tb, &line_starts, &line_lengths, width);
 mbbuf = mem_alloc(text_wcsz() + 1);
 for (i = 0; i < n_lines; i++) {
  if (indent > 0) {
   file_putf(f, "%*c", indent, ' ');
  }
  for (j = 0; j < line_lengths[i]; ++j) {
   int nc = text_wctomb(mbbuf,
    tb->text[line_starts[i] + j]);
   if (nc > 0) {
    mbbuf[nc] = 0;
   } else {
    mbbuf[0] = ' ';
    mbbuf[1] = 0;
   }
   file_putf(f, "%s", mbbuf);
  }
  file_putf(f, "\n");
 }
 mem_free(mbbuf);
 mem_free(line_starts);
 mem_free(line_lengths);
}
/**
 * ------------------------------------------------------------------------
 * text_out()
 * ------------------------------------------------------------------------ */
/**
 * Function hook to output (colored) text to the screen or to a file.
 */
void (*text_out_hook)(int a, const char *str);
/**
 * Hack -- Where to wrap the text when using text_out().  Use the default
 * value (for example the screen width) when 'text_out_wrap' is 0.
 */
int text_out_wrap = 0;
/**
 * Hack -- Indentation for the text when using text_out().
 */
int text_out_indent = 0;
/**
 * Hack -- Padding after wrapping
 */
int text_out_pad = 0;
/**
 * Hack - the destination file for text_out_to_file.
 */
ang_file *text_out_file = NULL;
/**
 * Write text to the given file and apply line-wrapping.
 *
 * Hook function for text_out(). Make sure that text_out_file points
 * to an open text-file.
 *
 * Long lines will be wrapped at text_out_wrap, or at column 75 if that
 * is not set; or at a newline character.  Note that punctuation can
 * sometimes be placed one column beyond the wrap limit.
 *
 * You must be careful to end all file output with a newline character
 * to "flush" the stored line position.
 */
void text_out_to_file(int a, const char *str)
{
 const char *s;
 char buf[1024];
 /* Current position on the line */
 static int pos = 0;
 /* Wrap width */
 int wrap = (text_out_wrap ? text_out_wrap : 75);
 /* Unused parameter */
 (void)a;
 /* Copy to a rewriteable string */
  my_strcpy(buf, str, 1024);
 /* Current location within "buf" */
  s = buf;
 /* Process the string */
 while (*s) {
  int n = 0;
  int len = wrap - pos;
  int l_space = -1;
  /* In case we are already past the wrap point (which can happen with
		 * punctuation at the end of the line), make sure we don't overrun.
		 */
  if (len < 0)
   len = 0;
  /* If we are at the start of the line... */
  if (pos == 0) {
   int i;
   /* Output the indent */
   for (i = 0; i < text_out_indent; i++) {
    file_writec(text_out_file, ' ');
    pos++;
   }
  }
  /* Find length of line up to next newline or end-of-string */
  while ((n < len) && !((s[n] == '\n') || (s[n] == '\0'))) {
   /* Mark the most recent space in the string */
   if (s[n] == ' ') l_space = n;
   /* Increment */
   n++;
  }
  /* If we have encountered no spaces */
  if ((l_space == -1) && (n == len)) {
   /* If we are at the start of a new line */
   if (pos == text_out_indent) {
    len = n;
   } else if ((s[0] == ' ') || (s[0] == ',') || (s[0] == '.')) {
    /* HACK - Output punctuation at the end of the line */
    len = 1;
   } else {
    /* Begin a new line */
    file_writec(text_out_file, '\n');
    /* Reset */
    pos = 0;
    continue;
   }
  } else {
   /* Wrap at the newline */
   if ((s[n] == '\n') || (s[n] == '\0')) len = n;
   /* Wrap at the last space */
   else len = l_space;
  }
  /* Write that line to file */
  file_write(text_out_file, s, len);
  pos += len;
  /* Move 's' past the stuff we've written */
  s += len;
  /* If we are at the end of the string, end */
  if (*s == '\0') return;
  /* Skip newlines */
  if (*s == '\n') s++;
  /* Begin a new line */
  file_writec(text_out_file, '\n');
  /* Reset */
  pos = 0;
  /* Skip whitespace */
  while (*s == ' ') s++;
 }
 /* We are done */
 return;
}
/**
 * Output text to the screen or to a file depending on the selected
 * text_out hook.
 */
void text_out(const char *fmt, ...)
{
 char buf[1024];
 va_list vp;
 /* Begin the Varargs Stuff */
 va_start(vp, fmt);
 /* Do the va_arg fmt to the buffer */
 (void)vstrnfmt(buf, sizeof(buf), fmt, vp);
 /* End the Varargs Stuff */
 va_end(vp);
 /* Output now */
 text_out_hook(COLOUR_WHITE, buf);
}
/**
 * Output text to the screen (in color) or to a file depending on the
 * selected hook.
 */
void text_out_c(int a, const char *fmt, ...)
{
 char buf[1024];
 va_list vp;
 /* Begin the Varargs Stuff */
 va_start(vp, fmt);
 /* Do the va_arg fmt to the buffer */
 (void)vstrnfmt(buf, sizeof(buf), fmt, vp);
 /* End the Varargs Stuff */
 va_end(vp);
 /* Output now */
 text_out_hook(a, buf);
}
/**
 * Given a "formatted" chunk of text (i.e. one including tags like {red}{/})
 * in 'source', with starting point 'init', this finds the next section of
 * text and any tag that goes with it, return true if it finds something to 
 * print.
 * 
 * If it returns true, then it also fills 'text' with a pointer to the start
 * of the next printable section of text, and 'len' with the length of that 
 * text, and 'end' with a pointer to the start of the next section.  This
 * may differ from "text + len" because of the presence of tags.  If a tag
 * applies to the section of text, it returns a pointer to the start of that
 * tag in 'tag' and the length in 'taglen'.  Otherwise, 'tag' is filled with
 * NULL.
 *
 * See text_out_e for an example of its use.
 */
static bool next_section(const char *source, size_t init, const char **text,
       size_t *len, const char **tag, size_t *taglen,
       const char **end)
{
 const char *next;
 *tag = NULL;
 *text = source + init;
 if (*text[0] == '\0') return false;
 next = strchr(*text, '{');
 while (next)
 {
  const char *s = next + 1;
  while (*s && (isalpha((unsigned char) *s) ||
       isspace((unsigned char) *s)))
   s++;
  /* Woo!  valid opening tag thing */
  if (*s == '}') {
   const char *close = strstr(s, "{/}");
   /* There's a closing thing, so it's valid. */
   if (close) {
    /* If this tag is at the start of the fragment */
    if (next == *text) {
     *tag = *text + 1;
     *taglen = s - *text - 1;
     *text = s + 1;
     *len = close - *text;
     *end = close + 3;
     return true;
    } else {
     /* Otherwise return the chunk up to this */
     *len = next - *text;
     *end = *text + *len;
     return true;
    }
   } else {
    /* No closing thing, therefore all one lump of text. */
    *len = strlen(*text);
    *end = *text + *len;
    return true;
   }
  } else if (*s == '\0') {
   /* End of the string, that's fine. */
   *len = strlen(*text);
   *end = *text + *len;
   return true;
  } else {
   /* An invalid tag, skip it. */
   next = next + 1;
  }
  next = strchr(next, '{');
 }
 /* Default to the rest of the string */
 *len = strlen(*text);
 *end = *text + *len;
 return true;
}
/**
 * Output text to the screen or to a file depending on the
 * selected hook.  Takes strings with "embedded formatting",
 * such that something within {red}{/} will be printed in red.
 *
 * Note that such formatting will be treated as a "breakpoint"
 * for the printing, so if used within words may lead to part of the
 * word being moved to the next line.
 */
void text_out_e(const char *fmt, ...)
{
 char buf[1024];
 char smallbuf[1024];
 va_list vp;
 const char *start, *next, *text, *tag;
 size_t textlen, taglen = 0;
 /* Begin the Varargs Stuff */
 va_start(vp, fmt);
 /* Do the va_arg fmt to the buffer */
 (void)vstrnfmt(buf, sizeof(buf), fmt, vp);
 /* End the Varargs Stuff */
 va_end(vp);
 start = buf;
 while (next_section(start, 0, &text, &textlen, &tag, &taglen, &next)) {
  int a = -1;
  memcpy(smallbuf, text, textlen);
  smallbuf[textlen] = 0;
  if (tag) {
   char tagbuffer[16];
   /* Colour names are less than 16 characters long. */
   assert(taglen < 16);
   memcpy(tagbuffer, tag, taglen);
   tagbuffer[taglen] = '\0';
   a = color_text_to_attr(tagbuffer);
  }
  if (a == -1)
   a = COLOUR_WHITE;
  /* Output now */
  text_out_hook(a, smallbuf);
  start = next;
 }
}
/**
 * Write a text file from given input.
 *
 * \param path the path to write to
 * \param writer the text-writing function
 */
errr text_lines_to_file(const char *path, text_writer writer)
{
 char new_fname[1024];
 char old_fname[1024];
 ang_file *new_file;
 /* Format filenames */
 strnfmt(new_fname, sizeof(new_fname), "%s.new", path);
 strnfmt(old_fname, sizeof(old_fname), "%s.old", path);
 /* Write new file */
 new_file = file_open(new_fname, MODE_WRITE, FTYPE_TEXT);
 if (!new_file) {
  return -1;
 }
 text_out_file = new_file;
 writer(new_file);
 text_out_file = NULL;
 file_close(new_file);
 /* Move files around */
 strnfmt(old_fname, sizeof(old_fname), "%s.old", path);
 if (!file_exists(path)) {
  file_move(new_fname, path);
 } else if (file_move(path, old_fname)) {
  file_move(new_fname, path);
  file_delete(old_fname);
 } else {
  file_delete(new_fname);
 }
 return 0;
}
/**
 * \file z-type.c
 * \brief Support various data types.
 *
 * Copyright (c) 2007 Angband Developers
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
struct loc loc(int x, int y) {
 struct loc p;
 p.x = x;
 p.y = y;
 return p;
}
/**
 * Determine if two grid locations are equal
 */
bool loc_eq(struct loc grid1, struct loc grid2)
{
 return (grid1.x == grid2.x) && (grid1.y == grid2.y);
}
/**
 * Determine if a grid location is the (0, 0) location
 */
bool loc_is_zero(struct loc grid)
{
 return loc_eq(grid, loc(0, 0));
}
/**
 * Sum two grid locations
 */
struct loc loc_sum(struct loc grid1, struct loc grid2)
{
 return loc(grid1.x + grid2.x, grid1.y + grid2.y);
}
/**
 * Take the difference of two grid locations
 */
struct loc loc_diff(struct loc grid1, struct loc grid2)
{
 return loc(grid1.x - grid2.x, grid1.y - grid2.y);
}
/**
 * Get a random location with the given x and y centres and spread 
 */
struct loc rand_loc(struct loc grid, int x_spread, int y_spread)
{
 return loc(rand_spread(grid.x, x_spread), rand_spread(grid.y, y_spread));
}
struct loc loc_offset(struct loc grid, int dx, int dy)
{
 return loc(grid.x + dx, grid.y + dy);
}
/**
 * Utility functions to work with point_sets
 */
struct point_set *point_set_new(int initial_size)
{
 struct point_set *ps = mem_alloc(sizeof(struct point_set));
 ps->n = 0;
 ps->allocated = initial_size;
 ps->pts = mem_zalloc(sizeof(*(ps->pts)) * ps->allocated);
 return ps;
}
void point_set_dispose(struct point_set *ps)
{
 mem_free(ps->pts);
 mem_free(ps);
}
/**
 * Add the point to the given point set, making more space if there is
 * no more space left.
 */
void add_to_point_set(struct point_set *ps, struct loc grid)
{
 ps->pts[ps->n] = grid;
 ps->n++;
 if (ps->n >= ps->allocated) {
  ps->allocated *= 2;
  ps->pts = mem_realloc(ps->pts, sizeof(*(ps->pts)) * ps->allocated);
 }
}
int point_set_size(struct point_set *ps)
{
 return ps->n;
}
int point_set_contains(struct point_set *ps, struct loc grid)
{
 int i;
 for (i = 0; i < ps->n; i++)
  if (loc_eq(ps->pts[i], grid))
   return 1;
 return 0;
}
/**
 * \file z-util.c
 * \brief Low-level string handling and other utilities.
 *
 * Copyright (c) 1997-2005 Ben Harrison, Robert Ruehlmann.
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Convenient storage of the program name
 */
char *argv0 = NULL;
/**
 * Hook for platform-specific wide character handling
 */
size_t (*text_mbcs_hook)(wchar_t *dest, const char *src, int n) = NULL;
/**
 * Hook to convert a wide character (in whatever encoding the platform uses)
 * back to a multibyte representation using UTF-8.  Expected to behave like
 * wctomb().
 */
int (*text_wctomb_hook)(char *s, wchar_t wchar) = NULL;
/**
 * Hook to get the maximum number of bytes needed to store a wide character
 * converted to a multibyte representation using UTF-8.
 */
int (*text_wcsz_hook)(void) = NULL;
/**
 * Hook to test whether a given wide character is printable.
 */
int (*text_iswprint_hook)(wint_t wc) = NULL;
/**
 * Count the number of characters in a UTF-8 encoded string
 *
 * Taken from http://canonical.org/~kragen/strlen-utf8.html
 */
size_t utf8_strlen(const char *s)
{
 size_t i = 0, j = 0;
 while (s[i]) {
  if ((s[i] & 0xc0) != 0x80) j++;
  i++;
 }
 return j;
}
/**
 * Clip a null-terminated UTF-8 string 's' to 'n' unicode characters.
 * e.g. utf8_clipto("example", 4) will clip after 'm', resulting in 'exam'.
 */
void utf8_clipto(char *s, size_t n)
{
 size_t i = 0, j = 0;
 bool terminate_next = false;
 if (n == 0) {
  s[i] = 0;
  return;
 }
 while (s[i]) {
  if ((s[i] & 0xc0) != 0x80) {
   j++;
   if (terminate_next)
    break;
   if (j == n)
    terminate_next = true;
  }
  i++;
 }
 s[i] = 0;
}
/**
 * Advance a pointer to a UTF-8 buffer by a given number of Unicode code points.
 * \param s Is the pointer to advance.
 * \param n Is the number of code points to skip over.
 * \param lim If not NULL, is the limit for how far to advance.
 * \return If s could be advanced by n code points before reaching lim (if
 * lim is not NULL) or before reaching the end of the input, the returned
 * value is the incremented pointer.  Otherwise, the returned value is NULL.
 * If n is zero, the return value may be different than s if s does not
 * point to the start of a code point.  In that case, the returned value will
 * point to the start of the next code point.
 */
char *utf8_fskip(char *s, size_t n, char *lim)
{
 while (1) {
  if (*s == 0) {
   /* Reached the end of the input. */
   return (n > 0) ? NULL : s;
  }
  if ((*s & 0xc0) != 0x80) {
   /* It's not marked as a continuation byte. */
   if (n == 0) {
    return s;
   }
   --n;
  }
  if (s == lim) {
   return NULL;
  }
  ++s;
 }
}
/**
 * Decrement a pointer to a UTF-8 buffer by a given number of Unicode code
 * points.
 * \param s Is the pointer to decrement.
 * \param n Is the number of code points to skip over.
 * \param lim Is the limit for how far to backtrack.  Must not be NULL.
 * \return If s could be decremented by n code points before reaching lim,
 * the returned value is the decremented pointer.  Otherwise, the returned
 * value is NULL.  If n is zero, the return value may be different than s
 * if s does not point to the start of a code point.  In that case, the
 * returned valued will be the start of the first code point prior to s or
 * NULL, if the start of a code point could not be found before reaching lim.
 */
char *utf8_rskip(char *s, size_t n, char *lim)
{
 while (1) {
  if ((*s & 0xc0) != 0x80) {
   /* It's not marked as a continuation byte. */
   if (n == 0) {
    return s;
   }
   --n;
  }
  if (s == lim) {
   return NULL;
  }
  --s;
 }
}
/**
 * Convert a sequence of UTF-32 values, in the native byte order, to UTF-8.
 * \param out Is the pointer to the buffer to hold the conversion.
 * \param n_out Is the number of char-sized units that can be placed in out.
 * \param in Is the pointer to the sequence to convert.
 * \param n_in Is the maximum number of values to convert from in.  Conversion
 * will terminate before that if the sequence to convert contains a zero or
 * something that is not a valid Unicode code point (either larger than
 * 0x10FFFF or in the range of 0xD800 to 0xDFFF reserved for surrogate pairs)
 * or if the next value to convert would cause the output buffer to overflow.
 * \param pn_cnvt If not NULL, *pn_cnvt will be set to the number of UTF-32
 * values converted.
 * \return The returned value is the number of char-sized units, excluding
 * the terminating null character, written to out.  The returned value will
 * be less than n_out if n_out is greater than zero.
 */
size_t utf32_to_utf8(char *out, size_t n_out, const uint32_t *in, size_t n_in,
 size_t *pn_cnvt)
{
 size_t nwritten = 0;
 const uint32_t *in_orig = in;
 const uint32_t *in_lim = in + n_in;
 while (1) {
  if (in == in_lim) {
   break;
  }
  if (*in <= 0x7f) {
   /* Encoded as single byte. */
   if (*in == 0) {
    break;
   }
   if (n_out <= 1) {
    break;
   }
   out[nwritten++] = (char) *in;
   --n_out;
  } else if (*in <= 0x7ff) {
   /* Encoded as two bytes. */
   if (n_out <= 2) {
    break;
   }
   out[nwritten++] = 0xc0 + ((*in & 0x7c0) >> 6);
   out[nwritten++] = 0x80 + (*in & 0x3f);
   n_out -= 2;
  } else if (*in <= 0xffff) {
   /* Encoded as three bytes. */
   if (*in >= 0xd800 && *in <= 0xdfff) {
    /*
				 * Those are reserved for UTF-16 surrogate
				 * pairs and should not be encoded.
				 */
    break;
   }
   if (n_out <= 3) {
    break;
   }
   out[nwritten++] = 0xe0 + ((*in & 0xf000) >> 12);
   out[nwritten++] = 0x80 + ((*in & 0xfc0) >> 6);
   out[nwritten++] = 0x80 + (*in & 0x3f);
   n_out -= 3;
  } else if (*in <= 0x10ffff) {
   /*
			 * Encoded as four bytes.  The upper limit of 0x10ffff
			 * is imposed by the limits of UTF-16.  Without that,
			 * the four byte encoding can handle values up to
			 * 0x1fffff.
			 */
   if (n_out <= 4) {
    break;
   }
   out[nwritten++] = 0xf0 + ((*in & 0x1c0000) >> 18);
   out[nwritten++] = 0x80 + ((*in & 0x3f000) >> 12);
   out[nwritten++] = 0x80 + ((*in & 0xfc0) >> 6);
   out[nwritten++] = 0x80 + (*in & 0x3f);
   n_out -= 4;
  } else {
   break;
  }
  ++in;
 }
 if (n_out > 0) {
  out[nwritten] = 0;
 }
 if (pn_cnvt) {
  *pn_cnvt = in - in_orig;
 }
 return nwritten;
}
/**
 * Return whether a given UTF-32 value corresponds to a printable character.
 *
 * The similar standard library functions are isprint() and iswprint().
 * Choose not to use those because both depend on the locale and only want
 * to use the locale when converting a keyboard event to a keycode and when
 * converting internally stored text to a final form for display.  Between
 * those two points, use fixed encodings:  UTF-32 for single keycodes and
 * UTF-8 for bulk storage of text.  Also, isprint() is, in general, limited
 * to distinguishing 8 bits, and the wchar_t for iswprint() is, at least on
 * Windows, a 16-bit type.
 */
bool utf32_isprint(uint32_t v)
{
 /* Switch based on the plane (each plane has 2^16 code points). */
        switch ((v & 0xff0000) >> 16) {
        case 0:
                /* Is the basic multilingual plane.  Most things are here. */
                switch ((v & 0xff00) >> 8) {
                case 0:
                        /*
                         * C0 control characters, DEL, and C1 controls are
                         * not printable.
                         */
                        if (v <= 0x1f || (v >= 0x7f && v <= 0x9f)) {
                                return false;
                        }
                        break;
                case 0xd8:
                case 0xd9:
                case 0xda:
                case 0xdb:
                case 0xdc:
                case 0xdd:
                case 0xde:
                case 0xdf:
                        /* Used for surrogate pairs in UTF-16. */
                        return false;
                case 0xfd:
                        /*
                         * Part of the arabic presentation forms-a block is
                         * guaranteed to not be used for characters.
                         */
                        if (v >= 0xfdd0 && v <= 0xfdef) {
                                return false;
                        }
                        break;
                case 0xfe:
                        /*
                         * The variation selectors indicate how to present a
                         * preceding character.  Treat as not printable.
                         * Also exclude the byte-order mark, 0xfeff.
                         */
                        if ((v & 0xfff0) == 0xfe00 || v == 0xfeff) {
                                return false;
                        }
                        break;
                case 0xff:
                        /* Interlinear annotation marks are not printable. */
                        if (v >= 0xfff9 && v <= 0xfffb) {
                                return false;
                        }
                        break;
                default:
                        /* Do no special casing for the rest. */
                        break;
                }
                break;
        case 1:
                /* Is the supplemental multilingual plane. */
        case 2:
                /* Is the supplmental ideographic plane. */
        case 3:
                /* Is the tertiary ideographic plane. */
                /* Assume no no special casing for those planes. */
                break;
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
                /*
                 * Those planes are currently unassigned.  Assume unprintable.
                 */
                return false;
        case 14:
                /*
                 * Is the supplemental special-purpose plane.  Used for tags
                 * to modify a preceding character or to indicate a variant
                 * form of an ideograph.  Assume all are unprintable.
                 */
                return false;
        case 15:
        case 16:
                /*
                 * These are private use planes.  Assume that no special
                 * cases are necessary.
                 */
                break;
        default:
                /* Is not a valid Unicode code point. */
                return false;
        }
        /*
         * Assume printable unless it is xxfffe or xxffff which are guaranteed
         * to not be characters (i.e. the code points in the basic multilingual
         * plane used as byte-order marks).
         */
        return ((v & 0xfffe) != 0xfffe);
}
/**
 * Case insensitive comparison between two strings
 */
int my_stricmp(const char *s1, const char *s2)
{
 char ch1 = 0;
 char ch2 = 0;
 /* Just loop */
 while (true) {
  /* We've reached the end of both strings simultaneously */
  if ((*s1 == 0) && (*s2 == 0)) {
   /* We're still here, so s1 and s2 are equal */
   return (0);
  }
  ch1 = toupper((unsigned char) *s1);
  ch2 = toupper((unsigned char) *s2);
  /* If the characters don't match */
  if (ch1 != ch2) {
   /* return the difference between them */
   return ((int)(ch1 - ch2));
  }
  /* Step on through both strings */
  s1++;
  s2++;
 }
}
/**
 * Case insensitive comparison between the first n characters of two strings
 */
int my_strnicmp(const char *a, const char *b, int n)
{
 const char *s1, *s2;
 char z1, z2;
 /* Scan the strings */
 for (s1 = a, s2 = b; n > 0; s1++, s2++, n--) {
  z1 = toupper((unsigned char)*s1);
  z2 = toupper((unsigned char)*s2);
  if (z1 < z2) return (-1);
  if (z1 > z2) return (1);
  if (!z1) return (0);
 }
 return 0;
}
/**
 * An ANSI version of strstr() with case insensitivity.
 *
 * In the public domain; found at:
 *    http://c.snippets.org/code/stristr.c
 */
char *my_stristr(const char *string, const char *pattern)
{
 const char *pptr, *sptr;
 char *start;
 for (start = (char *)string; *start != 0; start++) {
  /* Find start of pattern in string */
  for ( ; ((*start != 0) && (toupper((unsigned char)*start) != toupper((unsigned char)*pattern))); start++)
   ;
  if (*start == 0)
   return NULL;
  pptr = (const char *)pattern;
  sptr = (const char *)start;
  while (toupper((unsigned char)*sptr) == toupper((unsigned char)*pptr)) {
   sptr++;
   pptr++;
   /* If end of pattern then pattern was found */
   if (*pptr == 0)
    return (start);
  }
 }
 return NULL;
}
/**
 * The my_strcpy() function copies up to 'bufsize'-1 characters from 'src'
 * to 'buf' and NUL-terminates the result.  The 'buf' and 'src' strings may
 * not overlap.
 *
 * my_strcpy() returns strlen(src).  This makes checking for truncation
 * easy.  Example: if (my_strcpy(buf, src, sizeof(buf)) >= sizeof(buf)) ...;
 *
 * This function should be equivalent to the strlcpy() function in BSD.
 */
size_t my_strcpy(char *buf, const char *src, size_t bufsize)
{
 size_t len = strlen(src);
 size_t ret = len;
 /* Paranoia */
 if (bufsize == 0) return ret;
 /* Truncate */
 if (len >= bufsize) len = bufsize - 1;
 /* Copy the string and terminate it */
 (void)memcpy(buf, src, len);
 buf[len] = '\0';
 /* Return strlen(src) */
 return ret;
}
/**
 * The my_strcat() tries to append a string to an existing NUL-terminated
 * string.
 * It never writes more characters into the buffer than indicated by 'bufsize'
 * and NUL-terminates the buffer.  The 'buf' and 'src' strings may not overlap.
 *
 * my_strcat() returns strlen(buf) + strlen(src).  This makes checking for
 * truncation easy.  Example:
 * if (my_strcat(buf, src, sizeof(buf)) >= sizeof(buf)) ...;
 *
 * This function should be equivalent to the strlcat() function in BSD.
 */
size_t my_strcat(char *buf, const char *src, size_t bufsize)
{
 size_t dlen = strlen(buf);
 /* Is there room left in the buffer? */
 if (dlen + 1 < bufsize) {
  /* Append as much as possible  */
  return (dlen + my_strcpy(buf + dlen, src, bufsize - dlen));
 } else {
  /* Return without appending */
  return (dlen + strlen(src));
 }
}
/**
 * Capitalise the first letter of string 'str'.
 */
void my_strcap(char *buf)
{
 if (buf && buf[0])
  buf[0] = toupper((unsigned char) buf[0]);
}
/**
 * Determine if string "a" is equal to string "b"
 */
#undef streq
bool streq(const char *a, const char *b)
{
 return (!strcmp(a, b));
}
/**
 * Determine if string "t" is a suffix of string "s"
 */
bool suffix(const char *s, const char *t)
{
 size_t tlen = strlen(t);
 size_t slen = strlen(s);
 /* Check for incompatible lengths */
 if (tlen > slen) return (false);
 /* Compare "t" to the end of "s" */
 return (!strcmp(s + slen - tlen, t));
}
/**
 * Determine if string "t" is a suffix of string "s" - case insensitive
 */
bool suffix_i(const char *s, const char *t)
{
 size_t tlen = strlen(t);
 size_t slen = strlen(s);
 /* Check for incompatible lengths */
 if (tlen > slen) return (false);
 /* Compare "t" to the end of "s" */
 return !my_stricmp(s + slen - tlen, t);
}
/**
 * Determine if string "t" is a prefix of string "s"
 */
bool prefix(const char *s, const char *t)
{
 /* Scan "t" */
 while (*t)
 {
  /* Compare content and length */
  if (*t++ != *s++) return (false);
 }
 /* Matched, we have a prefix */
 return (true);
}
/**
 * Determine if string "t" is a prefix of string "s" - case insensitive.
 */
bool prefix_i(const char *s, const char *t)
{
 /* Scan "t" */
 while (*t)
 {
  if (toupper((unsigned char)*t) != toupper((unsigned char)*s))
   return (false);
  else
  {
   t++;
   s++;
  }
 }
 /* Matched, we have a prefix */
 return (true);
}
/**
 * Rewrite string s in-place "skipping" every occurrence of character c except
 * those preceded by character e
 */
void strskip(char *s, const char c, const char e) {
 char *in = s;
 char *out = s;
 bool escapeseen = false;
 while (*in) {
  if ((*in != c) && ((*in != e) || escapeseen)) {
   if (escapeseen) {
    /* Not escaping anything */
    *out = e;
    out++;
   }
   *out = *in;
   out++;
   escapeseen = false;
  } else if (*in == e) {
   /* Maybe escaping something */
   escapeseen = true;
  } else if (escapeseen) {
   /* Add the escaped character */
   *out = *in;
   out++;
   escapeseen = false;
  }
  in++;
 }
 *out = 0;
}
/**
 * Rewrite string s in-place removing escape character c
 * note that pairs of c will leave one instance of c in out
 */
void strescape(char *s, const char c) {
 char *in = s;
 char *out = s;
 bool escapenext = false;
 while (*in) {
  if (*in != c || escapenext) {
   *out = *in;
   out++;
   escapenext = false;
  } else if (*in == c) {
   escapenext = true;
  }
  in++;
 }
 *out = 0;
}
/**
 * Gives the integer value of a hexadecimal character
 * Returns -1 if invalid
 */
static int hex_char_to_int(char c) {
 if ((c >= '0') && (c <= '9'))
  return c - '0';
 if ((c >= 'A') && (c <= 'F'))
  return c - 'A' + 10;
 if ((c >= 'a') && (c <= 'f'))
  return c - 'a' + 10;
 return -1;
}
/**
 * Gives the integer value of a hexadecimal string
 * hex_str_to_int("4A") returns 74 == 0x4A
 * Returns -1 if invalid
 */
int hex_str_to_int(const char *s) {
 int result = 0;
 while (*s) {
  int current = hex_char_to_int(*s);
  if (current == -1)
   return -1;
  result *= 16;
  result += current;
  ++s;
 }
 return result;
}
/**
 * Rewrite string s in-place, replacing encoded representations of escaped characters
 * ("\\r", etc.) with their literal character counterparts.
 * This does only handle escape sequences visible on the ascii manpage (and "\e" and "\x").
 */
void strunescape(char *s) {
 char *in = s;
 char *out = s;
 bool unescapenext = false;
 while (*in) {
  if (unescapenext) {
   unescapenext = false;
   switch (*in) {
   case '0':
    *out++ = '\0';
    break;
   case 'a':
    *out++ = '\a';
    break;
   case 'b':
    *out++ = '\b';
    break;
   case 't':
    *out++ = '\t';
    break;
   case 'n':
    *out++ = '\n';
    break;
   case 'v':
    *out++ = '\v';
    break;
   case 'f':
    *out++ = '\f';
    break;
   case 'r':
    *out++ = '\r';
    break;
   case '\\':
    *out++ = '\\';
    break;
   case 'e':
    *out++ = '\x1B';
    break;
   case 'x': {
    char hex[3];
    if (*++in == 0) {
     /* Add back the unmodified sequence */
     *out++ = '\\';
     *out++ = 'x';
     continue;
    }
    hex[0] = *in;
    if (*++in == 0) {
     /* Add back the unmodified sequence */
     *out++ = '\\';
     *out++ = 'x';
     *out++ = hex[0];
     continue;
    }
    hex[1] = *in;
    hex[2] = 0;
    int result = hex_str_to_int(hex);
    if (result == -1) {
     /* Add back the unmodified sequence */
     *out++ = '\\';
     *out++ = 'x';
     *out++ = hex[0];
     *out++ = hex[1];
    }
    *out++ = result;
    break;
    }
   default:
    /* Add back the unmodified sequence */
    *out++ = '\\';
    *out++ = *in;
    break;
   }
   in++;
   continue;
  }
  if (*in == '\\') {
   unescapenext = true;
   in++;
   continue;
  }
  *out++ = *in++;
 }
 *out = 0;
}
/**
 * returns true if string only contains spaces
 */
bool contains_only_spaces(const char* s){
 const char spaces[]=" \t";
 size_t nsp = strspn(s, spaces);
 return s[nsp] == '\0';
}
/**
 * Check a char for "vowel-hood"
 */
bool is_a_vowel(int ch)
{
 switch (tolower((unsigned char) ch))
 {
  case 'a':
  case 'e':
  case 'i':
  case 'o':
  case 'u':
  {
   return (true);
  }
 }
 return (false);
}
/**
 * Allow override of the multi-byte to wide char conversion
 */
size_t text_mbstowcs(wchar_t *dest, const char *src, int n)
{
 if (text_mbcs_hook)
  return (*text_mbcs_hook)(dest, src, n);
 else
  return mbstowcs(dest, src, n);
}
/**
 * Convert a wide character to a multibyte representation.
 * \param s Points to a buffer to hold the converted result.  That buffer must
 * have at least text_wcsz() bytes.  With the exception of the case where wchar
 * is 0, the contents written to the buffer will not be null terminated.
 * \param wchar Is the wide character to convert.
 * \return The returned value is the number of bytes in the converted character
 * or -1 if the character could not be recognized and converted.
 */
int text_wctomb(char *s, wchar_t wchar)
{
 return (text_wctomb_hook) ?
  (*text_wctomb_hook)(s, wchar) : wctomb(s, wchar);
}
/**
 * Get the maximum size to store a wide character converted to multibyte.
 */
int text_wcsz(void)
{
 return (text_wcsz_hook) ? (*text_wcsz_hook)() : MB_LEN_MAX;
}
/**
 * Return whether the given wide character is printable.
 */
int text_iswprint(wint_t wc)
{
 return (text_iswprint_hook) ? (*text_iswprint_hook)(wc) : iswprint(wc);
}
/**
 * Redefinable "plog" action
 */
void (*plog_aux)(const char *) = NULL;
/*
 * Print (or log) a "warning" message (ala "perror()")
 * Note the use of the (optional) "plog_aux" hook.
 */
void plog(const char *str)
{
 /* Use the "alternative" function if possible */
 if (plog_aux) (*plog_aux)(str);
 /* Just do a labeled fprintf to stderr */
 else (void)(fprintf(stderr, "%s: %s\n", argv0 ? argv0 : "?", str));
}
/**
 * Redefinable "quit" action
 */
void (*quit_aux)(const char *) = NULL;
/**
 * Exit (ala "exit()").  If 'str' is NULL, do "exit(EXIT_SUCCESS)".
 * Otherwise, plog() 'str' and exit with an error code of -1.
 * But always use 'quit_aux', if set, before anything else.
 */
void quit(const char *str)
{
 /* Attempt to use the aux function */
 if (quit_aux) (*quit_aux)(str);
 /* Success */
 if (!str) exit(EXIT_SUCCESS);
 /* Send the string to plog() */
 plog(str);
 /* Failure */
 exit(EXIT_FAILURE);
}
/**
 * Arithmetic mean of the first 'size' entries of the array 'nums'
 */
int mean(const int *nums, int size)
{
 int i, total = 0;
 for(i = 0; i < size; i++) total += nums[i];
 return total / size;
}
/**
 * Variance of the first 'size' entries of the array 'nums'
 */
int variance(const int *nums, int size)
{
 int i, avg, total = 0;
 avg = mean(nums, size);
 for(i = 0; i < size; i++)
 {
  int delta = nums[i] - avg;
  total += delta * delta;
 }
 return total / size;
}
void sort(void *base, size_t nmemb, size_t smemb,
   int (*comp)(const void *, const void *))
{
 qsort(base, nmemb, smemb, comp);
}
uint32_t djb2_hash(const char *str)
{
 uint32_t hash = 5381;
 int c = *str;
 while (c)
 {
  hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
  c = *++str;
 }
 return hash;
}
/**
 * \file z-virt.c
 * \brief Memory management routines
 *
 * Copyright (c) 1997 Ben Harrison.
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Allocate `len` bytes of memory.
 *
 * Returns:
 *  - NULL if `len` == 0; or
 *  - a pointer to a block of memory of at least `len` bytes
 *
 * Doesn't return on out of memory.
 */
void *mem_alloc(size_t len)
{
 /* Note: standard malloc(3) returns a non-null pointer if passed
	 * a length of 0. Not quite sure why Angband's wrapper has this
	 * behavior. */
 if (!len)
  return NULL;
 void *p = malloc(len);
 if (!p)
  quit("Out of memory!");
 return p;
}
void *mem_zalloc(size_t len)
{
 void *mem = mem_alloc(len);
 if (len)
  memset(mem, 0, len);
 return mem;
}
void mem_free(void *p)
{
 free(p);
}
void *mem_realloc(void *p, size_t len)
{
 /* Note: standard realloc(3) frees if passed a size of 0, so this
	 * wrapper has different behavior. */
 if (!len)
  return NULL;
 p = realloc(p, len);
 if (!p)
  quit("Out of Memory!");
 return p;
}
/**
 * Duplicates an existing string `str`, allocating as much memory as necessary.
 */
char *string_make(const char *str)
{
 char *res;
 size_t siz;
 /* Error-checking */
 if (!str) return NULL;
 /* Allocate space for the string (including terminator) */
 siz = strlen(str) + 1;
 res = mem_alloc(siz);
 /* Copy the string (with terminator) */
 my_strcpy(res, str, siz);
 return res;
}
void string_free(char *str)
{
 mem_free(str);
}
char *string_append(char *s1, const char *s2)
{
 size_t len;
 if (!s1 && !s2) {
  return NULL;
 } else if (s1 && !s2) {
  return s1;
 } else if (!s1 && s2) {
  return string_make(s2);
 }
 len = strlen(s1);
 s1 = mem_realloc(s1, len + strlen(s2) + 1);
 my_strcpy(s1 + len, s2, strlen(s2) + 1);
 return s1;
}
/**
 * \file main.c
 * \brief Core game initialisation for UNIX (and other) machines
 *
 * Copyright (c) 1997 Ben Harrison, and others
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * locale junk
 */
/**
 * Some machines have a "main()" function in their "main-xxx.c" file,
 * all the others use this file for their "main()" function.
 */
/*
 * On some platforms, SDL2 uses a macro to replace main() with another name
 * to hook into the platform-specific initialization.  Account for that here.
 */
/**
 * List of the available mmodules in the order they are tried.
 */
static const struct module mmodules[] =
{
 { "gcu", help_gcu, init_gcu },
 { "spoil", help_spoil, init_spoil },
};
/**
 * A hook for "quit()".
 *
 * Close down, then fall back into "quit()".
 */
static void quit_hook(const char *s)
{
 int j;
 /* Unused parameter */
 (void)s;
 /* Scan windows */
 for (j = ANGBAND_TERM_MAX - 1; j >= 0; j--) {
  /* Unused */
  if (!angband_term[j]) continue;
  /* Nuke it */
  term_nuke(angband_term[j]);
 }
}
/**
 * Initialize and verify the file paths, and the score file.
 *
 * Use the configured DEFAULT_*_PATH constants.  Be sure to
 * set those properly when building...
 *
 * We must ensure that the path ends with "PATH_SEP" if needed,
 * since the "init_file_paths()" function will simply append the
 * relevant "sub-directory names" to the given path.
 *
 * Make sure that the path doesn't overflow the buffer.  We have
 * to leave enough space for the path separator, directory, and
 * filenames.
 */
static void init_stuff(void)
{
 char configpath[512];
 char libpath[512];
 char datapath[512];
 /* Use the angband_path, or a default */
 my_strcpy(configpath, DEFAULT_CONFIG_PATH, sizeof(configpath));
 my_strcpy(libpath, DEFAULT_LIB_PATH, sizeof(libpath));
 my_strcpy(datapath, DEFAULT_DATA_PATH, sizeof(datapath));
 /* Make sure they're terminated */
 configpath[511] = '\0';
 libpath[511] = '\0';
 datapath[511] = '\0';
 /* Hack -- Add a path separator (only if needed) */
 if (!suffix(configpath, PATH_SEP)) my_strcat(configpath, PATH_SEP,
             sizeof(configpath));
 if (!suffix(libpath, PATH_SEP)) my_strcat(libpath, PATH_SEP,
             sizeof(libpath));
 if (!suffix(datapath, PATH_SEP)) my_strcat(datapath, PATH_SEP,
              sizeof(datapath));
 /* Initialize */
 init_file_paths(configpath, libpath, datapath);
}
/**
 * Perform (as ui-game.c's reinit_hook) platform-specific actions necessary
 * when restarting without exiting.  Also called directly at startup.
 */
static void generic_reinit(void)
{
}
static const struct {
 const char *name;
 char **path;
 bool setgid_ok;
} change_path_values[] = {
 { "scores", &ANGBAND_DIR_SCORES, false },
 { "gamedata", &ANGBAND_DIR_GAMEDATA, true },
 { "screens", &ANGBAND_DIR_SCREENS, true },
 { "help", &ANGBAND_DIR_HELP, true },
 { "pref", &ANGBAND_DIR_CUSTOMIZE, true },
 { "fonts", &ANGBAND_DIR_FONTS, true },
 { "tiles", &ANGBAND_DIR_TILES, true },
 { "sounds", &ANGBAND_DIR_SOUNDS, true },
 { "icons", &ANGBAND_DIR_ICONS, true },
 { "user", &ANGBAND_DIR_USER, true },
 { "save", &ANGBAND_DIR_SAVE, false },
 { "panic", &ANGBAND_DIR_PANIC, false },
 { "archive", &ANGBAND_DIR_ARCHIVE, false },
};
/**
 * Handle a "-d<dir>=<path>" option.
 *
 * Sets any of angband's special directories to <path>.
 *
 * The "<path>" can be any legal path for the given system, and should
 * not end in any special path separator (i.e. "/tmp" or "~/.ang-info").
 */
static void change_path(const char *info)
{
 char *info_copy = NULL;
 char *path = NULL;
 char *dir = NULL;
 unsigned int i = 0;
 char dirpath[512];
 if (!info || !info[0])
  quit_fmt("Try '-d<dir>=<path>'.");
 info_copy = string_make(info);
 path = strtok(info_copy, "=");
 dir = strtok(NULL, "=");
 for (i = 0; i < N_ELEMENTS(change_path_values); i++) {
  if (my_stricmp(path, change_path_values[i].name) == 0) {
   string_free(*change_path_values[i].path);
   *change_path_values[i].path = string_make(dir);
   /* the directory may not exist and may need to be created. */
   path_build(dirpath, sizeof(dirpath), dir, "");
   if (!dir_create(dirpath)) quit_fmt("Cannot create '%s'", dirpath);
   string_free(info_copy);
   return;
  }
 }
 quit_fmt("Unrecognised -d parameter %s", path);
}
/**
 * Find a default user name from the system.
 */
static void user_name(char *buf, size_t len, int id)
{
 struct passwd *pw = getpwuid(id);
 /* Default to PLAYER */
 if (!pw || !pw->pw_name || !pw->pw_name[0] ) {
  my_strcpy(buf, "PLAYER", len);
  return;
 }
 /* Copy and capitalise */
 my_strcpy(buf, pw->pw_name, len);
 my_strcap(buf);
}
/**
 * List all savefiles this player can access.
 */
static void list_saves(void)
{
 savefile_getter g = NULL;
 if (!got_savefile(&g)) {
  bool nodir = !got_savefile_dir(g);
  cleanup_savefile_getter(g);
  if (nodir) {
   quit_fmt("Cannot open savefile directory");
  }
  printf("There are no savefiles you can use.\n");
  return;
 }
 printf("Savefiles you can use are:\n");
 do {
  const struct savefile_details *details =
   get_savefile_details(g);
  if (details->desc) {
   printf(" %-15s  %s\n", details->fnam + details->foff,
    details->desc);
  } else {
   printf(" %-15s\n", details->fnam + details->foff);
  }
 } while (got_savefile(&g));
 printf("\nUse angband -u<name> to use savefile <name>.\n");
 cleanup_savefile_getter(g);
}
/**
 * Simple "main" function for multiple platforms.
 *
 * Note the special "--" option which terminates the processing of
 * standard options.  All non-standard options (if any) are passed
 * directly to the "init_xxx()" function.
 */
int main(int argc, char *argv[])
{
 int i;
 bool new_game = false, select_game = false;
 bool done = false;
 const char *mstr = NULL;
 bool args = true;
 /* Save the "program name" XXX XXX XXX */
 argv0 = argv[0];
 /* Default permissions on files */
 (void)umask(022);
 /* Get the user id */
 player_uid = getuid();
 /* Drop permissions */
 safe_setuid_drop();
 /* Get the file paths 
	 * Paths may be overriden by -d options, so this has to occur *before* 
	 * processing command line args */
 init_stuff();
 /* Process the command line arguments */
 for (i = 1; args && (i < argc); i++) {
  const char *arg = argv[i];
  /* Require proper options */
  if (*arg++ != '-') goto usage;
  /* Analyze option */
  switch (*arg++)
  {
   case 'c':
    select_game = true;
    break;
   case 'l':
    list_saves();
    exit(0);
   case 'n':
    new_game = true;
    break;
   case 'w':
    arg_wizard = true;
    break;
   case 'g':
    /* Default graphics tile */
    /* in graphics.txt, 2 corresponds to adam bolt's tiles */
    arg_graphics = 2;
    if (*arg) arg_graphics = atoi(arg);
    break;
   case 'u': {
    if (!*arg) goto usage;
    my_strcpy(arg_name, arg, sizeof(arg_name));
    /* The difference here is because on setgid we have to be
				 * careful to only let the player have savefiles stored in
				 * the central save directory.  Sanitising input using
				 * player_safe_name() removes anything like that.
				 *
				 * But if the player is running with per-user saves, they
				 * can do whatever the hell they want.
				 */
    savefile_set_name(arg, false, false);
    continue;
   }
   case 'f':
    arg_force_name = true;
    break;
   case 'm':
    if (!*arg) goto usage;
    mstr = arg;
    continue;
   case 'd':
    change_path(arg);
    continue;
   case '-':
    argv[i] = argv[0];
    argc = argc - i;
    argv = argv + i;
    args = false;
    break;
   default:
   usage:
    puts("Usage: angband [options] [-- subopts]");
    puts("  -c             Select savefile with a menu; overrides -n");
    puts("  -n             Start a new character (WARNING: overwrites default savefile without -u)");
    puts("  -l             Lists all savefiles you can play");
    puts("  -w             Resurrect dead character (marks savefile)");
    puts("  -g             Request graphics mode");
    puts("  -u<who>        Use your <who> savefile");
    puts("  -d<dir>=<path> Override a specific directory with <path>. <path> can be:");
    for (i = 0; i < (int)N_ELEMENTS(change_path_values); i++) {
     printf("    %s (default is %s)\n", change_path_values[i].name, *change_path_values[i].path);
    }
    puts("                 Multiple -d options are allowed.");
    puts("  -m<sys>        Use module <sys>, where <sys> can be:");
    /* Print the name and help for each available module */
    for (i = 0; i < (int)N_ELEMENTS(mmodules); i++)
     printf("     %s   %s\n",
            mmodules[i].name, mmodules[i].help);
    /* Actually abort the process */
    quit(NULL);
  }
  if (*arg) goto usage;
 }
 /* Hack -- Forget standard args */
 if (args) {
  argc = 1;
  argv[1] = NULL;
 }
 /* Install "quit" hook */
 quit_aux = quit_hook;
 /* If we were told which mode to use, then use it */
 if (mstr)
  ANGBAND_SYS = mstr;
 if (setlocale(LC_CTYPE, "")) {
  /* Require UTF-8 */
  if (!streq(nl_langinfo(CODESET), "UTF-8"))
   quit("Angband requires UTF-8 support");
 }
 /* Get the "user name" as default player name, unless set with -u switch */
 if (!arg_name[0]) {
  user_name(arg_name, sizeof(arg_name), player_uid);
  /* Sanitise name and set as savefile */
  savefile_set_name(arg_name, true, false);
 }
 /* Create any missing directories */
 create_needed_dirs();
 /* Try the mmodules in the order specified by mmodules[] */
 for (i = 0; i < (int)N_ELEMENTS(mmodules); i++) {
  /* User requested a specific module? */
  if (!mstr || (streq(mstr, mmodules[i].name))) {
   ANGBAND_SYS = mmodules[i].name;
   if (0 == mmodules[i].init(argc, argv)) {
    done = true;
    break;
   }
  }
 }
 /* Make sure we have a display! */
 if (!done) quit("Unable to prepare any 'display module'!");
 /* Catch nasty signals */
 signals_init();
 /* Set up the command hook */
 cmd_get_hook = textui_get_cmd;
 /*
	 * Set action that needs to be done if restarting without exiting.
	 * Also need to do it now.
	 */
 reinit_hook = generic_reinit;
 generic_reinit();
 /* Set up the display handlers and things. */
 init_display();
 init_angband();
 textui_init();
 /* Wait for response */
 pause_line(Term);
 /* Play the game */
 play_game((select_game) ?
  GAME_SELECT : ((new_game) ? GAME_NEW : GAME_LOAD));
 /* Free resources */
 textui_cleanup();
 cleanup_angband();
 /* Quit */
 quit(NULL);
 /* Exit */
 return (0);
}
/**
 * \file main-gcu.c
 * \brief Support for "curses" systems
 *
 * Copyright (c) 1997 Ben Harrison, and others
 * Copyright (c) 2009-2015 Erik Osheim
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
/**
 * Avoid 'struct term' name conflict with <curses.h> (via <term.h>) on AIX
 */
#define term System_term
#include <ncurses.h>
#include <term.h>
#undef term

/**
 * Include the proper "header" file
 */
/* Mac needs _XOPEN_SOURCE_EXTENDED to expose mvwaddnstr(). */
/**
 * Use POSIX terminal I/O
 */
/**
 * Hack -- Windows Console mode uses PDCURSES and cannot do any terminal stuff
 * Hack -- Windows needs Sleep(), and I really don't want to pull in all
 *         the Win32 headers for this one function
 */
/**
 * POSIX stuff
 */
/**
 * If you have errors relating to curs_set(), comment out the following line
 */
/**
 * If you have errors with any of the functions mentioned below, try
 * uncommenting the line it's mentioned on.
 */
/* #define cbreak() crmode() */
/* #define nonl() */
/* #define nl() */
/**
 * Save the "normal" and "angband" terminal settings
 */
static struct termios norm_termios;
static struct termios game_termios;
/**
 * The TERM environment variable; used for terminal capabilities.
 */
static char *termtype;
static bool loaded_terminfo;
/**
 * Simple rectangle type
 */
struct rect_s
{
    int x, y;
    int cx, cy;
};
typedef struct rect_s rect_t, *rect_ptr;
/* Trivial rectangle utility to make code a bit more readable */
static rect_t rect(int x, int y, int cx, int cy)
{
    rect_t r;
    r.x = x;
    r.y = y;
    r.cx = cx;
    r.cy = cy;
    return r;
}
/**
 * Information about a term
 */
typedef struct term_data {
 term t; /* All term info */
 rect_t r;
 WINDOW *win; /* Pointer to the curses window */
} term_data;
/* Max number of windows on screen */
/* Minimum main term size */
/* Comfortable subterm size */
/* Information about our windows */
static term_data data[6];
/* Number of initialized "term" structures */
static int active = 0;
/**
 * Hack -- define "A_BRIGHT" to be "A_BOLD", because on many
 * machines, "A_BRIGHT" produces ugly "inverse" video.
 */
/**
 * Software flag -- we are allowed to use color
 */
static int can_use_color = false;
/**
 * Simple Angband to Curses color conversion table
 */
static int colortable[BASIC_COLORS];
/**
 * Same colors as in the colortable, except fg and bg are both set to the fg value.
 * These pairs are used for drawing solid walls.
 */
static int same_colortable[BASIC_COLORS];
/* Screen info: use one big Term 0, or other subwindows? */
static bool bold_extended = false;
static bool use_default_background = false;
static bool keep_terminal_colors = false;
static int term_count = 1;
/**
 * Background color we should draw with; either BLACK or DEFAULT
 */
static int bg_color = COLOR_BLACK;
/**
 * Place the "keymap" into its "normal" state
 */
static void keymap_norm(void) {
 (void)tcsetattr(0, TCSAFLUSH, &norm_termios);
}
/**
 * Place the "keymap" into the "game" state
 */
static void keymap_game(void) {
 /* Set the game's termios settings */
 (void)tcsetattr(0, TCSAFLUSH, &game_termios);
}
/**
 * Save the normal keymap
 */
static void keymap_norm_prepare(void) {
 /* Restore the normal termios settings */
 tcgetattr(0, &norm_termios);
}
/**
 * Save the keymaps (normal and game)
 */
static void keymap_game_prepare(void) {
 /* Save the current termios settings */
 tcgetattr(0, &game_termios);
 /* Force "Ctrl-C" to interupt */
 game_termios.c_cc[VINTR] = (char)3;
 /* Force "Ctrl-Z" to suspend */
 game_termios.c_cc[VSUSP] = (char)26;
 /* Disable the standard control characters */
 game_termios.c_cc[VQUIT] = (char)-1;
 game_termios.c_cc[VERASE] = (char)-1;
 game_termios.c_cc[VKILL] = (char)-1;
 game_termios.c_cc[VEOF] = (char)-1;
 game_termios.c_cc[VEOL] = (char)-1;
 /* Normally, block until a character is read */
 game_termios.c_cc[VMIN] = 1;
 game_termios.c_cc[VTIME] = 0;
 /* Turn off flow control (enable ^S) */
 game_termios.c_iflag &= ~IXON;
}
/**
 * Suspend/Resume
 */
static errr Term_xtra_gcu_alive(int v) {
 if (!v) {
  /* Suspend */
  int x, y;
  /* Go to normal keymap mode */
  keymap_norm();
  /* Restore modes */
  nocbreak();
  echo();
  nl();
  /* Hack -- make sure the cursor is visible */
  Term_xtra(TERM_XTRA_SHAPE, 1);
  /* Flush the curses buffer */
  refresh();
  /* Get current cursor position */
  getyx(stdscr, y, x);
  /* Move the cursor to bottom right corner */
  mvcur(y, x, LINES - 1, 0);
  /* Exit curses */
  endwin();
  /* Flush the output */
  fflush(stdout);
 } else {
  /* Resume */
  /* Restore the settings */
  cbreak();
  noecho();
  nonl();
  /* Go to angband keymap mode */
  keymap_game();
 }
 /* Success */
 return 0;
}
const char help_gcu[] = "Text mode, subopts\n"
 "              -B     Use brighter bold characters\n"
 "              -D     Use terminal default background color\n"
 "              -K     Keep terminal's color table when changing colors\n"
 "              -nN    Use N terminals (up to 6)";
/**
 * Usage:
 *
 * narsil -mgcu -- [-B] [-D] [-nN]
 *
 *   -B      Use brighter bold characters
 *   -D      Use terminal default background color
 *   -nN     Use N terminals (up to 6)
 */
/**
 * Init the "curses" system
 */
static void Term_init_gcu(term *t) {
 term_data *td = (term_data *)(t->data);
 /*
	 * This is necessary to keep the first call to getch()
	 * from clearing the screen
	 */
 wrefresh(stdscr);
 /* Count init's, handle first */
 if (active++ != 0) return;
 /* Erase the window */
 wclear(td->win);
 /* Reset the cursor */
 wmove(td->win, 0, 0);
 /* Flush changes */
 wrefresh(td->win);
 /* Game keymap */
 keymap_game();
}
/**
 * Nuke the "curses" system
 */
static void Term_nuke_gcu(term *t) {
 int x, y;
 term_data *td = (term_data *)(t->data);
 /* Delete this window */
 delwin(td->win);
 /* Count nuke's, handle last */
 if (--active != 0) return;
 /* Hack -- make sure the cursor is visible */
 Term_xtra(TERM_XTRA_SHAPE, 1);
 /* Reset colors to defaults */
 start_color();
 /* Get current cursor position */
 getyx(stdscr, y, x);
 /* Move the cursor to bottom right corner */
 mvcur(y, x, LINES - 1, 0);
 /* Flush the curses buffer */
 refresh();
 /* Exit curses */
 endwin();
 /* Flush the output */
 fflush(stdout);
 /* Normal keymap */
 keymap_norm();
}
/**
 * Helper function for get_gcu_term_size:
 * Given inputs, populates size and start (rows and y, or cols and x)
 * with correct values for a group (column or row) of terms.
 *   term_group_index: the placement of the group, e.g.
 *     top row is 0
 *   term_group_count: the number of groups in this dimension (2 or 3)
 *   window_size:      the number of grids the window has in this dimension
 *   min_term0_size:   the minimum main term size in this dimension 
 *     (80 or 24), also the maximum subterm size
 *   comfy_subterm_size: in balancing among three groups, we first give the
 *     main term its minimum, and then allocate evenly between the other
 *     two subterms until they are both comfy_subterm_size, at which point
 *     we grow the outer subterm until it reaches min_term0_size. (The
 *     middle subterm then grows until min_term0_size, and any further
 *     window space goes to the main term.)
 */
static void balance_dimension(int *size, int *start, int term_group_index,
 int term_group_count, int window_size, int min_term0_size,
 int comfy_subterm_size) {
 /* Convenience variable for clarity.
	 * Note that it is also the number of separator rows/columns */
 int subterm_group_count = term_group_count - 1;
 if (term_group_index == 0) {
  /* main term */
  *size = MAX(min_term0_size, window_size - subterm_group_count*(min_term0_size + 1));
  *start = 0;
 } else if (term_group_index == term_group_count - 1) {
  /* outer or only subterm */
  if (window_size <= min_term0_size + subterm_group_count*(comfy_subterm_size + 1)) {
   /* Not enough room for min term0 and all subterms comfy.
			 * Note that we round up here and down for the middle subterm*/
   *size = (window_size - min_term0_size - subterm_group_count) / subterm_group_count;
   if (window_size > min_term0_size + subterm_group_count + *size * subterm_group_count)
    (*size)++;
  } else {
   *size = MIN(min_term0_size, window_size - min_term0_size - comfy_subterm_size*(subterm_group_count - 1) - subterm_group_count);
  }
  *start = window_size - *size;
 } else {
  /* middle subterm */
  if (window_size <= subterm_group_count*(min_term0_size + 1) + comfy_subterm_size) {
   /* Outer subterm(s) not yet full-sized, thus at most comfy */
   *size = MIN(comfy_subterm_size, (window_size - min_term0_size - subterm_group_count) / subterm_group_count);
  } else {
   *size = MIN(min_term0_size, window_size - subterm_group_count*(min_term0_size + 1));
  }
  *start = 1 + MAX(min_term0_size, window_size - subterm_group_count*(min_term0_size + 1));
 }
}
/**
 * For a given term number (i) set the upper left corner (x, y) and the
 * correct dimensions. Remember to leave one row and column between
 * subterms.
 */
static void get_gcu_term_size(int i, int *rows, int *cols, int *y, int *x) {
 bool is_wide = (10 * LINES < 3 * COLS);
 int term_rows = 1;
 int term_cols = 1;
 int term_row_index = 0;
 int term_col_index = 0;
 assert(i < term_count);
 /* For sufficiently small windows, we can only use one term.
	 * Each additional row/column of terms requires at least two lines
	 * for the separators. If everything is as square as possible, 
	 * the 3rd, 7th, 13th, etc. terms add to the short dimension, while
	 * the 2nd, 5th, 10th, etc. terms add to the long dimension.
	 * However, three terms are the special case of 1x3 or 3x1.
	 */
 if (is_wide) {
  while (term_rows*(term_rows + 1) < term_count) term_rows++;
  while (term_cols*term_cols < term_count) term_cols++;
  if (term_count == 3) {
   term_rows = 1;
   term_cols = 3;
  }
  term_col_index = i % term_cols;
  term_row_index = (int)(i / term_cols);
 } else { /* !is_wide */
  while (term_rows*term_rows < term_count) term_rows++;
  while (term_cols*(term_cols + 1) < term_count) term_cols++;
  if (term_count == 3) {
   term_rows = 3;
   term_cols = 1;
  }
  term_col_index = (int)(i / term_rows);
  term_row_index = i % term_rows;
 }
 if (LINES < 24 + 2 * (term_rows - 1) ||
  COLS < 80 + 2 * (term_cols - 1)) {
  term_rows = term_cols = term_count = 1;
  if (i != 0) {
   *rows = *cols = *y = *x = 0;
  }
  term_col_index = term_row_index = 0;
 }
 balance_dimension(cols, x, term_col_index, term_cols, COLS, 80, 40);
 balance_dimension(rows, y, term_row_index, term_rows, LINES, 24, 5);
}
/**
 * Query ncurses for new screen size and try to resize the GCU terms.
 */
static void do_gcu_resize(void) {
 int i, rows, cols, y, x;
 term *old_t = Term;
 for (i = 0; i < term_count; i++) {
  /* Activate the current Term */
  Term_activate(&data[i].t);
  /* If we can resize the curses window, then resize the Term */
  get_gcu_term_size(i, &rows, &cols, &y, &x);
  if (wresize(data[i].win, rows, cols) == OK)
   Term_resize(cols, rows);
  /* Activate the old term */
  Term_activate(old_t);
 }
 do_cmd_redraw();
}
/**
 * Process events, with optional wait
 */
static errr Term_xtra_gcu_event(int v) {
 int i, j, k, mods=0;
 if (v) {
  /* Wait for a keypress; use halfdelay(1) so if the user takes more */
  /* than 0.2 seconds we get a chance to do updates. */
  halfdelay(2);
  i = getch();
  while (i == ERR) {
   i = getch();
   idle_update();
  }
  cbreak();
 } else {
  /* Do not wait for it */
  nodelay(stdscr, true);
  /* Check for keypresses */
  i = getch();
  /* Wait for it next time */
  nodelay(stdscr, false);
  /* None ready */
  if (i == ERR) return (1);
  if (i == EOF) return (1);
 }
 /* Not sure if this is portable to non-ncurses platforms */
 if (i == KEY_RESIZE) {
  /* wait until we go one second (10 deci-seconds) before actually
		 * doing the resizing. users often end up triggering multiple
		 * KEY_RESIZE events while changing window size. */
  halfdelay(10);
  do {
   i = getch();
  } while (i == KEY_RESIZE);
  cbreak();
  do_gcu_resize();
  if (i == ERR) return (1);
 }
 /* uncomment to debug keycode issues */
 /* This might be a bad idea, but...
	 *
	 * Here we try to second-guess ncurses. In some cases, keypad() mode will
	 * fail to translate multi-byte escape sequences into things like number-
	 * pad actions, function keys, etc. So we can hardcode a small list of some
	 * of the most common sequences here, just in case.
	 *
	 * Notice that we turn nodelay() on. This means, that we won't accidentally
	 * interpret sequences as valid unless all the bytes are immediately
	 * available; this seems like an acceptable risk to fix problems associated
	 * with various terminal emulators (I'm looking at you PuTTY).
	 */
 if (i == 27) { /* ESC */
  nodelay(stdscr, true);
  j = getch();
  switch (j) {
   case 'O': {
    k = getch();
    switch (k) {
     /* PuTTY number pad */
     case 'q': i = '1'; break;
     case 'r': i = '2'; break;
     case 's': i = '3'; break;
     case 't': i = '4'; break;
     case 'u': i = '5'; break;
     case 'v': i = '6'; break;
     case 'w': i = '7'; break;
     case 'x': i = '8'; break;
     case 'y': i = '9'; break;
     /* no match */
     case ERR: break;
     default: ungetch(k); ungetch(j);
    }
    break;
   }
   /* no match */
   case ERR: break;
   default: ungetch(j);
  }
  nodelay(stdscr, false);
 }
 /* Enqueue the keypress */
 Term_keypress(i, mods);
 /* Success */
 return (0);
}
static int scale_color(int i, int j, int scale) {
 return (angband_color_table[i][j] * (scale - 1) + 127) / 255;
}
static int create_color(int i, int scale) {
 int r = scale_color(i, 1, scale);
 int g = scale_color(i, 2, scale);
 int b = scale_color(i, 3, scale);
 int rgb = 16 + scale * scale * r + scale * g + b;
 /* In the case of white and black we need to use the ANSI colors */
 if (r == g && g == b) {
  if (b == 0) rgb = 0;
  if (b == scale) rgb = 15;
 }
 return rgb;
}
/**
 * Adjust the color tables if there's more than 16 available.
 */
static void handle_extended_color_tables(void) {
 if (COLORS == 256 || COLORS == 88) {
  int isbold = bold_extended ? A_BOLD : A_NORMAL;
  int i;
  if (keep_terminal_colors) {
   /*
			 * If we have more than 16 colors, find the best
			 * matches in the terminal's default color table.
			 * These numbers correspond to xterm/rxvt's builtin
			 * color numbers--they do not correspond to curses'
			 * constants OR with curses' color pairs.
			 *
			 * XTerm has 216 (6*6*6) RGB colors, with each RGB
			 * setting 0-5.
			 * RXVT has 64 (4*4*4) RGB colors, with each RGB
			 * setting 0-3.
			 *
			 * Both also have the basic 16 ANSI colors, plus some
			 * extra grayscale colors which we do not use.
			 */
   int scale = COLORS == 256 ? 6 : 4;
   bg_color = create_color(COLOUR_DARK, scale);
   for (i = 0; i < BASIC_COLORS; i++) {
    int fg = create_color(i, scale);
    init_pair(i + 1, fg, bg_color);
    colortable[i] = COLOR_PAIR(i + 1) | isbold;
    init_pair(BASIC_COLORS + i, fg, fg);
    same_colortable[i] =
     COLOR_PAIR(BASIC_COLORS + i) | isbold;
   }
  } else {
   bg_color = 0;
   for (i = 0; i < BASIC_COLORS; i++) {
    /*
				 * Scale components to a range of 0 - 1000 per
				 * init_color()'s documentation.
				 */
    init_color(i,
     (angband_color_table[i][1] * 1001) / 256,
     (angband_color_table[i][2] * 1001) / 256,
     (angband_color_table[i][3] * 1001) / 256);
    init_pair(i + 1, i, bg_color);
    colortable[i] = COLOR_PAIR(i + 1) | isbold;
    init_pair(BASIC_COLORS + i, i, i);
    same_colortable[i] =
     COLOR_PAIR(BASIC_COLORS + i) | isbold;
   }
  }
  for (i = 0; i < term_count; ++i) {
   if (data[i].win) {
    wbkgdset(data[i].win, ' ' |
     colortable[COLOUR_DARK]);
   }
  }
  if (data[0].win) {
   /*
			 * Adjust the background color on the standard screen
			 * as well so separators between the terminals have
			 * the same background as the rest.
			 */
   chtype term0_bkg = getbkgd(data[0].win);
   if (getbkgd(stdscr) != term0_bkg) {
    wbkgd(stdscr, term0_bkg);
    wrefresh(stdscr);
   }
  }
 }
}
/**
 * Handle a "special request"
 */
static errr Term_xtra_gcu(int n, int v) {
 term_data *td = (term_data *)(Term->data);
 /* Analyze the request */
 switch (n) {
  /* Clear screen */
  case TERM_XTRA_CLEAR: touchwin(td->win); wclear(td->win); return 0;
  /* Make a noise */
  case TERM_XTRA_NOISE: write(1, "\007", 1); return 0;
  /* Flush the Curses buffer */
  case TERM_XTRA_FRESH: wrefresh(td->win); return 0;
  /* Change the cursor visibility */
  case TERM_XTRA_SHAPE: curs_set(v); return 0;
  /* Suspend/Resume curses */
  case TERM_XTRA_ALIVE: return Term_xtra_gcu_alive(v);
  /* Process events */
  case TERM_XTRA_EVENT: return Term_xtra_gcu_event(v);
  /* Flush events */
  case TERM_XTRA_FLUSH: while (!Term_xtra_gcu_event(false)); return 0;
  /* Delay */
  case TERM_XTRA_DELAY: if (v > 0) usleep(1000 * v); return 0;
  /* React to events */
  case TERM_XTRA_REACT: handle_extended_color_tables(); return 0;
 }
 /* Unknown event */
 return 1;
}
/**
 * Actually MOVE the hardware cursor
 */
static errr Term_curs_gcu(int x, int y) {
 term_data *td = (term_data *)(Term->data);
 wmove(td->win, y, x);
 return 0;
}
/**
 * Erase a grid of space
 * Hack -- try to be "semi-efficient".
 */
static errr Term_wipe_gcu(int x, int y, int n) {
 term_data *td = (term_data *)(Term->data);
 wmove(td->win, y, x);
 if (x + n >= td->t.wid) {
  /* Clear to end of line */
  wclrtoeol(td->win);
 } else {
  /* Clear some characters */
  if (can_use_color) {
   wattrset(td->win, colortable[COLOUR_DARK] | A_NORMAL);
  }
  whline(td->win, ' ', n);
  if (can_use_color) {
   wattrset(td->win, A_NORMAL);
  }
 }
 return 0;
}
/**
 * Place some text on the screen using an attribute
 */
static errr Term_text_gcu(int x, int y, int n, int a, const wchar_t *s) {
 term_data *td = (term_data *)(Term->data);
//#ifdef A_COLOR
//	if (can_use_color) {
//
//		/* the lower 7 bits of the attribute indicate the fg/bg */
//		int attr = a & 127;
//
//		/* the high bit of the attribute indicates a reversed fg/bg */
//		bool reversed = a > 127;
//
//		int color;
//
//		/* Set bg and fg to the same color when drawing solid walls */
//		if (a / MULT_BG == BG_SAME) {
//			color = same_colortable[attr];
//		} else {
//			color = colortable[attr];
//		}
//
//		/* the following check for A_BRIGHT is to avoid #1813 */
//		int mode;
//		if (reversed && (color & A_BRIGHT))
//			mode = (color & ~A_BRIGHT) | A_BLINK | A_REVERSE;
//		else if (reversed)
//			mode = color | A_REVERSE;
//		else
//			mode = color | A_NORMAL;
//
//		wattrset(td->win, mode);
//		mvwaddnwstr(td->win, y, x, s, n);
//		wattrset(td->win, A_NORMAL);
//		return 0;
//	}
//#endif
//
//	mvwaddnwstr(td->win, y, x, s, n);
 return 0;
}
/**
 * Create a window for the given "term_data" argument.
 *
 * Assumes legal arguments.
 */
static errr term_data_init_gcu(term_data *td, int rows, int cols, int y, int x)
{
 term *t = &td->t;
 /* Create new window */
 td->win = newwin(rows, cols, y, x);
 /* Check for failure */
 if (!td->win)
  quit("Failed to setup curses window.");
 /* Initialize the term */
 term_init(t, cols, rows, 256);
 /* Avoid bottom right corner */
 t->icky_corner = true;
 /* Differentiate between BS/^h, Tab/^i, etc. */
 t->complex_input = true;
 /* Set some hooks */
 t->init_hook = Term_init_gcu;
 t->nuke_hook = Term_nuke_gcu;
 /* Set some more hooks */
 t->text_hook = Term_text_gcu;
 t->wipe_hook = Term_wipe_gcu;
 t->curs_hook = Term_curs_gcu;
 t->xtra_hook = Term_xtra_gcu;
 /* Save the data */
 t->data = td;
 /* Activate it */
 Term_activate(t);
 /* Success */
 return (0);
}
/**
 * Simple helper
 */
static errr term_data_init(term_data *td)
{
 return term_data_init_gcu(td, td->r.cy, td->r.cx, td->r.y, td->r.x);
}
/* Parse 27,15,*x30 up to the 'x'. * gets converted to a big number
   Parse 32,* until the end. Return count of numbers parsed */
static int _parse_size_list(const char *arg, int sizes[], int max)
{
    int i = 0;
    const char *start = arg;
    const char *stop = arg;
    for (;;)
    {
        if (!*stop || !isdigit(*stop))
        {
            if (i >= max) break;
            if (*start == '*')
                sizes[i] = 255;
            else
            {
                /* rely on atoi("23,34,*") -> 23
                   otherwise, copy [start, stop) into a new buffer first.*/
                sizes[i] = atoi(start);
            }
            i++;
            if (!*stop || *stop != ',') break;
            stop++;
            start = stop;
        }
        else
            stop++;
    }
    return i;
}
static void hook_quit(const char *str) {
 int i;
 for (i = 0; i < term_count; i++) {
  if (angband_term[i]) {
   term_nuke(angband_term[i]);
  }
 }
 endwin();
}
/**
 * Prepare "curses" for use by the file "ui-term.c"
 *
 * Installs the "hook" functions defined above, and then activates
 * the main screen "term", which clears the screen and such things.
 *
 * Someone should really check the semantics of "initscr()"
 */
errr init_gcu(int argc, char **argv) {
 int i;
 /* Initialize info about terminal capabilities */
 termtype = getenv("TERM");
 loaded_terminfo = termtype && tgetent(0, termtype) == 1;
 /* Parse args */
 for (i = 1; i < argc; i++) {
  if (prefix(argv[i], "-B")) {
   bold_extended = true;
  } else if (prefix(argv[i], "-n")) {
   term_count = atoi(&argv[i][2]);
   if (term_count > 6) term_count = 6;
   else if (term_count < 1) term_count = 1;
  } else if (prefix(argv[i], "-D")) {
   use_default_background = true;
  } else if (streq(argv[i], "-K")) {
   keep_terminal_colors = true;
  }
 }
 /* Extract the normal keymap */
 keymap_norm_prepare();
 /* We do it like this to prevent a link error with curseses that
	 * lack ESCDELAY. */
 if (!getenv("ESCDELAY")) {
  static char escdelbuf[80] = "ESCDELAY=20";
  putenv(escdelbuf);
 }
 /* Initialize */
 if (initscr() == NULL) return (-1);
 /* Activate hooks */
 quit_aux = hook_quit;
 /* Require standard size screen */
 if (LINES < 24 || COLS < 80)
  quit("Angband needs at least an 80x24 'curses' screen");
 /* Do we have color, and enough color, available? */
 can_use_color = ((start_color() != ERR) && has_colors() &&
      (COLORS >= 8) && (COLOR_PAIRS >= 8));
 if (!can_change_color()) keep_terminal_colors = true;
 /* Should we use curses' "default color" */
 if (use_default_background && use_default_colors() == OK) bg_color = -1;
 /* Attempt to use colors */
 if (can_use_color) {
  /* Prepare the color pairs */
  /* PAIR_WHITE (pair 0) is *always* WHITE on BLACK */
  init_pair(1, COLOR_RED, bg_color);
  init_pair(2, COLOR_GREEN, bg_color);
  init_pair(3, COLOR_YELLOW, bg_color);
  init_pair(4, COLOR_BLUE, bg_color);
  init_pair(5, COLOR_MAGENTA, bg_color);
  init_pair(6, COLOR_CYAN, bg_color);
  init_pair(7, COLOR_BLACK, bg_color);
  /* These pairs are used for drawing solid walls */
  init_pair(8, COLOR_WHITE, COLOR_WHITE);
  init_pair(9, COLOR_RED, COLOR_RED);
  init_pair(10, COLOR_GREEN, COLOR_GREEN);
  init_pair(11, COLOR_YELLOW, COLOR_YELLOW);
  init_pair(12, COLOR_BLUE, COLOR_BLUE);
  init_pair(13, COLOR_MAGENTA, COLOR_MAGENTA);
  init_pair(14, COLOR_CYAN, COLOR_CYAN);
  init_pair(15, COLOR_BLACK, COLOR_BLACK);
  /* Prepare the colors */
  colortable[COLOUR_DARK] = (COLOR_PAIR(7));
  colortable[COLOUR_WHITE] = (COLOR_PAIR(0) | A_BOLD);
  colortable[COLOUR_SLATE] = (COLOR_PAIR(0));
  colortable[COLOUR_ORANGE] = (COLOR_PAIR(3) | A_BOLD);
  colortable[COLOUR_RED] = (COLOR_PAIR(1));
  colortable[COLOUR_GREEN] = (COLOR_PAIR(2));
  colortable[COLOUR_BLUE] = (COLOR_PAIR(4));
  colortable[COLOUR_UMBER] = (COLOR_PAIR(3));
  colortable[COLOUR_L_DARK] = (COLOR_PAIR(7) | A_BOLD);
  colortable[COLOUR_L_WHITE] = (COLOR_PAIR(0));
  colortable[COLOUR_L_PURPLE] = (COLOR_PAIR(5));
  colortable[COLOUR_YELLOW] = (COLOR_PAIR(3) | A_BOLD);
  colortable[COLOUR_L_RED] = (COLOR_PAIR(5) | A_BOLD);
  colortable[COLOUR_L_GREEN] = (COLOR_PAIR(2) | A_BOLD);
  colortable[COLOUR_L_BLUE] = (COLOR_PAIR(4) | A_BOLD);
  colortable[COLOUR_L_UMBER] = (COLOR_PAIR(3));
  colortable[COLOUR_PURPLE] = (COLOR_PAIR(5));
  colortable[COLOUR_VIOLET] = (COLOR_PAIR(5));
  colortable[COLOUR_TEAL] = (COLOR_PAIR(6));
  colortable[COLOUR_MUD] = (COLOR_PAIR(3));
  colortable[COLOUR_L_YELLOW] = (COLOR_PAIR(3 | A_BOLD));
  colortable[COLOUR_MAGENTA] = (COLOR_PAIR(5 | A_BOLD));
  colortable[COLOUR_L_TEAL] = (COLOR_PAIR(6) | A_BOLD);
  colortable[COLOUR_L_VIOLET] = (COLOR_PAIR(5) | A_BOLD);
  colortable[COLOUR_L_PINK] = (COLOR_PAIR(5) | A_BOLD);
  colortable[COLOUR_MUSTARD] = (COLOR_PAIR(3));
  colortable[COLOUR_BLUE_SLATE] = (COLOR_PAIR(4));
  colortable[COLOUR_DEEP_L_BLUE] = (COLOR_PAIR(4));
  same_colortable[COLOUR_DARK] = (COLOR_PAIR(15));
  same_colortable[COLOUR_WHITE] = (COLOR_PAIR(8) | A_BOLD);
  same_colortable[COLOUR_SLATE] = (COLOR_PAIR(8));
  same_colortable[COLOUR_ORANGE] = (COLOR_PAIR(11) | A_BOLD);
  same_colortable[COLOUR_RED] = (COLOR_PAIR(9));
  same_colortable[COLOUR_GREEN] = (COLOR_PAIR(10));
  same_colortable[COLOUR_BLUE] = (COLOR_PAIR(12));
  same_colortable[COLOUR_UMBER] = (COLOR_PAIR(11));
  same_colortable[COLOUR_L_DARK] = (COLOR_PAIR(15) | A_BOLD);
  same_colortable[COLOUR_L_WHITE] = (COLOR_PAIR(8));
  same_colortable[COLOUR_L_PURPLE] = (COLOR_PAIR(13));
  same_colortable[COLOUR_YELLOW] = (COLOR_PAIR(11) | A_BOLD);
  same_colortable[COLOUR_L_RED] = (COLOR_PAIR(13) | A_BOLD);
  same_colortable[COLOUR_L_GREEN] = (COLOR_PAIR(10) | A_BOLD);
  same_colortable[COLOUR_L_BLUE] = (COLOR_PAIR(12) | A_BOLD);
  same_colortable[COLOUR_L_UMBER] = (COLOR_PAIR(11));
  same_colortable[COLOUR_PURPLE] = (COLOR_PAIR(13));
  same_colortable[COLOUR_VIOLET] = (COLOR_PAIR(13));
  same_colortable[COLOUR_TEAL] = (COLOR_PAIR(14));
  same_colortable[COLOUR_MUD] = (COLOR_PAIR(11));
  same_colortable[COLOUR_L_YELLOW] = (COLOR_PAIR(11) | A_BOLD);
  same_colortable[COLOUR_MAGENTA] = (COLOR_PAIR(13) | A_BOLD);
  same_colortable[COLOUR_L_TEAL] = (COLOR_PAIR(14) | A_BOLD);
  same_colortable[COLOUR_L_VIOLET] = (COLOR_PAIR(13) | A_BOLD);
  same_colortable[COLOUR_L_PINK] = (COLOR_PAIR(13) | A_BOLD);
  same_colortable[COLOUR_MUSTARD] = (COLOR_PAIR(3));
  same_colortable[COLOUR_BLUE_SLATE] = (COLOR_PAIR(4));
  same_colortable[COLOUR_DEEP_L_BLUE] = (COLOR_PAIR(4));
  handle_extended_color_tables();
 }
 /* Paranoia -- Assume no waiting */
 nodelay(stdscr, false);
 /* Prepare */
 cbreak();
 noecho();
 nonl();
 raw();
 /* Tell curses to rewrite escape sequences to KEY_UP and friends */
 keypad(stdscr, true);
 /* Extract the game keymap */
 keymap_game_prepare();
 /* Now prepare the term(s) */
 if (term_count > 1)
 {
  int rows, cols, y, x;
  int next_win = 0;
  for (i = 0; i < term_count; i++) {
   /* Get the terminal dimensions; if the user asked for a big screen
			 * then we'll put the whole screen in term 0; otherwise we'll divide
			 * it amongst the available terms */
   get_gcu_term_size(i, &rows, &cols, &y, &x);
   /* Skip non-existant windows */
   if (rows <= 0 || cols <= 0) continue;
   /* Create a term */
   term_data_init_gcu(&data[next_win], rows, cols, y, x);
   /* Remember the term */
   angband_term[next_win] = &data[next_win].t;
   /* One more window */
   next_win++;
  }
 }
 else
/* Parse Args and Prepare the Terminals. Rectangles are specified
      as Width x Height, right? The game will allow you to have two
      strips of extra terminals, one on the right and one on the bottom.
      The map terminal will than fit in as big as possible in the remaining
      space.

      Examples:
        narsil -mgcu -- -right 30x27,* -bottom *x7 will layout as

        Term-0: Map (COLS-30)x(LINES-7) | Term-1: 30x27
        --------------------------------|----------------------
        <----Term-3: (COLS-30)x7------->| Term-2: 30x(LINES-27)

        narsil -mgcu -- -bottom *x7 -right 30x27,* will layout as

        Term-0: Map (COLS-30)x(LINES-7) | Term-2: 30x27
                                        |------------------------------
                                        | Term-3: 30x(LINES-27)
        ---------------------------------------------------------------
        <----------Term-1: (COLS)x7----------------------------------->

        Notice the effect on the bottom terminal by specifying its argument
        second or first. Notice the sequence numbers for the various terminals
        as you will have to blindly configure them in the window setup screen.

        EDIT: Added support for -left and -top.
    */
    {
        rect_t remaining = rect(0, 0, COLS, LINES);
        int spacer_cx = 1;
        int spacer_cy = 1;
        int next_term = 1;
        int term_ct = 1;
        for (i = 1; i < argc; i++)
        {
            if (streq(argv[i], "-spacer"))
            {
                char *pe, *ystr;
                long lv;
                i++;
                if (i >= argc)
                    quit("Missing size specifier for -spacer");
                lv = strtol(argv[i], &pe, 10);
                /*
                 * Also reject INT_MIN and INT_MAX so do not have to check
                 * errno to detect overflow on platforms where sizeof(int) ==
                 * sizeof(long).
                 */
                if (pe == argv[i] || *pe != 'x' || lv <= INT_MIN ||
                        lv >= INT_MAX) {
                    quit_fmt("Invalid specification for -spacer; got %s",
                        argv[i]);
                }
                spacer_cx = (int)lv;
                ystr = pe + 1;
                lv = strtol(ystr, &pe, 10);
                if (pe == ystr || !contains_only_spaces(pe) ||
                        lv <= INT_MIN || lv >= INT_MAX) {
                    quit_fmt("Invalid specification for -spacer; got %s",
                        argv[i]);
                }
                spacer_cy = (int)lv;
            }
            else if (streq(argv[i], "-right") || streq(argv[i], "-left"))
            {
                const char *arg, *tmp;
                bool left = streq(argv[i], "-left");
                int cx, cys[6] = {0}, ct, j, x, y;
                i++;
                if (i >= argc)
                    quit(format("Missing size specifier for -%s", left ? "left" : "right"));
                arg = argv[i];
                tmp = strchr(arg, 'x');
                if (!tmp)
                    quit(format("Expected something like -%s 60x27,* for two %s hand terminals of 60 columns, the first 27 lines and the second whatever is left.", left ? "left" : "right", left ? "left" : "right"));
                cx = atoi(arg);
                remaining.cx -= cx;
                if (left)
                {
                    x = remaining.x;
                    y = remaining.y;
                    remaining.x += cx;
                }
                else
                {
                    x = remaining.x + remaining.cx;
                    y = remaining.y;
                }
                remaining.cx -= spacer_cx;
                if (left)
                    remaining.x += spacer_cx;
                tmp++;
                ct = _parse_size_list(tmp, cys, 6);
                for (j = 0; j < ct; j++)
                {
                    int cy = cys[j];
                    if (y + cy > remaining.y + remaining.cy)
                        cy = remaining.y + remaining.cy - y;
                    if (next_term >= 6)
                        quit(format("Too many terminals. Only %d are allowed.", 6));
                    if (cy <= 0)
                    {
                        quit(format("Out of bounds in -%s: %d is too large (%d rows max for this strip)",
                            left ? "left" : "right", cys[j], remaining.cy));
                    }
                    data[next_term++].r = rect(x, y, cx, cy);
                    y += cy + spacer_cy;
                    term_ct++;
                }
            }
            else if (streq(argv[i], "-top") || streq(argv[i], "-bottom"))
            {
                const char *arg, *tmp;
                bool top = streq(argv[i], "-top");
                int cy, cxs[6] = {0}, ct, j, x, y;
                i++;
                if (i >= argc)
                    quit(format("Missing size specifier for -%s", top ? "top" : "bottom"));
                arg = argv[i];
                tmp = strchr(arg, 'x');
                if (!tmp)
                    quit(format("Expected something like -%s *x7 for a single %s terminal of 7 lines using as many columns as are available.", top ? "top" : "bottom", top ? "top" : "bottom"));
                tmp++;
                cy = atoi(tmp);
                ct = _parse_size_list(arg, cxs, 6);
                remaining.cy -= cy;
                if (top)
                {
                    x = remaining.x;
                    y = remaining.y;
                    remaining.y += cy;
                }
                else
                {
                    x = remaining.x;
                    y = remaining.y + remaining.cy;
                }
                remaining.cy -= spacer_cy;
                if (top)
                    remaining.y += spacer_cy;
                tmp++;
                for (j = 0; j < ct; j++)
                {
                    int cx = cxs[j];
                    if (x + cx > remaining.x + remaining.cx)
                        cx = remaining.x + remaining.cx - x;
                    if (next_term >= 6)
                        quit(format("Too many terminals. Only %d are allowed.", 6));
                    if (cx <= 0)
                    {
                        quit(format("Out of bounds in -%s: %d is too large (%d cols max for this strip)",
                            top ? "top" : "bottom", cxs[j], remaining.cx));
                    }
                    data[next_term++].r = rect(x, y, cx, cy);
                    x += cx + spacer_cx;
                    term_ct++;
                }
            }
        }
        /* Map Terminal */
        if (remaining.cx < 80 || remaining.cy < 24)
            quit(format("Failed: angband needs an %dx%d map screen, not %dx%d", 80, 24, remaining.cx, remaining.cy));
        data[0].r = remaining;
        term_data_init(&data[0]);
        angband_term[0] = Term;
        /* Child Terminals */
        for (next_term = 1; next_term < term_ct; next_term++)
        {
            term_data_init(&data[next_term]);
            angband_term[next_term] = Term;
        }
    }
 /* Activate the "Angband" window screen */
 Term_activate(&data[0].t);
 /* Remember the active screen */
 term_screen = &data[0].t;
 /* Success */
 return (0);
}
/**
 * \file main-spoil.c
 * \brief Support spoiler generation from the command line
 *
 * Copyright (c) 2021 Eric Branlund
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
static struct {
 char letter;
 void (*func)(const char*);
 bool enabled;
 const char *path;
} opts[] = {
 { 'a', spoil_artifact, false, NULL },
 { 'm', spoil_mon_desc, false, NULL },
 { 'M', spoil_mon_info, false, NULL },
 { 'o', spoil_obj_desc, false, NULL },
};
const char help_spoil[] =
 "Spoiler generation mode, subopts\n"
 "              -a fname    Write artifact spoilers to fname;\n"
 "                          if neither -p, -r, nor -s are used, uses\n"
 "                          the standard artifacts\n"
 "              -m fname    Write brief monster spoilers to fname\n"
 "              -M fname    Write extended monster spoilers to fname\n"
 "              -o fname    Write object spoilers to fname\n";
/**
 * Usage:
 *
 * angband -mspoil -- [-a fname] [-m fname] [-M fname] [-o fname] \
 *     [-p] [-r fname] [-s seed]
 *
 *   -a fname  Write artifact spoilers to a file named fname.  If neither -p,
 *             -r, nor -s are used, the artifacts will be the standard set.
 *   -m fname  Write brief monster spoilers to a file named fname.
 *   -M fname  Write extended monster spoilers to a file named fname.
 *   -o fname  Write object spoilers to a file named fname.
 *
 * Bugs:
 * Would be nice to accept "-" as the file name and write the spoilers to
 * standard output in that case.  Given the current implementation in
 * wiz-spoil.c, that would require writing to a temporary file and then
 * copying the contents of that file to standard output.  Don't have temporary
 * file support in z-file.c so punting on that for now.
 *
 * The functions in wiz-spoil.c don't provide any feedback about whether the
 * operation failed so the exit code will always indicate success even if there
 * was a problem.
 */
errr init_spoil(int argc, char *argv[]) {
 /* Skip over argv[0] */
 int i = 1;
 int result = 0;
 /* Parse the arguments. */
 while (1) {
  bool badarg = false;
  int increment = 1;
  if (i >= argc) {
   break;
  }
  if (argv[i][0] == '-') {
   /* Try to match with a known option. */
   int j = 0;
   while (1) {
    if (j >= (int)N_ELEMENTS(opts)) {
     badarg = true;
     break;
    }
    if (argv[i][1] == opts[j].letter &&
     argv[i][2] == '\0') {
     if (i < argc - 1) {
      opts[j].enabled = true;
      /*
						 * Record the filename
						 * and skip parsing
						 * of it.
						 */
      opts[j].path =
       argv[i + 1];
      ++increment;
     } else {
      printf("init-spoil: '%s' requires an argument, the name of the spoiler file\n", argv[i]);
      result = 1;
     }
     break;
    }
    ++j;
   }
  } else {
   badarg = true;
  }
  if (badarg) {
   printf("init-spoil: bad argument '%s'\n", argv[i]);
   result = 1;
  }
  i += increment;
 }
 if (result != 0) return result;
 /* Generate the spoilers. */
 init_angband();
 if (!player_make_simple(NULL, NULL, NULL, "Spoiler")) {
  printf("init-spoil: could not initialize player.\n");
  result = 1;
 }
 if (result == 0) {
  flavor_set_all_aware();
  for (i = 0; i < (int)N_ELEMENTS(opts); ++i) {
   if (!opts[i].enabled) continue;
   (*(opts[i].func))(opts[i].path);
  }
 }
 cleanup_angband();
 if (result == 0) {
  exit(0);
 }
 return result;
}
