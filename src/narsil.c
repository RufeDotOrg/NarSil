#include "bulk.h"

#include "src/local/macro.c"
#include "src/local/type.c"
#include "pre.h"
#include "src/local/var.c"

STATIC_OVL int
motion_dir(struct loc start, struct loc finish)
{
  if (loc_eq(start, finish)) return (DIR_NONE);
  if (start.x == finish.x) return ((start.y < finish.y) ? DIR_S : DIR_N);
  if (start.y == finish.y) return ((start.x < finish.x) ? DIR_E : DIR_W);
  if (start.y < finish.y) return ((start.x < finish.x) ? DIR_SE : DIR_SW);
  if (start.y > finish.y) return ((start.x < finish.x) ? DIR_NE : DIR_NW);
  return (DIR_NONE);
}
STATIC_OVL struct loc
next_grid(struct loc grid, int dir)
{
  return loc(grid.x + ddgrid[dir].x, grid.y + ddgrid[dir].y);
}
STATIC_OVL int
dir_from_delta(int delta_y, int delta_x)
{
  int16_t dird[3][3] = {{7, 8, 9}, {4, 5, 6}, {1, 2, 3}};
  assert((ABS(delta_y) < 2) && (ABS(delta_x) < 2));
  return (dird[delta_y + 1][delta_x + 1]);
}
STATIC_OVL int
rough_direction(struct loc grid1, struct loc grid2)
{
  int delta_y = grid2.y - grid1.y;
  int delta_x = grid2.x - grid1.x;
  int dy, dx;
  if (delta_y == 0) {
    dy = 0;
  } else {
    dy = (delta_y > 0) ? 1 : -1;
  }
  if (delta_x == 0) {
    dx = 0;
  } else {
    dx = (delta_x > 0) ? 1 : -1;
  }
  if ((delta_x != 0) && (ABS(delta_y) / ABS(delta_x) >= 2)) dx = 0;
  if ((delta_y != 0) && (ABS(delta_x) / ABS(delta_y) >= 2)) dy = 0;
  return (dir_from_delta(dy, dx));
}
STATIC_OVL int
lookup_feat(const char* name)
{
  int i;
  for (i = 0; i < FEAT_MAX; i++) {
    struct feature* feat = &f_info[i];
    if (!feat->name) continue;
    if (streq(name, feat->name)) return i;
  }
  quit_fmt("Failed to find terrain feature %s", name);
  return -1;
}
STATIC_OVL int
lookup_feat_code(const char* code)
{
  int i = 0;
  while (1) {
    assert(i >= 0 && i < (int)N_ELEMENTS(feat_code_list));
    if (!feat_code_list[i]) {
      return -1;
    }
    if (streq(code, feat_code_list[i])) {
      break;
    }
    ++i;
  }
  return i;
}
STATIC_OVL const char*
get_feat_code_name(int idx)
{
  return (idx < 0 || idx >= FEAT_MAX) ? NULL : feat_code_list[idx];
}
STATIC_OVL void
flow_new(struct chunk* c, struct flow* flow)
{
  int y;
  flow->grids = mem_zalloc(c->height * sizeof(uint16_t*));
  for (y = 0; y < c->height; y++) {
    flow->grids[y] = mem_zalloc(c->width * sizeof(uint16_t));
  }
}
STATIC_OVL void
flow_free(struct chunk* c, struct flow* flow)
{
  int y;
  for (y = 0; y < c->height; y++) {
    mem_free(flow->grids[y]);
  }
  mem_free(flow->grids);
}
STATIC_OVL struct chunk*
cave_new(int height, int width)
{
  int y, x;
  struct chunk* c = mem_zalloc(sizeof *c);
  c->height = height;
  c->width = width;
  c->feat_count = mem_zalloc((FEAT_MAX + 1) * sizeof(int));
  c->squares = mem_zalloc(c->height * sizeof(struct square*));
  for (y = 0; y < c->height; y++) {
    c->squares[y] = mem_zalloc(c->width * sizeof(struct square));
    for (x = 0; x < c->width; x++) {
      c->squares[y][x].info = mem_zalloc(SQUARE_SIZE * sizeof(bitflag));
    }
  }
  flow_new(c, &c->player_noise);
  flow_new(c, &c->monster_noise);
  flow_new(c, &c->scent);
  c->objects = mem_zalloc(OBJECT_LIST_SIZE * sizeof(struct object*));
  c->obj_max = OBJECT_LIST_SIZE - 1;
  c->monsters = mem_zalloc(z_info->level_monster_max * sizeof(struct monster));
  c->mon_max = 1;
  c->mon_current = -1;
  c->monster_groups =
      mem_zalloc(z_info->level_monster_max * sizeof(struct monster_group*));
  c->turn = turn;
  return c;
}
STATIC_OVL void
cave_free(struct chunk* c)
{
  struct chunk* p_c = (c == cave && player) ? player->cave : NULL;
  int y, x, i;
  for (i = 1; i < c->obj_max; i++) {
    if (c->objects[i] && loc_is_zero(c->objects[i]->grid)) {
      object_delete(c, p_c, &c->objects[i]);
    }
  }
  for (y = 0; y < c->height; y++) {
    for (x = 0; x < c->width; x++) {
      mem_free(c->squares[y][x].info);
      if (c->squares[y][x].trap) square_free_trap(c, loc(x, y));
      if (c->squares[y][x].obj) object_pile_free(c, p_c, c->squares[y][x].obj);
    }
    mem_free(c->squares[y]);
  }
  mem_free(c->squares);
  flow_free(c, &c->player_noise);
  flow_free(c, &c->monster_noise);
  flow_free(c, &c->scent);
  mem_free(c->feat_count);
  mem_free(c->objects);
  mem_free(c->monsters);
  mem_free(c->monster_groups);
  if (c->name) string_free(c->name);
  if (c->vault_name) string_free(c->vault_name);
  mem_free(c);
}
STATIC_OVL void
list_object(struct chunk* c, struct object* obj)
{
  int i, newsize;
  if (!obj) return;
  for (i = 1; i < c->obj_max; i++)
    if (c->objects[i] == obj) return;
  for (i = 1; i < c->obj_max; i++) {
    if ((c == cave) && player->cave && player->cave->objects[i]) {
      continue;
    }
    if (c->objects[i] == NULL) {
      c->objects[i] = obj;
      obj->oidx = i;
      return;
    }
  }
  newsize = (c->obj_max + OBJECT_LIST_INCR + 1) * sizeof(struct object*);
  c->objects = mem_realloc(c->objects, newsize);
  c->objects[c->obj_max] = obj;
  obj->oidx = c->obj_max;
  for (i = c->obj_max + 1; i <= c->obj_max + OBJECT_LIST_INCR; i++)
    c->objects[i] = NULL;
  c->obj_max += OBJECT_LIST_INCR;
  if ((c == cave) && player->cave) {
    player->cave->objects = mem_realloc(player->cave->objects, newsize);
    for (i = player->cave->obj_max; i <= c->obj_max; i++)
      player->cave->objects[i] = NULL;
    player->cave->obj_max = c->obj_max;
  }
}
STATIC_OVL void
delist_object(struct chunk* c, struct object* obj)
{
  if (!obj->oidx) return;
  assert(c->objects[obj->oidx] == obj);
  if ((c == cave) && player->cave->objects[obj->oidx]) return;
  c->objects[obj->oidx] = NULL;
  obj->oidx = 0;
}
STATIC_OVL void
object_lists_check_integrity(struct chunk* c, struct chunk* c_k)
{
  int i;
  if (c_k) {
    assert(c->obj_max == c_k->obj_max);
    for (i = 0; i < c->obj_max; i++) {
      struct object* obj = c->objects[i];
      struct object* known_obj = c_k->objects[i];
      if (obj) {
        assert(obj->oidx == i);
        if (!loc_is_zero(obj->grid))
          assert(pile_contains(square_object(c, obj->grid), obj));
      }
      if (known_obj) {
        assert(obj);
        if (player->upkeep->playing) {
          assert(known_obj == obj->known);
        }
        if (!loc_is_zero(known_obj->grid))
          assert(pile_contains(square_object(c_k, known_obj->grid), known_obj));
        assert(known_obj->oidx == i);
      }
    }
  } else {
    for (i = 0; i < c->obj_max; i++) {
      struct object* obj = c->objects[i];
      if (obj) {
        assert(obj->oidx == i);
        if (!loc_is_zero(obj->grid))
          assert(pile_contains(square_object(c, obj->grid), obj));
      }
    }
  }
}
STATIC_OVL void
scatter(struct chunk* c, struct loc* place, struct loc grid, int d,
        bool need_los)
{
  (void)scatter_ext(c, place, 1, grid, d, need_los, NULL);
}
STATIC_OVL int
scatter_ext(struct chunk* c, struct loc* places, int n, struct loc grid, int d,
            bool need_los, bool (*pred)(struct chunk*, struct loc))
{
  int result = 0;
  struct loc* feas =
      mem_alloc(MIN(c->width, (1 + 2 * MAX(0, d))) *
                (size_t)MIN(c->height, (1 + 2 * MAX(0, d))) * sizeof(*feas));
  int nfeas = 0;
  struct loc g;
  for (g.y = grid.y - d; g.y <= grid.y + d; ++g.y) {
    for (g.x = grid.x - d; g.x <= grid.x + d; ++g.x) {
      if (!square_in_bounds_fully(c, g)) continue;
      if (d > 1 && distance(grid, g) > d) continue;
      if (need_los && !los(c, grid, g)) continue;
      if (pred && !(*pred)(c, g)) continue;
      feas[nfeas] = g;
      ++nfeas;
    }
  }
  while (result < n && nfeas > 0) {
    int choice = randint0(nfeas);
    places[result] = feas[choice];
    ++result;
    --nfeas;
    feas[choice] = feas[nfeas];
  }
  mem_free(feas);
  return result;
}
STATIC_OVL struct monster*
cave_monster(struct chunk* c, int idx)
{
  if (idx <= 0) return NULL;
  return &c->monsters[idx];
}
STATIC_OVL int
cave_monster_max(struct chunk* c)
{
  return c->mon_max;
}
STATIC_OVL int
cave_monster_count(struct chunk* c)
{
  return c->mon_cnt;
}
STATIC_OVL int
count_feats(struct loc* grid, bool (*test)(struct chunk* c, struct loc grid),
            bool under)
{
  int d;
  struct loc grid1;
  int count = 0;
  for (d = 0; d < 9; d++) {
    if ((d == 8) && !under) continue;
    grid1 = loc_sum(player->grid, ddgrid_ddd[d]);
    if (!square_in_bounds_fully(cave, grid1)) continue;
    if (!square_isknown(cave, grid1)) continue;
    if (!((*test)(cave, grid1))) continue;
    ++count;
    if (grid) {
      *grid = grid1;
    }
  }
  return count;
}
STATIC_OVL int
count_neighbors(struct loc* match, struct chunk* c, struct loc grid,
                bool (*test)(struct chunk* c, struct loc grid), bool under)
{
  int dlim = (under) ? 9 : 8;
  int count = 0;
  int d;
  struct loc grid1;
  for (d = 0; d < dlim; d++) {
    grid1 = loc_sum(grid, ddgrid_ddd[d]);
    if (!square_in_bounds(c, grid1)) continue;
    if (!((*test)(c, grid1))) continue;
    ++count;
    if (match) {
      *match = grid1;
    }
  }
  return count;
}
bool (*ang_sort_comp)(const void* u, const void* v, int a, int b);
void (*ang_sort_swap)(void* u, void* v, int a, int b);
static bool
ang_sort_comp_hook_longs(const void* u, const void* v, int a, int b)
{
  long* x = (long*)(u);
  (void)v;
  return (x[a] <= x[b]);
}
STATIC_OVL void
ang_sort_swap_hook_longs(void* u, void* v, int a, int b)
{
  long* x = (long*)(u);
  long temp;
  (void)v;
  temp = x[a];
  x[a] = x[b];
  x[b] = temp;
}
STATIC_OVL void
ang_sort_aux(void* u, void* v, int p, int q)
{
  int z, a, b;
  if (p >= q) return;
  z = p;
  a = p;
  b = q;
  while (true) {
    while (!(*ang_sort_comp)(u, v, b, z)) b--;
    while (!(*ang_sort_comp)(u, v, z, a)) a++;
    if (a >= b) break;
    (*ang_sort_swap)(u, v, a, b);
    a++, b--;
  }
  ang_sort_aux(u, v, p, b);
  ang_sort_aux(u, v, b + 1, q);
}
STATIC_OVL void
ang_sort(void* u, void* v, int n)
{
  ang_sort_aux(u, v, 0, n - 1);
}
STATIC_OVL void
vinfo_init_aux(struct vinfo_hack* hack, int y, int x, long m)
{
  int i;
  if ((m > 0) && (m <= 100000L)) {
    for (i = 0; i < hack->num_slopes; i++) {
      if (hack->slopes[i] == m) break;
    }
    if (i == hack->num_slopes) {
      if (hack->num_slopes >= 126) {
        quit_fmt("Too many LOS slopes (%d)!", 126);
      }
      hack->slopes[hack->num_slopes++] = m;
    }
  }
  if (hack->slopes_min[y][x] > m) hack->slopes_min[y][x] = m;
  if (hack->slopes_max[y][x] < m) hack->slopes_max[y][x] = m;
}
STATIC_OVL errr
vinfo_init(void)
{
  int i, g;
  int y, x;
  long m;
  struct vinfo_hack* hack;
  int num_grids = 0;
  int queue_head = 0;
  int queue_tail = 0;
  struct vinfo_type* queue[161 * 2];
  hack = mem_zalloc(sizeof(*hack));
  for (y = 0; y <= 20; ++y) {
    for (x = y; x <= 20; ++x) {
      if (distance(loc(0, 0), loc(x, y)) > 20) continue;
      hack->slopes_min[y][x] = 999999999;
      hack->slopes_max[y][x] = 0;
      if (num_grids >= 161) {
        quit_fmt("Too many grids (%d >= %d)!", num_grids, 161);
      }
      num_grids++;
      m = 100000L * (1000L * y - 500) / (1000L * x + 500);
      vinfo_init_aux(hack, y, x, m);
      m = 100000L * (1000L * y - 500) / (1000L * x - 500);
      vinfo_init_aux(hack, y, x, m);
      m = 100000L * (1000L * y + 500) / (1000L * x + 500);
      vinfo_init_aux(hack, y, x, m);
      m = 100000L * (1000L * y + 500) / (1000L * x - 500);
      vinfo_init_aux(hack, y, x, m);
    }
  }
  if (num_grids < 161) {
    quit_fmt("Too few grids (%d < %d)!", num_grids, 161);
  }
  if (hack->num_slopes < 126) {
    quit_fmt("Too few LOS slopes (%d < %d)!", hack->num_slopes, 126);
  }
  ang_sort_comp = ang_sort_comp_hook_longs;
  ang_sort_swap = ang_sort_swap_hook_longs;
  ang_sort(hack->slopes, NULL, hack->num_slopes);
  queue[queue_tail++] = &vinfo[0];
  while (queue_head < queue_tail) {
    int e;
    e = queue_head++;
    g = vinfo[e].grid[0];
    y = ((int)((g) / 256U));
    x = ((int)((g) % 256U));
    vinfo[e].grid[0] = (256 * (+y) + (+x));
    vinfo[e].grid[1] = (256 * (+x) + (+y));
    vinfo[e].grid[2] = (256 * (+x) + (-y));
    vinfo[e].grid[3] = (256 * (+y) + (-x));
    vinfo[e].grid[4] = (256 * (-y) + (-x));
    vinfo[e].grid[5] = (256 * (-x) + (-y));
    vinfo[e].grid[6] = (256 * (-x) + (+y));
    vinfo[e].grid[7] = (256 * (-y) + (+x));
    if (e > 0) {
      long slope_fire;
      long slope_min = 0;
      long slope_max = 999999L;
      uint8_t tmp0 = 0;
      uint8_t tmp1 = 0;
      uint8_t tmp2 = 0;
      if (x == 0)
        slope_fire = 100000L;
      else
        slope_fire = 100000L * (1000L * y) / (1000L * x);
      for (i = 0; i < hack->num_slopes; ++i) {
        m = hack->slopes[i];
        if ((hack->slopes_min[y][x] < m) && (hack->slopes_max[y][x] > m)) {
          switch (i / 32) {
            case 3:
              vinfo[e].bits_3 |= (1L << (i % 32));
              break;
            case 2:
              vinfo[e].bits_2 |= (1L << (i % 32));
              break;
            case 1:
              vinfo[e].bits_1 |= (1L << (i % 32));
              break;
            case 0:
              vinfo[e].bits_0 |= (1L << (i % 32));
              break;
          }
          if (m == slope_fire) {
            tmp0 = i;
          } else if ((m < slope_fire) && (m > slope_min)) {
            tmp1 = i;
            slope_min = m;
          } else if ((m > slope_fire) && (m < slope_max)) {
            tmp2 = i;
            slope_max = m;
          }
        }
      }
      if (tmp0) {
        vinfo[e].slope_fire_index1 = tmp0;
        vinfo[e].slope_fire_index2 = 0;
      } else {
        vinfo[e].slope_fire_index1 = tmp1;
        vinfo[e].slope_fire_index2 = tmp2;
      }
    }
    vinfo[e].next_0 = &vinfo[0];
    if (distance(loc(0, 0), loc(x + 1, y)) <= 20) {
      g = (256 * (y) + (x + 1));
      if (queue[queue_tail - 1]->grid[0] != g) {
        vinfo[queue_tail].grid[0] = g;
        queue[queue_tail] = &vinfo[queue_tail];
        queue_tail++;
      }
      vinfo[e].next_0 = &vinfo[queue_tail - 1];
    }
    vinfo[e].next_1 = &vinfo[0];
    if (distance(loc(0, 0), loc(x + 1, y + 1)) <= 20) {
      g = (256 * (y + 1) + (x + 1));
      if (queue[queue_tail - 1]->grid[0] != g) {
        vinfo[queue_tail].grid[0] = g;
        queue[queue_tail] = &vinfo[queue_tail];
        queue_tail++;
      }
      vinfo[e].next_1 = &vinfo[queue_tail - 1];
    }
    if (y == x) vinfo[e].next_0 = vinfo[e].next_1;
    vinfo[e].y = y;
    vinfo[e].x = x;
    vinfo[e].d = ((y > x) ? (y + x / 2) : (x + y / 2));
    vinfo[e].r = ((!y) ? x : (!x) ? y : (y == x) ? y : 0);
  }
  if (((vinfo[1].bits_3 | vinfo[2].bits_3) != 0x3FFFFFFF) ||
      ((vinfo[1].bits_2 | vinfo[2].bits_2) != 0xFFFFFFFF) ||
      ((vinfo[1].bits_1 | vinfo[2].bits_1) != 0xFFFFFFFF) ||
      ((vinfo[1].bits_0 | vinfo[2].bits_0) != 0xFFFFFFFF)) {
    quit("Incorrect bit masks!");
  }
  mem_free(hack);
  return (0);
}
STATIC_OVL int
loc_to_grid(struct loc grid)
{
  return (256 * (grid.y) + (grid.x));
}
STATIC_OVL struct loc
grid_to_loc(int grid)
{
  return loc(((int)((grid) % 256U)), ((int)((grid) / 256U)));
}
STATIC_OVL void
forget_fire(struct chunk* c)
{
  int i;
  if (!fire_n) return;
  for (i = 0; i < fire_n; i++) {
    int g;
    struct loc grid;
    g = fire_g[i];
    grid = grid_to_loc(g);
    sqinfo_off(square(c, grid)->info, SQUARE_FIRE);
    fire_info[g] = false;
  }
  fire_n = 0;
}
STATIC_OVL void
update_fire(struct chunk* c, struct player* p)
{
  int i, g, o2;
  struct loc grid;
  bool in_pit = square_ispit(c, p->grid) && !p->upkeep->leaping;
  forget_fire(c);
  g = loc_to_grid(p->grid);
  fire_info[g] = true;
  sqinfo_on(square(c, p->grid)->info, SQUARE_FIRE);
  fire_g[fire_n++] = g;
  for (o2 = 0; o2 < 8; o2++) {
    struct vinfo_type* point;
    struct vinfo_type* last = &vinfo[0];
    int queue_head = 0;
    int queue_tail = 0;
    struct vinfo_type* queue[161 * 2];
    uint32_t bits0 = 0xFFFFFFFF;
    uint32_t bits1 = 0xFFFFFFFF;
    uint32_t bits2 = 0xFFFFFFFF;
    uint32_t bits3 = 0x3FFFFFFF;
    queue_head = queue_tail = 0;
    queue[queue_tail++] = &vinfo[1];
    queue[queue_tail++] = &vinfo[2];
    while (queue_head < queue_tail) {
      bool line_fire = false;
      point = queue[queue_head++];
      if ((bits0 & (point->bits_0)) || (bits1 & (point->bits_1)) ||
          (bits2 & (point->bits_2)) || (bits3 & (point->bits_3))) {
        bool new = false;
        g = loc_to_grid(p->grid) + point->grid[o2];
        grid = grid_to_loc(g);
        new = fire_info[g];
        if (!square_in_bounds_fully(c, grid)) continue;
        if (in_pit && (distance(grid, p->grid) > 1)) {
          continue;
        }
        i = point->slope_fire_index1;
        while (true) {
          switch (i / 32) {
            case 3: {
              if (bits3 & (1L << (i % 32))) line_fire = true;
              break;
            }
            case 2: {
              if (bits2 & (1L << (i % 32))) line_fire = true;
              break;
            }
            case 1: {
              if (bits1 & (1L << (i % 32))) line_fire = true;
              break;
            }
            case 0: {
              if (bits0 & (1L << (i % 32))) line_fire = true;
              break;
            }
          }
          if ((!point->slope_fire_index2) || (line_fire) ||
              (i == point->slope_fire_index2)) {
            break;
          }
          i = point->slope_fire_index2;
        }
        if (line_fire) {
          fire_info[g] = true;
          sqinfo_on(square(c, grid)->info, SQUARE_FIRE);
          if (new) {
            fire_g[fire_n++] = g;
          }
          if (square_iswall(c, grid)) {
            bits0 &= ~(point->bits_0);
            bits1 &= ~(point->bits_1);
            bits2 &= ~(point->bits_2);
            bits3 &= ~(point->bits_3);
          } else {
            if (last != point->next_0) {
              queue[queue_tail++] = last = point->next_0;
            }
            if (last != point->next_1) {
              queue[queue_tail++] = last = point->next_1;
            }
          }
        }
      }
    }
  }
}
STATIC_OVL int
project_path(struct chunk* c, struct loc* gp, int range, struct loc grid1,
             struct loc* grid2, int flg)
{
  int i, j, k;
  int dy, dx;
  int num, dist, octant;
  int n_grids = 0;
  bool line_fire;
  bool full_stop = false;
  struct loc grid_a, grid_b;
  struct loc grid = loc(0, 0), old_grid = loc(0, 0);
  uint32_t bits0 = 0xFFFFFFFF;
  uint32_t bits1 = 0xFFFFFFFF;
  uint32_t bits2 = 0xFFFFFFFF;
  uint32_t bits3 = 0x3FFFFFFF;
  int slope_fire1 = -1, slope_fire2 = 0;
  bool vertical = false;
  struct loc tmp_grids[80];
  int step;
  int blockage[2];
  bool monster_in_way = false;
  int16_t g0 = loc_to_grid(grid1);
  int16_t g;
  struct vinfo_type* point;
  if ((range <= 0) || loc_eq(grid1, *grid2)) return 0;
  dy = (*grid2).y - grid1.y;
  dx = (*grid2).x - grid1.x;
  dist = distance(grid1, *grid2);
  if ((dist > z_info->max_sight) && !(flg & PROJECT_LEAVE)) {
    int round_y = (dy < 0 ? -(dist / 2) : (dist / 2));
    int round_x = (dx < 0 ? -(dist / 2) : (dist / 2));
    dy = ((dy * (z_info->max_sight - 1)) + round_y) / dist;
    dx = ((dx * (z_info->max_sight - 1)) + round_x) / dist;
    *grid2 = loc_sum(grid1, loc(dx, dy));
  }
  if (dy < 0) {
    if (dx < 0) {
      if (ABS(dy) > ABS(dx)) {
        octant = 5;
        vertical = true;
      } else {
        octant = 4;
      }
    } else {
      if (ABS(dy) > ABS(dx)) {
        octant = 6;
        vertical = true;
      } else {
        octant = 7;
      }
    }
  } else {
    if (dx < 0) {
      if (ABS(dy) > ABS(dx)) {
        octant = 2;
        vertical = true;
      } else {
        octant = 3;
      }
    } else {
      if (ABS(dy) > ABS(dx)) {
        octant = 1;
        vertical = true;
      } else {
        octant = 0;
      }
    }
  }
  for (j = 1; j < 161; j++) {
    int16_t vy, vx;
    point = &vinfo[j];
    g = g0 + point->grid[octant];
    vy = ((int)((g) / 256U));
    vx = ((int)((g) % 256U));
    if (vy > 256 * 127) {
      vy = vy - (256 * 256);
    }
    if (vx > grid1.x + 127) {
      vy++;
      vx = vx - 256;
    }
    if ((vy != (*grid2).y) || (vx != (*grid2).x)) continue;
    slope_fire1 = point->slope_fire_index1;
    slope_fire2 = point->slope_fire_index2;
    break;
  }
  if (slope_fire1 == -1) return (0);
  for (j = 1; j < 161; j++) {
    line_fire = false;
    point = &vinfo[j];
    if (!((bits0 & (point->bits_0)) || (bits1 & (point->bits_1)) ||
          (bits2 & (point->bits_2)) || (bits3 & (point->bits_3)))) {
      continue;
    }
    g = g0 + point->grid[octant];
    grid = grid_to_loc(g);
    if (!square_in_bounds_fully(c, grid)) continue;
    i = slope_fire1;
    while (true) {
      switch (i / 32) {
        case 3: {
          if (bits3 & (1L << (i % 32))) {
            if (point->bits_3 & (1L << (i % 32))) line_fire = true;
          }
          break;
        }
        case 2: {
          if (bits2 & (1L << (i % 32))) {
            if (point->bits_2 & (1L << (i % 32))) line_fire = true;
          }
          break;
        }
        case 1: {
          if (bits1 & (1L << (i % 32))) {
            if (point->bits_1 & (1L << (i % 32))) line_fire = true;
          }
          break;
        }
        case 0: {
          if (bits0 & (1L << (i % 32))) {
            if (point->bits_0 & (1L << (i % 32))) line_fire = true;
          }
          break;
        }
      }
      if ((!slope_fire2) || (i == slope_fire2)) break;
      i = slope_fire2;
    }
    if (line_fire) {
      if (n_grids && distance(grid, old_grid) > 1) {
        break;
      }
      tmp_grids[n_grids++] = grid_to_loc(g);
      old_grid = grid;
    }
    if (!(flg & (PROJECT_PASS)) && square_iswall(c, grid)) {
      if (!(flg & (PROJECT_INVIS)) || square_isknown(c, grid)) {
        bits0 &= ~(point->bits_0);
        bits1 &= ~(point->bits_1);
        bits2 &= ~(point->bits_2);
        bits3 &= ~(point->bits_3);
      }
    }
  }
  for (step = 0, j = 0; j < n_grids;) {
    grid_a = tmp_grids[j];
    if (j < n_grids - 1) {
      grid_b = tmp_grids[j + 1];
    } else {
      grid_b = loc(-1, -1);
    }
    if (vertical ? grid_a.y == grid_b.y : grid_a.x == grid_b.x) {
      num = 2;
    } else {
      num = 1;
    }
    for (i = 0; i < num; i++) {
      blockage[i] = 0;
      grid = i == 0 ? grid_a : grid_b;
      k = (vertical ? ABS(grid.x - grid1.x) : ABS(grid.y - grid1.y));
      if ((i == num - 1) && (step + (k >> 1)) >= range - 1) {
        full_stop = true;
      }
      if (!(flg & (PROJECT_THRU))) {
        if (loc_eq(grid, *grid2)) {
          full_stop = true;
        }
      }
      if (!(flg & (PROJECT_PASS)) &&
          (!(flg & (PROJECT_INVIS)) || square_isknown(c, grid))) {
        if (!square_isprojectable(c, grid)) {
          blockage[i] = 2;
        }
      } else if (!square_in_bounds_fully(c, grid)) {
        full_stop = true;
        blockage[i] = 3;
      }
      if ((square_monster(c, grid) || square_isplayer(c, grid)) &&
          (blockage[i] < 2)) {
        if (!loc_eq(c->project_path_ignore, grid)) {
          if (flg & (PROJECT_STOP)) {
            blockage[i] = 2;
          } else if (flg & (PROJECT_CHCK)) {
            blockage[i] = 1;
          }
        }
      }
    }
    if ((num == 1) || (blockage[0] <= blockage[1])) {
      if (blockage[0] < 3) gp[step++] = tmp_grids[j];
      if (blockage[0] >= 2) break;
      if (blockage[0] == 1) {
        if (!loc_eq(grid, *grid2)) monster_in_way = true;
      }
      if (full_stop) break;
    } else {
      if (blockage[1] < 3) gp[step++] = tmp_grids[j + 1];
      if (blockage[1] >= 2) break;
      if (blockage[1] == 1) {
        if (!loc_eq(grid, *grid2)) monster_in_way = true;
      }
      if (full_stop) break;
    }
    j += num;
  }
  if (!(flg & PROJECT_LEAVE)) *grid2 = gp[step - 1];
  if (monster_in_way) return -step;
  return step;
}
STATIC_OVL void
map_info(struct loc grid, struct grid_data* g)
{
  struct object* obj;
  assert(grid.x < cave->width);
  assert(grid.y < cave->height);
  g->first_kind = NULL;
  g->first_art = NULL;
  g->trap = NULL;
  g->multiple_objects = false;
  g->glow = false;
  g->lighting = LIGHTING_LIT;
  g->f_idx = square(cave, grid)->feat;
  if (f_info[g->f_idx].mimic)
    g->f_idx = (uint32_t)(f_info[g->f_idx].mimic - f_info);
  g->in_view = (square_isseen(cave, grid)) ? true : false;
  g->is_player = (square(cave, grid)->mon < 0) ? true : false;
  g->m_idx = (g->is_player) ? 0 : square(cave, grid)->mon;
  g->hallucinate = player->timed[TMD_IMAGE] ? true : false;
  g->rage = player->timed[TMD_RAGE] ? true : false;
  if (square_isglow(cave, grid)) {
    g->lighting = LIGHTING_LIT;
  }
  if (g->in_view) {
    bool lit = square_islit(cave, grid);
    if (lit) {
      g->lighting = LIGHTING_LOS;
    }
    square_memorize(cave, grid);
  } else if (g->rage) {
    g->f_idx = FEAT_NONE;
    g->m_idx = 0;
    return;
  } else if (!square_isknown(cave, grid)) {
    g->f_idx = FEAT_NONE;
  }
  g->f_idx = square(player->cave, grid)->feat;
  if (f_info[g->f_idx].mimic)
    g->f_idx = (uint32_t)(f_info[g->f_idx].mimic - f_info);
  if (square_trap(player->cave, grid) && square_isknown(cave, grid)) {
    struct trap* trap = square(player->cave, grid)->trap;
    while (trap) {
      if (trf_has(trap->flags, TRF_TRAP) || trf_has(trap->flags, TRF_GLYPH)) {
        g->trap = trap;
        break;
      }
      trap = trap->next;
    }
  }
  for (obj = square_object(player->cave, grid); obj; obj = obj->next) {
    if (ignore_known_item_ok(player, obj)) {
    } else if (!g->first_kind) {
      struct object* base_obj = cave->objects[obj->oidx];
      g->first_kind = obj->kind;
      g->first_art = obj->artifact;
      assert(base_obj);
      g->glow = loc_eq(obj->grid, base_obj->grid) && weapon_glows(base_obj, 0);
    } else {
      g->multiple_objects = true;
      break;
    }
  }
  if (g->m_idx > 0) {
    struct monster* mon = cave_monster(cave, g->m_idx);
    if (!monster_is_visible(mon) && !monster_is_listened(mon)) g->m_idx = 0;
  }
  if (g->hallucinate && g->m_idx == 0 && g->first_kind == 0) {
    if (one_in_(128) && (int)g->f_idx != FEAT_PERM)
      g->m_idx = z_info->r_max + 1;
    else if (one_in_(128) && (int)g->f_idx != FEAT_PERM)
      g->first_kind = k_info;
    else
      g->hallucinate = false;
  }
  assert((int)g->f_idx < FEAT_MAX);
  if (!g->hallucinate) assert((int)g->m_idx < cave->mon_max);
}
STATIC_OVL void
square_note_spot(struct chunk* c, struct loc grid)
{
  if (c != cave) return;
  if (!square_isseen(c, grid) && !square_isplayer(c, grid)) return;
  square_know_pile(c, grid);
  if (square_issecrettrap(c, grid)) {
    square_reveal_trap(c, grid, true);
  }
  square_memorize_traps(c, grid);
  if (!square_ismemorybad(c, grid)) return;
  square_memorize(c, grid);
}
STATIC_OVL void
square_light_spot(struct chunk* c, struct loc grid)
{
  if ((c == cave) && player->cave) {
    player->upkeep->redraw |= PR_ITEMLIST;
    event_signal_point(EVENT_MAP, grid.x, grid.y);
  }
}
STATIC_OVL void
cave_unlight(struct point_set* ps)
{
  int i;
  for (i = 0; i < ps->n; i++) {
    struct loc grid = ps->pts[i];
    sqinfo_off(square(cave, ps->pts[i])->info, SQUARE_GLOW);
    if (square_isfloor(cave, grid)) square_unmark(cave, grid);
  }
  for (i = 0; i < ps->n; i++) {
    square_light_spot(cave, ps->pts[i]);
  }
}
STATIC_OVL void
cave_room_aux(struct point_set* seen, struct loc grid)
{
  if (point_set_contains(seen, grid)) return;
  if (!square_in_bounds(cave, grid)) return;
  if (!square_isroom(cave, grid)) return;
  add_to_point_set(seen, grid);
}
STATIC_OVL void
light_room(struct loc grid, bool light)
{
  int i, d;
  struct point_set* ps;
  ps = point_set_new(200);
  cave_room_aux(ps, grid);
  for (i = 0; i < ps->n; i++) {
    if (!square_isprojectable(cave, ps->pts[i])) continue;
    for (d = 0; d < 8; d++) {
      cave_room_aux(ps, loc_sum(ps->pts[i], ddgrid_ddd[d]));
    }
  }
  if (!light) {
    cave_unlight(ps);
  }
  point_set_dispose(ps);
  player->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
  update_stuff(player);
}
STATIC_OVL void
wiz_light(struct chunk* c, struct player* p)
{
  int i, y, x;
  for (y = 1; y < c->height - 1; y++) {
    for (x = 1; x < c->width - 1; x++) {
      struct loc grid = loc(x, y);
      if (!square_seemslikewall(c, grid)) {
        if (!square_in_bounds_fully(c, grid)) continue;
        for (i = 0; i < 9; i++) {
          struct loc a_grid = loc_sum(grid, ddgrid_ddd[i]);
          sqinfo_on(square(c, a_grid)->info, SQUARE_GLOW);
          if (!square_isfloor(c, a_grid) || square_isvisibletrap(c, a_grid)) {
            square_memorize(c, a_grid);
            square_mark(c, a_grid);
          }
        }
      }
      square_know_pile(c, grid);
      if (!square_ismark(c, grid) && square_ismemorybad(c, grid))
        square_forget(c, grid);
    }
  }
  for (y = 1; y < c->height - 1; y++) {
    for (x = 1; x < c->width - 1; x++) {
      struct loc grid = loc(x, y);
      if (!square_in_bounds(c, grid)) continue;
      square_unmark(c, grid);
    }
  }
  p->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
  p->upkeep->redraw |= (PR_MAP | PR_MONLIST | PR_ITEMLIST);
}
STATIC_OVL void
wiz_dark(struct chunk* c, struct player* p)
{
  int y, x;
  assert(c == cave);
  for (y = 1; y < c->height - 1; y++) {
    for (x = 1; x < c->width - 1; x++) {
      struct loc grid = loc(x, y);
      struct object* obj = square_object(p->cave, grid);
      square_forget(c, grid);
      sqinfo_off(square(c, grid)->info, SQUARE_SEEN);
      while (obj) {
        struct object* base = cave->objects[obj->oidx];
        struct object* next = obj->next;
        assert(base && base->known == obj);
        square_excise_object(p->cave, grid, obj);
        delist_object(p->cave, obj);
        object_delete(p->cave, NULL, &obj);
        base->known = NULL;
        obj = next;
      }
    }
  }
  p->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
  p->upkeep->redraw |= (PR_MAP | PR_MONLIST | PR_ITEMLIST);
}
STATIC_OVL bool
feat_is_rock(int feat)
{
  return tf_has(f_info[feat].flags, TF_ROCK);
}
STATIC_OVL bool
feat_is_quartz(int feat)
{
  return tf_has(f_info[feat].flags, TF_QUARTZ);
}
STATIC_OVL bool
feat_is_granite(int feat)
{
  return tf_has(f_info[feat].flags, TF_GRANITE);
}
STATIC_OVL bool
feat_is_wall(int feat)
{
  return tf_has(f_info[feat].flags, TF_WALL);
}
STATIC_OVL bool
feat_is_floor(int feat)
{
  return tf_has(f_info[feat].flags, TF_FLOOR);
}
STATIC_OVL bool
feat_is_trap_holding(int feat)
{
  return tf_has(f_info[feat].flags, TF_TRAP);
}
STATIC_OVL bool
feat_is_object_holding(int feat)
{
  return tf_has(f_info[feat].flags, TF_OBJECT);
}
STATIC_OVL bool
feat_is_monster_walkable(int feat)
{
  return tf_has(f_info[feat].flags, TF_PASSABLE);
}
STATIC_OVL bool
feat_is_forge(int feat)
{
  return tf_has(f_info[feat].flags, TF_FORGE);
}
STATIC_OVL bool
feat_is_los(int feat)
{
  return tf_has(f_info[feat].flags, TF_LOS);
}
STATIC_OVL bool
feat_is_passable(int feat)
{
  return tf_has(f_info[feat].flags, TF_PASSABLE);
}
STATIC_OVL bool
feat_is_projectable(int feat)
{
  return tf_has(f_info[feat].flags, TF_PROJECT);
}
STATIC_OVL bool
feat_is_torch(int feat)
{
  return tf_has(f_info[feat].flags, TF_TORCH);
}
STATIC_OVL bool
feat_is_pit(int feat)
{
  return tf_has(f_info[feat].flags, TF_PIT);
}
STATIC_OVL bool
feat_is_no_flow(int feat)
{
  return tf_has(f_info[feat].flags, TF_NO_FLOW);
}
STATIC_OVL bool
feat_is_no_scent(int feat)
{
  return tf_has(f_info[feat].flags, TF_NO_SCENT);
}
STATIC_OVL bool
feat_is_chasm(int feat)
{
  return tf_has(f_info[feat].flags, TF_CHASM);
}
STATIC_OVL bool
square_isfloor(struct chunk* c, struct loc grid)
{
  return feat_is_floor(square(c, grid)->feat);
}
STATIC_OVL bool
square_istrappable(struct chunk* c, struct loc grid)
{
  return feat_is_trap_holding(square(c, grid)->feat);
}
STATIC_OVL bool
square_isobjectholding(struct chunk* c, struct loc grid)
{
  return feat_is_object_holding(square(c, grid)->feat);
}
STATIC_OVL bool
square_isgranitewall(struct chunk* c, struct loc grid)
{
  return (tf_has(f_info[square(c, grid)->feat].flags, TF_GRANITE) &&
          !tf_has(f_info[square(c, grid)->feat].flags, TF_DOOR_ANY));
}
STATIC_OVL bool
square_isgranite(struct chunk* c, struct loc grid)
{
  return feat_is_granite(square(c, grid)->feat);
}
STATIC_OVL bool
square_isperm(struct chunk* c, struct loc grid)
{
  return (tf_has(f_info[square(c, grid)->feat].flags, TF_PERMANENT) &&
          tf_has(f_info[square(c, grid)->feat].flags, TF_ROCK));
}
STATIC_OVL bool
square_isrock(struct chunk* c, struct loc grid)
{
  return feat_is_rock(square(c, grid)->feat);
}
STATIC_OVL bool
square_isquartz(struct chunk* c, struct loc grid)
{
  return feat_is_quartz(square(c, grid)->feat);
}
STATIC_OVL bool
square_ismineral(struct chunk* c, struct loc grid)
{
  return square_isgranitewall(c, grid) || square_isquartz(c, grid);
}
STATIC_OVL bool
square_isrubble(struct chunk* c, struct loc grid)
{
  return (tf_has(f_info[square(c, grid)->feat].flags, TF_ROCK) &&
          !tf_has(f_info[square(c, grid)->feat].flags, TF_DOOR_ANY) &&
          !tf_has(f_info[square(c, grid)->feat].flags, TF_WALL));
}
STATIC_OVL bool
square_issecretdoor(struct chunk* c, struct loc grid)
{
  return (tf_has(f_info[square(c, grid)->feat].flags, TF_DOOR_ANY) &&
          tf_has(f_info[square(c, grid)->feat].flags, TF_ROCK));
}
STATIC_OVL bool
square_isopendoor(struct chunk* c, struct loc grid)
{
  return (tf_has(f_info[square(c, grid)->feat].flags, TF_CLOSABLE));
}
STATIC_OVL bool
square_iscloseddoor(struct chunk* c, struct loc grid)
{
  int feat = square(c, grid)->feat;
  return tf_has(f_info[feat].flags, TF_DOOR_CLOSED);
}
STATIC_OVL bool
square_isbrokendoor(struct chunk* c, struct loc grid)
{
  int feat = square(c, grid)->feat;
  return (tf_has(f_info[feat].flags, TF_DOOR_ANY) &&
          tf_has(f_info[feat].flags, TF_PASSABLE) &&
          !tf_has(f_info[feat].flags, TF_CLOSABLE));
}
STATIC_OVL bool
square_isdoor(struct chunk* c, struct loc grid)
{
  int feat = square(c, grid)->feat;
  return tf_has(f_info[feat].flags, TF_DOOR_ANY);
}
STATIC_OVL bool
square_iswall(struct chunk* c, struct loc grid)
{
  int feat = square(c, grid)->feat;
  return tf_has(f_info[feat].flags, TF_DOOR_CLOSED) ||
         tf_has(f_info[feat].flags, TF_ROCK);
}
STATIC_OVL bool
square_isstairs(struct chunk* c, struct loc grid)
{
  int feat = square(c, grid)->feat;
  return tf_has(f_info[feat].flags, TF_STAIR);
}
STATIC_OVL bool
square_isupstairs(struct chunk* c, struct loc grid)
{
  int feat = square(c, grid)->feat;
  return tf_has(f_info[feat].flags, TF_UPSTAIR);
}
STATIC_OVL bool
square_isdownstairs(struct chunk* c, struct loc grid)
{
  int feat = square(c, grid)->feat;
  return tf_has(f_info[feat].flags, TF_DOWNSTAIR);
}
STATIC_OVL bool
square_isshaft(struct chunk* c, struct loc grid)
{
  int feat = square(c, grid)->feat;
  return tf_has(f_info[feat].flags, TF_SHAFT);
}
STATIC_OVL bool
square_isforge(struct chunk* c, struct loc grid)
{
  return feat_is_forge(square(c, grid)->feat);
}
STATIC_OVL bool
square_isplayer(struct chunk* c, struct loc grid)
{
  return square(c, grid)->mon < 0 ? true : false;
}
STATIC_OVL bool
square_isoccupied(struct chunk* c, struct loc grid)
{
  return square(c, grid)->mon != 0 ? true : false;
}
STATIC_OVL bool
square_isimpassable(struct chunk* c, struct loc grid)
{
  return square_ischasm(c, grid) || square_isrock(c, grid);
}
STATIC_OVL bool
square_isknown(struct chunk* c, struct loc grid)
{
  if (c != cave && (!player || c != player->cave)) return false;
  if (!player->cave) return false;
  return square(player->cave, grid)->feat == FEAT_NONE ? false : true;
}
STATIC_OVL bool
square_ismemorybad(struct chunk* c, struct loc grid)
{
  return !square_isknown(c, grid) ||
         square(player->cave, grid)->feat != square(cave, grid)->feat;
}
STATIC_OVL bool
square_ischasm(struct chunk* c, struct loc grid)
{
  return feat_is_chasm(square(c, grid)->feat);
}
STATIC_OVL bool
square_ismark(struct chunk* c, struct loc grid)
{
  assert(square_in_bounds(c, grid));
  return sqinfo_has(square(c, grid)->info, SQUARE_MARK);
}
STATIC_OVL bool
square_isglow(struct chunk* c, struct loc grid)
{
  assert(square_in_bounds(c, grid));
  return sqinfo_has(square(c, grid)->info, SQUARE_GLOW);
}
STATIC_OVL bool
square_isvault(struct chunk* c, struct loc grid)
{
  assert(square_in_bounds(c, grid));
  return sqinfo_has(square(c, grid)->info, SQUARE_VAULT);
}
STATIC_OVL bool
square_isgreatervault(struct chunk* c, struct loc grid)
{
  assert(square_in_bounds(c, grid));
  return sqinfo_has(square(c, grid)->info, SQUARE_G_VAULT);
}
STATIC_OVL bool
square_isroom(struct chunk* c, struct loc grid)
{
  assert(square_in_bounds(c, grid));
  return sqinfo_has(square(c, grid)->info, SQUARE_ROOM);
}
STATIC_OVL bool
square_isseen(struct chunk* c, struct loc grid)
{
  assert(square_in_bounds(c, grid));
  return sqinfo_has(square(c, grid)->info, SQUARE_SEEN);
}
STATIC_OVL bool
square_isview(struct chunk* c, struct loc grid)
{
  assert(square_in_bounds(c, grid));
  return sqinfo_has(square(c, grid)->info, SQUARE_VIEW);
}
STATIC_OVL bool
square_isfire(struct chunk* c, struct loc grid)
{
  assert(square_in_bounds(c, grid));
  return sqinfo_has(square(c, grid)->info, SQUARE_FIRE);
}
STATIC_OVL bool
square_wasseen(struct chunk* c, struct loc grid)
{
  assert(square_in_bounds(c, grid));
  return sqinfo_has(square(c, grid)->info, SQUARE_WASSEEN);
}
STATIC_OVL bool
square_istrap(struct chunk* c, struct loc grid)
{
  assert(square_in_bounds(c, grid));
  return sqinfo_has(square(c, grid)->info, SQUARE_TRAP);
}
STATIC_OVL bool
square_isinvis(struct chunk* c, struct loc grid)
{
  assert(square_in_bounds(c, grid));
  return sqinfo_has(square(c, grid)->info, SQUARE_INVIS);
}
STATIC_OVL bool
square_iswall_inner(struct chunk* c, struct loc grid)
{
  assert(square_in_bounds(c, grid));
  return sqinfo_has(square(c, grid)->info, SQUARE_WALL_INNER);
}
STATIC_OVL bool
square_iswall_outer(struct chunk* c, struct loc grid)
{
  assert(square_in_bounds(c, grid));
  return sqinfo_has(square(c, grid)->info, SQUARE_WALL_OUTER);
}
STATIC_OVL bool
square_iswall_solid(struct chunk* c, struct loc grid)
{
  assert(square_in_bounds(c, grid));
  return sqinfo_has(square(c, grid)->info, SQUARE_WALL_SOLID);
}
STATIC_OVL bool
square_tobechasm(struct chunk* c, struct loc grid)
{
  assert(square_in_bounds(c, grid));
  return sqinfo_has(square(c, grid)->info, SQUARE_CHASM);
}
STATIC_OVL bool
square_isproject(struct chunk* c, struct loc grid)
{
  assert(square_in_bounds(c, grid));
  return sqinfo_has(square(c, grid)->info, SQUARE_PROJECT);
}
STATIC_OVL bool
square_isopen(struct chunk* c, struct loc grid)
{
  return square_isfloor(c, grid) && !square(c, grid)->mon;
}
STATIC_OVL bool
square_isempty(struct chunk* c, struct loc grid)
{
  if (square_isplayertrap(c, grid)) return false;
  if (square_iswebbed(c, grid)) return false;
  return square_isopen(c, grid) && !square_object(c, grid);
}
STATIC_OVL bool
square_isunseen(struct chunk* c, struct loc grid)
{
  if (square_isseen(cave, grid)) return false;
  return square_isempty(cave, grid);
}
STATIC_OVL bool
square_isarrivable(struct chunk* c, struct loc grid)
{
  if (square_iswall(c, grid)) return false;
  if (square_ischasm(c, grid)) return false;
  if (square(c, grid)->mon) return false;
  return true;
}
STATIC_OVL bool
square_canputitem(struct chunk* c, struct loc grid)
{
  if (!square_isobjectholding(c, grid)) return false;
  if (square_istrap(c, grid)) return false;
  return !square_object(c, grid);
}
STATIC_OVL bool
square_isdiggable(struct chunk* c, struct loc grid)
{
  return (square_ismineral(c, grid) || square_issecretdoor(c, grid) ||
          square_isrubble(c, grid));
}
STATIC_OVL bool
square_iswebbable(struct chunk* c, struct loc grid)
{
  if (square_trap(c, grid)) return false;
  return square_isfloor(c, grid);
}
STATIC_OVL bool
square_isleapable(struct chunk* c, struct loc grid)
{
  struct trap_kind* false_floor = lookup_trap("false floor");
  if (square_istrap(c, grid) &&
      square_trap_specific(c, grid, false_floor->tidx)) {
    return true;
  }
  if (square_ispit(c, grid)) return true;
  return square_ischasm(c, grid);
}
STATIC_OVL bool
square_is_monster_walkable(struct chunk* c, struct loc grid)
{
  assert(square_in_bounds(c, grid));
  return feat_is_monster_walkable(square(c, grid)->feat);
}
STATIC_OVL bool
square_ispassable(struct chunk* c, struct loc grid)
{
  assert(square_in_bounds(c, grid));
  return feat_is_passable(square(c, grid)->feat);
}
STATIC_OVL bool
square_isprojectable(struct chunk* c, struct loc grid)
{
  if (!square_in_bounds(c, grid)) return false;
  return feat_is_projectable(square(c, grid)->feat);
}
STATIC_OVL bool
square_allowslos(struct chunk* c, struct loc grid)
{
  assert(square_in_bounds(c, grid));
  return feat_is_los(square(c, grid)->feat);
}
STATIC_OVL bool
square_isstrongwall(struct chunk* c, struct loc grid)
{
  assert(square_in_bounds(c, grid));
  return square_ismineral(c, grid) || square_isperm(c, grid);
}
STATIC_OVL bool
square_ispit(struct chunk* c, struct loc grid)
{
  assert(square_in_bounds(c, grid));
  return feat_is_pit(square(c, grid)->feat);
}
STATIC_OVL bool
square_islit(struct chunk* c, struct loc grid)
{
  assert(square_in_bounds(c, grid));
  return square_light(c, grid) > 0 ? true : false;
}
STATIC_OVL bool
square_isnoflow(struct chunk* c, struct loc grid)
{
  assert(square_in_bounds(c, grid));
  return feat_is_no_flow(square(c, grid)->feat);
}
STATIC_OVL bool
square_isnoscent(struct chunk* c, struct loc grid)
{
  assert(square_in_bounds(c, grid));
  return feat_is_no_scent(square(c, grid)->feat);
}
STATIC_OVL bool
square_iswarded(struct chunk* c, struct loc grid)
{
  struct trap_kind* rune = lookup_trap("glyph of warding");
  return square_trap_specific(c, grid, rune->tidx);
}
STATIC_OVL bool
square_iswebbed(struct chunk* c, struct loc grid)
{
  struct trap_kind* web = lookup_trap("web");
  return square_trap_specific(c, grid, web->tidx);
}
STATIC_OVL bool
square_seemslikewall(struct chunk* c, struct loc grid)
{
  return tf_has(f_info[square(c, grid)->feat].flags, TF_ROCK);
}
STATIC_OVL bool
square_isinteresting(struct chunk* c, struct loc grid)
{
  int f = square(c, grid)->feat;
  return tf_has(f_info[f].flags, TF_INTERESTING);
}
STATIC_OVL bool
square_islockeddoor(struct chunk* c, struct loc grid)
{
  return square_door_lock_power(c, grid) > 0;
}
STATIC_OVL bool
square_isjammeddoor(struct chunk* c, struct loc grid)
{
  return square_door_jam_power(c, grid) > 0;
}
STATIC_OVL bool
square_isplayertrap(struct chunk* c, struct loc grid)
{
  return square_trap_flag(c, grid, TRF_TRAP);
}
STATIC_OVL bool
square_isvisibletrap(struct chunk* c, struct loc grid)
{
  return square_trap_flag(c, grid, TRF_VISIBLE);
}
STATIC_OVL bool
square_issecrettrap(struct chunk* c, struct loc grid)
{
  return !square_isvisibletrap(c, grid) && square_isplayertrap(c, grid);
}
STATIC_OVL bool
square_isdisarmabletrap(struct chunk* c, struct loc grid)
{
  return square_isvisibletrap(c, grid) && square_isplayertrap(c, grid);
}
STATIC_OVL bool
square_changeable(struct chunk* c, struct loc grid)
{
  struct object* obj;
  if (square_isperm(c, grid) || square_isforge(c, grid) ||
      square_isstairs(c, grid)) {
    return false;
  }
  for (obj = square_object(c, grid); obj; obj = obj->next) {
    if (of_has(obj->flags, OF_INDESTRUCTIBLE)) return false;
  }
  return true;
}
STATIC_OVL bool
square_in_bounds(struct chunk* c, struct loc grid)
{
  assert(c);
  return grid.x >= 0 && grid.x < c->width && grid.y >= 0 && grid.y < c->height;
}
STATIC_OVL bool
square_in_bounds_fully(struct chunk* c, struct loc grid)
{
  assert(c);
  return grid.x > 0 && grid.x < c->width - 1 && grid.y > 0 &&
         grid.y < c->height - 1;
}
STATIC_OVL bool
square_isbelievedwall(struct chunk* c, struct loc grid)
{
  if (!square_in_bounds_fully(c, grid)) return true;
  if (!square_isknown(c, grid)) return false;
  return !square_isprojectable(player->cave, grid);
}
STATIC_OVL bool
square_suits_start(struct chunk* c, struct loc grid)
{
  return square_isempty(c, grid) && !square_isvault(c, grid);
}
STATIC_OVL bool
square_suits_stairs(struct chunk* c, struct loc grid)
{
  if (!square_isempty(c, grid) || !square_isroom(c, grid)) return false;
  return !square_num_doors_adjacent(c, grid);
}
STATIC_OVL bool
square_allows_summon(struct chunk* c, struct loc grid)
{
  return square_isempty(c, grid) && !square_iswarded(c, grid);
}
STATIC_OVL bool
square_seen_by_keen_senses(struct chunk* c, struct loc grid)
{
  if (player_active_ability(player, "Keen Senses") && square_isview(c, grid) &&
      (square_light(c, grid) == 0)) {
    int d;
    for (d = 0; d < 8; d++) {
      struct loc grid1 = loc_sum(grid, ddgrid_ddd[d]);
      if (!square_in_bounds(c, grid1)) continue;
      if ((square_light(c, grid1) > 0) && square_isfloor(c, grid1) &&
          square_isview(c, grid1)) {
        return true;
      }
    }
  }
  return false;
}
STATIC_OVL const struct square*
square(struct chunk* c, struct loc grid)
{
  assert(square_in_bounds(c, grid));
  return &c->squares[grid.y][grid.x];
}
STATIC_OVL struct feature*
square_feat(struct chunk* c, struct loc grid)
{
  assert(square_in_bounds(c, grid));
  return &f_info[square(c, grid)->feat];
}
STATIC_OVL int
square_light(struct chunk* c, struct loc grid)
{
  assert(square_in_bounds(c, grid));
  return square(c, grid)->light;
}
STATIC_OVL struct monster*
square_monster(struct chunk* c, struct loc grid)
{
  if (!square_in_bounds(c, grid)) return NULL;
  if (square(c, grid)->mon > 0) {
    struct monster* mon = cave_monster(c, square(c, grid)->mon);
    return mon && mon->race ? mon : NULL;
  }
  return NULL;
}
STATIC_OVL struct object*
square_object(struct chunk* c, struct loc grid)
{
  if (!square_in_bounds(c, grid)) return NULL;
  return square(c, grid)->obj;
}
STATIC_OVL struct trap*
square_trap(struct chunk* c, struct loc grid)
{
  if (!square_in_bounds(c, grid)) return NULL;
  return square(c, grid)->trap;
}
STATIC_OVL bool
square_holds_object(struct chunk* c, struct loc grid, struct object* obj)
{
  assert(square_in_bounds(c, grid));
  return pile_contains(square_object(c, grid), obj);
}
STATIC_OVL void
square_excise_object(struct chunk* c, struct loc grid, struct object* obj)
{
  assert(square_in_bounds(c, grid));
  pile_excise(&c->squares[grid.y][grid.x].obj, obj);
}
STATIC_OVL void
square_excise_pile(struct chunk* c, struct loc grid)
{
  struct chunk* p_c = (player && c == cave) ? player->cave : NULL;
  assert(square_in_bounds(c, grid));
  object_pile_free(c, p_c, square_object(c, grid));
  square_set_obj(c, grid, NULL);
}
STATIC_OVL void
square_excise_all_imagined(struct chunk* p_c, struct chunk* c, struct loc grid)
{
  struct object* obj;
  assert(square_in_bounds(p_c, grid));
  obj = square_object(p_c, grid);
  while (obj) {
    struct object* next = obj->next;
    if (obj->notice & OBJ_NOTICE_IMAGINED) {
      struct object* original;
      assert(c->objects && c->objects[obj->oidx]);
      original = c->objects[obj->oidx];
      square_excise_object(p_c, grid, obj);
      delist_object(p_c, obj);
      object_delete(p_c, NULL, &obj);
      original->known = NULL;
      delist_object(c, original);
      object_delete(c, p_c, &original);
    }
    obj = next;
  }
}
STATIC_OVL void
square_delete_object(struct chunk* c, struct loc grid, struct object* obj,
                     bool do_note, bool do_light)
{
  struct chunk* p_c = (c == cave) ? player->cave : NULL;
  square_excise_object(c, grid, obj);
  delist_object(c, obj);
  object_delete(c, p_c, &obj);
  if (do_note) {
    square_note_spot(c, grid);
  }
  if (do_light) {
    square_light_spot(c, grid);
  }
}
STATIC_OVL void
forget_remembered_objects(struct chunk* c, struct chunk* knownc,
                          struct loc grid)
{
  struct object* obj = square_object(knownc, grid);
  while (obj) {
    struct object* next = obj->next;
    struct object* original = c->objects[obj->oidx];
    assert(original);
    if (!square_holds_object(c, grid, original)) {
      square_excise_object(knownc, grid, obj);
      obj->grid = loc(0, 0);
      if (obj->notice & OBJ_NOTICE_IMAGINED) {
        delist_object(knownc, obj);
        object_delete(knownc, NULL, &obj);
        original->known = NULL;
        delist_object(c, original);
        object_delete(c, knownc, &original);
      }
    }
    obj = next;
  }
}
STATIC_OVL void
square_know_pile(struct chunk* c, struct loc grid)
{
  struct object* obj;
  if (c != cave) return;
  object_lists_check_integrity(c, player->cave);
  for (obj = square_object(c, grid); obj; obj = obj->next) {
    object_see(player, obj);
    if (loc_eq(grid, player->grid)) {
      object_touch(player, obj);
    }
  }
  forget_remembered_objects(c, player->cave, grid);
}
STATIC_OVL int
square_num_doors_adjacent(struct chunk* c, struct loc grid)
{
  int k = 0;
  assert(square_in_bounds(c, grid));
  if (square_isdoor(c, next_grid(grid, DIR_S))) k++;
  if (square_isdoor(c, next_grid(grid, DIR_N))) k++;
  if (square_isdoor(c, next_grid(grid, DIR_E))) k++;
  if (square_isdoor(c, next_grid(grid, DIR_W))) k++;
  return k;
}
STATIC_OVL int
square_num_walls_diagonal(struct chunk* c, struct loc grid)
{
  int k = 0;
  assert(square_in_bounds(c, grid));
  if (feat_is_wall(square(c, next_grid(grid, DIR_SE))->feat)) k++;
  if (feat_is_wall(square(c, next_grid(grid, DIR_NW))->feat)) k++;
  if (feat_is_wall(square(c, next_grid(grid, DIR_NE))->feat)) k++;
  if (feat_is_wall(square(c, next_grid(grid, DIR_SW))->feat)) k++;
  return k;
}
STATIC_OVL void
square_set_feat(struct chunk* c, struct loc grid, int feat)
{
  int current_feat;
  assert(square_in_bounds(c, grid));
  current_feat = square(c, grid)->feat;
  if (current_feat) c->feat_count[current_feat]--;
  if (feat) c->feat_count[feat]++;
  c->squares[grid.y][grid.x].feat = feat;
  if (character_dungeon) {
    if (!square_istrappable(c, grid)) square_destroy_trap(c, grid);
    square_note_spot(c, grid);
    square_light_spot(c, grid);
  } else {
    sqinfo_off(square(c, grid)->info, SQUARE_WALL_INNER);
    sqinfo_off(square(c, grid)->info, SQUARE_WALL_OUTER);
    sqinfo_off(square(c, grid)->info, SQUARE_WALL_SOLID);
  }
}
STATIC_OVL void
square_set_known_feat(struct chunk* c, struct loc grid, int feat)
{
  if (c != cave) return;
  player->cave->squares[grid.y][grid.x].feat = feat;
}
STATIC_OVL void
square_set_mon(struct chunk* c, struct loc grid, int midx)
{
  c->squares[grid.y][grid.x].mon = midx;
}
STATIC_OVL void
square_set_obj(struct chunk* c, struct loc grid, struct object* obj)
{
  c->squares[grid.y][grid.x].obj = obj;
}
STATIC_OVL void
square_set_trap(struct chunk* c, struct loc grid, struct trap* trap)
{
  c->squares[grid.y][grid.x].trap = trap;
}
STATIC_OVL void
square_add_trap(struct chunk* c, struct loc grid)
{
  assert(square_in_bounds_fully(c, grid));
  if (!square_isempty(c, grid)) return;
  place_trap(c, grid, -1, c->depth);
}
STATIC_OVL void
square_add_glyph(struct chunk* c, struct loc grid, int type)
{
  struct trap_kind* glyph = NULL;
  switch (type) {
    case GLYPH_WARDING: {
      glyph = lookup_trap("glyph of warding");
      break;
    }
    default: {
      msg("Non-existent glyph requested. Please report this bug.");
      return;
    }
  }
  place_trap(c, grid, glyph->tidx, 0);
}
STATIC_OVL void
square_add_web(struct chunk* c, struct loc grid)
{
  struct trap_kind* web = lookup_trap("web");
  place_trap(c, grid, web->tidx, 0);
}
STATIC_OVL void
square_add_stairs(struct chunk* c, struct loc grid, int depth)
{
  int down = randint0(100) < 50;
  if (depth == 0)
    down = 1;
  else if (depth >= z_info->dun_depth)
    down = 0;
  square_set_feat(c, grid, down ? FEAT_MORE : FEAT_LESS);
}
STATIC_OVL void
square_add_door(struct chunk* c, struct loc grid, bool closed)
{
  square_set_feat(c, grid, closed ? FEAT_CLOSED : FEAT_OPEN);
}
STATIC_OVL void
square_open_door(struct chunk* c, struct loc grid)
{
  square_remove_all_traps(c, grid);
  square_set_feat(c, grid, FEAT_OPEN);
}
STATIC_OVL void
square_close_door(struct chunk* c, struct loc grid)
{
  square_set_feat(c, grid, FEAT_CLOSED);
}
STATIC_OVL void
square_smash_door(struct chunk* c, struct loc grid)
{
  square_remove_all_traps(c, grid);
  square_set_feat(c, grid, FEAT_BROKEN);
}
STATIC_OVL void
square_unlock_door(struct chunk* c, struct loc grid)
{
  assert(square_islockeddoor(c, grid));
  square_set_door_lock(c, grid, 0);
}
STATIC_OVL void
square_destroy_door(struct chunk* c, struct loc grid)
{
  assert(square_isdoor(c, grid));
  square_remove_all_traps(c, grid);
  square_set_feat(c, grid, FEAT_FLOOR);
}
STATIC_OVL void
square_destroy_trap(struct chunk* c, struct loc grid)
{
  square_remove_all_traps(c, grid);
}
STATIC_OVL void
square_tunnel_wall(struct chunk* c, struct loc grid)
{
  if (square_isrubble(c, grid)) {
    square_set_feat(c, grid, FEAT_FLOOR);
  } else if (square_issecretdoor(c, grid)) {
    square_set_feat(c, grid, FEAT_CLOSED);
  } else {
    square_set_feat(c, grid, FEAT_RUBBLE);
  }
}
STATIC_OVL void
square_destroy_wall(struct chunk* c, struct loc grid)
{
  square_set_feat(c, grid, FEAT_FLOOR);
}
STATIC_OVL void
square_smash_wall(struct chunk* c, struct loc grid)
{
  int i;
  square_set_feat(c, grid, FEAT_FLOOR);
  for (i = 0; i < 8; i++) {
    struct loc adj_grid = loc_sum(grid, ddgrid_ddd[i]);
    if (!square_in_bounds_fully(c, adj_grid)) continue;
    if (square_isperm(c, adj_grid)) continue;
    if (square_isfloor(c, adj_grid)) {
      continue;
    }
    if ((square_isgranite(c, adj_grid) && one_in_(4)) ||
        (square_isquartz(c, adj_grid) && one_in_(10))) {
      continue;
    }
    square_set_feat(c, adj_grid, FEAT_FLOOR);
  }
}
STATIC_OVL void
square_destroy_rubble(struct chunk* c, struct loc grid)
{
  assert(square_isrubble(c, grid));
  square_set_feat(c, grid, FEAT_FLOOR);
}
STATIC_OVL void
square_force_floor(struct chunk* c, struct loc grid)
{
  square_set_feat(c, grid, FEAT_FLOOR);
}
STATIC_OVL int
square_forge_bonus(struct chunk* c, struct loc grid)
{
  if (square_isforge(c, grid)) return f_info[square(c, grid)->feat].forge_bonus;
  return 0;
}
STATIC_OVL int
square_digging(struct chunk* c, struct loc grid)
{
  if (square_isdiggable(c, grid)) return f_info[square(c, grid)->feat].dig;
  return 0;
}
STATIC_OVL int
square_pit_difficulty(struct chunk* c, struct loc grid)
{
  if (square_ispit(c, grid))
    return f_info[square(c, grid)->feat].pit_difficulty;
  return 0;
}
STATIC_OVL void
square_apparent_name(struct chunk* c, struct loc grid, char* name, int size)
{
  int actual = square_isknown(c, grid) ? square(c, grid)->feat : 0;
  const struct feature* fp =
      f_info[actual].mimic ? f_info[actual].mimic : &f_info[actual];
  char forge_string[40];
  if (square_isforge(c, grid)) {
    int uses = square_forge_uses(cave, grid);
    if (!uses) {
      my_strcpy(forge_string, " (exhausted)", sizeof(forge_string));
    } else if (uses == 1) {
      my_strcpy(forge_string, " (1 use remaining)", sizeof(forge_string));
    } else {
      strnfmt(forge_string, sizeof(forge_string), " (%d uses remaining)", uses);
    }
  } else {
    my_strcpy(forge_string, "", sizeof(forge_string));
  }
  strnfmt(name, size, "%s%s", fp->name, forge_string);
}
STATIC_OVL const char*
square_apparent_look_prefix(struct chunk* c, struct loc grid)
{
  int actual = square_isknown(c, grid) ? square(c, grid)->feat : 0;
  const struct feature* fp =
      f_info[actual].mimic ? f_info[actual].mimic : &f_info[actual];
  return (fp->look_prefix) ? fp->look_prefix
                           : (is_a_vowel(fp->name[0]) ? "an " : "a ");
}
STATIC_OVL const char*
square_apparent_look_in_preposition(struct chunk* c, struct loc grid)
{
  int actual = square(c, grid)->feat;
  const struct feature* fp =
      f_info[actual].mimic ? f_info[actual].mimic : &f_info[actual];
  return (fp->look_in_preposition) ? fp->look_in_preposition : "on ";
}
STATIC_OVL void
square_memorize(struct chunk* c, struct loc grid)
{
  if (c != cave) return;
  square_set_known_feat(c, grid, square(c, grid)->feat);
}
STATIC_OVL void
square_forget(struct chunk* c, struct loc grid)
{
  if (c != cave) return;
  square_set_known_feat(c, grid, FEAT_NONE);
}
STATIC_OVL void
square_mark(struct chunk* c, struct loc grid)
{
  sqinfo_on(square(c, grid)->info, SQUARE_MARK);
}
STATIC_OVL void
square_unmark(struct chunk* c, struct loc grid)
{
  sqinfo_off(square(c, grid)->info, SQUARE_MARK);
}
STATIC_OVL int
distance(struct loc grid1, struct loc grid2)
{
  int ay = abs(grid2.y - grid1.y);
  int ax = abs(grid2.x - grid1.x);
  return ay > ax ? ay + (ax >> 1) : ax + (ay >> 1);
}
STATIC_OVL bool
los(struct chunk* c, struct loc grid1, struct loc grid2)
{
  int dx, dy;
  int ax, ay;
  int sx, sy;
  int qx, qy;
  int tx, ty;
  int f1, f2;
  int m;
  dy = grid2.y - grid1.y;
  dx = grid2.x - grid1.x;
  ay = ABS(dy);
  ax = ABS(dx);
  if ((ax < 2) && (ay < 2)) return (true);
  if (!dx) {
    if (dy > 0) {
      for (ty = grid1.y + 1; ty < grid2.y; ty++)
        if (!square_isprojectable(c, loc(grid1.x, ty))) return (false);
    } else {
      for (ty = grid1.y - 1; ty > grid2.y; ty--)
        if (!square_isprojectable(c, loc(grid1.x, ty))) return (false);
    }
    return (true);
  }
  if (!dy) {
    if (dx > 0) {
      for (tx = grid1.x + 1; tx < grid2.x; tx++)
        if (!square_isprojectable(c, loc(tx, grid1.y))) return (false);
    } else {
      for (tx = grid1.x - 1; tx > grid2.x; tx--)
        if (!square_isprojectable(c, loc(tx, grid1.y))) return (false);
    }
    return (true);
  }
  sx = (dx < 0) ? -1 : 1;
  sy = (dy < 0) ? -1 : 1;
  if ((ax == 1) && (ay == 2) &&
      square_isprojectable(c, loc(grid1.x, grid1.y + sy))) {
    return (true);
  } else if ((ay == 1) && (ax == 2) &&
             square_isprojectable(c, loc(grid1.x + sx, grid1.y))) {
    return (true);
  }
  f2 = (ax * ay);
  f1 = f2 << 1;
  if (ax >= ay) {
    qy = ay * ay;
    m = qy << 1;
    tx = grid1.x + sx;
    if (qy == f2) {
      ty = grid1.y + sy;
      qy -= f1;
    } else {
      ty = grid1.y;
    }
    while (grid2.x - tx) {
      if (!square_isprojectable(c, loc(tx, ty))) return (false);
      qy += m;
      if (qy < f2) {
        tx += sx;
      } else if (qy > f2) {
        ty += sy;
        if (!square_isprojectable(c, loc(tx, ty))) return (false);
        qy -= f1;
        tx += sx;
      } else {
        ty += sy;
        qy -= f1;
        tx += sx;
      }
    }
  } else {
    qx = ax * ax;
    m = qx << 1;
    ty = grid1.y + sy;
    if (qx == f2) {
      tx = grid1.x + sx;
      qx -= f1;
    } else {
      tx = grid1.x;
    }
    while (grid2.y - ty) {
      if (!square_isprojectable(c, loc(tx, ty))) return (false);
      qx += m;
      if (qx < f2) {
        ty += sy;
      } else if (qx > f2) {
        tx += sx;
        if (!square_isprojectable(c, loc(tx, ty))) return (false);
        qx -= f1;
        ty += sy;
      } else {
        tx += sx;
        qx -= f1;
        ty += sy;
      }
    }
  }
  return (true);
}
STATIC_OVL void
mark_wasseen(struct chunk* c)
{
  int x, y;
  for (y = 0; y < c->height; y++) {
    for (x = 0; x < c->width; x++) {
      struct loc grid = loc(x, y);
      if (square_isseen(c, grid))
        sqinfo_on(square(c, grid)->info, SQUARE_WASSEEN);
      sqinfo_off(square(c, grid)->info, SQUARE_VIEW);
      sqinfo_off(square(c, grid)->info, SQUARE_SEEN);
      sqinfo_off(square(c, grid)->info, SQUARE_CLOSE_PLAYER);
    }
  }
}
STATIC_OVL bool
source_can_light_wall(struct chunk* c, struct player* p, struct loc sgrid,
                      struct loc wgrid)
{
  struct loc sn = next_grid(wgrid, motion_dir(wgrid, sgrid)), pn, cn;
  if (loc_eq(sn, wgrid)) return true;
  pn = next_grid(wgrid, motion_dir(wgrid, p->grid));
  if (loc_eq(pn, wgrid)) return true;
  if (sn.x == pn.x) {
    if (sn.y == pn.y) return true;
    cn.x = sn.x;
    cn.y = 0;
  } else if (sn.y == pn.y) {
    cn.x = 0;
    cn.y = sn.y;
  } else {
    return false;
  }
  return square_allowslos(c, cn);
}
STATIC_OVL bool
glow_can_light_wall(struct chunk* c, struct player* p, struct loc wgrid)
{
  struct loc pn = next_grid(wgrid, motion_dir(wgrid, p->grid)), chk;
  if (loc_eq(pn, wgrid)) return true;
  if (square_allowslos(c, pn) && square_isglow(c, pn)) return true;
  if (pn.x != wgrid.x) {
    if (pn.y != wgrid.y) {
      chk.x = pn.x;
      chk.y = wgrid.y;
      if (square_allowslos(c, chk) && square_isglow(c, chk) &&
          source_can_light_wall(c, p, chk, wgrid))
        return true;
      chk.x = wgrid.x;
      chk.y = pn.y;
      if (square_allowslos(c, chk) && square_isglow(c, chk) &&
          source_can_light_wall(c, p, chk, wgrid))
        return true;
    } else {
      chk.x = pn.x;
      chk.y = wgrid.y - 1;
      if (square_in_bounds(c, chk) && square_allowslos(c, chk) &&
          square_isglow(c, chk) && source_can_light_wall(c, p, chk, wgrid))
        return true;
      chk.y = wgrid.y + 1;
      if (square_in_bounds(c, chk) && square_allowslos(c, chk) &&
          square_isglow(c, chk) && source_can_light_wall(c, p, chk, wgrid))
        return true;
    }
  } else {
    chk.y = pn.y;
    chk.x = wgrid.x - 1;
    if (square_in_bounds(c, chk) && square_allowslos(c, chk) &&
        square_isglow(c, chk) && source_can_light_wall(c, p, chk, wgrid))
      return true;
    chk.x = wgrid.x + 1;
    if (square_in_bounds(c, chk) && square_allowslos(c, chk) &&
        square_isglow(c, chk) && source_can_light_wall(c, p, chk, wgrid))
      return true;
  }
  return false;
}
STATIC_OVL void
add_light(struct chunk* c, struct player* p, struct loc sgrid, int radius,
          int inten)
{
  int y;
  int bonus_light = 0;
  if (loc_eq(sgrid, p->grid) && player_active_ability(p, "Inner Light")) {
    bonus_light = 1;
  }
  for (y = -radius; y <= radius; y++) {
    int x;
    for (x = -radius; x <= radius; x++) {
      struct loc grid = loc_sum(sgrid, loc(x, y));
      int dist = distance(sgrid, grid);
      if (!square_in_bounds(c, grid)) continue;
      if (dist > radius) continue;
      if (!los(c, sgrid, grid)) continue;
      if (!square_allowslos(c, grid) &&
          !source_can_light_wall(c, p, sgrid, grid))
        continue;
      if (inten > 0) {
        c->squares[grid.y][grid.x].light += radius + 1 - dist + bonus_light;
      } else {
        c->squares[grid.y][grid.x].light -= radius + 1 - dist + bonus_light;
      }
    }
  }
}
STATIC_OVL void
calc_lighting(struct chunk* c, struct player* p)
{
  int k, x, y;
  int light = p->upkeep->cur_light, radius = ABS(light);
  int old_light = square_light(c, p->grid);
  for (y = 0; y < c->height; y++) {
    for (x = 0; x < c->width; x++) {
      struct loc grid = loc(x, y);
      if (square_isglow(c, grid) &&
          (square_allowslos(c, grid) || glow_can_light_wall(c, p, grid))) {
        c->squares[y][x].light = 1;
      } else {
        c->squares[y][x].light = 0;
      }
    }
  }
  add_light(c, p, p->grid, radius, light);
  for (k = 1; k < cave_monster_max(c); k++) {
    struct monster* mon = cave_monster(c, k);
    if (!mon->race) continue;
    light = mon->race->light;
    radius = ABS(light);
    if (!light) continue;
    if (distance(p->grid, mon->grid) - radius > z_info->max_sight) continue;
    add_light(c, p, mon->grid, radius, light);
    if (rf_has(mon->race->flags, RF_GLOW)) {
      c->squares[mon->grid.y][mon->grid.x].light += 1;
    }
  }
  for (k = 1; k < c->obj_max; k++) {
    struct object* obj = c->objects[k];
    if (!obj || !obj->kind) continue;
    if (loc_is_zero(obj->grid)) continue;
    light = 0;
    if (of_has(obj->flags, OF_LIGHT) && !(of_has(obj->flags, OF_TAKES_FUEL) ||
                                          of_has(obj->flags, OF_BURNS_OUT))) {
      light++;
    }
    if (weapon_glows(obj, 1)) {
      light++;
    }
    if (of_has(obj->flags, OF_DARKNESS) && !tval_is_light(obj)) {
      light--;
    }
    if (tval_is_light(obj) && of_has(obj->flags, OF_NO_FUEL)) {
      light += obj->pval;
    }
    if (obj->artifact) {
      const struct artifact* crown = lookup_artifact_name("of Morgoth");
      if (obj->artifact == crown) {
        light += obj->pval;
      }
    }
    radius = ABS(light);
    if (radius > 0) add_light(c, p, obj->grid, radius, light);
  }
  if (square_light(c, p->grid) != old_light) {
    p->upkeep->redraw |= PR_LIGHT;
  }
}
STATIC_OVL void
become_viewable(struct chunk* c, struct loc grid, struct player* p, bool close)
{
  int x = grid.x;
  int y = grid.y;
  if (square_isview(c, grid)) return;
  sqinfo_on(square(c, grid)->info, SQUARE_VIEW);
  if (close) {
    sqinfo_on(square(c, grid)->info, SQUARE_SEEN);
    sqinfo_on(square(c, grid)->info, SQUARE_CLOSE_PLAYER);
  }
  if (square_islit(c, grid)) {
    if (!square_allowslos(c, grid)) {
      int xc = (x < p->grid.x) ? (x + 1) : (x > p->grid.x) ? (x - 1) : x;
      int yc = (y < p->grid.y) ? (y + 1) : (y > p->grid.y) ? (y - 1) : y;
      if (square_islit(c, loc(xc, yc))) {
        sqinfo_on(square(c, grid)->info, SQUARE_SEEN);
      }
    } else {
      sqinfo_on(square(c, grid)->info, SQUARE_SEEN);
    }
  }
}
STATIC_OVL void
update_view_one(struct chunk* c, struct loc grid, struct player* p)
{
  int x = grid.x;
  int y = grid.y;
  int xc = x, yc = y;
  int d = distance(grid, p->grid);
  bool close = d < p->upkeep->cur_light;
  if (d > z_info->max_sight) return;
  if (!square_allowslos(c, grid)) {
    int dx = x - p->grid.x;
    int dy = y - p->grid.y;
    int ax = ABS(dx);
    int ay = ABS(dy);
    int sx = dx > 0 ? 1 : -1;
    int sy = dy > 0 ? 1 : -1;
    xc = (x < p->grid.x) ? (x + 1) : (x > p->grid.x) ? (x - 1) : x;
    yc = (y < p->grid.y) ? (y + 1) : (y > p->grid.y) ? (y - 1) : y;
    if (!square_allowslos(c, loc(xc, yc))) {
      xc = x;
      yc = y;
    }
    if (ax == 2 && ay == 1) {
      if (square_allowslos(c, loc(x - sx, y)) &&
          !square_allowslos(c, loc(x - sx, y - sy))) {
        xc = x;
        yc = y;
      }
    } else if (ax == 1 && ay == 2) {
      if (square_allowslos(c, loc(x, y - sy)) &&
          !square_allowslos(c, loc(x - sx, y - sy))) {
        xc = x;
        yc = y;
      }
    }
  }
  if (los(c, p->grid, loc(xc, yc))) become_viewable(c, grid, p, close);
}
STATIC_OVL void
update_one(struct chunk* c, struct loc grid, struct player* p)
{
  if (p->timed[TMD_BLIND]) {
    sqinfo_off(square(c, grid)->info, SQUARE_SEEN);
    sqinfo_off(square(c, grid)->info, SQUARE_CLOSE_PLAYER);
  }
  if (square_isseen(c, grid) && !square_wasseen(c, grid)) {
    square_note_spot(c, grid);
    square_light_spot(c, grid);
  }
  if (!square_isseen(c, grid) && square_wasseen(c, grid))
    square_light_spot(c, grid);
  sqinfo_off(square(c, grid)->info, SQUARE_WASSEEN);
}
STATIC_OVL void
update_view(struct chunk* c, struct player* p)
{
  int x, y;
  mark_wasseen(c);
  calc_lighting(c, p);
  sqinfo_on(square(c, p->grid)->info, SQUARE_VIEW);
  if (p->upkeep->cur_light > 0 || square_islit(c, p->grid)) {
    sqinfo_on(square(c, p->grid)->info, SQUARE_SEEN);
    sqinfo_on(square(c, p->grid)->info, SQUARE_CLOSE_PLAYER);
  }
  if (p->timed[TMD_BLIND] && square_isknown(c, p->grid) &&
      !square_ispassable(p->cave, p->grid)) {
    square_forget(c, p->grid);
  }
  for (y = 0; y < c->height; y++)
    for (x = 0; x < c->width; x++) update_view_one(c, loc(x, y), p);
  for (y = 0; y < c->height; y++)
    for (x = 0; x < c->width; x++) update_one(c, loc(x, y), p);
  update_fire(c, p);
}
STATIC_OVL bool
no_light(const struct player* p)
{
  return (!square_isseen(cave, p->grid));
}
STATIC_OVL bool
trapped_stairs(void)
{
  int chance;
  chance = player->staircasiness / 100;
  chance = chance * chance * chance;
  chance = chance / 10000;
  if (percent_chance(chance)) {
    msg("The stairs crumble beneath you!");
    event_signal(EVENT_MESSAGE_FLUSH);
    msg("You fall through...");
    event_signal(EVENT_MESSAGE_FLUSH);
    msg("...and land somewhere deeper in the Iron Hells.");
    event_signal(EVENT_MESSAGE_FLUSH);
    history_add(player, "Fell through a crumbling stair", HIST_TRAPPED_STAIRS);
    player_falling_damage(player, false);
    player->upkeep->create_stair = FEAT_NONE;
    return true;
  }
  return false;
}
STATIC_OVL void
do_cmd_go_up_aux(void)
{
  int new_depth, min;
  int change = square_isshaft(cave, player->grid) ? -2 : -1;
  if (!square_isupstairs(cave, player->grid)) {
    msg("You see no up staircase here.");
    return;
  }
  if (in_tutorial()) {
    player->upkeep->energy_use = z_info->move_energy;
    tutorial_leave_section(player);
    return;
  }
  if (OPT(player, birth_force_descend) && (silmarils_possessed(player) == 0)) {
    msg("You have vowed to not to return until you hold a Silmaril.");
    return;
  }
  new_depth = dungeon_get_next_level(player, player->depth, change);
  player->upkeep->energy_use = z_info->move_energy;
  player->previous_action[0] = ACTION_MISC;
  if ((player->max_depth == z_info->dun_depth) &&
      (silmarils_possessed(player) == 0)) {
    msg("You enter a maze of staircases, but cannot find your way.");
    return;
  }
  monster_opportunist_or_zone(player, player->grid);
  if (player->chp < 0) return;
  min = player_min_depth(player);
  player->upkeep->create_stair = (change == -2) ? FEAT_MORE_SHAFT : FEAT_MORE;
  if ((new_depth < min) && (player->max_depth != z_info->dun_depth)) {
    msgt(MSG_STAIRS_UP,
         "You enter a maze of up staircases, but cannot find your way.");
    if (!trapped_stairs()) {
      if (player->depth == min) {
        msgt(MSG_STAIRS_UP, "You emerge near where you began.");
      } else {
        msgt(MSG_STAIRS_UP, "You emerge even deeper in the dungeon.");
      }
      if (player->upkeep->create_stair == FEAT_MORE) {
        player->upkeep->create_stair = FEAT_LESS;
      } else {
        player->upkeep->create_stair = FEAT_LESS_SHAFT;
      }
    }
    new_depth = min;
  } else {
    msgt(MSG_STAIRS_UP, "You enter a maze of up staircases.");
    if (silmarils_possessed(player) > 0) {
      msgt(MSG_STAIRS_UP, "The divine light reveals the way.");
    }
    if (player->depth == z_info->dun_depth) {
      if (!player->morgoth_slain) {
        msg("As you climb the stair, a great cry of rage and anguish comes "
            "from below.");
        msg("Make quick your escape: it shall be hard-won.");
      }
      player->on_the_run = true;
      player->truce = false;
    } else if (trapped_stairs()) {
      new_depth++;
    }
  }
  player->stairs_taken++;
  player->staircasiness += 1000;
  if (OPT(player, birth_discon_stairs)) {
    player->upkeep->create_stair = FEAT_NONE;
  }
  dungeon_change_level(player, new_depth);
}
STATIC_OVL void
do_cmd_go_up(struct command* cmd)
{
  do_cmd_go_up_aux();
}
STATIC_OVL void
do_cmd_go_down_aux(void)
{
  int new_depth, min;
  int change = square_isshaft(cave, player->grid) ? 2 : 1;
  if (!square_isdownstairs(cave, player->grid)) {
    msg("I see no down staircase here.");
    return;
  }
  if (in_tutorial()) {
    player->upkeep->energy_use = z_info->move_energy;
    tutorial_leave_section(player);
    return;
  }
  if (player->depth == 0) {
    msg("You have made it to the very gates of Angband and can once more taste "
        "the freshness on the air.");
    msg("You will not re-enter that fell pit.");
    return;
  }
  new_depth = dungeon_get_next_level(player, player->depth, change);
  min = player_min_depth(player);
  player->upkeep->create_stair = (change == 2) ? FEAT_LESS_SHAFT : FEAT_LESS;
  if (new_depth == z_info->dun_depth) {
    if (!player->on_the_run) {
      msg("From up this stair comes the harsh din of feasting in Morgoth's own "
          "hall.");
      if (!get_check("Are you completely sure you wish to descend? ")) {
        player->upkeep->create_stair = FEAT_NONE;
        return;
      }
    }
  }
  player->upkeep->energy_use = z_info->move_energy;
  player->previous_action[0] = ACTION_MISC;
  monster_opportunist_or_zone(player, player->grid);
  if (player->chp < 0) return;
  msgt(MSG_STAIRS_DOWN, "You enter a maze of down staircases.");
  if ((player->on_the_run) && (new_depth == z_info->dun_depth)) {
    msgt(MSG_STAIRS_DOWN,
         "Try though you might, you cannot find your way back to Morgoth's "
         "throne.");
    msgt(MSG_STAIRS_DOWN, "You emerge near where you began.");
    player->upkeep->create_stair = FEAT_MORE;
    new_depth = z_info->dun_depth - 1;
  } else if (!trapped_stairs() && (new_depth < min)) {
    msgt(MSG_STAIRS_DOWN, "You emerge much deeper in the dungeon.");
    new_depth = min;
  }
  player->stairs_taken++;
  player->staircasiness += 1000;
  if (OPT(player, birth_discon_stairs)) {
    player->upkeep->create_stair = FEAT_NONE;
  }
  dungeon_change_level(player, new_depth);
}
STATIC_OVL void
do_cmd_go_down(struct command* cmd)
{
  do_cmd_go_down_aux();
}
STATIC_OVL void
do_cmd_toggle_stealth(struct command* cmd)
{
  if (player->stealth_mode) {
    player->stealth_mode = STEALTH_MODE_OFF;
    player->upkeep->update |= (PU_BONUS);
    player->upkeep->redraw |= (PR_STATE);
  } else {
    player->stealth_mode = STEALTH_MODE_ON;
    player->upkeep->update |= (PU_BONUS);
    player->upkeep->redraw |= (PR_STATE | PR_SPEED);
  }
}
STATIC_OVL bool
do_cmd_open_test(struct player* p, struct loc grid)
{
  if (!square_isknown(cave, grid)) {
    msg("You see nothing there.");
    return false;
  }
  if (!square_iscloseddoor(cave, grid)) {
    msgt(MSG_NOTHING_TO_OPEN, "You see nothing there to open.");
    if (square_iscloseddoor(p->cave, grid)) {
      square_forget(cave, grid);
      square_light_spot(cave, grid);
    }
    return false;
  }
  return (true);
}
STATIC_OVL bool
do_cmd_open_aux(struct loc grid)
{
  int score, power, difficulty;
  bool more = false;
  if (!do_cmd_open_test(player, grid)) return (false);
  if (square_isjammeddoor(cave, grid)) {
    msg("The door appears to be stuck.");
  } else if (square_islockeddoor(cave, grid)) {
    score = player->state.skill_use[SKILL_PERCEPTION];
    power = square_door_lock_power(cave, grid);
    difficulty = power + 5;
    if (player->timed[TMD_BLIND] || no_light(player) ||
        player->timed[TMD_IMAGE]) {
      difficulty += 5;
    }
    if (player->timed[TMD_CONFUSED]) difficulty += 5;
    if (skill_check(source_player(), score, difficulty, source_none()) > 0) {
      msgt(MSG_LOCKPICK, "You have picked the lock.");
      square_open_door(cave, grid);
      player->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
    } else {
      event_signal(EVENT_INPUT_FLUSH);
      msgt(MSG_LOCKPICK_FAIL, "You failed to pick the lock.");
      more = true;
    }
  } else {
    square_open_door(cave, grid);
    player->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
    sound(MSG_OPENDOOR);
  }
  return more;
}
STATIC_OVL void
do_cmd_open(struct command* cmd)
{
  struct loc grid;
  int dir;
  struct object* obj;
  bool more = false;
  int err;
  struct monster* mon;
  err = cmd_get_arg_direction(cmd, "direction", &dir);
  if (err || dir == DIR_UNKNOWN) {
    struct loc grid1;
    int n_closed_doors, n_locked_chests;
    n_closed_doors = count_feats(&grid1, square_iscloseddoor, false) -
                     count_feats(&grid1, square_issecretdoor, false);
    assert(n_closed_doors >= 0);
    n_locked_chests = count_chests(&grid1, CHEST_OPENABLE);
    if (n_closed_doors + n_locked_chests == 1) {
      dir = motion_dir(player->grid, grid1);
      cmd_set_arg_direction(cmd, "direction", dir);
    } else if (cmd_get_direction(cmd, "direction", &dir, n_locked_chests > 0)) {
      return;
    }
  }
  grid = loc_sum(player->grid, ddgrid[dir]);
  obj = chest_check(player, grid, CHEST_OPENABLE);
  if (!obj && !do_cmd_open_test(player, grid)) {
    msg("There is nothing in your square (or adjacent) to open.");
    disturb(player, false);
    return;
  }
  player->upkeep->energy_use = z_info->move_energy;
  player->previous_action[0] = ACTION_MISC;
  if (player_confuse_dir(player, &dir, false)) {
    grid = loc_sum(player->grid, ddgrid[dir]);
    obj = chest_check(player, grid, CHEST_OPENABLE);
  }
  mon = square_monster(cave, grid);
  if (mon) {
    msg("There is a monster in the way!");
    py_attack(player, grid, ATT_MAIN);
  } else if (obj) {
    more = do_cmd_open_chest(grid, obj);
  } else {
    more = do_cmd_open_aux(grid);
  }
  if (!more) disturb(player, false);
}
STATIC_OVL bool
do_cmd_close_test(struct player* p, struct loc grid)
{
  if (!square_isknown(cave, grid)) {
    msg("You see nothing there.");
    return (false);
  }
  if (!square_isopendoor(cave, grid) && !square_isbrokendoor(cave, grid)) {
    msg("You see nothing there to close.");
    if (square_isopendoor(p->cave, grid) ||
        square_isbrokendoor(p->cave, grid)) {
      square_forget(cave, grid);
      square_light_spot(cave, grid);
    }
    return (false);
  }
  if (square(cave, grid)->mon < 0) {
    msg("To close the door you would need to move out from the doorway.");
    return (false);
  }
  return (true);
}
STATIC_OVL bool
do_cmd_close_aux(struct loc grid)
{
  bool more = false;
  if (!do_cmd_close_test(player, grid)) return (false);
  if (square_isbrokendoor(cave, grid)) {
    msg("The door appears to be broken.");
  } else {
    square_close_door(cave, grid);
    player->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
    sound(MSG_SHUTDOOR);
  }
  return (more);
}
STATIC_OVL void
do_cmd_close(struct command* cmd)
{
  struct loc grid;
  int dir;
  int err;
  bool more = false;
  err = cmd_get_arg_direction(cmd, "direction", &dir);
  if (err || dir == DIR_UNKNOWN) {
    struct loc grid1;
    if (count_feats(&grid1, square_isopendoor, false) == 1) {
      dir = motion_dir(player->grid, grid1);
      cmd_set_arg_direction(cmd, "direction", dir);
    } else if (cmd_get_direction(cmd, "direction", &dir, false)) {
      return;
    }
  }
  grid = loc_sum(player->grid, ddgrid[dir]);
  if (!do_cmd_close_test(player, grid)) {
    disturb(player, false);
    return;
  }
  player->upkeep->energy_use = z_info->move_energy;
  player->previous_action[0] = ACTION_MISC;
  if (player_confuse_dir(player, &dir, false)) {
    grid = loc_sum(player->grid, ddgrid[dir]);
  }
  if (square(cave, grid)->mon > 0) {
    msg("There is a monster in the way!");
    py_attack(player, grid, ATT_MAIN);
  } else
    more = do_cmd_close_aux(grid);
  if (!more) disturb(player, false);
}
STATIC_OVL void
do_cmd_exchange(struct command* cmd)
{
  int dir;
  struct loc grid;
  struct monster* mon;
  char m_name[80];
  if (!player_active_ability(player, "Exchange Places")) {
    msg("You need the ability 'exchange places' to use this command.");
    return;
  }
  if (cmd_get_direction(cmd, "direction", &dir, false) != CMD_OK) return;
  grid = loc_sum(player->grid, ddgrid[dir]);
  if (player->upkeep->total_weight > weight_limit(player->state) * 3 / 2) {
    msg("You are too burdened to move.");
    return;
  }
  mon = square_monster(cave, grid);
  if (square_ispit(cave, player->grid)) {
    msg("You would have to escape the pit before being able to exchange "
        "places.");
    return;
  } else if (square_iswebbed(cave, player->grid)) {
    msg("You would have to escape the web before being able to exchange "
        "places.");
    return;
  } else if (!mon || !monster_is_visible(mon)) {
    msg("You cannot see a monster there to exchange places with.");
    return;
  } else if (square_isrubble(cave, grid)) {
    msg("You cannot enter the rubble.");
    return;
  } else if (square_isrock(cave, grid)) {
    msg("You cannot enter the wall.");
    return;
  } else if (square_iscloseddoor(cave, grid)) {
    msg("You cannot enter the closed door.");
    return;
  } else {
    if (rf_has(mon->race->flags, RF_NEVER_MOVE) ||
        rf_has(mon->race->flags, RF_HIDDEN_MOVE)) {
      monster_desc(m_name, sizeof(m_name), mon, MDESC_DEFAULT);
      msg("You cannot get past %s.", m_name);
      return;
    }
  }
  player->upkeep->energy_use = z_info->move_energy;
  player->previous_action[0] = ACTION_MISC;
  if (player_confuse_dir(player, &dir, false)) {
    grid = loc_sum(player->grid, ddgrid[dir]);
  }
  mon = square_monster(cave, grid);
  if (!mon || !monster_is_visible(mon)) {
    msg("You cannot see a monster there to exchange places with.");
    return;
  } else if (square_isrubble(cave, grid)) {
    msg("There is a pile of rubble in the way.");
    return;
  } else if (square_isrock(cave, grid)) {
    msg("There is a wall in the way.");
    return;
  } else if (square_iscloseddoor(cave, grid)) {
    msg("There is a door in the way.");
    return;
  } else if (square_ischasm(cave, grid)) {
    msg("You cannot exchange places over the chasm.");
    return;
  }
  monster_desc(m_name, sizeof(m_name), mon, MDESC_DEFAULT);
  msg("You exchange places with %s.", m_name);
  if ((mon->alertness >= ALERTNESS_ALERT) && !mon->m_timed[MON_TMD_CONF] &&
      !rf_has(mon->race->flags, RF_MINDLESS)) {
    char m_pronoun[80];
    monster_desc(m_pronoun, sizeof(m_pronoun), mon,
                 MDESC_PRO_VIS | MDESC_CAPITAL);
    msg("%s attacks you as you slip past.", m_pronoun);
    make_attack_normal(mon, player);
  }
  make_alert(mon, 0);
  monster_swap(player->grid, grid);
  player_handle_post_move(player, true, false);
}
STATIC_OVL bool
do_cmd_tunnel_test(struct player* p, struct loc grid)
{
  if (!square_isknown(cave, grid)) {
    msg("You see nothing there.");
    return (false);
  }
  if (square_isperm(cave, grid)) {
    msg("You cannot tunnel any further in that direction.");
    if (!square_isperm(p->cave, grid)) {
      square_memorize(cave, grid);
      square_light_spot(cave, grid);
    }
    return (false);
  }
  if (!square_isdiggable(cave, grid)) {
    if (square_iscloseddoor(cave, grid)) {
      msg("You cannot tunnel through a door. Try bashing it.");
    } else {
      msg("You see nothing there to tunnel.");
    }
    if (square_isdiggable(p->cave, grid) ||
        square_iscloseddoor(p->cave, grid)) {
      square_forget(cave, grid);
      square_light_spot(cave, grid);
    }
    return (false);
  }
  return (true);
}
STATIC_OVL bool
twall(struct loc grid)
{
  if (!square_isdiggable(cave, grid)) return (false);
  sound(MSG_DIG);
  square_tunnel_wall(cave, grid);
  player->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
  return (true);
}
STATIC_OVL void
fail_message(struct feature* terrain, char* name)
{
  char buf[1024] = "\0";
  if (!terrain->fail_msg) return;
  insert_name(buf, 1024, terrain->fail_msg, name);
  msg("%s", buf);
}
STATIC_OVL bool
do_cmd_tunnel_aux(struct loc grid)
{
  bool more = false;
  int weapon_slot = slot_by_name(player, "weapon");
  struct object* current_weapon = slot_object(player, weapon_slot);
  struct object* digger = NULL;
  int digging_score = 0;
  int difficulty = square_digging(cave, grid);
  char o_name[80];
  if (!do_cmd_tunnel_test(player, grid)) return (false);
  if (obj_digging_score(current_weapon)) {
    digging_score = obj_digging_score(current_weapon);
    digger = current_weapon;
  } else {
    bool more_than_one = false;
    struct object* test;
    for (test = player->gear; test; test = test->next) {
      if (obj_digging_score(test)) {
        if (digging_score) {
          more_than_one = true;
        }
        digging_score = obj_digging_score(test);
        digger = test;
      }
    }
    if (more_than_one) {
      if (!get_item(&digger, "Use which digger?",
                    "You are not carrying a shovel or mattock.", CMD_TUNNEL,
                    obj_can_dig, USE_INVEN))
        return false;
      digging_score = obj_digging_score(digger);
    }
  }
  if (digging_score == 0) {
    if (player->timed[TMD_CONFUSED]) {
      if (square_isrubble(cave, grid)) {
        msg("You bump into the rubble.");
      } else {
        msg("You bump into the wall.");
      }
      return false;
    } else {
      msg("You are not carrying a shovel or mattock.");
      player->previous_action[0] = ACTION_NOTHING;
      player->upkeep->energy_use = 0;
      return false;
    }
  }
  object_desc(o_name, sizeof(o_name), digger, ODESC_BASE, player);
  if (difficulty > digging_score) {
    fail_message(square_feat(cave, grid), o_name);
    if (!player->timed[TMD_CONFUSED]) {
      player->previous_action[0] = ACTION_NOTHING;
      player->upkeep->energy_use = 0;
      return false;
    }
  } else if (difficulty > player->state.stat_use[STAT_STR]) {
    msg(square_feat(cave, grid)->str_msg);
    if (!player->timed[TMD_CONFUSED]) {
      player->previous_action[0] = ACTION_NOTHING;
      player->upkeep->energy_use = 0;
      return false;
    }
  } else {
    monsters_hear(true, false, -10);
    msg(square_feat(cave, grid)->dig_msg);
    twall(grid);
  }
  break_truce(player, false);
  attacks_of_opportunity(player, loc(0, 0));
  return more;
}
STATIC_OVL void
do_cmd_tunnel(struct command* cmd)
{
  struct loc grid;
  int dir;
  bool more = false;
  if (cmd_get_direction(cmd, "direction", &dir, false)) return;
  grid = loc_sum(player->grid, ddgrid[dir]);
  if (!do_cmd_tunnel_test(player, grid)) {
    disturb(player, false);
    return;
  }
  player->upkeep->energy_use = z_info->move_energy;
  player->previous_action[0] = ACTION_MISC;
  if (player_confuse_dir(player, &dir, false)) {
    grid = loc_sum(player->grid, ddgrid[dir]);
  }
  if (square(cave, grid)->mon > 0) {
    msg("There is a monster in the way!");
    py_attack(player, grid, ATT_MAIN);
  } else {
    more = do_cmd_tunnel_aux(grid);
  }
  if (!more) disturb(player, false);
}
STATIC_OVL bool
do_cmd_disarm_test(struct player* p, struct loc grid)
{
  if (!square_isknown(cave, grid)) {
    msg("You see nothing there.");
    return false;
  }
  if (!square_isdisarmabletrap(cave, grid) && !square_iswarded(cave, grid)) {
    msg("You see nothing there to disarm.");
    if (square_isdisarmabletrap(p->cave, grid)) {
      square_memorize_traps(cave, grid);
      square_light_spot(cave, grid);
    }
    return false;
  }
  return true;
}
STATIC_OVL bool
do_cmd_disarm_aux(struct loc grid)
{
  int skill, power, difficulty, result;
  struct trap* trap = square(cave, grid)->trap;
  bool more = false;
  if (!do_cmd_disarm_test(player, grid)) return (false);
  while (trap) {
    if (trf_has(trap->flags, TRF_TRAP)) break;
    if (trf_has(trap->flags, TRF_GLYPH)) break;
    trap = trap->next;
  }
  if (!trap) return false;
  skill = player->state.skill_use[SKILL_PERCEPTION];
  if (square_iswebbed(cave, grid) && loc_eq(grid, player->grid)) {
    more = player_break_web(player);
    return !more;
  }
  power = trap->power;
  if (power == (uint8_t)-1) {
    msg("You cannot disarm the %s.", trap->kind->name);
    return false;
  }
  difficulty = power;
  if (player->timed[TMD_BLIND] || no_light(player) || player->timed[TMD_IMAGE])
    difficulty += 5;
  if (player->timed[TMD_CONFUSED]) difficulty += 5;
  result = skill_check(source_player(), skill, difficulty, source_none());
  if (result > 0) {
    if (trf_has(trap->flags, TRF_GLYPH)) {
      msgt(MSG_DISARM, "You have scuffed the %s.", trap->kind->name);
    } else {
      msgt(MSG_DISARM, "You have disarmed the %s.", trap->kind->name);
    }
    square_destroy_trap(cave, grid);
    square_unmark(cave, grid);
  } else if (result > -3) {
    event_signal(EVENT_INPUT_FLUSH);
    msg("You failed to disarm the %s.", trap->kind->name);
    more = true;
  } else {
    monster_swap(player->grid, grid);
    msg("You set off the %s!", trap->kind->name);
    hit_trap(grid);
  }
  return more;
}
STATIC_OVL void
do_cmd_disarm(struct command* cmd)
{
  struct loc grid;
  int dir;
  int err;
  struct object* obj;
  bool more = false;
  err = cmd_get_arg_direction(cmd, "direction", &dir);
  if (err || dir == DIR_UNKNOWN) {
    struct loc grid1;
    int n_traps, n_wards, n_chests;
    n_traps = count_feats(&grid1, square_isdisarmabletrap, true);
    n_wards = count_feats(&grid1, square_iswarded, true);
    n_chests = count_chests(&grid1, CHEST_TRAPPED);
    if (n_traps + n_wards + n_chests == 1) {
      dir = motion_dir(player->grid, grid1);
      cmd_set_arg_direction(cmd, "direction", dir);
    } else if (cmd_get_direction(cmd, "direction", &dir, true)) {
      return;
    }
  }
  grid = loc_sum(player->grid, ddgrid[dir]);
  obj = chest_check(player, grid, CHEST_TRAPPED);
  if (!obj && !do_cmd_disarm_test(player, grid)) {
    disturb(player, false);
    return;
  }
  player->upkeep->energy_use = z_info->move_energy;
  player->previous_action[0] = ACTION_MISC;
  if (player_confuse_dir(player, &dir, false)) {
    grid = loc_sum(player->grid, ddgrid[dir]);
    obj = chest_check(player, grid, CHEST_TRAPPED);
  }
  if (square(cave, grid)->mon > 0) {
    msg("There is a monster in the way!");
    py_attack(player, grid, ATT_MAIN);
  } else if (obj) {
    more = do_cmd_disarm_chest(obj);
  } else {
    more = do_cmd_disarm_aux(grid);
  }
  if (!more) disturb(player, false);
}
STATIC_OVL bool
do_cmd_bash_test(struct player* p, struct loc grid)
{
  if (!square_isknown(cave, grid)) {
    msg("You see nothing there.");
    return false;
  }
  if (!square_iscloseddoor(cave, grid) || square_issecretdoor(cave, grid)) {
    msg("You see no door there to bash.");
    if (square_iscloseddoor(p->cave, grid)) {
      square_forget(cave, grid);
      square_light_spot(cave, grid);
    }
    return false;
  }
  return true;
}
STATIC_OVL bool
do_cmd_bash_aux(struct loc grid)
{
  int score, difficulty;
  bool more = false;
  bool success = false;
  if (!do_cmd_bash_test(player, grid)) return false;
  score = player->state.stat_use[STAT_STR] * 2;
  difficulty = square_door_jam_power(cave, grid);
  msg("You slam into the door!");
  if (skill_check(source_player(), score, difficulty, source_none()) > 0) {
    success = true;
    if (player_is_singing(player, lookup_song("Silence"))) {
      msgt(MSG_OPENDOOR, "The door opens with a muffled crash!");
    } else {
      msgt(MSG_OPENDOOR, "The door crashes open!");
    }
    if (one_in_(2)) {
      square_set_feat(cave, grid, FEAT_BROKEN);
    } else {
      square_set_feat(cave, grid, FEAT_OPEN);
    }
    monster_swap(player->grid, grid);
    player_handle_post_move(player, false, false);
    monsters_hear(true, false, -10);
    player->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
  }
  if (!success) {
    int old_stun = player->timed[TMD_STUN];
    if (square_iscloseddoor(cave, grid)) {
      msg("The door holds firm.");
    }
    (void)player_inc_timed(player, TMD_STUN, 10, true, true, true);
    if (player->timed[TMD_STUN] > old_stun) {
      more = true;
    }
    monsters_hear(true, false, -5);
  }
  return more;
}
STATIC_OVL void
do_cmd_bash(struct command* cmd)
{
  int dir;
  struct loc grid;
  struct monster* mon;
  bool more = false;
  if (cmd_get_direction(cmd, "direction", &dir, false) != CMD_OK) return;
  grid = loc_sum(player->grid, ddgrid[dir]);
  if (!do_cmd_bash_test(player, grid)) return;
  player->upkeep->energy_use = z_info->move_energy;
  player->previous_action[0] = ACTION_MISC;
  if (player_confuse_dir(player, &dir, false)) {
    grid = loc_sum(player->grid, ddgrid[dir]);
  }
  mon = square_monster(cave, grid);
  if (mon) {
    msg("There is a monster in the way!");
    py_attack(player, grid, ATT_MAIN);
  } else {
    more = do_cmd_bash_aux(grid);
  }
  if (!more) disturb(player, false);
}
STATIC_OVL void
do_cmd_alter_aux(int dir)
{
  struct loc grid;
  bool more = false;
  struct object* o_chest_closed;
  struct object* o_chest_trapped;
  struct object* obj = NULL;
  grid = loc_sum(player->grid, ddgrid[dir]);
  player->upkeep->energy_use = z_info->move_energy;
  player->previous_action[0] = ACTION_MISC;
  if (player_confuse_dir(player, &dir, false)) {
    grid = loc_sum(player->grid, ddgrid[dir]);
  }
  o_chest_closed = chest_check(player, grid, CHEST_OPENABLE);
  o_chest_trapped = chest_check(player, grid, CHEST_TRAPPED);
  obj = square_object(cave, grid);
  if (square(cave, grid)->mon > 0) {
    py_attack(player, grid, ATT_MAIN);
  } else if ((dir != DIR_NONE) && !square_isknown(cave, grid)) {
    if (square_isfloor(cave, grid)) {
      msg("You strike, but there is nothing there.");
    } else {
      msg("You hit something hard.");
      square_memorize(cave, grid);
      square_light_spot(cave, grid);
    }
  } else if (square_isrock(cave, grid)) {
    more = do_cmd_tunnel_aux(grid);
  } else if (square_iscloseddoor(cave, grid)) {
    more = do_cmd_bash_aux(grid);
  } else if (square_isdisarmabletrap(cave, grid) ||
             square_iswarded(cave, grid)) {
    more = do_cmd_disarm_aux(grid);
  } else if (o_chest_trapped) {
    more = do_cmd_disarm_chest(o_chest_trapped);
  } else if (o_chest_closed) {
    more = do_cmd_open_chest(grid, o_chest_closed);
  } else if (square_isopendoor(cave, grid)) {
    more = do_cmd_close_aux(grid);
  } else if ((dir == DIR_NONE) && square_isupstairs(cave, grid)) {
    if (get_check("Are you sure you wish to ascend? ")) {
      do_cmd_go_up_aux();
    }
  } else if ((dir == DIR_NONE) && square_isdownstairs(cave, grid)) {
    if (get_check("Are you sure you wish to descend? ")) {
      do_cmd_go_down_aux();
    }
  } else if ((dir == DIR_NONE) && square_isforge(cave, grid)) {
    cmd_cancel_repeat();
    do_cmd_smith_aux(true);
    more = true;
    player->upkeep->energy_use = 0;
  } else if ((dir == DIR_NONE) && obj) {
    player_pickup_item(player, obj, true);
  } else if (dir == DIR_NONE) {
    msg("There is nothing here to use.");
    player->upkeep->energy_use = 0;
  } else {
    msg("You strike, but there is nothing there.");
  }
  if (!more) disturb(player, false);
}
STATIC_OVL void
do_cmd_alter(struct command* cmd)
{
  int dir;
  if (cmd_get_direction(cmd, "direction", &dir, true) != CMD_OK) return;
  do_cmd_alter_aux(dir);
}
STATIC_OVL bool
confirm_leap(struct loc grid, int dir)
{
  bool confirm = true;
  char prompt[80];
  struct loc end = loc_sum(loc_sum(player->grid, ddgrid[dir]), ddgrid[dir]);
  struct monster* mon = square_monster(cave, end);
  if (!(square_isseen(cave, end) || square_isknown(cave, end))) {
    strnfmt(prompt, sizeof(prompt),
            "Are you sure you wish to leap into the unknown? ");
  } else if (square_ischasm(cave, end)) {
    strnfmt(prompt, sizeof(prompt),
            "Are you sure you wish to leap into the abyss? ");
  } else if (mon && monster_is_visible(mon)) {
    char m_name[80];
    monster_desc(m_name, sizeof(m_name), mon, 0);
    strnfmt(prompt, sizeof(prompt), "Are you sure you wish to leap into %s? ",
            m_name);
  } else {
    confirm = false;
  }
  return (!confirm || get_check(prompt));
}
STATIC_OVL void
player_land(struct player* p)
{
  p->stealth_score -= 5;
  player_handle_post_move(p, true, false);
}
STATIC_OVL void
do_cmd_leap(struct command* cmd)
{
  int dir = player->previous_action[1];
  struct loc end = loc_sum(player->grid, ddgrid[dir]);
  struct monster* mon = square_monster(cave, end);
  if (player->upkeep->knocked_back) return;
  msg("You fly through the air.");
  event_signal(EVENT_MESSAGE_FLUSH);
  player->upkeep->energy_use = z_info->move_energy;
  player->previous_action[0] = dir;
  if (!square_ispassable(cave, end)) {
    if (square_isrubble(cave, end)) {
      msgt(MSG_HITWALL, "You slam into a wall of rubble.");
    } else if (square_isrock(cave, end)) {
      msgt(MSG_HITWALL, "You slam into a wall.");
    } else {
      msgt(MSG_HITWALL, "You slam into a door.");
    }
  } else if (mon) {
    char m_name[80];
    monster_desc(m_name, sizeof(m_name), mon, MDESC_STANDARD);
    if (monster_is_visible(mon)) {
      msg("%s blocks your landing.", m_name);
    } else {
      msg("Some unseen foe blocks your landing.");
    }
  } else {
    player_flanking_or_retreat(player, end);
    monster_swap(player->grid, end);
  }
  player_land(player);
}
STATIC_OVL void
move_player(int dir, bool disarm)
{
  struct loc grid = loc_sum(player->grid, ddgrid[dir]);
  int m_idx = square(cave, grid)->mon;
  struct monster* mon = cave_monster(cave, m_idx);
  bool trap = square_isdisarmabletrap(cave, grid);
  bool door =
      square_iscloseddoor(cave, grid) && !square_issecretdoor(cave, grid);
  bool confused = player->timed[TMD_CONFUSED] > 0;
  if (mon && monster_is_visible(mon)) {
    py_attack(player, grid, ATT_MAIN);
  } else if (((trap && disarm) || door) && square_isknown(cave, grid)) {
    if (cmd_get_nrepeats() == 0) cmd_set_repeat(99);
    if (door) {
      if (!do_cmd_open_aux(grid)) {
        disturb(player, false);
      }
    } else {
      do_cmd_alter_aux(dir);
    }
  } else if (trap && player->upkeep->running) {
    disturb(player, false);
    player->upkeep->energy_use = 0;
  } else if (!square_ispassable(cave, grid)) {
    disturb(player, false);
    if (!square_isknown(cave, grid)) {
      if (square_isrubble(cave, grid)) {
        msgt(MSG_HITWALL, "You feel a pile of rubble blocking your way.");
      } else if (door) {
        msgt(MSG_HITWALL, "You feel a door blocking your way.");
      } else {
        msgt(MSG_HITWALL, "You feel a wall blocking your way.");
      }
      square_memorize(cave, grid);
      square_light_spot(cave, grid);
    } else {
      if (square_isrubble(cave, grid)) {
        msgt(MSG_HITWALL, "There is a pile of rubble blocking your way.");
        if (!square_isrubble(player->cave, grid)) {
          square_memorize(cave, grid);
          square_light_spot(cave, grid);
        }
      } else if (door) {
        msgt(MSG_HITWALL, "There is a door blocking your way.");
        if (!square_iscloseddoor(player->cave, grid)) {
          square_memorize(cave, grid);
          square_light_spot(cave, grid);
        }
      } else {
        msgt(MSG_HITWALL, "There is a wall blocking your way.");
        if (square_ispassable(player->cave, grid) ||
            square_isrubble(player->cave, grid) ||
            square_iscloseddoor(player->cave, grid)) {
          square_forget(cave, grid);
          square_light_spot(cave, grid);
        }
      }
    }
    player->previous_action[0] = ACTION_MISC;
  } else if (player->upkeep->total_weight >
             (weight_limit(player->state) * 3) / 2) {
    msg("You are too burdened to move.");
    disturb(player, false);
    player->upkeep->energy_use = 0;
  } else if (player_can_leap(player, grid, dir) && confirm_leap(grid, dir)) {
    if (mon) {
      msg("An unseen foe blocks your way.");
      py_attack(player, grid, ATT_MAIN);
    } else {
      struct loc mid = loc_sum(player->grid, ddgrid[dir]);
      player_flanking_or_retreat(player, mid);
      player->previous_action[0] = dir;
      monster_swap(player->grid, mid);
      player->upkeep->leaping = true;
      cmdq_push(CMD_LEAP);
    }
  } else {
    bool pit = square_ispit(cave, player->grid);
    bool web = square_iswebbed(cave, player->grid);
    bool step = true;
    if (!confused && square_isknown(cave, grid)) {
      if (square_ischasm(cave, grid)) {
        disturb(player, false);
        event_signal(EVENT_MESSAGE_FLUSH);
        if (!get_check("Step into the chasm? ")) {
          player->upkeep->energy_use = 0;
          step = false;
        }
      }
      if (trap) {
        disturb(player, false);
        event_signal(EVENT_MESSAGE_FLUSH);
        if (!get_check("Are you sure you want to step on the trap? ")) {
          player->upkeep->energy_use = 0;
          step = false;
        }
      }
    }
    if (mon) {
      msg("An unseen foe blocks your way.");
      py_attack(player, grid, ATT_MAIN);
      step = false;
    }
    if (pit && !player_escape_pit(player)) {
      step = false;
    }
    if (web && !player_break_web(player)) {
      step = false;
    }
    if (step) {
      player_flanking_or_retreat(player, grid);
      monster_swap(player->grid, grid);
      player_handle_post_move(player, true, false);
      perceive(player);
      player->previous_action[0] = dir;
    }
  }
  player->upkeep->running_firststep = false;
}
STATIC_OVL void
do_cmd_hold_aux(void)
{
  player->upkeep->energy_use = z_info->move_energy;
  player->previous_action[0] = ACTION_STAND;
  player->focused = true;
  event_signal(EVENT_SEEFLOOR);
  square_know_pile(cave, player->grid);
  if (player->stealth_mode) {
    player->stealth_score += 2;
  } else {
    player->stealth_score += 7;
  }
  player->upkeep->update |= (PU_BONUS);
  player->upkeep->redraw |= (PR_STATE | PR_SPEED);
  search(player);
}
STATIC_OVL void
do_cmd_hold(struct command* cmd)
{
  do_cmd_hold_aux();
}
STATIC_OVL bool
do_cmd_walk_test(struct player* p, struct loc grid)
{
  int m_idx = square(cave, grid)->mon;
  struct monster* mon = cave_monster(cave, m_idx);
  if (!square_isknown(cave, grid)) return true;
  if (m_idx > 0 && monster_is_visible(mon)) {
    return true;
  }
  if (!square_ispassable(cave, grid)) {
    if (square_isrubble(cave, grid)) {
      msgt(MSG_HITWALL, "There is a pile of rubble in the way!");
      if (!square_isrubble(p->cave, grid)) {
        square_memorize(cave, grid);
        square_light_spot(cave, grid);
      }
      player->previous_action[0] = ACTION_MISC;
    } else if (square_isrock(cave, grid)) {
      msgt(MSG_HITWALL, "There is a wall in the way!");
      if (square_ispassable(p->cave, grid) || square_isrubble(p->cave, grid) ||
          square_iscloseddoor(p->cave, grid)) {
        square_forget(cave, grid);
        square_light_spot(cave, grid);
      }
      player->previous_action[0] = ACTION_MISC;
    } else {
      return true;
    }
    disturb(player, false);
    return false;
  }
  return true;
}
STATIC_OVL void
do_cmd_walk(struct command* cmd)
{
  struct loc grid;
  int dir;
  if (cmd_get_direction(cmd, "direction", &dir, false) != CMD_OK) return;
  if (dir == DIR_NONE) {
    do_cmd_hold_aux();
    return;
  }
  if (player_confuse_dir(player, &dir, false))
    player->upkeep->energy_use = z_info->move_energy;
  grid = loc_sum(player->grid, ddgrid[dir]);
  if (!square_in_bounds_fully(cave, grid) && square_ispassable(cave, grid) &&
      !square_monster(cave, grid)) {
    do_cmd_escape();
    return;
  } else if (!do_cmd_walk_test(player, grid)) {
    return;
  }
  player->upkeep->energy_use = z_info->move_energy;
  move_player(dir, !square_isdisarmabletrap(cave, grid));
}
STATIC_OVL void
do_cmd_jump(struct command* cmd)
{
  struct loc grid;
  int dir;
  if (cmd_get_direction(cmd, "direction", &dir, false) != CMD_OK) return;
  if (player_confuse_dir(player, &dir, false))
    player->upkeep->energy_use = z_info->move_energy;
  grid = loc_sum(player->grid, ddgrid[dir]);
  if (!do_cmd_walk_test(player, grid)) return;
  player->upkeep->energy_use = z_info->move_energy;
  move_player(dir, false);
}
STATIC_OVL void
do_cmd_run(struct command* cmd)
{
  struct loc grid;
  int dir;
  if (cmd_get_direction(cmd, "direction", &dir, false) != CMD_OK) return;
  if (player_confuse_dir(player, &dir, true)) return;
  if (dir) {
    grid = loc_sum(player->grid, ddgrid[dir]);
    if (!do_cmd_walk_test(player, grid)) return;
    if (cmd->nrepeats > 0) {
      player->upkeep->running = cmd->nrepeats;
      cmd->nrepeats = 0;
    } else {
      player->upkeep->running = 0;
    }
  }
  run_step(dir);
}
STATIC_OVL void
do_cmd_pathfind(struct command* cmd)
{
  struct loc grid;
  cmd_get_arg_point(cmd, "point", &grid);
  if (player->timed[TMD_CONFUSED]) return;
  if (find_path(grid)) {
    player->upkeep->running = 1000;
    player->upkeep->update |= (PU_TORCH);
    player->upkeep->running_withpathfind = true;
    run_step(0);
  }
}
STATIC_OVL void
do_cmd_change_song(struct command* cmd)
{
  change_song();
}
STATIC_OVL void
do_cmd_rest(struct command* cmd)
{
  int n;
  if (cmd_get_arg_choice(cmd, "choice", &n) != CMD_OK) return;
  if (OPT(player, stop_singing_on_rest)) {
    player_change_song(player, NULL, false);
  }
  if (n < 0 && !player_resting_is_special(n)) return;
  if (!player_is_resting(player)) {
    player->upkeep->update |= (PU_BONUS);
    if (n > 1)
      player_set_resting_repeat_count(player, n);
    else if (n == 1)
      n = player_get_resting_repeat_count(player);
  }
  player_resting_set_count(player, n);
  if (!player_is_resting(player)) return;
  player_resting_step_turn(player);
  handle_stuff(player);
  if (player_resting_count(player) > 0) {
    cmdq_push(CMD_REST);
    cmd_set_arg_choice(cmdq_peek(), "choice", n - 1);
  } else if (player_resting_is_special(n)) {
    cmdq_push(CMD_REST);
    cmd_set_arg_choice(cmdq_peek(), "choice", n);
    player_set_resting_repeat_count(player, 0);
  } else {
    player_resting_cancel(player, false);
  }
}
STATIC_OVL void
do_cmd_sleep(struct command* cmd)
{
  player_change_song(player, NULL, false);
  player->upkeep->energy_use = z_info->move_energy;
  player->previous_action[0] = ACTION_MISC;
}
STATIC_OVL void
do_cmd_skip(struct command* cmd)
{
  msg("You recover your footing.");
  event_signal(EVENT_MESSAGE_FLUSH);
  player->upkeep->knocked_back = false;
  player->upkeep->energy_use = z_info->move_energy;
  player->previous_action[0] = ACTION_MISC;
}
STATIC_OVL void
cmd_copy(struct command* dest, const struct command* src)
{
  int i;
  *dest = *src;
  for (i = 0; i < CMD_MAX_ARGS; ++i) {
    if (dest->arg[i].type == arg_STRING) {
      dest->arg[i].data.string = string_make(src->arg[i].data.string);
    }
  }
}
STATIC_OVL void
cmd_release(struct command* cmd)
{
  int i;
  for (i = 0; i < CMD_MAX_ARGS; ++i) {
    if (cmd->arg[i].type == arg_STRING) {
      string_free((char*)(cmd->arg[i].data.string));
      cmd->arg[i].name[0] = '\0';
      cmd->arg[i].type = arg_NONE;
    }
  }
}
STATIC_OVL const char*
cmd_verb(cmd_code cmd)
{
  size_t i;
  for (i = 0; i < N_ELEMENTS(game_cmds); i++) {
    if (game_cmds[i].cmd == cmd) return game_cmds[i].verb;
  }
  return NULL;
}
STATIC_OVL int
cmd_idx(cmd_code code)
{
  size_t i;
  for (i = 0; i < N_ELEMENTS(game_cmds); i++)
    if (game_cmds[i].cmd == code) return i;
  return CMD_ARG_NOT_PRESENT;
}
STATIC_OVL struct command*
cmdq_peek(void)
{
  return &cmd_queue[((cmd_head + 20 - 1) % 20)];
}
STATIC_OVL errr
cmdq_push_copy(struct command* cmd)
{
  if (cmd_head + 1 == cmd_tail) return 1;
  if (cmd_head + 1 == 20 && cmd_tail == 0) return 1;
  if (cmd->code != CMD_REPEAT) {
    if (last_command_idx == cmd_head) {
      cmd_release(&last_command);
      cmd_copy(&last_command, &cmd_queue[cmd_head]);
      last_command_idx = -1;
    }
    cmd_release(&cmd_queue[cmd_head]);
    cmd_queue[cmd_head] = *cmd;
  } else if (!repeat_prev_allowed) {
    return 1;
  } else {
    if (last_command_idx >= 0) {
      assert(last_command_idx < 20);
      if (last_command_idx != cmd_head) {
        cmd_release(&cmd_queue[cmd_head]);
        cmd_copy(&cmd_queue[cmd_head], &cmd_queue[last_command_idx]);
      }
    } else if (last_command.code != CMD_NULL) {
      cmd_release(&cmd_queue[cmd_head]);
      cmd_copy(&cmd_queue[cmd_head], &last_command);
    } else {
      return 1;
    }
  }
  cmd_head++;
  if (cmd_head == 20) cmd_head = 0;
  return 0;
}
STATIC_OVL void
process_command(cmd_context ctx, struct command* cmd)
{
  int oldrepeats = cmd->nrepeats;
  int idx = cmd_idx(cmd->code);
  player->upkeep->command_wrk = 0;
  if (idx == -1) return;
  if (game_cmds[idx].repeat_allowed) {
    if (game_cmds[idx].auto_repeat_n > 0 && cmd->nrepeats == 0)
      cmd_set_repeat(game_cmds[idx].auto_repeat_n);
  } else {
    cmd->nrepeats = 0;
    repeating = false;
  }
  repeat_prev_allowed = true;
  cmd->context = ctx;
  if (game_cmds[idx].fn) {
    game_cmds[idx].fn(cmd);
  }
  if (cmd->nrepeats > 0 && oldrepeats == cmd_get_nrepeats())
    cmd_set_repeat(oldrepeats - 1);
}
STATIC_OVL bool
cmdq_pop(cmd_context c)
{
  struct command* cmd;
  if (repeating) {
    cmd = &cmd_queue[((cmd_tail + 20 - 1) % 20)];
  } else if (cmd_head != cmd_tail) {
    cmd = &cmd_queue[cmd_tail++];
    if (cmd_tail == 20) cmd_tail = 0;
  } else {
    return false;
  }
  if (!cmd->is_background_command) {
    last_command_idx = ((cmd_tail + 20 - 1) % 20);
  }
  process_command(c, cmd);
  return true;
}
STATIC_OVL errr
cmdq_push_repeat(cmd_code c, int nrepeats)
{
  struct command cmd = {.context = CTX_INIT,
                        .code = CMD_NULL,
                        .nrepeats = 0,
                        .is_background_command = false,
                        .arg = {{0}}};
  if (cmd_idx(c) == -1) return 1;
  cmd.code = c;
  cmd.nrepeats = nrepeats;
  return cmdq_push_copy(&cmd);
}
STATIC_OVL errr
cmdq_push(cmd_code c)
{
  return cmdq_push_repeat(c, 0);
}
STATIC_OVL void
cmdq_execute(cmd_context ctx)
{
  while (cmdq_pop(ctx))
    ;
}
STATIC_OVL void
cmdq_flush(void)
{
  cmd_tail = cmd_head;
}
STATIC_OVL void
cmdq_release(void)
{
  int i;
  cmdq_flush();
  for (i = 0; i < 20; ++i) {
    cmd_release(cmd_queue + i);
  }
  cmd_release(&last_command);
  last_command.code = CMD_NULL;
  last_command_idx = -1;
}
STATIC_OVL void
cmd_cancel_repeat(void)
{
  struct command* cmd = &cmd_queue[((cmd_tail + 20 - 1) % 20)];
  if (cmd->nrepeats || repeating) {
    cmd->nrepeats = 0;
    repeating = false;
    player->upkeep->redraw |= (PR_STATE);
  }
}
STATIC_OVL void
cmd_set_repeat(int nrepeats)
{
  struct command* cmd = &cmd_queue[((cmd_tail + 20 - 1) % 20)];
  cmd->nrepeats = nrepeats;
  if (nrepeats)
    repeating = true;
  else
    repeating = false;
  player->upkeep->redraw |= (PR_STATE);
}
STATIC_OVL int
cmd_get_nrepeats(void)
{
  struct command* cmd = &cmd_queue[((cmd_tail + 20 - 1) % 20)];
  return cmd->nrepeats;
}
STATIC_OVL void
cmd_disable_repeat(void)
{
  repeat_prev_allowed = false;
}
STATIC_OVL void
cmd_disable_repeat_floor_item(void)
{
  int cmd_prev;
  if (!repeat_prev_allowed) return;
  cmd_prev = cmd_head - 1;
  if (cmd_prev < 0) cmd_prev = 20 - 1;
  if (cmd_queue[cmd_prev].code != CMD_NULL) {
    struct command* cmd = &cmd_queue[cmd_prev];
    int i = 0;
    while (1) {
      if (i >= CMD_MAX_ARGS) {
        break;
      }
      if (cmd->arg[i].type == arg_ITEM && cmd->arg[i].data.obj &&
          (cmd->arg[i].data.obj->grid.x != 0 ||
           cmd->arg[i].data.obj->grid.y != 0)) {
        repeat_prev_allowed = false;
        break;
      }
      ++i;
    }
  }
}
STATIC_OVL void
cmd_set_arg(struct command* cmd, const char* name, enum cmd_arg_type type,
            union cmd_arg_data data)
{
  size_t i;
  int first_empty = -1;
  int idx = -1;
  assert(name);
  assert(name[0]);
  for (i = 0; i < CMD_MAX_ARGS; i++) {
    struct cmd_arg* arg = &cmd->arg[i];
    if (!arg->name[0] && first_empty == -1) first_empty = i;
    if (streq(arg->name, name)) {
      idx = i;
      break;
    }
  }
  assert(first_empty != -1 || idx != -1);
  if (idx == -1) {
    idx = first_empty;
  } else {
    if (cmd->arg[idx].type == arg_STRING) {
      string_free((char*)(cmd->arg[idx].data.string));
    }
  }
  cmd->arg[idx].type = type;
  cmd->arg[idx].data = data;
  my_strcpy(cmd->arg[idx].name, name, sizeof cmd->arg[0].name);
}
STATIC_OVL int
cmd_get_arg(struct command* cmd, const char* arg, enum cmd_arg_type type,
            union cmd_arg_data* data)
{
  size_t i;
  for (i = 0; i < CMD_MAX_ARGS; i++) {
    if (streq(cmd->arg[i].name, arg)) {
      if (cmd->arg[i].type != type) return CMD_ARG_WRONG_TYPE;
      *data = cmd->arg[i].data;
      return CMD_OK;
    }
  }
  return CMD_ARG_NOT_PRESENT;
}
STATIC_OVL void
cmd_set_arg_choice(struct command* cmd, const char* arg, int choice)
{
  union cmd_arg_data data;
  data.choice = choice;
  cmd_set_arg(cmd, arg, arg_CHOICE, data);
}
STATIC_OVL int
cmd_get_arg_choice(struct command* cmd, const char* arg, int* choice)
{
  union cmd_arg_data data;
  int err;
  if ((err = cmd_get_arg(cmd, arg, arg_CHOICE, &data)) == CMD_OK)
    *choice = data.choice;
  return err;
}
STATIC_OVL int
cmd_get_effect_from_list(struct command* cmd, const char* arg, int* choice,
                         const char* prompt, struct effect* effect, int count,
                         bool allow_random)
{
  int selection;
  if (count == -1) {
    struct effect* cursor = effect;
    count = 0;
    while (cursor) {
      ++count;
      cursor = effect_next(cursor);
    }
  }
  if (cmd_get_arg_choice(cmd, arg, &selection) != CMD_OK ||
      ((selection != -2 || !allow_random) &&
       (selection < 0 || selection >= count))) {
    selection = get_effect_from_list(prompt, effect, count, allow_random);
  }
  if ((selection == -2 && allow_random) ||
      (selection >= 0 && selection < count)) {
    cmd_set_arg_choice(cmd, arg, selection);
    *choice = selection;
    return CMD_OK;
  }
  return CMD_ARG_ABORTED;
}
STATIC_OVL void
cmd_set_arg_string(struct command* cmd, const char* arg, const char* str)
{
  union cmd_arg_data data;
  data.string = string_make(str);
  cmd_set_arg(cmd, arg, arg_STRING, data);
}
STATIC_OVL int
cmd_get_arg_string(struct command* cmd, const char* arg, const char** str)
{
  union cmd_arg_data data;
  int err;
  if ((err = cmd_get_arg(cmd, arg, arg_STRING, &data)) == CMD_OK)
    *str = data.string;
  return err;
}
STATIC_OVL int
cmd_get_string(struct command* cmd, const char* arg, const char** str,
               const char* initial, const char* title, const char* prompt)
{
  char tmp[80] = "";
  if (cmd_get_arg_string(cmd, arg, str) == CMD_OK) return CMD_OK;
  msg("%s", title);
  event_signal(EVENT_MESSAGE_FLUSH);
  if (initial) my_strcpy(tmp, initial, sizeof tmp);
  if (get_string(prompt, tmp, sizeof tmp)) {
    cmd_set_arg_string(cmd, arg, tmp);
    if (cmd_get_arg_string(cmd, arg, str) == CMD_OK) return CMD_OK;
  }
  return CMD_ARG_ABORTED;
}
STATIC_OVL void
cmd_set_arg_direction(struct command* cmd, const char* arg, int dir)
{
  union cmd_arg_data data;
  data.direction = dir;
  cmd_set_arg(cmd, arg, arg_DIRECTION, data);
}
STATIC_OVL int
cmd_get_arg_direction(struct command* cmd, const char* arg, int* dir)
{
  union cmd_arg_data data;
  int err;
  if ((err = cmd_get_arg(cmd, arg, arg_DIRECTION, &data)) == CMD_OK)
    *dir = data.direction;
  return err;
}
STATIC_OVL int
cmd_get_direction(struct command* cmd, const char* arg, int* dir, bool allow_5)
{
  if (cmd_get_arg_direction(cmd, arg, dir) == CMD_OK) {
    if (*dir != DIR_NONE) return CMD_OK;
  }
  if (get_rep_dir(dir, allow_5)) {
    cmd_set_arg_direction(cmd, arg, *dir);
    return CMD_OK;
  }
  cmd_cancel_repeat();
  return CMD_ARG_ABORTED;
}
STATIC_OVL void
cmd_set_arg_target(struct command* cmd, const char* arg, int target)
{
  union cmd_arg_data data;
  data.direction = target;
  cmd_set_arg(cmd, arg, arg_TARGET, data);
}
STATIC_OVL int
cmd_get_arg_target(struct command* cmd, const char* arg, int* target)
{
  union cmd_arg_data data;
  int err;
  if ((err = cmd_get_arg(cmd, arg, arg_TARGET, &data)) == CMD_OK)
    *target = data.direction;
  return err;
}
STATIC_OVL int
cmd_get_target(struct command* cmd, const char* arg, int* target, int range,
               bool allow_vertical)
{
  if (cmd_get_arg_target(cmd, arg, target) == CMD_OK) {
    if (*target != DIR_UNKNOWN && (*target != DIR_TARGET || target_okay(range)))
      return CMD_OK;
  }
  if (get_aim_dir(target, range) &&
      (((*target != DIR_UP) && (*target != DIR_DOWN)) || allow_vertical)) {
    cmd_set_arg_target(cmd, arg, *target);
    return CMD_OK;
  }
  return CMD_ARG_ABORTED;
}
STATIC_OVL void
cmd_set_arg_point(struct command* cmd, const char* arg, struct loc grid)
{
  union cmd_arg_data data;
  data.point = grid;
  cmd_set_arg(cmd, arg, arg_POINT, data);
}
STATIC_OVL int
cmd_get_arg_point(struct command* cmd, const char* arg, struct loc* grid)
{
  union cmd_arg_data data;
  int err;
  if ((err = cmd_get_arg(cmd, arg, arg_POINT, &data)) == CMD_OK) {
    *grid = data.point;
  }
  return err;
}
STATIC_OVL void
cmd_set_arg_item(struct command* cmd, const char* arg, struct object* obj)
{
  union cmd_arg_data data;
  data.obj = obj;
  cmd_set_arg(cmd, arg, arg_ITEM, data);
}
STATIC_OVL int
cmd_get_arg_item(struct command* cmd, const char* arg, struct object** obj)
{
  union cmd_arg_data data;
  int err;
  if ((err = cmd_get_arg(cmd, arg, arg_ITEM, &data)) == CMD_OK) *obj = data.obj;
  return err;
}
STATIC_OVL int
cmd_get_item(struct command* cmd, const char* arg, struct object** obj,
             const char* prompt, const char* reject, item_tester filter,
             int mode)
{
  if ((cmd_get_arg_item(cmd, arg, obj) == CMD_OK) && (!filter || filter(*obj)))
    return CMD_OK;
  if (get_item(obj, prompt, reject, cmd->code, filter, mode)) {
    cmd_set_arg_item(cmd, arg, *obj);
    return CMD_OK;
  }
  return CMD_ARG_ABORTED;
}
STATIC_OVL void
cmd_set_arg_number(struct command* cmd, const char* arg, int amt)
{
  union cmd_arg_data data;
  data.number = amt;
  cmd_set_arg(cmd, arg, arg_NUMBER, data);
}
STATIC_OVL int
cmd_get_arg_number(struct command* cmd, const char* arg, int* amt)
{
  union cmd_arg_data data;
  int err;
  if ((err = cmd_get_arg(cmd, arg, arg_NUMBER, &data)) == CMD_OK)
    *amt = data.number;
  return err;
}
STATIC_OVL int
cmd_get_quantity(struct command* cmd, const char* arg, int* amt, int max)
{
  if (cmd_get_arg_number(cmd, arg, amt) == CMD_OK) return CMD_OK;
  *amt = get_quantity(NULL, max);
  if (*amt > 0) {
    cmd_set_arg_number(cmd, arg, *amt);
    return CMD_OK;
  }
  return CMD_ARG_ABORTED;
}
STATIC_OVL void
do_cmd_wizard(void)
{
  if (!(player->noscore & NOSCORE_WIZARD)) {
    msg("You are about to enter 'wizard' mode for the very first time!");
    msg("This is a form of cheating, and your game will not be scored!");
    event_signal(EVENT_MESSAGE_FLUSH);
    if (!get_check("Are you sure you want to enter wizard mode? ")) return;
    player->noscore |= NOSCORE_WIZARD;
  }
  if (player->wizard) {
    player->wizard = false;
    msg("Wizard mode off.");
  } else {
    player->wizard = true;
    msg("Wizard mode on.");
  }
  player->upkeep->update |= (PU_MONSTERS);
}
STATIC_OVL void
do_cmd_escape(void)
{
  time_t ct = time((time_t*)0);
  char long_day[40];
  char buf[120];
  player->escaped = true;
  event_signal(EVENT_INPUT_FLUSH);
  event_signal(EVENT_DEATH);
  player->is_dead = true;
  (void)strftime(long_day, 40, "%d %B %Y", localtime(&ct));
  strnfmt(buf, sizeof(buf), "You escaped the Iron Hells on %s.", long_day);
  history_add(player, buf, HIST_ESCAPE);
  switch (silmarils_possessed(player)) {
    case 0: {
      history_add(player, "You returned empty handed.", HIST_ESCAPE);
      break;
    }
    case 1: {
      history_add(player, "You brought back a Silmaril from Morgoth's crown!",
                  HIST_ESCAPE);
      break;
    }
    case 2: {
      history_add(player,
                  "You brought back two Silmarils from Morgoth's crown!",
                  HIST_ESCAPE);
      break;
    }
    case 3: {
      history_add(player,
                  "You brought back all three Silmarils from Morgoth's crown!",
                  HIST_ESCAPE);
      break;
    }
    default: {
      history_add(player,
                  "You brought back so many Silmarils that people should be "
                  "suspicious!",
                  HIST_ESCAPE);
    }
  }
  my_strcpy(player->died_from, "ripe old age", sizeof(player->died_from));
}
STATIC_OVL void
do_cmd_retire(struct command* cmd)
{
  player->is_dead = true;
  my_strcpy(player->died_from, "Retiring", sizeof(player->died_from));
}
STATIC_OVL void
do_cmd_note(void)
{
  char tmp[70];
  char note[90];
  my_strcpy(tmp, "", sizeof(tmp));
  my_strcpy(note, "", sizeof(note));
  if (!get_string("Note: ", tmp, sizeof(tmp))) return;
  if (!tmp[0] || (tmp[0] == ' ')) return;
  if (strncmp(tmp, "/say ", 5) == 0)
    strnfmt(note, sizeof(note), "-- %s says: \"%s\"", player->full_name,
            &tmp[5]);
  else if (strncmp(tmp, "/me", 3) == 0)
    strnfmt(note, sizeof(note), "-- %s%s", player->full_name, &tmp[3]);
  else
    strnfmt(note, sizeof(note), "-- Note: %s", tmp);
  msg("%s", &note[3]);
  history_add(player, note, HIST_USER_INPUT);
}
STATIC_OVL int
check_devices(struct object* obj)
{
  int score = player->state.skill_use[SKILL_WILL];
  int difficulty = obj->kind->level / 2;
  if (player_active_ability(player, "Channeling")) {
    score += 5;
  }
  if (player->timed[TMD_CONFUSED]) difficulty += 5;
  if (skill_check(source_player(), score, difficulty, source_none()) <= 0) {
    event_signal(EVENT_INPUT_FLUSH);
    msg("You failed to use the staff properly.");
    return false;
  }
  if (!obj_has_charges(obj)) {
    event_signal(EVENT_INPUT_FLUSH);
    msg("That staff has no charges left.");
    obj->notice |= (OBJ_NOTICE_EMPTY);
    return false;
  }
  return true;
}
STATIC_OVL void
do_cmd_uninscribe(struct command* cmd)
{
  struct object* obj;
  if (cmd_get_item(cmd, "item", &obj, "Uninscribe which item?",
                   "You have nothing you can uninscribe.", obj_has_inscrip,
                   USE_EQUIP | USE_INVEN | USE_QUIVER | USE_FLOOR) != CMD_OK)
    return;
  obj->note = 0;
  msg("Inscription removed.");
  player->upkeep->notice |= (PN_COMBINE | PN_IGNORE);
  player->upkeep->redraw |= (PR_INVEN | PR_EQUIP);
}
STATIC_OVL void
do_cmd_inscribe(struct command* cmd)
{
  struct object* obj;
  const char* str;
  char prompt[1024];
  char o_name[80];
  if (cmd_get_item(cmd, "item", &obj, "Inscribe which item?",
                   "You have nothing to inscribe.", NULL,
                   USE_EQUIP | USE_INVEN | USE_QUIVER | USE_FLOOR |
                       IS_HARMLESS) != CMD_OK)
    return;
  object_desc(o_name, sizeof(o_name), obj, ODESC_PREFIX | ODESC_FULL, player);
  strnfmt(prompt, sizeof prompt, "Inscribing %s.", o_name);
  if (cmd_get_string(cmd, "inscription", &str, quark_str(obj->note), prompt,
                     "Inscribe with what? ") != CMD_OK)
    return;
  obj->note = quark_add(str);
  player->upkeep->notice |= (PN_COMBINE | PN_IGNORE);
  player->upkeep->redraw |= (PR_INVEN | PR_EQUIP);
}
STATIC_OVL void
do_cmd_autoinscribe(struct command* cmd)
{
  autoinscribe_ground(player);
  autoinscribe_pack(player);
  player->upkeep->redraw |= (PR_INVEN | PR_EQUIP);
}
STATIC_OVL void
do_cmd_takeoff(struct command* cmd)
{
  struct object* obj;
  if (cmd_get_item(cmd, "item", &obj, "Take off or unwield which item?",
                   "You have nothing to take off or unwield.", obj_can_takeoff,
                   USE_EQUIP) != CMD_OK)
    return;
  if (handle_stickied_removal(player, obj)) {
    return;
  }
  inven_takeoff(obj);
  combine_pack(player);
  pack_overflow(obj);
  player->upkeep->energy_use = z_info->move_energy;
  player->previous_action[0] = ACTION_MISC;
}
STATIC_OVL void
do_cmd_wield(struct command* cmd)
{
  struct object* equip_obj;
  struct object* weapon = equipped_item_by_slot_name(player, "weapon");
  int shield_slot = slot_by_name(player, "arm");
  char o_name[80];
  unsigned n;
  int slot;
  struct object* obj;
  struct ability* ability;
  bool two_weapon = false;
  bool combine = false;
  if (cmd_get_item(cmd, "item", &obj, "Wear or wield which item?",
                   "You have nothing to wear or wield.", obj_can_wear,
                   USE_INVEN | USE_FLOOR | USE_QUIVER) != CMD_OK)
    return;
  if (!object_is_carried(player, obj) &&
      (player->upkeep->total_weight + obj->weight >
       weight_limit(player->state) * 3 / 2)) {
    object_desc(o_name, sizeof(o_name), obj, ODESC_PREFIX | ODESC_FULL, player);
    if (obj->kind) msg("You cannot lift %s.", o_name);
    return;
  }
  if (tval_is_ammo(obj)) {
    int quiver1_slot = slot_by_name(player, "first quiver");
    struct object* quiver1_obj =
        equipped_item_by_slot_name(player, "first quiver");
    int quiver2_slot = slot_by_name(player, "second quiver");
    struct object* quiver2_obj =
        equipped_item_by_slot_name(player, "second quiver");
    if (quiver1_obj && object_similar(quiver1_obj, obj, OSTACK_PACK) &&
        quiver1_obj->number < quiver1_obj->kind->base->max_stack) {
      slot = quiver1_slot;
      equip_obj = quiver1_obj;
      combine = true;
    } else if (quiver2_obj && object_similar(quiver2_obj, obj, OSTACK_PACK) &&
               quiver2_obj->number < quiver2_obj->kind->base->max_stack) {
      slot = quiver2_slot;
      equip_obj = quiver2_obj;
      combine = true;
    } else if (quiver1_obj && quiver2_obj) {
      if (cmd_get_item(cmd, "replace", &equip_obj,
                       "Replace which set of arrows? ",
                       "Error in do_cmd_wield(), please report.", tval_is_ammo,
                       USE_EQUIP) != CMD_OK) {
        return;
      }
      slot = equipped_item_slot(player->body, equip_obj);
    } else {
      slot = (quiver1_obj) ? quiver2_slot : quiver1_slot;
      equip_obj = NULL;
      assert(!slot_object(player, slot));
    }
  } else {
    slot = wield_slot(obj);
    equip_obj = slot_object(player, slot);
  }
  if (of_has(obj->flags, OF_TWO_HANDED) && slot_object(player, shield_slot)) {
    bool shield = tval_is_shield(slot_object(player, shield_slot));
    const char* thing = shield ? "shield" : "off-hand weapon";
    if (obj_is_cursed(slot_object(player, shield_slot))) {
      msg("You would need to remove your %s, but cannot bear to part with it.",
          thing);
      return;
    }
    if (!object_is_carried(player, obj) && pack_is_full()) {
      event_signal(EVENT_INPUT_FLUSH);
      msg("This would require removing (and dropping) your %s.", thing);
      if (!get_check("Proceed? ")) {
        return;
      }
    }
  }
  if ((slot == shield_slot) && weapon && of_has(weapon->flags, OF_TWO_HANDED)) {
    if (obj_is_cursed(weapon)) {
      msg("You would need to remove your weapon, but cannot bear to part with "
          "it.");
      return;
    }
    if (!object_is_carried(player, obj) && pack_is_full()) {
      event_signal(EVENT_INPUT_FLUSH);
      msg("This would require removing (and dropping) your weapon.");
      if (!get_check("Proceed? ")) {
        return;
      }
    }
  }
  if (!equip_obj) {
    inven_wield(obj, slot);
    return;
  }
  if (tval_is_ring(obj)) {
    if (cmd_get_item(cmd, "replace", &equip_obj, "Replace which ring? ",
                     "Error in do_cmd_wield(), please report.", tval_is_ring,
                     USE_EQUIP) != CMD_OK)
      return;
    slot = equipped_item_slot(player->body, equip_obj);
  }
  for (ability = obj->known->abilities; ability; ability = ability->next) {
    if (streq(ability->name, "Two Weapon Fighting")) {
      two_weapon = true;
    }
  }
  if ((player_active_ability(player, "Two Weapon Fighting") || two_weapon) &&
      tval_is_melee_weapon(obj)) {
    if (!of_has(obj->flags, OF_TWO_HANDED) &&
        !of_has(obj->flags, OF_HAND_AND_A_HALF)) {
      if (get_check("Do you wish to wield it in your off-hand? ")) {
        slot = shield_slot;
        equip_obj = slot_object(player, slot);
        if (!equip_obj) {
          inven_wield(obj, slot);
          return;
        }
      }
    }
  }
  if (!obj_can_takeoff(equip_obj)) {
    object_desc(o_name, sizeof(o_name), equip_obj, ODESC_BASE, player);
    msg("You cannot remove the %s you are %s.", o_name,
        equip_describe(player, slot));
    return;
  }
  n = check_for_inscrip(equip_obj, "!t");
  while (n--) {
    object_desc(o_name, sizeof(o_name), equip_obj, ODESC_PREFIX | ODESC_FULL,
                player);
    if (!get_check(format("Really take off %s? ", o_name))) return;
  }
  if (handle_stickied_removal(player, equip_obj)) {
    return;
  }
  if (combine) {
    int quantity =
        MIN(obj->number, equip_obj->kind->base->max_stack - equip_obj->number);
    struct object* wielded;
    bool dummy = false;
    assert(quantity);
    if (object_is_carried(player, obj)) {
      wielded = gear_object_for_use(player, obj, quantity, false, &dummy);
      object_absorb(equip_obj, wielded);
    } else {
      quantity = MIN(quantity, inven_carry_num(player, obj));
      assert(quantity);
      wielded = floor_object_for_use(player, obj, quantity, false, &dummy);
      inven_carry(player, wielded, true, true);
    }
  } else {
    inven_takeoff(equip_obj);
    if (!object_is_carried(player, obj)) {
      combine_pack(player);
      pack_overflow(equip_obj);
    }
    inven_wield(obj, slot);
  }
}
STATIC_OVL void
do_cmd_drop(struct command* cmd)
{
  int amt;
  struct object* obj;
  if (cmd_get_item(cmd, "item", &obj, "Drop which item?",
                   "You have nothing to drop.", NULL,
                   USE_EQUIP | USE_INVEN | USE_QUIVER) != CMD_OK)
    return;
  if (handle_stickied_removal(player, obj)) {
    return;
  }
  if (cmd_get_quantity(cmd, "quantity", &amt, obj->number) != CMD_OK) return;
  inven_drop(obj, amt);
  player->upkeep->energy_use = z_info->move_energy;
  player->previous_action[0] = ACTION_MISC;
}
STATIC_OVL void
use_aux(struct command* cmd, struct object* obj, enum use use, int snd,
        bool allow_vertical)
{
  struct effect* effect = object_effect(obj);
  bool from_floor = !object_is_carried(player, obj);
  bool can_use = true;
  bool was_aware;
  bool known_aim = false;
  bool none_left = false;
  int dir = 5;
  struct trap_kind* rune = lookup_trap("glyph of warding");
  if (cmd_get_arg_item(cmd, "item", &obj) != CMD_OK) assert(0);
  was_aware = object_flavor_is_aware(obj);
  if (tval_is_horn(obj) || was_aware) {
    known_aim = true;
  }
  if (obj_needs_aim(obj)) {
    if (!known_aim) {
      dir = ddd[randint0(8)];
    } else if (cmd_get_target(cmd, "target", &dir, 0, allow_vertical) !=
               CMD_OK) {
      return;
    }
    player_confuse_dir(player, &dir, false);
  }
  track_object(player->upkeep, obj);
  assert(effect);
  if (use == USE_VOICE) {
    int voice_cost = player_active_ability(player, "Channeling") ? 10 : 20;
    if (player->csp < voice_cost) {
      event_signal(EVENT_INPUT_FLUSH);
      msg("You are out of breath.");
      return;
    }
    msg("You sound a loud note on the horn.");
    player->csp -= voice_cost;
    player->upkeep->redraw |= PR_MANA;
  }
  if (use == USE_CHARGE) {
    can_use = check_devices(obj);
  }
  if (can_use) {
    uint16_t number;
    bool ident = false, describe = false, deduct_before, used;
    struct object* work_obj;
    struct object* first_remainder = NULL;
    char label = '\0';
    if (from_floor) {
      number = obj->number;
    } else {
      label = gear_to_label(player, obj);
      if (use != USE_VOICE) {
        number = object_pack_total(player, obj, false, &first_remainder);
        if (first_remainder && first_remainder->number == number) {
          first_remainder = NULL;
        }
      } else {
        number = obj->number;
      }
    }
    if (obj->kind->effect_msg) {
      msgt(snd, "%s", obj->kind->effect_msg);
    } else {
      sound(snd);
    }
    if (from_floor) {
      if (use == USE_SINGLE) {
        deduct_before = true;
        work_obj = floor_object_for_use(player, obj, 1, false, &none_left);
      } else {
        if (use == USE_CHARGE) {
          deduct_before = true;
          obj->pval--;
          obj->used++;
        } else {
          deduct_before = false;
        }
        work_obj = object_new();
        object_copy(work_obj, obj);
        work_obj->oidx = 0;
        if (obj->known) {
          work_obj->known = object_new();
          object_copy(work_obj->known, obj->known);
          work_obj->known->oidx = 0;
        }
      }
    } else {
      deduct_before = false;
      work_obj = object_new();
      object_copy(work_obj, obj);
      work_obj->oidx = 0;
      if (obj->known) {
        work_obj->known = object_new();
        object_copy(work_obj->known, obj->known);
        work_obj->known->oidx = 0;
      }
    }
    target_fix();
    used = effect_do(effect, source_player(), obj, &ident, was_aware, dir, cmd);
    target_release();
    if (use == USE_VOICE) {
      player_change_song(player, NULL, false);
    }
    if (!used) {
      if (deduct_before) {
        if (use == USE_SINGLE) {
          struct object* wcopy = object_new();
          object_copy(wcopy, work_obj);
          if (from_floor) {
            drop_near(cave, &wcopy, 0, player->grid, false, true);
          } else {
            inven_carry(player, wcopy, true, false);
          }
        } else if (use == USE_CHARGE) {
          obj->pval++;
          obj->used--;
        }
      }
      if (was_aware || !ident) {
        if (work_obj->known) {
          object_delete(player->cave, NULL, &work_obj->known);
        }
        object_delete(cave, player->cave, &work_obj);
        if (deduct_before) {
          assert(from_floor);
          player->upkeep->redraw |= (PR_OBJECT);
        }
        return;
      }
    }
    if (!was_aware && ident) {
      object_flavor_aware(player, work_obj);
      describe = true;
    } else {
      object_flavor_tried(work_obj);
    }
    if (used && !deduct_before) {
      assert(!from_floor);
      if (use == USE_CHARGE) {
        obj->pval--;
        obj->used++;
        work_obj->pval--;
        work_obj->used++;
      } else if (use == USE_SINGLE) {
        struct object* used_obj =
            gear_object_for_use(player, obj, 1, false, &none_left);
        if (used_obj->known) {
          object_delete(cave, player->cave, &used_obj->known);
        }
        object_delete(cave, player->cave, &used_obj);
      }
    }
    if (describe) {
      char name[80];
      object_desc(name, sizeof(name), work_obj,
                  ODESC_PREFIX | ODESC_FULL | ODESC_ALTNUM |
                      ((number + ((used && use == USE_SINGLE) ? -1 : 0)) << 16),
                  player);
      if (from_floor) {
        msg("You see %s.", name);
      } else if (first_remainder) {
        label = gear_to_label(player, first_remainder);
        msg("You have %s (1st %c).", name, label);
      } else {
        msg("You have %s (%c).", name, label);
      }
    } else if (used && use == USE_CHARGE) {
      if (from_floor) {
        floor_item_charges(work_obj);
      } else {
        inven_item_charges(work_obj);
      }
    }
    if (work_obj->known) object_delete(player->cave, NULL, &work_obj->known);
    object_delete(cave, player->cave, &work_obj);
  }
  player->upkeep->energy_use = z_info->move_energy;
  player->previous_action[0] = ACTION_MISC;
  if (!none_left && !from_floor) apply_autoinscription(player, obj);
  player->upkeep->notice |= (PN_COMBINE);
  player->upkeep->redraw |= (PR_INVEN | PR_EQUIP | PR_OBJECT);
  if (square_trap_specific(cave, player->grid, rune->tidx)) {
    if (square_object(cave, player->grid)) push_object(player->grid);
  }
}
STATIC_OVL void
do_cmd_use_staff(struct command* cmd)
{
  struct object* obj;
  if (cmd_get_item(cmd, "item", &obj, "Use which staff? ",
                   "You have no staves to use.", tval_is_staff,
                   USE_INVEN | USE_FLOOR | SHOW_FAIL) != CMD_OK)
    return;
  use_aux(cmd, obj, USE_CHARGE, MSG_USE_STAFF, false);
}
STATIC_OVL void
do_cmd_blow_horn(struct command* cmd)
{
  struct object* obj;
  if (cmd_get_item(cmd, "item", &obj, "Blow which horn? ",
                   "You have no horns to blow.", tval_is_horn,
                   USE_INVEN | USE_FLOOR | SHOW_FAIL) != CMD_OK)
    return;
  use_aux(cmd, obj, USE_VOICE, MSG_ZAP_ROD, obj_allows_vertical_aim(obj));
}
STATIC_OVL void
do_cmd_eat_food(struct command* cmd)
{
  struct object* obj;
  if (cmd_get_item(cmd, "item", &obj, "Eat which food? ",
                   "You have no food to eat.", tval_is_edible,
                   USE_INVEN | USE_FLOOR) != CMD_OK)
    return;
  if ((player->timed[TMD_FOOD] >= PY_FOOD_MAX) && obj_nourishes(obj)) {
    msg("You are too full to eat it.");
    return;
  }
  use_aux(cmd, obj, USE_SINGLE, MSG_EAT, false);
}
STATIC_OVL void
do_cmd_quaff_potion(struct command* cmd)
{
  struct object* obj;
  if (cmd_get_item(cmd, "item", &obj, "Quaff which potion? ",
                   "You have no potions from which to quaff.", tval_is_potion,
                   USE_INVEN | USE_FLOOR) != CMD_OK)
    return;
  if ((player->timed[TMD_FOOD] >= PY_FOOD_MAX) && obj_nourishes(obj)) {
    msg("You are too full to drink it.");
    return;
  }
  use_aux(cmd, obj, USE_SINGLE, MSG_QUAFF, false);
}
STATIC_OVL void
do_cmd_use(struct command* cmd)
{
  struct object* obj;
  if (cmd_get_item(
          cmd, "item", &obj, "Use which item? ", "You have no items to use.",
          obj_is_useable,
          USE_EQUIP | USE_INVEN | USE_QUIVER | USE_FLOOR | SHOW_FAIL) != CMD_OK)
    return;
  if (tval_is_ammo(obj))
    do_cmd_fire(cmd);
  else if (tval_is_potion(obj))
    do_cmd_quaff_potion(cmd);
  else if (tval_is_edible(obj))
    do_cmd_eat_food(cmd);
  else if (tval_is_horn(obj))
    do_cmd_blow_horn(cmd);
  else if (tval_is_staff(obj))
    do_cmd_use_staff(cmd);
  else if (obj_can_refuel(obj))
    do_cmd_refuel(cmd);
  else if (tval_is_wearable(obj))
    do_cmd_wield(cmd);
  else
    msg("The item cannot be used at the moment");
}
STATIC_OVL void
refill_lamp(struct object* lamp, struct object* obj)
{
  int timeout = lamp->timeout + (obj->timeout ? obj->timeout : obj->pval);
  if (timeout > z_info->fuel_lamp) {
    if (tval_is_light(obj)) {
      if (!get_check(
              "Refueling from this lantern will waste some fuel. Proceed? ")) {
        return;
      }
    } else if (!get_check("Refueling from this flask will waste some fuel. "
                          "Proceed? ")) {
      return;
    }
  } else {
    msg("You fuel your lamp.");
  }
  lamp->timeout = timeout;
  if (lamp->timeout >= z_info->fuel_lamp) {
    lamp->timeout = z_info->fuel_lamp;
    msg("Your lamp is full.");
  }
  if (of_has(obj->flags, OF_TAKES_FUEL)) {
    if (obj->number > 1) {
      struct object* used = object_split(obj, 1);
      used->timeout = 0;
      if (object_is_carried(player, obj) && inven_carry_okay(used))
        inven_carry(player, used, true, true);
      else
        drop_near(cave, &used, 0, player->grid, false, true);
    } else {
      obj->timeout = 0;
    }
    player->upkeep->notice |= (PN_COMBINE);
    player->upkeep->redraw |= (PR_INVEN);
  } else {
    struct object* used;
    bool none_left = false;
    if (object_is_carried(player, obj)) {
      used = gear_object_for_use(player, obj, 1, true, &none_left);
    } else {
      used = floor_object_for_use(player, obj, 1, true, &none_left);
    }
    if (used->known) object_delete(player->cave, NULL, &used->known);
    object_delete(cave, player->cave, &used);
  }
  player->upkeep->update |= (PU_TORCH);
  player->upkeep->redraw |= (PR_EQUIP);
}
STATIC_OVL void
combine_torches(struct object* torch, struct object* obj)
{
  struct object* used;
  bool none_left = false;
  int timeout = torch->timeout + obj->timeout + 5;
  if ((timeout > z_info->fuel_torch) &&
      !get_check("Refueling from this torch will waste some fuel. Proceed? ")) {
    return;
  }
  torch->timeout = timeout;
  msg("You combine the torches.");
  if (torch->timeout >= z_info->fuel_torch) {
    torch->timeout = z_info->fuel_torch;
    msg("Your torch is fully fueled.");
  } else {
    msg("Your torch glows more brightly.");
  }
  if (object_is_carried(player, obj)) {
    used = gear_object_for_use(player, obj, 1, true, &none_left);
  } else {
    used = floor_object_for_use(player, obj, 1, true, &none_left);
  }
  if (used->known) object_delete(player->cave, NULL, &used->known);
  object_delete(cave, player->cave, &used);
  player->upkeep->notice |= (PN_COMBINE);
  player->upkeep->update |= (PU_TORCH);
  player->upkeep->redraw |= (PR_EQUIP | PR_INVEN);
}
STATIC_OVL void
do_cmd_refuel(struct command* cmd)
{
  struct object* light = equipped_item_by_slot_name(player, "light");
  struct object* obj;
  if (!light || !tval_is_light(light)) {
    msg("You are not wielding a light.");
    return;
  } else if (of_has(light->flags, OF_NO_FUEL)) {
    msg("Your light cannot be refilled.");
    return;
  }
  if (cmd_get_item(cmd, "item", &obj, "Refuel with which fuel source? ",
                   "You have nothing you can refuel with.", obj_can_refuel,
                   USE_INVEN | USE_FLOOR | USE_QUIVER) != CMD_OK)
    return;
  if (of_has(light->flags, OF_TAKES_FUEL)) {
    refill_lamp(light, obj);
  } else if (of_has(light->flags, OF_BURNS_OUT)) {
    combine_torches(light, obj);
  } else {
    return;
  }
  player->upkeep->energy_use = z_info->move_energy;
  player->previous_action[0] = ACTION_MISC;
}
STATIC_OVL void
do_cmd_destroy(struct command* cmd)
{
  int amt;
  struct object* obj;
  struct object* weapon = equipped_item_by_slot_name(player, "weapon");
  obj = square_object(cave, player->grid);
  if (obj && (obj->artifact == lookup_artifact_name("of Morgoth")) &&
      obj->pval) {
    if (!weapon) {
      msg("To prise a Silmaril from the crown, you would need to wield a "
          "weapon.");
    } else {
      if (get_check("Will you try to prise a Silmaril from the Iron Crown? ")) {
        prise_silmaril(player);
        player->upkeep->energy_use = z_info->move_energy;
        player->previous_action[0] = ACTION_MISC;
        return;
      }
    }
  }
  if (cmd_get_item(cmd, "item", &obj, "Destroy which item? ",
                   "You have nothing to destroy.", NULL,
                   USE_INVEN | USE_FLOOR) != CMD_OK)
    return;
  if ((obj->artifact == lookup_artifact_name("of Morgoth")) && obj->pval) {
    if (object_is_carried(player, obj)) {
      msg("You would have to put it down first.");
    } else {
      if (!weapon) {
        msg("To prise a Silmaril from the crown, you would need to wield a "
            "weapon.");
      } else {
        msg("You decide to try to prise out a Silmaril after all.");
        prise_silmaril(player);
        player->upkeep->energy_use = z_info->move_energy;
        player->previous_action[0] = ACTION_MISC;
      }
    }
    return;
  }
  if (cmd_get_quantity(cmd, "quantity", &amt, obj->number) != CMD_OK) return;
  if (object_is_carried(player, obj)) {
    if (!inven_destroy(obj, amt)) return;
  } else {
    if (!floor_destroy(obj, amt)) return;
  }
  player->upkeep->energy_use = z_info->move_energy;
  player->previous_action[0] = ACTION_MISC;
}
STATIC_OVL const struct object*
find_stack_object_in_inventory(const struct object* obj,
                               const struct object* start)
{
  const struct object* gear_obj;
  for (gear_obj = (start) ? start : player->gear; gear_obj;
       gear_obj = gear_obj->next) {
    if (!object_is_equipped(player->body, gear_obj) &&
        object_similar(gear_obj, obj, OSTACK_PACK)) {
      return gear_obj;
    }
  }
  return NULL;
}
STATIC_OVL int
auto_pickup_okay(const struct object* obj)
{
  int num = inven_carry_num(player, obj);
  unsigned obj_has_auto, obj_has_maxauto;
  int obj_maxauto;
  if (!num) return 0;
  if (OPT(player, pickup_always)) return num;
  if (obj->notice & OBJ_NOTICE_PICKUP) return num;
  if (check_for_inscrip(obj, "!g")) return 0;
  obj_has_auto = check_for_inscrip(obj, "=g");
  obj_maxauto = INT_MAX;
  obj_has_maxauto = check_for_inscrip_with_int(obj, "=g", &obj_maxauto);
  if (obj_has_auto > obj_has_maxauto) return num;
  if (OPT(player, pickup_inven) || obj_has_maxauto) {
    const struct object* gear_obj = find_stack_object_in_inventory(obj, NULL);
    if (!gear_obj) {
      if (obj_has_maxauto) {
        return (num < obj_maxauto) ? num : obj_maxauto;
      }
      return 0;
    }
    if (!check_for_inscrip(gear_obj, "!g")) {
      unsigned int gear_has_auto = check_for_inscrip(gear_obj, "=g");
      unsigned int gear_has_maxauto;
      int gear_maxauto;
      gear_has_maxauto =
          check_for_inscrip_with_int(gear_obj, "=g", &gear_maxauto);
      if (gear_has_auto > gear_has_maxauto) {
        return num;
      }
      if (obj_has_maxauto || gear_has_maxauto) {
        int max_num = (gear_has_maxauto) ? gear_maxauto : obj_maxauto;
        int pack_num = gear_obj->number;
        while (1) {
          if (!gear_obj->next) {
            break;
          }
          gear_obj = find_stack_object_in_inventory(obj, gear_obj->next);
          if (!gear_obj) {
            break;
          }
          pack_num += gear_obj->number;
        }
        if (pack_num >= max_num) {
          return 0;
        }
        return (num < max_num - pack_num) ? num : max_num - pack_num;
      }
      return num;
    }
  }
  return 0;
}
STATIC_OVL void
player_pickup_aux(struct player* p, struct object* obj, int auto_max,
                  bool domsg)
{
  int max = inven_carry_num(p, obj);
  bool autopick = (obj->notice & OBJ_NOTICE_PICKUP);
  if (max == 0) quit_fmt("Failed pickup of %s", obj->kind->name);
  p->upkeep->notice |= PN_IGNORE;
  if (auto_max && max > auto_max) {
    max = auto_max;
  }
  if (max == obj->number) {
    if (obj->known) {
      square_excise_object(p->cave, p->grid, obj->known);
      delist_object(p->cave, obj->known);
    }
    square_excise_object(cave, p->grid, obj);
    delist_object(cave, obj);
    inven_carry(p, obj, true, domsg);
  } else {
    int num;
    bool dummy;
    struct object* picked_up;
    if (auto_max)
      num = auto_max;
    else
      num = get_quantity(NULL, max);
    if (!num) return;
    picked_up = floor_object_for_use(p, obj, num, false, &dummy);
    inven_carry(p, picked_up, true, domsg);
  }
  if (autopick) return;
  p->previous_action[0] = ACTION_MISC;
  p->upkeep->energy_use = z_info->move_energy;
}
STATIC_OVL void
player_pickup_item(struct player* p, struct object* obj, bool menu)
{
  struct object* current = NULL;
  int floor_max = z_info->floor_size + 1;
  struct object** floor_list = mem_zalloc(floor_max * sizeof(*floor_list));
  int floor_num = 0;
  int i;
  int can_pickup = 0;
  bool call_function_again = false;
  bool domsg = true;
  square_know_pile(cave, p->grid);
  if (!square_object(cave, p->grid)) {
    mem_free(floor_list);
    return;
  }
  if (obj) {
    mem_free(floor_list);
    if (inven_carry_num(p, obj) > 0) {
      player_pickup_aux(p, obj, 0, domsg);
    }
    return;
  }
  floor_num = scan_floor(floor_list, floor_max, p, OFLOOR_VISIBLE, NULL);
  for (i = 0; i < floor_num; i++)
    if (inven_carry_num(p, floor_list[i]) > 0) can_pickup++;
  if (!can_pickup) {
    event_signal(EVENT_SEEFLOOR);
    mem_free(floor_list);
    return;
  }
  if (!menu && !current) {
    if (floor_num > 1)
      menu = true;
    else
      current = floor_list[0];
  }
  if (menu && !current) {
    const char *q, *s;
    struct object* obj_local = NULL;
    q = "Get which item?";
    s = "You see nothing there.";
    if (!get_item(&obj_local, q, s, CMD_PICKUP, inven_carry_okay, USE_FLOOR)) {
      mem_free(floor_list);
      return;
    }
    current = obj_local;
    call_function_again = true;
    domsg = true;
  }
  if (current) {
    player_pickup_aux(p, current, 0, domsg);
  }
  if (call_function_again) player_pickup_item(p, NULL, true);
  mem_free(floor_list);
}
STATIC_OVL bool
do_autopickup(struct player* p)
{
  struct object *obj, *next;
  bool picked_up = false;
  if (!square_object(cave, p->grid)) return false;
  obj = square_object(cave, p->grid);
  while (obj) {
    next = obj->next;
    if (!ignore_item_ok(p, obj)) {
      int auto_num;
      disturb(p, false);
      auto_num = auto_pickup_okay(obj);
      if (auto_num) {
        player_pickup_aux(p, obj, auto_num, true);
        picked_up = true;
      }
    }
    obj = next;
  }
  return picked_up;
}
STATIC_OVL void
do_cmd_pickup(struct command* cmd)
{
  struct object* obj = NULL;
  (void)cmd_get_arg_item(cmd, "item", &obj);
  player_pickup_item(player, obj, false);
  player->upkeep->redraw |= (PR_ITEMLIST);
}
STATIC_OVL void
do_cmd_autopickup(struct command* cmd)
{
  if (do_autopickup(player)) {
    event_signal(EVENT_SEEFLOOR);
  }
  player->upkeep->redraw |= (PR_ITEMLIST);
}
STATIC_OVL void
do_cmd_spoil_artifact(struct command* cmd)
{
  spoil_artifact("artifact.spo");
}
STATIC_OVL void
do_cmd_spoil_monster(struct command* cmd)
{
  spoil_mon_info("mon-info.spo");
}
STATIC_OVL void
do_cmd_spoil_monster_brief(struct command* cmd)
{
  spoil_mon_desc("mon-desc.spo");
}
STATIC_OVL void
do_cmd_spoil_obj(struct command* cmd)
{
  spoil_obj_desc("obj-desc.spo");
}
STATIC_OVL bool
get_int_from_string(const char* s, int* val)
{
  char* endptr;
  long lval = strtol(s, &endptr, 10);
  if (s[0] == '\0' || (*endptr != '\0' && !contains_only_spaces(endptr)) ||
      lval <= INT_MIN || lval >= INT_MAX) {
    return false;
  }
  *val = (int)lval;
  return true;
}
STATIC_OVL bool
get_long_from_string(const char* s, long* val)
{
  char* endptr;
  long lval = strtol(s, &endptr, 10);
  if (s[0] == '\0' || (*endptr != '\0' && !contains_only_spaces(endptr)) ||
      lval <= LONG_MIN || lval >= LONG_MAX) {
    return false;
  }
  *val = lval;
  return true;
}
STATIC_OVL void
prt_binary(const bitflag* flags, int offset, int row, int col, wchar_t ch,
           int num)
{
  int flag;
  for (flag = FLAG_START + offset; flag < FLAG_START + offset + num; flag++) {
    if (of_has(flags, flag)) {
      Term_putch(col++, row, COLOUR_BLUE, ch);
    } else {
      Term_putch(col++, row, COLOUR_WHITE, L'-');
    }
  }
}
STATIC_OVL struct object*
wiz_create_object_from_artifact(const struct artifact* art)
{
  struct object_kind* kind;
  struct object* obj;
  if (!art->name) return NULL;
  kind = lookup_kind(art->tval, art->sval);
  if (!kind) return NULL;
  obj = object_new();
  object_prep(obj, kind, art->level, RANDOMISE);
  obj->artifact = art;
  copy_artifact_data(obj, art);
  mark_artifact_created(art, true);
  return obj;
}
STATIC_OVL struct object*
wiz_create_object_from_kind(struct object_kind* kind)
{
  struct object* obj;
  obj = object_new();
  object_prep(obj, kind, player->depth, RANDOMISE);
  apply_magic(obj, player->depth, false, false, false);
  return obj;
}
STATIC_OVL void
wiz_display_item(const struct object* obj, bool all, const struct player* p)
{
  static const char* flagLabels[] = {
      " sStr", " sDex", " sCon", " sGra", "pFear", "pBlnd", "pConf",
      "pStun", "pHall", "S.Dig", "Regen", "S.Inv", "FrAct", "Rad",
      "Light", "Speed", "Sharp", "SHARP", "Vamp",  "BuOut", "TFuel",
      "NFuel", "Cowrd", "Hungr", "Darkn", "Dangr", "Haunt", "Aggrv",
      "Curse", " Dig1", " Dig2", "Throw", "",      "",      "",
      "",      "",      "",      "",      "",      "",      "",
  };
  int j = 0, i, k, nflg;
  bitflag f[OF_SIZE];
  char buf[256];
  bool* labelsDone;
  if (all) {
    object_flags(obj, f);
  }
  Term_clear();
  object_desc(buf, sizeof(buf), obj, ODESC_PREFIX | ODESC_FULL | ODESC_SPOIL,
              p);
  prt(buf, 2, j);
  prt(format("combat = (%+d,%dd%d) [%+d,%dd%d]", obj->att, obj->ds, obj->dd,
             obj->evn, obj->ps, obj->pd),
      4, j);
  prt(format("kind = %-5lu  tval = %-5d  sval = %-5d  wgt = %-3d     timeout = "
             "%-d",
             (unsigned long)obj->kind->kidx, obj->tval, obj->sval, obj->weight,
             obj->timeout),
      5, j);
  prt(format("number = %-3d  pval = %-5d  name1 = %-4ld  egoidx = %-4ld  cost "
             "= %ld",
             obj->number, obj->pval,
             obj->artifact ? (long)obj->artifact->aidx : 0L,
             obj->ego ? (long)obj->ego->eidx : -1L, (long)object_value(obj)),
      6, j);
  nflg = MIN(OF_MAX - FLAG_START, 80);
  if (nflg >= 6) {
    buf[0] = '+';
    k = (nflg - 6) / 2;
    for (i = 1; i < k; ++i) {
      buf[i] = '-';
    }
  } else {
    k = 0;
  }
  buf[k] = 'F';
  buf[k + 1] = 'L';
  buf[k + 2] = 'A';
  buf[k + 3] = 'G';
  buf[k + 4] = 'S';
  for (i = k + 5; i < nflg - 1; ++i) {
    buf[i] = '-';
  }
  if (nflg >= 7) {
    buf[nflg - 1] = '+';
    buf[nflg] = '\0';
  } else {
    buf[k + 5] = '\0';
  }
  prt(buf, 16, j);
  labelsDone = mem_zalloc(nflg * sizeof(*labelsDone));
  for (k = 0; k < 5; ++k) {
    for (i = 0; i < nflg; ++i) {
      if (labelsDone[i]) {
        buf[i] = ' ';
      } else if (flagLabels[i][k] == '\0') {
        labelsDone[i] = true;
        buf[i] = ' ';
      } else {
        buf[i] = flagLabels[i][k];
      }
    }
    buf[nflg] = '\0';
    prt(buf, 17 + k, j);
  }
  mem_free(labelsDone);
  prt_binary(f, 0, 22, j, L'*', nflg);
}
STATIC_OVL void
wiz_drop_object(struct object* obj)
{
  if (obj == NULL) return;
  obj->origin = ORIGIN_CHEAT;
  obj->origin_depth = convert_depth_to_origin(player->depth);
  drop_near(cave, &obj, 0, player->grid, true, true);
}
STATIC_OVL void
wiz_hack_map(struct chunk* c, struct player* p,
             void (*func)(struct chunk*, void*, struct loc, bool*, uint8_t*),
             void* closure)
{
  int y;
  for (y = Term->offset_y; y < Term->offset_y + SCREEN_HGT; y++) {
    int x;
    for (x = Term->offset_x; x < Term->offset_x + SCREEN_WID; x++) {
      struct loc grid = loc(x, y);
      bool show;
      uint8_t color;
      if (!square_in_bounds_fully(c, grid)) continue;
      (*func)(c, closure, grid, &show, &color);
      if (!show) continue;
      if (loc_eq(grid, p->grid)) {
        print_rel(L'@', color, y, x);
      } else if (square_ispassable(c, grid)) {
        print_rel(L'*', color, y, x);
      } else {
        print_rel(L'#', color, y, x);
      }
    }
  }
}
STATIC_OVL void
wiz_play_item_notify_changed(void)
{
  struct command* cmd = cmdq_peek();
  if (cmd) {
    assert(cmd->code == CMD_WIZ_PLAY_ITEM);
    cmd_set_arg_choice(cmd, "changed", 1);
  }
}
STATIC_OVL void
wiz_play_item_standard_upkeep(struct player* p, struct object* obj)
{
  if (object_is_carried(p, obj)) {
    p->upkeep->update |= (PU_BONUS | PU_INVEN);
    p->upkeep->notice |= (PN_COMBINE);
    p->upkeep->redraw |= (PR_INVEN | PR_EQUIP);
  } else {
    p->upkeep->redraw |= (PR_ITEMLIST);
  }
}
STATIC_OVL void
do_cmd_wiz_acquire(struct command* cmd)
{
  int n, great;
  struct object* nice_obj;
  if (cmd_get_arg_choice(cmd, "choice", &great) != CMD_OK) {
    great = (get_check("Acquire great objects? ")) ? 1 : 0;
    cmd_set_arg_choice(cmd, "choice", great);
  }
  if (cmd_get_arg_number(cmd, "quantity", &n) != CMD_OK) {
    n = get_quantity(
        (great) ? "How many great objects? " : "How many good objects? ", 40);
    if (n < 1) return;
    cmd_set_arg_number(cmd, "quantity", n);
  }
  while (n--) {
    nice_obj = make_object(cave, player->depth, true, great, NULL);
    if (!nice_obj) continue;
    nice_obj->origin = ORIGIN_ACQUIRE;
    nice_obj->origin_depth = convert_depth_to_origin(player->depth);
    drop_near(cave, &nice_obj, 0, player->grid, true, false);
  }
}
STATIC_OVL void
do_cmd_wiz_advance(struct command* cmd)
{
  player_exp_gain(player, PY_MAX_EXP);
  player->chp = player->mhp;
  player->chp_frac = 0;
  player->csp = player->msp;
  player->csp_frac = 0;
  player->upkeep->redraw |= PR_HP | PR_MANA;
}
STATIC_OVL void
do_cmd_wiz_banish(struct command* cmd)
{
  int d, i;
  if (cmd_get_arg_number(cmd, "range", &d) != CMD_OK) {
    d = get_quantity("Zap within what distance? ", z_info->max_sight);
    cmd_set_arg_number(cmd, "range", d);
  }
  for (i = 1; i < cave_monster_max(cave); i++) {
    struct monster* mon = cave_monster(cave, i);
    if (!mon->race) continue;
    if (mon->cdis > d) continue;
    delete_monster_idx(cave, i);
  }
  player->upkeep->redraw |= PR_MONLIST;
}
STATIC_OVL void
do_cmd_wiz_change_item_quantity(struct command* cmd)
{
  struct object* obj;
  int n, nmax;
  int update = 0;
  if (cmd_get_arg_item(cmd, "item", &obj) != CMD_OK) {
    if (!get_item(&obj, "Change quantity of which item? ",
                  "You have nothing to change.", cmd->code, NULL,
                  (USE_INVEN | USE_QUIVER | USE_FLOOR))) {
      return;
    }
    cmd_set_arg_item(cmd, "item", obj);
  } else if (object_is_equipped(player->body, obj)) {
    msg("Can not change the quantity of an equipped item.");
    return;
  }
  if (obj->artifact) {
    msg("Can not modify the quantity of an artifact.");
    return;
  }
  nmax = obj->kind->base->max_stack;
  if (tval_can_have_charges(obj) && obj->pval > 0 && obj->number > 0) {
    nmax = MIN((MAX_PVAL * obj->number) / obj->pval, nmax);
  }
  if (cmd_get_arg_number(cmd, "quantity", &n) != CMD_OK) {
    char prompt[80], s[80];
    strnfmt(prompt, sizeof(prompt), "Quantity (1-%d): ", nmax);
    strnfmt(s, sizeof(s), "%d", obj->number);
    if (!get_string(prompt, s, sizeof(s)) || !get_int_from_string(s, &n) ||
        n < 1 || n > obj->kind->base->max_stack) {
      return;
    }
    cmd_set_arg_number(cmd, "quantity", n);
  }
  n = MAX(1, MIN(nmax, n));
  if (n != obj->number) {
    if (tval_can_have_charges(obj) && obj->number > 0) {
      obj->pval = (obj->pval * n) / obj->number;
    }
    if (cmd_get_arg_choice(cmd, "update", &update) != CMD_OK || update) {
      if (object_is_carried(player, obj)) {
        player->upkeep->total_weight -= obj->number * obj->weight;
        player->upkeep->total_weight += n * obj->weight;
      }
      wiz_play_item_standard_upkeep(player, obj);
    } else {
      wiz_play_item_notify_changed();
    }
    obj->number = n;
  }
}
STATIC_OVL void
do_cmd_wiz_collect_disconnect_stats(struct command* cmd)
{
  static int default_nsim = 50;
  int nsim, stop_on_disconnect;
  if (!stats_are_enabled()) return;
  if (cmd_get_arg_number(cmd, "quantity", &nsim) != CMD_OK) {
    char s[80];
    strnfmt(s, sizeof(s), "%d", default_nsim);
    if (!get_string("Number of simulations: ", s, sizeof(s))) return;
    if (!get_int_from_string(s, &nsim) || nsim < 1) return;
    cmd_set_arg_number(cmd, "quantity", nsim);
  }
  default_nsim = nsim;
  if (cmd_get_arg_choice(cmd, "choice", &stop_on_disconnect) != CMD_OK) {
    stop_on_disconnect =
        get_check("Stop if disconnected level found? ") ? 1 : 0;
    cmd_set_arg_choice(cmd, "choice", stop_on_disconnect);
  }
  disconnect_stats(nsim, stop_on_disconnect != 0);
}
STATIC_OVL void
do_cmd_wiz_collect_obj_mon_stats(struct command* cmd)
{
  static int default_nsim = 50;
  static int default_simtype = 1;
  int nsim, simtype;
  char s[80];
  if (!stats_are_enabled()) return;
  if (cmd_get_arg_number(cmd, "quantity", &nsim) != CMD_OK) {
    strnfmt(s, sizeof(s), "%d", default_nsim);
    if (!get_string("Number of simulations: ", s, sizeof(s))) return;
    if (!get_int_from_string(s, &nsim) || nsim < 1) return;
    cmd_set_arg_number(cmd, "quantity", nsim);
  }
  default_nsim = nsim;
  if (cmd_get_arg_choice(cmd, "choice", &simtype) != CMD_OK) {
    strnfmt(s, sizeof(s), "%d", default_simtype);
    if (!get_string("Type of Sim: Diving (1) or Clearing (2) ", s, sizeof(s)))
      return;
    if (!get_int_from_string(s, &simtype) || simtype < 1 || simtype > 2) return;
    if (simtype == 2) {
      if (get_check("Regen randarts (warning SLOW)? ")) {
        simtype = 3;
      }
    }
    cmd_set_arg_choice(cmd, "choice", simtype);
  }
  default_simtype = (simtype == 1) ? 1 : 2;
  stats_collect(nsim, simtype);
}
STATIC_OVL void
do_cmd_wiz_create_all_artifact(struct command* cmd)
{
  int i;
  for (i = 1; i < z_info->a_max; i++) {
    struct artifact* art = &a_info[i];
    struct object* obj = wiz_create_object_from_artifact(art);
    wiz_drop_object(obj);
  }
}
STATIC_OVL void
do_cmd_wiz_create_all_artifact_from_tval(struct command* cmd)
{
  int tval, i;
  if (cmd_get_arg_number(cmd, "tval", &tval) != CMD_OK) {
    char prompt[80];
    char s[80] = "";
    strnfmt(prompt, sizeof(prompt),
            "Create all artifacts of which tval (1-%d)? ", TV_MAX - 1);
    if (!get_string(prompt, s, sizeof(s))) return;
    if (!get_int_from_string(s, &tval) || tval < 1 || tval >= TV_MAX) return;
    cmd_set_arg_number(cmd, "tval", tval);
  }
  for (i = 1; i < z_info->a_max; i++) {
    struct artifact* art = &a_info[i];
    if (art->tval == tval) {
      struct object* obj = wiz_create_object_from_artifact(art);
      wiz_drop_object(obj);
    }
  }
}
STATIC_OVL void
do_cmd_wiz_create_all_obj(struct command* cmd)
{
  int i;
  for (i = 0; i < z_info->k_max; i++) {
    struct object_kind* kind = &k_info[i];
    struct object* obj;
    if (kind->base == NULL || kind->base->name == NULL) continue;
    if (kf_has(kind->kind_flags, KF_INSTA_ART)) continue;
    obj = wiz_create_object_from_kind(kind);
    wiz_drop_object(obj);
  }
}
STATIC_OVL void
do_cmd_wiz_create_all_obj_from_tval(struct command* cmd)
{
  int tval, art;
  int i;
  if (cmd_get_arg_number(cmd, "tval", &tval) != CMD_OK) {
    char prompt[80];
    char s[80] = "";
    strnfmt(prompt, sizeof(prompt), "Create all items of which tval (1-%d)? ",
            TV_MAX - 1);
    if (!get_string(prompt, s, sizeof(s))) return;
    if (!get_int_from_string(s, &tval) || tval < 1 || tval >= TV_MAX) return;
    cmd_set_arg_number(cmd, "tval", tval);
  }
  if (cmd_get_arg_choice(cmd, "choice", &art) != CMD_OK) {
    art = get_check("Create instant artifacts? ");
    cmd_set_arg_choice(cmd, "choice", art);
  }
  for (i = 0; i < z_info->k_max; i++) {
    struct object_kind* kind = &k_info[i];
    struct object* obj;
    if (kind->tval != tval || (!art && kf_has(kind->kind_flags, KF_INSTA_ART)))
      continue;
    obj = wiz_create_object_from_kind(kind);
    wiz_drop_object(obj);
  }
}
STATIC_OVL void
do_cmd_wiz_create_artifact(struct command* cmd)
{
  int ind;
  if (cmd_get_arg_number(cmd, "index", &ind) != CMD_OK) {
    char prompt[80];
    char s[80] = "";
    strnfmt(prompt, sizeof(prompt), "Create which artifact (1-%d)? ",
            z_info->a_max - 1);
    if (!get_string(prompt, s, sizeof(s))) return;
    if (!get_int_from_string(s, &ind)) return;
    cmd_set_arg_number(cmd, "index", ind);
  }
  if (ind >= 1 && ind < z_info->a_max) {
    struct artifact* art = &a_info[ind];
    struct object* obj = wiz_create_object_from_artifact(art);
    wiz_drop_object(obj);
  } else {
    msg("That's not a valid artifact.");
  }
}
STATIC_OVL void
do_cmd_wiz_create_obj(struct command* cmd)
{
  int ind;
  if (cmd_get_arg_number(cmd, "index", &ind) != CMD_OK) {
    char prompt[80];
    char s[80] = "";
    strnfmt(prompt, sizeof(prompt), "Create which object (0-%d)? ",
            z_info->k_max - 1);
    if (!get_string(prompt, s, sizeof(s))) return;
    if (!get_int_from_string(s, &ind)) return;
    cmd_set_arg_number(cmd, "index", ind);
  }
  if (ind >= 0 && ind < z_info->k_max) {
    struct object_kind* kind = &k_info[ind];
    struct object* obj = wiz_create_object_from_kind(kind);
    wiz_drop_object(obj);
  } else {
    msg("That's not a valid kind of object.");
  }
}
STATIC_OVL void
do_cmd_wiz_create_trap(struct command* cmd)
{
  int tidx;
  if (cmd_get_arg_number(cmd, "index", &tidx) != CMD_OK) {
    char s[80] = "";
    if (!get_string("Create which trap? ", s, sizeof(s))) return;
    if (!get_int_from_string(s, &tidx)) {
      const struct trap_kind* trap = lookup_trap(s);
      tidx = (trap) ? trap->tidx : z_info->trap_max;
    }
    cmd_set_arg_number(cmd, "index", tidx);
  }
  if (!square_player_trap_allowed(cave, player->grid)) {
    msg("You can't place a trap there!");
  } else if (tidx < 1 || tidx >= z_info->trap_max) {
    msg("Trap not found.");
  } else {
    place_trap(cave, player->grid, tidx, 0);
    cmd_disable_repeat();
  }
}
STATIC_OVL void
do_cmd_wiz_cure_all(struct command* cmd)
{
  int i, flag;
  for (i = 0; i < player->body.count; i++) {
    struct object* obj = player->body.slots[i].obj;
    if (obj) {
      for (flag = FLAG_START; flag != FLAG_END;
           flag = of_next(obj->flags, flag + 1)) {
        struct obj_property* prop =
            lookup_obj_property(OBJ_PROPERTY_FLAG, flag);
        if (prop && prop->type == OFT_BAD) {
          of_off(obj->flags, flag);
        }
      }
    }
  }
  for (i = 0; i < STAT_MAX; i++) {
    effect_simple(EF_RESTORE_STAT, source_player(), "20", i, 0, 0, NULL);
  }
  player->chp = player->mhp;
  player->csp = player->msp;
  (void)player_clear_timed(player, TMD_BLIND, true, false);
  (void)player_clear_timed(player, TMD_CONFUSED, true, false);
  (void)player_clear_timed(player, TMD_POISONED, true, false);
  (void)player_clear_timed(player, TMD_AFRAID, true, false);
  (void)player_clear_timed(player, TMD_ENTRANCED, true, false);
  (void)player_clear_timed(player, TMD_IMAGE, true, false);
  (void)player_clear_timed(player, TMD_STUN, true, false);
  (void)player_clear_timed(player, TMD_CUT, true, false);
  (void)player_clear_timed(player, TMD_SLOW, true, false);
  (void)player_clear_timed(player, TMD_DARKENED, true, false);
  player_set_timed(player, TMD_FOOD, PY_FOOD_FULL - 1, false, false);
  player->upkeep->update |= PU_TORCH | PU_UPDATE_VIEW | PU_MONSTERS;
  player->upkeep->redraw |= PR_BASIC | PR_EXTRA | PR_MAP | PR_EQUIP;
  msg("You feel *much* better!");
}
STATIC_OVL void
do_cmd_wiz_detect_all_local(struct command* cmd)
{
  effect_simple(EF_DETECT_TRAPS, source_player(), "0", 0, 0, 0, NULL);
  effect_simple(EF_DETECT_DOORS, source_player(), "0", 0, 0, 0, NULL);
  effect_simple(EF_DETECT_OBJECTS, source_player(), "0", 0, 0, 0, NULL);
  effect_simple(EF_DETECT_MONSTERS, source_player(), "0", 0, 0, 0, NULL);
}
STATIC_OVL void
do_cmd_wiz_detect_all_monsters(struct command* cmd)
{
  effect_simple(EF_DETECT_MONSTERS, source_player(), "0", 0, 0, 0, NULL);
}
STATIC_OVL void
do_cmd_wiz_display_keylog(struct command* cmd)
{
  int i;
  char buf[50];
  char buf2[12];
  struct keypress keys[2] = {KEYPRESS_NULL, KEYPRESS_NULL};
  screen_save();
  prt("Previous keypresses (top most recent):", 0, 0);
  for (i = 0; i < KEYLOG_SIZE; i++) {
    if (i < log_size) {
      int j = (log_i > i) ? log_i - i - 1 : log_i - i - 1 + KEYLOG_SIZE;
      struct keypress k = keylog[j];
      keys[0] = k;
      keypress_to_text(buf2, sizeof(buf2), keys, true);
      strnfmt(buf, sizeof(buf), "    %-12s (code=%lu mods=%u)", buf2,
              (unsigned long)k.code, k.mods);
    } else {
      strnfmt(buf, sizeof(buf), "%40s", "");
    }
    prt(buf, i + 1, 0);
  }
  prt("Press any key to continue.", KEYLOG_SIZE + 1, 0);
  anykey();
  screen_load();
}
STATIC_OVL void
do_cmd_wiz_dump_level_map(struct command* cmd)
{
  char path[1024] = "";
  char title[80];
  ang_file* fo;
  strnfmt(title, sizeof(title), "Map of level %d", player->depth);
  if (!get_file("level.html", path, sizeof(path)) ||
      !get_string("Title for map: ", title, sizeof(title))) {
    return;
  }
  fo = file_open(path, MODE_WRITE, FTYPE_TEXT);
  if (fo) {
    dump_level(fo, title, cave, NULL);
    if (file_close(fo)) {
      msg("Level dumped to %s.", path);
    }
  }
}
STATIC_OVL void
do_cmd_wiz_edit_player_exp(struct command* cmd)
{
  char s[80];
  long newv;
  if (edit_player_state == EDIT_PLAYER_BREAK) return;
  strnfmt(s, sizeof(s), "%ld", (long)(player->exp));
  if (!get_string("Experience: ", s, sizeof(s)) ||
      !get_long_from_string(s, &newv)) {
    edit_player_state = EDIT_PLAYER_BREAK;
    return;
  }
  newv = MIN(PY_MAX_EXP, MAX(0, newv));
  if (newv > player->exp) {
    player_exp_gain(player, newv - player->exp);
  } else {
    player_exp_lose(player, player->exp - newv);
  }
}
STATIC_OVL void
do_cmd_wiz_edit_player_start(struct command* cmd)
{
  int i;
  if (edit_player_state != EDIT_PLAYER_UNKNOWN) {
    edit_player_state = EDIT_PLAYER_UNKNOWN;
    return;
  }
  edit_player_state = EDIT_PLAYER_STARTED;
  for (i = 0; i < STAT_MAX; ++i) {
    if (cmdq_push(CMD_WIZ_EDIT_PLAYER_STAT) != 0) {
      edit_player_state = EDIT_PLAYER_BREAK;
      return;
    }
    cmd_set_arg_choice(cmdq_peek(), "choice", i);
  }
  if (cmdq_push(CMD_WIZ_EDIT_PLAYER_EXP) != 0) {
    edit_player_state = EDIT_PLAYER_BREAK;
    return;
  }
  if (cmdq_push(CMD_WIZ_EDIT_PLAYER_START) != 0) {
    edit_player_state = EDIT_PLAYER_BREAK;
    return;
  }
}
STATIC_OVL void
do_cmd_wiz_edit_player_stat(struct command* cmd)
{
  int stat, newv;
  char prompt[80], s[80];
  if (edit_player_state == EDIT_PLAYER_BREAK) return;
  if (cmd_get_arg_choice(cmd, "choice", &stat) != CMD_OK) {
    strnfmt(prompt, sizeof(prompt),
            "Edit which stat (name or 0-%d): ", STAT_MAX - 1);
    strnfmt(s, sizeof(s), "%s", stat_idx_to_name(0));
    if (!get_string(prompt, s, sizeof(s))) return;
    if (!get_int_from_string(s, &stat)) {
      stat = stat_name_to_idx(s);
      if (stat < 0) {
        return;
      }
    }
    cmd_set_arg_choice(cmd, "choice", stat);
  }
  if (stat < 0 || stat >= STAT_MAX) {
    return;
  }
  strnfmt(prompt, sizeof(prompt), "%s (0-20): ", stat_idx_to_name(stat));
  strnfmt(s, sizeof(s), "%d", player->stat_base[stat]);
  if (!get_string(prompt, s, sizeof(s)) || !get_int_from_string(s, &newv)) {
    edit_player_state = EDIT_PLAYER_BREAK;
    return;
  }
  newv = MIN(20, MAX(0, newv));
  player->stat_base[stat] = newv;
  player->upkeep->update |= (PU_BONUS);
  player->upkeep->redraw |= (PR_STATS);
}
STATIC_OVL void
do_cmd_wiz_hit_all_los(struct command* cmd)
{
  effect_simple(EF_PROJECT_LOS, source_player(), "10000", PROJ_DISP_ALL, 0, 0,
                NULL);
}
STATIC_OVL void
do_cmd_wiz_increase_exp(struct command* cmd)
{
  int n;
  if (cmd_get_arg_number(cmd, "quantity", &n) != CMD_OK) {
    n = get_quantity("Gain how much experience? ", 9999);
    cmd_set_arg_number(cmd, "quantity", n);
  }
  if (n < 1) n = 1;
  player_exp_gain(player, n);
}
STATIC_OVL void
do_cmd_wiz_jump_level(struct command* cmd)
{
  int level, choose_gen;
  if (cmd_get_arg_number(cmd, "level", &level) != CMD_OK) {
    char prompt[80], s[80];
    strnfmt(prompt, sizeof(prompt),
            "Jump to level (0-%d): ", z_info->dun_depth);
    strnfmt(s, sizeof(s), "%d", player->depth);
    if (!get_string(prompt, s, sizeof(s))) return;
    if (!get_int_from_string(s, &level)) return;
    cmd_set_arg_number(cmd, "level", level);
  }
  if (level < 0 || level > z_info->dun_depth) return;
  if (cmd_get_arg_choice(cmd, "choice", &choose_gen) != CMD_OK) {
    choose_gen = (get_check("Choose cave profile? ")) ? 1 : 0;
    cmd_set_arg_choice(cmd, "choice", choose_gen);
  }
  if (choose_gen) {
    player->noscore |= NOSCORE_JUMPING;
  }
  msg("You jump to dungeon level %d.", level);
  dungeon_change_level(player, level);
  player->upkeep->energy_use = z_info->move_energy;
}
STATIC_OVL void
do_cmd_wiz_learn_object_kinds(struct command* cmd)
{
  int level, i;
  if (cmd_get_arg_number(cmd, "level", &level) != CMD_OK) {
    char s[80] = "100";
    if (!get_string("Learn object kinds up to level (0-100)? ", s, sizeof(s)))
      return;
    if (!get_int_from_string(s, &level)) return;
    cmd_set_arg_number(cmd, "level", level);
  }
  for (i = 1; i < z_info->k_max; i++) {
    struct object_kind* kind = &k_info[i];
    if (kind && kind->name && kind->level <= level) {
      kind->aware = true;
    }
  }
  msg("You now know about many items!");
}
STATIC_OVL void
do_cmd_wiz_magic_map(struct command* cmd)
{
  effect_simple(EF_MAP_AREA, source_player(), "0", 0, 0, 0, NULL);
}
STATIC_OVL void
wiz_hack_map_peek_noise(struct chunk* c, void* closure, struct loc grid,
                        bool* show, uint8_t* color)
{
  if (c->player_noise.grids[grid.y][grid.x] == *((int*)closure)) {
    *show = true;
    *color = COLOUR_RED;
  } else {
    *show = false;
  }
}
STATIC_OVL void
wiz_hack_map_peek_scent(struct chunk* c, void* closure, struct loc grid,
                        bool* show, uint8_t* color)
{
  if (c->scent.grids[grid.y][grid.x] == *((int*)closure)) {
    *show = true;
    *color = COLOUR_YELLOW;
  } else {
    *show = false;
  }
}
STATIC_OVL void
do_cmd_wiz_peek_noise_scent(struct command* cmd)
{
  int i;
  char kp;
  for (i = 0; i < 100; i++) {
    wiz_hack_map(cave, player, wiz_hack_map_peek_noise, &i);
    if (!get_com(format("Depth %d: ", i), &kp)) break;
    prt_map();
  }
  for (i = 0; i < 50; i++) {
    wiz_hack_map(cave, player, wiz_hack_map_peek_scent, &i);
    if (!get_com(format("Depth %d: ", i), &kp)) break;
    prt_map();
  }
  prt("", 0, 0);
  prt_map();
}
STATIC_OVL void
do_cmd_wiz_perform_effect(struct command* cmd)
{
  char name[80] = "";
  char dice[80] = "0";
  int index = -1;
  int p1 = 0, p2 = 0, p3 = 0;
  bool ident = false;
  screen_save();
  if (get_string("Do which effect: ", name, sizeof(name))) {
    if (!get_int_from_string(name, &index)) {
      index = effect_lookup(name);
    }
    if (index <= EF_NONE || index >= EF_MAX) {
      msg("No effect found.");
      return;
    }
  }
  if (!get_string("Enter damage dice (eg 1+2d6M2): ", dice, sizeof(dice))) {
    my_strcpy(dice, "0", sizeof(dice));
  }
  my_strcpy(name, "0", sizeof(name));
  if (get_string("Enter name or number for effect subtype: ", name,
                 sizeof(name))) {
    p1 = effect_subtype(index, name);
    if (p1 == -1) p1 = 0;
  }
  p2 = get_quantity("Enter second parameter (radius): ", 100);
  p3 = get_quantity("Enter third parameter (other): ", 100);
  screen_load();
  effect_simple(index, source_player(), dice, p1, p2, p3, &ident);
  if (ident) {
    msg("Identified!");
  }
}
STATIC_OVL void
do_cmd_wiz_play_item(struct command* cmd)
{
  struct object* obj = NULL;
  struct object* orig_obj = NULL;
  int display_all_prop = 1;
  int object_changed = 0;
  bool done = false;
  bool rejected = true;
  const char* done_msg = NULL;
  char ch;
  if (cmd_get_arg_item(cmd, "original_item", &orig_obj) == CMD_OK && orig_obj) {
    if (cmd_get_arg_item(cmd, "item", &obj) != CMD_OK || !obj) {
      assert(0);
      return;
    }
    if (cmd_get_arg_choice(cmd, "all_prop", &display_all_prop) != CMD_OK) {
      assert(0);
      return;
    }
    if (cmd_get_arg_choice(cmd, "changed", &object_changed) != CMD_OK) {
      assert(0);
      return;
    }
  } else {
    if (cmd_get_arg_item(cmd, "item", &obj) != CMD_OK || !obj) {
      if (!get_item(&obj, "Play with which object? ",
                    "You have nothing to play with.", cmd->code, NULL,
                    (USE_EQUIP | USE_INVEN | USE_QUIVER | USE_FLOOR))) {
        return;
      }
    }
    cmd_set_arg_item(cmd, "item", obj);
    orig_obj = object_new();
    object_copy(orig_obj, obj);
    cmd_set_arg_item(cmd, "original_item", orig_obj);
    if (cmd_get_arg_choice(cmd, "all_prop", &display_all_prop) != CMD_OK) {
      display_all_prop = 1;
      cmd_set_arg_choice(cmd, "all_prop", display_all_prop);
    }
    if (cmd_get_arg_choice(cmd, "changed", &object_changed) != CMD_OK) {
      object_changed = 0;
      cmd_set_arg_choice(cmd, "changed", object_changed);
    }
    screen_save();
  }
  wiz_display_item(obj, display_all_prop != 0, player);
  if (get_com("[a]ccept [s]tatistics [r]eroll [t]weak [q]uantity [k]nown? ",
              &ch)) {
    bool queue_failed = false;
    switch (ch) {
      case 'A':
      case 'a':
        done = true;
        rejected = false;
        if (object_changed) {
          if (object_is_carried(player, obj) &&
              (obj->number != orig_obj->number ||
               obj->weight != orig_obj->weight)) {
            player->upkeep->total_weight -= orig_obj->number * orig_obj->weight;
            player->upkeep->total_weight += obj->number * obj->weight;
          }
          object_touch(player, obj);
          if (object_is_equipped(player->body, obj)) {
            assert(obj->known);
            obj->known->notice &= ~OBJ_NOTICE_WORN;
            object_learn_on_wield(player, obj);
          }
          wiz_play_item_standard_upkeep(player, obj);
        }
        break;
      case 'S':
      case 's':
        if (cmdq_push(CMD_WIZ_STAT_ITEM) == 0) {
          cmd_set_arg_item(cmdq_peek(), "item", obj);
        } else {
          queue_failed = true;
        }
        break;
      case 'R':
      case 'r':
        if (cmdq_push(CMD_WIZ_REROLL_ITEM) == 0) {
          cmd_set_arg_item(cmdq_peek(), "item", obj);
          cmd_set_arg_choice(cmdq_peek(), "update", 0);
        } else {
          queue_failed = true;
        }
        break;
      case 'T':
      case 't':
        if (cmdq_push(CMD_WIZ_TWEAK_ITEM) == 0) {
          cmd_set_arg_item(cmdq_peek(), "item", obj);
          cmd_set_arg_choice(cmdq_peek(), "update", 0);
        } else {
          queue_failed = true;
        }
        break;
      case 'K':
      case 'k':
        display_all_prop = !display_all_prop;
        cmd_set_arg_choice(cmd, "all_prop", display_all_prop);
        break;
      case 'Q':
      case 'q':
        if (cmdq_push(CMD_WIZ_CHANGE_ITEM_QUANTITY) == 0) {
          cmd_set_arg_item(cmdq_peek(), "item", obj);
          cmd_set_arg_choice(cmdq_peek(), "update", 0);
        } else {
          queue_failed = true;
        }
        break;
      default:
        break;
    }
    if (queue_failed && get_check("Couldn't proceed.  Stop playing with item "
                                  "and lose all changes? ")) {
      done = true;
      if (object_changed) {
        done_msg = "Bailed out.  Changes to item lost.";
      }
    }
  } else {
    done = true;
    if (object_changed) {
      done_msg = "Changes ignored.";
    }
  }
  if (!done) {
    if (cmdq_push_copy(cmd) != 0) {
      done = true;
      done_msg = "Couldn't queue command.  Changes lost.";
    }
  }
  if (done) {
    if (rejected && object_changed) {
      struct object* prev = obj->prev;
      struct object* next = obj->next;
      mem_free(obj->slays);
      obj->slays = NULL;
      mem_free(obj->brands);
      obj->brands = NULL;
      release_ability_list(obj->abilities);
      obj->abilities = NULL;
      object_copy(obj, orig_obj);
      obj->prev = prev;
      obj->next = next;
    }
    object_delete(cave, player->cave, &orig_obj);
    cmd_set_arg_item(cmd, "original_item", NULL);
    cmd_set_arg_choice(cmd, "changed", 0);
    screen_load();
    if (done_msg) {
      msg("%s", done_msg);
    }
  }
}
STATIC_OVL void
do_cmd_wiz_push_object(struct command* cmd)
{
  struct loc grid;
  if (cmd_get_arg_point(cmd, "point", &grid) != CMD_OK) {
    if (!target_set_interactive(TARGET_KILL, loc(-1, -1), 0)) return;
    target_get(&grid);
    cmd_set_arg_point(cmd, "point", grid);
  }
  push_object(grid);
}
STATIC_OVL void
wiz_hack_map_query_feature(struct chunk* c, void* closure, struct loc grid,
                           bool* show, uint8_t* color)
{
  const struct wiz_query_feature_closure* sel_feats = closure;
  int i = 0;
  int sq_feat = square(c, grid)->feat;
  while (1) {
    if (i >= sel_feats->n) {
      *show = false;
      return;
    }
    if (sq_feat == sel_feats->features[i]) {
      *show = true;
      *color = (square_ispassable(c, grid)) ? COLOUR_YELLOW : COLOUR_RED;
      return;
    }
    ++i;
  }
}
STATIC_OVL void
do_cmd_wiz_query_feature(struct command* cmd)
{
  int feature_class;
  struct wiz_query_feature_closure selected;
  const int featf[] = {FEAT_FLOOR};
  const int feato[] = {FEAT_OPEN};
  const int featb[] = {FEAT_BROKEN};
  const int featu[] = {FEAT_LESS, FEAT_LESS_SHAFT};
  const int featz[] = {FEAT_MORE, FEAT_MORE_SHAFT};
  const int featt[] = {FEAT_LESS, FEAT_MORE, FEAT_LESS_SHAFT, FEAT_MORE_SHAFT};
  const int featc[] = {FEAT_CLOSED};
  const int featd[] = {FEAT_CLOSED, FEAT_OPEN, FEAT_BROKEN, FEAT_SECRET};
  const int feath[] = {FEAT_SECRET};
  const int featm[] = {FEAT_FORGE, FEAT_FORGE_GOOD, FEAT_FORGE_UNIQUE};
  const int featq[] = {FEAT_QUARTZ};
  const int featg[] = {FEAT_GRANITE};
  const int featp[] = {FEAT_PERM};
  const int featr[] = {FEAT_RUBBLE};
  const int feata[] = {FEAT_CHASM};
  if (cmd_get_arg_choice(cmd, "choice", &feature_class) != CMD_OK) {
    char choice;
    if (!get_com("Debug Command Feature Query: ", &choice)) return;
    feature_class = choice;
    cmd_set_arg_choice(cmd, "choice", feature_class);
  }
  switch (feature_class) {
    case 'f':
      selected.features = featf;
      selected.n = (int)N_ELEMENTS(featf);
      break;
    case 'o':
      selected.features = feato;
      selected.n = (int)N_ELEMENTS(feato);
      break;
    case 'b':
      selected.features = featb;
      selected.n = (int)N_ELEMENTS(featb);
      break;
    case 'u':
      selected.features = featu;
      selected.n = (int)N_ELEMENTS(featu);
      break;
    case 'z':
      selected.features = featz;
      selected.n = (int)N_ELEMENTS(featz);
      break;
    case 't':
      selected.features = featt;
      selected.n = (int)N_ELEMENTS(featt);
      break;
    case 'c':
      selected.features = featc;
      selected.n = (int)N_ELEMENTS(featc);
      break;
    case 'd':
      selected.features = featd;
      selected.n = (int)N_ELEMENTS(featd);
      break;
    case 'h':
      selected.features = feath;
      selected.n = (int)N_ELEMENTS(feath);
      break;
    case 'm':
      selected.features = featm;
      selected.n = (int)N_ELEMENTS(featm);
      break;
    case 'q':
      selected.features = featq;
      selected.n = (int)N_ELEMENTS(featq);
      break;
    case 'g':
      selected.features = featg;
      selected.n = (int)N_ELEMENTS(featg);
      break;
    case 'p':
      selected.features = featp;
      selected.n = (int)N_ELEMENTS(featp);
      break;
    case 'r':
      selected.features = featr;
      selected.n = (int)N_ELEMENTS(featr);
      break;
    case 'a':
      selected.features = feata;
      selected.n = (int)N_ELEMENTS(feata);
      break;
    default:
      msg("That was an invalid selection.  Use one of fobuztcdhmqgpra .");
      return;
  }
  wiz_hack_map(cave, player, wiz_hack_map_query_feature, &selected);
  Term_redraw();
  msg("Press any key.");
  inkey_ex();
  prt("", 0, 0);
  prt_map();
}
STATIC_OVL void
wiz_hack_map_query_square_flag(struct chunk* c, void* closure, struct loc grid,
                               bool* show, uint8_t* color)
{
  int flag = *((int*)closure);
  if ((flag && sqinfo_has(square(c, grid)->info, flag)) ||
      (!flag && square_isknown(c, grid))) {
    *show = true;
    *color = (square_ispassable(c, grid)) ? COLOUR_YELLOW : COLOUR_RED;
  } else {
    *show = false;
  }
}
STATIC_OVL void
do_cmd_wiz_query_square_flag(struct command* cmd)
{
  int flag = 0;
  if (cmd_get_arg_choice(cmd, "choice", &flag) != CMD_OK) {
    char c;
    if (!get_com("Debug Command Query [grasvwftniolx]: ", &c)) return;
    switch (c) {
      case 'g':
        flag = SQUARE_GLOW;
        break;
      case 'r':
        flag = SQUARE_ROOM;
        break;
      case 'a':
        flag = SQUARE_VAULT;
        break;
      case 's':
        flag = SQUARE_SEEN;
        break;
      case 'v':
        flag = SQUARE_VIEW;
        break;
      case 'w':
        flag = SQUARE_WASSEEN;
        break;
      case 'f':
        flag = SQUARE_FIRE;
        break;
      case 't':
        flag = SQUARE_TRAP;
        break;
      case 'n':
        flag = SQUARE_INVIS;
        break;
      case 'i':
        flag = SQUARE_WALL_INNER;
        break;
      case 'o':
        flag = SQUARE_WALL_OUTER;
        break;
      case 'l':
        flag = SQUARE_WALL_SOLID;
        break;
    }
    cmd_set_arg_choice(cmd, "choice", flag);
  }
  wiz_hack_map(cave, player, wiz_hack_map_query_square_flag, &flag);
  Term_redraw();
  msg("Press any key.");
  inkey_ex();
  prt("", 0, 0);
  prt_map();
}
STATIC_OVL void
do_cmd_wiz_quit_no_save(struct command* cmd)
{
  quit("user choice");
}
STATIC_OVL void
do_cmd_wiz_recall_monster(struct command* cmd)
{
  int r_idx = z_info->r_max;
  if (cmd_get_arg_number(cmd, "index", &r_idx) != CMD_OK) {
    char s[80] = "";
    char c;
    if (!get_com("Full recall for [a]ll monsters or [s]pecific monster? ", &c))
      return;
    if (c == 'a' || c == 'A') {
      r_idx = -1;
    } else if (c == 's' || c == 'S') {
      if (!get_string("Which monster? ", s, sizeof(s))) return;
      if (!get_int_from_string(s, &r_idx)) {
        const struct monster_race* race = lookup_monster(s);
        if (race) {
          r_idx = race->ridx;
        }
      }
    } else {
      return;
    }
    cmd_set_arg_number(cmd, "index", r_idx);
  }
  if (r_idx >= 0 && r_idx < z_info->r_max) {
    const struct monster_race* race = &r_info[r_idx];
    cheat_monster_lore(race, get_lore(race));
  } else if (r_idx == -1) {
    int i;
    for (i = 0; i < z_info->r_max; i++) {
      cheat_monster_lore(&r_info[i], &l_list[i]);
    }
  } else {
    msg("No monster found.");
  }
}
STATIC_OVL void
do_cmd_wiz_reroll_item(struct command* cmd)
{
  bool good = false;
  bool great = false;
  int roll_choice = 0;
  int update = 0;
  struct object* obj;
  struct object* new;
  if (cmd_get_arg_item(cmd, "item", &obj) != CMD_OK) {
    if (!get_item(&obj, "Reroll which item? ", "You have nothing to reroll.",
                  cmd->code, NULL,
                  (USE_EQUIP | USE_INVEN | USE_QUIVER | USE_FLOOR))) {
      return;
    }
    cmd_set_arg_item(cmd, "item", obj);
  }
  if (cmd_get_arg_choice(cmd, "choice", &roll_choice) != CMD_OK) {
    char ch;
    if (!get_com("Roll as [n]ormal, [g]ood, or [e]xcellent? ", &ch)) {
      return;
    }
    if (ch == 'n' || ch == 'N') {
      roll_choice = 0;
    } else if (ch == 'g' || ch == 'G') {
      roll_choice = 1;
    } else if (ch == 'e' || ch == 'E') {
      roll_choice = 2;
    } else {
      return;
    }
    cmd_set_arg_choice(cmd, "choice", roll_choice);
  }
  if (roll_choice == 0) {
    good = false;
    great = false;
  } else if (roll_choice == 1) {
    good = true;
    great = false;
  } else if (roll_choice == 2) {
    good = true;
    great = true;
  } else {
    return;
  }
  if (obj->artifact) {
    return;
  }
  new = object_new();
  object_prep(new, obj->kind, player->depth, RANDOMISE);
  apply_magic(new, player->depth, false, good, great);
  {
    struct object* prev = obj->prev;
    struct object* next = obj->next;
    struct object* known_obj = obj->known;
    uint16_t oidx = obj->oidx;
    struct loc grid = obj->grid;
    bitflag notice = obj->notice;
    mem_free(obj->slays);
    obj->slays = NULL;
    mem_free(obj->brands);
    obj->brands = NULL;
    release_ability_list(obj->abilities);
    obj->abilities = NULL;
    object_copy(obj, new);
    obj->prev = prev;
    obj->next = next;
    obj->known = known_obj;
    obj->known->ego = obj->ego;
    obj->oidx = oidx;
    obj->grid = grid;
    obj->notice = notice;
  }
  obj->origin = ORIGIN_CHEAT;
  if (cmd_get_arg_choice(cmd, "update", &update) != CMD_OK || update) {
    wiz_play_item_standard_upkeep(player, obj);
  } else {
    wiz_play_item_notify_changed();
  }
  object_delete(cave, player->cave, &new);
}
STATIC_OVL void
do_cmd_wiz_stat_item(struct command* cmd)
{
  const char* repfmt =
      "Rolls: %ld, Matches: %ld, Better: %ld, Worse: %ld, Other: %ld";
  int level = player->depth;
  int treasure_choice = 0;
  bool good = false, great = false;
  long matches = 0, better = 0, worse = 0, other = 0;
  long n = 100000;
  struct object* obj;
  long i;
  const char* quality;
  if (cmd_get_arg_item(cmd, "item", &obj) != CMD_OK) {
    if (!get_item(&obj, "Compare with which item? ",
                  "You have nothing to compare.", cmd->code, NULL,
                  (USE_EQUIP | USE_INVEN | USE_QUIVER | USE_FLOOR))) {
      return;
    }
    cmd_set_arg_item(cmd, "item", obj);
  }
  wiz_display_item(obj, true, player);
  if (cmd_get_arg_choice(cmd, "choice", &treasure_choice) != CMD_OK) {
    char ch;
    if (!get_com("Roll for [n]ormal, [g]ood, or [e]xcellent treasure? ", &ch)) {
      return;
    }
    if (ch == 'n' || ch == 'N') {
      treasure_choice = 0;
    } else if (ch == 'g' || ch == 'G') {
      treasure_choice = 1;
    } else if (ch == 'e' || ch == 'E') {
      treasure_choice = 2;
    } else {
      return;
    }
    cmd_set_arg_choice(cmd, "choice", treasure_choice);
  }
  if (treasure_choice == 0) {
    good = false;
    great = false;
    quality = "normal";
  } else if (treasure_choice == 1) {
    good = true;
    great = false;
    quality = "good";
  } else if (treasure_choice == 2) {
    good = true;
    great = true;
    quality = "excellent";
  } else {
    return;
  }
  if (cmd_get_arg_number(cmd, "depth", &level) != CMD_OK) {
    char prompt[80], s[80];
    strnfmt(prompt, sizeof(prompt),
            "Depth for treasure (0-%d): ", z_info->max_depth - 1);
    strnfmt(s, sizeof(s), "%d", player->depth);
    if (!get_string(prompt, s, sizeof(s)) || !get_int_from_string(s, &level) ||
        level < 0 || level >= z_info->max_depth) {
      return;
    }
    cmd_set_arg_number(cmd, "depth", level);
  }
  if (level < 0 || level >= z_info->max_depth) {
    return;
  }
  msg("Creating a lot of %s items.  Base level = %d.", quality, level);
  event_signal(EVENT_MESSAGE_FLUSH);
  for (i = 0; i < n; i++) {
    bool ismatch = true, isbetter = true, isworse = true;
    struct object* test_obj;
    int j;
    if (i < 100 || i % 100 == 0) {
      ui_event e;
      inkey_scan = SCAN_INSTANT;
      e = inkey_ex();
      if (e.type != EVT_NONE) {
        event_signal(EVENT_INPUT_FLUSH);
        break;
      }
      prt(format(repfmt, i, matches, better, worse, other), 0, 0);
      Term_fresh();
    }
    test_obj = make_object(cave, level, good, great, NULL);
    if (obj->artifact) {
      mark_artifact_created(obj->artifact, false);
    }
    if (!test_obj) continue;
    if (obj->tval != test_obj->tval || obj->sval != test_obj->sval) {
      object_delete(cave, player->cave, &test_obj);
      continue;
    }
    for (j = 0; j < OBJ_MOD_MAX; j++) {
      if (test_obj->modifiers[j] != obj->modifiers[j]) {
        ismatch = false;
        if (test_obj->modifiers[j] < obj->modifiers[j]) {
          isbetter = false;
        } else {
          isworse = false;
        }
      }
    }
    if (ismatch && test_obj->att == obj->att && test_obj->ds == obj->ds &&
        test_obj->dd == obj->dd && test_obj->evn == obj->evn &&
        test_obj->ps == obj->ps && test_obj->pd == obj->pd) {
      ++matches;
    } else if (isbetter && test_obj->att > obj->att && test_obj->ds > obj->ds &&
               test_obj->dd > obj->dd && test_obj->evn > obj->evn &&
               test_obj->ps > obj->ps && test_obj->pd > obj->pd) {
      ++better;
    } else if (isworse && test_obj->att <= obj->att &&
               test_obj->ds <= obj->ds && test_obj->dd <= obj->dd &&
               test_obj->evn <= obj->evn && test_obj->ps <= obj->ps &&
               test_obj->pd <= obj->pd) {
      ++worse;
    } else {
      ++other;
    }
    object_delete(cave, player->cave, &test_obj);
  }
  msg(repfmt, i, matches, better, worse, other);
  event_signal(EVENT_MESSAGE_FLUSH);
  if (obj->artifact) {
    mark_artifact_created(obj->artifact, true);
  }
}
STATIC_OVL void
do_cmd_wiz_summon_named(struct command* cmd)
{
  int r_idx, i = 0;
  struct monster_race* r = NULL;
  struct monster_group_info info = {0, 0};
  if (cmd_get_arg_number(cmd, "index", &r_idx) == CMD_OK) {
    if (r_idx > 0 && r_idx < z_info->r_max) {
      r = &r_info[r_idx];
    }
  } else {
    char s[80] = "";
    if (!get_string("Summon which monster? ", s, sizeof(s))) return;
    if (get_int_from_string(s, &r_idx)) {
      if (r_idx > 0 && r_idx < z_info->r_max) {
        r = &r_info[r_idx];
      }
    } else {
      r = lookup_monster(s);
    }
    if (r != NULL) {
      cmd_set_arg_number(cmd, "index", r->ridx);
    }
  }
  if (r == NULL) {
    msg("No monster found.");
    return;
  }
  while (1) {
    struct loc grid;
    if (i >= 10 || scatter_ext(cave, &grid, 1, player->grid, 1, true,
                               square_isempty) == 0) {
      msg("Could not place monster.");
      break;
    }
    if (place_new_monster(cave, grid, r, true, true, info,
                          ORIGIN_DROP_WIZARD)) {
      player->upkeep->redraw |= PR_MAP | PR_MONLIST;
      break;
    }
    ++i;
  }
}
STATIC_OVL void
do_cmd_wiz_summon_random(struct command* cmd)
{
  int n, i;
  if (cmd_get_arg_number(cmd, "quantity", &n) != CMD_OK) {
    n = get_quantity("How many monsters? ", 40);
    if (n < 1) n = 1;
    cmd_set_arg_number(cmd, "quantity", n);
  }
  for (i = 0; i < n; i++) {
    effect_simple(EF_SUMMON, source_player(), "1", 0, 0, 0, NULL);
  }
}
STATIC_OVL void
do_cmd_wiz_teleport_to(struct command* cmd)
{
  struct loc grid;
  if (cmd_get_arg_point(cmd, "point", &grid) != CMD_OK) {
    if (!target_set_interactive(TARGET_LOOK, loc(-1, -1), 0)) return;
    target_get(&grid);
    cmd_set_arg_point(cmd, "point", grid);
  }
  if (square_ispassable(cave, grid)) {
    effect_simple(EF_TELEPORT_TO, source_player(), "0", 0, 0, 0, NULL);
  } else {
    msg("The square you are aiming for is impassable.");
  }
}
STATIC_OVL void
do_cmd_wiz_tweak_item(struct command* cmd)
{
  static const char* obj_mods[] = {
      "STR",      "DEX",     "CON",          "GRA",        "MELEE",
      "ARCHERY",  "EVASION", "STEALTH",      "PERCEPTION", "WILL",
      "SMITHING", "SONG",    "DAMAGE_SIDES", "TUNNEL",     NULL};
  struct object* obj;
  char tmp_val[80];
  int i, val;
  int update = 0;
  if (cmd_get_arg_item(cmd, "item", &obj) != CMD_OK) {
    if (!get_item(&obj, "Tweak which item? ", "You have nothing to tweak.",
                  cmd->code, NULL,
                  (USE_EQUIP | USE_INVEN | USE_QUIVER | USE_FLOOR))) {
      return;
    }
    cmd_set_arg_item(cmd, "item", obj);
  }
  if (obj->artifact) return;
  if (cmd_get_arg_choice(cmd, "update", &update) != CMD_OK) {
    update = 1;
  }
  if (obj->ego) {
    strnfmt(tmp_val, sizeof(tmp_val), "%s", obj->ego->name);
  } else {
    strnfmt(tmp_val, sizeof(tmp_val), "-1");
  }
  if (!get_string("Enter ego item: ", tmp_val, sizeof(tmp_val))) return;
  if (get_int_from_string(tmp_val, &val)) {
    if (val >= 0 && val < z_info->e_max) {
      obj->ego = &e_info[val];
    } else {
      obj->ego = NULL;
    }
  } else {
    obj->ego = lookup_ego_item(tmp_val, obj->tval, obj->sval);
  }
  if (obj->ego) {
    struct ego_item* e = obj->ego;
    struct object* prev = obj->prev;
    struct object* next = obj->next;
    struct object* known = obj->known;
    uint16_t oidx = obj->oidx;
    struct loc grid = obj->grid;
    bitflag notice = obj->notice;
    object_prep(obj, obj->kind, player->depth, RANDOMISE);
    obj->ego = e;
    obj->prev = prev;
    obj->next = next;
    obj->known = known;
    obj->oidx = oidx;
    obj->grid = grid;
    obj->notice = notice;
    ego_apply_magic(obj, player->depth);
  }
  wiz_display_item(obj, true, player);
  if (obj->artifact) {
    strnfmt(tmp_val, sizeof(tmp_val), "%s", obj->artifact->name);
  } else {
    strnfmt(tmp_val, sizeof(tmp_val), "0");
  }
  if (!get_string("Enter new artifact: ", tmp_val, sizeof(tmp_val))) {
    if (update) {
      wiz_play_item_standard_upkeep(player, obj);
    } else {
      wiz_play_item_notify_changed();
    }
    return;
  }
  if (get_int_from_string(tmp_val, &val)) {
    if (val > 0 && val < z_info->a_max) {
      obj->artifact = &a_info[val];
    } else {
      obj->artifact = NULL;
    }
  } else {
    obj->artifact = lookup_artifact_name(tmp_val);
  }
  if (obj->artifact) {
    const struct artifact* a = obj->artifact;
    struct object* prev = obj->prev;
    struct object* next = obj->next;
    struct object* known = obj->known;
    uint16_t oidx = obj->oidx;
    struct loc grid = obj->grid;
    bitflag notice = obj->notice;
    obj->ego = NULL;
    object_prep(obj, obj->kind, obj->artifact->level, RANDOMISE);
    obj->artifact = a;
    obj->prev = prev;
    obj->next = next;
    obj->known = known;
    obj->oidx = oidx;
    obj->grid = grid;
    obj->notice = notice;
    copy_artifact_data(obj, obj->artifact);
  }
  wiz_display_item(obj, true, player);
  for (i = 0; i < OBJ_MOD_MAX; i++) {
    do {
      char prompt[80];
      strnfmt(prompt, sizeof(prompt), "Enter new %s setting: ", obj_mods[i]);
      strnfmt(tmp_val, sizeof(tmp_val), "%d", obj->modifiers[i]);
      if (!get_string(prompt, tmp_val, sizeof(tmp_val))) {
        if (update) {
          wiz_play_item_standard_upkeep(player, obj);
        } else {
          wiz_play_item_notify_changed();
        }
        return;
      }
      if (get_int_from_string(tmp_val, &val)) {
        obj->modifiers[i] = val;
        wiz_display_item(obj, true, player);
      }
    } while (0);
  }
  do {
    char prompt[80];
    strnfmt(prompt, sizeof(prompt), "Enter new %s setting: ", "Attack");
    strnfmt(tmp_val, sizeof(tmp_val), "%d", obj->att);
    if (!get_string(prompt, tmp_val, sizeof(tmp_val))) {
      if (update) {
        wiz_play_item_standard_upkeep(player, obj);
      } else {
        wiz_play_item_notify_changed();
      }
      return;
    }
    if (get_int_from_string(tmp_val, &val)) {
      obj->att = val;
      wiz_display_item(obj, true, player);
    }
  } while (0);
  do {
    char prompt[80];
    strnfmt(prompt, sizeof(prompt), "Enter new %s setting: ", "Damage dice");
    strnfmt(tmp_val, sizeof(tmp_val), "%d", obj->dd);
    if (!get_string(prompt, tmp_val, sizeof(tmp_val))) {
      if (update) {
        wiz_play_item_standard_upkeep(player, obj);
      } else {
        wiz_play_item_notify_changed();
      }
      return;
    }
    if (get_int_from_string(tmp_val, &val)) {
      obj->dd = val;
      wiz_display_item(obj, true, player);
    }
  } while (0);
  do {
    char prompt[80];
    strnfmt(prompt, sizeof(prompt), "Enter new %s setting: ", "Damage sides");
    strnfmt(tmp_val, sizeof(tmp_val), "%d", obj->ds);
    if (!get_string(prompt, tmp_val, sizeof(tmp_val))) {
      if (update) {
        wiz_play_item_standard_upkeep(player, obj);
      } else {
        wiz_play_item_notify_changed();
      }
      return;
    }
    if (get_int_from_string(tmp_val, &val)) {
      obj->ds = val;
      wiz_display_item(obj, true, player);
    }
  } while (0);
  do {
    char prompt[80];
    strnfmt(prompt, sizeof(prompt), "Enter new %s setting: ", "Evasion");
    strnfmt(tmp_val, sizeof(tmp_val), "%d", obj->evn);
    if (!get_string(prompt, tmp_val, sizeof(tmp_val))) {
      if (update) {
        wiz_play_item_standard_upkeep(player, obj);
      } else {
        wiz_play_item_notify_changed();
      }
      return;
    }
    if (get_int_from_string(tmp_val, &val)) {
      obj->evn = val;
      wiz_display_item(obj, true, player);
    }
  } while (0);
  do {
    char prompt[80];
    strnfmt(prompt, sizeof(prompt),
            "Enter new %s setting: ", "Protection dice");
    strnfmt(tmp_val, sizeof(tmp_val), "%d", obj->pd);
    if (!get_string(prompt, tmp_val, sizeof(tmp_val))) {
      if (update) {
        wiz_play_item_standard_upkeep(player, obj);
      } else {
        wiz_play_item_notify_changed();
      }
      return;
    }
    if (get_int_from_string(tmp_val, &val)) {
      obj->pd = val;
      wiz_display_item(obj, true, player);
    }
  } while (0);
  do {
    char prompt[80];
    strnfmt(prompt, sizeof(prompt),
            "Enter new %s setting: ", "Protection sides");
    strnfmt(tmp_val, sizeof(tmp_val), "%d", obj->ps);
    if (!get_string(prompt, tmp_val, sizeof(tmp_val))) {
      if (update) {
        wiz_play_item_standard_upkeep(player, obj);
      } else {
        wiz_play_item_notify_changed();
      }
      return;
    }
    if (get_int_from_string(tmp_val, &val)) {
      obj->ps = val;
      wiz_display_item(obj, true, player);
    }
  } while (0);
  if (update) {
    wiz_play_item_standard_upkeep(player, obj);
  } else {
    wiz_play_item_notify_changed();
  }
}
STATIC_OVL void
do_cmd_wiz_wipe_recall(struct command* cmd)
{
  int r_idx = z_info->r_max;
  if (cmd_get_arg_number(cmd, "index", &r_idx) != CMD_OK) {
    char s[80] = "";
    char c;
    if (!get_com("Wipe recall for [a]ll monsters or [s]pecific monster? ", &c))
      return;
    if (c == 'a' || c == 'A') {
      r_idx = -1;
    } else if (c == 's' || c == 'S') {
      if (!get_string("Which monster? ", s, sizeof(s))) return;
      if (!get_int_from_string(s, &r_idx)) {
        const struct monster_race* race = lookup_monster(s);
        if (race) {
          r_idx = race->ridx;
        }
      }
    } else {
      return;
    }
    cmd_set_arg_number(cmd, "index", r_idx);
  }
  if (r_idx >= 0 && r_idx < z_info->r_max) {
    const struct monster_race* race = &r_info[r_idx];
    wipe_monster_lore(race, get_lore(race));
  } else if (r_idx == -1) {
    int i;
    for (i = 0; i < z_info->r_max; i++) {
      wipe_monster_lore(&r_info[i], &l_list[i]);
    }
  } else {
    msg("No monster found.");
  }
}
STATIC_OVL void
do_cmd_wiz_wizard_light(struct command* cmd)
{
  wiz_light(cave, player);
}
STATIC_OVL bool
knock_back(struct loc grid1, struct loc grid2)
{
  bool knocked = false;
  int mod, d, i;
  struct monster* mon = square_monster(cave, grid2);
  struct loc grid3;
  int dir = rough_direction(grid1, grid2);
  struct loc next = loc_sum(grid2, ddgrid[dir]);
  if (!square_iswall(cave, next) && (square_monster(cave, next) == NULL)) {
    grid3 = next;
    knocked = true;
  } else {
    mod = one_in_(2) ? -1 : +1;
    for (i = 0; i < 2; i++) {
      d = cycle[chome[dir_from_delta(ddy[dir], ddx[dir])] + mod];
      grid3 = loc_sum(grid2, ddgrid[d]);
      if (!square_iswall(cave, grid3) && (square_monster(cave, next) == NULL)) {
        knocked = true;
        break;
      }
      mod *= -1;
    }
  }
  if (knocked) {
    if (mon) {
      mon->skip_next_turn = true;
      monster_swap(grid2, grid3);
    } else {
      msg("You are knocked back.");
      player->upkeep->knocked_back = true;
      monster_swap(grid2, grid3);
      player->upkeep->leaping = false;
      player->stealth_score -= 5;
      player_handle_post_move(player, true, true);
    }
  }
  return knocked;
}
STATIC_OVL int
skill_check(struct source attacker, int skill, int difficulty,
            struct source defender)
{
  int skill_total;
  int difficulty_total;
  if ((attacker.what == SRC_PLAYER) && (defender.what == SRC_MONSTER)) {
    struct monster* mon = cave_monster(cave, defender.which.monster);
    skill += player_bane_bonus(player, mon);
  }
  if ((defender.what == SRC_PLAYER) && (attacker.what == SRC_MONSTER)) {
    struct monster* mon = cave_monster(cave, attacker.which.monster);
    difficulty += player_bane_bonus(player, mon);
  }
  if ((attacker.what == SRC_PLAYER) && (defender.what == SRC_MONSTER)) {
    struct monster* mon = cave_monster(cave, defender.which.monster);
    difficulty += monster_elf_bane_bonus(mon, player);
  }
  if ((defender.what == SRC_PLAYER) && (attacker.what == SRC_MONSTER)) {
    struct monster* mon = cave_monster(cave, attacker.which.monster);
    skill += monster_elf_bane_bonus(mon, player);
  }
  skill_total = randint1(10) + skill;
  difficulty_total = randint1(10) + difficulty;
  if (player->cursed) {
    int alt_total;
    if (attacker.what == SRC_PLAYER) {
      alt_total = randint1(10) + skill;
      skill_total = MIN(skill_total, alt_total);
    }
    if (defender.what == SRC_PLAYER) {
      alt_total = randint1(10) + difficulty;
      difficulty_total = MIN(difficulty_total, alt_total);
    }
  }
  if (OPT(player, cheat_skill_rolls)) {
    msg("{%d+%d v %d+%d = %d}.", skill_total - skill, skill,
        difficulty_total - difficulty, difficulty,
        skill_total - difficulty_total);
  }
  return skill_total - difficulty_total;
}
STATIC_OVL int
hit_roll(int att, int evn, struct source attacker, struct source defender,
         bool display_roll)
{
  int attack_score, attack_score_alt;
  int evasion_score, evasion_score_alt;
  bool non_player_visible;
  if (attacker.what == SRC_PLAYER) {
    if ((defender.what == SRC_NONE) || (defender.what == SRC_TRAP)) {
      non_player_visible = true;
    } else {
      struct monster* mon = cave_monster(cave, defender.which.monster);
      assert(mon);
      non_player_visible = monster_is_visible(mon);
    }
  } else {
    if ((attacker.what == SRC_NONE) || (attacker.what == SRC_TRAP)) {
      non_player_visible = true;
    } else {
      struct monster* mon = cave_monster(cave, attacker.which.monster);
      assert(mon);
      non_player_visible = monster_is_visible(mon);
    }
  }
  attack_score = randint1(20) + att;
  attack_score_alt = randint1(20) + att;
  evasion_score = randint1(20) + evn;
  evasion_score_alt = randint1(20) + evn;
  if (player && player->cursed) {
    if (attacker.what == SRC_PLAYER) {
      attack_score = MIN(attack_score, attack_score_alt);
    } else {
      evasion_score = MIN(evasion_score, evasion_score_alt);
    }
  }
  if (display_roll) {
    event_signal_combat_attack(EVENT_COMBAT_ATTACK, attacker, defender,
                               non_player_visible, att, attack_score - att, evn,
                               evasion_score - evn, true);
  }
  return (attack_score - evasion_score);
}
STATIC_OVL int
concentration_bonus(struct player* p, struct loc grid)
{
  int bonus = 0;
  int midx = square_monster(cave, grid) ? square_monster(cave, grid)->midx : 0;
  if (player_active_ability(p, "Concentration") &&
      (p->last_attack_m_idx == midx)) {
    bonus =
        MIN(p->consecutive_attacks, p->state.skill_use[SKILL_PERCEPTION] / 2);
  }
  if (p->last_attack_m_idx != midx) {
    p->consecutive_attacks = 0;
    p->last_attack_m_idx = midx;
  }
  return bonus;
}
STATIC_OVL int
focused_attack_bonus(struct player* p)
{
  if (p->focused) {
    p->focused = false;
    if (player_active_ability(p, "Focused Attack")) {
      return (p->state.skill_use[SKILL_PERCEPTION] / 2);
    }
  }
  return 0;
}
STATIC_OVL int
master_hunter_bonus(struct player* p, struct monster* mon)
{
  struct monster_lore* lore = get_lore(mon->race);
  if (player_active_ability(p, "Master Hunter")) {
    return MIN(lore->pkills, p->state.skill_use[SKILL_PERCEPTION] / 4);
  }
  return 0;
}
STATIC_OVL int
total_player_attack(struct player* p, struct monster* mon, int base)
{
  int att = base;
  att += concentration_bonus(p, mon->grid);
  att += focused_attack_bonus(p);
  att += player_bane_bonus(p, mon);
  att += master_hunter_bonus(p, mon);
  att -= distance(p->grid, mon->grid) / 5;
  if (att > 0) {
    if (!monster_is_visible(mon)) att /= 2;
    if (square_ispit(cave, p->grid) || square_iswebbed(cave, p->grid)) {
      att /= 2;
    }
  }
  return att;
}
STATIC_OVL int
total_player_evasion(struct player* p, struct monster* mon, bool archery)
{
  int evn = p->state.skill_use[SKILL_EVASION];
  evn += player_dodging_bonus(p);
  evn += player_bane_bonus(p, mon);
  if (evn > 0) {
    if (!monster_is_visible(mon)) {
      evn /= 2;
    }
    if (archery) {
      evn /= 2;
    }
    if (square_ispit(cave, p->grid) || square_iswebbed(cave, p->grid)) {
      evn /= 2;
    }
  }
  return evn;
}
STATIC_OVL int
light_penalty(const struct monster* mon)
{
  int penalty = 0;
  if (rf_has(mon->race->flags, RF_HURT_LIGHT)) {
    penalty = square_light(cave, mon->grid) - 2;
    if (penalty < 0) penalty = 0;
  }
  return penalty;
}
STATIC_OVL int
total_monster_attack(struct player* p, struct monster* mon, int base)
{
  int att = base;
  if (mon->m_timed[MON_TMD_STUN]) {
    att -= 2;
  }
  att -= light_penalty(mon);
  att += overwhelming_att_mod(p, mon);
  att -= distance(p->grid, mon->grid) / 5;
  att += monster_elf_bane_bonus(mon, p);
  if (att > 0) {
    if ((mon->race->light > 0) && strchr("@G", mon->race->d_char) &&
        (square_light(cave, p->grid) <= 0)) {
      att /= 2;
    }
  }
  return att;
}
STATIC_OVL int
total_monster_evasion(struct player* p, struct monster* mon, bool archery)
{
  struct monster_race* race = mon->race;
  int evn = race->evn;
  bool unseen = false;
  if (mon->alertness < ALERTNESS_UNWARY) return -5;
  if (mon->m_timed[MON_TMD_STUN]) {
    evn -= 2;
  }
  evn -= light_penalty(mon);
  evn += monster_elf_bane_bonus(mon, p);
  if (evn > 0) {
    if ((race->light > 0) && strchr("@G", race->d_char) &&
        (square_light(cave, p->grid) <= 0)) {
      unseen = true;
    }
    if (unseen || (mon->alertness < ALERTNESS_ALERT)) {
      evn /= 2;
    }
    if (archery) {
      evn /= 2;
    }
  }
  return evn;
}
STATIC_OVL int
stealth_melee_bonus(const struct monster* mon)
{
  int stealth_bonus = 0;
  if (player_active_ability(player, "Assassination")) {
    if ((mon->alertness < ALERTNESS_ALERT) && monster_is_visible(mon) &&
        !player->timed[TMD_CONFUSED]) {
      stealth_bonus = player->state.skill_use[SKILL_STEALTH];
    }
  }
  return stealth_bonus;
}
STATIC_OVL int
overwhelming_att_mod(struct player* p, struct monster* mon)
{
  int mod = 0;
  int dir;
  int dy, dx;
  int py = p->grid.y;
  int px = p->grid.x;
  dir = rough_direction(p->grid, mon->grid);
  dy = ddy[dir];
  dx = ddx[dir];
  if (dy * dx == 0) {
    if (square_monster(cave, loc(px - dy + dx, py + dx + dy))) mod++;
    if (square_monster(cave, loc(px + dy + dx, py - dx + dy))) mod++;
    if (square_monster(cave, loc(px - dy, py + dx))) mod++;
    if (square_monster(cave, loc(px + dy, py - dx))) mod++;
    if (square_monster(cave, loc(px - dy - dx, py + dx - dy))) mod++;
    if (square_monster(cave, loc(px + dy - dx, py - dx - dy))) mod++;
    if (square_monster(cave, loc(px - dx, py - dy))) mod++;
  } else {
    if (square_monster(cave, loc(px, py + dy))) mod++;
    if (square_monster(cave, loc(px + dx, py))) mod++;
    if (square_monster(cave, loc(px - dy, py + dx))) mod++;
    if (square_monster(cave, loc(px + dy, py - dx))) mod++;
    if (square_monster(cave, loc(px, py - dy))) mod++;
    if (square_monster(cave, loc(px - dx, py))) mod++;
    if (square_monster(cave, loc(px - dx, py - dy))) mod++;
  }
  if (player_active_ability(p, "Crowd Fighting")) {
    mod /= 2;
  }
  return (mod);
}
STATIC_OVL int
crit_bonus(struct player* p, int hit_result, int weight,
           const struct monster_race* race, int skill_type, bool thrown)
{
  int crit_bonus_dice;
  int crit_separation = 70;
  if (race) {
    if (skill_type == SKILL_MELEE) {
      if (player_active_ability(p, "Finesse")) {
        crit_separation -= 10;
      }
      if (player_active_ability(p, "Subtlety") && !thrown &&
          !two_handed_melee(p) && !equipped_item_by_slot_name(p, "arm")) {
        crit_separation -= 20;
      }
      if (player_active_ability(p, "Power")) {
        crit_separation += 10;
      }
    }
    if ((skill_type == SKILL_ARCHERY) &&
        player_active_ability(p, "Precision")) {
      crit_separation -= 10;
    }
  } else {
    if (player_active_ability(p, "Critical Resistance")) {
      crit_separation += (p->state.skill_use[SKILL_WILL] / 5) * 10;
    }
  }
  crit_bonus_dice = (hit_result * 10 + 4) / (crit_separation + weight);
  if (race) {
    if (rf_has(race->flags, RF_RES_CRIT)) {
      crit_bonus_dice /= 2;
    }
    if (rf_has(race->flags, RF_NO_CRIT)) {
      crit_bonus_dice = 0;
    }
  }
  return MAX(crit_bonus_dice, 0);
}
STATIC_OVL int
protection_roll(struct player* p, int typ, bool melee, aspect prot_aspect)
{
  int i;
  int prt = 0;
  int mult = 1;
  int armour_weight = 0;
  struct song* staying = lookup_song("Staying");
  if (player_is_singing(p, staying)) {
    int bonus = song_bonus(p, p->state.skill_use[SKILL_SONG], staying);
    prt += damcalc(1, MAX(1, bonus), prot_aspect);
  }
  if (player_active_ability(p, "Hardiness")) {
    prt += damcalc(1, p->state.skill_use[SKILL_WILL] / 6, prot_aspect);
  }
  for (i = 0; i < p->body.count; i++) {
    struct object* obj = p->body.slots[i].obj;
    if (!obj) continue;
    if (slot_type_is(p, i, EQUIP_SHIELD) && tval_is_weapon(obj)) continue;
    if (tval_is_armor(obj)) {
      armour_weight += obj->weight;
    }
    if (slot_type_is(p, i, EQUIP_SHIELD)) {
      if ((typ == PROJ_HURT) || (typ == PROJ_FIRE) || (typ == PROJ_COLD)) {
        if (player_active_ability(p, "Blocking") &&
            (!melee || ((p->previous_action[0] == ACTION_STAND) ||
                        ((p->previous_action[0] == ACTION_NOTHING) &&
                         (p->previous_action[1] == ACTION_STAND))))) {
          mult = 2;
        }
        if (obj->pd > 0) {
          prt += damcalc(obj->pd * mult, obj->ps, prot_aspect);
        }
      }
    } else if ((typ == PROJ_HURT) || (tval_is_jewelry(obj))) {
      if (obj->ps > 0) {
        prt += damcalc(obj->pd, obj->ps, prot_aspect);
      }
    }
  }
  if (player_active_ability(p, "Heavy Armour") && (typ == PROJ_HURT)) {
    prt += damcalc(1, MIN(1, armour_weight / 150), prot_aspect);
  }
  return prt;
}
STATIC_OVL void
parse_error(struct file_parser* fp, struct parser* p)
{
  struct parser_state s;
  parser_getstate(p, &s);
  msg("Parse error in %s line %d column %d: %s: %s", fp->name, s.line, s.col,
      s.msg, parser_error_str[s.error]);
  event_signal(EVENT_MESSAGE_FLUSH);
  quit_fmt("Parse error in %s line %d column %d.", fp->name, s.line, s.col);
}
STATIC_OVL errr
run_parser(struct file_parser* fp)
{
  struct parser* p = fp->init();
  errr r;
  if (!p) {
    return PARSE_ERROR_GENERIC;
  }
  r = fp->run(p);
  if (r) {
    parse_error(fp, p);
    return r;
  }
  r = fp->finish(p);
  if (r) {
    msg("Parser finish error in %s: %s", fp->name,
        (r > 0 && r < PARSE_ERROR_MAX) ? parser_error_str[r]
                                       : "unspecified error");
    event_signal(EVENT_MESSAGE_FLUSH);
    quit_fmt("Parser finish error in %s.", fp->name);
  }
  return r;
}
STATIC_OVL errr
parse_file_quit_not_found(struct parser* p, const char* filename)
{
  errr parse_err = parse_file(p, filename);
  if (parse_err == PARSE_ERROR_NO_FILE_FOUND)
    quit(format("Cannot open '%s.txt'", filename));
  return parse_err;
}
STATIC_OVL errr
parse_file(struct parser* p, const char* filename)
{
  char path[1024];
  char buf[1024];
  ang_file* fh;
  errr r = 0;
  path_build(path, sizeof(path), ANGBAND_DIR_USER, format("%s.txt", filename));
  fh = file_open(path, MODE_READ, FTYPE_TEXT);
  if (!fh) {
    path_build(path, sizeof(path), ANGBAND_DIR_GAMEDATA,
               format("%s.txt", filename));
    fh = file_open(path, MODE_READ, FTYPE_TEXT);
  }
  if (!fh) return PARSE_ERROR_NO_FILE_FOUND;
  while (file_getl(fh, buf, sizeof(buf))) {
    r = parser_parse(p, buf);
    if (r) break;
  }
  file_close(fh);
  return r;
}
STATIC_OVL void
cleanup_parser(struct file_parser* fp)
{
  fp->cleanup();
}
STATIC_OVL int
lookup_flag(const char** flag_table, const char* flag_name)
{
  int i = FLAG_START;
  while (flag_table[i] && !streq(flag_table[i], flag_name)) i++;
  if (!flag_table[i]) i = FLAG_END;
  return i;
}
STATIC_OVL int
code_index_in_array(const char* code_name[], const char* code)
{
  int i = 0;
  while (code_name[i]) {
    if (streq(code_name[i], code)) {
      return i;
    }
    i++;
  }
  return -1;
}
STATIC_OVL bool
find_value_arg(char* value_name, char* string, size_t nstring, int* num)
{
  char* to = strchr(value_name, '[');
  if (!to) {
    return false;
  }
  if (string) {
    char* tc = strchr(to + 1, ']');
    if (!tc || (size_t)(tc - to) > nstring) {
      return false;
    }
    memcpy(string, to + 1, tc - (to + 1));
    string[tc - (to + 1)] = '\0';
  } else if (num) {
    char* tc;
    long lv = strtol(to + 1, &tc, 10);
    if (*tc != ']' || lv <= INT_MIN || lv >= INT_MAX) {
      return false;
    }
    *num = (int)lv;
  } else {
    return false;
  }
  *to = '\0';
  return true;
}
STATIC_OVL errr
grab_rand_value(random_value* value, const char** value_type,
                const char* name_and_value)
{
  int i = 0;
  char* value_name = string_make(name_and_value);
  char dice_string[40];
  dice_t* dice;
  if (!find_value_arg(value_name, dice_string, sizeof(dice_string), NULL)) {
    string_free(value_name);
    return PARSE_ERROR_INVALID_VALUE;
  }
  dice = dice_new();
  while (value_type[i] && !streq(value_type[i], value_name)) i++;
  string_free(value_name);
  if (value_type[i]) {
    if (!dice_parse_string(dice, dice_string)) {
      dice_free(dice);
      return PARSE_ERROR_NOT_RANDOM;
    }
    dice_random_value(dice, &value[i]);
  }
  dice_free(dice);
  return value_type[i] ? PARSE_ERROR_NONE : PARSE_ERROR_INTERNAL;
}
STATIC_OVL errr
grab_int_value(int* value, const char** value_type, const char* name_and_value)
{
  int val, i = 0;
  char* value_name = string_make(name_and_value);
  if (!find_value_arg(value_name, NULL, 0, &val)) {
    string_free(value_name);
    return PARSE_ERROR_INVALID_VALUE;
  }
  while (value_type[i] && !streq(value_type[i], value_name)) i++;
  string_free(value_name);
  if (value_type[i]) value[i] = val;
  return value_type[i] ? PARSE_ERROR_NONE : PARSE_ERROR_INTERNAL;
}
STATIC_OVL errr
grab_int_range(int* lo, int* hi, const char* range, const char* sep)
{
  char* pe;
  long lv1 = strtol(range, &pe, 10), lv2;
  if (pe == range || !isspace(*pe) || lv1 <= INT_MIN || lv1 >= INT_MAX) {
    return PARSE_ERROR_INVALID_VALUE;
  }
  range = pe;
  if (sep) {
    size_t nonwhite_offset;
    pe = strstr(range, sep);
    if (!pe) {
      return PARSE_ERROR_INVALID_VALUE;
    }
    nonwhite_offset = strspn(range, " \t");
    if (range + nonwhite_offset != pe) {
      return PARSE_ERROR_INVALID_VALUE;
    }
    range = pe + strlen(sep);
    if (!isspace(*range)) {
      return PARSE_ERROR_INVALID_VALUE;
    }
  }
  lv2 = strtol(range, &pe, 10);
  if (pe == range || !contains_only_spaces(pe) || lv2 <= INT_MIN ||
      lv2 >= INT_MAX) {
    return PARSE_ERROR_INVALID_VALUE;
  }
  *lo = (int)lv1;
  *hi = (int)lv2;
  return PARSE_ERROR_NONE;
}
STATIC_OVL errr
grab_index_and_int(int* value, int* index, const char** value_type,
                   const char* prefix, const char* name_and_value)
{
  int i;
  char* value_name = string_make(name_and_value);
  char* value_string = string_make(prefix);
  if (!find_value_arg(value_name, NULL, 0, value)) {
    string_free(value_string);
    string_free(value_name);
    return PARSE_ERROR_INVALID_VALUE;
  }
  for (i = 0; value_type[i]; i++) {
    value_string = string_append(value_string, value_type[i]);
    if (streq(value_string, value_name)) break;
    my_strcpy(value_string, prefix, strlen(prefix) + 1);
  }
  free(value_string);
  free(value_name);
  if (value_type[i]) *index = i;
  return value_type[i] ? PARSE_ERROR_NONE : PARSE_ERROR_INTERNAL;
}
STATIC_OVL errr
grab_base_and_int(int* value, char** base, const char* name_and_value)
{
  char* value_name = string_make(name_and_value);
  if (!find_value_arg(value_name, NULL, 0, value)) {
    string_free(value_name);
    return PARSE_ERROR_INVALID_VALUE;
  }
  if (strncmp(value_name, "SLAY_", 5)) {
    string_free(value_name);
    return PARSE_ERROR_INVALID_VALUE;
  }
  *base = string_make(value_name + 5);
  string_free(value_name);
  return PARSE_ERROR_NONE;
}
STATIC_OVL errr
grab_name(const char* from, const char* what, const char* list[], int max,
          int* num)
{
  int i;
  for (i = 0; i < max; i++) {
    if (streq(what, list[i])) {
      *num = i;
      return PARSE_ERROR_NONE;
    }
  }
  msg("Unknown %s '%s'.", from, what);
  return PARSE_ERROR_GENERIC;
}
STATIC_OVL errr
grab_flag(bitflag* flags, const size_t size, const char** flag_table,
          const char* flag_name)
{
  int flag = lookup_flag(flag_table, flag_name);
  if (flag == FLAG_END) return PARSE_ERROR_INVALID_FLAG;
  flag_on(flags, size, flag);
  return 0;
}
STATIC_OVL errr
remove_flag(bitflag* flags, const size_t size, const char** flag_table,
            const char* flag_name)
{
  int flag = lookup_flag(flag_table, flag_name);
  if (flag == FLAG_END) return PARSE_ERROR_INVALID_FLAG;
  flag_off(flags, size, flag);
  return 0;
}
STATIC_OVL void
write_flags(ang_file* fff, const char* intro_text, const bitflag* flags,
            int flag_size, const char* names[])
{
  int flag;
  char buf[1024] = "";
  int pointer = 0;
  for (flag = flag_next(flags, flag_size, FLAG_START); flag != FLAG_END;
       flag = flag_next(flags, flag_size, flag + 1)) {
    if (strlen(buf)) {
      my_strcat(buf, " | ", sizeof(buf));
      pointer += 3;
    }
    if (!names[flag]) break;
    my_strcat(buf, names[flag], sizeof(buf));
    pointer += strlen(names[flag]);
    if (pointer >= 60) {
      file_putf(fff, "%s%s\n", intro_text, buf);
      my_strcpy(buf, "", sizeof(buf));
      pointer = 0;
    }
  }
  if (pointer) file_putf(fff, "%s%s\n", intro_text, buf);
}
STATIC_OVL void
write_mods(ang_file* fff, const int values[])
{
  size_t i;
  char buf[1024] = "";
  int pointer = 0;
  static const char* obj_mods[] = {
      "STR",      "DEX",     "CON",          "GRA",        "MELEE",
      "ARCHERY",  "EVASION", "STEALTH",      "PERCEPTION", "WILL",
      "SMITHING", "SONG",    "DAMAGE_SIDES", "TUNNEL",     NULL};
  for (i = 0; i < OBJ_MOD_MAX; i++) {
    if (values[i] == 0) continue;
    if (strlen(buf)) {
      my_strcat(buf, " | ", sizeof(buf));
      pointer += 3;
    }
    my_strcat(buf, obj_mods[i], sizeof(buf));
    pointer += strlen(obj_mods[i]);
    my_strcat(buf, format("[%d]", values[i]), sizeof(buf));
    pointer += 5;
    if (pointer >= 60) {
      file_putf(fff, "%s%s\n", "values:", buf);
      my_strcpy(buf, "", sizeof(buf));
      pointer = 0;
    }
  }
  if (pointer) file_putf(fff, "%s%s\n", "values:", buf);
}
STATIC_OVL void
write_elements(ang_file* fff, const struct element_info* el_info)
{
  size_t i;
  char buf[1024] = "";
  int pointer = 0;
  static const char* element_names[] = {"ACID", "FIRE", "COLD",
                                        "POIS", "DARK", NULL};
  for (i = 0; i < ELEM_MAX; i++) {
    if (el_info[i].res_level == 0) continue;
    if (strlen(buf)) {
      my_strcat(buf, " | ", sizeof(buf));
      pointer += 3;
    }
    my_strcat(buf, format("RES_%s", element_names[i]), sizeof(buf));
    pointer += strlen(element_names[i]) + 4;
    my_strcat(buf, format("[%d]", el_info[i].res_level), sizeof(buf));
    pointer += 5;
    if (pointer >= 60) {
      file_putf(fff, "%s%s\n", "values:", buf);
      my_strcpy(buf, "", sizeof(buf));
      pointer = 0;
    }
  }
  if (pointer) file_putf(fff, "%s%s\n", "values:", buf);
}
STATIC_OVL void
set_archive_user_prefix(const char* pfx)
{
  string_free(archive_user_pfx);
  archive_user_pfx = string_make(pfx);
}
STATIC_OVL void
file_archive(const char* fname, const char* append)
{
  char arch[1024];
  char old[1024];
  int i, max_arch = 10000;
  if (append) {
    path_build(arch, sizeof(arch), ANGBAND_DIR_ARCHIVE,
               format("%s%s_%s.txt", (archive_user_pfx) ? archive_user_pfx : "",
                      fname, append));
  } else {
    for (i = 1; i < max_arch; i++) {
      path_build(arch, sizeof(arch), ANGBAND_DIR_ARCHIVE,
                 format("%s%s_%d.txt",
                        (archive_user_pfx) ? archive_user_pfx : "", fname, i));
      if (!file_exists(arch)) break;
      my_strcpy(arch, "", sizeof(arch));
    }
  }
  path_build(old, sizeof(old), ANGBAND_DIR_USER, format("%s.txt", fname));
  safe_setuid_grab();
  file_move(old, arch);
  safe_setuid_drop();
}
STATIC_OVL bool
randart_file_exists(void)
{
  char path[1024];
  path_build(
      path, sizeof(path), ANGBAND_DIR_ARCHIVE,
      format("%srandart_%08lx.txt", (archive_user_pfx) ? archive_user_pfx : "",
             (unsigned long)seed_randart));
  return file_exists(path);
}
STATIC_OVL void
activate_randart_file(void)
{
  char new[1024];
  char old[1024];
  path_build(
      old, sizeof(old), ANGBAND_DIR_ARCHIVE,
      format("%srandart_%08lx.txt", (archive_user_pfx) ? archive_user_pfx : "",
             (unsigned long)seed_randart));
  path_build(new, sizeof(new), ANGBAND_DIR_USER, "randart.txt");
  safe_setuid_grab();
  file_move(old, new);
  safe_setuid_drop();
}
STATIC_OVL void
deactivate_randart_file(void)
{
  char buf[10];
  strnfmt(buf, 9, "%08lx", (unsigned long)seed_randart);
  file_archive("randart", buf);
}
STATIC_OVL void
write_self_made_artefacts(void)
{
  ang_file* log_file;
  char fname[1024];
  path_build(fname, sizeof(fname), ANGBAND_DIR_USER, "randart.txt");
  log_file = file_open(fname, MODE_WRITE, FTYPE_TEXT);
  file_putf(log_file,
            "# Artifact file for self-made artifacts with label %08x\n\n\n",
            seed_randart);
  write_self_made_artefact_entries(log_file);
  if (!file_close(log_file)) {
    quit_fmt("Error - can't close %s.", fname);
  }
}
STATIC_OVL void
to_stderr(const char* out)
{
  fputs(out, stderr);
  fputs("\n", stderr);
}
STATIC_OVL void
debug(const char* fmt, ...)
{
  va_list vp;
  char buffer[1024] = "";
  va_start(vp, fmt);
  vstrnfmt(buffer, sizeof(buffer), fmt, vp);
  va_end(vp);
  d_out(buffer);
  return;
}
STATIC_OVL void
get_target(struct source origin, int dir, struct loc* grid, int* flags)
{
  switch (origin.what) {
    case SRC_MONSTER: {
      struct monster* monster = cave_monster(cave, origin.which.monster);
      if (!monster) break;
      *flags |= (PROJECT_PLAY);
      if (monster->target.midx > 0) {
        struct monster* mon = cave_monster(cave, monster->target.midx);
        *grid = mon->grid;
      } else {
        *grid = player->grid;
      }
      break;
    }
    case SRC_PLAYER:
      if (dir == DIR_TARGET && target_okay(z_info->max_range)) {
        target_get(grid);
      } else {
        *grid = loc_sum(player->grid, ddgrid[dir]);
      }
      break;
    default:
      *flags |= PROJECT_PLAY;
      *grid = player->grid;
      break;
  }
}
STATIC_OVL bool
project_aimed(struct source origin, int typ, int dir, int dd, int ds, int dif,
              int flg, const struct object* obj)
{
  struct loc grid = loc(-1, -1);
  flg |= (PROJECT_THRU);
  get_target(origin, dir, &grid, &flg);
  return (project(origin, 0, grid, dd, ds, dif, typ, flg, 0, false, obj));
}
STATIC_OVL bool
effect_handler_HEAL_HP(effect_handler_context_t* context)
{
  int num, minh;
  context->ident = true;
  if (player->chp >= player->mhp) return (true);
  num = ((player->mhp - player->chp) * context->value.m_bonus) / 100;
  minh =
      context->value.base + damroll(context->value.dice, context->value.sides);
  if (num < minh) num = minh;
  if (num <= 0) {
    return true;
  }
  player->chp += num;
  if (player->chp >= player->mhp) {
    player->chp = player->mhp;
    player->chp_frac = 0;
  }
  player->upkeep->redraw |= (PR_HP);
  if (num < 5)
    msg("You feel a little better.");
  else if (num < 15)
    msg("You feel better.");
  else if (num < 35)
    msg("You feel much better.");
  else
    msg("You feel very good.");
  return (true);
}
STATIC_OVL bool
effect_handler_DAMAGE(effect_handler_context_t* context)
{
  int dam = effect_calculate_value(context);
  char killer[80];
  context->ident = true;
  switch (context->origin.what) {
    case SRC_MONSTER: {
      struct monster* mon = cave_monster(cave, context->origin.which.monster);
      monster_desc(killer, sizeof(killer), mon, MDESC_DIED_FROM);
      break;
    }
    case SRC_TRAP: {
      struct trap* trap = context->origin.which.trap;
      const char* article = is_a_vowel(trap->kind->desc[0]) ? "an " : "a ";
      strnfmt(killer, sizeof(killer), "%s%s", article, trap->kind->desc);
      break;
    }
    case SRC_CHEST_TRAP: {
      struct chest_trap* trap = context->origin.which.chest_trap;
      strnfmt(killer, sizeof(killer), "%s", trap->msg_death);
      break;
    }
    case SRC_PLAYER: {
      if (context->msg) {
        my_strcpy(killer, context->msg, sizeof(killer));
      } else {
        my_strcpy(killer, "yourself", sizeof(killer));
      }
      break;
    }
    case SRC_NONE: {
      my_strcpy(killer, "a bug", sizeof(killer));
      break;
    }
    default:
      break;
  }
  take_hit(player, dam, killer);
  return true;
}
STATIC_OVL bool
effect_handler_DART(effect_handler_context_t* context)
{
  int dam = effect_calculate_value(context);
  int prt = protection_roll(player, PROJ_HURT, false, RANDOMISE);
  char* name;
  assert(context->origin.what == SRC_TRAP);
  name = context->origin.which.trap->kind->name;
  if (check_hit(context->radius, true, context->origin)) {
    if (dam > prt) {
      msg("A small dart hits you!");
      take_hit(player, context->other, name);
      event_signal_combat_damage(EVENT_COMBAT_DAMAGE, context->value.dice,
                                 context->value.sides, prt + 1, -1, -1, prt,
                                 100, PROJ_HURT, false);
      player_stat_dec(player, context->subtype);
    } else {
      msg("A small dart hits you, but is deflected by your armour.");
      event_signal_combat_damage(EVENT_COMBAT_DAMAGE, context->value.dice,
                                 context->value.sides, dam, -1, -1, prt, 100,
                                 PROJ_HURT, false);
    }
  } else {
    msg("A small dart barely misses you.");
  }
  monsters_hear(true, false, 5);
  return true;
}
STATIC_OVL bool
effect_handler_PIT(effect_handler_context_t* context)
{
  bool spiked = (context->subtype == 1);
  square_set_feat(cave, player->grid, spiked ? FEAT_SPIKED_PIT : FEAT_PIT);
  player_fall_in_pit(player, spiked);
  return true;
}
STATIC_OVL bool
effect_handler_PROJECT_LOS(effect_handler_context_t* context)
{
  int i;
  int typ = context->subtype;
  struct loc origin = origin_get_loc(context->origin);
  int flg = PROJECT_JUMP | PROJECT_KILL | PROJECT_HIDE;
  for (i = 1; i < cave_monster_max(cave); i++) {
    struct monster* mon = cave_monster(cave, i);
    if (!mon->race) continue;
    if (mon->midx == cave->mon_current) continue;
    if (!los(cave, origin, mon->grid)) continue;
    if (!square_isfire(cave, mon->grid)) continue;
    if (project(source_player(), 0, mon->grid, 0, 0, context->value.base, typ,
                flg, 0, 0, context->obj)) {
      context->ident = true;
    }
  }
  return true;
}
STATIC_OVL bool
effect_handler_PROJECT_LOS_GRIDS(effect_handler_context_t* context)
{
  struct loc grid;
  int typ = context->subtype;
  int flg = PROJECT_GRID | PROJECT_ITEM | PROJECT_JUMP | PROJECT_HIDE;
  for (grid.y = player->grid.y - z_info->max_sight;
       grid.y <= player->grid.y + z_info->max_sight; grid.y++) {
    for (grid.x = player->grid.x - z_info->max_sight;
         grid.x <= player->grid.x + z_info->max_sight; grid.x++) {
      if (!square_in_bounds_fully(cave, grid)) continue;
      if (!square_isview(cave, grid)) continue;
      if (project(source_player(), 0, grid, 0, 0, context->value.base, typ, flg,
                  0, 0, context->obj))
        context->ident = true;
    }
  }
  return true;
}
STATIC_OVL bool
effect_handler_DEADFALL(effect_handler_context_t* context)
{
  int i;
  struct loc pgrid = player->grid, safe_grid = loc(0, 0);
  int safe_grids = 0;
  int dam, prt, net_dam = 0;
  for (i = 0; i < 8; i++) {
    struct loc grid = loc_sum(pgrid, ddgrid_ddd[i]);
    if (!square_isopen(cave, grid)) continue;
    if ((++safe_grids > 1) && (randint0(safe_grids) != 0)) continue;
    safe_grid = grid;
  }
  if (!safe_grids) {
    msg("You are severely crushed!");
    dam = damroll(6, 8);
    prt = protection_roll(player, PROJ_HURT, false, false);
    net_dam = (dam - prt > 0) ? (dam - prt) : 0;
    event_signal_combat_attack(EVENT_COMBAT_ATTACK, source_none(),
                               source_player(), true, -1, -1, -1, -1, false);
    event_signal_combat_damage(EVENT_COMBAT_DAMAGE, 6, 8, dam, -1, -1, prt, 100,
                               PROJ_HURT, false);
    (void)player_inc_timed(player, TMD_STUN, dam * 4, true, true, true);
  } else {
    if (check_hit(20, true, context->origin)) {
      msg("You are struck by rubble!");
      dam = damroll(4, 8);
      prt = protection_roll(player, PROJ_HURT, false, false);
      event_signal_combat_damage(EVENT_COMBAT_DAMAGE, 4, 8, dam, -1, -1, prt,
                                 100, PROJ_HURT, false);
      net_dam = (dam - prt > 0) ? (dam - prt) : 0;
      (void)player_inc_timed(player, TMD_STUN, dam * 4, true, true, true);
    } else {
      msg("You nimbly dodge the falling rock!");
    }
    monster_swap(pgrid, safe_grid);
    player_handle_post_move(player, true, true);
  }
  take_hit(player, net_dam, "a deadfall");
  square_set_feat(cave, pgrid, FEAT_RUBBLE);
  return true;
}
STATIC_OVL bool
effect_handler_EARTHQUAKE(effect_handler_context_t* context)
{
  int r = effect_calculate_value(context);
  ;
  bool melee = context->other;
  struct loc pgrid = player->grid;
  bool vis = (context->origin.what == SRC_PLAYER);
  int i;
  struct loc offset, pit = loc(0, 0);
  bool fall_in = false;
  struct loc centre = origin_get_loc(context->origin);
  int player_damage = 0, player_dd = 0, player_ds = 0;
  context->ident = true;
  if (!player->depth) {
    msg("The ground shakes for a moment.");
    return true;
  }
  if (r > 10) r = 10;
  if (context->origin.what == SRC_MONSTER) {
    struct monster* mon = cave_monster(cave, context->origin.which.monster);
    vis = monster_is_visible(mon);
    if (mon->race == lookup_monster("Morgoth, Lord of Darkness")) {
      struct loc safe;
      bool in_pit = square_ispit(cave, player->grid);
      int num = 0;
      if (melee) {
        int dir = rough_direction(mon->grid, pgrid);
        pit = loc_sum(mon->grid, ddgrid[dir]);
      } else {
        pit = pgrid;
      }
      if (loc_eq(pit, pgrid)) {
        if (!in_pit) {
          for (i = 0; i < 8; i++) {
            struct loc test = loc_sum(pgrid, ddgrid_ddd[i]);
            if (!square_isempty(cave, test)) continue;
            if ((++num > 1) && (randint0(num) != 0)) continue;
            safe = test;
          }
        }
        if (num > 0) {
          monster_swap(pgrid, safe);
          player_handle_post_move(player, true, true);
        } else {
          fall_in = true;
        }
      }
      if (square_changeable(cave, pit)) {
        square_excise_pile(cave, pit);
        square_set_feat(cave, pit, FEAT_PIT);
      }
    }
  }
  for (offset.y = -r; offset.y <= r; offset.y++) {
    for (offset.x = -r; offset.x <= r; offset.x++) {
      int ds, dd, damage, net_dam, prt;
      struct loc grid = loc_sum(centre, offset);
      int dist = distance(centre, grid);
      struct monster* mon = square_monster(cave, grid);
      if (!square_in_bounds_fully(cave, grid)) continue;
      if (dist > r) continue;
      if (loc_is_zero(offset)) continue;
      dd = r + 1 - dist;
      ds = 8;
      damage = damroll(dd, ds);
      if (square_isplayer(cave, grid)) {
        player_damage = damage;
        player_dd = dd;
        player_ds = ds;
      } else if (mon) {
        char m_name[80];
        monster_desc(m_name, sizeof(m_name), mon, MDESC_STANDARD);
        prt = damroll(mon->race->pd, mon->race->ps);
        net_dam = damage - prt;
        if (net_dam > 0) {
          bool killed = false;
          if (monster_is_visible(mon)) {
            msg("%s is hit by falling debris.", m_name);
            event_signal_combat_attack(EVENT_COMBAT_ATTACK, context->origin,
                                       source_monster(mon->midx), vis, -1, -1,
                                       -1, -1, false);
            event_signal_combat_damage(EVENT_COMBAT_DAMAGE, dd, ds, damage,
                                       mon->race->pd, mon->race->ps, prt, 100,
                                       PROJ_HURT, false);
          }
          killed = mon_take_hit(mon, player, net_dam, NULL);
          if (!killed) {
            if (rf_has(mon->race->flags, RF_NO_STUN)) {
              struct monster_lore* lore = get_lore(mon->race);
              if (monster_is_visible(mon)) {
                rf_on(lore->flags, RF_NO_STUN);
              }
            } else {
              mon_inc_timed(mon, MON_TMD_STUN, net_dam * 4, 0);
            }
            set_alertness(mon, MAX(mon->alertness + 10, ALERTNESS_VERY_ALERT));
            if (!monster_is_visible(mon)) {
              message_pain(mon, damage);
            }
          }
        }
      }
      if (!square_isoccupied(cave, grid) && percent_chance(damage) &&
          !loc_eq(grid, pit)) {
        if (square_changeable(cave, grid)) {
          int t, feat = FEAT_FLOOR, adj_chasms = 0;
          square_excise_pile(cave, grid);
          for (i = 0; i < 8; i++) {
            struct loc adj_grid = loc_sum(grid, ddgrid_ddd[i]);
            if (square_ischasm(cave, adj_grid)) {
              adj_chasms++;
            }
          }
          t = randint0(100);
          if (square_ischasm(cave, grid)) {
            if (one_in_(10)) {
              if (t < 10) {
                feat = FEAT_RUBBLE;
              } else if (t < 70) {
                feat = FEAT_GRANITE;
              } else {
                feat = FEAT_QUARTZ;
              }
            }
          } else if (!square_iswall(cave, grid)) {
            if (randint1(8) <= adj_chasms + 1) {
              feat = FEAT_CHASM;
            } else if (t < 40) {
              feat = FEAT_RUBBLE;
            } else if (t < 80) {
              feat = FEAT_GRANITE;
            } else {
              feat = FEAT_QUARTZ;
            }
          } else if (square_isrubble(cave, grid)) {
            if (randint1(32) <= adj_chasms) {
              feat = FEAT_CHASM;
            } else if (t < 40) {
              feat = FEAT_FLOOR;
            } else if (t < 70) {
              feat = FEAT_GRANITE;
            } else {
              feat = FEAT_QUARTZ;
            }
          } else {
            if (randint1(32) <= adj_chasms) {
              feat = FEAT_CHASM;
            } else if (t < 80) {
              feat = FEAT_RUBBLE;
            } else {
              feat = FEAT_FLOOR;
            }
          }
          if ((feat != FEAT_CHASM) && (player->depth < z_info->dun_depth - 1)) {
            square_unmark(cave, grid);
            square_set_feat(cave, grid, feat);
          }
        }
      }
    }
  }
  if (player_damage) {
    int prt, net_dam;
    msg("You are pummeled with debris!");
    prt = protection_roll(player, PROJ_HURT, false, RANDOMISE);
    net_dam = player_damage - prt;
    if (net_dam > 0) {
      take_hit(player, net_dam, "an earthquake");
    }
    if (!player->is_dead) {
      player_inc_timed(player, TMD_STUN, net_dam * 4, true, true, true);
    }
    event_signal_combat_attack(EVENT_COMBAT_ATTACK, context->origin,
                               source_player(), vis, -1, -1, -1, -1, false);
    event_signal_combat_damage(EVENT_COMBAT_DAMAGE, player_dd, player_ds,
                               player_damage, -1, -1, prt, 100, PROJ_HURT,
                               false);
  }
  if (fall_in && !player->is_dead && square_ispit(cave, pgrid)) {
    int damage;
    msg("You fall back into the newly made pit!");
    damage = damroll(2, 4);
    event_signal_combat_attack(EVENT_COMBAT_ATTACK, source_grid(pgrid),
                               source_player(), true, -1, -1, -1, -1, false);
    event_signal_combat_damage(EVENT_COMBAT_DAMAGE, 2, 4, damage, -1, -1, 0, 0,
                               PROJ_HURT, false);
    take_hit(player, damage, "falling into a pit");
  }
  monsters_hear(true, false, -30);
  player->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
  player->upkeep->redraw |= (PR_MAP | PR_HEALTH);
  player->upkeep->redraw |= (PR_MONLIST | PR_ITEMLIST);
  return true;
}
STATIC_OVL bool
effect_handler_SPOT(effect_handler_context_t* context)
{
  struct loc pgrid = player->grid;
  int rad = context->radius ? context->radius : 0;
  int flg = PROJECT_JUMP | PROJECT_PLAY;
  if (project(context->origin, rad, pgrid, context->value.dice,
              context->value.sides, context->value.m_bonus, context->subtype,
              flg, 0, true, NULL))
    context->ident = true;
  return true;
}
STATIC_OVL bool
effect_handler_SPHERE(effect_handler_context_t* context)
{
  struct loc pgrid = player->grid;
  int rad = context->radius ? context->radius : 0;
  int diameter_of_source = context->other ? context->other : 0;
  int flg = PROJECT_STOP | PROJECT_GRID | PROJECT_ITEM | PROJECT_KILL;
  if (context->origin.what == SRC_MONSTER) {
    flg |= PROJECT_PLAY;
  }
  if (project(context->origin, rad, pgrid, context->value.dice,
              context->value.sides, context->value.m_bonus, context->subtype,
              flg, 0, diameter_of_source, NULL))
    context->ident = true;
  return true;
}
STATIC_OVL bool
effect_handler_EXPLOSION(effect_handler_context_t* context)
{
  int dd = context->value.dice;
  int ds = context->value.sides;
  int dif = context->value.base;
  int rad = context->radius ? context->radius : 0;
  struct loc target = origin_get_loc(context->origin);
  int flg = PROJECT_BOOM | PROJECT_GRID | PROJECT_JUMP | PROJECT_ITEM |
            PROJECT_KILL | PROJECT_PLAY;
  if (project(context->origin, rad, target, dd, ds, dif, context->subtype, flg,
              0, true, context->obj))
    context->ident = true;
  return true;
}
STATIC_OVL bool
effect_handler_BREATH(effect_handler_context_t* context)
{
  int type = context->subtype;
  struct loc target = player->grid;
  int degrees_of_arc = context->other;
  int rad = context->radius;
  int flg = PROJECT_ARC | PROJECT_GRID | PROJECT_ITEM | PROJECT_KILL |
            PROJECT_PLAY | PROJECT_RANGE_DAM;
  if (project(context->origin, rad, target, context->value.dice,
              context->value.sides, context->value.m_bonus, type, flg,
              degrees_of_arc, 0, context->obj))
    context->ident = true;
  return true;
}
STATIC_OVL bool
effect_handler_BOLT(effect_handler_context_t* context)
{
  int flg = PROJECT_STOP | PROJECT_KILL;
  (void)project_aimed(context->origin, context->subtype, context->dir,
                      context->value.dice, context->value.sides,
                      context->value.m_bonus, flg, context->obj);
  if (!player->timed[TMD_BLIND]) context->ident = true;
  return true;
}
STATIC_OVL bool
effect_handler_BEAM(effect_handler_context_t* context)
{
  int flg = PROJECT_BEAM | PROJECT_KILL;
  (void)project_aimed(context->origin, context->subtype, context->dir,
                      context->value.dice, context->value.sides,
                      context->value.m_bonus, flg, context->obj);
  if (!player->timed[TMD_BLIND]) {
    context->ident = true;
  }
  return true;
}
STATIC_OVL bool
effect_handler_TERRAIN_BEAM(effect_handler_context_t* context)
{
  if (context->dir == DIR_UP || context->dir == DIR_DOWN) {
    assert(context->other);
    assert(context->subtype == PROJ_KILL_WALL);
    if (context->dir == DIR_UP) {
      player_blast_ceiling(player);
    } else {
      player_blast_floor(player);
    }
    context->ident = true;
  } else {
    int flg = PROJECT_BEAM | PROJECT_GRID | PROJECT_ITEM | PROJECT_WALL;
    (void)project_aimed(context->origin, context->subtype, context->dir,
                        context->value.dice, context->value.sides,
                        context->value.m_bonus, flg, context->obj);
    if (!player->timed[TMD_BLIND]) {
      context->ident = true;
    }
  }
  return true;
}
STATIC_OVL int
effect_calculate_value(effect_handler_context_t* context)
{
  int final = 0;
  if (set_value) {
    return set_value;
  }
  if (context->value.base > 0 ||
      (context->value.dice > 0 && context->value.sides > 0)) {
    final = context->value.base +
            damroll(context->value.dice, context->value.sides);
  }
  return final;
}
STATIC_OVL const char*
desc_stat(int stat, bool positive)
{
  struct obj_property* prop = lookup_obj_property(OBJ_PROPERTY_STAT, stat);
  if (positive) {
    return prop->adjective;
  }
  return prop->neg_adj;
}
STATIC_OVL bool
close_chasm(struct loc grid, int power)
{
  int adj_chasms = 0;
  int y, x;
  bool effect = false;
  for (y = grid.y - 1; y <= grid.y + 1; y++) {
    for (x = grid.x - 1; x <= grid.x + 1; x++) {
      struct loc adj = loc(x, y);
      if (!loc_eq(adj, grid) && square_in_bounds(cave, adj) &&
          square_ischasm(cave, adj)) {
        adj_chasms++;
      }
    }
  }
  if (adj_chasms < 8) {
    if (skill_check(source_player(), power, 20 + adj_chasms, source_none()) >
        0) {
      square_mark(cave, grid);
      effect = true;
    }
  }
  return effect;
}
STATIC_OVL void
close_marked_chasms(void)
{
  struct loc grid;
  for (grid.y = 0; grid.y < cave->height; grid.y++) {
    for (grid.x = 0; grid.x < cave->width; grid.x++) {
      if (square_ischasm(cave, grid) && square_ismark(cave, grid)) {
        square_unmark(cave, grid);
        square_set_feat(cave, grid, FEAT_FLOOR);
        square_memorize(cave, grid);
        square_light_spot(cave, grid);
      }
    }
  }
}
STATIC_OVL bool
item_tester_unknown(const struct object* obj)
{
  return object_runes_known(obj) ? false : true;
}
STATIC_OVL bool
effect_handler_NOURISH(effect_handler_context_t* context)
{
  const char* old_grade = player_get_timed_grade(player, TMD_FOOD);
  int amount = effect_calculate_value(context);
  if (context->subtype == 0) {
    player_inc_timed(player, TMD_FOOD, MAX(amount, 0), false,
                     context->origin.what != SRC_PLAYER || !context->aware,
                     false);
  } else if (context->subtype == 1) {
    player_dec_timed(player, TMD_FOOD, MAX(amount, 0), false,
                     context->origin.what != SRC_PLAYER || !context->aware);
  } else {
    return false;
  }
  if (context->other) {
    if (old_grade != player_get_timed_grade(player, TMD_FOOD)) {
      context->ident = true;
    }
  } else {
    context->ident = true;
  }
  return true;
}
STATIC_OVL bool
effect_handler_CURE(effect_handler_context_t* context)
{
  int type = context->subtype;
  (void)player_clear_timed(
      player, type, true,
      context->origin.what != SRC_PLAYER || !context->aware);
  context->ident = true;
  return true;
}
STATIC_OVL bool
effect_handler_TIMED_SET(effect_handler_context_t* context)
{
  int amount = effect_calculate_value(context);
  if (player_set_timed(player, context->subtype, MAX(amount, 0), true,
                       context->origin.what != SRC_PLAYER || !context->aware)) {
    context->ident = true;
  }
  return true;
}
STATIC_OVL bool
effect_handler_TIMED_INC(effect_handler_context_t* context)
{
  int amount = effect_calculate_value(context);
  player_inc_timed(player, context->subtype, MAX(amount, 0), true,
                   context->origin.what != SRC_PLAYER || !context->aware, true);
  context->ident = true;
  return true;
}
STATIC_OVL bool
effect_handler_TIMED_INC_CHECK(effect_handler_context_t* context)
{
  context->ident = player_inc_check(player, context->subtype, false);
  return true;
}
STATIC_OVL bool
effect_handler_TIMED_INC_NO_RES(effect_handler_context_t* context)
{
  int amount = effect_calculate_value(context);
  player_inc_timed(player, context->subtype, MAX(amount, 0), true,
                   context->origin.what != SRC_PLAYER || !context->aware,
                   false);
  context->ident = true;
  return true;
}
STATIC_OVL bool
effect_handler_TERROR(effect_handler_context_t* context)
{
  bool afraid = player_inc_check(player, TMD_AFRAID, false);
  if (afraid) {
    int fear_amount, haste_amount;
    fear_amount = damroll(context->value.dice, context->value.sides);
    haste_amount = damroll(context->value.dice / 2, context->value.sides);
    context->ident = !player->timed[TMD_AFRAID] || !player->timed[TMD_FAST];
    player_inc_timed(player, TMD_AFRAID, MAX(fear_amount, 0), true,
                     context->origin.what != SRC_PLAYER || !context->aware,
                     false);
    player_inc_timed(player, TMD_FAST, MAX(haste_amount, 0), true,
                     context->origin.what != SRC_PLAYER || !context->aware,
                     false);
  } else {
    msg("You feel nervous for a moment.");
    context->ident = true;
  }
  return true;
}
STATIC_OVL bool
effect_handler_GLYPH(effect_handler_context_t* context)
{
  context->ident = true;
  if (!square_istrappable(cave, player->grid)) {
    msg("You cannot draw a glyph without a clean expanse of floor.");
    return false;
  }
  if (square_object(cave, player->grid)) push_object(player->grid);
  msg("You trace out a glyph of warding upon the floor.");
  square_add_glyph(cave, player->grid, context->subtype);
  return true;
}
STATIC_OVL bool
effect_handler_RESTORE_STAT(effect_handler_context_t* context)
{
  int stat = context->subtype;
  int gain = effect_calculate_value(context);
  if (stat < 0 || stat >= STAT_MAX) return false;
  if (player_stat_res(player, stat, gain)) {
    msg("You feel less %s.", desc_stat(stat, false));
    context->ident = true;
  }
  return true;
}
STATIC_OVL bool
effect_handler_DRAIN_STAT(effect_handler_context_t* context)
{
  int stat = context->subtype;
  int flag = sustain_flag(stat);
  struct monster* mon = cave_monster(cave, cave->mon_current);
  if (flag < 0) return false;
  if (player_saving_throw(player, mon, player->state.flags[flag])) {
    msg("You feel %s for a moment, but it passes.", desc_stat(stat, false));
    equip_learn_flag(player, flag);
    context->ident = true;
    return true;
  }
  player_stat_dec(player, stat);
  msgt(MSG_DRAIN_STAT, "You feel %s.", desc_stat(stat, false));
  context->ident = true;
  return true;
}
STATIC_OVL bool
effect_handler_RESTORE_MANA(effect_handler_context_t* context)
{
  int amount = effect_calculate_value(context);
  if (!amount) amount = player->msp;
  if (player->csp < player->msp) {
    player->csp += amount;
    if (player->csp > player->msp) {
      player->csp = player->msp;
      player->csp_frac = 0;
      msg("You feel your power renew.");
    } else
      msg("You feel your power renew somewhat.");
    player->upkeep->redraw |= (PR_MANA);
  }
  context->ident = true;
  return true;
}
STATIC_OVL bool
effect_handler_REMOVE_CURSE(effect_handler_context_t* context)
{
  int i;
  bool removed = false;
  for (i = 0; i < player->body.count; i++) {
    struct object* obj = slot_object(player, i);
    if (!obj || !obj->kind) continue;
    if (!obj_is_cursed(obj)) continue;
    uncurse_object(obj);
    removed = true;
  }
  if (removed) {
    context->ident = true;
    msg("You feel sanctified.");
  }
  return true;
}
STATIC_OVL bool
effect_handler_MAP_AREA(effect_handler_context_t* context)
{
  int i, x, y;
  for (y = 1; y < cave->height - 1; y++) {
    for (x = 1; x < cave->width - 1; x++) {
      struct loc grid = loc(x, y);
      if (!square_seemslikewall(cave, grid)) {
        if (!square_in_bounds_fully(cave, grid)) continue;
        if (!square_isfloor(cave, grid)) square_memorize(cave, grid);
        for (i = 0; i < 8; i++) {
          int yy = y + ddy_ddd[i];
          int xx = x + ddx_ddd[i];
          if (square_seemslikewall(cave, loc(xx, yy)))
            square_memorize(cave, loc(xx, yy));
        }
      }
      if (square_ismemorybad(cave, grid)) {
        square_unmark(cave, grid);
      }
    }
  }
  player->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
  player->upkeep->redraw |= (PR_MAP | PR_MONLIST | PR_ITEMLIST);
  context->ident = true;
  return true;
}
STATIC_OVL bool
effect_handler_DETECT_TRAPS(effect_handler_context_t* context)
{
  struct loc grid;
  bool detect = false;
  for (grid.y = player->grid.y - z_info->max_sight;
       grid.y <= player->grid.y + z_info->max_sight; grid.y++) {
    for (grid.x = player->grid.x - z_info->max_sight;
         grid.x <= player->grid.x + z_info->max_sight; grid.x++) {
      if (!square_in_bounds_fully(cave, grid)) continue;
      if (!square_isview(cave, grid)) continue;
      if (square_isplayertrap(cave, grid)) {
        if (square_reveal_trap(cave, grid, false)) {
          detect = true;
        }
      }
    }
  }
  if (detect) {
    msg("You sense the presence of traps!");
  }
  context->ident = true;
  return true;
}
STATIC_OVL bool
effect_handler_DETECT_DOORS(effect_handler_context_t* context)
{
  struct loc grid;
  bool doors = false;
  for (grid.y = player->grid.y - z_info->max_sight;
       grid.y <= player->grid.y + z_info->max_sight; grid.y++) {
    for (grid.x = player->grid.x - z_info->max_sight;
         grid.x <= player->grid.x + z_info->max_sight; grid.x++) {
      if (!square_in_bounds_fully(cave, grid)) continue;
      if (!square_isview(cave, grid)) continue;
      if (square_issecretdoor(cave, grid)) {
        place_closed_door(cave, grid);
        square_memorize(cave, grid);
        square_light_spot(cave, grid);
        doors = true;
      } else if (square_isdoor(cave, grid)) {
        if (square_ismemorybad(cave, grid)) {
          square_memorize(cave, grid);
          square_light_spot(cave, grid);
          doors = true;
        }
      } else if (square_isdoor(player->cave, grid) &&
                 square_ismemorybad(cave, grid)) {
        square_forget(cave, grid);
      }
    }
  }
  if (doors)
    msg("You sense the presence of doors!");
  else if (context->aware)
    msg("You sense no doors.");
  context->ident = true;
  return true;
}
STATIC_OVL bool
detect_monsters(monster_predicate pred)
{
  int i;
  bool monsters = false;
  for (i = 1; i < cave_monster_max(cave); i++) {
    struct monster* mon = cave_monster(cave, i);
    if (!mon->race) continue;
    if (!pred || pred(mon)) {
      mflag_on(mon->mflag, MFLAG_MARK);
      mflag_on(mon->mflag, MFLAG_SHOW);
      if (monster_is_invisible(mon)) {
        struct monster_lore* lore = get_lore(mon->race);
        rf_on(lore->flags, RF_INVISIBLE);
      }
      if (player->upkeep->monster_race == mon->race)
        player->upkeep->redraw |= (PR_MONSTER);
      update_mon(mon, cave, false);
      monsters = true;
    }
  }
  return monsters;
}
STATIC_OVL bool
effect_handler_DETECT_OBJECTS(effect_handler_context_t* context)
{
  int x, y;
  bool objects = false;
  for (y = 1; y <= cave->height - 1; y++) {
    for (x = 1; x <= cave->width - 1; x++) {
      struct loc grid = loc(x, y);
      struct object* obj = square_object(cave, grid);
      if (!obj) continue;
      if (!ignore_item_ok(player, obj)) {
        objects = true;
        context->ident = true;
      }
      square_know_pile(cave, grid);
    }
  }
  if (objects)
    msg("You detect the presence of objects!");
  else if (context->aware)
    msg("You detect no objects.");
  player->upkeep->redraw |= PR_ITEMLIST;
  return true;
}
STATIC_OVL bool
effect_handler_DETECT_MONSTERS(effect_handler_context_t* context)
{
  bool monsters = detect_monsters(NULL);
  if (monsters) {
    msg("You sense the presence of your enemies!");
    context->ident = true;
  }
  return monsters;
}
STATIC_OVL bool
effect_handler_REVEAL_MONSTER(effect_handler_context_t* context)
{
  assert(context->origin.what == SRC_MONSTER);
  struct monster* mon = cave_monster(cave, context->origin.which.monster);
  char m_name[80];
  struct monster_lore* lore = get_lore(mon->race);
  if (monster_is_visible(mon) || !rf_has(mon->race->flags, RF_INVISIBLE)) {
    return false;
  }
  mflag_on(mon->mflag, MFLAG_VISIBLE);
  square_light_spot(cave, mon->grid);
  monster_desc(m_name, sizeof(m_name), mon, MDESC_DEFAULT);
  msg("%s appears for an instant!", m_name);
  rf_on(lore->flags, RF_INVISIBLE);
  context->ident = true;
  return true;
}
STATIC_OVL bool
effect_handler_CLOSE_CHASMS(effect_handler_context_t* context)
{
  struct loc grid;
  bool closed = false;
  int power = effect_calculate_value(context);
  for (grid.y = player->grid.y - z_info->max_sight;
       grid.y <= player->grid.y + z_info->max_sight; grid.y++) {
    for (grid.x = player->grid.x - z_info->max_sight;
         grid.x <= player->grid.x + z_info->max_sight; grid.x++) {
      if (!square_in_bounds_fully(cave, grid)) continue;
      if (!square_isview(cave, grid)) continue;
      if (square_ischasm(cave, grid)) {
        closed |= close_chasm(grid, power);
      }
    }
  }
  if (closed) {
    close_marked_chasms();
  }
  context->ident = true;
  return true;
}
STATIC_OVL bool
effect_handler_IDENTIFY(effect_handler_context_t* context)
{
  struct object* obj;
  const char *q, *s;
  int itemmode = (USE_EQUIP | USE_INVEN | USE_QUIVER | USE_FLOOR);
  bool used = false;
  context->ident = true;
  q = "Identify which item? ";
  s = "You have nothing to identify.";
  if (context->cmd) {
    if (cmd_get_item(context->cmd, "tgtitem", &obj, q, s, item_tester_unknown,
                     itemmode)) {
      return used;
    }
  } else if (!get_item(&obj, q, s, 0, item_tester_unknown, itemmode))
    return used;
  object_learn_unknown_rune(player, obj);
  return true;
}
STATIC_OVL bool
effect_handler_RECHARGE(effect_handler_context_t* context)
{
  int num = context->value.base;
  int itemmode = (USE_INVEN | USE_FLOOR);
  struct object* obj;
  bool used = false;
  const char *q, *s;
  context->ident = true;
  q = "Recharge which item? ";
  s = "You have nothing to recharge.";
  if (context->cmd) {
    if (cmd_get_item(context->cmd, "tgtitem", &obj, q, s, tval_can_have_charges,
                     itemmode)) {
      return used;
    }
  } else if (!get_item(&obj, q, s, 0, tval_can_have_charges, itemmode)) {
    return (used);
  }
  obj->pval += num;
  obj->notice &= ~(OBJ_NOTICE_EMPTY);
  player->upkeep->notice |= (PN_COMBINE);
  player->upkeep->redraw |= (PR_INVEN);
  return true;
}
STATIC_OVL bool
effect_handler_SUMMON(effect_handler_context_t* context)
{
  int summon_max = effect_calculate_value(context);
  int summon_type = context->subtype;
  bool stairs = context->other ? true : false;
  int level_boost = damroll(2, 2) - damroll(2, 2);
  int message_type = summon_message_type(summon_type);
  int count = 0;
  sound(message_type);
  if (stairs) {
    int i;
    for (i = 0; i < summon_max; i++) {
      if (pick_and_place_monster_on_stairs(cave, player, false, player->depth,
                                           false))
        context->ident = true;
    }
  } else {
    int itry = 0;
    while (count < summon_max && itry < 1000) {
      count += summon_specific(player->grid, player->depth + level_boost,
                               summon_type);
      ++itry;
    }
    context->ident = count ? true : false;
  }
  return true;
}
STATIC_OVL bool
effect_handler_TELEPORT_TO(effect_handler_context_t* context)
{
  struct loc start = player->grid, aim, land;
  int dis = 0, ctr = 0, dir = DIR_TARGET;
  context->ident = true;
  do {
    if (!get_aim_dir(&dir, cave->width)) return false;
  } while (dir == DIR_TARGET && !target_okay(cave->width));
  if (dir == DIR_TARGET)
    target_get(&aim);
  else
    aim = loc_offset(start, ddx[dir], ddy[dir]);
  while (1) {
    while (1) {
      land = rand_loc(aim, dis, dis);
      if (square_in_bounds_fully(cave, land)) break;
    }
    if (square_isempty(cave, land)) break;
    if (++ctr > (4 * dis * dis + 4 * dis + 1)) {
      ctr = 0;
      dis++;
    }
  }
  sound(MSG_TELEPORT);
  monster_swap(start, land);
  target_set_location(loc(0, 0));
  handle_stuff(player);
  return true;
}
STATIC_OVL bool
effect_handler_DARKEN_LEVEL(effect_handler_context_t* context)
{
  wiz_dark(cave, player);
  context->ident = true;
  return true;
}
STATIC_OVL bool
effect_handler_LIGHT_AREA(effect_handler_context_t* context)
{
  struct loc pgrid = player->grid;
  int rad = context->radius ? context->radius : 0;
  int flg = PROJECT_BOOM | PROJECT_GRID | PROJECT_KILL;
  if (!player->timed[TMD_BLIND]) msg("You are surrounded by a white light.");
  (void)project(source_player(), rad, pgrid, context->value.dice,
                context->value.sides, -1, context->subtype, flg, 0, false,
                NULL);
  context->ident = true;
  return (true);
}
STATIC_OVL bool
effect_handler_DARKEN_AREA(effect_handler_context_t* context)
{
  bool message = player->timed[TMD_BLIND] ? false : true;
  if (message) {
    msg("Darkness surrounds you.");
  }
  light_room(player->grid, false);
  context->ident = true;
  return (true);
}
STATIC_OVL bool
effect_handler_SONG_OF_ELBERETH(effect_handler_context_t* context)
{
  int i;
  int score = song_bonus(player, player->state.skill_use[SKILL_SONG],
                         lookup_song("Elbereth"));
  for (i = cave_monster_max(cave) - 1; i >= 1; i--) {
    struct monster* mon = cave_monster(cave, i);
    int resistance;
    int result;
    if (!mon->race) continue;
    if (!rf_has(mon->race->flags, RF_SMART)) continue;
    if (!rf_has(mon->race->flags, RF_QUESTOR)) continue;
    resistance = monster_skill(mon, SKILL_WILL);
    resistance += flow_dist(cave->player_noise, mon->grid);
    result = skill_check(source_player(), score, resistance,
                         source_monster(mon->midx));
    if (result > 0) {
      mon->tmp_morale -= result * 10;
    }
  }
  return true;
}
STATIC_OVL bool
effect_handler_SONG_OF_LORIEN(effect_handler_context_t* context)
{
  int i;
  int score = song_bonus(player, player->state.skill_use[SKILL_SONG],
                         lookup_song("Lorien"));
  for (i = cave_monster_max(cave) - 1; i >= 1; i--) {
    struct monster* mon = cave_monster(cave, i);
    int resistance;
    int result;
    if (!mon->race) continue;
    if (rf_has(mon->race->flags, RF_NO_SLEEP)) {
      struct monster_lore* lore = get_lore(mon->race);
      ;
      if (monster_is_visible(mon)) {
        rf_on(lore->flags, RF_NO_SLEEP);
      }
      continue;
    }
    resistance = monster_skill(mon, SKILL_WILL);
    resistance += 5 + flow_dist(cave->player_noise, mon->grid);
    result = skill_check(source_player(), score, resistance,
                         source_monster(mon->midx));
    if (result > 0) {
      set_alertness(mon, mon->alertness - result);
    }
  }
  return true;
}
STATIC_OVL bool
effect_handler_SONG_OF_FREEDOM(effect_handler_context_t* context)
{
  int base_diff = player->depth ? player->depth / 2 : 10;
  int score = song_bonus(player, player->state.skill_use[SKILL_SONG],
                         lookup_song("Freedom"));
  struct loc grid;
  bool closed_chasm = false;
  for (grid.y = 0; grid.y < cave->height; grid.y++) {
    for (grid.x = 0; grid.x < cave->width; grid.x++) {
      struct object* obj;
      if (!square_in_bounds_fully(cave, grid)) continue;
      obj = square_object(cave, grid);
      if (obj && tval_is_chest(obj) && (obj->pval > 0)) {
        int diff = base_diff + 5 + flow_dist(cave->player_noise, grid);
        if (skill_check(source_player(), score, diff, source_none())) {
          obj->pval = (0 - obj->pval);
          obj->known->pval = obj->pval;
        }
      } else if (square_ischasm(cave, grid)) {
        int power = score - flow_dist(cave->player_noise, grid) - 5;
        closed_chasm |= close_chasm(grid, power);
      } else if (square_issecrettrap(cave, grid)) {
        int diff = base_diff + 5 + flow_dist(cave->player_noise, grid);
        if (skill_check(source_player(), score, diff, source_none()) > 0) {
          square_destroy_trap(cave, grid);
        }
      } else if (square_isvisibletrap(cave, grid)) {
        int diff = base_diff + 5 + flow_dist(cave->player_noise, grid);
        if (skill_check(source_player(), score, diff, source_none()) > 0) {
          square_destroy_trap(cave, grid);
          square_light_spot(cave, grid);
        }
      } else if (square_issecretdoor(cave, grid)) {
        int diff = base_diff + flow_dist(cave->player_noise, grid);
        if (skill_check(source_player(), score, diff, source_none()) > 0) {
          place_closed_door(cave, grid);
          if (square_isseen(cave, grid)) {
            msg("You have found a secret door.");
            disturb(player, false);
          }
        }
      } else if (square_isjammeddoor(cave, grid)) {
        int diff = base_diff + flow_dist(cave->player_noise, grid);
        int result = skill_check(source_player(), score, diff, source_none());
        if (result > 0) {
          int jam = square_door_jam_power(cave, grid) - result;
          square_set_door_jam(cave, grid, MAX(jam, 0));
        }
      } else if (square_islockeddoor(cave, grid)) {
        int diff = base_diff + flow_dist(cave->player_noise, grid);
        int result = skill_check(source_player(), score, diff, source_none());
        if (result > 0) {
          int lock = square_door_lock_power(cave, grid) - result;
          square_set_door_lock(cave, grid, MAX(lock, 0));
        }
      } else if (square_isrubble(cave, grid)) {
        int d, noise_dist = 100;
        int diff, result;
        for (d = 0; d < 8; d++) {
          int dir = cycle[d];
          int noise_dist_new =
              flow_dist(cave->player_noise, loc_sum(grid, ddgrid[dir]));
          noise_dist = MIN(noise_dist, noise_dist_new);
        }
        noise_dist++;
        diff = base_diff + 5 + noise_dist;
        result = skill_check(source_player(), score, diff, source_none());
        if (result > 0) {
          square_set_feat(cave, grid, FEAT_FLOOR);
          player->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
        }
      }
    }
  }
  if (closed_chasm) {
    close_marked_chasms();
  }
  return true;
}
STATIC_OVL bool
effect_handler_SONG_OF_BINDING(effect_handler_context_t* context)
{
  struct monster* mon = cave_monster(cave, context->origin.which.monster);
  int song_skill = monster_sing(mon, lookup_song("Binding"));
  struct loc grid;
  int dist, result, resistance;
  cave->monster_noise.centre = mon->grid;
  update_flow(cave, &cave->monster_noise, NULL);
  for (grid.y = 0; grid.y < cave->height; grid.y++) {
    for (grid.x = 0; grid.x < cave->width; grid.x++) {
      if (!square_in_bounds_fully(cave, grid)) continue;
      if (!square_monster(cave, grid) && square_isdoor(cave, grid) &&
          !((mon->grid.y <= grid.y) && (grid.y <= player->grid.y) &&
            (mon->grid.y <= grid.y) && (grid.y <= player->grid.y))) {
        dist = 15 + flow_dist(cave->monster_noise, grid);
        result = skill_check(source_monster(mon->midx), song_skill, dist,
                             source_none());
        square_set_door_lock(cave, grid, result);
      }
    }
  }
  dist = flow_dist(cave->monster_noise, player->grid);
  resistance = player->state.skill_use[SKILL_WILL] +
               (player->state.flags[OF_FREE_ACT] * 10) + dist;
  result = skill_check(source_monster(mon->midx), song_skill, resistance,
                       source_player());
  if (result > 0) {
    int slow = MAX(player->timed[TMD_SLOW], 2);
    player_set_timed(player, TMD_SLOW, slow, false, true);
  }
  return true;
}
STATIC_OVL bool
effect_handler_SONG_OF_PIERCING(effect_handler_context_t* context)
{
  struct monster* mon = cave_monster(cave, context->origin.which.monster);
  int song_skill = monster_sing(mon, lookup_song("Piercing"));
  int dist = flow_dist(cave->player_noise, mon->grid);
  int result, resistance;
  char name[80];
  monster_desc(name, sizeof(name), mon, MDESC_POSS);
  resistance = player->state.skill_use[SKILL_WILL] + 5 + dist;
  result = skill_check(source_monster(mon->midx), song_skill, resistance,
                       source_player());
  if (result > 0) {
    msg("You feel your mind laid bare before %s will.", name);
    set_alertness(mon, MIN(result, ALERTNESS_VERY_ALERT));
  } else if (result > -5) {
    msg("You feel the force of %s will searching for the intruder.", name);
  }
  return true;
}
STATIC_OVL bool
effect_handler_SONG_OF_OATHS(effect_handler_context_t* context)
{
  struct monster* mon = cave_monster(cave, context->origin.which.monster);
  int song_skill = monster_sing(mon, lookup_song("Oaths"));
  int result, resistance = 15;
  cave->monster_noise.centre = mon->grid;
  update_flow(cave, &cave->monster_noise, NULL);
  result = skill_check(source_monster(mon->midx), song_skill, resistance,
                       source_player());
  if (result > 0) {
    int range = MAX(15 - result, 3);
    struct loc grid;
    while (true) {
      struct monster* new;
      struct monster_group_info info = {0, 0};
      cave_find(cave, &grid, square_isarrivable);
      if (flow_dist(cave->monster_noise, grid) > range) continue;
      place_new_monster_one(cave, grid, lookup_monster("Oathwraith"), true,
                            false, info, ORIGIN_DROP_SUMMON);
      new = square_monster(cave, grid);
      if (monster_is_visible(new)) {
        msg("An Oathwraith appears.");
      }
      mflag_on(new->mflag, MFLAG_SUMMONED);
      set_alertness(new, ALERTNESS_QUITE_ALERT);
      break;
    }
  }
  return true;
}
STATIC_OVL bool
effect_handler_AGGRAVATE(effect_handler_context_t* context)
{
  int i;
  for (i = 1; i < cave_monster_max(cave); i++) {
    struct monster* mon = cave_monster(cave, i);
    struct monster_race* race = mon ? mon->race : NULL;
    if (!race) continue;
    if ((mon->alertness >= ALERTNESS_ALERT) &&
        (flow_dist(cave->player_noise, mon->grid) <= 10)) {
      mflag_on(mon->mflag, MFLAG_AGGRESSIVE);
      if (monster_is_visible(mon)) context->ident = true;
      if (rf_has(race->flags, RF_SMART) &&
          (rf_has(race->flags, RF_FRIENDS) || rf_has(race->flags, RF_FRIEND) ||
           rf_has(race->flags, RF_UNIQUE_FRIEND) ||
           rf_has(race->flags, RF_ESCORT) || rf_has(race->flags, RF_ESCORTS) ||
           rsf_has(race->spell_flags, RSF_SHRIEK))) {
        tell_allies(mon, MFLAG_AGGRESSIVE);
        context->ident = true;
      }
    }
  }
  return true;
}
STATIC_OVL bool
effect_handler_NOISE(effect_handler_context_t* context)
{
  int amount = effect_calculate_value(context);
  bool player_centred = context->subtype ? true : false;
  if (context->origin.what == SRC_MONSTER) {
    struct monster* mon = cave_monster(cave, context->origin.which.monster);
    cave->monster_noise.centre = mon->grid;
    update_flow(cave, &cave->monster_noise, NULL);
    if (context->radius) mon->noise += context->radius;
  }
  monsters_hear(player_centred, false, amount);
  return true;
}
STATIC_OVL bool
effect_handler_CREATE_TRAPS(effect_handler_context_t* context)
{
  int amount = effect_calculate_value(context);
  while (amount--) {
    struct loc grid;
    cave_find(cave, &grid, square_isunseen);
    square_add_trap(cave, grid);
  }
  return true;
}
STATIC_OVL void
free_effect(struct effect* source)
{
  struct effect *e = source, *e_next;
  while (e) {
    e_next = e->next;
    dice_free(e->dice);
    if (e->msg) {
      string_free(e->msg);
    }
    mem_free(e);
    e = e_next;
  }
}
STATIC_OVL bool
effect_valid(const struct effect* effect)
{
  if (!effect) return false;
  return effect->index > EF_NONE && effect->index < EF_MAX;
}
STATIC_OVL bool
effect_aim(const struct effect* effect)
{
  const struct effect* e = effect;
  if (!effect_valid(effect)) return false;
  while (e) {
    if (effects[e->index].aim) return true;
    e = e->next;
  }
  return false;
}
STATIC_OVL const char*
effect_info(const struct effect* effect)
{
  if (!effect_valid(effect)) return NULL;
  return effects[effect->index].info;
}
STATIC_OVL const char*
effect_desc(const struct effect* effect)
{
  if (!effect_valid(effect)) return NULL;
  return effects[effect->index].desc;
}
STATIC_OVL effect_index
effect_lookup(const char* name)
{
  size_t i;
  for (i = 0; i < N_ELEMENTS(effect_names); i++) {
    const char* effect_name = effect_names[i];
    if (effect_name != NULL && streq(name, effect_name)) return i;
  }
  return EF_MAX;
}
STATIC_OVL int
effect_subtype(int index, const char* type)
{
  char* pe;
  long lv;
  lv = strtol(type, &pe, 10);
  if (pe != type) {
    return (contains_only_spaces(pe) && lv < INT_MAX && lv > INT_MIN) ? (int)lv
                                                                      : -1;
  }
  switch (index) {
    case EF_PROJECT_LOS:
    case EF_PROJECT_LOS_GRIDS:
    case EF_LIGHT_AREA:
    case EF_EXPLOSION:
    case EF_SPOT:
    case EF_SPHERE:
    case EF_BREATH:
    case EF_BOLT:
    case EF_BEAM:
    case EF_TERRAIN_BEAM:
      return proj_name_to_idx(type);
    case EF_CURE:
    case EF_TIMED_SET:
    case EF_TIMED_INC:
    case EF_TIMED_INC_CHECK:
    case EF_TIMED_INC_NO_RES:
      return timed_name_to_idx(type);
    case EF_NOURISH:
      if (streq(type, "INC_BY")) {
        return 0;
      } else if (streq(type, "DEC_BY")) {
        return 1;
      }
      break;
    case EF_SUMMON:
      return summon_name_to_idx(type);
    case EF_RESTORE_STAT:
    case EF_DRAIN_STAT:
    case EF_DART:
      return stat_name_to_idx(type);
    case EF_GLYPH:
      if (streq(type, "WARDING")) {
        return GLYPH_WARDING;
      }
      break;
    case EF_TELEPORT_TO:
      if (streq(type, "SELF")) {
        return 1;
      }
      break;
    case EF_PIT:
      if (streq(type, "SPIKED")) {
        return 1;
      } else if (streq(type, "NORMAL")) {
        return 0;
      }
      break;
    case EF_NOISE:
      if (streq(type, "PLAYER")) {
        return 1;
      } else if (streq(type, "MONSTER")) {
        return 0;
      }
      break;
    default:
      if (streq(type, "NONE")) {
        return 0;
      }
      break;
  }
  return -1;
}
STATIC_OVL int32_t
effect_value_base_zero(void)
{
  return 0;
}
STATIC_OVL int32_t
effect_value_base_spell_power(void)
{
  int power = 0;
  if (ref_race)
    power = ref_race->spell_power;
  else if (cave->mon_current > 0)
    power = cave_monster(cave, cave->mon_current)->race->spell_power;
  return power;
}
STATIC_OVL int32_t
effect_value_base_dungeon_level(void)
{
  return cave->depth;
}
STATIC_OVL int32_t
effect_value_base_max_sight(void)
{
  return z_info->max_sight;
}
STATIC_OVL int32_t
effect_value_base_player_hp(void)
{
  return player->chp;
}
STATIC_OVL int32_t
effect_value_base_player_max_hp(void)
{
  return player->mhp;
}
STATIC_OVL int32_t
effect_value_base_player_will(void)
{
  int will = player->state.skill_use[SKILL_WILL];
  if (player_active_ability(player, "Channeling")) {
    will += 5;
  }
  return will;
}
STATIC_OVL int32_t
effect_value_base_player_cut(void)
{
  return player->timed[TMD_CUT];
}
STATIC_OVL int32_t
effect_value_base_player_pois(void)
{
  return player->timed[TMD_POISONED];
}
STATIC_OVL expression_base_value_f
effect_value_base_by_name(const char* name)
{
  static const struct value_base_s {
    const char* name;
    expression_base_value_f function;
  } value_bases[] = {
      {"ZERO", effect_value_base_zero},
      {"SPELL_POWER", effect_value_base_spell_power},
      {"DUNGEON_LEVEL", effect_value_base_dungeon_level},
      {"MAX_SIGHT", effect_value_base_max_sight},
      {"PLAYER_HP", effect_value_base_player_hp},
      {"PLAYER_MAX_HP", effect_value_base_player_max_hp},
      {"PLAYER_WILL", effect_value_base_player_will},
      {"PLAYER_CUT", effect_value_base_player_cut},
      {"PLAYER_POIS", effect_value_base_player_pois},
      {NULL, NULL},
  };
  const struct value_base_s* current = value_bases;
  while (current->name != NULL && current->function != NULL) {
    if (my_stricmp(name, current->name) == 0) return current->function;
    current++;
  }
  return NULL;
}
STATIC_OVL bool
effect_do(struct effect* effect, struct source origin, struct object* obj,
          bool* ident, bool aware, int dir, struct command* cmd)
{
  bool completed = false;
  bool first = true;
  effect_handler_f handler;
  random_value value = {0, 0, 0, 0};
  do {
    int leftover = 1;
    if (!effect_valid(effect)) {
      msg("Bad effect passed to effect_do(). Please report this bug.");
      return false;
    }
    if (effect->dice != NULL) (void)dice_roll(effect->dice, &value);
    handler = effects[effect->index].handler;
    if (handler != NULL) {
      effect_handler_context_t context = {effect->index,
                                          origin,
                                          obj,
                                          aware,
                                          dir,
                                          value,
                                          effect->subtype,
                                          effect->radius,
                                          effect->other,
                                          effect->msg,
                                          *ident,
                                          cmd};
      completed = handler(&context) || completed;
      if ((effect->index != EF_NOURISH) || (!effect->next && first)) {
        *ident = context.ident;
      }
      first = false;
    }
    while (leftover-- && effect) effect = effect->next;
  } while (effect);
  return completed;
}
STATIC_OVL void
effect_simple(int index, struct source origin, const char* dice_string,
              int subtype, int radius, int other, bool* ident)
{
  struct effect effect;
  int dir = DIR_TARGET;
  bool dummy_ident = false;
  memset(&effect, 0, sizeof(effect));
  effect.index = index;
  effect.dice = dice_new();
  dice_parse_string(effect.dice, dice_string);
  effect.subtype = subtype;
  effect.radius = radius;
  effect.other = other;
  if (effect_aim(&effect)) get_aim_dir(&dir, z_info->max_range);
  if (!ident) {
    ident = &dummy_ident;
  }
  effect_do(&effect, origin, NULL, ident, true, dir, NULL);
  dice_free(effect.dice);
}
STATIC_OVL void
format_dice_string(const random_value* v, int multiplier, size_t len,
                   char* dice_string)
{
  if (v->dice && v->base) {
    if (multiplier == 1) {
      strnfmt(dice_string, len, "%d+%dd%d", v->base, v->dice, v->sides);
    } else {
      strnfmt(dice_string, len, "%d+%d*(%dd%d)", multiplier * v->base,
              multiplier, v->dice, v->sides);
    }
  } else if (v->dice) {
    if (multiplier == 1) {
      strnfmt(dice_string, len, "%dd%d", v->dice, v->sides);
    } else {
      strnfmt(dice_string, len, "%d*(%dd%d)", multiplier, v->dice, v->sides);
    }
  } else {
    strnfmt(dice_string, len, "%d", multiplier * v->base);
  }
}
STATIC_OVL void
append_damage(char* buffer, size_t buffer_size, random_value value)
{
  if (randcalc_varies(value)) {
    int dam = (100 * randcalc(value, 0, AVERAGE)) / 10;
    my_strcat(buffer,
              format(" for an average of %d.%d damage", dam / 10, dam % 10),
              buffer_size);
  }
}
STATIC_OVL void
copy_to_textblock_with_coloring(textblock* tb, const char* s)
{
  while (*s) {
    if (isdigit((unsigned char)*s)) {
      textblock_append_c(tb, COLOUR_L_GREEN, "%c", *s);
    } else {
      textblock_append(tb, "%c", *s);
    }
    ++s;
  }
}
STATIC_OVL textblock*
effect_describe(const struct effect* e, const char* prefix)
{
  textblock* tb = NULL;
  char desc[250];
  random_value value = {0, 0, 0, 0};
  bool value_set = false;
  while (e) {
    const char* edesc = effect_desc(e);
    char dice_string[20];
    if ((e->dice != NULL) && !value_set) {
      (void)dice_roll(e->dice, &value);
    }
    if (!edesc) {
      e = e->next;
      continue;
    }
    format_dice_string(&value, 1, sizeof(dice_string), dice_string);
    switch (base_descs[e->index].efinfo_flag) {
      case EFINFO_DICE:
        strnfmt(desc, sizeof(desc), edesc, dice_string);
        break;
      case EFINFO_HEAL: {
        char min_string[50];
        if (value.m_bonus) {
          strnfmt(min_string, sizeof(min_string),
                  " (or %d%%, whichever is greater)", value.m_bonus);
        } else {
          strnfmt(min_string, sizeof(min_string), "%s", "");
        }
        strnfmt(desc, sizeof(desc), edesc, dice_string, min_string);
      } break;
      case EFINFO_FOOD: {
        const char* fed = e->subtype
                              ? (e->subtype == 1 ? "uses enough food value"
                                                 : "leaves you nourished")
                              : "feeds you";
        char turn_dice_string[20];
        format_dice_string(&value, 10, sizeof(turn_dice_string),
                           turn_dice_string);
        strnfmt(desc, sizeof(desc), edesc, fed, turn_dice_string, dice_string);
      } break;
      case EFINFO_CURE:
        strnfmt(desc, sizeof(desc), edesc, timed_effects[e->subtype].desc);
        break;
      case EFINFO_TIMED:
        strnfmt(desc, sizeof(desc), edesc, timed_effects[e->subtype].desc,
                dice_string);
        break;
      case EFINFO_TERROR:
        strnfmt(desc, sizeof(desc), edesc, dice_string);
        break;
      case EFINFO_STAT: {
        int stat = e->subtype;
        strnfmt(desc, sizeof(desc), edesc,
                lookup_obj_property(OBJ_PROPERTY_STAT, stat)->name);
      } break;
      case EFINFO_PROJ:
        strnfmt(desc, sizeof(desc), edesc, projections[e->subtype].desc);
        break;
      case EFINFO_SUMM:
        strnfmt(desc, sizeof(desc), edesc, summon_desc(e->subtype));
        break;
      case EFINFO_QUAKE:
        strnfmt(desc, sizeof(desc), edesc, e->radius);
        break;
      case EFINFO_SPOT: {
        int i_radius = e->other ? e->other : e->radius;
        strnfmt(desc, sizeof(desc), edesc, projections[e->subtype].player_desc,
                e->radius, i_radius, dice_string);
        append_damage(desc, sizeof(desc), value);
      } break;
      case EFINFO_BREATH:
        strnfmt(desc, sizeof(desc), edesc, projections[e->subtype].player_desc,
                e->other, dice_string);
        append_damage(desc, sizeof(desc), value);
        break;
      case EFINFO_BOLT:
        strnfmt(desc, sizeof(desc), edesc, projections[e->subtype].desc,
                dice_string);
        append_damage(desc, sizeof(desc), value);
        break;
      case EFINFO_NONE:
        strnfmt(desc, sizeof(desc), "%s", edesc);
        break;
      default:
        strnfmt(desc, sizeof(desc), "%s", "");
        msg("Bad effect description passed to effect_info().  Please report "
            "this bug.");
        break;
    }
    e = e->next;
    if (desc[0] != '\0') {
      if (tb) {
        if (e) {
          textblock_append(tb, ", ");
        } else {
          textblock_append(tb, " and ");
        }
      } else {
        tb = textblock_new();
        if (prefix) {
          textblock_append(tb, "%s", prefix);
        }
      }
      copy_to_textblock_with_coloring(tb, desc);
    }
  }
  return tb;
}
STATIC_OVL size_t
effect_get_menu_name(char* buf, size_t max, const struct effect* e)
{
  const char* fmt;
  size_t len;
  if (!e || e->index <= EF_NONE || e->index >= EF_MAX) {
    return 0;
  }
  fmt = base_descs[e->index].menu_name;
  switch (base_descs[e->index].efinfo_flag) {
    case EFINFO_DICE:
    case EFINFO_HEAL:
    case EFINFO_QUAKE:
    case EFINFO_TERROR:
    case EFINFO_NONE:
      len = strnfmt(buf, max, "%s", fmt);
      break;
    case EFINFO_FOOD: {
      const char* actstr;
      const char* actarg;
      int avg;
      switch (e->subtype) {
        case 0:
          actstr = "feed";
          actarg = "yourself";
          break;
        case 1:
          actstr = "increase";
          actarg = "hunger";
          break;
        case 2:
          avg = (e->dice) ? dice_evaluate(e->dice, 1, AVERAGE, NULL) : 0;
          actstr = "become";
          if (avg > PY_FOOD_FULL) {
            actarg = "bloated";
          } else {
            actarg = "hungry";
          }
          break;
        case 3:
          avg = (e->dice) ? dice_evaluate(e->dice, 1, AVERAGE, NULL) : 0;
          actstr = "leave";
          if (avg > PY_FOOD_FULL) {
            actarg = "bloated";
          } else {
            actarg = "hungry";
          }
          break;
        default:
          actstr = NULL;
          actarg = NULL;
          break;
      }
      if (actstr && actarg) {
        len = strnfmt(buf, max, fmt, actstr, actarg);
      } else {
        len = strnfmt(buf, max, "%s", "");
      }
    } break;
    case EFINFO_CURE:
    case EFINFO_TIMED:
      len = strnfmt(buf, max, fmt, timed_effects[e->subtype].desc);
      break;
    case EFINFO_STAT:
      len = strnfmt(buf, max, fmt,
                    lookup_obj_property(OBJ_PROPERTY_STAT, e->subtype)->name);
      break;
    case EFINFO_PROJ:
    case EFINFO_BOLT:
      len = strnfmt(buf, max, fmt, projections[e->subtype].desc);
      break;
    case EFINFO_SUMM:
      len = strnfmt(buf, max, fmt, summon_desc(e->subtype));
      break;
    case EFINFO_SPOT:
    case EFINFO_BREATH:
      len = strnfmt(buf, max, fmt, projections[e->subtype].player_desc);
      break;
    default:
      len = strnfmt(buf, max, "%s", "");
      msg("Bad effect description passed to effect_get_menu_name().  Please "
          "report this bug.");
      break;
  }
  return len;
}
STATIC_OVL struct effect*
effect_next(struct effect* effect)
{
  return effect->next;
}
STATIC_OVL bool
effect_damages(const struct effect* effect)
{
  return effect_info(effect) != NULL && streq(effect_info(effect), "dam");
}
STATIC_OVL int
effect_avg_damage(const struct effect* effect)
{
  return dice_evaluate(effect->dice, 0, AVERAGE, NULL);
}
STATIC_OVL const char*
effect_projection(const struct effect* effect)
{
  if (projections[effect->subtype].player_desc != NULL) {
    switch (base_descs[effect->index].efinfo_flag) {
      case EFINFO_PROJ:
      case EFINFO_BOLT:
      case EFINFO_BREATH:
      case EFINFO_SPOT:
        return projections[effect->subtype].player_desc;
    }
  }
  return "";
}
STATIC_OVL void
game_event_dispatch(game_event_type type, game_event_data* data)
{
  struct event_handler_entry* this = event_handlers[type];
  while (this) {
    this->fn(type, data, this->user);
    this = this->next;
  }
}
STATIC_OVL void
event_add_handler(game_event_type type, game_event_handler* fn, void* user)
{
  struct event_handler_entry* new;
  assert(fn != NULL);
  new = mem_alloc(sizeof *new);
  new->fn = fn;
  new->user = user;
  new->next = event_handlers[type];
  event_handlers[type] = new;
}
STATIC_OVL void
event_remove_handler(game_event_type type, game_event_handler* fn, void* user)
{
  struct event_handler_entry* prev = NULL;
  struct event_handler_entry* this = event_handlers[type];
  while (this) {
    if (this->fn == fn && this->user == user) {
      if (!prev) {
        event_handlers[type] = this->next;
      } else {
        prev->next = this->next;
      }
      mem_free(this);
      return;
    }
    prev = this;
    this = this->next;
  }
}
STATIC_OVL void
event_remove_handler_type(game_event_type type)
{
  struct event_handler_entry* handler = event_handlers[type];
  while (handler) {
    struct event_handler_entry* next = handler->next;
    mem_free(handler);
    handler = next;
  }
  event_handlers[type] = NULL;
}
STATIC_OVL void
event_remove_all_handlers(void)
{
  int type;
  struct event_handler_entry *handler, *next;
  for (type = 0; type < N_GAME_EVENTS; type++) {
    handler = event_handlers[type];
    while (handler) {
      next = handler->next;
      mem_free(handler);
      handler = next;
    }
    event_handlers[type] = NULL;
  }
}
STATIC_OVL void
event_add_handler_set(game_event_type* type, size_t n_types,
                      game_event_handler* fn, void* user)
{
  size_t i;
  for (i = 0; i < n_types; i++) event_add_handler(type[i], fn, user);
}
STATIC_OVL void
event_remove_handler_set(game_event_type* type, size_t n_types,
                         game_event_handler* fn, void* user)
{
  size_t i;
  for (i = 0; i < n_types; i++) event_remove_handler(type[i], fn, user);
}
STATIC_OVL void
event_signal(game_event_type type)
{
  game_event_dispatch(type, NULL);
}
STATIC_OVL void
event_signal_flag(game_event_type type, bool flag)
{
  game_event_data data;
  data.flag = flag;
  game_event_dispatch(type, &data);
}
STATIC_OVL void
event_signal_point(game_event_type type, int x, int y)
{
  game_event_data data;
  data.point.x = x;
  data.point.y = y;
  game_event_dispatch(type, &data);
}
STATIC_OVL void
event_signal_string(game_event_type type, const char* s)
{
  game_event_data data;
  data.string = s;
  game_event_dispatch(type, &data);
}
STATIC_OVL void
event_signal_message(game_event_type type, int t, const char* s)
{
  game_event_data data;
  memset(&data, 0, sizeof data);
  data.message.type = t;
  data.message.msg = s;
  game_event_dispatch(type, &data);
}
STATIC_OVL void
event_signal_birthpoints(const int* points, const int* inc_points,
                         int remaining)
{
  game_event_data data;
  data.points.points = points;
  data.points.inc_points = inc_points;
  data.points.remaining = remaining;
  game_event_dispatch(EVENT_STATPOINTS, &data);
}
STATIC_OVL void
event_signal_skillpoints(const int* exp, const int* inc_exp, int remaining)
{
  game_event_data data;
  data.exp.exp = exp;
  data.exp.inc_exp = inc_exp;
  data.exp.remaining = remaining;
  game_event_dispatch(EVENT_SKILLPOINTS, &data);
}
STATIC_OVL void
event_signal_blast(game_event_type type, int proj_type, int num_grids,
                   int* distance_to_grid, bool drawing, bool* player_sees_grid,
                   struct loc* blast_grid, struct loc centre)
{
  game_event_data data;
  data.explosion.proj_type = proj_type;
  data.explosion.num_grids = num_grids;
  data.explosion.distance_to_grid = distance_to_grid;
  data.explosion.drawing = drawing;
  data.explosion.player_sees_grid = player_sees_grid;
  data.explosion.blast_grid = blast_grid;
  data.explosion.centre = centre;
  game_event_dispatch(type, &data);
}
STATIC_OVL void
event_signal_bolt(game_event_type type, int proj_type, bool drawing, bool seen,
                  bool beam, int oy, int ox, int y, int x)
{
  game_event_data data;
  data.bolt.proj_type = proj_type;
  data.bolt.drawing = drawing;
  data.bolt.seen = seen;
  data.bolt.beam = beam;
  data.bolt.oy = oy;
  data.bolt.ox = ox;
  data.bolt.y = y;
  data.bolt.x = x;
  game_event_dispatch(type, &data);
}
STATIC_OVL void
event_signal_missile(game_event_type type, struct object* obj, bool seen, int y,
                     int x)
{
  game_event_data data;
  data.missile.obj = obj;
  data.missile.seen = seen;
  data.missile.y = y;
  data.missile.x = x;
  game_event_dispatch(type, &data);
}
STATIC_OVL void
event_signal_hit(game_event_type type, int dam, int dam_type, bool fatal,
                 struct loc grid)
{
  game_event_data data;
  data.hit.dam = dam;
  data.hit.dam_type = dam_type;
  data.hit.fatal = fatal;
  data.hit.grid = grid;
  game_event_dispatch(type, &data);
}
STATIC_OVL void
event_signal_size(game_event_type type, int h, int w)
{
  game_event_data data;
  data.size.h = h;
  data.size.w = w;
  game_event_dispatch(type, &data);
}
STATIC_OVL void
event_signal_tunnel(game_event_type type, tunnel_type t,
                    tunnel_direction_type dir, int vlength, int hlength)
{
  game_event_data data;
  data.tunnel.t = t;
  data.tunnel.dir = dir;
  data.tunnel.vlength = vlength;
  data.tunnel.hlength = hlength;
  game_event_dispatch(type, &data);
}
STATIC_OVL void
event_signal_combat_attack(game_event_type type, struct source attacker,
                           struct source defender, bool vis, int att,
                           int att_roll, int evn, int evn_roll, bool melee)
{
  game_event_data data;
  data.combat_attack.attacker = attacker;
  data.combat_attack.defender = defender;
  data.combat_attack.vis = vis;
  data.combat_attack.att = att;
  data.combat_attack.att_roll = att_roll;
  data.combat_attack.evn = evn;
  data.combat_attack.evn_roll = evn_roll;
  data.combat_attack.melee = melee;
  game_event_dispatch(type, &data);
}
STATIC_OVL void
event_signal_combat_damage(game_event_type type, int dd, int ds, int dam,
                           int pd, int ps, int prot, int prt_percent,
                           int dam_type, bool melee)
{
  game_event_data data;
  data.combat_damage.dd = dd;
  data.combat_damage.ds = ds;
  data.combat_damage.dam = dam;
  data.combat_damage.pd = pd;
  data.combat_damage.ps = ps;
  data.combat_damage.prot = prot;
  data.combat_damage.prt_percent = prt_percent;
  data.combat_damage.dam_type = dam_type;
  data.combat_damage.melee = melee;
  game_event_dispatch(type, &data);
}
STATIC_OVL void
event_signal_poem(game_event_type type, const char* name, int row, int col)
{
  game_event_data data;
  data.verse.filename = name;
  data.verse.text = NULL;
  data.verse.row = row;
  data.verse.col = col;
  game_event_dispatch(type, &data);
}
STATIC_OVL void
event_signal_poem_textblock(game_event_type type, struct textblock* tb, int row,
                            int col)
{
  game_event_data data;
  data.verse.filename = NULL;
  data.verse.text = tb;
  data.verse.row = row;
  data.verse.col = col;
  game_event_dispatch(type, &data);
}
bool (*get_string_hook)(const char* prompt, char* buf, size_t len);
int (*get_quantity_hook)(const char* prompt, int max);
bool (*get_check_hook)(const char* prompt);
bool (*get_com_hook)(const char* prompt, char* command);
bool (*get_rep_dir_hook)(int* dir, bool allow_none);
bool (*get_aim_dir_hook)(int* dir, int range);
bool (*get_item_hook)(struct object** choice, const char* pmt, const char* str,
                      cmd_code cmd, item_tester tester, int mode);
int (*get_effect_from_list_hook)(const char* prompt, struct effect* effect,
                                 int count, bool allow_random);
bool (*confirm_debug_hook)(void);
void (*get_panel_hook)(int* min_y, int* min_x, int* max_y, int* max_x);
bool (*panel_contains_hook)(unsigned int y, unsigned int x);
bool (*map_is_visible_hook)(void);
struct object* (*smith_object_hook)(struct smithing_cost* cost);
void (*view_abilities_hook)(struct player_ability* ability_list,
                            int num_abilities);
void (*change_song_hook)(void);
bool
get_string(const char* prompt, char* buf, size_t len)
{
  if (get_string_hook)
    return get_string_hook(prompt, buf, len);
  else
    return false;
}
STATIC_OVL int
get_quantity(const char* prompt, int max)
{
  if (get_quantity_hook)
    return get_quantity_hook(prompt, max);
  else
    return 0;
}
STATIC_OVL bool
get_check(const char* prompt)
{
  if (get_check_hook)
    return get_check_hook(prompt);
  else
    return false;
}
STATIC_OVL bool
get_com(const char* prompt, char* command)
{
  if (get_com_hook)
    return get_com_hook(prompt, command);
  else
    return false;
}
STATIC_OVL bool
get_rep_dir(int* dir, bool allow_none)
{
  if (get_rep_dir_hook)
    return get_rep_dir_hook(dir, allow_none);
  else
    return false;
}
STATIC_OVL bool
get_aim_dir(int* dir, int range)
{
  if (get_aim_dir_hook)
    return get_aim_dir_hook(dir, range);
  else
    return false;
}
STATIC_OVL bool
get_item(struct object** choice, const char* pmt, const char* str, cmd_code cmd,
         item_tester tester, int mode)
{
  if (get_item_hook)
    return get_item_hook(choice, pmt, str, cmd, tester, mode);
  else
    return false;
}
STATIC_OVL int
get_effect_from_list(const char* prompt, struct effect* effect, int count,
                     bool allow_random)
{
  if (get_effect_from_list_hook) {
    return get_effect_from_list_hook(prompt, effect, count, allow_random);
  }
  return (allow_random) ? -2 : -1;
}
STATIC_OVL bool
confirm_debug(void)
{
  if (confirm_debug_hook) {
    return confirm_debug_hook();
  }
  msg("You are about to use the dangerous, unsupported, debug commands!");
  msg("Your machine may crash, and your savefile may become corrupted!");
  event_signal(EVENT_MESSAGE_FLUSH);
  return get_check("Are you sure you want to use the debug commands? ");
}
STATIC_OVL void
get_panel(int* min_y, int* min_x, int* max_y, int* max_x)
{
  if (get_panel_hook) get_panel_hook(min_y, min_x, max_y, max_x);
}
STATIC_OVL bool
panel_contains(unsigned int y, unsigned int x)
{
  if (panel_contains_hook)
    return panel_contains_hook(y, x);
  else
    return true;
}
STATIC_OVL bool
map_is_visible(void)
{
  if (map_is_visible_hook)
    return map_is_visible_hook();
  else
    return true;
}
STATIC_OVL struct object*
smith_object(struct smithing_cost* cost)
{
  if (smith_object_hook) return smith_object_hook(cost);
  return NULL;
}
STATIC_OVL void
view_ability_menu(struct player_ability* ability_list, int num_abilities)
{
  if (view_abilities_hook) view_abilities_hook(ability_list, num_abilities);
}
STATIC_OVL void
change_song(void)
{
  if (change_song_hook) change_song_hook();
}
STATIC_OVL struct level*
level_by_name(const char* name)
{
  struct level* lev = world;
  while (lev) {
    if (streq(lev->name, name)) {
      break;
    }
    lev = lev->next;
  }
  return lev;
}
STATIC_OVL struct level*
level_by_depth(int depth)
{
  struct level* lev = world;
  while (lev) {
    if (lev->depth == depth) {
      break;
    }
    lev = lev->next;
  }
  return lev;
}
STATIC_OVL bool
is_daytime(void)
{
  if ((turn % (10L * z_info->day_length)) < ((10L * z_info->day_length) / 2))
    return true;
  return false;
}
STATIC_OVL int
turn_energy(int speed)
{
  return extract_energy[speed] * z_info->move_energy / 100;
}
STATIC_OVL int
regen_amount(int turn_number, int max, int period)
{
  int regen_so_far, regen_next;
  if (turn_number == 0) {
    return 0;
  }
  if ((turn_number % period) > 0) {
    regen_so_far = (max * ((turn_number - 1) % period)) / period;
    regen_next = (max * (turn_number % period)) / period;
  } else {
    regen_so_far = (max * ((turn_number - 1) % period)) / period;
    regen_next = (max * period) / period;
  }
  return regen_next - regen_so_far;
}
STATIC_OVL int
health_level(int current, int max)
{
  int level;
  if (current == max) {
    level = HEALTH_UNHURT;
  } else {
    switch ((4 * current + max - 1) / max) {
      case 4:
        level = HEALTH_SOMEWHAT_WOUNDED;
        break;
      case 3:
        level = HEALTH_WOUNDED;
        break;
      case 2:
        level = HEALTH_BADLY_WOUNDED;
        break;
      case 1:
        level = HEALTH_ALMOST_DEAD;
        break;
      default:
        level = HEALTH_DEAD;
        break;
    }
  }
  return (level);
}
STATIC_OVL void
play_ambient_sound(void)
{
  if (player->depth == 0) {
    if (is_daytime())
      sound(MSG_AMBIENT_DAY);
    else
      sound(MSG_AMBIENT_NITE);
  } else if (player->depth <= 20) {
    sound(MSG_AMBIENT_DNG1);
  } else if (player->depth <= 40) {
    sound(MSG_AMBIENT_DNG2);
  } else if (player->depth <= 60) {
    sound(MSG_AMBIENT_DNG3);
  } else if (player->depth <= 80) {
    sound(MSG_AMBIENT_DNG4);
  } else {
    sound(MSG_AMBIENT_DNG5);
  }
}
STATIC_OVL void
decrease_timeouts(void)
{
  int i;
  for (i = 0; i < TMD_MAX; i++) {
    int decr = player_timed_decrement_amount(player, i);
    if (!player->timed[i] || (i == TMD_FOOD)) continue;
    player_dec_timed(player, i, decr, false, true);
  }
}
STATIC_OVL int
square_flow_cost(struct chunk* c, struct loc grid, struct monster* mon)
{
  int cost = 0;
  if (mon) {
    bool bash = false;
    int chance = monster_entry_chance(c, mon, grid, &bash);
    if (chance > 0) {
      cost += (100 / chance) - 1;
      if (square_iscloseddoor(c, grid)) {
        if (!(bash || rf_has(mon->race->flags, RF_PASS_DOOR) ||
              rf_has(mon->race->flags, RF_PASS_WALL))) {
          cost += 1;
        }
      } else if (square_isdiggable(c, grid) &&
                 rf_has(mon->race->flags, RF_TUNNEL_WALL)) {
        if (square_isrubble(c, grid)) {
          cost += 1;
        } else {
          cost += 2;
        }
      } else if (square_iswall(c, grid) &&
                 rf_has(mon->race->flags, RF_KILL_WALL)) {
        cost += 1;
      }
    } else {
      return -1;
    }
  } else {
    if (square_iswall(c, grid) && !square_isdoor(c, grid)) {
      return -1;
    }
    if (square_iscloseddoor(c, grid) || square_issecretdoor(c, grid)) {
      cost += 5;
    }
  }
  return cost;
}
STATIC_OVL int
grid_to_i(struct loc grid, int w)
{
  return grid.y * w + grid.x;
}
STATIC_OVL void
i_to_grid(int i, int w, struct loc* grid)
{
  grid->y = i / w;
  grid->x = i % w;
}
STATIC_OVL void
update_flow(struct chunk* c, struct flow* flow, struct monster* mon)
{
  struct loc next = flow->centre;
  int y, x, d;
  int value = 0;
  struct queue* queue = q_new(c->height * c->width);
  for (y = 1; y < c->height - 1; y++) {
    for (x = 1; x < c->width - 1; x++) {
      flow->grids[y][x] = z_info->flow_max;
    }
  }
  if (loc_eq(next, loc(0, 0))) {
    quit("Flow has no centre!");
  }
  flow->grids[next.y][next.x] = 0;
  q_push_int(queue, grid_to_i(next, c->width));
  value++;
  while ((q_len(queue) > 0) && (value < z_info->flow_max)) {
    int count = q_len(queue);
    while (count) {
      i_to_grid(q_pop_int(queue), c->width, &next);
      count--;
      if (flow->grids[next.y][next.x] > value) {
        q_push_int(queue, grid_to_i(next, c->width));
        continue;
      }
      for (d = 0; d < 8; d++) {
        struct loc grid = loc_sum(next, ddgrid_ddd[d]);
        struct monster* grid_mon;
        int cost;
        if (!square_in_bounds(c, grid)) continue;
        if (flow->grids[grid.y][grid.x] < z_info->flow_max) continue;
        cost = square_flow_cost(c, grid, mon);
        if (cost < 0) continue;
        flow->grids[grid.y][grid.x] = value + cost;
        q_push_int(queue, grid_to_i(grid, c->width));
        grid_mon = square_monster(c, grid);
        if (grid_mon) {
          grid_mon->target.grid = loc(0, 0);
        }
      }
    }
    value++;
  }
  q_free(queue);
}
STATIC_OVL int
flow_dist(struct flow flow, struct loc grid)
{
  return flow.grids[grid.y][grid.x];
}
STATIC_OVL void
update_scent(void)
{
  int y, x;
  int scent_strength[5][5] = {
      {250, 2, 2, 2, 250}, {2, 1, 1, 1, 2},     {2, 1, 0, 1, 2},
      {2, 1, 1, 1, 2},     {250, 2, 2, 2, 250},
  };
  cave->scent_age--;
  if (cave->scent_age <= 0) {
    for (y = 1; y < cave->height - 1; y++) {
      for (x = 1; x < cave->width - 1; x++) {
        if (cave->scent.grids[y][x] == 0) continue;
        if (cave->scent.grids[y][x] > SMELL_STRENGTH) {
          cave->scent.grids[y][x] = 0;
        } else {
          cave->scent.grids[y][x] += 250 - SMELL_STRENGTH;
        }
      }
    }
    cave->scent_age = 250 - SMELL_STRENGTH;
  }
  for (y = 0; y < 5; y++) {
    for (x = 0; x < 5; x++) {
      struct loc scent;
      int new_scent = scent_strength[y][x];
      scent.y = y + player->grid.y - 2;
      scent.x = x + player->grid.x - 2;
      if (!square_in_bounds(cave, scent)) continue;
      if (square_isnoscent(cave, scent)) continue;
      if (!los(cave, player->grid, loc(x, y))) continue;
      if (scent_strength[y][x] == 250) continue;
      cave->scent.grids[scent.y][scent.x] = cave->scent_age + new_scent;
    }
  }
}
STATIC_OVL int
get_scent(struct chunk* c, struct loc grid)
{
  int age;
  int scent;
  if (!square_in_bounds(c, grid)) return -1;
  scent = c->scent.grids[grid.y][grid.x];
  if (!c->scent.grids[grid.y][grid.x]) return -1;
  age = scent - c->scent_age;
  if (age > SMELL_STRENGTH) return -1;
  return age;
}
STATIC_OVL void
process_world(struct chunk* c)
{
  if (cave_monster_count(c) + 32 > z_info->level_monster_max)
    compact_monsters(c, 64);
  if (cave_monster_count(c) + 32 < cave_monster_max(c)) compact_monsters(c, 0);
  if (!(turn % ((10L * z_info->day_length) / 4))) play_ambient_sound();
  if (!player->depth) {
    if (percent_chance(10)) {
      (void)pick_and_place_monster_on_stairs(c, player, true, 0, false);
    }
  }
  if (silmarils_possessed(player) >= 2) {
    int percent =
        (c->height * c->width) / (z_info->block_hgt * z_info->block_wid);
    if (percent_chance(percent)) {
      (void)pick_and_place_monster_on_stairs(c, player, true, c->depth, false);
    }
  } else if (one_in_(z_info->alloc_monster_chance)) {
    (void)pick_and_place_monster_on_stairs(c, player, true, c->depth, false);
  }
  if (percent_chance(player->state.flags[OF_HAUNTED])) {
    (void)pick_and_place_monster_on_stairs(c, player, true, c->depth, true);
  }
  player_update_light(player);
}
STATIC_OVL void
pre_process_player(void)
{
  int i;
  player->upkeep->riposte = false;
  player->upkeep->was_entranced = false;
  calc_light(player);
  monsters_hear(true, true, player->stealth_score);
  if (player->stealth_mode == STEALTH_MODE_STOPPING) {
    player->stealth_mode = STEALTH_MODE_OFF;
    player->upkeep->update |= (PU_BONUS);
    player->upkeep->redraw |= (PR_STATE);
  }
  if (player->truce && (player->depth == z_info->dun_depth)) {
    check_truce(player);
  }
  if (player->turn == 1) {
    options_list_challenge();
  }
  for (i = MAX_ACTION - 1; i > 0; i--) {
    player->previous_action[i] = player->previous_action[i - 1];
  }
  player->previous_action[0] = ACTION_NOTHING;
  redraw_stuff(player);
  player->upkeep->update |= (PU_BONUS);
}
STATIC_OVL void
process_player_cleanup(void)
{
  int i;
  if (square_isgreatervault(cave, player->grid) && cave->vault_name) {
    char note[120];
    strnfmt(note, sizeof(note), "Entered %s", cave->vault_name);
    history_add(player, note, HIST_VAULT_ENTERED);
    if (player->depth > 0 && player->depth < 20) {
      msg("You have entered %s.", cave->vault_name);
    }
    string_free(cave->vault_name);
    cave->vault_name = NULL;
  }
  if (player->upkeep->energy_use) {
    player->energy -= player->upkeep->energy_use;
    player->total_energy += player->upkeep->energy_use;
    if (!player->upkeep->dropping) {
      if (player->timed[TMD_IMAGE]) player->upkeep->redraw |= (PR_MAP);
      for (i = 1; i < cave_monster_max(cave); i++) {
        struct monster* mon = cave_monster(cave, i);
        if (!mon->race) continue;
        if (!rf_has(mon->race->flags, RF_ATTR_MULTI)) continue;
        square_light_spot(cave, mon->grid);
      }
      for (i = 1; i < cave_monster_max(cave); i++) {
        struct monster* mon = cave_monster(cave, i);
        if (mflag_has(mon->mflag, MFLAG_MARK)) {
          if (!mflag_has(mon->mflag, MFLAG_SHOW)) {
            mflag_off(mon->mflag, MFLAG_MARK);
            update_mon(mon, cave, false);
          }
        }
      }
    }
  }
  for (i = 1; i < cave_monster_max(cave); i++) {
    struct monster* mon = cave_monster(cave, i);
    mflag_off(mon->mflag, MFLAG_SHOW);
  }
  player->upkeep->dropping = false;
  update_stuff(player);
  redraw_stuff(player);
}
STATIC_OVL void
process_player_post_energy_use_cleanup(void)
{
  if (player->is_dead || player->upkeep->generate_level) return;
  player_sing(player);
  if (player_is_resting(player)) {
    player->stealth_score += (player->stealth_mode) ? 2 : 7;
  }
  if (player->upkeep->smithing) {
    monsters_hear(true, false, -10);
  }
  cave->player_noise.centre = player->grid;
  update_flow(cave, &cave->player_noise, NULL);
  update_scent();
  if (one_in_(500)) {
    equip_learn_flag(player, OF_DANGER);
  }
  if (player->timed[TMD_POISONED]) {
    take_hit(player, (player->timed[TMD_POISONED] + 4) / 5, "poison");
    if (player->is_dead) {
      return;
    }
  }
  if (player->timed[TMD_CUT]) {
    take_hit(player, (player->timed[TMD_CUT] + 4) / 5, "a fatal wound");
    if (player->is_dead) {
      return;
    }
  }
  if (player->wrath) {
    int amount = (player->wrath / 100) * (player->wrath / 100);
    if (player_is_singing(player, lookup_song("Slaying"))) {
      player->wrath -= MAX(amount / 2, 1);
    } else {
      player->wrath -= MAX(amount, 1);
    }
    player->upkeep->update |= (PU_BONUS);
    player->upkeep->redraw |= (PR_SONG);
  }
  player_digest(player);
  if (player->is_dead) {
    return;
  }
  if (player->chp < player->mhp) {
    player_regen_hp(player);
  }
  if (player->csp < player->msp) {
    player_regen_mana(player);
  }
  decrease_timeouts();
  if (!(turn % 100)) equip_learn_after_time(player);
  if (player->staircasiness > 0) {
    int amount;
    if (player->on_the_run) {
      amount = (player->staircasiness + 99) / 100;
    } else {
      amount = (player->staircasiness + 999) / 1000;
    }
    player->staircasiness -= amount;
  }
  player->forge_drought++;
  if (player->previous_action[0] != ACTION_STAND) {
    player->focused = false;
  }
  if (!player->attacked && (player->previous_action[0] != ACTION_STAND)) {
    player->consecutive_attacks = 0;
    player->last_attack_m_idx = 0;
  }
  if (player_radiates(player)) {
    sqinfo_on(square(cave, player->grid)->info, SQUARE_GLOW);
  }
  player->turn++;
}
STATIC_OVL void
process_player(void)
{
  player_resting_complete_special(player);
  event_signal(EVENT_CHECK_INTERRUPT);
  do {
    notice_stuff(player);
    handle_stuff(player);
    event_signal(EVENT_REFRESH);
    pack_overflow(NULL);
    player->upkeep->energy_use = 0;
    event_signal(EVENT_COMBAT_RESET);
    player->stealth_score = player->state.skill_use[SKILL_STEALTH];
    if (player->timed[TMD_ENTRANCED] ||
        player_timed_grade_eq(player, TMD_STUN, "Knocked Out")) {
      cmdq_push(CMD_SLEEP);
    } else if (player->upkeep->knocked_back) {
      cmdq_push(CMD_SKIP);
    }
    if (cmd_get_nrepeats() > 0) {
      event_signal(EVENT_COMMAND_REPEAT);
    } else {
      if (player->upkeep->monster_race) player->upkeep->redraw |= (PR_MONSTER);
      event_signal(EVENT_REFRESH);
    }
    if (!cmdq_pop(CTX_GAME)) break;
    if (!player->upkeep->playing) break;
    process_player_cleanup();
  } while (!player->upkeep->energy_use && !player->is_dead &&
           !player->upkeep->generate_level);
  if (player->upkeep->energy_use) process_player_post_energy_use_cleanup();
  notice_stuff(player);
}
STATIC_OVL void
on_new_level(void)
{
  int i;
  cave->player_noise.centre = player->grid;
  update_flow(cave, &cave->player_noise, NULL);
  update_scent();
  disturb(player, false);
  if (player->turn == 0) {
    event_signal_poem(EVENT_POEM, player->sex->poetry_name, 5, 15);
    player->forge_count = 0;
    player->forge_drought = 5000;
  }
  event_signal(EVENT_MESSAGE_FLUSH);
  event_signal(EVENT_NEW_LEVEL_DISPLAY);
  if (player->max_depth < player->depth) {
    for (i = player->max_depth + 1; i <= player->depth; i++) {
      if (i > 1) {
        int new_exp = i * 50;
        player_exp_gain(player, new_exp);
        player->descent_exp += new_exp;
      }
    }
    player->max_depth = player->depth;
  }
  player->upkeep->update |= (PU_BONUS | PU_HP | PU_SPELLS | PU_INVEN);
  player->upkeep->notice |= (PN_COMBINE);
  notice_stuff(player);
  update_stuff(player);
  redraw_stuff(player);
  event_signal(EVENT_REFRESH);
  if ((player->depth == z_info->dun_depth) && player->truce) {
    msg("There is a strange tension in the air.");
    if (player->state.skill_use[SKILL_PERCEPTION] >= 15) {
      msg("You feel that Morgoth's servants are reluctant to attack before he "
          "delivers judgment.");
    }
  }
}
STATIC_OVL void
on_leave_level(void)
{
  cmd_disable_repeat_floor_item();
  notice_stuff(player);
  update_stuff(player);
  redraw_stuff(player);
  event_signal(EVENT_MESSAGE_FLUSH);
}
STATIC_OVL void
run_game_loop(void)
{
  while (player->upkeep->playing) {
    process_player();
    if (player->upkeep->energy_use) {
      break;
    } else {
      return;
    }
  }
  while (true) {
    notice_stuff(player);
    handle_stuff(player);
    event_signal(EVENT_REFRESH);
    if (player->is_dead || !player->upkeep->playing) {
      return;
    } else if (!player->upkeep->generate_level) {
      process_monsters(0);
      reset_monsters();
      notice_stuff(player);
      handle_stuff(player);
      event_signal(EVENT_REFRESH);
      if (player->is_dead || !player->upkeep->playing) return;
      if (!(turn % 10) && !player->upkeep->generate_level) {
        process_world(cave);
        notice_stuff(player);
        handle_stuff(player);
        event_signal(EVENT_REFRESH);
        if (player->is_dead || !player->upkeep->playing) return;
      }
      player->energy += turn_energy(player->state.speed);
      turn++;
    } else {
      if (character_dungeon) {
        on_leave_level();
      }
      if (!in_tutorial()) {
        prepare_next_level(player);
      } else {
        tutorial_prepare_section(tutorial_get_next_section(player), player);
      }
      on_new_level();
      player->upkeep->generate_level = false;
    }
    while (player->energy >= z_info->move_energy) {
      event_signal(EVENT_ANIMATE);
      process_monsters(player->energy + 1);
      if (player->is_dead || !player->upkeep->playing ||
          player->upkeep->generate_level)
        break;
      while (player->upkeep->playing) {
        pre_process_player();
        process_player();
        if (player->upkeep->energy_use) {
          break;
        } else {
          return;
        }
      }
    }
  }
}
STATIC_OVL enum parser_error
parse_profile_name(struct parser* p)
{
  struct cave_profile* h = parser_priv(p);
  struct cave_profile* c = mem_zalloc(sizeof *c);
  size_t i;
  c->name = string_make(parser_getstr(p, "name"));
  for (i = 0; i < N_ELEMENTS(cave_builders); i++)
    if (streq(c->name, cave_builders[i].name)) break;
  if (i == N_ELEMENTS(cave_builders)) return PARSE_ERROR_NO_BUILDER_FOUND;
  c->builder = cave_builders[i].builder;
  c->next = h;
  parser_setpriv(p, c);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_profile_rooms(struct parser* p)
{
  struct cave_profile* c = parser_priv(p);
  if (!c) return PARSE_ERROR_MISSING_RECORD_HEADER;
  c->dun_rooms = parser_getint(p, "rooms");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_profile_streamer(struct parser* p)
{
  struct cave_profile* c = parser_priv(p);
  if (!c) return PARSE_ERROR_MISSING_RECORD_HEADER;
  c->str.den = parser_getint(p, "den");
  c->str.rng = parser_getint(p, "rng");
  c->str.qua = parser_getint(p, "qua");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_profile_alloc(struct parser* p)
{
  struct cave_profile* c = parser_priv(p);
  if (!c) return PARSE_ERROR_MISSING_RECORD_HEADER;
  c->alloc = parser_getint(p, "alloc");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_profile_room(struct parser* p)
{
  struct cave_profile* c = parser_priv(p);
  struct room_profile* r = c->room_profiles;
  size_t i;
  if (!c) return PARSE_ERROR_MISSING_RECORD_HEADER;
  if (!r) {
    c->room_profiles = mem_zalloc(sizeof(struct room_profile));
    r = c->room_profiles;
  } else {
    while (r->next) r = r->next;
    r->next = mem_zalloc(sizeof(struct room_profile));
    r = r->next;
  }
  r->name = string_make(parser_getsym(p, "name"));
  for (i = 0; i < N_ELEMENTS(room_builders); i++)
    if (streq(r->name, room_builders[i].name)) break;
  if (i == N_ELEMENTS(room_builders)) return PARSE_ERROR_NO_ROOM_FOUND;
  r->builder = room_builders[i].builder;
  r->hardness = parser_getint(p, "hardness");
  r->level = parser_getint(p, "level");
  r->random = parser_getint(p, "random");
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_parse_profile(void)
{
  struct parser* p = parser_new();
  parser_setpriv(p, NULL);
  parser_reg(p, "name str name", parse_profile_name);
  parser_reg(p, "rooms int rooms", parse_profile_rooms);
  parser_reg(p, "streamer int den int rng int qua", parse_profile_streamer);
  parser_reg(p, "alloc int alloc", parse_profile_alloc);
  parser_reg(p, "room sym name int hardness int level int random",
             parse_profile_room);
  return p;
}
STATIC_OVL errr
run_parse_profile(struct parser* p)
{
  return parse_file_quit_not_found(p, "dungeon_profile");
}
STATIC_OVL errr
finish_parse_profile(struct parser* p)
{
  struct cave_profile *n, *c = parser_priv(p);
  int num;
  z_info->profile_max = 0;
  while (c) {
    z_info->profile_max++;
    c = c->next;
  }
  cave_profiles = mem_zalloc(z_info->profile_max * sizeof(*c));
  num = z_info->profile_max - 1;
  for (c = parser_priv(p); c; c = n) {
    memcpy(&cave_profiles[num], c, sizeof(*c));
    n = c->next;
    if (num < z_info->profile_max - 1) {
      cave_profiles[num].next = &cave_profiles[num + 1];
    } else {
      cave_profiles[num].next = NULL;
    }
    if (c->room_profiles) {
      struct room_profile* r_old = c->room_profiles;
      struct room_profile* r_new;
      int i;
      cave_profiles[num].n_room_profiles = 0;
      while (r_old) {
        ++cave_profiles[num].n_room_profiles;
        r_old = r_old->next;
      }
      r_new = mem_zalloc(cave_profiles[num].n_room_profiles * sizeof(*r_new));
      r_old = c->room_profiles;
      for (i = 0; i < cave_profiles[num].n_room_profiles; i++) {
        struct room_profile* r_temp = r_old;
        memcpy(&r_new[i], r_old, sizeof(*r_old));
        if (r_new[i].next) {
          r_new[i].next = &r_new[i + 1];
        }
        r_old = r_old->next;
        mem_free(r_temp);
      }
      cave_profiles[num].room_profiles = r_new;
    } else {
      cave_profiles[num].n_room_profiles = 0;
      cave_profiles[num].room_profiles = NULL;
    }
    mem_free(c);
    num--;
  }
  parser_destroy(p);
  return 0;
}
STATIC_OVL void
cleanup_profile(void)
{
  int i, j;
  for (i = 0; i < z_info->profile_max; i++) {
    for (j = 0; j < cave_profiles[i].n_room_profiles; j++)
      string_free((char*)cave_profiles[i].room_profiles[j].name);
    mem_free(cave_profiles[i].room_profiles);
    string_free((char*)cave_profiles[i].name);
  }
  mem_free(cave_profiles);
}
STATIC_OVL enum parser_error
parse_vault_name(struct parser* p)
{
  struct vault* h = parser_priv(p);
  struct vault* v = mem_zalloc(sizeof *v);
  v->name = string_make(parser_getstr(p, "name"));
  v->next = h;
  v->index = z_info->v_max;
  z_info->v_max++;
  parser_setpriv(p, v);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_vault_type(struct parser* p)
{
  struct vault* v = parser_priv(p);
  if (!v) return PARSE_ERROR_MISSING_RECORD_HEADER;
  v->typ = string_make(parser_getstr(p, "type"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_vault_depth(struct parser* p)
{
  struct vault* v = parser_priv(p);
  if (!v) return PARSE_ERROR_MISSING_RECORD_HEADER;
  v->depth = parser_getuint(p, "depth");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_vault_rarity(struct parser* p)
{
  struct vault* v = parser_priv(p);
  if (!v) return PARSE_ERROR_MISSING_RECORD_HEADER;
  v->rarity = parser_getuint(p, "rarity");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_vault_flags(struct parser* p)
{
  struct vault* v = parser_priv(p);
  char *s, *st;
  if (!v) return PARSE_ERROR_MISSING_RECORD_HEADER;
  s = string_make(parser_getstr(p, "flags"));
  st = strtok(s, " |");
  while (st && !grab_flag(v->flags, ROOMF_SIZE, room_flags, st)) {
    st = strtok(NULL, " |");
  }
  mem_free(s);
  return st ? PARSE_ERROR_INVALID_FLAG : PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_vault_d(struct parser* p)
{
  struct vault* v = parser_priv(p);
  const char* desc;
  size_t i;
  if (!v) return PARSE_ERROR_MISSING_RECORD_HEADER;
  desc = parser_getstr(p, "text");
  if (!v->wid) {
    size_t wid = strlen(desc);
    if (wid > 255) {
      return PARSE_ERROR_VAULT_TOO_BIG;
    }
    v->wid = (uint8_t)wid;
  }
  if (strlen(desc) != v->wid) {
    return PARSE_ERROR_VAULT_DESC_WRONG_LENGTH;
  } else {
    if (v->hgt == 255) {
      return PARSE_ERROR_VAULT_TOO_BIG;
    }
    v->text = string_append(v->text, desc);
    v->hgt++;
    if (strchr(desc, '0')) v->forge = true;
  }
  for (i = 0; i < N_ELEMENTS(room_builders); i++) {
    if (streq(v->typ, room_builders[i].name)) {
      break;
    }
  }
  if (i == N_ELEMENTS(room_builders)) {
    return PARSE_ERROR_NO_ROOM_FOUND;
  }
  if (v->wid > room_builders[i].max_width) {
    return PARSE_ERROR_VAULT_TOO_BIG;
  }
  if (v->hgt > room_builders[i].max_height) {
    return PARSE_ERROR_VAULT_TOO_BIG;
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_parse_vault(void)
{
  struct parser* p = parser_new();
  z_info->v_max = 0;
  parser_setpriv(p, NULL);
  parser_reg(p, "name str name", parse_vault_name);
  parser_reg(p, "type str type", parse_vault_type);
  parser_reg(p, "depth uint depth", parse_vault_depth);
  parser_reg(p, "rarity uint rarity", parse_vault_rarity);
  parser_reg(p, "flags str flags", parse_vault_flags);
  parser_reg(p, "D str text", parse_vault_d);
  return p;
}
STATIC_OVL errr
run_parse_vault(struct parser* p)
{
  return parse_file_quit_not_found(p, "vault");
}
STATIC_OVL errr
finish_parse_vault(struct parser* p)
{
  uint32_t rarity_denom = 1;
  struct vault* v;
  vaults = parser_priv(p);
  parser_destroy(p);
  for (v = vaults; v; v = v->next) {
    if (v->rarity > 0) {
      uint32_t g = rarity_denom;
      uint32_t b = v->rarity;
      while (b) {
        uint32_t t = b;
        b = g % b;
        g = t;
      }
      if (rarity_denom > 4294967295 / (v->rarity / g)) {
        plog("Smallest integer divisible by all vault rarities is too large.");
        return PARSE_ERROR_OUT_OF_BOUNDS;
      }
      rarity_denom *= v->rarity / g;
    }
  }
  if (rarity_denom > 4294967295 / z_info->v_max) {
    plog(
        "Product of number of vaults and smallest integer divisible by all "
        "vault rarities is too large.");
    return PARSE_ERROR_OUT_OF_BOUNDS;
  }
  for (v = vaults; v; v = v->next) {
    if (v->rarity > 0) {
      v->rarity = rarity_denom / v->rarity;
    }
  }
  return 0;
}
STATIC_OVL void
cleanup_vault(void)
{
  struct vault *v, *next;
  for (v = vaults; v; v = next) {
    next = v->next;
    mem_free(v->name);
    mem_free(v->typ);
    mem_free(v->text);
    mem_free(v);
  }
}
STATIC_OVL void
run_template_parser(void)
{
  event_signal_message(EVENT_INITSTATUS, 0,
                       "Initializing arrays... (dungeon profiles)");
  if (run_parser(&profile_parser)) quit("Cannot initialize dungeon profiles");
  event_signal_message(EVENT_INITSTATUS, 0, "Initializing arrays... (vaults)");
  if (run_parser(&vault_parser)) quit("Cannot initialize vaults");
}
STATIC_OVL void
cleanup_template_parser(void)
{
  cleanup_parser(&profile_parser);
  cleanup_parser(&vault_parser);
}
STATIC_OVL const struct cave_profile*
find_cave_profile(const char* name)
{
  int i;
  for (i = 0; i < z_info->profile_max; i++) {
    const struct cave_profile* profile;
    profile = &cave_profiles[i];
    if (streq(name, profile->name)) return profile;
  }
  return NULL;
}
STATIC_OVL const struct cave_profile*
choose_profile(struct player* p)
{
  const struct cave_profile* profile = NULL;
  if (p->depth == 0) {
    profile = find_cave_profile("gates");
  } else if (p->depth == z_info->dun_depth) {
    profile = find_cave_profile("throne");
  } else {
    int total_alloc = 0;
    size_t i;
    for (i = 0; i < z_info->profile_max; i++) {
      struct cave_profile* test_profile = &cave_profiles[i];
      if (test_profile->alloc <= 0) continue;
      total_alloc += test_profile->alloc;
      if (randint0(total_alloc) < test_profile->alloc) {
        profile = test_profile;
      }
    }
    if (!profile) {
      profile = find_cave_profile("cave");
    }
  }
  if (profile)
    return profile;
  else
    quit("Failed to find cave profile!");
  return NULL;
}
STATIC_OVL void
cave_clear(struct chunk* c, struct player* p)
{
  p->smithing_leftover = 0;
  p->upkeep->knocked_back = false;
  if (p->cave && (c == cave)) {
    int x, y;
    for (y = 0; y < c->height; y++) {
      for (x = 0; x < c->width; x++) {
        struct object* obj = square_object(c, loc(x, y));
        while (obj) {
          if (obj->artifact && object_is_known_artifact(obj)) {
            history_lose_artifact(p, obj->artifact);
            mark_artifact_created(obj->artifact, true);
          }
          obj = obj->next;
        }
      }
    }
    cave_free(p->cave);
    p->cave = NULL;
  }
  wipe_mon_list(c, p);
  forget_fire(c);
  cave_free(c);
}
STATIC_OVL void
cleanup_dun_data(struct dun_data* dd)
{
  int i;
  mem_free(dd->cent);
  mem_free(dd->corner);
  mem_free(dd->piece);
  for (i = 0; i < z_info->level_room_max; ++i) {
    mem_free(dd->connection[i]);
  }
  mem_free(dd->connection);
  for (i = 0; i < z_info->dungeon_hgt; ++i) {
    mem_free(dd->tunn1[i]);
    mem_free(dd->tunn2[i]);
  }
  mem_free(dd->tunn1);
  mem_free(dd->tunn2);
}
STATIC_OVL struct chunk*
cave_generate(struct player* p)
{
  const char* error = "no generation";
  int i, tries = 0;
  struct chunk* chunk = NULL;
  for (tries = 0; tries < 100 && error; tries++) {
    int y, x;
    struct dun_data dun_body;
    bool forge_made = p->unique_forge_made;
    error = NULL;
    character_dungeon = false;
    dun = &dun_body;
    dun->cent = mem_zalloc(z_info->level_room_max * sizeof(struct loc));
    dun->cent_n = 0;
    dun->corner = mem_zalloc(z_info->level_room_max * sizeof(struct rectangle));
    dun->piece = mem_zalloc(z_info->level_room_max * sizeof(int));
    dun->tunn1 = mem_zalloc(z_info->dungeon_hgt * sizeof(int*));
    dun->tunn2 = mem_zalloc(z_info->dungeon_hgt * sizeof(int*));
    for (y = 0; y < z_info->dungeon_hgt; y++) {
      dun->tunn1[y] = mem_zalloc(z_info->dungeon_wid * sizeof(int));
      dun->tunn2[y] = mem_zalloc(z_info->dungeon_wid * sizeof(int));
    }
    dun->connection = mem_zalloc(z_info->level_room_max * sizeof(bool*));
    for (i = 0; i < z_info->level_room_max; ++i) {
      dun->connection[i] = mem_zalloc(z_info->level_room_max * sizeof(bool));
    }
    dun->profile = choose_profile(p);
    event_signal_string(EVENT_GEN_LEVEL_START, dun->profile->name);
    chunk = dun->profile->builder(p);
    if (!chunk) {
      error = "Failed to find builder";
      cleanup_dun_data(dun);
      p->unique_forge_made = forge_made;
      event_signal_flag(EVENT_GEN_LEVEL_END, false);
      continue;
    }
    for (y = 0; y < chunk->height; y++) {
      for (x = 0; x < chunk->width; x++) {
        struct loc grid = loc(x, y);
        sqinfo_off(square(chunk, grid)->info, SQUARE_WALL_INNER);
        sqinfo_off(square(chunk, grid)->info, SQUARE_WALL_OUTER);
        sqinfo_off(square(chunk, grid)->info, SQUARE_WALL_SOLID);
      }
    }
    if (cave_monster_max(chunk) >= z_info->level_monster_max)
      error = "too many monsters";
    if (error) {
      if (OPT(p, cheat_room)) {
        msg("Generation restarted: %s.", error);
      }
      uncreate_artifacts(chunk);
      uncreate_greater_vaults(chunk, p);
      cave_clear(chunk, p);
      p->unique_forge_made = forge_made;
      event_signal_flag(EVENT_GEN_LEVEL_END, false);
    }
    cleanup_dun_data(dun);
  }
  if (error) quit_fmt("cave_generate() failed 100 times!");
  chunk_validate_objects(chunk);
  p->cave = cave_new(chunk->height, chunk->width);
  p->cave->depth = chunk->depth;
  p->cave->objects = mem_realloc(p->cave->objects,
                                 (chunk->obj_max + 1) * sizeof(struct object*));
  p->cave->obj_max = chunk->obj_max;
  for (i = 0; i <= p->cave->obj_max; i++) {
    p->cave->objects[i] = NULL;
  }
  p->upkeep->create_stair = FEAT_NONE;
  return chunk;
}
STATIC_OVL void
prepare_next_level(struct player* p)
{
  int x, y;
  bool noted = false;
  if (character_dungeon) {
    for (y = 0; y < cave->height; y++) {
      for (x = 0; x < cave->width; x++) {
        struct loc grid = loc(x, y);
        struct object* obj = square_object(cave, grid);
        while (obj) {
          if (obj->artifact) {
            history_lose_artifact(p, obj->artifact);
            mark_artifact_created(obj->artifact, true);
          }
          obj = obj->next;
        }
        if (!noted && square_isknown(cave, grid) &&
            square_isgreatervault(cave, grid)) {
          history_add(p, format("Left without entering %s", cave->vault_name),
                      HIST_VAULT_LOST);
          noted = true;
        }
      }
    }
    if (cave) {
      cave_clear(cave, p);
      cave = NULL;
    }
  }
  cave = cave_generate(p);
  event_signal_flag(EVENT_GEN_LEVEL_END, true);
  for (y = 0; y < cave->height; y++) {
    for (x = 0; x < cave->width; x++) {
      if (square_isforge(cave, loc(x, y))) {
        player->forge_drought = 0;
        player->forge_count++;
      }
    }
  }
  character_dungeon = true;
}
STATIC_OVL int
get_room_builder_count(void)
{
  return (int)N_ELEMENTS(room_builders);
}
STATIC_OVL int
get_room_builder_index_from_name(const char* name)
{
  int i = 0;
  while (1) {
    if (i >= (int)N_ELEMENTS(room_builders)) {
      return -1;
    }
    if (streq(name, room_builders[i].name)) {
      return i;
    }
    ++i;
  }
}
STATIC_OVL const char*
get_room_builder_name_from_index(int i)
{
  return (i >= 0 && i < (int)get_room_builder_count()) ? room_builders[i].name
                                                       : NULL;
}
STATIC_OVL int
get_level_profile_index_from_name(const char* name)
{
  const struct cave_profile* p = find_cave_profile(name);
  return (p) ? (int)(p - cave_profiles) : -1;
}
STATIC_OVL const char*
get_level_profile_name_from_index(int i)
{
  return (i >= 0 && i < z_info->profile_max) ? cave_profiles[i].name : NULL;
}
STATIC_OVL bool
player_pass(struct chunk* c, struct loc grid, bool ignore_rubble)
{
  bool vault_interior = square_isvault(c, grid) &&
                        square_isvault(c, loc(grid.x - 1, grid.y)) &&
                        square_isvault(c, loc(grid.x + 1, grid.y)) &&
                        square_isvault(c, loc(grid.x, grid.y - 1)) &&
                        square_isvault(c, loc(grid.x, grid.y + 1));
  return square_ispassable(c, grid) || square_issecretdoor(c, grid) ||
         square_iscloseddoor(c, grid) ||
         (square_isrubble(c, grid) && ignore_rubble) || vault_interior;
}
STATIC_OVL void
flood_access(struct chunk* c, struct loc grid, bool** access,
             bool ignore_rubble)
{
  int i;
  if (!square_in_bounds(c, grid)) return;
  access[grid.y][grid.x] = true;
  for (i = 0; i < 8; i++) {
    struct loc check = loc_sum(grid, ddgrid_ddd[i]);
    if (player_pass(c, check, ignore_rubble) && !access[check.y][check.x]) {
      flood_access(c, check, access, ignore_rubble);
    }
  }
  return;
}
STATIC_OVL bool
check_connectivity(struct chunk* c)
{
  struct loc grid;
  bool result = false;
  bool** access = mem_zalloc(c->height * sizeof(bool*));
  for (grid.y = 0; grid.y < c->height; grid.y++) {
    access[grid.y] = mem_zalloc(c->width * sizeof(bool));
  }
  flood_access(c, player->grid, access, true);
  for (grid.y = 0; grid.y < c->height; grid.y++) {
    for (grid.x = 0; grid.x < c->width; grid.x++) {
      if (player_pass(c, grid, true) && !access[grid.y][grid.x]) {
        goto CLEANUP;
      }
    }
  }
  for (grid.y = 0; grid.y < c->height; grid.y++) {
    for (grid.x = 0; grid.x < c->width; grid.x++) {
      access[grid.y][grid.x] = false;
    }
  }
  flood_access(c, player->grid, access, false);
  for (grid.y = 0; grid.y < c->height; grid.y++) {
    for (grid.x = 0; grid.x < c->width; grid.x++) {
      if (access[grid.y][grid.x] && square_isstairs(c, grid)) {
        result = true;
        goto CLEANUP;
      }
    }
  }
CLEANUP:
  for (grid.y = 0; grid.y < c->height; grid.y++) {
    mem_free(access[grid.y]);
  }
  mem_free(access);
  return result;
}
STATIC_OVL void
flood_piece(int n, int piece_num)
{
  int i;
  dun->piece[n] = piece_num;
  for (i = 0; i < dun->cent_n; i++) {
    if (dun->connection[n][i] && (dun->piece[i] == 0)) {
      flood_piece(i, piece_num);
    }
  }
  return;
}
STATIC_OVL int
dungeon_pieces(void)
{
  int piece_num;
  int i;
  for (i = 0; i < dun->cent_n; i++) {
    dun->piece[i] = 0;
  }
  for (piece_num = 1; piece_num <= dun->cent_n; piece_num++) {
    for (i = 0; (i < dun->cent_n) && (dun->piece[i] != 0); i++)
      ;
    if (i == dun->cent_n) {
      break;
    } else {
      flood_piece(i, piece_num);
    }
  }
  return (piece_num - 1);
}
STATIC_OVL bool
build_streamer(struct chunk* c, int feat)
{
  struct loc grid = rand_loc(loc(c->width / 2, c->height / 2), 15, 10);
  int dir = ddd[randint0(8)];
  int tries1 = 0;
  while (true) {
    int i;
    struct loc change;
    tries1++;
    if (tries1 > 2500) return false;
    for (i = 0; i < dun->profile->str.den; i++) {
      int d = dun->profile->str.rng;
      find_nearby_grid(c, &change, grid, d, d);
      if (square_isgranitewall(c, change)) {
        square_set_feat(c, change, feat);
      }
    }
    grid = loc_sum(grid, ddgrid[dir]);
    if (!square_in_bounds(c, grid)) break;
  }
  return true;
}
STATIC_OVL void
build_chasm(struct chunk* c)
{
  bool chasm_ok = false;
  struct loc grid1;
  while (!chasm_ok) {
    int i;
    struct loc grid =
        loc(rand_range(10, c->width - 10), rand_range(10, c->height - 10));
    int main_dir = ddd[randint0(4)];
    int length = damroll(4, 8);
    int floor_to_chasm = 0;
    for (i = 0; i < length; i++) {
      if (one_in_(2)) {
        grid = loc_sum(grid, ddgrid_ddd[randint0(4)]);
      } else {
        grid = loc_sum(grid, ddgrid[main_dir]);
      }
      if ((grid.y < 3) || (grid.y > c->height - 3) || (grid.x < 3) ||
          (grid.x > c->width - 3))
        break;
      sqinfo_on(square(c, grid)->info, SQUARE_CHASM);
    }
    chasm_ok = true;
    for (grid.y = 1; grid.y < c->height - 1; grid.y++) {
      for (grid.x = 1; grid.x < c->width - 1; grid.x++) {
        struct loc gride = loc_sum(grid, loc(1, 0));
        struct loc grids = loc_sum(grid, loc(0, 1));
        struct loc gridw = loc_sum(grid, loc(-1, 0));
        struct loc gridn = loc_sum(grid, loc(0, -1));
        if (square_tobechasm(c, grid)) {
          if (square_isvault(c, grid)) {
            chasm_ok = false;
          }
          if (square_tobechasm(c, grids) && !square_isroom(c, grid) &&
              !square_isroom(c, grids) && square_isfloor(c, grid) &&
              square_isfloor(c, grids)) {
            chasm_ok = false;
          }
          if (square_tobechasm(c, gride) && !square_isroom(c, grid) &&
              !square_isroom(c, gride) && square_isfloor(c, grid) &&
              square_isfloor(c, gride)) {
            chasm_ok = false;
          }
          if (square_iscloseddoor(c, gride) || square_iscloseddoor(c, grids) ||
              square_iscloseddoor(c, gridw) || square_iscloseddoor(c, gridn)) {
            chasm_ok = false;
          }
          if (square_isrock(c, grid) && square_isglow(c, grid)) {
            if ((square_isrock(c, gride) && !square_isglow(c, gride) &&
                 !square_tobechasm(c, gride)) ||
                (square_isrock(c, grids) && !square_isglow(c, grids) &&
                 !square_tobechasm(c, grids)) ||
                (square_isrock(c, gridw) && !square_isglow(c, gridw) &&
                 !square_tobechasm(c, gridw)) ||
                (square_isrock(c, gridn) && !square_isglow(c, gridn) &&
                 !square_tobechasm(c, gridn))) {
              chasm_ok = false;
            }
          }
          if (square_ispassable(c, grid)) {
            floor_to_chasm++;
          }
        }
      }
    }
    if (floor_to_chasm < 1) {
      chasm_ok = false;
    }
    if (!chasm_ok) {
      for (grid.y = 0; grid.y < c->height; grid.y++) {
        for (grid.x = 0; grid.x < c->width; grid.x++) {
          sqinfo_off(square(c, grid)->info, SQUARE_CHASM);
        }
      }
    }
  }
  for (grid1.y = 0; grid1.y < c->height; grid1.y++) {
    for (grid1.x = 0; grid1.x < c->width; grid1.x++) {
      if (sqinfo_has(square(c, grid1)->info, SQUARE_CHASM)) {
        square_set_feat(c, grid1, FEAT_CHASM);
        sqinfo_off(square(c, grid1)->info, SQUARE_CHASM);
      }
    }
  }
}
STATIC_OVL void
build_chasms(struct chunk* c)
{
  int i;
  int chasms = 0;
  int blocks = (c->height / z_info->block_hgt) * (c->width / z_info->block_wid);
  if ((c->depth > 2) && (c->depth < z_info->dun_depth - 1) &&
      percent_chance(c->depth + 30)) {
    chasms += damroll(1, blocks / 3);
    while (one_in_(2)) {
      chasms += damroll(1, blocks / 3);
    }
  }
  for (i = 0; i < chasms; i++) {
    build_chasm(c);
  }
  if (OPT(player, cheat_room) && (chasms > 0)) {
    msg("%d chasms.", chasms);
  }
}
STATIC_OVL bool
tunnel_ok(struct chunk* c, struct loc grid1, struct loc grid2, bool tentative,
          int desired_changes)
{
  int x, y;
  struct loc grid_lo, grid_hi;
  bool vert = true;
  int changes = 0;
  if (grid1.y == grid2.y) {
    vert = false;
    if (grid1.x < grid2.x) {
      grid_lo = grid1;
      grid_hi = grid2;
    } else {
      grid_lo = grid2;
      grid_hi = grid1;
    }
  } else {
    if (grid1.y < grid2.y) {
      grid_lo = grid1;
      grid_hi = grid2;
    } else {
      grid_lo = grid2;
      grid_hi = grid1;
    }
  }
  if (square_iswall_outer(c, grid_lo) || square_iswall_outer(c, grid_hi)) {
    return false;
  }
  if (!square_isroom(c, grid_lo)) {
    struct loc check1 = loc_sum(grid_lo, loc(-1, -1));
    struct loc check2 =
        vert ? loc_sum(grid_lo, loc(1, -1)) : loc_sum(grid_lo, loc(-1, 1));
    if (square_isfloor(c, check1) || square_isfloor(c, check2)) {
      return false;
    }
  }
  if (!square_isroom(c, grid_hi)) {
    struct loc check1 =
        vert ? loc_sum(grid_hi, loc(-1, 1)) : loc_sum(grid_hi, loc(1, -1));
    struct loc check2 = loc_sum(grid_hi, loc(1, 1));
    if (square_isfloor(c, check1) || square_isfloor(c, check2)) {
      return false;
    }
  }
  for (x = grid_lo.x, y = grid_lo.y; x <= grid_hi.x && y <= grid_hi.y;
       vert ? y++ : x++) {
    struct loc grid = loc(x, y);
    struct loc perp0 = vert ? loc(x - 1, y) : loc(x, y - 1);
    struct loc perp1 = vert ? loc(x + 1, y) : loc(x, y + 1);
    struct loc prev = vert ? loc(x, y - 1) : loc(x - 1, y);
    if (square_iscloseddoor(c, perp0) && !square_isvault(c, perp0)) {
      return false;
    }
    if (square_iscloseddoor(c, grid) && !square_isvault(c, grid)) {
      return false;
    }
    if (square_iscloseddoor(c, perp1) && !square_isvault(c, perp1)) {
      return false;
    }
    if ((square_isfloor(c, perp0) || square_isfloor(c, perp1)) &&
        !square_isroom(c, grid)) {
      return false;
    }
    if ((x == grid_lo.x) && (y == grid_lo.y)) continue;
    if (square_iswall_outer(c, grid) &&
        (square_ispassable(c, prev) || square_iswall_inner(c, prev))) {
      changes++;
    }
    if (square_iswall_outer(c, prev) &&
        (square_ispassable(c, grid) || square_iswall_inner(c, grid))) {
      changes++;
    }
    if (square_iswall_outer(c, grid) && square_iswall_outer(c, prev)) {
      return false;
    }
    if (square_iswall_outer(c, prev) && square_iscloseddoor(c, grid)) {
      return false;
    }
    if (square_iswall_outer(c, grid) && square_iscloseddoor(c, prev)) {
      return false;
    }
    if (square_iswall_outer(c, prev) && square_iswall_inner(c, grid)) {
      return false;
    }
    if (square_iswall_outer(c, grid) && square_iswall_inner(c, prev)) {
      return false;
    }
    if (square_iswall_solid(c, prev) &&
        (square_ispassable(c, grid) || square_iswall_inner(c, grid))) {
      return false;
    }
    if (square_iswall_solid(c, grid) &&
        (square_ispassable(c, prev) || square_iswall_inner(c, prev))) {
      return false;
    }
  }
  if (tentative && (changes != desired_changes)) {
    return false;
  } else {
    return true;
  }
}
STATIC_OVL int
lay_tunnel(struct chunk* c, struct loc grid1, struct loc grid2, int r1, int r2)
{
  int ncnvt = 0;
  int x, y;
  struct loc grid_lo, grid_hi;
  bool vert = true;
  if (grid1.y == grid2.y) {
    vert = false;
    if (grid1.x < grid2.x) {
      grid_lo = grid1;
      grid_hi = grid2;
    } else {
      grid_lo = grid2;
      grid_hi = grid1;
    }
  } else {
    if (grid1.y < grid2.y) {
      grid_lo = grid1;
      grid_hi = grid2;
    } else {
      grid_lo = grid2;
      grid_hi = grid1;
    }
  }
  for (x = grid_lo.x, y = grid_lo.y; x <= grid_hi.x && y <= grid_hi.y;
       vert ? y++ : x++) {
    struct loc grid = loc(x, y);
    if (square_iswall_outer(c, grid)) {
      square_set_feat(c, grid, FEAT_CLOSED);
      ++ncnvt;
    } else if (square_iswall_solid(c, grid)) {
      square_set_feat(c, grid, FEAT_FLOOR);
      dun->tunn1[y][x] = r1;
      dun->tunn2[y][x] = r2;
      ++ncnvt;
    }
  }
  return ncnvt;
}
STATIC_OVL bool
build_tunnel(struct chunk* c, int r1, int r2, struct loc grid1,
             struct loc grid2, bool tentative, enum tunnel_type t)
{
  struct loc grid_mid;
  tunnel_direction_type dir;
  int nver, nhor;
  if ((grid1.y == grid2.y) || (grid1.x == grid2.x)) {
    if (t == TUNNEL_ROOM_TO_CORRIDOR ||
        tunnel_ok(c, grid1, grid2, tentative, 2)) {
      nver = lay_tunnel(c, grid1, grid2, r1, r2);
      nhor = 0;
      if (grid1.y == grid2.y) {
        int tmp = nver;
        nver = nhor;
        nhor = tmp;
        dir = TUNNEL_HOR;
      } else {
        dir = TUNNEL_VER;
      }
      event_signal_tunnel(EVENT_GEN_TUNNEL_FINISHED, t, dir, nver, nhor);
      return true;
    } else {
      return false;
    }
  } else if (one_in_(2)) {
    grid_mid = loc(grid2.x, grid1.y);
    dir = TUNNEL_BENT;
  } else {
    grid_mid = loc(grid1.x, grid2.y);
    dir = TUNNEL_BENT;
  }
  if (!tunnel_ok(c, grid1, grid_mid, tentative, 1)) return false;
  if (!tunnel_ok(c, grid_mid, grid2, tentative, 1)) return false;
  nver = lay_tunnel(c, grid1, grid_mid, r1, r2);
  nhor = lay_tunnel(c, grid_mid, grid2, r1, r2);
  if (grid_mid.y == grid1.y) {
    int tmp = nver;
    nver = nhor;
    nhor = tmp;
  }
  event_signal_tunnel(EVENT_GEN_TUNNEL_FINISHED, t, dir, nver, nhor);
  return true;
}
STATIC_OVL bool
connect_two_rooms(struct chunk* c, int r1, int r2, bool tentative,
                  bool desperate)
{
  struct loc cent1 = dun->cent[r1];
  struct loc cent2 = dun->cent[r2];
  struct loc top_left1 = dun->corner[r1].top_left;
  struct loc top_left2 = dun->corner[r2].top_left;
  struct loc bottom_right1 = dun->corner[r1].bottom_right;
  struct loc bottom_right2 = dun->corner[r2].bottom_right;
  bool success;
  int distance_limitx = desperate ? 22 : 15;
  int distance_limity = desperate ? 16 : 10;
  if ((ABS(cent1.y - cent2.y) > distance_limity * 3) ||
      (ABS(cent1.x - cent2.x) > distance_limitx * 3)) {
    return false;
  }
  if ((cent1.x < cent2.x) &&
      (top_left2.x - bottom_right1.x > distance_limitx)) {
    return false;
  }
  if ((cent2.x < cent1.x) &&
      (top_left1.x - bottom_right2.x > distance_limitx)) {
    return false;
  }
  if ((cent1.y < cent2.y) &&
      (top_left2.y - bottom_right1.y > distance_limity)) {
    return false;
  }
  if ((cent2.y < cent1.y) &&
      (top_left1.y - bottom_right2.y > distance_limity)) {
    return false;
  }
  if ((top_left1.x <= bottom_right2.x) && (top_left2.x <= bottom_right1.x)) {
    int x = rand_range(MAX(top_left1.x, top_left2.x),
                       MIN(bottom_right1.x, bottom_right2.x));
    struct loc grid1 = loc(x, cent1.y);
    struct loc grid2 = loc(x, cent2.y);
    if (tentative && one_in_(2)) {
      return false;
    }
    success =
        build_tunnel(c, r1, r2, grid1, grid2, tentative,
                     (desperate) ? TUNNEL_DESPERATE : TUNNEL_ROOM_TO_ROOM);
  } else if ((top_left1.y <= bottom_right2.y) &&
             (top_left2.y <= bottom_right1.y)) {
    int y = rand_range(MAX(top_left1.y, top_left2.y),
                       MIN(bottom_right1.y, bottom_right2.y));
    struct loc grid1 = loc(cent1.x, y);
    struct loc grid2 = loc(cent2.x, y);
    success =
        build_tunnel(c, r1, r2, grid1, grid2, tentative,
                     (desperate) ? TUNNEL_DESPERATE : TUNNEL_ROOM_TO_ROOM);
  } else {
    if (MIN(ABS(cent2.x - top_left1.x), ABS(cent2.x - bottom_right1.x)) >
        distance_limitx - 2) {
      return false;
    }
    if (MIN(ABS(cent1.x - top_left2.x), ABS(cent1.x - bottom_right2.x)) >
        distance_limitx - 2) {
      return false;
    }
    if (MIN(ABS(cent2.y - top_left1.y), ABS(cent2.y - bottom_right1.y)) >
        distance_limity - 2) {
      return false;
    }
    if (MIN(ABS(cent1.y - top_left2.y), ABS(cent1.y - bottom_right2.y)) >
        distance_limity - 2) {
      return false;
    }
    success =
        build_tunnel(c, r1, r2, cent1, cent2, tentative,
                     (desperate) ? TUNNEL_DESPERATE : TUNNEL_ROOM_TO_ROOM);
  }
  if (success) {
    dun->connection[r1][r2] = true;
    dun->connection[r2][r1] = true;
  }
  return success;
}
STATIC_OVL bool
connect_room_to_corridor(struct chunk* c, int r)
{
  int length = 10;
  struct loc grid, cent = dun->cent[r];
  int r1, r2;
  bool success = false;
  bool done = false;
  int delta = one_in_(2) ? 1 : -1;
  bool vert = one_in_(2);
  grid = cent;
  while (!done) {
    if (vert) {
      grid.y += delta;
    } else {
      grid.x += delta;
    }
    if (!square_in_bounds(c, grid) || (ABS(grid.x - cent.x) > length) ||
        (ABS(grid.y - cent.y) > length) || square_iscloseddoor(c, grid)) {
      success = false;
      done = true;
    } else if (square_isfloor(c, grid) && !square_isroom(c, grid)) {
      r1 = dun->tunn1[grid.y][grid.x];
      r2 = dun->tunn2[grid.y][grid.x];
      if ((r1 < 0) || (r2 < 0) ||
          (!(dun->connection[r][r1]) && !(dun->connection[r][r2]))) {
        struct loc grid1 = vert ? loc(grid.x, cent.y) : loc(cent.x, grid.y);
        struct loc grid2 = vert ? loc(grid.x, grid.y - (delta * 2))
                                : loc(grid.x - (delta * 2), grid.y);
        if (tunnel_ok(c, grid1, grid2, true, 1)) {
          (void)build_tunnel(c, r, r1, grid1, grid, false,
                             TUNNEL_ROOM_TO_CORRIDOR);
          dun->connection[r][r1] = true;
          dun->connection[r1][r] = true;
          dun->connection[r][r2] = true;
          dun->connection[r2][r] = true;
          success = true;
        }
      }
      done = true;
    }
  }
  return success;
}
STATIC_OVL bool
connect_rooms_stairs(struct chunk* c)
{
  int i;
  int corridor_attempts = dun->cent_n * dun->cent_n * 10;
  int r1, r2;
  int pieces = 0;
  int width;
  int stairs = 0;
  for (r1 = 0; r1 < dun->cent_n; r1++) {
    int r_closest = 0;
    int d_closest = 1000;
    for (r2 = 0; r2 < dun->cent_n; r2++) {
      if (r2 != r1) {
        int d = distance(dun->cent[r1], dun->cent[r2]);
        if (d < d_closest) {
          d_closest = d;
          r_closest = r2;
        }
      }
    }
    if (!(dun->connection[r1][r_closest])) {
      (void)connect_two_rooms(c, r1, r_closest, true, false);
    }
  }
  for (i = 0; i < corridor_attempts; i++) {
    r1 = randint0(dun->cent_n);
    r2 = randint0(dun->cent_n);
    if ((r1 != r2) && !(dun->connection[r1][r2])) {
      (void)connect_two_rooms(c, r1, r2, true, false);
    }
  }
  for (i = 0; i < corridor_attempts; i++) {
    r1 = randint0(dun->cent_n);
    (void)connect_room_to_corridor(c, r1);
  }
  pieces = dungeon_pieces();
  while (pieces > 1) {
    bool joined = false;
    for (r1 = 0; r1 < dun->cent_n; r1++) {
      for (r2 = 0; r2 < dun->cent_n; r2++) {
        if (!joined && (dun->piece[r1] != dun->piece[r2])) {
          for (i = 0; i < 10; i++) {
            if (!(dun->connection[r1][r2])) {
              joined = connect_two_rooms(c, r1, r2, true, true);
            }
          }
        }
      }
    }
    if (!joined) {
      break;
    }
    pieces = dungeon_pieces();
  }
  width = c->width / z_info->block_wid;
  if (width <= 3) {
    stairs = 1;
  } else if (width == 4) {
    stairs = 2;
  } else {
    stairs = 4;
  }
  if ((player->upkeep->create_stair == FEAT_MORE) ||
      (player->upkeep->create_stair == FEAT_MORE_SHAFT)) {
    stairs--;
  }
  alloc_stairs(c, FEAT_MORE, stairs);
  width = c->width / z_info->block_wid;
  if (width <= 3) {
    stairs = 1;
  } else if (width == 4) {
    stairs = 2;
  } else {
    stairs = 4;
  }
  if ((player->upkeep->create_stair == FEAT_LESS) ||
      (player->upkeep->create_stair == FEAT_LESS_SHAFT))
    stairs--;
  alloc_stairs(c, FEAT_LESS, stairs);
  for (i = 0; i < dun->profile->str.qua; i++) {
    if (!build_streamer(c, FEAT_QUARTZ)) return false;
  }
  build_chasms(c);
  return true;
}
STATIC_OVL struct chunk*
cave_gen(struct player* p)
{
  int i, y, x;
  int blocks;
  int room_attempts;
  struct chunk* c;
  int rubble_gen, mon_gen, obj_room_gen;
  blocks = 3 + ((p->depth + randint1(5)) / 10);
  c = cave_new(blocks * z_info->block_hgt, blocks * z_info->block_wid);
  room_attempts = blocks * blocks * blocks * blocks;
  c->depth = p->depth;
  fill_rectangle(c, 0, 0, c->height - 1, c->width - 1, FEAT_GRANITE,
                 SQUARE_WALL_SOLID);
  for (y = 0; y < c->height; y++) {
    for (x = 0; x < c->width; x++) {
      dun->tunn1[y][x] = -1;
      dun->tunn2[y][x] = -1;
    }
  }
  if (p->forge_drought >= rand_range(2000, 5000)) {
    struct room_profile profile = lookup_room_profile("Interesting room");
    if (OPT(p, cheat_room)) msg("Trying to force a forge:");
    p->upkeep->force_forge = true;
    if (!room_build(c, profile)) {
      p->upkeep->force_forge = false;
      if (OPT(p, cheat_room)) msg("failed.");
      uncreate_artifacts(c);
      uncreate_greater_vaults(c, p);
      wipe_mon_list(c, p);
      cave_free(c);
      return NULL;
    }
    if (OPT(p, cheat_room)) msg("succeeded.");
    p->upkeep->force_forge = false;
  }
  for (i = 0; i < room_attempts; i++) {
    int j;
    struct room_profile profile = dun->profile->room_profiles[0];
    int hardness = randint1(c->depth + 5);
    if (one_in_(5)) hardness += randint1(5);
    for (j = 0; j < dun->profile->n_room_profiles; j++) {
      profile = dun->profile->room_profiles[j];
      if ((profile.hardness > hardness) || !profile.hardness) break;
      if (profile.level && (profile.level == c->depth)) break;
      if (profile.random && one_in_(profile.random)) break;
    }
    if (!profile.builder) continue;
    room_build(c, profile);
    if (dun->cent_n == z_info->level_room_max - 1) break;
  }
  draw_rectangle(c, 0, 0, c->height - 1, c->width - 1, FEAT_PERM, SQUARE_NONE,
                 true);
  if (dun->cent_n < z_info->level_room_min) {
    if (OPT(p, cheat_room)) msg("Not enough rooms.");
    uncreate_artifacts(c);
    uncreate_greater_vaults(c, p);
    wipe_mon_list(c, p);
    cave_free(c);
    return NULL;
  }
  if (!connect_rooms_stairs(c)) {
    if (OPT(p, cheat_room)) msg("Couldn't connect the rooms.");
    uncreate_artifacts(c);
    uncreate_greater_vaults(c, p);
    wipe_mon_list(c, p);
    cave_free(c);
    return NULL;
  }
  for (y = 0; y < c->height; y++) {
    for (x = 0; x < c->width; x++) {
      struct loc grid = loc(x, y);
      if (square_iscloseddoor(c, grid) && !square_isvault(c, grid)) {
        if (one_in_(4)) {
          square_set_feat(c, grid, FEAT_FLOOR);
        } else {
          place_random_door(c, grid);
        }
      }
    }
  }
  rubble_gen = randint1((blocks * blocks) / 3);
  if ((c->depth >= 10) && one_in_(10)) {
    rubble_gen += blocks * blocks * 2;
  }
  alloc_object(c, SET_BOTH, TYP_RUBBLE, rubble_gen, c->depth, ORIGIN_FLOOR);
  new_player_spot(c, p);
  if (!check_connectivity(c)) {
    if (OPT(p, cheat_room)) msg("Failed connectivity.");
    uncreate_artifacts(c);
    uncreate_greater_vaults(c, p);
    wipe_mon_list(c, p);
    cave_free(c);
    return NULL;
  }
  if (c->depth == 1) {
    mon_gen = dun->cent_n / 2;
  } else {
    mon_gen = (dun->cent_n + randint1(dun->cent_n)) / 2;
  }
  obj_room_gen = 3 * mon_gen / 4;
  if (obj_room_gen > 0) {
    alloc_object(c, SET_ROOM, TYP_OBJECT, obj_room_gen, c->depth, ORIGIN_FLOOR);
  }
  place_traps(c);
  for (i = mon_gen; i > 0; i--) {
    (void)pick_and_place_distant_monster(c, p, true, c->depth);
  }
  if (p->on_the_run && !p->morgoth_slain) {
    struct loc grid;
    int count = 100;
    while (cave_find(c, &grid, square_suits_start) && count--) {
      if (!los(c, p->grid, grid)) {
        struct monster_group_info info = {0, 0};
        place_new_monster_one(c, grid, lookup_monster("Morgoth"), true, true,
                              info, ORIGIN_DROP);
        break;
      }
    }
  }
  if (p->turn == 0) {
    place_item_near_player(c, p, TV_SWORD, "Curved Sword");
  }
  return c;
}
STATIC_OVL struct chunk*
throne_gen(struct player* p)
{
  int y, x;
  struct chunk* c;
  struct room_profile profile = lookup_room_profile("Throne room");
  struct loc pgrid = loc(0, 0);
  event_signal_poem(EVENT_POEM, "throne_poetry", 5, 15);
  p->truce = true;
  c = cave_new(3 * z_info->block_hgt, 3 * z_info->block_wid);
  c->depth = p->depth;
  fill_rectangle(c, 0, 0, c->height - 1, c->width - 1, FEAT_GRANITE,
                 SQUARE_WALL_SOLID);
  draw_rectangle(c, 0, 0, c->height - 1, c->width - 1, FEAT_PERM, SQUARE_NONE,
                 true);
  room_build(c, profile);
  for (y = 0; y < c->height; y++) {
    for (x = 0; x < c->width; x++) {
      struct loc grid = loc(x, y);
      if (square_isupstairs(c, grid) && (x >= 40) && (x <= 55)) {
        pgrid = grid;
        break;
      }
    }
    if (!loc_eq(pgrid, loc(0, 0))) break;
  }
  if (loc_eq(pgrid, loc(0, 0))) {
    msg("Failed to find an up staircase in the throne-room");
  }
  delete_monster(c, pgrid);
  player_place(c, p, pgrid);
  return c;
}
STATIC_OVL struct chunk*
gates_gen(struct player* p)
{
  int y, x;
  struct chunk* c;
  struct room_profile profile = lookup_room_profile("Gates of Angband");
  const struct vault* gates_room =
      random_vault(p->depth, "Gates of Angband", false);
  struct loc pgrid = loc(0, 0);
  c = cave_new(2 + gates_room->hgt, 2 + gates_room->wid);
  c->depth = p->depth;
  fill_rectangle(c, 0, 0, c->height - 1, c->width - 1, FEAT_GRANITE,
                 SQUARE_WALL_SOLID);
  draw_rectangle(c, 0, 0, c->height - 1, c->width - 1, FEAT_PERM, SQUARE_NONE,
                 true);
  for (x = 1; x < c->width - 1; x++) {
    square_set_feat(c, loc(x, c->height - 1), FEAT_FLOOR);
  }
  room_build(c, profile);
  for (y = 0; y < c->height; y++) {
    for (x = 0; x < c->width; x++) {
      struct loc grid = loc(x, y);
      if (square_isdownstairs(c, grid)) {
        pgrid = grid;
        break;
      }
    }
    if (!loc_eq(pgrid, loc(0, 0))) break;
  }
  if (loc_eq(pgrid, loc(0, 0))) {
    msg("Failed to find a down staircase in the gates level");
  }
  delete_monster(c, pgrid);
  player_place(c, p, pgrid);
  return c;
}
STATIC_OVL struct vault*
random_vault(int depth, const char* typ, bool forge)
{
  struct vault* v = vaults;
  struct vault* r = NULL;
  uint32_t rarity_sum = 0;
  do {
    if (streq(v->typ, typ) && (v->depth <= depth)) {
      bool valid = v->rarity > 0;
      if (forge && !v->forge) {
        valid = false;
      }
      if (streq(v->typ, "Greater vault") && player->vaults[v->index]) {
        valid = false;
      }
      if (valid) {
        rarity_sum += v->rarity;
        if (Rand_div(rarity_sum) < v->rarity) r = v;
      }
    }
    v = v->next;
  } while (v);
  return r;
}
STATIC_OVL bool
solid_rock(struct chunk* c, int y1, int x1, int y2, int x2)
{
  int y, x;
  for (y = y1; y <= y2; y++) {
    for (x = x1; x <= x2; x++) {
      if (square_isfloor(c, loc(x, y)) || square_isvault(c, loc(x, y))) {
        return false;
      }
    }
  }
  return true;
}
STATIC_OVL bool
doubled_wall(struct chunk* c, int y1, int x1, int y2, int x2)
{
  int y, x;
  for (x = x1; x < x2; x++) {
    if (square_iswall_outer(c, loc(x, y1 - 2)) &&
        square_iswall_outer(c, loc(x + 1, y1 - 2)))
      return true;
  }
  for (x = x1; x < x2; x++) {
    if (square_iswall_outer(c, loc(x, y2 + 2)) &&
        square_iswall_outer(c, loc(x + 1, y2 + 2)))
      return true;
  }
  for (y = y1; y < y2; y++) {
    if (square_iswall_outer(c, loc(x1 - 2, y)) &&
        square_iswall_outer(c, loc(x1 - 2, y + 1)))
      return true;
  }
  for (y = y1; y < y2; y++) {
    if (square_iswall_outer(c, loc(x2 + 2, y)) &&
        square_iswall_outer(c, loc(x2 + 2, y + 1)))
      return true;
  }
  return false;
}
STATIC_OVL void
generate_room(struct chunk* c, int y1, int x1, int y2, int x2, int light)
{
  struct loc grid;
  for (grid.y = y1; grid.y <= y2; grid.y++)
    for (grid.x = x1; grid.x <= x2; grid.x++) {
      sqinfo_on(square(c, grid)->info, SQUARE_ROOM);
      if (light) sqinfo_on(square(c, grid)->info, SQUARE_GLOW);
    }
}
STATIC_OVL void
generate_mark(struct chunk* c, int y1, int x1, int y2, int x2, int flag)
{
  struct loc grid;
  for (grid.y = y1; grid.y <= y2; grid.y++) {
    for (grid.x = x1; grid.x <= x2; grid.x++) {
      sqinfo_on(square(c, grid)->info, flag);
    }
  }
}
STATIC_OVL void
fill_rectangle(struct chunk* c, int y1, int x1, int y2, int x2, int feat,
               int flag)
{
  int y, x;
  for (y = y1; y <= y2; y++)
    for (x = x1; x <= x2; x++) square_set_feat(c, loc(x, y), feat);
  if (flag) generate_mark(c, y1, x1, y2, x2, flag);
}
STATIC_OVL void
draw_rectangle(struct chunk* c, int y1, int x1, int y2, int x2, int feat,
               int flag, bool overwrite_perm)
{
  int y, x;
  for (y = y1; y <= y2; y++) {
    if (overwrite_perm || !square_isperm(c, loc(x1, y))) {
      square_set_feat(c, loc(x1, y), feat);
    }
    if (overwrite_perm || !square_isperm(c, loc(x2, y))) {
      square_set_feat(c, loc(x2, y), feat);
    }
  }
  if (flag) {
    generate_mark(c, y1, x1, y2, x1, flag);
    generate_mark(c, y1, x2, y2, x2, flag);
  }
  for (x = x1; x <= x2; x++) {
    if (overwrite_perm || !square_isperm(c, loc(x, y1))) {
      square_set_feat(c, loc(x, y1), feat);
    }
    if (overwrite_perm || !square_isperm(c, loc(x, y2))) {
      square_set_feat(c, loc(x, y2), feat);
    }
  }
  if (flag) {
    generate_mark(c, y1, x1, y1, x2, flag);
    generate_mark(c, y2, x1, y2, x2, flag);
  }
}
STATIC_OVL void
generate_plus(struct chunk* c, int y1, int x1, int y2, int x2, int feat,
              int flag)
{
  int y, x;
  int y0 = (y1 + y2) / 2;
  int x0 = (x1 + x2) / 2;
  assert(c);
  for (y = y1; y <= y2; y++) square_set_feat(c, loc(x0, y), feat);
  if (flag) generate_mark(c, y1, x0, y2, x0, flag);
  for (x = x1; x <= x2; x++) square_set_feat(c, loc(x, y0), feat);
  if (flag) generate_mark(c, y0, x1, y0, x2, flag);
}
STATIC_OVL void
set_marked_granite(struct chunk* c, struct loc grid, int flag)
{
  square_set_feat(c, grid, FEAT_GRANITE);
  if (flag) generate_mark(c, grid.y, grid.x, grid.y, grid.x, flag);
}
STATIC_OVL bool
build_vault(struct chunk* c, struct loc centre, struct vault* v, bool flip)
{
  const char* data = v->text;
  int x, y;
  const char* t;
  bool flip_v = false;
  bool flip_h = false;
  assert(c);
  for (t = data, y = 0; y < v->hgt; y++) {
    for (x = 0; x < v->wid; x++, t++) {
      if ((*t == 'W') && (c->depth > 12)) {
        return false;
      }
      if ((*t == '7') && (c->depth >= z_info->dun_depth - 1)) {
        return false;
      }
    }
  }
  if ((c->depth > 0) && (c->depth < z_info->dun_depth)) {
    if (one_in_(2)) flip_v = true;
    if (one_in_(2)) flip_h = true;
  }
  for (t = data, y = 0; y < v->hgt && *t; y++) {
    int ay = flip_v ? v->hgt - 1 - y : y;
    for (x = 0; x < v->wid && *t; x++, t++) {
      int ax = flip_h ? v->wid - 1 - x : x;
      struct loc grid;
      if (flip) {
        grid.x = centre.x - (v->hgt / 2) + ay;
        grid.y = centre.y - (v->wid / 2) + ax;
      } else {
        grid.x = centre.x - (v->wid / 2) + ax;
        grid.y = centre.y - (v->hgt / 2) + ay;
      }
      if (*t == ' ') continue;
      square_set_feat(c, grid, FEAT_FLOOR);
      assert(square_isempty(c, grid));
      sqinfo_on(square(c, grid)->info, SQUARE_ROOM);
      sqinfo_on(square(c, grid)->info, SQUARE_VAULT);
      switch (*t) {
        case '$':
          set_marked_granite(c, grid, SQUARE_WALL_OUTER);
          break;
        case '#':
          set_marked_granite(c, grid, SQUARE_WALL_INNER);
          break;
        case '%':
          square_set_feat(c, grid, FEAT_QUARTZ);
          break;
        case ':':
          square_set_feat(c, grid, FEAT_RUBBLE);
          break;
        case ';':
          square_add_glyph(c, grid, GLYPH_WARDING);
          break;
        case '<':
          square_set_feat(c, grid, FEAT_LESS);
          break;
        case '>':
          square_set_feat(c, grid, FEAT_MORE);
          break;
        case '+':
          place_closed_door(c, grid);
          break;
        case 's':
          place_secret_door(c, grid);
          break;
        case '^':
          if (one_in_(2)) square_add_trap(c, grid);
          break;
        case '0':
          place_forge(c, grid);
          break;
        case '7':
          square_set_feat(c, grid, FEAT_CHASM);
          break;
      }
    }
  }
  for (t = data, y = 0; y < v->hgt && *t; y++) {
    int ay = flip_v ? v->hgt - 1 - y : y;
    for (x = 0; x < v->wid && *t; x++, t++) {
      int ax = flip_h ? v->wid - 1 - x : x;
      struct loc grid;
      struct monster_group_info info = {0, 0};
      if (flip) {
        grid.x = centre.x - (v->hgt / 2) + ay;
        grid.y = centre.y - (v->wid / 2) + ax;
      } else {
        grid.x = centre.x - (v->wid / 2) + ax;
        grid.y = centre.y - (v->hgt / 2) + ay;
      }
      if (*t == ' ') continue;
      switch (*t) {
        case '1': {
          pick_and_place_monster(c, grid, c->depth + 1, true, true,
                                 ORIGIN_DROP_VAULT);
          break;
        }
        case '2': {
          pick_and_place_monster(c, grid, c->depth + 2, true, true,
                                 ORIGIN_DROP_VAULT);
          break;
        }
        case '3': {
          pick_and_place_monster(c, grid, c->depth + 3, true, true,
                                 ORIGIN_DROP_VAULT);
          break;
        }
        case '4': {
          pick_and_place_monster(c, grid, c->depth + 4, true, true,
                                 ORIGIN_DROP_VAULT);
          break;
        }
        case '*': {
          place_object(c, grid, c->depth + randint1(4), false, false,
                       ORIGIN_VAULT, lookup_drop("not useless"));
          break;
        }
        case '&': {
          place_object(c, grid, c->depth + randint1(4), true, false,
                       ORIGIN_VAULT, lookup_drop("not useless"));
          break;
        }
        case '~': {
          int depth = c->depth ? c->depth + 4 : z_info->dun_depth;
          place_object(c, grid, depth, false, false, ORIGIN_VAULT,
                       lookup_drop("chest"));
          break;
        }
        case 'S': {
          if (one_in_(2)) {
            struct object* obj = object_new();
            int sval;
            struct object_kind* kind;
            if (one_in_(3)) {
              sval = lookup_sval(TV_USELESS, "Human Skeleton");
            } else {
              sval = lookup_sval(TV_USELESS, "Elf Skeleton");
            }
            kind = lookup_kind(TV_USELESS, sval);
            object_prep(obj, kind, c->depth, RANDOMISE);
            drop_near(c, &obj, 0, grid, false, false);
          }
          break;
        }
        case '?': {
          int r = randint1(3);
          if (r <= 2) {
            pick_and_place_monster(c, grid, c->depth + 1, true, true,
                                   ORIGIN_DROP_VAULT);
          }
          if (r >= 2) {
            place_object(c, grid, c->depth + 1, false, false, ORIGIN_VAULT,
                         NULL);
          }
          break;
        }
        case 'C': {
          place_new_monster_one(c, grid, lookup_monster("Carcharoth"), true,
                                true, info, ORIGIN_DROP_VAULT);
          break;
        }
        case 'H': {
          place_new_monster_one(c, grid, lookup_monster("Silent watcher"), true,
                                false, info, ORIGIN_DROP_VAULT);
          break;
        }
        case '@': {
          place_new_monster_one(c, grid, lookup_monster("Easterling spy"), true,
                                false, info, ORIGIN_DROP_VAULT);
          break;
        }
        case 'o': {
          place_new_monster_one(c, grid, lookup_monster("Orc champion"), true,
                                false, info, ORIGIN_DROP_VAULT);
          break;
        }
        case 'O': {
          place_new_monster_one(c, grid, lookup_monster("Orc captain"), true,
                                false, info, ORIGIN_DROP_VAULT);
          break;
        }
        case 'f': {
          place_new_monster_one(c, grid, lookup_monster("Cat warrior"), true,
                                false, info, ORIGIN_DROP_VAULT);
          break;
        }
        case 'F': {
          place_new_monster_one(c, grid, lookup_monster("Cat assassin"), true,
                                false, info, ORIGIN_DROP_VAULT);
          break;
        }
        case 'T': {
          place_new_monster_one(c, grid, lookup_monster("Troll guard"), true,
                                false, info, ORIGIN_DROP_VAULT);
          break;
        }
        case 'W': {
          place_new_monster_one(c, grid, lookup_monster("Barrow wight"), true,
                                false, info, ORIGIN_DROP_VAULT);
          break;
        }
        case 'd': {
          place_monster_by_flag(c, grid, RF_DRAGON, -1, true, c->depth + 4,
                                false);
          break;
        }
        case 'y': {
          place_new_monster_one(c, grid, lookup_monster("Young cold-drake"),
                                true, false, info, ORIGIN_DROP_VAULT);
          break;
        }
        case 'Y': {
          place_new_monster_one(c, grid, lookup_monster("Young fire-drake"),
                                true, false, info, ORIGIN_DROP_VAULT);
          break;
        }
        case 'M': {
          place_monster_by_flag(c, grid, RF_SPIDER, -1, true,
                                c->depth + rand_range(1, 4), false);
          break;
        }
        case 'v': {
          place_monster_by_letter(c, grid, 'v', true,
                                  c->depth + rand_range(1, 4));
          break;
        }
        case 'a': {
          place_monster_by_flag(c, grid, RSF_ARROW1, RSF_ARROW2, true,
                                c->depth + 1, true);
          break;
        }
        case 'b': {
          place_monster_by_flag(c, grid, RF_FLYING, -1, true, c->depth + 1,
                                false);
          break;
        }
        case 'c': {
          place_monster_by_flag(c, grid, RF_WOLF, -1, true,
                                c->depth + rand_range(1, 4), false);
          break;
        }
        case 'r': {
          place_monster_by_flag(c, grid, RF_RAUKO, -1, true,
                                c->depth + rand_range(1, 4), false);
          break;
        }
        case 'A': {
          place_new_monster_one(c, grid, lookup_monster("Aldor"), true, true,
                                info, ORIGIN_DROP_VAULT);
          break;
        }
        case 'D': {
          place_new_monster_one(c, grid, lookup_monster("Glaurung"), true, true,
                                info, ORIGIN_DROP_VAULT);
          break;
        }
        case 'R': {
          place_new_monster_one(c, grid, lookup_monster("Gothmog"), true, true,
                                info, ORIGIN_DROP_VAULT);
          break;
        }
        case 'U': {
          place_new_monster_one(c, grid, lookup_monster("Ungoliant"), true,
                                true, info, ORIGIN_DROP_VAULT);
          break;
        }
        case 'G': {
          place_new_monster_one(c, grid, lookup_monster("Gorthaur"), true, true,
                                info, ORIGIN_DROP_VAULT);
          break;
        }
        case 'V': {
          place_new_monster_one(c, grid,
                                lookup_monster("Morgoth, Lord of Darkness"),
                                true, true, info, ORIGIN_DROP_VAULT);
          break;
        }
      }
    }
  }
  for (t = data, y = 0; y < v->hgt && *t; y++) {
    int ay = flip_v ? v->hgt - 1 - y : y;
    for (x = 0; x < v->wid && *t; x++, t++) {
      int ax = flip_h ? v->wid - 1 - x : x;
      struct loc grid;
      int mult;
      if (flip) {
        grid.x = centre.x - (v->hgt / 2) + ay;
        grid.y = centre.y - (v->wid / 2) + ax;
      } else {
        grid.x = centre.x - (v->wid / 2) + ax;
        grid.y = centre.y - (v->hgt / 2) + ay;
      }
      if (*t == ' ') continue;
      if (roomf_has(v->flags, ROOMF_LIGHT)) {
        sqinfo_on(square(c, grid)->info, SQUARE_GLOW);
      }
      mult = roomf_has(v->flags, ROOMF_TRAPS) ? 10 : 5;
      if (randint1(1000) <= trap_placement_chance(c, grid) * (mult - 1)) {
        square_add_trap(c, grid);
      } else if (roomf_has(v->flags, ROOMF_WEBS) && one_in_(20)) {
        square_add_web(c, grid);
        if (one_in_(2)) {
          struct trap* trap = square_trap(c, grid);
          trf_on(trap->flags, TRF_INVISIBLE);
        }
      }
    }
  }
  return true;
}
STATIC_OVL bool
build_vault_type(struct chunk* c, struct loc centre, const char* typ,
                 bool forge)
{
  bool flip_d;
  int y1, x1, y2, x2;
  struct vault* v = random_vault(c->depth, typ, forge);
  if (v == NULL) {
    return false;
  }
  flip_d = one_in_(3) && !roomf_has(v->flags, ROOMF_NO_ROTATION);
  if (flip_d) {
    y1 = centre.y - (v->wid / 2);
    x1 = centre.x - (v->hgt / 2);
    y2 = y1 + v->wid - 1;
    x2 = x1 + v->hgt - 1;
  } else {
    y1 = centre.y - (v->hgt / 2);
    x1 = centre.x - (v->wid / 2);
    y2 = y1 + v->hgt - 1;
    x2 = x1 + v->wid - 1;
  }
  if ((y1 <= 3) || (x1 <= 3) || (y2 >= c->height - 3) || (x2 >= c->width - 3)) {
    return false;
  }
  if (!solid_rock(c, y1 - 2, x1 - 2, y2 + 2, x2 + 2)) {
    return false;
  }
  if (!build_vault(c, centre, v, flip_d)) {
    return false;
  }
  dun->corner[dun->cent_n].top_left = loc(x1 + 1, y1 + 1);
  dun->corner[dun->cent_n].bottom_right = loc(x2 - 1, y2 - 1);
  dun->cent[dun->cent_n] = centre;
  dun->cent_n++;
  ROOM_LOG("%s (%s)", typ, v->name);
  if (streq(typ, "Greater vault")) {
    player->vaults[v->index] = true;
    generate_mark(c, y1, x1, y2, x2, SQUARE_G_VAULT);
    assert(!c->vault_name);
    c->vault_name = string_make(v->name);
  }
  return true;
}
STATIC_OVL bool
build_simple(struct chunk* c, struct loc centre)
{
  int y, x, y1, x1, y2, x2;
  bool light = false;
  if ((c->depth < randint1(z_info->dun_depth - 1)) ||
      (c->depth < randint1(z_info->dun_depth - 1))) {
    light = true;
  }
  y1 = centre.y - randint1(3);
  x1 = centre.x - randint1(5);
  y2 = centre.y + randint1(3);
  x2 = centre.x + randint1(4) + 1;
  if (y1 <= 3 || (x1 <= 3) || (y2 >= c->height - 3) || (x2 >= c->width - 3)) {
    return false;
  }
  if (!solid_rock(c, y1 - 1, x1 - 1, y2 + 1, x2 + 1)) {
    return false;
  }
  if (doubled_wall(c, y1, x1, y2, x2)) {
    return false;
  }
  dun->corner[dun->cent_n].top_left = loc(x1, y1);
  dun->corner[dun->cent_n].bottom_right = loc(x2, y2);
  dun->cent[dun->cent_n] = centre;
  dun->cent_n++;
  generate_room(c, y1 - 1, x1 - 1, y2 + 1, x2 + 1, light);
  draw_rectangle(c, y1 - 1, x1 - 1, y2 + 1, x2 + 1, FEAT_GRANITE,
                 SQUARE_WALL_OUTER, false);
  fill_rectangle(c, y1, x1, y2, x2, FEAT_FLOOR, SQUARE_NONE);
  if (one_in_(20) && ((x2 - x1) % 2 == 0) && ((y2 - y1) % 2 == 0)) {
    event_signal_string(EVENT_GEN_ROOM_CHOOSE_SUBTYPE, "pillared");
    for (y = y1 + 1; y <= y2; y += 2) {
      for (x = x1 + 1; x <= x2; x += 2) {
        set_marked_granite(c, loc(x, y), SQUARE_WALL_INNER);
      }
    }
  } else if (one_in_(10) && ((x2 - x1) % 2 == 0) && ((y2 - y1) % 2 == 0)) {
    event_signal_string(EVENT_GEN_ROOM_CHOOSE_SUBTYPE, "ragged");
    for (y = y1 + 1; y <= y2; y += 2) {
      for (x = x1 + 1; x <= x2; x += 2) {
        if ((x == x1 + 1) || (x == x2 - 1) || (y == y1 + 1) || (y == y2 - 1)) {
          set_marked_granite(c, loc(x, y), SQUARE_WALL_INNER);
        }
      }
    }
  }
  return true;
}
STATIC_OVL bool
build_crossed(struct chunk* c, struct loc centre)
{
  int y, x;
  int y1h, x1h, y2h, x2h;
  int y1v, x1v, y2v, x2v;
  int h_hgt, h_wid, v_hgt, v_wid;
  int light = false;
  if (c->depth <= randint1(z_info->dun_depth - 1)) light = true;
  h_hgt = 1;
  h_wid = rand_range(5, 7);
  y1h = centre.y - h_hgt;
  x1h = centre.x - h_wid;
  y2h = centre.y + h_hgt;
  x2h = centre.x + h_wid;
  v_hgt = rand_range(3, 6);
  v_wid = rand_range(1, 2);
  y1v = centre.y - v_hgt;
  x1v = centre.x - v_wid;
  y2v = centre.y + v_hgt;
  x2v = centre.x + v_wid;
  if ((y1v <= 3) || (x1h <= 3) || (y2v >= c->height - 3) ||
      (x2h >= c->width - 3)) {
    return false;
  }
  if (!solid_rock(c, y1v - 1, x1h - 1, y2v + 1, x2h + 1)) {
    return false;
  }
  if (doubled_wall(c, y1v, x1h, y2v, x2h)) {
    return false;
  }
  dun->corner[dun->cent_n].top_left = loc(x1h, y1v);
  dun->corner[dun->cent_n].bottom_right = loc(x2h, y2v);
  dun->cent[dun->cent_n] = centre;
  dun->cent_n++;
  generate_room(c, y1h - 1, x1h - 1, y2h + 1, x2h + 1, light);
  generate_room(c, y1v - 1, x1v - 1, y2v + 1, x2v + 1, light);
  draw_rectangle(c, y1h - 1, x1h - 1, y2h + 1, x2h + 1, FEAT_GRANITE,
                 SQUARE_WALL_OUTER, false);
  draw_rectangle(c, y1v - 1, x1v - 1, y2v + 1, x2v + 1, FEAT_GRANITE,
                 SQUARE_WALL_OUTER, false);
  fill_rectangle(c, y1h, x1h, y2h, x2h, FEAT_FLOOR, SQUARE_NONE);
  fill_rectangle(c, y1v, x1v, y2v, x2v, FEAT_FLOOR, SQUARE_NONE);
  switch (randint1(7)) {
    case 1: {
      event_signal_string(EVENT_GEN_ROOM_CHOOSE_SUBTYPE, "chest");
      if ((v_wid == 2) && (v_hgt == 6)) {
        for (y = y1v + 1; y <= y2v; y += 2) {
          for (x = x1v + 1; x <= x2v; x += 2) {
            set_marked_granite(c, loc(x, y), SQUARE_WALL_INNER);
          }
        }
        place_object(c, centre, c->depth, false, false, ORIGIN_SPECIAL,
                     lookup_drop("chest"));
      }
      break;
    }
    case 2: {
      if ((v_wid == 1) && (h_hgt == 1)) {
        event_signal_string(EVENT_GEN_ROOM_CHOOSE_SUBTYPE, "plus");
        generate_plus(c, centre.y - 1, centre.x - 1, centre.y + 1, centre.x + 1,
                      FEAT_GRANITE, SQUARE_WALL_INNER);
      }
      break;
    }
    case 3: {
      if ((v_wid == 1) && (h_hgt == 1)) {
        event_signal_string(EVENT_GEN_ROOM_CHOOSE_SUBTYPE, "pinched");
        set_marked_granite(c, loc(centre.x - 1, centre.y - 1),
                           SQUARE_WALL_INNER);
        set_marked_granite(c, loc(centre.x - 1, centre.y + 1),
                           SQUARE_WALL_INNER);
        set_marked_granite(c, loc(centre.x + 1, centre.y - 1),
                           SQUARE_WALL_INNER);
        set_marked_granite(c, loc(centre.x + 1, centre.y + 1),
                           SQUARE_WALL_INNER);
      }
      break;
    }
    case 4: {
      if ((v_wid == 1) && (h_hgt == 1)) {
        event_signal_string(EVENT_GEN_ROOM_CHOOSE_SUBTYPE, "hollow plus");
        set_marked_granite(c, loc(centre.x - 1, centre.y), SQUARE_WALL_INNER);
        set_marked_granite(c, loc(centre.x + 1, centre.y), SQUARE_WALL_INNER);
        set_marked_granite(c, loc(centre.x, centre.y - 1), SQUARE_WALL_INNER);
        set_marked_granite(c, loc(centre.x, centre.y + 1), SQUARE_WALL_INNER);
      }
      break;
    }
    default: {
      break;
    }
  }
  return true;
}
STATIC_OVL bool
build_interesting(struct chunk* c, struct loc centre)
{
  return build_vault_type(c, centre, "Interesting room",
                          player->upkeep->force_forge);
}
STATIC_OVL bool
build_lesser_vault(struct chunk* c, struct loc centre)
{
  return build_vault_type(c, centre, "Lesser vault", false);
}
STATIC_OVL bool
build_greater_vault(struct chunk* c, struct loc centre)
{
  if (c->vault_name) {
    return false;
  }
  return build_vault_type(c, centre, "Greater vault", false);
}
STATIC_OVL bool
build_throne(struct chunk* c, struct loc centre)
{
  int y1, x1, y2, x2;
  struct vault* v = random_vault(c->depth, "Throne room", false);
  if (v == NULL) {
    return false;
  }
  centre = loc(c->width / 2, c->height / 2);
  y1 = centre.y - (v->hgt / 2);
  x1 = centre.x - (v->wid / 2);
  y2 = y1 + v->hgt - 1;
  x2 = x1 + v->wid - 1;
  if (!build_vault(c, centre, v, false)) {
    return false;
  }
  generate_mark(c, y1, x1, y2, x2, SQUARE_G_VAULT);
  assert(!c->vault_name);
  c->vault_name = string_make(v->name);
  return true;
}
STATIC_OVL bool
build_gates(struct chunk* c, struct loc centre)
{
  int y1, x1, y2, x2;
  struct vault* v = random_vault(c->depth, "Gates of Angband", false);
  if (v == NULL) {
    return false;
  }
  centre = loc(c->width / 2, c->height / 2);
  y1 = centre.y - (v->hgt / 2);
  x1 = centre.x - (v->wid / 2);
  y2 = y1 + v->hgt - 1;
  x2 = x1 + v->wid - 1;
  if (!build_vault(c, centre, v, false)) {
    return false;
  }
  generate_mark(c, y1, x1, y2, x2, SQUARE_G_VAULT);
  assert(!c->vault_name);
  c->vault_name = string_make(v->name);
  return true;
}
STATIC_OVL bool
room_build(struct chunk* c, struct room_profile profile)
{
  struct loc centre =
      loc(rand_range(5, c->width - 5), rand_range(5, c->height - 5));
  if (dun->cent_n >= z_info->level_room_max) {
    return false;
  }
  event_signal_string(EVENT_GEN_ROOM_START, profile.name);
  while (!profile.builder(c, centre)) {
    centre = loc(rand_range(5, c->width - 5), rand_range(5, c->height - 5));
    if (!player->upkeep->force_forge) {
      event_signal_flag(EVENT_GEN_ROOM_END, false);
      return false;
    }
  }
  event_signal_flag(EVENT_GEN_ROOM_END, true);
  return true;
}
STATIC_OVL int*
cave_find_init(struct loc top_left, struct loc bottom_right)
{
  struct loc diff = loc_diff(bottom_right, top_left);
  int n = (diff.y < 0 || diff.x < 0) ? 0 : (diff.x + 1) * (diff.y + 1);
  int* state = mem_alloc((5 + n) * sizeof(*state));
  int i;
  state[0] = n;
  state[1] = diff.x + 1;
  state[2] = top_left.x;
  state[3] = top_left.y;
  state[4] = 0;
  for (i = 5; i < 5 + n; ++i) {
    state[i] = i - 5;
  }
  return state;
}
STATIC_OVL void
cave_find_reset(int* state)
{
  state[4] = 0;
}
STATIC_OVL bool
cave_find_get_grid(struct loc* grid, int* state)
{
  int j, k;
  assert(state[4] >= 0);
  if (state[4] >= state[0]) return false;
  j = randint0(state[0] - state[4]) + state[4];
  k = state[5 + j];
  state[5 + j] = state[5 + state[4]];
  state[5 + state[4]] = k;
  grid->y = (k / state[1]) + state[3];
  grid->x = (k % state[1]) + state[2];
  ++state[4];
  return true;
}
STATIC_OVL bool
cave_find_in_range(struct chunk* c, struct loc* grid, struct loc top_left,
                   struct loc bottom_right, square_predicate pred)
{
  int* state = cave_find_init(top_left, bottom_right);
  bool found = false;
  while (!found && cave_find_get_grid(grid, state)) {
    found = pred(c, *grid);
  }
  mem_free(state);
  return found;
}
STATIC_OVL bool
cave_find(struct chunk* c, struct loc* grid, square_predicate pred)
{
  struct loc top_left = loc(0, 0);
  struct loc bottom_right = loc(c->width - 1, c->height - 1);
  return cave_find_in_range(c, grid, top_left, bottom_right, pred);
}
STATIC_OVL bool
find_empty(struct chunk* c, struct loc* grid)
{
  return cave_find(c, grid, square_isempty);
}
STATIC_OVL bool
find_empty_range(struct chunk* c, struct loc* grid, struct loc top_left,
                 struct loc bottom_right)
{
  return cave_find_in_range(c, grid, top_left, bottom_right, square_isempty);
}
STATIC_OVL bool
find_nearby_grid(struct chunk* c, struct loc* grid, struct loc centre, int yd,
                 int xd)
{
  struct loc top_left = loc(centre.x - xd, centre.y - yd);
  struct loc bottom_right = loc(centre.x + xd, centre.y + yd);
  return cave_find_in_range(c, grid, top_left, bottom_right,
                            square_in_bounds_fully);
}
STATIC_OVL void
place_rubble(struct chunk* c, struct loc grid)
{
  if (c->depth >= 4) {
    square_set_feat(c, grid, FEAT_RUBBLE);
  }
}
STATIC_OVL int
choose_up_stairs(struct chunk* c)
{
  if (c->depth >= 2) {
    if (one_in_(2)) return FEAT_LESS_SHAFT;
  }
  return FEAT_LESS;
}
STATIC_OVL int
choose_down_stairs(struct chunk* c)
{
  if (c->depth < z_info->dun_depth - 2) {
    if (one_in_(2)) return FEAT_MORE_SHAFT;
  }
  return FEAT_MORE;
}
STATIC_OVL void
place_stairs(struct chunk* c, struct loc grid, bool first, int feat)
{
  if (!c->depth) {
    square_set_feat(c, grid, FEAT_MORE);
  } else if (c->depth >= z_info->dun_depth) {
    if (first) {
      square_set_feat(c, grid, FEAT_LESS);
    } else {
      square_set_feat(c, grid, choose_up_stairs(c));
    }
  } else {
    if (!first) {
      if (feat == FEAT_LESS) {
        feat = choose_up_stairs(c);
      } else if (feat == FEAT_MORE) {
        feat = choose_down_stairs(c);
      }
    }
    square_set_feat(c, grid, feat);
  }
}
STATIC_OVL void
place_item_near_player(struct chunk* c, struct player* p, int tval,
                       const char* name)
{
  struct loc grid;
  int count = 100;
  struct object* obj;
  struct object_kind* kind;
  while (find_nearby_grid(c, &grid, p->grid, 5, 5) && count--) {
    if (square_isempty(c, grid) && square_isroom(c, grid) &&
        los(c, p->grid, grid)) {
      break;
    }
  }
  obj = object_new();
  kind = lookup_kind(tval, lookup_sval(tval, name));
  if (!kind) return;
  object_prep(obj, kind, c->depth, RANDOMISE);
  if (tval == TV_ARROW) {
    obj->number = 24;
  } else {
    obj->number = 1;
  }
  drop_near(c, &obj, 0, grid, false, false);
}
STATIC_OVL void
place_object(struct chunk* c, struct loc grid, int level, bool good, bool great,
             uint8_t origin, struct drop* drop)
{
  struct object* new_obj;
  bool dummy = true;
  if (!square_in_bounds(c, grid)) return;
  if (!square_canputitem(c, grid)) return;
  new_obj = make_object(c, level, good, great, drop);
  if (!new_obj) return;
  new_obj->origin = origin;
  new_obj->origin_depth = convert_depth_to_origin(c->depth);
  if (!floor_carry(c, grid, new_obj, &dummy)) {
    if (new_obj->artifact) {
      mark_artifact_created(new_obj->artifact, false);
    }
    object_delete(c, NULL, &new_obj);
    return;
  } else {
    list_object(c, new_obj);
  }
}
STATIC_OVL void
place_secret_door(struct chunk* c, struct loc grid)
{
  square_set_feat(c, grid, FEAT_SECRET);
}
STATIC_OVL void
place_closed_door(struct chunk* c, struct loc grid)
{
  int value = randint0(100);
  square_set_feat(c, grid, FEAT_CLOSED);
  if (square_isvault(c, grid)) {
    int power = (10 + c->depth + randint1(15)) / 5;
    power = MIN(7, power);
    if (value < 4) {
      square_set_door_lock(c, grid, power);
    } else if (value < 8) {
      square_set_door_jam(c, grid, power);
    }
  } else {
    int power = (c->depth + randint1(15)) / 5;
    power = MIN(7, power);
    if (value < 24) {
      square_set_door_lock(c, grid, power);
    } else if (value < 25) {
      square_set_door_jam(c, grid, power);
    }
  }
}
STATIC_OVL void
place_random_door(struct chunk* c, struct loc grid)
{
  int tmp = randint0(60 + c->depth);
  if (tmp < 20) {
    square_set_feat(c, grid, FEAT_OPEN);
  } else if (tmp < 60) {
    place_closed_door(c, grid);
  } else {
    place_secret_door(c, grid);
  }
}
STATIC_OVL void
place_forge(struct chunk* c, struct loc grid)
{
  int i;
  int effective_depth = c->depth;
  int power = 1;
  int uses = damroll(2, 2);
  if (square_isgreatervault(c, grid)) {
    effective_depth *= 2;
  }
  for (i = 0; i < effective_depth; i++) {
    int p = randint1(1000);
    power = MAX(power, p);
  }
  if (c->depth <= 2) {
    uses = 3;
    power = 0;
  }
  if ((power >= 1000) && !player->unique_forge_made) {
    uses = 3;
    square_set_feat(c, grid, FEAT_FORGE_UNIQUE);
    square_set_forge(c, grid, uses);
    player->unique_forge_made = true;
    if (OPT(player, cheat_room)) msg("Orodruth.");
  } else if (power >= 990) {
    square_set_feat(c, grid, FEAT_FORGE_GOOD);
    square_set_forge(c, grid, uses);
    if (OPT(player, cheat_room)) msg("Enchanted forge.");
  } else {
    square_set_feat(c, grid, FEAT_FORGE);
    square_set_forge(c, grid, uses);
    if (OPT(player, cheat_room)) msg("Forge.");
  }
}
STATIC_OVL void
alloc_stairs(struct chunk* c, int feat, int num)
{
  int i = 0;
  if (dun->cent_n == 4) {
    num = 1;
  } else if (num > (dun->cent_n / 2)) {
    num = dun->cent_n / 2;
  }
  while (i < num) {
    struct loc grid;
    bool first = (i == 0);
    cave_find(c, &grid, square_suits_stairs);
    place_stairs(c, grid, first, feat);
    assert(square_isstairs(c, grid) || (!first && square_isshaft(c, grid)));
    ++i;
  }
}
STATIC_OVL bool
stairs_within_los(struct chunk* c, struct loc grid0)
{
  int y, x;
  for (y = grid0.y - 15; y < grid0.y + 15; y++) {
    for (x = grid0.x - 15; x < grid0.x + 15; x++) {
      struct loc grid = loc(x, y);
      if (!square_in_bounds_fully(c, grid)) continue;
      if (!los(c, grid0, grid)) continue;
      if (square_isstairs(c, grid)) {
        return true;
      }
    }
  }
  return false;
}
STATIC_OVL bool
find_start(struct chunk* c, struct loc* grid)
{
  int* state = cave_find_init(loc(1, 1), loc(c->width - 2, c->height - 2));
  bool found = false;
  int count = 100;
  while (!found && cave_find_get_grid(grid, state) && count--) {
    found = square_suits_start(c, *grid);
    if ((player->turn == 0) && !square_isroom(c, *grid)) found = false;
    if (stairs_within_los(c, *grid) && player->upkeep->create_stair) {
      found = false;
    }
  }
  mem_free(state);
  return found;
}
STATIC_OVL bool
new_player_spot(struct chunk* c, struct player* p)
{
  struct loc grid;
  if (!find_start(c, &grid)) {
    msg("Failed to place player; please report.  Restarting generation.");
    dump_level_simple(NULL, "Player Placement Failure", c);
    return false;
  }
  if (p->upkeep->create_stair == FEAT_RUBBLE) {
    effect_simple(EF_EARTHQUAKE, source_grid(grid), "0", 0, 5, 0, NULL);
  }
  if (p->upkeep->create_stair && square_changeable(c, grid)) {
    object_pile_free(c, NULL, square_object(c, grid));
    square_set_feat(c, grid, p->upkeep->create_stair);
  }
  player_place(c, p, grid);
  return true;
}
STATIC_OVL int
trap_placement_chance(struct chunk* c, struct loc grid)
{
  int chance = 0;
  if (square_isfloor(c, grid) && square_isroom(c, grid) &&
      !square_object(c, grid)) {
    int y, x, d;
    chance = 1;
    for (y = grid.y - 1; y <= grid.y + 1; y++) {
      for (x = grid.x - 1; x <= grid.x + 1; x++) {
        struct loc check = loc(x, y);
        if (loc_eq(grid, check)) continue;
        if (square_object(c, check)) chance += 10;
        if (square_isstairs(c, check)) chance += 10;
        if (square_iscloseddoor(c, check)) chance += 10;
      }
    }
    for (d = 0; d < 4; d += 2) {
      struct loc adj1 = loc_sum(grid, ddgrid_ddd[d]);
      struct loc adj2 = loc_sum(grid, ddgrid_ddd[d + 1]);
      if (square_isimpassable(c, adj1) && square_isimpassable(c, adj2)) {
        chance += 10;
      }
    }
  }
  return chance;
}
STATIC_OVL void
place_traps(struct chunk* c)
{
  struct loc grid;
  for (grid.y = 0; grid.y < c->height; grid.y++) {
    for (grid.x = 0; grid.x < c->width; grid.x++) {
      if (randint1(1000) <= trap_placement_chance(c, grid)) {
        square_add_trap(c, grid);
      }
    }
  }
}
STATIC_OVL int
alloc_object(struct chunk* c, int set, int typ, int num, int depth,
             uint8_t origin)
{
  int nrem = num;
  int* state = cave_find_init(loc(1, 1), loc(c->width - 2, c->height - 2));
  struct loc grid;
  while (nrem > 0 && cave_find_get_grid(&grid, state)) {
    bool matched = ((set & SET_CORR) && !square_isroom(c, grid)) ||
                   ((set & SET_ROOM) && square_isroom(c, grid));
    if (square_isempty(c, grid) && matched) {
      switch (typ) {
        case TYP_RUBBLE:
          place_rubble(c, grid);
          break;
        case TYP_OBJECT:
          place_object(c, grid, depth, false, false, origin, 0);
          break;
      }
      --nrem;
    }
  }
  mem_free(state);
  return num - nrem;
}
STATIC_OVL struct room_profile
lookup_room_profile(const char* name)
{
  int num_rooms = dun->profile->n_room_profiles;
  struct room_profile profile;
  int i;
  for (i = 1; i < num_rooms; i++) {
    profile = dun->profile->room_profiles[i];
    if (streq(profile.name, name)) {
      return profile;
    }
  }
  return dun->profile->room_profiles[0];
}
STATIC_OVL void
uncreate_artifacts(struct chunk* c)
{
  int y, x;
  for (y = 0; y < c->height; y++) {
    for (x = 0; x < c->width; x++) {
      struct loc grid = loc(x, y);
      struct object* obj = square_object(c, grid);
      while (obj) {
        if (obj->artifact) {
          mark_artifact_created(obj->artifact, false);
        }
        obj = obj->next;
      }
    }
  }
}
STATIC_OVL void
uncreate_greater_vaults(struct chunk* c, struct player* p)
{
  const struct vault* v;
  if (!c->vault_name) return;
  for (v = vaults; v; v = v->next) {
    if (streq(v->typ, "Greater vault") && streq(c->vault_name, v->name)) {
      p->vaults[v->index] = false;
      break;
    }
  }
}
STATIC_OVL void
chunk_validate_objects(struct chunk* c)
{
  int x, y;
  struct object* obj;
  for (y = 0; y < c->height; y++) {
    for (x = 0; x < c->width; x++) {
      struct loc grid = loc(x, y);
      for (obj = square_object(c, grid); obj; obj = obj->next)
        assert(obj->tval != 0);
      if (square(c, grid)->mon > 0) {
        struct monster* mon = square_monster(c, grid);
        if (mon->held_obj)
          for (obj = mon->held_obj; obj; obj = obj->next)
            assert(obj->tval != 0);
      }
    }
  }
}
STATIC_OVL void
dump_level_simple(const char* basefilename, const char* title, struct chunk* c)
{
  char path[1024];
  ang_file* fo;
  path_build(
      path, sizeof(path), ANGBAND_DIR_USER,
      (basefilename) ? format("%s.html", basefilename) : "dumpedlevel.html");
  fo = file_open(path, MODE_WRITE, FTYPE_TEXT);
  if (fo) {
    dump_level(fo, (title) ? title : "Dumped Level", c, NULL);
    if (file_close(fo)) {
      msg("Level dumped to %s.html",
          (basefilename) ? basefilename : "dumpedlevel");
    }
  }
}
STATIC_OVL void
dump_level(ang_file* fo, const char* title, struct chunk* c, int** dist)
{
  dump_level_header(fo, title);
  dump_level_body(fo, title, c, dist);
  dump_level_footer(fo);
}
STATIC_OVL void
dump_level_escaped_string(ang_file* fo, const char* s)
{
  while (*s) {
    switch (*s) {
      case '&':
        file_put(fo, "&amp;");
        break;
      case '<':
        file_put(fo, "&lt;");
        break;
      case '>':
        file_put(fo, "&gt;");
        break;
      case '\"':
        file_put(fo, "&quot;");
        break;
      default:
        file_putf(fo, "%c", *s);
        break;
    }
    ++s;
  }
}
STATIC_OVL void
dump_level_header(ang_file* fo, const char* title)
{
  file_put(fo,
           "<!DOCTYPE html>\n"
           "<html lang=\"en\" xml:lang=\"en\" "
           "xmlns=\"http://www.w3.org/1999/xhtml\">\n"
           "  <head>\n"
           "    <meta http-equiv=\"Content-Type\" content=\"text/html; "
           "charset=UTF-8\">\n"
           "    <title>");
  dump_level_escaped_string(fo, title);
  file_put(fo, "</title>\n  </head>\n  <body>\n");
}
STATIC_OVL void
dump_level_body(ang_file* fo, const char* title, struct chunk* c, int** dist)
{
  int y;
  file_put(fo, "    <p>");
  dump_level_escaped_string(fo, title);
  if (dist != NULL) {
    file_put(fo,
             "\n    <p>A location where the distance array was negative is "
             "marked with *.");
  }
  file_put(fo, "\n    <pre>\n");
  for (y = 0; y < c->height; ++y) {
    int x;
    for (x = 0; x < c->width; ++x) {
      struct loc grid = loc(x, y);
      const char* s = "#";
      if (square_in_bounds_fully(c, grid)) {
        if (square_isplayer(c, grid)) {
          s = "@";
        } else if (square_isoccupied(c, grid)) {
          s = (dist == NULL || dist[y][x] >= 0) ? "M" : "*";
        } else if (square_isdoor(c, grid)) {
          s = (dist == NULL || dist[y][x] >= 0) ? "+" : "*";
        } else if (square_isrubble(c, grid)) {
          s = (dist == NULL || dist[y][x] >= 0) ? ":" : "*";
        } else if (square_isdownstairs(c, grid)) {
          s = (dist == NULL || dist[y][x] >= 0) ? "&gt;" : "*";
        } else if (square_isupstairs(c, grid)) {
          s = (dist == NULL || dist[y][x] >= 0) ? "&lt;" : "*";
        } else if (square_isforge(c, grid)) {
          s = (dist == NULL || dist[y][x] >= 0) ? "0" : "*";
        } else if (square_ischasm(c, grid)) {
          s = (dist == NULL || dist[y][x] >= 0) ? "7" : "*";
        } else if (square_istrap(c, grid) || square_isplayertrap(c, grid)) {
          s = (dist == NULL || dist[y][x] >= 0) ? "^" : "*";
        } else if (square_iswebbed(c, grid)) {
          s = (dist == NULL || dist[y][x] >= 0) ? "w" : "*";
        } else if (square_object(c, grid)) {
          s = (dist == NULL || dist[y][x] >= 0) ? "$" : "*";
        } else if (square_isempty(c, grid) && square_isvault(c, grid)) {
          s = (dist == NULL || dist[y][x] >= 0) ? " " : "*";
        } else if (square_ispassable(c, grid)) {
          s = (dist == NULL || dist[y][x] >= 0) ? "." : "*";
        }
      }
      file_put(fo, s);
    }
    file_put(fo, "\n");
  }
  file_put(fo, "    </pre>\n");
}
STATIC_OVL void
dump_level_footer(ang_file* fo)
{
  file_put(fo, "  </body>\n</html>\n");
}
STATIC_OVL enum parser_error
parse_graf_name(struct parser* p)
{
  graphics_mode* list = parser_priv(p);
  graphics_mode* mode = mem_zalloc(sizeof(graphics_mode));
  if (!mode) {
    return PARSE_ERROR_OUT_OF_MEMORY;
  }
  mode->pNext = list;
  mode->grafID = parser_getuint(p, "index");
  my_strcpy(mode->menuname, parser_getstr(p, "menuname"), 32);
  mode->alphablend = 0;
  mode->overdrawRow = 0;
  mode->overdrawMax = 0;
  my_strcpy(mode->file, "", 32);
  my_strcpy(mode->pref, "none", 32);
  parser_setpriv(p, mode);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_graf_directory(struct parser* p)
{
  graphics_mode* mode = parser_priv(p);
  const char* dir = parser_getsym(p, "dirname");
  if (!mode) {
    return PARSE_ERROR_INVALID_VALUE;
  }
  path_build(mode->path, sizeof(mode->path), ANGBAND_DIR_TILES, dir);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_graf_size(struct parser* p)
{
  graphics_mode* mode = parser_priv(p);
  if (!mode) {
    return PARSE_ERROR_INVALID_VALUE;
  }
  mode->cell_width = parser_getuint(p, "wid");
  mode->cell_height = parser_getuint(p, "hgt");
  my_strcpy(mode->file, parser_getstr(p, "filename"), 32);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_graf_pref(struct parser* p)
{
  graphics_mode* mode = parser_priv(p);
  if (!mode) {
    return PARSE_ERROR_INVALID_VALUE;
  }
  my_strcpy(mode->pref, parser_getstr(p, "prefname"), 32);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_graf_extra(struct parser* p)
{
  graphics_mode* mode = parser_priv(p);
  if (!mode) {
    return PARSE_ERROR_INVALID_VALUE;
  }
  mode->alphablend = parser_getuint(p, "alpha");
  mode->overdrawRow = parser_getuint(p, "row");
  mode->overdrawMax = parser_getuint(p, "max");
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_parse_grafmode(void)
{
  struct parser* p = parser_new();
  parser_setpriv(p, NULL);
  parser_reg(p, "name uint index str menuname", parse_graf_name);
  parser_reg(p, "directory sym dirname", parse_graf_directory);
  parser_reg(p, "size uint wid uint hgt str filename", parse_graf_size);
  parser_reg(p, "pref str prefname", parse_graf_pref);
  parser_reg(p, "extra uint alpha uint row uint max", parse_graf_extra);
  return p;
}
STATIC_OVL errr
finish_parse_grafmode(struct parser* p)
{
  graphics_mode *mode, *n;
  int max = 0;
  int count = 0;
  int i;
  if (p) {
    mode = parser_priv(p);
    while (mode) {
      if (mode->grafID > max) {
        max = mode->grafID;
      }
      count++;
      mode = mode->pNext;
    }
  }
  if (graphics_modes) {
    close_graphics_modes();
  }
  graphics_modes = mem_zalloc(sizeof(graphics_mode) * (count + 1));
  if (p) {
    mode = parser_priv(p);
    for (i = count - 1; i >= 0; i--, mode = mode->pNext) {
      memcpy(&(graphics_modes[i]), mode, sizeof(graphics_mode));
      graphics_modes[i].pNext = &(graphics_modes[i + 1]);
    }
  }
  graphics_modes[count].pNext = NULL;
  graphics_modes[count].grafID = GRAPHICS_NONE;
  graphics_modes[count].alphablend = 0;
  graphics_modes[count].overdrawRow = 0;
  graphics_modes[count].overdrawMax = 0;
  my_strcpy(graphics_modes[count].pref, "none", 8);
  my_strcpy(graphics_modes[count].path, "", 32);
  my_strcpy(graphics_modes[count].file, "", 32);
  my_strcpy(graphics_modes[count].menuname, "None", 32);
  graphics_mode_high_id = max;
  current_graphics_mode = &(graphics_modes[count]);
  if (p) {
    mode = parser_priv(p);
    while (mode) {
      n = mode->pNext;
      mem_free(mode);
      mode = n;
    }
    parser_setpriv(p, NULL);
    parser_destroy(p);
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL void
print_error(const char* name, struct parser* p)
{
  struct parser_state s;
  parser_getstate(p, &s);
  msg("Parse error in %s line %d column %d: %s: %s", name, s.line, s.col, s.msg,
      parser_error_str[s.error]);
  event_signal(EVENT_MESSAGE_FLUSH);
}
STATIC_OVL bool
init_graphics_modes(void)
{
  char buf[1024];
  ang_file* f;
  struct parser* p;
  errr e = 0;
  path_build(buf, sizeof(buf), ANGBAND_DIR_TILES, "list.txt");
  f = file_open(buf, MODE_READ, FTYPE_TEXT);
  if (!f) {
    msg("Cannot open '%s'.", buf);
    finish_parse_grafmode(NULL);
  } else {
    char line[1024];
    p = init_parse_grafmode();
    while (file_getl(f, line, sizeof line)) {
      e = parser_parse(p, line);
      if (e != PARSE_ERROR_NONE) {
        print_error(buf, p);
        break;
      }
    }
    finish_parse_grafmode(p);
    file_close(f);
  }
  return e == PARSE_ERROR_NONE;
}
STATIC_OVL void
close_graphics_modes(void)
{
  if (graphics_modes) {
    mem_free(graphics_modes);
    graphics_modes = NULL;
  }
}
STATIC_OVL graphics_mode*
get_graphics_mode(uint8_t id)
{
  graphics_mode* test = graphics_modes;
  while (test) {
    if (test->grafID == id) {
      return test;
    }
    test = test->pNext;
  }
  return NULL;
}
STATIC_OVL int
is_dh_tile(int a, wchar_t c)
{
  int tileset_row;
  if (!(a & 0x80) || !current_graphics_mode ||
      !current_graphics_mode->overdrawRow) {
    return 0;
  }
  tileset_row = a & 0x7f;
  return tileset_row >= current_graphics_mode->overdrawRow &&
         tileset_row <= current_graphics_mode->overdrawMax;
}
STATIC_OVL int
guid_eq(guid a, guid b)
{
  return a == b;
}
STATIC_OVL errr
grab_effect_data(struct parser* p, struct effect* effect)
{
  const char* type;
  int val;
  if (grab_name("effect", parser_getsym(p, "eff"), effect_list,
                N_ELEMENTS(effect_list), &val))
    return PARSE_ERROR_INVALID_EFFECT;
  effect->index = val;
  if (parser_hasval(p, "type")) {
    type = parser_getsym(p, "type");
    if (type == NULL) return PARSE_ERROR_UNRECOGNISED_PARAMETER;
    val = effect_subtype(effect->index, type);
    if (val < 0)
      return PARSE_ERROR_INVALID_VALUE;
    else
      effect->subtype = val;
  }
  if (parser_hasval(p, "radius")) effect->radius = parser_getint(p, "radius");
  if (parser_hasval(p, "other")) effect->other = parser_getint(p, "other");
  return PARSE_ERROR_NONE;
}
STATIC_OVL void
init_file_paths(const char* configpath, const char* libpath,
                const char* datapath)
{
  char buf[1024];
  char* userpath = NULL;
  string_free(ANGBAND_DIR_GAMEDATA);
  string_free(ANGBAND_DIR_CUSTOMIZE);
  string_free(ANGBAND_DIR_HELP);
  string_free(ANGBAND_DIR_SCREENS);
  string_free(ANGBAND_DIR_FONTS);
  string_free(ANGBAND_DIR_TILES);
  string_free(ANGBAND_DIR_SOUNDS);
  string_free(ANGBAND_DIR_ICONS);
  string_free(ANGBAND_DIR_USER);
  string_free(ANGBAND_DIR_SAVE);
  string_free(ANGBAND_DIR_PANIC);
  string_free(ANGBAND_DIR_SCORES);
  string_free(ANGBAND_DIR_ARCHIVE);
  {
    path_build(buf, sizeof(buf), (configpath), ("gamedata"));
    ANGBAND_DIR_GAMEDATA = string_make(buf);
  };
  {
    path_build(buf, sizeof(buf), (configpath), ("customize"));
    ANGBAND_DIR_CUSTOMIZE = string_make(buf);
  };
  {
    path_build(buf, sizeof(buf), (libpath), ("help"));
    ANGBAND_DIR_HELP = string_make(buf);
  };
  {
    path_build(buf, sizeof(buf), (libpath), ("screens"));
    ANGBAND_DIR_SCREENS = string_make(buf);
  };
  {
    path_build(buf, sizeof(buf), (libpath), ("fonts"));
    ANGBAND_DIR_FONTS = string_make(buf);
  };
  {
    path_build(buf, sizeof(buf), (libpath), ("tiles"));
    ANGBAND_DIR_TILES = string_make(buf);
  };
  {
    path_build(buf, sizeof(buf), (libpath), ("sounds"));
    ANGBAND_DIR_SOUNDS = string_make(buf);
  };
  {
    path_build(buf, sizeof(buf), (libpath), ("icons"));
    ANGBAND_DIR_ICONS = string_make(buf);
  };
  if (strncmp(ANGBAND_SYS, "test", 4) == 0)
    path_build(buf, sizeof(buf), "~/.angband", "Test");
  else
    path_build(buf, sizeof(buf), "~/.angband", VERSION_NAME);
  ANGBAND_DIR_USER = string_make(buf);
  {
    path_build(buf, sizeof(buf), (ANGBAND_DIR_USER), ("archive"));
    ANGBAND_DIR_ARCHIVE = string_make(buf);
  };
  userpath = ANGBAND_DIR_USER;
  {
    path_build(buf, sizeof(buf), (userpath), ("scores"));
    ANGBAND_DIR_SCORES = string_make(buf);
  };
  {
    path_build(buf, sizeof(buf), (userpath), ("save"));
    ANGBAND_DIR_SAVE = string_make(buf);
  };
  {
    path_build(buf, sizeof(buf), (userpath), ("panic"));
    ANGBAND_DIR_PANIC = string_make(buf);
  };
}
STATIC_OVL void
create_needed_dirs(void)
{
  char dirpath[512];
  path_build(dirpath, sizeof(dirpath), ANGBAND_DIR_USER, "");
  if (!dir_create(dirpath)) quit_fmt("Cannot create '%s'", dirpath);
  path_build(dirpath, sizeof(dirpath), ANGBAND_DIR_SAVE, "");
  if (!dir_create(dirpath)) quit_fmt("Cannot create '%s'", dirpath);
  path_build(dirpath, sizeof(dirpath), ANGBAND_DIR_PANIC, "");
  if (!dir_create(dirpath)) quit_fmt("Cannot create '%s'", dirpath);
  path_build(dirpath, sizeof(dirpath), ANGBAND_DIR_SCORES, "");
  if (!dir_create(dirpath)) quit_fmt("Cannot create '%s'", dirpath);
  path_build(dirpath, sizeof(dirpath), ANGBAND_DIR_ARCHIVE, "");
  if (!dir_create(dirpath)) quit_fmt("Cannot create '%s'", dirpath);
}
STATIC_OVL enum parser_error
parse_constants_level_max(struct parser* p)
{
  struct angband_constants* z;
  const char* label;
  int value;
  z = parser_priv(p);
  label = parser_getsym(p, "label");
  value = parser_getint(p, "value");
  if (value < 0) return PARSE_ERROR_INVALID_VALUE;
  if (streq(label, "monsters"))
    z->level_monster_max = value;
  else
    return PARSE_ERROR_UNDEFINED_DIRECTIVE;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_constants_mon_gen(struct parser* p)
{
  struct angband_constants* z;
  const char* label;
  int value;
  z = parser_priv(p);
  label = parser_getsym(p, "label");
  value = parser_getint(p, "value");
  if (value < 0) return PARSE_ERROR_INVALID_VALUE;
  if (streq(label, "chance"))
    z->alloc_monster_chance = value;
  else if (streq(label, "group-max"))
    z->monster_group_max = value;
  else
    return PARSE_ERROR_UNDEFINED_DIRECTIVE;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_constants_mon_play(struct parser* p)
{
  struct angband_constants* z;
  const char* label;
  int value;
  z = parser_priv(p);
  label = parser_getsym(p, "label");
  value = parser_getint(p, "value");
  if (value < 0) return PARSE_ERROR_INVALID_VALUE;
  if (streq(label, "mult-rate"))
    z->repro_monster_rate = value;
  else if (streq(label, "mana-cost"))
    z->mana_cost = value;
  else if (streq(label, "mana-max")) {
    if (value > 255) return PARSE_ERROR_INVALID_VALUE;
    z->mana_max = (uint8_t)value;
  } else if (streq(label, "flee-range")) {
    if (value > 255) return PARSE_ERROR_INVALID_VALUE;
    z->flee_range = (uint8_t)value;
  } else if (streq(label, "turn-range"))
    z->turn_range = value;
  else if (streq(label, "hide-range"))
    z->hide_range = value;
  else if (streq(label, "wander-range")) {
    if (value > 255) return PARSE_ERROR_INVALID_VALUE;
    z->wander_range = (uint8_t)value;
  } else if (streq(label, "regen-hp-period"))
    z->mon_regen_hp_period = value;
  else if (streq(label, "regen-sp-period"))
    z->mon_regen_sp_period = value;
  else
    return PARSE_ERROR_UNDEFINED_DIRECTIVE;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_constants_dun_gen(struct parser* p)
{
  struct angband_constants* z;
  const char* label;
  int value;
  z = parser_priv(p);
  label = parser_getsym(p, "label");
  value = parser_getint(p, "value");
  if (value < 0) return PARSE_ERROR_INVALID_VALUE;
  if (streq(label, "room-max"))
    z->level_room_max = value;
  else if (streq(label, "room-min"))
    z->level_room_min = value;
  else if (streq(label, "block-hgt"))
    z->block_hgt = value;
  else if (streq(label, "block-wid"))
    z->block_wid = value;
  else
    return PARSE_ERROR_UNDEFINED_DIRECTIVE;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_constants_world(struct parser* p)
{
  struct angband_constants* z;
  const char* label;
  int value;
  z = parser_priv(p);
  label = parser_getsym(p, "label");
  value = parser_getint(p, "value");
  if (value < 0) return PARSE_ERROR_INVALID_VALUE;
  if (streq(label, "dun-depth"))
    z->dun_depth = value;
  else if (streq(label, "max-depth"))
    z->max_depth = value;
  else if (streq(label, "day-length"))
    z->day_length = value;
  else if (streq(label, "dungeon-hgt"))
    z->dungeon_hgt = value;
  else if (streq(label, "dungeon-wid"))
    z->dungeon_wid = value;
  else if (streq(label, "move-energy"))
    z->move_energy = value;
  else if (streq(label, "flow-max"))
    z->flow_max = value;
  else
    return PARSE_ERROR_UNDEFINED_DIRECTIVE;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_constants_carry_cap(struct parser* p)
{
  struct angband_constants* z;
  const char* label;
  int value;
  z = parser_priv(p);
  label = parser_getsym(p, "label");
  value = parser_getint(p, "value");
  if (value < 0) return PARSE_ERROR_INVALID_VALUE;
  if (streq(label, "pack-size"))
    z->pack_size = value;
  else if (streq(label, "floor-size"))
    z->floor_size = value;
  else
    return PARSE_ERROR_UNDEFINED_DIRECTIVE;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_constants_obj_make(struct parser* p)
{
  struct angband_constants* z;
  const char* label;
  int value;
  z = parser_priv(p);
  label = parser_getsym(p, "label");
  value = parser_getint(p, "value");
  if (value < 0) return PARSE_ERROR_INVALID_VALUE;
  if (streq(label, "max-depth"))
    z->max_obj_depth = value;
  else if (streq(label, "great-obj"))
    z->great_obj = value;
  else if (streq(label, "great-spec"))
    z->great_ego = value;
  else if (streq(label, "default-torch"))
    z->default_torch = value;
  else if (streq(label, "fuel-torch"))
    z->fuel_torch = value;
  else if (streq(label, "default-lamp"))
    z->default_lamp = value;
  else if (streq(label, "fuel-lamp"))
    z->fuel_lamp = value;
  else if (streq(label, "self-arts"))
    z->self_arts_max = value;
  else
    return PARSE_ERROR_UNDEFINED_DIRECTIVE;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_constants_player(struct parser* p)
{
  struct angband_constants* z;
  const char* label;
  int value;
  z = parser_priv(p);
  label = parser_getsym(p, "label");
  value = parser_getint(p, "value");
  if (value < 0) return PARSE_ERROR_INVALID_VALUE;
  if (streq(label, "max-sight"))
    z->max_sight = value;
  else if (streq(label, "max-range"))
    z->max_range = value;
  else if (streq(label, "start-exp"))
    z->start_exp = value;
  else if (streq(label, "ability-cost"))
    z->ability_cost = value;
  else if (streq(label, "stealth-bonus"))
    z->stealth_bonus = value;
  else if (streq(label, "regen-period"))
    z->player_regen_period = value;
  else
    return PARSE_ERROR_UNDEFINED_DIRECTIVE;
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_parse_constants(void)
{
  struct angband_constants* z = mem_zalloc(sizeof *z);
  struct parser* p = parser_new();
  parser_setpriv(p, z);
  parser_reg(p, "level-max sym label int value", parse_constants_level_max);
  parser_reg(p, "mon-gen sym label int value", parse_constants_mon_gen);
  parser_reg(p, "mon-play sym label int value", parse_constants_mon_play);
  parser_reg(p, "dun-gen sym label int value", parse_constants_dun_gen);
  parser_reg(p, "world sym label int value", parse_constants_world);
  parser_reg(p, "carry-cap sym label int value", parse_constants_carry_cap);
  parser_reg(p, "obj-make sym label int value", parse_constants_obj_make);
  parser_reg(p, "player sym label int value", parse_constants_player);
  return p;
}
STATIC_OVL errr
run_parse_constants(struct parser* p)
{
  return parse_file_quit_not_found(p, "constants");
}
STATIC_OVL errr
finish_parse_constants(struct parser* p)
{
  z_info = parser_priv(p);
  parser_destroy(p);
  return 0;
}
STATIC_OVL void
cleanup_constants(void)
{
  mem_free(z_info);
}
STATIC_OVL void
init_game_constants(void)
{
  event_signal_message(EVENT_INITSTATUS, 0, "Initializing constants");
  if (run_parser(&constants_parser)) quit_fmt("Cannot initialize constants.");
}
STATIC_OVL void
cleanup_game_constants(void)
{
  cleanup_parser(&constants_parser);
}
STATIC_OVL enum parser_error
parse_world_level(struct parser* p)
{
  const int depth = parser_getint(p, "depth");
  const char* name = parser_getsym(p, "name");
  const char* up = parser_getsym(p, "up");
  const char* down = parser_getsym(p, "down");
  struct level* last = parser_priv(p);
  struct level* lev = mem_zalloc(sizeof *lev);
  if (last) {
    last->next = lev;
  } else {
    world = lev;
  }
  lev->depth = depth;
  lev->name = string_make(name);
  lev->up = streq(up, "None") ? NULL : string_make(up);
  lev->down = streq(down, "None") ? NULL : string_make(down);
  parser_setpriv(p, lev);
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_parse_world(void)
{
  struct parser* p = parser_new();
  parser_reg(p, "level int depth sym name sym up sym down", parse_world_level);
  return p;
}
STATIC_OVL errr
run_parse_world(struct parser* p)
{
  return parse_file_quit_not_found(p, "world");
}
STATIC_OVL errr
finish_parse_world(struct parser* p)
{
  struct level* level_check;
  for (level_check = world; level_check; level_check = level_check->next) {
    struct level* level_find = world;
    if (level_check->up) {
      while (level_find && !streq(level_check->up, level_find->name)) {
        level_find = level_find->next;
      }
      if (!level_find) {
        quit_fmt("Invalid level reference %s", level_check->up);
      }
    }
    level_find = world;
    if (level_check->down) {
      while (level_find && !streq(level_check->down, level_find->name)) {
        level_find = level_find->next;
      }
      if (!level_find) {
        quit_fmt("Invalid level reference %s", level_check->down);
      }
    }
  }
  parser_destroy(p);
  return 0;
}
STATIC_OVL void
cleanup_world(void)
{
  struct level* level = world;
  while (level) {
    struct level* old = level;
    string_free(level->name);
    string_free(level->up);
    string_free(level->down);
    level = level->next;
    mem_free(old);
  }
}
STATIC_OVL enum parser_error
parse_feat_code(struct parser* p)
{
  const char* code = parser_getstr(p, "code");
  int idx = lookup_feat_code(code);
  struct feature* f;
  if (idx < 0) {
    return PARSE_ERROR_OUT_OF_BOUNDS;
  }
  assert(idx < FEAT_MAX);
  f = &f_info[idx];
  f->fidx = idx;
  parser_setpriv(p, f);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_feat_name(struct parser* p)
{
  const char* name = parser_getstr(p, "name");
  struct feature* f = parser_priv(p);
  if (!f) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  if (f->name) {
    return PARSE_ERROR_REPEATED_DIRECTIVE;
  }
  f->name = string_make(name);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_feat_graphics(struct parser* p)
{
  wchar_t glyph = parser_getchar(p, "glyph");
  const char* color = parser_getsym(p, "color");
  int attr = 0;
  struct feature* f = parser_priv(p);
  if (!f) return PARSE_ERROR_MISSING_RECORD_HEADER;
  f->d_char = glyph;
  if (strlen(color) > 1)
    attr = color_text_to_attr(color);
  else
    attr = color_char_to_attr(color[0]);
  if (attr < 0) return PARSE_ERROR_INVALID_COLOR;
  f->d_attr = attr;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_feat_mimic(struct parser* p)
{
  const char* mimic_name = parser_getstr(p, "feat");
  struct feature* f = parser_priv(p);
  int mimic_idx;
  if (!f) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  mimic_idx = lookup_feat_code(mimic_name);
  if (mimic_idx < 0) {
    return PARSE_ERROR_OUT_OF_BOUNDS;
  }
  f->mimic = &f_info[mimic_idx];
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_feat_priority(struct parser* p)
{
  unsigned int priority = parser_getuint(p, "priority");
  struct feature* f = parser_priv(p);
  if (!f) return PARSE_ERROR_MISSING_RECORD_HEADER;
  f->priority = priority;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_feat_flags(struct parser* p)
{
  struct feature* f = parser_priv(p);
  char *flags, *s;
  if (!f) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  if (!parser_hasval(p, "flags")) {
    return PARSE_ERROR_NONE;
  }
  flags = string_make(parser_getstr(p, "flags"));
  s = strtok(flags, " |");
  while (s) {
    if (grab_flag(f->flags, TF_SIZE, terrain_flags, s)) {
      break;
    }
    s = strtok(NULL, " |");
  }
  string_free(flags);
  return s ? PARSE_ERROR_INVALID_FLAG : PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_feat_info(struct parser* p)
{
  struct feature* f = parser_priv(p);
  if (!f) return PARSE_ERROR_MISSING_RECORD_HEADER;
  f->forge_bonus = parser_getint(p, "bonus");
  f->dig = parser_getint(p, "dig");
  f->pit_difficulty = parser_getint(p, "pit");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_feat_desc(struct parser* p)
{
  struct feature* f = parser_priv(p);
  if (!f) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  f->desc = string_append(f->desc, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_feat_walk_msg(struct parser* p)
{
  struct feature* f = parser_priv(p);
  if (!f) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  f->walk_msg = string_append(f->walk_msg, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_feat_run_msg(struct parser* p)
{
  struct feature* f = parser_priv(p);
  if (!f) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  f->run_msg = string_append(f->run_msg, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_feat_hurt_msg(struct parser* p)
{
  struct feature* f = parser_priv(p);
  if (!f) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  f->hurt_msg = string_append(f->hurt_msg, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_feat_dig_msg(struct parser* p)
{
  struct feature* f = parser_priv(p);
  if (!f) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  f->dig_msg = string_append(f->dig_msg, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_feat_fail_msg(struct parser* p)
{
  struct feature* f = parser_priv(p);
  if (!f) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  f->fail_msg = string_append(f->fail_msg, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_feat_str_msg(struct parser* p)
{
  struct feature* f = parser_priv(p);
  if (!f) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  f->str_msg = string_append(f->str_msg, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_feat_die_msg(struct parser* p)
{
  struct feature* f = parser_priv(p);
  if (!f) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  f->die_msg = string_append(f->die_msg, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_feat_confused_msg(struct parser* p)
{
  struct feature* f = parser_priv(p);
  if (!f) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  f->confused_msg = string_append(f->confused_msg, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_feat_look_prefix(struct parser* p)
{
  struct feature* f = parser_priv(p);
  if (!f) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  f->look_prefix = string_append(f->look_prefix, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_feat_look_in_preposition(struct parser* p)
{
  struct feature* f = parser_priv(p);
  if (!f) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  f->look_in_preposition =
      string_append(f->look_in_preposition, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_parse_feat(void)
{
  struct parser* p = parser_new();
  parser_setpriv(p, NULL);
  parser_reg(p, "code str code", parse_feat_code);
  parser_reg(p, "name str name", parse_feat_name);
  parser_reg(p, "graphics char glyph sym color", parse_feat_graphics);
  parser_reg(p, "mimic str feat", parse_feat_mimic);
  parser_reg(p, "priority uint priority", parse_feat_priority);
  parser_reg(p, "flags ?str flags", parse_feat_flags);
  parser_reg(p, "info int bonus int dig int pit", parse_feat_info);
  parser_reg(p, "desc str text", parse_feat_desc);
  parser_reg(p, "walk-msg str text", parse_feat_walk_msg);
  parser_reg(p, "run-msg str text", parse_feat_run_msg);
  parser_reg(p, "hurt-msg str text", parse_feat_hurt_msg);
  parser_reg(p, "dig-msg str text", parse_feat_dig_msg);
  parser_reg(p, "fail-msg str text", parse_feat_fail_msg);
  parser_reg(p, "str-msg str text", parse_feat_str_msg);
  parser_reg(p, "die-msg str text", parse_feat_die_msg);
  parser_reg(p, "confused-msg str text", parse_feat_confused_msg);
  parser_reg(p, "look-prefix str text", parse_feat_look_prefix);
  parser_reg(p, "look-in-preposition str text", parse_feat_look_in_preposition);
  f_info = mem_zalloc(FEAT_MAX * sizeof(*f_info));
  return p;
}
STATIC_OVL errr
run_parse_feat(struct parser* p)
{
  return parse_file_quit_not_found(p, "terrain");
}
STATIC_OVL errr
finish_parse_feat(struct parser* p)
{
  int fidx;
  for (fidx = 0; fidx < FEAT_MAX; ++fidx) {
    if (f_info[fidx].look_prefix && !suffix(f_info[fidx].look_prefix, " ")) {
      f_info[fidx].look_prefix = string_append(f_info[fidx].look_prefix, " ");
    }
    if (f_info[fidx].look_in_preposition &&
        !suffix(f_info[fidx].look_in_preposition, " ")) {
      f_info[fidx].look_in_preposition =
          string_append(f_info[fidx].look_in_preposition, " ");
    }
  }
  parser_destroy(p);
  return 0;
}
STATIC_OVL void
cleanup_feat(void)
{
  int idx;
  for (idx = 0; idx < FEAT_MAX; idx++) {
    string_free(f_info[idx].look_in_preposition);
    string_free(f_info[idx].look_prefix);
    string_free(f_info[idx].confused_msg);
    string_free(f_info[idx].str_msg);
    string_free(f_info[idx].fail_msg);
    string_free(f_info[idx].dig_msg);
    string_free(f_info[idx].die_msg);
    string_free(f_info[idx].hurt_msg);
    string_free(f_info[idx].run_msg);
    string_free(f_info[idx].walk_msg);
    string_free(f_info[idx].desc);
    string_free(f_info[idx].name);
  }
  mem_free(f_info);
}
STATIC_OVL enum parser_error
parse_body_body(struct parser* p)
{
  struct player_body* h = parser_priv(p);
  struct player_body* b = mem_zalloc(sizeof *b);
  b->next = h;
  b->name = string_make(parser_getstr(p, "name"));
  parser_setpriv(p, b);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_body_slot(struct parser* p)
{
  struct player_body* b = parser_priv(p);
  struct equip_slot* slot;
  int n;
  if (!b) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  slot = b->slots;
  if (!slot) {
    b->slots = mem_zalloc(sizeof(struct equip_slot));
    slot = b->slots;
  } else {
    while (slot->next) slot = slot->next;
    slot->next = mem_zalloc(sizeof(struct equip_slot));
    slot = slot->next;
  }
  n = lookup_flag(slots, parser_getsym(p, "slot"));
  if (!n) {
    return PARSE_ERROR_INVALID_FLAG;
  }
  slot->type = n;
  slot->name = string_make(parser_getsym(p, "name"));
  b->count++;
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_parse_body(void)
{
  struct parser* p = parser_new();
  parser_setpriv(p, NULL);
  parser_reg(p, "body str name", parse_body_body);
  parser_reg(p, "slot sym slot sym name", parse_body_slot);
  return p;
}
STATIC_OVL errr
run_parse_body(struct parser* p)
{
  return parse_file_quit_not_found(p, "body");
}
STATIC_OVL errr
finish_parse_body(struct parser* p)
{
  struct player_body* b;
  int i;
  bodies = parser_priv(p);
  z_info->equip_slots_max = 0;
  for (b = bodies; b; b = b->next) {
    if (b->count > z_info->equip_slots_max) z_info->equip_slots_max = b->count;
  }
  for (b = bodies; b; b = b->next) {
    struct equip_slot* s_new;
    s_new = mem_zalloc(z_info->equip_slots_max * sizeof(*s_new));
    if (b->slots) {
      struct equip_slot *s_temp, *s_old = b->slots;
      for (i = 0; i < z_info->equip_slots_max; i++) {
        memcpy(&s_new[i], s_old, sizeof(*s_old));
        s_old = s_old->next;
        if (!s_old) break;
      }
      for (i = 0; i < z_info->equip_slots_max; i++)
        if (s_new[i].next) s_new[i].next = &s_new[i + 1];
      s_old = b->slots;
      s_temp = s_old;
      while (s_temp) {
        s_temp = s_old->next;
        mem_free(s_old);
        s_old = s_temp;
      }
    }
    b->slots = s_new;
  }
  parser_destroy(p);
  return 0;
}
STATIC_OVL void
cleanup_body(void)
{
  struct player_body* b = bodies;
  struct player_body* next;
  int i;
  while (b) {
    next = b->next;
    string_free((char*)b->name);
    for (i = 0; i < b->count; i++) string_free((char*)b->slots[i].name);
    mem_free(b->slots);
    mem_free(b);
    b = next;
  }
}
STATIC_OVL struct history_chart*
findchart(struct history_chart* hs, unsigned int idx)
{
  for (; hs; hs = hs->next)
    if (hs->idx == idx) break;
  return hs;
}
STATIC_OVL enum parser_error
parse_history_chart(struct parser* p)
{
  struct history_chart* oc = parser_priv(p);
  struct history_chart* c;
  struct history_entry* e = mem_zalloc(sizeof *e);
  unsigned int idx = parser_getuint(p, "chart");
  if (!(c = findchart(oc, idx))) {
    c = mem_zalloc(sizeof *c);
    c->next = oc;
    c->idx = idx;
    parser_setpriv(p, c);
  }
  e->isucc = parser_getint(p, "next");
  e->roll = parser_getint(p, "roll");
  e->next = c->entries;
  c->entries = e;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_history_phrase(struct parser* p)
{
  struct history_chart* h = parser_priv(p);
  if (!h) return PARSE_ERROR_MISSING_RECORD_HEADER;
  assert(h->entries);
  h->entries->text = string_append(h->entries->text, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_parse_history(void)
{
  struct parser* p = parser_new();
  parser_setpriv(p, NULL);
  parser_reg(p, "chart uint chart int next int roll", parse_history_chart);
  parser_reg(p, "phrase str text", parse_history_phrase);
  return p;
}
STATIC_OVL errr
run_parse_history(struct parser* p)
{
  return parse_file_quit_not_found(p, "history");
}
STATIC_OVL errr
finish_parse_history(struct parser* p)
{
  struct history_chart* c;
  struct history_entry *e, *prev, *next;
  histories = parser_priv(p);
  for (c = histories; c; c = c->next) {
    e = c->entries;
    prev = NULL;
    while (e) {
      next = e->next;
      e->next = prev;
      prev = e;
      e = next;
    }
    c->entries = prev;
    for (e = c->entries; e; e = e->next) {
      if (!e->isucc) continue;
      e->succ = findchart(histories, e->isucc);
      if (!e->succ) {
        return -1;
      }
    }
  }
  parser_destroy(p);
  return 0;
}
STATIC_OVL void
cleanup_history(void)
{
  struct history_chart *c, *next_c;
  struct history_entry *e, *next_e;
  c = histories;
  while (c) {
    next_c = c->next;
    e = c->entries;
    while (e) {
      next_e = e->next;
      mem_free(e->text);
      mem_free(e);
      e = next_e;
    }
    mem_free(c);
    c = next_c;
  }
}
STATIC_OVL enum parser_error
parse_sex_name(struct parser* p)
{
  struct player_sex* h = parser_priv(p);
  struct player_sex* s = mem_zalloc(sizeof *s);
  s->next = h;
  s->name = string_make(parser_getstr(p, "name"));
  parser_setpriv(p, s);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_sex_possess(struct parser* p)
{
  struct player_sex* s = parser_priv(p);
  if (!s) return PARSE_ERROR_MISSING_RECORD_HEADER;
  string_free((char*)s->possessive);
  s->possessive = string_make(parser_getstr(p, "pronoun"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_sex_poetry(struct parser* p)
{
  struct player_sex* s = parser_priv(p);
  if (!s) return PARSE_ERROR_MISSING_RECORD_HEADER;
  string_free((char*)s->poetry_name);
  s->poetry_name = string_make(parser_getstr(p, "name"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_parse_sex(void)
{
  struct parser* p = parser_new();
  parser_setpriv(p, NULL);
  parser_reg(p, "name str name", parse_sex_name);
  parser_reg(p, "possess str pronoun", parse_sex_possess);
  parser_reg(p, "poetry str name", parse_sex_poetry);
  return p;
}
STATIC_OVL errr
run_parse_sex(struct parser* p)
{
  return parse_file_quit_not_found(p, "sex");
}
STATIC_OVL errr
finish_parse_sex(struct parser* p)
{
  struct player_sex* s;
  int num = 0;
  sexes = parser_priv(p);
  for (s = sexes; s; s = s->next) num++;
  for (s = sexes; s; s = s->next, num--) {
    assert(num);
    s->sidx = num - 1;
  }
  parser_destroy(p);
  return 0;
}
STATIC_OVL void
cleanup_sex(void)
{
  struct player_sex* s = sexes;
  struct player_sex* next;
  while (s) {
    next = s->next;
    string_free((char*)s->poetry_name);
    string_free((char*)s->possessive);
    string_free((char*)s->name);
    mem_free(s);
    s = next;
  }
}
STATIC_OVL enum parser_error
parse_race_name(struct parser* p)
{
  struct player_race* h = parser_priv(p);
  struct player_race* r = mem_zalloc(sizeof *r);
  r->next = h;
  r->name = string_make(parser_getstr(p, "name"));
  r->body = 0;
  parser_setpriv(p, r);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_race_stats(struct parser* p)
{
  struct player_race* r = parser_priv(p);
  if (!r) return PARSE_ERROR_MISSING_RECORD_HEADER;
  r->stat_adj[STAT_STR] = parser_getint(p, "str");
  r->stat_adj[STAT_DEX] = parser_getint(p, "dex");
  r->stat_adj[STAT_CON] = parser_getint(p, "con");
  r->stat_adj[STAT_GRA] = parser_getint(p, "gra");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_race_skills(struct parser* p)
{
  struct player_race* r = parser_priv(p);
  if (!r) return PARSE_ERROR_MISSING_RECORD_HEADER;
  r->skill_adj[SKILL_MELEE] = parser_getint(p, "mel");
  r->skill_adj[SKILL_ARCHERY] = parser_getint(p, "arc");
  r->skill_adj[SKILL_EVASION] = parser_getint(p, "evn");
  r->skill_adj[SKILL_STEALTH] = parser_getint(p, "stl");
  r->skill_adj[SKILL_PERCEPTION] = parser_getint(p, "per");
  r->skill_adj[SKILL_WILL] = parser_getint(p, "wil");
  r->skill_adj[SKILL_SMITHING] = parser_getint(p, "smt");
  r->skill_adj[SKILL_SONG] = parser_getint(p, "sng");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_race_history(struct parser* p)
{
  struct player_race* r = parser_priv(p);
  if (!r) return PARSE_ERROR_MISSING_RECORD_HEADER;
  r->history = findchart(histories, parser_getuint(p, "hist"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_race_age(struct parser* p)
{
  struct player_race* r = parser_priv(p);
  if (!r) return PARSE_ERROR_MISSING_RECORD_HEADER;
  r->b_age = parser_getint(p, "base_age");
  r->m_age = parser_getint(p, "mod_age");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_race_height(struct parser* p)
{
  struct player_race* r = parser_priv(p);
  if (!r) return PARSE_ERROR_MISSING_RECORD_HEADER;
  r->base_hgt = parser_getint(p, "base_hgt");
  r->mod_hgt = parser_getint(p, "mod_hgt");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_race_weight(struct parser* p)
{
  struct player_race* r = parser_priv(p);
  if (!r) return PARSE_ERROR_MISSING_RECORD_HEADER;
  r->base_wgt = parser_getint(p, "base_wgt");
  r->mod_wgt = parser_getint(p, "mod_wgt");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_race_play_flags(struct parser* p)
{
  struct player_race* r = parser_priv(p);
  char* flags;
  char* s;
  if (!r) return PARSE_ERROR_MISSING_RECORD_HEADER;
  if (!parser_hasval(p, "flags")) return PARSE_ERROR_NONE;
  flags = string_make(parser_getstr(p, "flags"));
  s = strtok(flags, " |");
  while (s) {
    if (grab_flag(r->pflags, PF_SIZE, player_info_flags, s)) break;
    s = strtok(NULL, " |");
  }
  string_free(flags);
  return s ? PARSE_ERROR_INVALID_FLAG : PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_race_equip(struct parser* p)
{
  struct player_race* r = parser_priv(p);
  struct start_item* si;
  int tval, sval;
  if (!r) return PARSE_ERROR_MISSING_RECORD_HEADER;
  tval = tval_find_idx(parser_getsym(p, "tval"));
  if (tval < 0) return PARSE_ERROR_UNRECOGNISED_TVAL;
  sval = lookup_sval(tval, parser_getsym(p, "sval"));
  if (sval < 0) return PARSE_ERROR_UNRECOGNISED_SVAL;
  si = mem_zalloc(sizeof *si);
  si->tval = tval;
  si->sval = sval;
  si->min = parser_getuint(p, "min");
  si->max = parser_getuint(p, "max");
  if (si->min > 99 || si->max > 99) {
    mem_free(si);
    return PARSE_ERROR_INVALID_ITEM_NUMBER;
  }
  si->next = r->start_items;
  r->start_items = si;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_race_desc(struct parser* p)
{
  struct player_race* r = parser_priv(p);
  if (!r) return PARSE_ERROR_MISSING_RECORD_HEADER;
  r->desc = string_append((char*)r->desc, parser_getstr(p, "desc"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_parse_race(void)
{
  struct parser* p = parser_new();
  parser_setpriv(p, NULL);
  parser_reg(p, "name str name", parse_race_name);
  parser_reg(p, "stats int str int dex int con int gra", parse_race_stats);
  parser_reg(
      p,
      "skills int mel int arc int evn int stl int per int wil int smt int sng",
      parse_race_skills);
  parser_reg(p, "history uint hist", parse_race_history);
  parser_reg(p, "age int base_age int mod_age", parse_race_age);
  parser_reg(p, "height int base_hgt int mod_hgt", parse_race_height);
  parser_reg(p, "weight int base_wgt int mod_wgt", parse_race_weight);
  parser_reg(p, "player-flags ?str flags", parse_race_play_flags);
  parser_reg(p, "equip sym tval sym sval uint min uint max", parse_race_equip);
  parser_reg(p, "desc str desc", parse_race_desc);
  return p;
}
STATIC_OVL errr
run_parse_race(struct parser* p)
{
  return parse_file_quit_not_found(p, "race");
}
STATIC_OVL errr
finish_parse_race(struct parser* p)
{
  struct player_race* r;
  int num = 0;
  races = parser_priv(p);
  for (r = races; r; r = r->next) num++;
  for (r = races; r; r = r->next, num--) {
    assert(num);
    r->ridx = num - 1;
  }
  parser_destroy(p);
  return 0;
}
STATIC_OVL void
cleanup_race(void)
{
  struct player_race* r = races;
  struct player_race* next;
  struct start_item *item, *item_next;
  while (r) {
    next = r->next;
    item = r->start_items;
    while (item) {
      item_next = item->next;
      mem_free(item);
      item = item_next;
    }
    string_free((char*)r->name);
    string_free((char*)r->desc);
    mem_free(r);
    r = next;
  }
}
STATIC_OVL enum parser_error
parse_house_name(struct parser* p)
{
  struct player_house* n = parser_priv(p);
  struct player_house* h = mem_zalloc(sizeof *h);
  h->name = string_make(parser_getstr(p, "name"));
  h->next = n;
  parser_setpriv(p, h);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_house_alt_name(struct parser* p)
{
  struct player_house* h = parser_priv(p);
  if (!h) return PARSE_ERROR_MISSING_RECORD_HEADER;
  string_free((char*)h->alt_name);
  h->alt_name = string_make(parser_getstr(p, "name"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_house_short_name(struct parser* p)
{
  struct player_house* h = parser_priv(p);
  if (!h) return PARSE_ERROR_MISSING_RECORD_HEADER;
  string_free((char*)h->short_name);
  h->short_name = string_make(parser_getstr(p, "name"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_house_race(struct parser* p)
{
  struct player_house* h = parser_priv(p);
  struct player_race* r;
  const char* race_name = parser_getstr(p, "name");
  if (!h) return PARSE_ERROR_MISSING_RECORD_HEADER;
  for (r = races; r; r = r->next) {
    if (streq(r->name, race_name)) {
      h->race = r;
      break;
    }
  }
  if (!r) return PARSE_ERROR_INVALID_PLAYER_RACE;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_house_stats(struct parser* p)
{
  struct player_house* h = parser_priv(p);
  if (!h) return PARSE_ERROR_MISSING_RECORD_HEADER;
  h->stat_adj[STAT_STR] = parser_getint(p, "str");
  h->stat_adj[STAT_DEX] = parser_getint(p, "dex");
  h->stat_adj[STAT_CON] = parser_getint(p, "con");
  h->stat_adj[STAT_GRA] = parser_getint(p, "gra");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_house_skills(struct parser* p)
{
  struct player_house* h = parser_priv(p);
  if (!h) return PARSE_ERROR_MISSING_RECORD_HEADER;
  h->skill_adj[SKILL_MELEE] = parser_getint(p, "mel");
  h->skill_adj[SKILL_ARCHERY] = parser_getint(p, "arc");
  h->skill_adj[SKILL_EVASION] = parser_getint(p, "evn");
  h->skill_adj[SKILL_STEALTH] = parser_getint(p, "stl");
  h->skill_adj[SKILL_PERCEPTION] = parser_getint(p, "per");
  h->skill_adj[SKILL_WILL] = parser_getint(p, "wil");
  h->skill_adj[SKILL_SMITHING] = parser_getint(p, "smt");
  h->skill_adj[SKILL_SONG] = parser_getint(p, "sng");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_house_play_flags(struct parser* p)
{
  struct player_house* h = parser_priv(p);
  char* flags;
  char* s;
  if (!h) return PARSE_ERROR_MISSING_RECORD_HEADER;
  if (!parser_hasval(p, "flags")) return PARSE_ERROR_NONE;
  flags = string_make(parser_getstr(p, "flags"));
  s = strtok(flags, " |");
  while (s) {
    if (grab_flag(h->pflags, PF_SIZE, player_info_flags, s)) break;
    s = strtok(NULL, " |");
  }
  string_free(flags);
  return s ? PARSE_ERROR_INVALID_FLAG : PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_house_desc(struct parser* p)
{
  struct player_house* h = parser_priv(p);
  if (!h) return PARSE_ERROR_MISSING_RECORD_HEADER;
  h->desc = string_append((char*)h->desc, parser_getstr(p, "desc"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_parse_house(void)
{
  struct parser* p = parser_new();
  parser_setpriv(p, NULL);
  parser_reg(p, "name str name", parse_house_name);
  parser_reg(p, "alt-name str name", parse_house_alt_name);
  parser_reg(p, "short-name str name", parse_house_short_name);
  parser_reg(p, "race str name", parse_house_race);
  parser_reg(p, "stats int str int dex int con int gra", parse_house_stats);
  parser_reg(
      p,
      "skills int mel int arc int evn int stl int per int wil int smt int sng",
      parse_house_skills);
  parser_reg(p, "player-flags ?str flags", parse_house_play_flags);
  parser_reg(p, "desc str desc", parse_house_desc);
  return p;
}
STATIC_OVL errr
run_parse_house(struct parser* p)
{
  return parse_file_quit_not_found(p, "house");
}
STATIC_OVL errr
finish_parse_house(struct parser* p)
{
  struct player_house* h;
  int num = 0;
  houses = parser_priv(p);
  for (h = houses; h; h = h->next) num++;
  for (h = houses; h; h = h->next, num--) {
    assert(num);
    h->hidx = num - 1;
  }
  parser_destroy(p);
  return 0;
}
STATIC_OVL void
cleanup_house(void)
{
  struct player_house* h = houses;
  struct player_house* next;
  while (h) {
    next = h->next;
    string_free((char*)h->name);
    string_free((char*)h->alt_name);
    string_free((char*)h->short_name);
    string_free((char*)h->desc);
    mem_free(h);
    h = next;
  }
}
STATIC_OVL enum parser_error
parse_names_section(struct parser* p)
{
  unsigned int section = parser_getuint(p, "section");
  struct names_parse* s = parser_priv(p);
  if (section >= RANDNAME_NUM_TYPES) {
    return PARSE_ERROR_OUT_OF_BOUNDS;
  }
  s->section = section;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_names_word(struct parser* p)
{
  const char* name = parser_getstr(p, "name");
  struct names_parse* s = parser_priv(p);
  struct name* ns = mem_zalloc(sizeof *ns);
  s->nnames[s->section]++;
  ns->next = s->names[s->section];
  ns->str = string_make(name);
  s->names[s->section] = ns;
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_parse_names(void)
{
  struct parser* p = parser_new();
  struct names_parse* n = mem_zalloc(sizeof *n);
  n->section = 0;
  parser_setpriv(p, n);
  parser_reg(p, "section uint section", parse_names_section);
  parser_reg(p, "word str name", parse_names_word);
  return p;
}
STATIC_OVL errr
run_parse_names(struct parser* p)
{
  return parse_file_quit_not_found(p, "names");
}
STATIC_OVL errr
finish_parse_names(struct parser* p)
{
  int i;
  unsigned int j;
  struct names_parse* n = parser_priv(p);
  struct name* nm;
  name_sections = mem_zalloc(sizeof(char**) * RANDNAME_NUM_TYPES);
  for (i = 0; i < RANDNAME_NUM_TYPES; i++) {
    name_sections[i] = mem_alloc(sizeof(char*) * (n->nnames[i] + 1));
    for (nm = n->names[i], j = 0; nm && j < n->nnames[i]; nm = nm->next, j++) {
      name_sections[i][j] = nm->str;
    }
    name_sections[i][n->nnames[i]] = NULL;
    while (n->names[i]) {
      nm = n->names[i]->next;
      mem_free(n->names[i]);
      n->names[i] = nm;
    }
  }
  mem_free(n);
  parser_destroy(p);
  return 0;
}
STATIC_OVL void
cleanup_names(void)
{
  int i, j;
  for (i = 0; i < RANDNAME_NUM_TYPES; i++) {
    for (j = 0; name_sections[i][j]; j++) {
      string_free((char*)name_sections[i][j]);
    }
    mem_free(name_sections[i]);
  }
  mem_free(name_sections);
}
STATIC_OVL enum parser_error
parse_flavor_flavor(struct parser* p)
{
  struct flavor* h = parser_priv(p);
  struct flavor* f = mem_zalloc(sizeof *f);
  const char* attr;
  int d_attr;
  f->next = h;
  f->fidx = parser_getuint(p, "index");
  f->tval = flavor_tval;
  f->d_char = flavor_glyph;
  if (parser_hasval(p, "sval"))
    f->sval = lookup_sval(f->tval, parser_getsym(p, "sval"));
  else
    f->sval = SV_UNKNOWN;
  attr = parser_getsym(p, "attr");
  if (strlen(attr) == 1)
    d_attr = color_char_to_attr(attr[0]);
  else
    d_attr = color_text_to_attr(attr);
  if (d_attr < 0) return PARSE_ERROR_INVALID_COLOR;
  f->d_attr = d_attr;
  if (parser_hasval(p, "desc"))
    f->text = string_append(f->text, parser_getstr(p, "desc"));
  parser_setpriv(p, f);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_flavor_kind(struct parser* p)
{
  int tval = tval_find_idx(parser_getsym(p, "tval"));
  if (tval <= 0) {
    return PARSE_ERROR_UNRECOGNISED_TVAL;
  }
  flavor_glyph = parser_getchar(p, "glyph");
  flavor_tval = tval;
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_parse_flavor(void)
{
  struct parser* p = parser_new();
  parser_setpriv(p, NULL);
  parser_reg(p, "kind sym tval char glyph", parse_flavor_kind);
  parser_reg(p, "flavor uint index sym attr ?str desc", parse_flavor_flavor);
  parser_reg(p, "fixed uint index sym sval sym attr ?str desc",
             parse_flavor_flavor);
  return p;
}
STATIC_OVL errr
run_parse_flavor(struct parser* p)
{
  return parse_file_quit_not_found(p, "flavor");
}
STATIC_OVL errr
finish_parse_flavor(struct parser* p)
{
  flavors = parser_priv(p);
  parser_destroy(p);
  return 0;
}
STATIC_OVL void
cleanup_flavor(void)
{
  struct flavor *f, *next;
  f = flavors;
  while (f) {
    next = f->next;
    string_free(f->text);
    mem_free(f);
    f = next;
  }
}
STATIC_OVL void
init_arrays(void)
{
  unsigned int i;
  for (i = 0; i < N_ELEMENTS(pl); i++) {
    char* msg = string_make(format("Initializing %s...", pl[i].name));
    event_signal_message(EVENT_INITSTATUS, 0, msg);
    string_free(msg);
    if (run_parser(pl[i].parser)) quit_fmt("Cannot initialize %s.", pl[i].name);
  }
}
STATIC_OVL void
cleanup_arrays(void)
{
  unsigned int i;
  for (i = 1; i < N_ELEMENTS(pl); i++) cleanup_parser(pl[i].parser);
  cleanup_parser(pl[0].parser);
}
STATIC_OVL bool
init_angband(void)
{
  int i;
  event_signal(EVENT_ENTER_INIT);
  init_game_constants();
  for (i = 0; modules[i]; i++)
    if (modules[i]->init) modules[i]->init();
  (void)vinfo_init();
  event_signal_message(EVENT_INITSTATUS, 0, "Initializing other stuff...");
  monster_list_init();
  object_list_init();
  event_signal_message(EVENT_INITSTATUS, 0, "Getting the dice rolling...");
  Rand_init();
  return true;
}
STATIC_OVL void
cleanup_angband(void)
{
  int i;
  for (i = 0; modules[i]; i++)
    if (modules[i]->cleanup) modules[i]->cleanup();
  event_remove_all_handlers();
  if (cave) {
    forget_fire(cave);
    cave_free(cave);
    cave = NULL;
  }
  monster_list_finalize();
  object_list_finalize();
  cleanup_game_constants();
  cmdq_release();
  if (play_again) return;
  vformat_kill();
  string_free(ANGBAND_DIR_GAMEDATA);
  string_free(ANGBAND_DIR_CUSTOMIZE);
  string_free(ANGBAND_DIR_HELP);
  string_free(ANGBAND_DIR_SCREENS);
  string_free(ANGBAND_DIR_FONTS);
  string_free(ANGBAND_DIR_TILES);
  string_free(ANGBAND_DIR_SOUNDS);
  string_free(ANGBAND_DIR_ICONS);
  string_free(ANGBAND_DIR_USER);
  string_free(ANGBAND_DIR_SAVE);
  string_free(ANGBAND_DIR_PANIC);
  string_free(ANGBAND_DIR_SCORES);
  string_free(ANGBAND_DIR_ARCHIVE);
}
STATIC_OVL struct object*
rd_item(void)
{
  struct object* obj = object_new();
  uint8_t tmp8u;
  uint16_t tmp16u;
  size_t i;
  char buf[128];
  rd_u16b(&tmp16u);
  rd_byte(&tmp8u);
  if (tmp16u != 0xffff) return NULL;
  rd_u16b(&obj->oidx);
  rd_byte(&tmp8u);
  obj->grid.y = tmp8u;
  rd_byte(&tmp8u);
  obj->grid.x = tmp8u;
  rd_string(buf, sizeof(buf));
  if (buf[0]) {
    obj->tval = tval_find_idx(buf);
  }
  rd_string(buf, sizeof(buf));
  if (buf[0]) {
    obj->sval = lookup_sval(obj->tval, buf);
  }
  rd_string(buf, sizeof(buf));
  if (buf[0]) {
    int tv, sv;
    tv = tval_find_idx(buf);
    rd_string(buf, sizeof(buf));
    if (buf[0]) {
      sv = lookup_sval(tv, buf);
      obj->image_kind = lookup_kind(tv, sv);
    }
  }
  rd_s16b(&obj->pval);
  rd_byte(&obj->number);
  rd_s16b(&obj->weight);
  rd_string(buf, sizeof(buf));
  if (buf[0]) {
    obj->artifact = lookup_artifact_name(buf);
    if (!obj->artifact) {
      note(format("Couldn't find artifact %s!", buf));
      return NULL;
    }
  }
  rd_string(buf, sizeof(buf));
  if (buf[0]) {
    obj->ego = lookup_ego_item(buf, obj->tval, obj->sval);
    if (!obj->ego) {
      note(format("Couldn't find ego item %s!", buf));
      return NULL;
    }
  }
  rd_s16b(&obj->timeout);
  rd_byte(&obj->used);
  rd_s16b(&obj->att);
  rd_byte(&obj->dd);
  rd_byte(&obj->ds);
  rd_s16b(&obj->evn);
  rd_byte(&obj->pd);
  rd_byte(&obj->ps);
  rd_byte(&obj->origin);
  rd_byte(&obj->origin_depth);
  rd_string(buf, sizeof(buf));
  if (buf[0]) {
    obj->origin_race = lookup_monster(buf);
  }
  rd_byte(&obj->notice);
  rd_byte(&obj->pseudo);
  for (i = 0; i < of_size; i++) rd_byte(&obj->flags[i]);
  for (i = 0; i < obj_mod_max; i++) {
    rd_s16b(&obj->modifiers[i]);
  }
  rd_byte(&tmp8u);
  if (tmp8u) {
    obj->brands = mem_zalloc(z_info->brand_max * sizeof(bool));
    for (i = 0; i < brand_max; i++) {
      rd_byte(&tmp8u);
      obj->brands[i] = tmp8u ? true : false;
    }
  }
  rd_byte(&tmp8u);
  if (tmp8u) {
    obj->slays = mem_zalloc(z_info->slay_max * sizeof(bool));
    for (i = 0; i < slay_max; i++) {
      rd_byte(&tmp8u);
      obj->slays[i] = tmp8u ? true : false;
    }
  }
  for (i = 0; i < elem_max; i++) {
    rd_s16b(&obj->el_info[i].res_level);
    rd_byte(&obj->el_info[i].flags);
  }
  while (true) {
    struct ability* ability;
    rd_string(buf, sizeof(buf));
    if (streq(buf, "end")) break;
    rd_byte(&tmp8u);
    ability = lookup_ability(tmp8u, buf);
    if (ability == NULL) {
      note(format("Ability not found (%s).", buf));
      return NULL;
    }
    add_ability(&obj->abilities, ability);
  }
  rd_s16b(&obj->held_m_idx);
  rd_byte(&tmp8u);
  if (tmp8u) {
    rd_string(buf, sizeof(buf));
    if (buf[0]) obj->note = quark_add(buf);
  }
  obj->kind = lookup_kind(obj->tval, obj->sval);
  if ((!obj->tval && !obj->sval) || !obj->kind) {
    object_delete(NULL, NULL, &obj);
    return NULL;
  }
  return obj;
}
STATIC_OVL bool
rd_monster(struct chunk* c, struct monster* mon)
{
  uint8_t tmp8u;
  uint16_t tmp16u;
  char race_name[80];
  size_t j;
  rd_u16b(&tmp16u);
  mon->midx = tmp16u;
  rd_string(race_name, sizeof(race_name));
  mon->race = lookup_monster(race_name);
  if (!mon->race) {
    note(format("Monster race %s no longer exists!", race_name));
    return false;
  }
  rd_string(race_name, sizeof(race_name));
  if (streq(race_name, "none")) {
    mon->image_race = NULL;
  } else {
    mon->image_race = lookup_monster(race_name);
  }
  rd_byte(&tmp8u);
  mon->grid.y = tmp8u;
  rd_byte(&tmp8u);
  mon->grid.x = tmp8u;
  rd_s16b(&mon->hp);
  rd_s16b(&mon->maxhp);
  rd_byte(&mon->mana);
  rd_byte(&tmp8u);
  mon->song = song_by_idx(tmp8u);
  rd_s16b(&mon->alertness);
  rd_byte(&mon->mspeed);
  rd_byte(&mon->energy);
  rd_byte(&mon->origin);
  rd_byte(&mon->stance);
  rd_s16b(&mon->morale);
  rd_s16b(&mon->tmp_morale);
  rd_byte(&mon->noise);
  rd_byte(&mon->encountered);
  rd_byte(&tmp8u);
  for (j = 0; j < tmp8u; j++) rd_s16b(&mon->m_timed[j]);
  for (j = 0; j < mflag_size; j++) rd_byte(&mon->mflag[j]);
  for (j = 0; j < of_size; j++) rd_s16b(&mon->known_pstate.flags[j]);
  for (j = 0; j < elem_max; j++)
    rd_s16b(&mon->known_pstate.el_info[j].res_level);
  for (j = 0; j < MAX_ACTION; j++) rd_byte(&mon->previous_action[j]);
  while (true) {
    struct object* obj = rd_item();
    if (!obj) break;
    pile_insert(&mon->held_obj, obj);
    assert(obj->oidx);
    assert(c->objects[obj->oidx] == NULL);
    c->objects[obj->oidx] = obj;
  }
  rd_u16b(&tmp16u);
  mon->group_info.index = tmp16u;
  rd_byte(&tmp8u);
  mon->group_info.role = tmp8u;
  rd_byte(&tmp8u);
  mon->target.grid.y = tmp8u;
  rd_byte(&tmp8u);
  mon->target.grid.x = tmp8u;
  rd_byte(&mon->skip_this_turn);
  rd_byte(&mon->skip_next_turn);
  rd_s16b(&mon->consecutive_attacks);
  rd_s16b(&mon->turns_stationary);
  return true;
}
STATIC_OVL void
rd_trap(struct trap* trap)
{
  int i;
  uint8_t tmp8u;
  char buf[80];
  rd_string(buf, sizeof(buf));
  if (buf[0]) {
    trap->kind = lookup_trap(buf);
    trap->t_idx = trap->kind->tidx;
  }
  rd_byte(&tmp8u);
  trap->grid.y = tmp8u;
  rd_byte(&tmp8u);
  trap->grid.x = tmp8u;
  rd_byte(&trap->power);
  for (i = 0; i < trf_size; i++) rd_byte(&trap->flags[i]);
}
STATIC_OVL int
rd_randomizer(void)
{
  int i;
  uint32_t noop;
  rd_u32b(&Rand_value);
  rd_u32b(&state_i);
  state_i = state_i % RAND_DEG;
  rd_u32b(&z0);
  rd_u32b(&z1);
  rd_u32b(&z2);
  for (i = 0; i < RAND_DEG; i++) rd_u32b(&STATE[i]);
  for (i = 0; i < 59 - RAND_DEG; i++) rd_u32b(&noop);
  Rand_quick = false;
  return 0;
}
STATIC_OVL int
rd_options(void)
{
  uint8_t b;
  rd_byte(&b);
  player->opts.delay_factor = b;
  rd_byte(&b);
  player->opts.hitpoint_warn = b;
  rd_byte(&b);
  player->opts.lazymove_delay = b;
  if (angband_term[0]) {
    rd_byte(&b);
    if (b >= SIDEBAR_MAX) b = SIDEBAR_LEFT;
    SIDEBAR_MODE = b;
  } else {
    strip_bytes(1);
  }
  while (1) {
    uint8_t value;
    char name[40];
    rd_string(name, sizeof name);
    if (!name[0]) break;
    rd_byte(&value);
    option_set(name, !!value);
  }
  return 0;
}
STATIC_OVL int
rd_messages(void)
{
  int i;
  char buf[128];
  uint16_t tmp16u;
  int16_t num;
  rd_s16b(&num);
  for (i = 0; i < num; i++) {
    rd_string(buf, sizeof(buf));
    rd_u16b(&tmp16u);
    message_add(buf, tmp16u);
  }
  return 0;
}
STATIC_OVL int
rd_monster_memory(void)
{
  uint16_t nkill, nsight;
  char buf[128];
  int i;
  rd_byte(&mflag_size);
  if (mflag_size > MFLAG_SIZE) {
    note(format("Too many (%u) monster temporary flags!", mflag_size));
    return (-1);
  }
  for (i = 1; z_info && i < z_info->r_max; i++) {
    struct monster_race* race = &r_info[i];
    race->max_num = 100;
    if (rf_has(race->flags, RF_UNIQUE)) race->max_num = 1;
  }
  rd_string(buf, sizeof(buf));
  while (!streq(buf, "No more monsters")) {
    struct monster_race* race = lookup_monster(buf);
    rd_u16b(&nkill);
    rd_u16b(&nsight);
    if (!race) continue;
    l_list[race->ridx].pkills = nkill;
    if (rf_has(race->flags, RF_UNIQUE) && nkill) race->max_num = 0;
    l_list[race->ridx].psights = nsight;
    rd_string(buf, sizeof(buf));
  }
  return 0;
}
STATIC_OVL int
rd_object_memory(void)
{
  size_t i;
  uint16_t tmp16u;
  rd_u16b(&tmp16u);
  if (tmp16u > z_info->k_max) {
    note(format("Too many (%u) object kinds!", tmp16u));
    return (-1);
  }
  rd_byte(&of_size);
  if (of_size > OF_SIZE) {
    note(format("Too many (%u) object flags!", of_size));
    return (-1);
  }
  rd_byte(&obj_mod_max);
  if (obj_mod_max > OBJ_MOD_MAX) {
    note(format("Too many (%u) object modifiers allowed!", obj_mod_max));
    return (-1);
  }
  rd_byte(&elem_max);
  if (elem_max > ELEM_MAX) {
    note(format("Too many (%u) elements allowed!", elem_max));
    return (-1);
  }
  rd_byte(&brand_max);
  if (brand_max > z_info->brand_max) {
    note(format("Too many (%u) brands allowed!", brand_max));
    return (-1);
  }
  rd_byte(&slay_max);
  if (slay_max > z_info->slay_max) {
    note(format("Too many (%u) slays allowed!", slay_max));
    return (-1);
  }
  for (i = 0; i < tmp16u; i++) {
    uint8_t tmp8u;
    struct object_kind* kind = &k_info[i];
    rd_byte(&tmp8u);
    kind->aware = (tmp8u & 0x01) ? true : false;
    kind->tried = (tmp8u & 0x02) ? true : false;
    kind->everseen = (tmp8u & 0x08) ? true : false;
    if (tmp8u & 0x04) kind_ignore_when_aware(kind);
    if (tmp8u & 0x10) kind_ignore_when_unaware(kind);
  }
  return 0;
}
STATIC_OVL int
rd_player(void)
{
  int i;
  uint8_t tmp8u, num;
  uint8_t stat_max = 0;
  uint8_t skill_max = 0;
  uint16_t vault_max = 0;
  char buf[80];
  struct player_sex* s;
  struct player_race* r;
  struct player_house* h;
  rd_string(player->full_name, sizeof(player->full_name));
  rd_string(player->died_from, 80);
  player->history = mem_zalloc(250);
  rd_string(player->history, 250);
  rd_string(buf, sizeof(buf));
  for (r = races; r; r = r->next) {
    if (streq(r->name, buf)) {
      player->race = r;
      break;
    }
  }
  if (!player->race) {
    note(format("Invalid player race (%s).", buf));
    return -1;
  }
  rd_string(buf, sizeof(buf));
  for (h = houses; h; h = h->next) {
    if (streq(h->name, buf)) {
      player->house = h;
      break;
    }
  }
  if (!player->house) {
    note(format("Invalid player house (%s).", buf));
    return -1;
  }
  rd_string(buf, sizeof(buf));
  for (s = sexes; s; s = s->next) {
    if (streq(s->name, buf)) {
      player->sex = s;
      break;
    }
  }
  if (!player->sex) {
    note(format("Invalid player sex (%s).", buf));
    return -1;
  }
  rd_byte(&player->opts.name_suffix);
  rd_s16b(&player->game_type);
  rd_s16b(&player->age);
  rd_s16b(&player->ht);
  rd_s16b(&player->wt);
  rd_s16b(&player->ht_birth);
  rd_s16b(&player->wt_birth);
  rd_byte(&stat_max);
  if (stat_max > STAT_MAX) {
    note(format("Too many stats (%d).", stat_max));
    return -1;
  }
  for (i = 0; i < stat_max; i++) rd_s16b(&player->stat_base[i]);
  for (i = 0; i < stat_max; i++) rd_s16b(&player->stat_drain[i]);
  rd_byte(&skill_max);
  if (skill_max > SKILL_MAX) {
    note(format("Too many skills (%d).", skill_max));
    return -1;
  }
  for (i = 0; i < skill_max; i++) rd_s16b(&player->skill_base[i]);
  while (true) {
    struct ability* ability;
    rd_string(buf, sizeof(buf));
    if (streq(buf, "end")) break;
    rd_byte(&tmp8u);
    ability = lookup_ability(tmp8u, buf);
    if (ability == NULL) {
      note(format("Ability not found (%s).", buf));
      return -1;
    }
    add_ability(&player->abilities, ability);
    rd_byte(&tmp8u);
    if (tmp8u) {
      struct ability* instance = player->abilities;
      instance = locate_ability(player->abilities, ability);
      instance->active = true;
    }
  }
  while (true) {
    struct ability* ability;
    rd_string(buf, sizeof(buf));
    if (streq(buf, "end")) break;
    rd_byte(&tmp8u);
    ability = lookup_ability(tmp8u, buf);
    if (ability == NULL) {
      note(format("Ability not found (%s).", buf));
      return -1;
    }
    add_ability(&player->item_abilities, ability);
    rd_byte(&tmp8u);
    if (tmp8u) {
      struct ability* instance = player->item_abilities;
      instance = locate_ability(player->item_abilities, ability);
      instance->active = true;
    }
  }
  for (i = 0; i < MAX_ACTION; i++) {
    rd_byte(&tmp8u);
    player->previous_action[i] = tmp8u;
  }
  rd_string(buf, sizeof(buf));
  player->body.name = string_make(buf);
  rd_u16b(&player->body.count);
  if (player->body.count > z_info->equip_slots_max) {
    note(format("Too many (%u) body parts!", player->body.count));
    return (-1);
  }
  player->body.slots =
      mem_zalloc(player->body.count * sizeof(struct equip_slot));
  for (i = 0; i < player->body.count; i++) {
    rd_u16b(&player->body.slots[i].type);
    rd_string(buf, sizeof(buf));
    player->body.slots[i].name = string_make(buf);
  }
  rd_s32b(&player->new_exp);
  rd_s32b(&player->exp);
  rd_s32b(&player->encounter_exp);
  rd_s32b(&player->kill_exp);
  rd_s32b(&player->descent_exp);
  rd_s32b(&player->ident_exp);
  rd_s32b(&player->turn);
  rd_s16b(&player->mhp);
  rd_s16b(&player->chp);
  rd_s16b(&player->msp);
  rd_s16b(&player->csp);
  rd_s16b(&player->max_depth);
  rd_u16b(&player->staircasiness);
  if (player->max_depth < 0) player->max_depth = 1;
  if (player->chp >= 0)
    my_strcpy(player->died_from, "(alive and well)", sizeof(player->died_from));
  rd_s16b(&player->energy);
  rd_u32b(&player->total_energy);
  rd_u32b(&player->resting_turn);
  rd_byte(&num);
  if (num <= TMD_MAX) {
    for (i = 0; i < num; i++) rd_s16b(&player->timed[i]);
    if (num < TMD_MAX)
      memset(player->timed + num, 0, (TMD_MAX - num) * sizeof(int16_t));
  } else {
    for (i = 0; i < TMD_MAX; i++) rd_s16b(&player->timed[i]);
    strip_bytes(2 * (num - TMD_MAX));
    note("Discarded unsupported timed effects");
  }
  rd_u16b(&vault_max);
  if (vault_max > z_info->v_max) {
    note(format("Too many (%u) vaults!", vault_max));
    return (-1);
  }
  for (i = 0; i < vault_max; i++) {
    rd_byte(&tmp8u);
    player->vaults[i] = tmp8u ? true : false;
  }
  rd_byte(&player->unignoring);
  rd_s16b(&player->last_attack_m_idx);
  rd_s16b(&player->consecutive_attacks);
  rd_s16b(&player->bane_type);
  rd_byte(&tmp8u);
  player->focused = tmp8u ? true : false;
  rd_byte(&tmp8u);
  player->song[SONG_MAIN] = song_by_idx(tmp8u);
  rd_byte(&tmp8u);
  player->song[SONG_MINOR] = song_by_idx(tmp8u);
  rd_s16b(&player->song_duration);
  rd_s16b(&player->wrath);
  rd_u16b(&player->stairs_taken);
  rd_u16b(&player->forge_drought);
  rd_u16b(&player->forge_count);
  rd_byte(&tmp8u);
  player->stealth_mode = tmp8u;
  rd_byte(&player->self_made_arts);
  rd_byte(&tmp8u);
  player->truce = tmp8u ? true : false;
  rd_byte(&player->morgoth_hits);
  rd_byte(&tmp8u);
  player->crown_hint = tmp8u ? true : false;
  rd_byte(&tmp8u);
  player->crown_shatter = tmp8u ? true : false;
  rd_byte(&tmp8u);
  player->cursed = tmp8u ? true : false;
  rd_byte(&tmp8u);
  player->on_the_run = tmp8u ? true : false;
  rd_byte(&tmp8u);
  player->morgoth_slain = tmp8u ? true : false;
  rd_byte(&tmp8u);
  player->escaped = tmp8u ? true : false;
  rd_u16b(&player->noscore);
  rd_s16b(&player->smithing_leftover);
  rd_byte(&tmp8u);
  player->unique_forge_made = tmp8u ? true : false;
  rd_byte(&tmp8u);
  player->unique_forge_seen = tmp8u ? true : false;
  return 0;
}
STATIC_OVL int
rd_ignore(void)
{
  size_t i, j;
  uint8_t tmp8u = 24;
  uint16_t file_e_max;
  uint16_t itype_size;
  uint16_t inscriptions;
  rd_byte(&tmp8u);
  if (tmp8u != ignore_size) {
    strip_bytes(tmp8u);
  } else {
    for (i = 0; i < ignore_size; i++) rd_byte(&ignore_level[i]);
  }
  rd_u16b(&file_e_max);
  rd_u16b(&itype_size);
  if (itype_size > ITYPE_SIZE) {
    note(format("Too many (%u) ignore bytes!", itype_size));
    return (-1);
  }
  for (i = 0; i < file_e_max; i++) {
    if (i < z_info->e_max) {
      bitflag flags, itypes[ITYPE_SIZE];
      rd_byte(&flags);
      e_info[i].everseen = (flags & 0x02) ? true : false;
      e_info[i].aware = (flags & 0x04) ? true : false;
      for (j = 0; j < itype_size; j++) rd_byte(&itypes[j]);
      if (itype_size == ITYPE_SIZE) {
        for (j = ITYPE_NONE; j < ITYPE_MAX; j++)
          if (itype_has(itypes, j)) ego_ignore_toggle(i, j);
      }
    }
  }
  rd_u16b(&inscriptions);
  for (i = 0; i < inscriptions; i++) {
    char tmp[80];
    uint8_t tval, sval;
    struct object_kind* k;
    rd_string(tmp, sizeof(tmp));
    tval = tval_find_idx(tmp);
    rd_string(tmp, sizeof(tmp));
    sval = lookup_sval(tval, tmp);
    k = lookup_kind(tval, sval);
    if (!k) quit_fmt("lookup_kind(%d, %d) failed", tval, sval);
    rd_string(tmp, sizeof(tmp));
    k->note_aware = quark_add(tmp);
  }
  rd_u16b(&inscriptions);
  for (i = 0; i < inscriptions; i++) {
    char tmp[80];
    uint8_t tval, sval;
    struct object_kind* k;
    rd_string(tmp, sizeof(tmp));
    tval = tval_find_idx(tmp);
    rd_string(tmp, sizeof(tmp));
    sval = lookup_sval(tval, tmp);
    k = lookup_kind(tval, sval);
    if (!k) quit_fmt("lookup_kind(%d, %d) failed", tval, sval);
    rd_string(tmp, sizeof(tmp));
    k->note_unaware = quark_add(tmp);
  }
  return 0;
}
STATIC_OVL int
rd_misc(void)
{
  size_t i;
  uint8_t tmp8u;
  rd_u32b(&seed_randart);
  rd_u32b(&seed_flavor);
  flavor_init();
  rd_u16b(&player->noscore);
  rd_byte(&tmp8u);
  player->is_dead = tmp8u;
  rd_s32b(&turn);
  if (player->self_made_arts > 0) {
    activate_randart_file();
    run_parser(&randart_parser);
    deactivate_randart_file();
  }
  for (i = 0; i < OF_SIZE; i++) rd_byte(&player->obj_k->flags[i]);
  for (i = 0; i < OBJ_MOD_MAX; i++) {
    rd_s16b(&player->obj_k->modifiers[i]);
  }
  for (i = 0; i < ELEM_MAX; i++) {
    rd_s16b(&player->obj_k->el_info[i].res_level);
    rd_byte(&player->obj_k->el_info[i].flags);
  }
  for (i = 0; i < brand_max; i++) {
    rd_byte(&tmp8u);
    player->obj_k->brands[i] = tmp8u ? true : false;
  }
  for (i = 0; i < slay_max; i++) {
    rd_byte(&tmp8u);
    player->obj_k->slays[i] = tmp8u ? true : false;
  }
  rd_s16b(&player->obj_k->att);
  rd_s16b(&player->obj_k->evn);
  rd_byte(&player->obj_k->pd);
  rd_byte(&player->obj_k->ps);
  rd_byte(&player->obj_k->dd);
  rd_byte(&player->obj_k->ds);
  return 0;
}
STATIC_OVL int
rd_artifacts(void)
{
  int i;
  uint16_t tmp16u;
  const struct artifact* crown = lookup_artifact_name("of Morgoth");
  rd_u16b(&tmp16u);
  if (tmp16u > z_info->a_max) {
    if (!player->is_dead) {
      note(format("Too many (%u) artifacts!", tmp16u));
      return (-1);
    }
    tmp16u = z_info->a_max;
  } else if (tmp16u < z_info->a_max) {
    if (!player->is_dead) {
      note(format("Expected %u artifacts; got %u.", z_info->a_max, tmp16u));
    }
  }
  for (i = 0; i < tmp16u; i++) {
    uint8_t tmp8u;
    rd_byte(&tmp8u);
    aup_info[i].created = tmp8u ? true : false;
    rd_byte(&tmp8u);
    aup_info[i].seen = tmp8u ? true : false;
    rd_byte(&tmp8u);
    aup_info[i].everseen = tmp8u ? true : false;
    rd_byte(&tmp8u);
  }
  if (is_artifact_created(crown)) {
    struct monster_race* race = lookup_monster("Morgoth, Lord of Darkness");
    race->pd -= 1;
    race->light = 0;
    race->wil += 5;
    race->per += 5;
  }
  return 0;
}
STATIC_OVL int
rd_gear_aux(struct object** gear)
{
  uint8_t code;
  struct object* last_gear_obj = NULL;
  rd_byte(&code);
  while (code != FINISHED_CODE) {
    struct object* obj = rd_item();
    if (!obj) {
      note("Error reading item");
      return (-1);
    }
    obj->prev = last_gear_obj;
    if (last_gear_obj)
      last_gear_obj->next = obj;
    else
      *gear = obj;
    last_gear_obj = obj;
    if (code < player->body.count) {
      player->body.slots[code].obj = obj;
      player->upkeep->equip_cnt++;
    }
    rd_byte(&code);
  }
  return (0);
}
STATIC_OVL int
rd_gear(void)
{
  struct object *obj, *known_obj;
  if (rd_gear_aux(&player->gear)) return -1;
  if (rd_gear_aux(&player->gear_k)) return -1;
  for (obj = player->gear, known_obj = player->gear_k; obj;
       obj = obj->next, known_obj = known_obj->next) {
    obj->known = known_obj;
    player->upkeep->total_weight += obj->number * obj->weight;
  }
  calc_inventory(player);
  return 0;
}
STATIC_OVL int
rd_dungeon_aux(struct chunk** c)
{
  struct chunk* c1;
  int i, n, y, x;
  uint16_t height, width;
  uint8_t count;
  uint8_t tmp8u;
  char name[100];
  rd_string(name, sizeof(name));
  rd_u16b(&height);
  rd_u16b(&width);
  c1 = cave_new(height, width);
  c1->name = string_make(name);
  rd_byte(&tmp8u);
  if (tmp8u) {
    rd_string(name, sizeof(name));
    c1->vault_name = string_make(name);
  }
  for (n = 0; n < square_size; n++) {
    for (x = y = 0; y < c1->height;) {
      rd_byte(&count);
      rd_byte(&tmp8u);
      for (i = count; i > 0; i--) {
        c1->squares[y][x].info[n] = tmp8u;
        if (++x >= c1->width) {
          x = 0;
          if (++y >= c1->height) break;
        }
      }
    }
  }
  for (x = y = 0; y < c1->height;) {
    rd_byte(&count);
    rd_byte(&tmp8u);
    for (i = count; i > 0; i--) {
      square_set_feat(c1, loc(x, y), tmp8u);
      if (++x >= c1->width) {
        x = 0;
        if (++y >= c1->height) break;
      }
    }
  }
  *c = c1;
  return 0;
}
STATIC_OVL int
rd_objects_aux(struct chunk* c)
{
  int i;
  if (player->is_dead) return 0;
  rd_u16b(&c->obj_max);
  c->objects =
      mem_realloc(c->objects, (c->obj_max + 1) * sizeof(struct object*));
  for (i = 0; i <= c->obj_max; i++) c->objects[i] = NULL;
  while (true) {
    struct object* obj = rd_item();
    if (!obj) break;
    if (square_in_bounds_fully(c, obj->grid)) {
      pile_insert_end(&c->squares[obj->grid.y][obj->grid.x].obj, obj);
    }
    assert(obj->oidx);
    assert(c->objects[obj->oidx] == NULL);
    c->objects[obj->oidx] = obj;
  }
  return 0;
}
STATIC_OVL int
rd_monsters_aux(struct chunk* c)
{
  int i;
  uint16_t limit;
  if (player->is_dead) return 0;
  rd_u16b(&limit);
  if (limit > z_info->level_monster_max) {
    note(format("Too many (%d) monster entries!", limit));
    return (-1);
  }
  for (i = 1; i < limit; i++) {
    struct monster* mon;
    struct monster monster_body;
    mon = &monster_body;
    memset(mon, 0, sizeof(*mon));
    if (!rd_monster(c, mon)) {
      note(format("Cannot read monster %d", i));
      return (-1);
    }
    if (place_monster(c, mon->grid, mon, mon->origin) != i) {
      note(format("Cannot place monster %d", i));
      return (-1);
    }
    mon = cave_monster(c, mon->midx);
    flow_new(c, &mon->flow);
  }
  return 0;
}
STATIC_OVL int
rd_traps_aux(struct chunk* c)
{
  struct loc grid;
  struct trap* trap;
  if (player->is_dead) return 0;
  rd_byte(&trf_size);
  while (true) {
    trap = mem_zalloc(sizeof(*trap));
    rd_trap(trap);
    grid = trap->grid;
    if (loc_is_zero(grid))
      break;
    else {
      trap->next = square_trap(c, grid);
      square_set_trap(c, grid, trap);
    }
  }
  mem_free(trap);
  return 0;
}
STATIC_OVL int
rd_dungeon(void)
{
  uint16_t depth;
  uint16_t py, px;
  rd_u16b(&depth);
  rd_u16b(&daycount);
  rd_u16b(&py);
  rd_u16b(&px);
  rd_byte(&square_size);
  if (player->is_dead) return 0;
  if (depth > z_info->dun_depth) {
    note(format("Ignoring illegal dungeon depth (%d)", depth));
    return (0);
  }
  if (rd_dungeon_aux(&cave)) return 1;
  if ((px >= cave->width) || (py >= cave->height)) {
    note(format("Ignoring illegal player location (%d,%d).", py, px));
    return (1);
  }
  player->depth = depth;
  cave->depth = depth;
  player_place(cave, player, loc(px, py));
  character_dungeon = true;
  if (rd_dungeon_aux(&player->cave)) {
    return 1;
  }
  player->cave->depth = depth;
  return 0;
}
STATIC_OVL int
rd_objects(void)
{
  if (rd_objects_aux(cave)) return -1;
  if (rd_objects_aux(player->cave)) return -1;
  return 0;
}
STATIC_OVL int
rd_monsters(void)
{
  int i;
  if (player->is_dead) return 0;
  if (rd_monsters_aux(cave)) return -1;
  if (rd_monsters_aux(player->cave)) return -1;
  for (i = 0; i < player->cave->obj_max; i++)
    if (cave->objects[i] && player->cave->objects[i])
      cave->objects[i]->known = player->cave->objects[i];
  return 0;
}
STATIC_OVL int
rd_traps(void)
{
  if (rd_traps_aux(cave)) return -1;
  if (rd_traps_aux(player->cave)) return -1;
  return 0;
}
STATIC_OVL int
rd_history(void)
{
  uint32_t tmp32u;
  size_t i, j;
  history_clear(player);
  rd_byte(&hist_size);
  if (hist_size > HIST_SIZE) {
    note(format("Too many (%u) history types!", hist_size));
    return (-1);
  }
  rd_u32b(&tmp32u);
  for (i = 0; i < tmp32u; i++) {
    int32_t turnno;
    int16_t dlev;
    bitflag type[HIST_SIZE];
    const struct artifact* art = NULL;
    int aidx = 0;
    char name[80];
    char text[80];
    for (j = 0; j < hist_size; j++) rd_byte(&type[j]);
    rd_s32b(&turnno);
    rd_s16b(&dlev);
    rd_string(name, sizeof(name));
    if (name[0]) {
      art = lookup_artifact_name(name);
      if (art) {
        aidx = art->aidx;
      }
    }
    rd_string(text, sizeof(text));
    if (name[0] && !art) {
      note(format("Couldn't find artifact %s!", name));
      continue;
    }
    history_add_full(player, type, aidx, dlev, turnno, text);
  }
  return 0;
}
STATIC_OVL int
rd_null(void)
{
  return 0;
}
STATIC_OVL int
rd_monster_groups(void)
{
  uint16_t tmp16u;
  uint8_t tmp8u;
  int16_t tmp16s;
  struct monster_group* group;
  if (player->is_dead) return 0;
  rd_u16b(&tmp16u);
  while (tmp16u) {
    group = cave->monster_groups[tmp16u];
    rd_byte(&tmp8u);
    group->flow.centre.x = tmp8u;
    rd_byte(&tmp8u);
    group->flow.centre.y = tmp8u;
    rd_s16b(&tmp16s);
    group->wandering_pause = tmp16s;
    rd_u16b(&tmp16u);
  }
  return 0;
}
STATIC_OVL void
messages_init(void)
{
  messages = mem_zalloc(sizeof(msgqueue_t));
  messages->max = 2048;
}
STATIC_OVL void
messages_free(void)
{
  msgcolor_t* c = messages->colors;
  msgcolor_t* nextc;
  message_t* m = messages->head;
  message_t* nextm;
  while (m) {
    nextm = m->older;
    mem_free(m->str);
    mem_free(m);
    m = nextm;
  }
  while (c) {
    nextc = c->next;
    mem_free(c);
    c = nextc;
  }
  mem_free(messages);
}
STATIC_OVL uint16_t
messages_num(void)
{
  return messages->count;
}
STATIC_OVL void
message_add(const char* str, uint16_t type)
{
  message_t* m;
  if (messages->head && messages->head->type == type &&
      streq(messages->head->str, str) &&
      messages->head->count != (uint16_t)-1) {
    messages->head->count++;
    return;
  }
  m = mem_zalloc(sizeof(message_t));
  m->str = string_make(str);
  m->type = type;
  m->count = 1;
  m->older = messages->head;
  if (messages->head) messages->head->newer = m;
  messages->head = m;
  messages->count++;
  if (!messages->tail) messages->tail = m;
  if (messages->count > messages->max) {
    message_t* old_tail = messages->tail;
    messages->tail = old_tail->newer;
    messages->tail->older = NULL;
    mem_free(old_tail->str);
    mem_free(old_tail);
    messages->count--;
  }
}
STATIC_OVL message_t*
message_get(uint16_t age)
{
  message_t* m = messages->head;
  while (m && age) {
    age--;
    m = m->older;
  }
  return m;
}
STATIC_OVL const char*
message_str(uint16_t age)
{
  message_t* m = message_get(age);
  return (m ? m->str : "");
}
STATIC_OVL uint16_t
message_count(uint16_t age)
{
  message_t* m = message_get(age);
  return (m ? m->count : 0);
}
STATIC_OVL uint16_t
message_type(uint16_t age)
{
  message_t* m = message_get(age);
  return (m ? m->type : 0);
}
STATIC_OVL uint8_t
message_color(uint16_t age)
{
  message_t* m = message_get(age);
  return (m ? message_type_color(m->type) : COLOUR_WHITE);
}
STATIC_OVL void
message_color_define(uint16_t type, uint8_t color)
{
  msgcolor_t* mc;
  if (!messages->colors) {
    messages->colors = mem_zalloc(sizeof(msgcolor_t));
    messages->colors->type = type;
    messages->colors->color = color;
    return;
  }
  mc = messages->colors;
  while (1) {
    if (mc->type == type) {
      mc->color = color;
      break;
    }
    if (!mc->next) {
      mc->next = mem_zalloc(sizeof(msgcolor_t));
      mc->next->type = type;
      mc->next->color = color;
      break;
    }
    mc = mc->next;
  }
}
STATIC_OVL uint8_t
message_type_color(uint16_t type)
{
  msgcolor_t* mc;
  uint8_t color = COLOUR_WHITE;
  if (messages) {
    mc = messages->colors;
    while (mc && mc->type != type) mc = mc->next;
    if (mc && (mc->color != COLOUR_DARK)) color = mc->color;
  }
  return color;
}
STATIC_OVL int
message_lookup_by_name(const char* name)
{
  static const char* message_names[] = {
      "GENERIC",       "BIRTH",         "HIT",           "MISS",
      "FLEE",          "DROP",          "KILL",          "LEVEL",
      "DEATH",         "STUDY",         "TELEPORT",      "SHOOT",
      "QUAFF",         "ZAP_ROD",       "WALK",          "TPOTHER",
      "HITWALL",       "EAT",           "STORE1",        "STORE2",
      "STORE3",        "STORE4",        "DIG",           "OPENDOOR",
      "SHUTDOOR",      "TPLEVEL",       "BELL",          "NOTHING_TO_OPEN",
      "LOCKPICK_FAIL", "STAIRS_DOWN",   "HITPOINT_WARN", "ACT_ARTIFACT",
      "USE_STAFF",     "DESTROY",       "MON_HIT",       "MON_TOUCH",
      "MON_PUNCH",     "MON_KICK",      "MON_CLAW",      "MON_BITE",
      "MON_STING",     "MON_BUTT",      "MON_CRUSH",     "MON_ENGULF",
      "MON_CRAWL",     "MON_DROOL",     "MON_SPIT",      "MON_GAZE",
      "MON_WAIL",      "MON_SPORE",     "MON_BEG",       "MON_INSULT",
      "MON_MOAN",      "RECOVER",       "BLIND",         "CONFUSED",
      "POISONED",      "AFRAID",        "PARALYZED",     "DRUGGED",
      "SPEED",         "SLOW",          "SHIELD",        "BLESSED",
      "HERO",          "BERSERK",       "BOLD",          "PROT_EVIL",
      "INVULN",        "SEE_INVIS",     "INFRARED",      "RES_ACID",
      "RES_ELEC",      "RES_FIRE",      "RES_COLD",      "RES_POIS",
      "STUN",          "CUT",           "STAIRS_UP",     "STORE_ENTER",
      "STORE_LEAVE",   "STORE_HOME",    "MONEY1",        "MONEY2",
      "MONEY3",        "SHOOT_HIT",     "STORE5",        "LOCKPICK",
      "DISARM",        "IDENT_BAD",     "IDENT_EGO",     "IDENT_ART",
      "BR_ELEMENTS",   "BR_FROST",      "BR_ELEC",       "BR_ACID",
      "BR_GAS",        "BR_FIRE",       "BR_DISEN",      "BR_CHAOS",
      "BR_SHARDS",     "BR_SOUND",      "BR_LIGHT",      "BR_DARK",
      "BR_NETHER",     "BR_NEXUS",      "BR_TIME",       "BR_INERTIA",
      "BR_GRAVITY",    "BR_PLASMA",     "BR_FORCE",      "SUM_MONSTER",
      "SUM_AINU",      "SUM_UNDEAD",    "SUM_ANIMAL",    "SUM_SPIDER",
      "SUM_HOUND",     "SUM_HYDRA",     "SUM_DEMON",     "SUM_DRAGON",
      "SUM_HI_UNDEAD", "SUM_HI_DRAGON", "SUM_HI_DEMON",  "SUM_WRAITH",
      "SUM_UNIQUE",    "WIELD",         "QUIVER",        "CURSED",
      "RUNE",          "HUNGRY",        "NOTICE",        "AMBIENT_DAY",
      "AMBIENT_NITE",  "AMBIENT_DNG1",  "AMBIENT_DNG2",  "AMBIENT_DNG3",
      "AMBIENT_DNG4",  "AMBIENT_DNG5",  "CREATE_TRAP",   "SHRIEK",
      "CAST_FEAR",     "HIT_GOOD",      "HIT_GREAT",     "HIT_SUPERB",
      "HIT_HI_GREAT",  "HIT_HI_SUPERB", "SPELL",         "PRAYER",
      "KILL_UNIQUE",   "KILL_KING",     "DRAIN_STAT",    "MULTIPLY",
      "SCRAMBLE",      "MAX",
  };
  size_t i;
  char* pe;
  unsigned long number = strtoul(name, &pe, 10);
  if (pe != name) {
    return (contains_only_spaces(pe) && number < MSG_MAX) ? (int)number : -1;
  }
  for (i = 0; i < N_ELEMENTS(message_names); i++) {
    if (my_stricmp(name, message_names[i]) == 0) return (int)i;
  }
  return -1;
}
STATIC_OVL int
message_lookup_by_sound_name(const char* name)
{
  static const char* sound_names[] = {
      "",
      "",
      "hit",
      "miss",
      "flee",
      "drop",
      "kill",
      "level",
      "death",
      "study",
      "teleport",
      "shoot",
      "quaff",
      "zap_rod",
      "walk",
      "tpother",
      "hitwall",
      "eat",
      "store1",
      "store2",
      "store3",
      "store4",
      "dig",
      "opendoor",
      "shutdoor",
      "tplevel",
      "bell",
      "nothing_to_open",
      "lockpick_fail",
      "stairs_down",
      "hitpoint_warn",
      "act_artifact",
      "use_staff",
      "destroy",
      "mon_hit",
      "mon_touch",
      "mon_punch",
      "mon_kick",
      "mon_claw",
      "mon_bite",
      "mon_sting",
      "mon_butt",
      "mon_crush",
      "mon_engulf",
      "mon_crawl",
      "mon_drool",
      "mon_spit",
      "mon_gaze",
      "mon_wail",
      "mon_spore",
      "mon_beg",
      "mon_insult",
      "mon_moan",
      "recover",
      "blind",
      "confused",
      "poisoned",
      "afraid",
      "paralyzed",
      "drugged",
      "speed",
      "slow",
      "shield",
      "blessed",
      "hero",
      "berserk",
      "bold",
      "prot_evil",
      "invuln",
      "see_invis",
      "infrared",
      "res_acid",
      "res_elec",
      "res_fire",
      "res_cold",
      "res_pois",
      "stun",
      "cut",
      "stairs_up",
      "store_enter",
      "store_leave",
      "store_home",
      "money1",
      "money2",
      "money3",
      "shoot_hit",
      "store5",
      "lockpick",
      "disarm",
      "identify_bad",
      "identify_ego",
      "identify_art",
      "breathe_elements",
      "breathe_frost",
      "breathe_elec",
      "breathe_acid",
      "breathe_gas",
      "breathe_fire",
      "breathe_disenchant",
      "breathe_chaos",
      "breathe_shards",
      "breathe_sound",
      "breathe_light",
      "breathe_dark",
      "breathe_nether",
      "breathe_nexus",
      "breathe_time",
      "breathe_inertia",
      "breathe_gravity",
      "breathe_plasma",
      "breathe_force",
      "summon_monster",
      "summon_ainu",
      "summon_undead",
      "summon_animal",
      "summon_spider",
      "summon_hound",
      "summon_hydra",
      "summon_demon",
      "summon_dragon",
      "summon_gr_undead",
      "summon_gr_dragon",
      "summon_gr_demon",
      "summon_ringwraith",
      "summon_unique",
      "wield",
      "quiver",
      "cursed",
      "rune",
      "hungry",
      "notice",
      "ambient_day",
      "ambient_nite",
      "ambient_dng1",
      "ambient_dng2",
      "ambient_dng3",
      "ambient_dng4",
      "ambient_dng5",
      "mon_create_trap",
      "mon_shriek",
      "mon_cast_fear",
      "hit_good",
      "hit_great",
      "hit_superb",
      "hit_hi_great",
      "hit_hi_superb",
      "cast_spell",
      "pray_prayer",
      "kill_unique",
      "kill_king",
      "drain_stat",
      "multiply",
      "scramble",
      NULL,
  };
  size_t i;
  for (i = 0; i < N_ELEMENTS(sound_names) - 1; i++) {
    if (my_stricmp(name, sound_names[i]) == 0) return (int)i;
  }
  return MSG_GENERIC;
}
STATIC_OVL const char*
message_sound_name(int message)
{
  static const char* sound_names[] = {
      "",
      "",
      "hit",
      "miss",
      "flee",
      "drop",
      "kill",
      "level",
      "death",
      "study",
      "teleport",
      "shoot",
      "quaff",
      "zap_rod",
      "walk",
      "tpother",
      "hitwall",
      "eat",
      "store1",
      "store2",
      "store3",
      "store4",
      "dig",
      "opendoor",
      "shutdoor",
      "tplevel",
      "bell",
      "nothing_to_open",
      "lockpick_fail",
      "stairs_down",
      "hitpoint_warn",
      "act_artifact",
      "use_staff",
      "destroy",
      "mon_hit",
      "mon_touch",
      "mon_punch",
      "mon_kick",
      "mon_claw",
      "mon_bite",
      "mon_sting",
      "mon_butt",
      "mon_crush",
      "mon_engulf",
      "mon_crawl",
      "mon_drool",
      "mon_spit",
      "mon_gaze",
      "mon_wail",
      "mon_spore",
      "mon_beg",
      "mon_insult",
      "mon_moan",
      "recover",
      "blind",
      "confused",
      "poisoned",
      "afraid",
      "paralyzed",
      "drugged",
      "speed",
      "slow",
      "shield",
      "blessed",
      "hero",
      "berserk",
      "bold",
      "prot_evil",
      "invuln",
      "see_invis",
      "infrared",
      "res_acid",
      "res_elec",
      "res_fire",
      "res_cold",
      "res_pois",
      "stun",
      "cut",
      "stairs_up",
      "store_enter",
      "store_leave",
      "store_home",
      "money1",
      "money2",
      "money3",
      "shoot_hit",
      "store5",
      "lockpick",
      "disarm",
      "identify_bad",
      "identify_ego",
      "identify_art",
      "breathe_elements",
      "breathe_frost",
      "breathe_elec",
      "breathe_acid",
      "breathe_gas",
      "breathe_fire",
      "breathe_disenchant",
      "breathe_chaos",
      "breathe_shards",
      "breathe_sound",
      "breathe_light",
      "breathe_dark",
      "breathe_nether",
      "breathe_nexus",
      "breathe_time",
      "breathe_inertia",
      "breathe_gravity",
      "breathe_plasma",
      "breathe_force",
      "summon_monster",
      "summon_ainu",
      "summon_undead",
      "summon_animal",
      "summon_spider",
      "summon_hound",
      "summon_hydra",
      "summon_demon",
      "summon_dragon",
      "summon_gr_undead",
      "summon_gr_dragon",
      "summon_gr_demon",
      "summon_ringwraith",
      "summon_unique",
      "wield",
      "quiver",
      "cursed",
      "rune",
      "hungry",
      "notice",
      "ambient_day",
      "ambient_nite",
      "ambient_dng1",
      "ambient_dng2",
      "ambient_dng3",
      "ambient_dng4",
      "ambient_dng5",
      "mon_create_trap",
      "mon_shriek",
      "mon_cast_fear",
      "hit_good",
      "hit_great",
      "hit_superb",
      "hit_hi_great",
      "hit_hi_superb",
      "cast_spell",
      "pray_prayer",
      "kill_unique",
      "kill_king",
      "drain_stat",
      "multiply",
      "scramble",
      NULL,
  };
  if (message < MSG_GENERIC || message >= MSG_MAX) return NULL;
  return sound_names[message];
}
STATIC_OVL void
sound(int type)
{
  if (!OPT(player, use_sound)) return;
  event_signal_message(EVENT_SOUND, type, NULL);
}
STATIC_OVL void
bell(void)
{
  event_signal_message(EVENT_BELL, MSG_BELL, NULL);
}
STATIC_OVL void
msg(const char* fmt, ...)
{
  va_list vp;
  char buf[1024];
  va_start(vp, fmt);
  (void)vstrnfmt(buf, sizeof(buf), fmt, vp);
  va_end(vp);
  if (!messages) return;
  message_add(buf, MSG_GENERIC);
  event_signal_message(EVENT_MESSAGE, MSG_GENERIC, buf);
}
STATIC_OVL void
msgt(unsigned int type, const char* fmt, ...)
{
  va_list vp;
  char buf[1024];
  va_start(vp, fmt);
  vstrnfmt(buf, sizeof(buf), fmt, vp);
  va_end(vp);
  if (!messages) return;
  message_add(buf, type);
  sound(type);
  event_signal_message(EVENT_MESSAGE, type, buf);
}
STATIC_OVL int
choose_attack_spell_fast(const bitflag f[RSF_SIZE], bool do_random)
{
  int i, num = 0;
  uint8_t spells[RSF_MAX];
  for (i = 0; i < RSF_MAX; i++) {
    spells[i] = 0;
  }
  for (i = FLAG_START; i != FLAG_END; i = rsf_next(f, i + 1)) {
    if (rsf_has(f, i)) {
      spells[num++] = i;
    }
  }
  if (num == 0) return 0;
  if (num == 1) {
    return (spells[0]);
  }
  if (!do_random) return 0;
  return (spells[randint0(num)]);
}
STATIC_OVL int
choose_ranged_attack(struct monster* mon)
{
  bitflag f[RSF_SIZE];
  bool do_random = false;
  int best_spell, best_spell_rating = 0;
  int i;
  rsf_copy(f, mon->race->spell_flags);
  remove_bad_spells(mon, f);
  if (!rsf_count(f)) return 0;
  if (rf_has(mon->race->flags, RF_MINDLESS) ||
      (!rf_has(mon->race->flags, RF_SMART) && one_in_(5))) {
    do_random = true;
  }
  best_spell = choose_attack_spell_fast(f, do_random);
  if (best_spell) return best_spell;
  for (i = FLAG_START; i != FLAG_END;
       i = rsf_next(mon->race->spell_flags, i + 1)) {
    int spell_range, cur_spell_rating;
    const struct monster_spell* spell;
    if (!rsf_has(f, i)) continue;
    spell = monster_spell_by_index(i);
    spell_range = spell->best_range;
    cur_spell_rating = spell->desire;
    if (spell_range) {
      int cur_range = mon->cdis;
      while (cur_range > spell_range) {
        cur_spell_rating *= spell->use_past_range;
        cur_spell_rating /= 100;
        --cur_range;
      }
    }
    if (rf_has(mon->race->flags, RF_SMART)) {
      cur_spell_rating += randint0(10);
    } else {
      cur_spell_rating += randint0(50);
    }
    if ((cur_spell_rating > best_spell_rating) ||
        ((cur_spell_rating == best_spell_rating) && one_in_(2))) {
      best_spell_rating = cur_spell_rating;
      best_spell = i;
    }
  }
  if (player->wizard) {
    msg("Spell rating: %i.", best_spell_rating);
  }
  if (!best_spell_rating) return 0;
  assert(best_spell);
  return best_spell;
}
STATIC_OVL bool
make_ranged_attack(struct monster* mon)
{
  struct monster_lore* lore = get_lore(mon->race);
  bool seen = (player->timed[TMD_BLIND] == 0) && monster_is_visible(mon);
  int choice = choose_ranged_attack(mon);
  if (!choice) return false;
  mflag_off(mon->mflag, MFLAG_ALWAYS_CAST);
  do_mon_spell(choice, mon, seen);
  mon->min_range = 0;
  if (seen) {
    rsf_on(lore->spell_flags, choice);
    if (lore->ranged < UCHAR_MAX) lore->ranged++;
  }
  if (player->is_dead && (lore->deaths < SHRT_MAX)) {
    lore->deaths++;
  }
  lore_update(mon->race, lore);
  return true;
}
STATIC_OVL bool
monster_charge(struct monster* mon, struct player* p)
{
  int speed = mon->race->speed;
  int deltay = p->grid.y - mon->grid.y;
  int deltax = p->grid.x - mon->grid.x;
  if (distance(mon->grid, p->grid) > 1) return false;
  if (mon->m_timed[MON_TMD_SLOW]) speed--;
  if (rf_has(mon->race->flags, RF_CHARGE) && (speed >= 2)) {
    int d, i;
    for (i = -1; i <= 1; i++) {
      d = cycle[chome[dir_from_delta(deltay, deltax)] + i];
      if (mon->previous_action[1] == d) {
        return true;
      }
    }
  }
  return false;
}
STATIC_OVL int
elem_bonus(struct player* p, struct blow_effect* effect)
{
  int resistance = 1;
  if (streq(effect->name, "FIRE")) {
    resistance = p->state.el_info[ELEM_FIRE].res_level;
  } else if (streq(effect->name, "COLD")) {
    resistance = p->state.el_info[ELEM_COLD].res_level;
  } else if (streq(effect->name, "POISON")) {
    resistance = p->state.el_info[ELEM_POIS].res_level;
  } else if (streq(effect->name, "DARK")) {
    resistance = p->state.el_info[ELEM_DARK].res_level;
  } else {
    return 0;
  }
  if (resistance == 1) {
    return 1;
  } else if (resistance < 0) {
    return -resistance;
  }
  return 0;
}
STATIC_OVL bool
monster_cut_or_stun(int dice, int dam, struct blow_effect* effect)
{
  if (dam <= 0) return false;
  if (streq(effect->name, "WOUND") || streq(effect->name, "BATTER")) {
    if (dice >= randint1(2)) return true;
  } else if (one_in_(10)) {
    if (dice >= randint1(2)) return true;
  }
  return false;
}
STATIC_OVL void
cruel_blow(struct monster* mon, struct player* p, int dice)
{
  struct monster_lore* lore = get_lore(mon->race);
  int difficulty =
      p->state.skill_use[SKILL_WILL] + (p->state.flags[OF_PROT_CONF] * 10);
  if (skill_check(source_monster(mon->midx), dice * 4, difficulty,
                  source_player()) > 0) {
    if (monster_is_visible(mon)) {
      rf_on(lore->flags, RF_CRUEL_BLOW);
    }
    msg("You reel in pain!");
    player_inc_timed(p, TMD_CONFUSED, dice, true, true, true);
  }
}
STATIC_OVL bool
make_attack_normal(struct monster* mon, struct player* p)
{
  struct monster_lore* lore = get_lore(mon->race);
  int rlev = ((mon->race->level >= 1) ? mon->race->level : 1);
  char m_name[80];
  char ddesc[80];
  int blow;
  struct blow_effect* effect;
  struct blow_method* method;
  int att, dd, ds;
  int total_attack_mod, total_evasion_mod;
  bool visible = monster_is_visible(mon) || (mon->race->light > 0);
  bool obvious = false;
  bool do_cut, do_stun, do_prt;
  int sound_msg = MSG_GENERIC;
  int hit_result = 0;
  int net_dam = 0;
  char* act = NULL;
  bool act_allocated = false;
  monster_desc(m_name, sizeof(m_name), mon, MDESC_STANDARD);
  monster_desc(ddesc, sizeof(ddesc), mon, MDESC_SHOW | MDESC_IND_VIS);
  p->been_attacked = true;
  blow = mon->race->blow[1].method && one_in_(3) ? 1 : 0;
  effect = mon->race->blow[blow].effect;
  method = mon->race->blow[blow].method;
  att = mon->race->blow[blow].dice.base;
  dd = mon->race->blow[blow].dice.dice;
  ds = mon->race->blow[blow].dice.sides;
  total_attack_mod = total_monster_attack(p, mon, att);
  if (monster_charge(mon, p)) {
    total_attack_mod += 3;
    ds += 3;
  }
  total_evasion_mod = total_player_evasion(p, mon, false);
  hit_result = hit_roll(total_attack_mod, total_evasion_mod,
                        source_monster(mon->midx), source_player(), true);
  assert(effect);
  if (streq(effect->name, "NONE") || (hit_result > 0)) {
    melee_effect_handler_f effect_handler;
    int crit_bonus_dice = 0;
    int elem_bonus_dice = 0;
    int dam = 0, prt = 0;
    disturb(p, true);
    act = monster_blow_method_action(method, -1);
    act_allocated = true;
    do_cut = method->cut;
    do_stun = method->stun;
    do_prt = method->prt;
    sound_msg = method->msgt;
    if (streq(method->name, "HIT") && streq(effect->name, "BATTER")) {
      if (act_allocated) {
        string_free(act);
      }
      act = (char*)"batters you";
      act_allocated = false;
    }
    obvious = true;
    crit_bonus_dice =
        crit_bonus(p, hit_result, 20 * dd, NULL, SKILL_MELEE, false);
    elem_bonus_dice = elem_bonus(p, effect);
    if (!do_prt) crit_bonus_dice = 0;
    dam = damroll(dd + crit_bonus_dice + elem_bonus_dice, ds);
    prt = do_prt ? protection_roll(p, PROJ_HURT, true, RANDOMISE) : 0;
    net_dam = MAX((dam - prt), 0);
    if (act) {
      char punct[20];
      attack_punctuation(punct, sizeof(punct), net_dam, crit_bonus_dice);
      if (monster_charge(mon, p)) {
        if (monster_is_visible(mon)) {
          rf_on(lore->flags, RF_CHARGE);
          if (act_allocated) {
            string_free(act);
          }
          act = (char*)"charges you";
          act_allocated = false;
        }
      }
      msgt(sound_msg, "%s %s%s", m_name, act, punct);
      if (act_allocated) {
        string_free(act);
      }
    }
    effect_handler = melee_handler_for_blow_effect(effect->name);
    if (effect_handler != NULL) {
      melee_effect_handler_context_t context = {
          p, mon, rlev, method, ddesc, obvious, do_stun, do_cut, dam, net_dam,
      };
      effect_handler(&context);
      obvious = context.obvious;
      do_stun = context.stun;
      do_cut = context.cut;
      net_dam = context.damage;
      event_signal_combat_damage(
          EVENT_COMBAT_DAMAGE, dd + crit_bonus_dice + elem_bonus_dice, ds, dam,
          -1, -1, prt, do_prt ? 100 : 0, effect->dam_type, true);
      event_signal_hit(EVENT_HIT, net_dam, effect->dam_type, p->is_dead,
                       p->grid);
    } else {
      msg("ERROR: Effect handler not found for %s.", effect->name);
    }
    if (p->is_dead) {
      do_cut = false;
      do_stun = false;
    }
    if (do_cut && do_stun) {
      if (one_in_(2)) {
        do_cut = false;
      } else {
        do_stun = false;
      }
    }
    if ((do_cut) && monster_cut_or_stun(crit_bonus_dice, net_dam, effect)) {
      (void)player_inc_timed(p, TMD_CUT, dam / 2, true, true, true);
    }
    if ((do_stun) && monster_cut_or_stun(crit_bonus_dice, net_dam, effect)) {
      (void)player_inc_timed(p, TMD_STUN, dam, true, true, true);
    }
    if (rf_has(mon->race->flags, RF_CRUEL_BLOW) && (crit_bonus_dice >= 1) &&
        (net_dam > 0)) {
      cruel_blow(mon, p, crit_bonus_dice);
    }
    if (rf_has(mon->race->flags, RF_KNOCK_BACK)) {
      if (blow == 0) {
        if (skill_check(source_monster(mon->midx),
                        monster_stat(mon, STAT_STR) * 2,
                        p->state.stat_use[STAT_CON] * 2, source_player()) > 0) {
          knock_back(mon->grid, p->grid);
          if (monster_is_visible(mon)) {
            rf_on(lore->flags, RF_KNOCK_BACK);
          }
        }
      }
    }
    if ((p->state.flags[OF_COWARDICE] > 0) &&
        (net_dam >= 10 / p->state.flags[OF_COWARDICE])) {
      if (!p->timed[TMD_AFRAID]) {
        if (player_inc_timed(p, TMD_AFRAID, damroll(10, 4), true, true, true)) {
          player_inc_timed(p, TMD_FAST, damroll(5, 4), true, true, true);
          player_learn_flag(p, OF_COWARDICE);
        }
      }
    }
  } else {
    if (monster_is_visible(mon) && !p->timed[TMD_CONFUSED] && method->miss) {
      disturb(p, true);
      if (streq(effect->name, "SHATTER") && (hit_result > -3)) {
        msg("%s just misses you.", m_name);
        if (rf_has(mon->race->flags, RF_QUESTOR)) {
          msg("You leap aside as his great hammer slams into the floor.");
          msg("The ground shakes violently with the force of the blow!");
          effect_simple(EF_EARTHQUAKE, source_monster(mon->midx), "0", 0, 5, 1,
                        NULL);
        } else {
          msg("You leap aside as its stony fist slams into the floor.");
          msg("The ground shakes violently with the force of the blow!");
          effect_simple(EF_EARTHQUAKE, source_monster(mon->midx), "0", 0, 4, 1,
                        NULL);
        }
      } else {
        msg("%s misses you.", m_name);
        if (player_can_riposte(p, hit_result)) {
          msg("You riposte!");
          p->upkeep->riposte = true;
          py_attack_real(p, mon->grid, ATT_RIPOSTE);
        }
      }
    }
  }
  if (lore) {
    if (visible) {
      if (obvious || net_dam || (lore->blows[blow].times_seen > 10)) {
        if (lore->blows[blow].times_seen < UCHAR_MAX)
          lore->blows[blow].times_seen++;
      }
    }
    if (p->is_dead && (lore->deaths < SHRT_MAX)) lore->deaths++;
    lore_update(mon->race, lore);
  }
  return true;
}
STATIC_OVL blow_tag_t
blow_tag_lookup(const char* tag)
{
  if (strncmp(tag, "target", 6) == 0)
    return BLOW_TAG_TARGET;
  else if (strncmp(tag, "oftarget", 8) == 0)
    return BLOW_TAG_OF_TARGET;
  else if (strncmp(tag, "has", 3) == 0)
    return BLOW_TAG_HAS;
  else
    return BLOW_TAG_NONE;
}
STATIC_OVL char*
monster_blow_method_action(struct blow_method* method, int midx)
{
  const char punct[] = ".!?;:,'";
  char buf[1024] = "\0";
  const char* next;
  const char* s;
  const char* tag;
  const char* in_cursor;
  size_t end = 0;
  struct monster* t_mon = NULL;
  int choice = randint0(method->num_messages);
  struct blow_message* msg = method->messages;
  if (midx > 0) {
    t_mon = cave_monster(cave, midx);
  }
  while (choice--) {
    msg = msg->next;
  }
  in_cursor = msg->act_msg;
  next = strchr(in_cursor, '{');
  while (next) {
    strnfcat(buf, 1024, &end, "%.*s", (int)(next - in_cursor), in_cursor);
    s = next + 1;
    while (*s && isalpha((unsigned char)*s)) s++;
    if (*s == '}') {
      tag = next + 1;
      in_cursor = s + 1;
      switch (blow_tag_lookup(tag)) {
        case BLOW_TAG_TARGET: {
          char m_name[80];
          if (midx > 0) {
            int mdesc_mode = MDESC_TARG;
            if (!strchr(punct, *in_cursor)) {
              mdesc_mode |= MDESC_COMMA;
            }
            monster_desc(m_name, sizeof(m_name), t_mon, mdesc_mode);
            strnfcat(buf, sizeof(buf), &end, "%s", m_name);
          } else {
            strnfcat(buf, sizeof(buf), &end, "you");
          }
          break;
        }
        case BLOW_TAG_OF_TARGET: {
          char m_name[80];
          if (midx > 0) {
            monster_desc(m_name, sizeof(m_name), t_mon,
                         MDESC_TARG | MDESC_POSS);
            strnfcat(buf, sizeof(buf), &end, "%s", m_name);
          } else {
            strnfcat(buf, sizeof(buf), &end, "your");
          }
          break;
        }
        case BLOW_TAG_HAS: {
          if (midx > 0) {
            strnfcat(buf, sizeof(buf), &end, "has");
          } else {
            strnfcat(buf, sizeof(buf), &end, "have");
          }
          break;
        }
        default: {
          break;
        }
      }
    } else {
      in_cursor = next + 1;
    }
    next = strchr(in_cursor, '{');
  }
  strnfcat(buf, 1024, &end, "%s", in_cursor);
  return string_make(buf);
}
STATIC_OVL int
blow_index(const char* name)
{
  int i;
  for (i = 1; i < z_info->blow_effects_max; i++) {
    struct blow_effect* effect = &blow_effects[i];
    if (my_stricmp(name, effect->name) == 0) return i;
  }
  return 0;
}
STATIC_OVL void
steal_player_item(melee_effect_handler_context_t* context)
{
  int tries;
  for (tries = 0; tries < 10; tries++) {
    struct object *obj, *stolen;
    char o_name[80];
    bool split = false;
    bool none_left = false;
    int index = randint0(z_info->pack_size);
    obj = context->p->upkeep->inven[index];
    if (obj == NULL) continue;
    if (obj->artifact) continue;
    object_desc(o_name, sizeof(o_name), obj, ODESC_FULL, context->p);
    if (obj->number > 1) split = true;
    msg("%s %s (%c) was stolen!", (split ? "One of your" : "Your"), o_name,
        gear_to_label(context->p, obj));
    stolen = gear_object_for_use(context->p, obj, 1, false, &none_left);
    (void)monster_carry(cave, context->mon, stolen);
    context->obvious = true;
    break;
  }
}
STATIC_OVL bool
monster_damage_target(melee_effect_handler_context_t* context,
                      bool no_further_monster_effect)
{
  if (context->p) {
    take_hit(context->p, context->net_dam, context->ddesc);
    if (context->p->is_dead) return true;
  }
  return false;
}
STATIC_OVL void
melee_effect_elemental(melee_effect_handler_context_t* context, int type)
{
  int res = type < ELEM_MAX ? context->p->state.el_info[type].res_level : 0;
  context->obvious = true;
  if (!context->damage) return;
  switch (type) {
    case PROJ_ACID:
      msg("You are covered in acid!");
      break;
    case PROJ_FIRE:
      msg("You are enveloped in flames!");
      break;
    case PROJ_COLD:
      msg("You are covered with frost!");
      break;
  }
  take_hit(context->p, context->net_dam, context->ddesc);
  if (!context->p->is_dead) {
    if (type == PROJ_ACID) {
      minus_ac(context->p);
    }
    inven_damage(context->p, type, MIN((context->net_dam / 10) + 1, 3), res);
    equip_learn_element(context->p, type);
  }
}
STATIC_OVL void
melee_effect_timed(melee_effect_handler_context_t* context, int type,
                   int amount, const char* save_msg)
{
  if (monster_damage_target(context, false)) return;
  if (context->damage && !context->net_dam) return;
  if (player_inc_timed(context->p, type, amount, true, true, true)) {
    context->obvious = true;
  } else if (save_msg != NULL) {
    msg("%s", save_msg);
  }
}
STATIC_OVL void
melee_effect_stat(melee_effect_handler_context_t* context, int stat,
                  bool damage)
{
  if (damage) {
    if (monster_damage_target(context, true)) return;
    if (context->damage && !context->net_dam) return;
  }
  effect_simple(EF_DRAIN_STAT, source_monster(context->mon->midx), "0", stat, 0,
                0, &context->obvious);
}
STATIC_OVL void
melee_effect_handler_NONE(melee_effect_handler_context_t* context)
{
  context->obvious = true;
  context->damage = 0;
}
STATIC_OVL void
melee_effect_handler_HURT(melee_effect_handler_context_t* context)
{
  context->obvious = true;
  (void)monster_damage_target(context, true);
}
STATIC_OVL void
melee_effect_handler_WOUND(melee_effect_handler_context_t* context)
{
  context->obvious = true;
  (void)monster_damage_target(context, true);
  if (context->stun && !one_in_(5)) {
    context->stun = false;
  }
  context->cut = true;
}
STATIC_OVL void
melee_effect_handler_BATTER(melee_effect_handler_context_t* context)
{
  context->obvious = true;
  (void)monster_damage_target(context, true);
  if (context->cut && !one_in_(5)) {
    context->cut = false;
  }
  context->stun = true;
}
STATIC_OVL void
melee_effect_handler_SHATTER(melee_effect_handler_context_t* context)
{
  context->obvious = true;
  (void)monster_damage_target(context, true);
  if (context->cut && !one_in_(5)) {
    context->cut = false;
  }
  context->stun = true;
}
STATIC_OVL void
melee_effect_handler_EAT_ITEM(melee_effect_handler_context_t* context)
{
  if (monster_damage_target(context, false)) return;
  steal_player_item(context);
}
STATIC_OVL void
melee_effect_handler_DARK(melee_effect_handler_context_t* context)
{
  if (!context->damage) return;
  (void)monster_damage_target(context, true);
  equip_learn_element(context->p, PROJ_DARK);
}
STATIC_OVL void
melee_effect_handler_HUNGER(melee_effect_handler_context_t* context)
{
  int amount = 500;
  if (!monster_damage_target(context, true) && (context->damage > 0)) {
    if (!player_saving_throw(context->p, context->mon, 0)) {
      msg("You feel an unnatural hunger...");
      if (context->p->state.hunger < 0) {
        amount *= int_exp(2, -(context->p->state.hunger));
        amount /= int_exp(3, -(context->p->state.hunger));
      } else if (context->p->state.hunger > 0) {
        amount *= int_exp(3, context->p->state.hunger);
        amount /= int_exp(2, context->p->state.hunger);
      }
      player_dec_timed(context->p, TMD_FOOD, amount, false, true);
    }
  }
}
STATIC_OVL void
melee_effect_handler_POISON(melee_effect_handler_context_t* context)
{
  if (!context->damage) return;
  if (player_inc_timed(context->p, TMD_POISONED, context->damage, true, true,
                       true))
    context->obvious = true;
  equip_learn_element(context->p, PROJ_POIS);
}
STATIC_OVL void
melee_effect_handler_ACID(melee_effect_handler_context_t* context)
{
  melee_effect_elemental(context, PROJ_ACID);
}
STATIC_OVL void
melee_effect_handler_FIRE(melee_effect_handler_context_t* context)
{
  melee_effect_elemental(context, PROJ_FIRE);
}
STATIC_OVL void
melee_effect_handler_COLD(melee_effect_handler_context_t* context)
{
  melee_effect_elemental(context, PROJ_COLD);
}
STATIC_OVL void
melee_effect_handler_BLIND(melee_effect_handler_context_t* context)
{
  bool blind = context->p->timed[TMD_BLIND] > 0;
  melee_effect_timed(context, TMD_BLIND, damroll(5, 4),
                     blind ? NULL : "Your vision quickly clears.");
}
STATIC_OVL void
melee_effect_handler_CONFUSE(melee_effect_handler_context_t* context)
{
  melee_effect_timed(context, TMD_CONFUSED, damroll(2, 4),
                     "You resist the effects.");
}
STATIC_OVL void
melee_effect_handler_ENTRANCE(melee_effect_handler_context_t* context)
{
  melee_effect_timed(context, TMD_ENTRANCED, damroll(4, 4),
                     "You are unaffected!");
}
STATIC_OVL void
melee_effect_handler_HALLU(melee_effect_handler_context_t* context)
{
  melee_effect_timed(context, TMD_IMAGE, damroll(10, 4),
                     "You resist the effects.");
}
STATIC_OVL void
melee_effect_handler_LOSE_STR(melee_effect_handler_context_t* context)
{
  melee_effect_stat(context, STAT_STR, true);
}
STATIC_OVL void
melee_effect_handler_LOSE_DEX(melee_effect_handler_context_t* context)
{
  melee_effect_stat(context, STAT_DEX, true);
}
STATIC_OVL void
melee_effect_handler_LOSE_CON(melee_effect_handler_context_t* context)
{
  melee_effect_stat(context, STAT_CON, true);
}
STATIC_OVL void
melee_effect_handler_LOSE_GRA(melee_effect_handler_context_t* context)
{
  melee_effect_stat(context, STAT_GRA, true);
}
STATIC_OVL void
melee_effect_handler_LOSE_STR_CON(melee_effect_handler_context_t* context)
{
  melee_effect_stat(context, STAT_STR, true);
  melee_effect_stat(context, STAT_CON, false);
}
STATIC_OVL void
melee_effect_handler_LOSE_ALL(melee_effect_handler_context_t* context)
{
  melee_effect_stat(context, STAT_STR, true);
  melee_effect_stat(context, STAT_DEX, false);
  melee_effect_stat(context, STAT_CON, false);
  melee_effect_stat(context, STAT_GRA, false);
}
STATIC_OVL void
melee_effect_handler_DISARM(melee_effect_handler_context_t* context)
{
  struct object* obj = equipped_item_by_slot_name(context->p, "weapon");
  char o_name[120];
  char m_name[80];
  int difficulty = 2;
  if (!obj) return;
  object_desc(o_name, sizeof(o_name), obj, ODESC_BASE, context->p);
  monster_desc(m_name, sizeof(m_name), context->mon, MDESC_STANDARD);
  if (two_handed_melee(context->p)) {
    difficulty -= 4;
  }
  if (skill_check(source_monster(context->mon->midx), difficulty,
                  context->p->state.stat_use[STAT_STR] * 2,
                  source_player()) <= 0) {
    msg("%s tries to disarm you, but you keep a grip on your weapon.", m_name);
  } else {
    struct object* dislodged;
    bool none_left = false;
    msg("%s disarms you! Your %s falls to the ground nearby.", m_name, o_name);
    inven_takeoff(obj);
    dislodged = gear_object_for_use(context->p, obj, 1, false, &none_left);
    drop_near(cave, &dislodged, 0, context->p->grid, true, false);
  }
}
STATIC_OVL melee_effect_handler_f
melee_handler_for_blow_effect(const char* name)
{
  static const struct effect_handler_s {
    const char* name;
    melee_effect_handler_f function;
  } effect_handlers[] = {
      {"NONE", melee_effect_handler_NONE},
      {"HURT", melee_effect_handler_HURT},
      {"WOUND", melee_effect_handler_WOUND},
      {"BATTER", melee_effect_handler_BATTER},
      {"SHATTER", melee_effect_handler_SHATTER},
      {"EAT_ITEM", melee_effect_handler_EAT_ITEM},
      {"DARK", melee_effect_handler_DARK},
      {"HUNGER", melee_effect_handler_HUNGER},
      {"POISON", melee_effect_handler_POISON},
      {"ACID", melee_effect_handler_ACID},
      {"FIRE", melee_effect_handler_FIRE},
      {"COLD", melee_effect_handler_COLD},
      {"BLIND", melee_effect_handler_BLIND},
      {"CONFUSE", melee_effect_handler_CONFUSE},
      {"ENTRANCE", melee_effect_handler_ENTRANCE},
      {"HALLU", melee_effect_handler_HALLU},
      {"LOSE_STR", melee_effect_handler_LOSE_STR},
      {"LOSE_DEX", melee_effect_handler_LOSE_DEX},
      {"LOSE_CON", melee_effect_handler_LOSE_CON},
      {"LOSE_GRA", melee_effect_handler_LOSE_GRA},
      {"LOSE_STR_CON", melee_effect_handler_LOSE_STR_CON},
      {"LOSE_ALL", melee_effect_handler_LOSE_ALL},
      {"DISARM", melee_effect_handler_DISARM},
      {NULL, NULL},
  };
  const struct effect_handler_s* current = effect_handlers;
  while (current->name != NULL && current->function != NULL) {
    if (my_stricmp(name, current->name) == 0) return current->function;
    current++;
  }
  return NULL;
}
STATIC_OVL int
monster_elf_bane_bonus(struct monster* mon, struct player* p)
{
  bool elf = (streq(p->race->name, "Noldor") || streq(p->race->name, "Sindar"));
  if (!mon) return 0;
  return (rf_has(mon->race->flags, RF_ELFBANE) && elf) ? 5 : 0;
}
STATIC_OVL int
morale_from_friends(struct monster* mon)
{
  int i;
  int morale_bonus = 0;
  int morale_penalty = 0;
  for (i = 1; i < cave_monster_max(cave); i++) {
    struct monster* mon1 = cave_monster(cave, i);
    if (!mon1->race) continue;
    if (mon == mon1) continue;
    if (!los(cave, mon->grid, mon1->grid)) continue;
    if (!similar_monsters(mon, mon1)) continue;
    if (mon1->alertness >= ALERTNESS_ALERT) {
      int multiplier = 1;
      if (rf_has(mon1->race->flags, RF_ESCORT) ||
          rf_has(mon1->race->flags, RF_ESCORTS)) {
        multiplier = 4;
      }
      if (mon1->stance == STANCE_FLEEING) {
        morale_penalty += 10 * multiplier;
      } else {
        morale_bonus += 10 * multiplier;
      }
    }
  }
  return (morale_bonus - morale_penalty);
}
STATIC_OVL void
calc_morale(struct monster* mon)
{
  int morale;
  int difference;
  struct monster_race* race = mon->race;
  morale = 60;
  if (player->on_the_run) {
    morale += 20;
  } else {
    morale += (race->level - player->depth) * 10;
    if (player->depth == z_info->dun_depth) {
      morale = MAX(morale, 20);
    }
  }
  if (player->timed[TMD_IMAGE]) {
    morale += 20;
  }
  if (player->timed[TMD_BLIND]) {
    morale += 20;
  }
  if (player->timed[TMD_CONFUSED]) {
    morale += 40;
  }
  if (player->timed[TMD_SLOW]) {
    morale += 40;
  }
  if (player->timed[TMD_AFRAID]) {
    morale += 40;
  }
  if (player->timed[TMD_ENTRANCED]) {
    morale += 80;
  } else if (player->timed[TMD_STUN] > 100) {
    morale += 80;
  } else if (player->timed[TMD_STUN] > 50) {
    morale += 40;
  } else if (player->timed[TMD_STUN] > 0) {
    morale += 20;
  }
  switch (health_level(player->chp, player->mhp)) {
    case HEALTH_WOUNDED:
      morale += 20;
      break;
    case HEALTH_BADLY_WOUNDED:
      morale += 40;
      break;
    case HEALTH_ALMOST_DEAD:
      morale += 80;
      break;
  }
  if (mon->m_timed[MON_TMD_STUN]) {
    morale -= 20;
  }
  if (mon->m_timed[MON_TMD_FAST]) {
    morale += 40;
  }
  switch (health_level(mon->hp, mon->maxhp)) {
    case HEALTH_WOUNDED:
      morale -= 20;
      break;
    case HEALTH_BADLY_WOUNDED:
      morale -= 40;
      break;
    case HEALTH_ALMOST_DEAD:
      morale -= 80;
      break;
  }
  if ((mon->stance == STANCE_FLEEING) &&
      (health_level(mon->hp, mon->maxhp) <= HEALTH_WOUNDED)) {
    morale -= 20;
  }
  morale += morale_from_friends(mon);
  if (rf_has(race->flags, RF_HURT_LIGHT) &&
      (square_light(cave, player->grid) >= 4)) {
    morale -= (square_light(cave, player->grid) - 3) * 10;
  }
  if (!rf_has(race->flags, RF_UNIQUE)) {
    struct object* obj = mon->held_obj;
    while (obj) {
      morale -= 20;
      obj = obj->next;
    }
  }
  difference = MAX(
      player->state.skill_use[SKILL_WILL] - monster_skill(mon, SKILL_WILL), 0);
  if (player_active_ability(player, "Majesty")) {
    morale -= difference / 2 * 10;
  }
  if (player_active_ability(player, "Bane")) {
    morale -= player_bane_bonus(player, mon) * 10;
  }
  morale += monster_elf_bane_bonus(mon, player) * 10;
  morale += mon->tmp_morale;
  mon->morale = morale;
}
STATIC_OVL void
calc_stance(struct monster* mon)
{
  struct monster_race* race = mon->race;
  int stance;
  int stances[3];
  stances[0] = STANCE_FLEEING;
  stances[1] = STANCE_CONFIDENT;
  stances[2] = STANCE_AGGRESSIVE;
  if (rf_has(race->flags, RF_NO_FEAR) && (mon->tmp_morale >= 0)) {
    stances[0] = STANCE_CONFIDENT;
  }
  if (rf_has(race->flags, RF_MINDLESS)) {
    stances[0] = STANCE_AGGRESSIVE;
    stances[1] = STANCE_AGGRESSIVE;
  }
  if (rf_has(race->flags, RF_TROLL)) {
    stances[1] = STANCE_AGGRESSIVE;
  }
  if (player->state.flags[OF_AGGRAVATE] && !rf_has(race->flags, RF_MINDLESS)) {
    stances[1] = STANCE_AGGRESSIVE;
    if (monster_is_in_view(mon)) {
      equip_learn_flag(player, OF_AGGRAVATE);
    }
  }
  if (mflag_has(mon->mflag, MFLAG_AGGRESSIVE)) {
    stances[1] = STANCE_AGGRESSIVE;
  }
  if (mon->morale > 200) {
    stance = stances[2];
  } else if (mon->morale > 0) {
    stance = stances[1];
  } else {
    stance = stances[0];
  }
  if (mon->alertness < ALERTNESS_ALERT) {
    stance = stances[1];
  }
  if (stance != mon->stance) {
    enum mon_messages stance_msg = MON_MSG_NONE;
    switch (mon->stance) {
      case STANCE_FLEEING: {
        mon->tmp_morale += 60;
        calc_morale(mon);
        if (!player->truce) {
          stance_msg = MON_MSG_TURN_TO_FIGHT;
        } else {
          stance_msg = MON_MSG_RECOVER_COMPOSURE;
        }
        break;
      }
      case STANCE_CONFIDENT:
      case STANCE_AGGRESSIVE: {
        if (stance == STANCE_FLEEING) {
          mon->tmp_morale -= 60;
          calc_morale(mon);
          stance_msg = MON_MSG_FLEE_IN_TERROR;
        }
        break;
      }
    }
    if (stance_msg && monster_is_visible(mon) &&
        !rf_has(race->flags, RF_NEVER_MOVE)) {
      add_monster_message(mon, stance_msg, true);
    }
    mon->min_range = 0;
  }
  mon->stance = stance;
}
STATIC_OVL void
make_alert(struct monster* mon, int dam)
{
  int random_level = rand_range(ALERTNESS_ALERT, ALERTNESS_QUITE_ALERT);
  set_alertness(mon, MAX(mon->alertness + dam, random_level + dam));
}
STATIC_OVL void
set_alertness(struct monster* mon, int alertness)
{
  bool redisplay = false;
  enum mon_messages alert_msg = MON_MSG_NONE;
  if (mon->alertness == alertness) return;
  alertness = (MAX(MIN(alertness, ALERTNESS_MAX), ALERTNESS_MIN));
  if (mon->alertness < alertness) {
    if (mon->alertness < ALERTNESS_UNWARY) {
      if (alertness >= ALERTNESS_ALERT) {
        mon->skip_next_turn = true;
        if (monster_is_visible(mon)) {
          alert_msg = MON_MSG_WAKE_AND_NOTICE;
        }
        disturb(player, true);
        redisplay = true;
      } else if (alertness >= ALERTNESS_UNWARY) {
        if (monster_is_visible(mon)) {
          alert_msg = MON_MSG_WAKES_UP;
        }
        disturb(player, true);
        redisplay = true;
      }
    } else if ((mon->alertness < ALERTNESS_ALERT) &&
               (alertness >= ALERTNESS_ALERT)) {
      mon->skip_next_turn = true;
      if (monster_is_visible(mon)) {
        alert_msg = MON_MSG_NOTICE;
        disturb(player, true);
        redisplay = true;
      }
    } else if ((mon->alertness < ALERTNESS_UNWARY) &&
               (alertness < ALERTNESS_UNWARY) &&
               (alertness >= ALERTNESS_UNWARY - 2)) {
      if (monster_is_visible(mon)) {
        alert_msg = MON_MSG_STIR;
      }
    } else if ((mon->alertness < ALERTNESS_ALERT) &&
               (alertness < ALERTNESS_ALERT) &&
               (alertness >= ALERTNESS_ALERT - 2)) {
      if (monster_is_visible(mon)) {
        alert_msg = MON_MSG_LOOK_AROUND;
      }
    }
  } else {
    if ((mon->alertness >= ALERTNESS_UNWARY) &&
        (alertness < ALERTNESS_UNWARY)) {
      if (monster_is_visible(mon)) {
        alert_msg = MON_MSG_FALL_ASLEEP;
        if (rf_has(mon->race->flags, RF_QUESTOR)) {
          drop_iron_crown(mon,
                          "His crown slips from off his brow and falls to the "
                          "ground nearby.");
        }
        redisplay = true;
      }
    } else if ((mon->alertness >= ALERTNESS_ALERT) &&
               (alertness < ALERTNESS_ALERT)) {
      if (monster_is_visible(mon)) {
        alert_msg = MON_MSG_BECOME_UNWARY;
        redisplay = true;
        if (!rf_has(mon->race->flags, RF_TERRITORIAL)) {
          monster_group_new_wandering_flow(cave, mon, player->grid);
        }
      }
    }
  }
  if (alert_msg) {
    add_monster_message(mon, alert_msg, true);
  }
  mon->alertness = alertness;
  if (redisplay) {
    square_light_spot(cave, mon->grid);
  }
}
STATIC_OVL void
listen(struct chunk* c, struct player* p, struct monster* mon)
{
  int result;
  int difficulty = flow_dist(c->player_noise, mon->grid) - mon->noise;
  struct song* silence = lookup_song("Silence");
  mon->noise = 0;
  if (!player_active_ability(p, "Listen")) return;
  if (monster_is_visible(mon)) return;
  if (rf_has(mon->race->flags, RF_NEVER_MOVE)) return;
  difficulty += monster_skill(mon, SKILL_STEALTH);
  if ((mon->alertness >= ALERTNESS_UNWARY) &&
      (mon->alertness < ALERTNESS_ALERT)) {
    difficulty -= 3;
  }
  if (player_is_singing(p, silence)) {
    difficulty += song_bonus(p, p->state.skill_use[SKILL_SONG], silence);
  }
  result = skill_check(source_player(), p->state.skill_use[SKILL_PERCEPTION],
                       difficulty, source_monster(mon->midx));
  if (result <= 0) {
    square_light_spot(c, mon->grid);
    return;
  }
  if (result > 10) {
    mflag_on(mon->mflag, MFLAG_VISIBLE);
    square_light_spot(c, mon->grid);
    return;
  }
  mflag_on(mon->mflag, MFLAG_LISTENED);
}
STATIC_OVL void
path_analyse(struct chunk* c, struct loc grid)
{
  int path_n, i;
  struct loc path_g[256];
  if (c != cave) {
    return;
  }
  path_n = project_path(c, path_g, z_info->max_range, player->grid, &grid,
                        PROJECT_NONE);
  for (i = 0; i < path_n - 1; ++i) {
    if (!square_allowslos(player->cave, path_g[i])) {
      sqinfo_off(square(c, path_g[i])->info, SQUARE_SEEN);
      square_forget(c, path_g[i]);
      square_light_spot(c, path_g[i]);
    }
  }
}
STATIC_OVL void
update_mon(struct monster* mon, struct chunk* c, bool full)
{
  struct monster_lore* lore;
  struct monster_race* race;
  int d;
  bool flag = false;
  bool easy = false;
  bool immobile_seen = false;
  assert(mon != NULL);
  if (c != cave) {
    return;
  }
  lore = get_lore(mon->race);
  race = mon->race;
  if (rf_has(race->flags, RF_NEVER_MOVE) && rf_has(race->flags, RF_MINDLESS) &&
      mon->encountered) {
    immobile_seen = true;
  }
  if (full) {
    int dy = ABS(player->grid.y - mon->grid.y);
    int dx = ABS(player->grid.x - mon->grid.x);
    d = (dy > dx) ? (dy + (dx >> 1)) : (dx + (dy >> 1));
    if (d > 255) d = 255;
    mon->cdis = d;
  } else {
    d = mon->cdis;
  }
  if (mflag_has(mon->mflag, MFLAG_MARK)) flag = true;
  mflag_off(mon->mflag, MFLAG_LISTENED);
  if (d <= z_info->max_sight) {
    if (square_isview(c, mon->grid) && !player->timed[TMD_BLIND]) {
      bool do_invisible = false;
      if (square_isseen(c, mon->grid)) {
        if (monster_is_invisible(mon)) {
          int difficulty = monster_skill(mon, SKILL_WILL) +
                           (2 * distance(player->grid, mon->grid)) -
                           10 * player->state.flags[OF_SEE_INVIS];
          do_invisible = true;
          if (player_active_ability(player, "Keen Senses")) {
            difficulty -= 5;
          }
          if (skill_check(source_player(),
                          player->state.skill_use[SKILL_PERCEPTION], difficulty,
                          source_monster(mon->midx)) > 0) {
            easy = flag = true;
          }
        } else {
          easy = flag = true;
        }
      } else if (square_seen_by_keen_senses(c, mon->grid)) {
        easy = flag = true;
      }
      if (flag && do_invisible) {
        rf_on(lore->flags, RF_INVISIBLE);
      }
      path_analyse(c, mon->grid);
    }
  }
  if (flag || immobile_seen) {
    if (immobile_seen && !flag) {
      if (target_get_monster() == mon) {
        target_set_monster(NULL);
      }
      if (player->upkeep->health_who == mon) {
        health_track(player->upkeep, NULL);
      }
    }
    if (!monster_is_visible(mon)) {
      mflag_on(mon->mflag, MFLAG_VISIBLE);
      square_light_spot(c, mon->grid);
      if (player->upkeep->health_who == mon)
        player->upkeep->redraw |= (PR_HEALTH);
      player->upkeep->redraw |= PR_MONLIST;
      if (rf_has(race->flags, RF_INVISIBLE) &&
          (player->state.flags[OF_SEE_INVIS] > 0)) {
        player_learn_flag(player, OF_SEE_INVIS);
      }
    }
  } else if (monster_is_visible(mon)) {
    mflag_off(mon->mflag, MFLAG_VISIBLE);
    square_light_spot(c, mon->grid);
    if (player->upkeep->health_who == mon)
      player->upkeep->redraw |= (PR_HEALTH);
    player->upkeep->redraw |= PR_MONLIST;
  }
  if (easy) {
    if (!monster_is_in_view(mon)) {
      mflag_on(mon->mflag, MFLAG_VIEW);
      disturb(player, false);
      player->upkeep->redraw |= PR_MONLIST;
    }
  } else {
    if (monster_is_in_view(mon)) {
      mflag_off(mon->mflag, MFLAG_VIEW);
      player->upkeep->redraw |= PR_MONLIST;
    }
  }
  listen(c, player, mon);
  if (monster_is_visible(mon) && !mon->encountered &&
      square_isseen(c, mon->grid) && (lore->psights < SHRT_MAX)) {
    int new_exp = adjusted_mon_exp(race, false);
    player_exp_gain(player, new_exp);
    player->encounter_exp += new_exp;
    mon->encountered = true;
    lore->psights++;
    if (lore->tsights < SHRT_MAX) lore->tsights++;
    if (rf_has(race->flags, RF_UNIQUE)) {
      char note[120];
      my_strcpy(note, format("Encountered %s", race->name), sizeof(note));
      history_add(player, note, HIST_MEET_UNIQUE);
    }
    if (rf_has(race->flags, RF_UNDEAD) &&
        !rf_has(race->flags, RF_TERRITORIAL)) {
      player_learn_flag(player, OF_HAUNTED);
    }
  }
}
STATIC_OVL void
update_monsters(bool full)
{
  int i;
  for (i = 1; i < cave_monster_max(cave); i++) {
    struct monster* mon = cave_monster(cave, i);
    if (mon->race) update_mon(mon, cave, full);
  }
}
STATIC_OVL int
monster_skill(struct monster* mon, int skill_type)
{
  struct monster_race* race = mon->race;
  int skill = 0;
  switch (skill_type) {
    case SKILL_MELEE:
      msg("Can't determine the monster's Melee score.");
      break;
    case SKILL_ARCHERY:
      msg("Can't determine the monster's Archery score.");
      break;
    case SKILL_EVASION:
      msg("Can't determine the monster's Evasion score.");
      break;
    case SKILL_STEALTH:
      skill = race->stl;
      break;
    case SKILL_PERCEPTION:
      skill = race->per;
      break;
    case SKILL_WILL:
      skill = race->wil;
      break;
    case SKILL_SMITHING:
      msg("Can't determine the monster's Smithing score.");
      break;
    case SKILL_SONG:
      msg("Can't determine the monster's Song score.");
      break;
    default:
      msg("Asked for an invalid monster skill.");
      break;
  }
  if (mon->m_timed[MON_TMD_STUN]) {
    skill -= 2;
  }
  return skill;
}
STATIC_OVL int
monster_stat(struct monster* mon, int stat_type)
{
  struct monster_race* race = mon->race;
  int stat = 0;
  int mhp = mon->maxhp;
  int base = 20;
  switch (stat_type) {
    case STAT_STR:
      stat = (race->blow[0].dice.dice * 2) + (race->hdice / 10) - 4;
      break;
    case STAT_DEX:
      msg("Can't determine the monster's Dex score.");
      break;
    case STAT_CON:
      if (mhp < base) {
        while (mhp < base) {
          stat--;
          base = (base * 10) / 12;
        }
      } else if (mhp >= base) {
        stat--;
        while (mhp >= base) {
          stat++;
          base = (base * 12) / 10;
        }
      }
      break;
    case STAT_GRA:
      msg("Can't determine the monster's Gra score.");
      break;
    default:
      msg("Asked for an invalid monster stat.");
      break;
  }
  return stat;
}
STATIC_OVL void
calc_monster_speed(struct monster* mon)
{
  int speed;
  if (!mon) return;
  speed = mon->race->speed;
  if (mon->m_timed[MON_TMD_FAST]) speed += 1;
  if (mon->m_timed[MON_TMD_SLOW]) speed -= 1;
  if (speed < 1) speed = 1;
  mon->mspeed = speed;
  return;
}
STATIC_OVL void
plural_aux(char* name, size_t max)
{
  size_t name_len = strlen(name);
  assert(name_len != 0);
  if (name[name_len - 1] == 's')
    my_strcat(name, "es", max);
  else
    my_strcat(name, "s", max);
}
STATIC_OVL void
get_mon_name(char* buf, size_t buflen, const struct monster_race* race, int num)
{
  assert(race != NULL);
  if (rf_has(race->flags, RF_UNIQUE)) {
    strnfmt(buf, buflen, "[U] %s", race->name);
  } else {
    strnfmt(buf, buflen, "%3d ", num);
    if (num == 1) {
      my_strcat(buf, race->name, buflen);
    } else if (race->plural != NULL) {
      my_strcat(buf, race->plural, buflen);
    } else {
      my_strcat(buf, race->name, buflen);
      plural_aux(buf, buflen);
    }
  }
}
STATIC_OVL void
monster_desc(char* desc, size_t max, const struct monster* mon, int mode)
{
  assert(mon != NULL);
  bool seen =
      (mode & MDESC_SHOW) || (!(mode & MDESC_HIDE) && monster_is_visible(mon));
  bool use_pronoun =
      (seen && (mode & MDESC_PRO_VIS)) || (!seen && (mode & MDESC_PRO_HID));
  struct monster_race* race =
      (player && player->timed[TMD_IMAGE]) ? mon->image_race : mon->race;
  if (!seen || use_pronoun) {
    const char* choice = "it";
    int msex = 0x00;
    if (use_pronoun) {
      if (rf_has(race->flags, RF_FEMALE)) {
        msex = 0x20;
      } else if (rf_has(race->flags, RF_MALE)) {
        msex = 0x10;
      }
    }
    switch (msex + (mode & 0x07)) {
      case 0x00:
        choice = "it";
        break;
      case 0x01:
        choice = "it";
        break;
      case 0x02:
        choice = "its";
        break;
      case 0x03:
        choice = "itself";
        break;
      case 0x04:
        choice = "something";
        break;
      case 0x05:
        choice = "something";
        break;
      case 0x06:
        choice = "something's";
        break;
      case 0x07:
        choice = "itself";
        break;
      case 0x10:
        choice = "he";
        break;
      case 0x11:
        choice = "him";
        break;
      case 0x12:
        choice = "his";
        break;
      case 0x13:
        choice = "himself";
        break;
      case 0x14:
        choice = "someone";
        break;
      case 0x15:
        choice = "someone";
        break;
      case 0x16:
        choice = "someone's";
        break;
      case 0x17:
        choice = "himself";
        break;
      case 0x20:
        choice = "she";
        break;
      case 0x21:
        choice = "her";
        break;
      case 0x22:
        choice = "her";
        break;
      case 0x23:
        choice = "herself";
        break;
      case 0x24:
        choice = "someone";
        break;
      case 0x25:
        choice = "someone";
        break;
      case 0x26:
        choice = "someone's";
        break;
      case 0x27:
        choice = "herself";
        break;
    }
    my_strcpy(desc, choice, max);
  } else if ((mode & MDESC_POSS) && (mode & MDESC_OBJE)) {
    if (rf_has(race->flags, RF_FEMALE))
      my_strcpy(desc, "herself", max);
    else if (rf_has(race->flags, RF_MALE))
      my_strcpy(desc, "himself", max);
    else
      my_strcpy(desc, "itself", max);
  } else {
    const char* comma_pos;
    if (rf_has(race->flags, RF_UNIQUE)) {
      if ((mode & MDESC_POSS) && rf_has(race->flags, RF_NAME_COMMA) &&
          (comma_pos = strchr(race->name, ',')) &&
          comma_pos - race->name < 1024) {
        strnfmt(desc, max, "%.*s", (int)(comma_pos - race->name), race->name);
      } else {
        my_strcpy(desc, race->name, max);
      }
    } else {
      if (mode & MDESC_IND_VIS) {
        my_strcpy(desc, is_a_vowel(race->name[0]) ? "an " : "a ", max);
      } else {
        my_strcpy(desc, "the ", max);
      }
      if ((mode & MDESC_POSS) && rf_has(race->flags, RF_NAME_COMMA) &&
          (comma_pos = strchr(race->name, ',')) &&
          comma_pos - race->name < 1024) {
        my_strcat(desc,
                  format("%.*s", (int)(comma_pos - race->name), race->name),
                  max);
      } else {
        my_strcat(desc, race->name, max);
      }
    }
    if ((mode & MDESC_COMMA) && rf_has(race->flags, RF_NAME_COMMA)) {
      my_strcat(desc, ",", max);
    }
    if (mode & MDESC_POSS) {
      my_strcat(desc, "'s", max);
    }
    if (!panel_contains(mon->grid.y, mon->grid.x)) {
      my_strcat(desc, " (offscreen)", max);
    }
  }
  if (mode & MDESC_CAPITAL) {
    my_strcap(desc);
  }
}
STATIC_OVL struct monster_group*
monster_group_new(struct chunk* c)
{
  struct monster_group* group = mem_zalloc(sizeof(struct monster_group));
  flow_new(c, &group->flow);
  return group;
}
STATIC_OVL void
monster_group_free(struct chunk* c, struct monster_group* group)
{
  while (group->member_list) {
    struct mon_group_list_entry* next = group->member_list->next;
    mem_free(group->member_list);
    group->member_list = next;
  }
  flow_free(c, &group->flow);
  mem_free(group);
}
STATIC_OVL void
monster_group_remove_leader(struct chunk* c, struct monster* leader,
                            struct monster_group* group)
{
  struct mon_group_list_entry* list_entry = group->member_list;
  while (list_entry) {
    struct monster* mon = cave_monster(c, list_entry->midx);
    if (!mon) {
      list_entry = list_entry->next;
      continue;
    } else {
      group->leader = mon->midx;
      mon->group_info.role = MON_GROUP_LEADER;
      break;
    }
  }
  monster_groups_verify(c);
}
STATIC_OVL void
monster_remove_from_group(struct chunk* c, struct monster* mon)
{
  struct monster_group* group = c->monster_groups[mon->group_info.index];
  struct mon_group_list_entry* list_entry = group->member_list;
  if (list_entry->midx == mon->midx) {
    if (!list_entry->next) {
      monster_group_free(c, group);
      c->monster_groups[mon->group_info.index] = NULL;
    } else {
      group->member_list = list_entry->next;
      mem_free(list_entry);
      if (group->leader == mon->midx) {
        monster_group_remove_leader(c, mon, group);
      }
    }
    return;
  }
  if (list_entry->next == NULL) {
    quit_fmt("Bad group: index=%d, monster=%d", mon->group_info.index,
             mon->midx);
  }
  while (list_entry->next) {
    if (list_entry->next->midx == mon->midx) {
      struct mon_group_list_entry* remove = list_entry->next;
      list_entry->next = list_entry->next->next;
      mem_free(remove);
      if (group->leader == mon->midx) {
        monster_group_remove_leader(c, mon, group);
      }
      break;
    }
    list_entry = list_entry->next;
  }
  group->size--;
  monster_groups_verify(c);
}
STATIC_OVL int
monster_group_index_new(struct chunk* c)
{
  int index;
  for (index = 1; index < z_info->level_monster_max; index++) {
    if (!(c->monster_groups[index])) return index;
  }
  return 0;
}
STATIC_OVL void
monster_add_to_group(struct chunk* c, struct monster* mon,
                     struct monster_group* group)
{
  struct mon_group_list_entry* list_entry;
  assert(mon->group_info.index == group->index);
  list_entry = mem_zalloc(sizeof(struct mon_group_list_entry));
  list_entry->midx = mon->midx;
  list_entry->next = group->member_list;
  group->member_list = list_entry;
  group->size++;
  mon->group_info.role = MON_GROUP_MEMBER;
}
STATIC_OVL void
monster_group_start(struct chunk* c, struct monster* mon)
{
  struct monster_group* group = monster_group_new(c);
  int index = monster_group_index_new(c);
  assert(index);
  c->monster_groups[index] = group;
  group->index = index;
  group->leader = mon->midx;
  group->member_list = mem_zalloc(sizeof(struct mon_group_list_entry));
  group->member_list->midx = mon->midx;
  group->size = 1;
  mon->group_info.index = index;
  mon->group_info.role = MON_GROUP_LEADER;
}
STATIC_OVL void
monster_group_assign(struct chunk* c, struct monster* mon,
                     struct monster_group_info info, bool loading)
{
  int index = info.index;
  struct monster_group* group = monster_group_by_index(c, index);
  if (!loading) {
    if (group) {
      monster_add_to_group(c, mon, group);
    } else {
      monster_group_start(c, mon);
    }
  } else {
    struct mon_group_list_entry* entry = mem_zalloc(sizeof(*entry));
    index = info.index;
    if (!index) {
      quit_fmt("Monster %d has no group", mon->midx);
    }
    group = monster_group_by_index(c, index);
    if (!group) {
      group = monster_group_new(c);
      group->index = index;
      c->monster_groups[index] = group;
    }
    if (info.role == MON_GROUP_LEADER) {
      group->leader = mon->midx;
    }
    entry->midx = mon->midx;
    entry->next = group->member_list;
    group->member_list = entry;
    group->size++;
  }
}
STATIC_OVL int
monster_group_index(struct monster_group* group)
{
  return group->index;
}
STATIC_OVL struct monster_group*
monster_group_by_index(struct chunk* c, int index)
{
  return index ? c->monster_groups[index] : NULL;
}
STATIC_OVL bool
monster_group_change_index(struct chunk* c, int new, int old)
{
  int index = cave_monster(c, old)->group_info.index;
  struct monster_group* group = monster_group_by_index(c, index);
  struct mon_group_list_entry* entry = group->member_list;
  if (group->leader == old) {
    group->leader = new;
  }
  while (entry) {
    if (entry->midx == old) {
      entry->midx = new;
      return true;
    }
    entry = entry->next;
  }
  return false;
}
STATIC_OVL int
monster_group_size(struct chunk* c, const struct monster* mon)
{
  int index = mon->group_info.index;
  struct monster_group* group = c->monster_groups[index];
  return group->size;
}
STATIC_OVL int
monster_group_leader_idx(struct monster_group* group)
{
  return group->leader;
}
STATIC_OVL struct monster*
monster_group_leader(struct chunk* c, struct monster* mon)
{
  int index = mon->group_info.index;
  struct monster_group* group = c->monster_groups[index];
  return cave_monster(c, group->leader);
}
STATIC_OVL void
monster_group_new_wandering_flow(struct chunk* c, struct monster* mon,
                                 struct loc tgrid)
{
  int i;
  struct monster_group* group =
      monster_group_by_index(c, mon->group_info.index);
  struct monster* leader = cave_monster(c, group->leader);
  struct monster_race* race = !!leader ? leader->race : NULL;
  struct loc grid;
  if (!leader) return;
  if (rf_has(race->flags, RF_TERRITORIAL) || in_tutorial()) {
    if (mon->mspeed == 0) {
      group->flow.centre = leader->grid;
      update_flow(c, &group->flow, leader);
    }
  } else if (square_in_bounds_fully(c, tgrid)) {
    group->flow.centre = tgrid;
    update_flow(c, &group->flow, leader);
  } else {
    if (rf_has(race->flags, RF_SMART) && !rf_has(race->flags, RF_TERRITORIAL) &&
        (player->depth != z_info->dun_depth) && one_in_(5) &&
        cave_find(c, &grid, square_isstairs) && !square_isplayer(c, grid) &&
        !square_isvault(c, grid)) {
      group->flow.centre = grid;
      update_flow(c, &group->flow, leader);
    } else {
      for (i = 0; i < 100; i++) {
        grid.y = randint0(c->height);
        grid.x = randint0(c->width);
        if (square_in_bounds_fully(c, grid) && square_isfloor(c, grid) &&
            square_isroom(c, grid) && !square_isvault(c, grid)) {
          group->flow.centre = grid;
          update_flow(c, &group->flow, leader);
          break;
        }
      }
    }
  }
  group->wandering_pause = 0;
}
STATIC_OVL void
monster_groups_verify(struct chunk* c)
{
  int i;
  for (i = 0; i < z_info->level_monster_max; i++) {
    if (c->monster_groups[i]) {
      struct monster_group* group = c->monster_groups[i];
      struct mon_group_list_entry* entry = group->member_list;
      bool leader_found = false;
      while (entry) {
        struct monster* mon = cave_monster(c, entry->midx);
        struct monster_group_info info = mon->group_info;
        if (info.index != i) {
          quit_fmt("Bad group index: group: %d, monster: %d", i, info.index);
        }
        if (info.role == MON_GROUP_LEADER) {
          if (leader_found) {
            assert(0);
          }
          leader_found = true;
        }
        entry = entry->next;
      }
    }
  }
}
STATIC_OVL int
flag_index_by_name(const char* name)
{
  size_t i;
  for (i = 0; i < N_ELEMENTS(obj_flags); i++) {
    if (streq(name, obj_flags[i])) {
      return i;
    }
  }
  return -1;
}
STATIC_OVL struct blow_method*
findmeth(const char* meth_name)
{
  struct blow_method* meth = &blow_methods[1];
  while (meth) {
    if (streq(meth->name, meth_name)) break;
    meth = meth->next;
  }
  return meth;
}
STATIC_OVL enum parser_error
parse_meth_name(struct parser* p)
{
  const char* name = parser_getstr(p, "name");
  struct blow_method* h = parser_priv(p);
  struct blow_method* meth = mem_zalloc(sizeof *meth);
  meth->next = h;
  parser_setpriv(p, meth);
  meth->name = string_make(name);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_meth_cut(struct parser* p)
{
  struct blow_method* meth = parser_priv(p);
  int val;
  assert(meth);
  val = parser_getuint(p, "cut");
  meth->cut = val ? true : false;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_meth_stun(struct parser* p)
{
  struct blow_method* meth = parser_priv(p);
  int val;
  assert(meth);
  val = parser_getuint(p, "stun");
  meth->stun = val ? true : false;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_meth_miss(struct parser* p)
{
  struct blow_method* meth = parser_priv(p);
  int val;
  assert(meth);
  val = parser_getuint(p, "miss");
  meth->miss = val ? true : false;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_meth_prt(struct parser* p)
{
  struct blow_method* meth = parser_priv(p);
  int val;
  assert(meth);
  val = parser_getuint(p, "prt");
  meth->prt = val ? true : false;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_meth_message_type(struct parser* p)
{
  int msg_index;
  const char* type;
  struct blow_method* meth = parser_priv(p);
  assert(meth);
  if (parser_hasval(p, "msg")) {
    type = parser_getstr(p, "msg");
    msg_index = message_lookup_by_name(type);
    if (msg_index < 0) return PARSE_ERROR_INVALID_MESSAGE;
    meth->msgt = msg_index;
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_meth_act_msg(struct parser* p)
{
  const char* message = parser_getstr(p, "act");
  struct blow_method* meth = parser_priv(p);
  struct blow_message* msg;
  if (!meth) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  msg = mem_zalloc(sizeof(*msg));
  msg->act_msg = string_make(message);
  msg->next = meth->messages;
  meth->messages = msg;
  meth->num_messages++;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_meth_desc(struct parser* p)
{
  struct blow_method* meth = parser_priv(p);
  assert(meth);
  meth->desc = string_append(meth->desc, parser_getstr(p, "desc"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_parse_meth(void)
{
  struct parser* p = parser_new();
  parser_setpriv(p, NULL);
  parser_reg(p, "name str name", parse_meth_name);
  parser_reg(p, "cut uint cut", parse_meth_cut);
  parser_reg(p, "stun uint stun", parse_meth_stun);
  parser_reg(p, "miss uint miss", parse_meth_miss);
  parser_reg(p, "prt uint prt", parse_meth_prt);
  parser_reg(p, "msg ?str msg", parse_meth_message_type);
  parser_reg(p, "act str act", parse_meth_act_msg);
  parser_reg(p, "desc str desc", parse_meth_desc);
  return p;
}
STATIC_OVL errr
run_parse_meth(struct parser* p)
{
  return parse_file_quit_not_found(p, "blow_methods");
}
STATIC_OVL errr
finish_parse_meth(struct parser* p)
{
  struct blow_method *meth, *next = NULL;
  int count = 1;
  z_info->blow_methods_max = 0;
  meth = parser_priv(p);
  while (meth) {
    z_info->blow_methods_max++;
    meth = meth->next;
  }
  blow_methods = mem_zalloc((z_info->blow_methods_max + 1) * sizeof(*meth));
  for (meth = parser_priv(p); meth; meth = next, count++) {
    memcpy(&blow_methods[count], meth, sizeof(*meth));
    next = meth->next;
    if (next)
      blow_methods[count].next = &blow_methods[count + 1];
    else
      blow_methods[count].next = NULL;
    mem_free(meth);
  }
  z_info->blow_methods_max += 1;
  parser_destroy(p);
  return 0;
}
STATIC_OVL void
cleanup_meth(void)
{
  struct blow_method* meth = &blow_methods[1];
  while (meth) {
    struct blow_message* msg = meth->messages;
    string_free(meth->desc);
    while (msg) {
      struct blow_message* next = msg->next;
      string_free(msg->act_msg);
      mem_free(msg);
      msg = next;
    }
    string_free(meth->name);
    meth = meth->next;
  }
  mem_free(blow_methods);
}
STATIC_OVL struct blow_effect*
findeff(const char* eff_name)
{
  struct blow_effect* eff = &blow_effects[0];
  while (eff) {
    if (streq(eff->name, eff_name)) break;
    eff = eff->next;
  }
  return eff;
}
STATIC_OVL enum parser_error
parse_eff_name(struct parser* p)
{
  const char* name = parser_getstr(p, "name");
  struct blow_effect* h = parser_priv(p);
  struct blow_effect* eff = mem_zalloc(sizeof *eff);
  eff->next = h;
  parser_setpriv(p, eff);
  eff->name = string_make(name);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_eff_power(struct parser* p)
{
  struct blow_effect* eff = parser_priv(p);
  assert(eff);
  eff->power = parser_getint(p, "power");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_eff_eval(struct parser* p)
{
  struct blow_effect* eff = parser_priv(p);
  assert(eff);
  eff->eval = parser_getint(p, "eval");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_eff_desc(struct parser* p)
{
  struct blow_effect* eff = parser_priv(p);
  assert(eff);
  eff->desc = string_append(eff->desc, parser_getstr(p, "desc"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_eff_effect_type(struct parser* p)
{
  struct blow_effect* eff = parser_priv(p);
  assert(eff);
  eff->effect_type = string_make(parser_getstr(p, "type"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_eff_resist(struct parser* p)
{
  struct blow_effect* eff = parser_priv(p);
  const char* resist = parser_getstr(p, "resist");
  assert(eff);
  if (streq(eff->effect_type, "element")) {
    eff->resist = proj_name_to_idx(resist);
  } else if (streq(eff->effect_type, "flag")) {
    eff->resist = flag_index_by_name(resist);
  } else {
    return PARSE_ERROR_MISSING_BLOW_EFF_TYPE;
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_eff_dam_type(struct parser* p)
{
  struct blow_effect* eff = parser_priv(p);
  int type;
  assert(eff);
  type = proj_name_to_idx(parser_getstr(p, "type"));
  eff->dam_type = type >= 0 ? type : PROJ_HURT;
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_parse_eff(void)
{
  struct parser* p = parser_new();
  parser_setpriv(p, NULL);
  parser_reg(p, "name str name", parse_eff_name);
  parser_reg(p, "power int power", parse_eff_power);
  parser_reg(p, "eval int eval", parse_eff_eval);
  parser_reg(p, "desc str desc", parse_eff_desc);
  parser_reg(p, "effect-type str type", parse_eff_effect_type);
  parser_reg(p, "resist str resist", parse_eff_resist);
  parser_reg(p, "dam-type str type", parse_eff_dam_type);
  return p;
}
STATIC_OVL errr
run_parse_eff(struct parser* p)
{
  return parse_file_quit_not_found(p, "blow_effects");
}
STATIC_OVL errr
finish_parse_eff(struct parser* p)
{
  struct blow_effect *eff, *next = NULL;
  int count;
  z_info->blow_effects_max = 0;
  eff = parser_priv(p);
  while (eff) {
    z_info->blow_effects_max++;
    eff = eff->next;
  }
  count = z_info->blow_effects_max - 1;
  blow_effects = mem_zalloc((z_info->blow_effects_max + 1) * sizeof(*eff));
  for (eff = parser_priv(p); eff; eff = next, count--) {
    memcpy(&blow_effects[count], eff, sizeof(*eff));
    next = eff->next;
    if (count < z_info->blow_effects_max - 1)
      blow_effects[count].next = &blow_effects[count + 1];
    else
      blow_effects[count].next = NULL;
    mem_free(eff);
  }
  z_info->blow_effects_max++;
  parser_destroy(p);
  return 0;
}
STATIC_OVL void
cleanup_eff(void)
{
  struct blow_effect* eff = blow_effects;
  struct blow_effect* next;
  while (eff) {
    next = eff->next;
    string_free(eff->effect_type);
    string_free(eff->desc);
    string_free(eff->name);
    eff = next;
  }
  mem_free(blow_effects);
}
STATIC_OVL enum parser_error
parse_pain_type(struct parser* p)
{
  struct monster_pain* h = parser_priv(p);
  struct monster_pain* mp = mem_zalloc(sizeof *mp);
  mp->next = h;
  mp->pain_idx = parser_getuint(p, "index");
  parser_setpriv(p, mp);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_pain_message(struct parser* p)
{
  struct monster_pain* mp = parser_priv(p);
  int i;
  if (!mp) return PARSE_ERROR_MISSING_RECORD_HEADER;
  for (i = 0; i < (int)N_ELEMENTS(mp->messages); i++)
    if (!mp->messages[i]) break;
  if (i == (int)N_ELEMENTS(mp->messages)) return PARSE_ERROR_TOO_MANY_ENTRIES;
  mp->messages[i] = string_make(parser_getstr(p, "message"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_parse_pain(void)
{
  struct parser* p = parser_new();
  parser_setpriv(p, NULL);
  parser_reg(p, "type uint index", parse_pain_type);
  parser_reg(p, "message str message", parse_pain_message);
  return p;
}
STATIC_OVL errr
run_parse_pain(struct parser* p)
{
  return parse_file_quit_not_found(p, "pain");
}
STATIC_OVL errr
finish_parse_pain(struct parser* p)
{
  struct monster_pain *mp, *n;
  z_info->pain_max = 0;
  mp = parser_priv(p);
  while (mp) {
    if (mp->pain_idx > z_info->pain_max) z_info->pain_max = mp->pain_idx;
    mp = mp->next;
  }
  pain_messages = mem_zalloc((z_info->pain_max + 1) * sizeof(*mp));
  for (mp = parser_priv(p); mp; mp = n) {
    memcpy(&pain_messages[mp->pain_idx], mp, sizeof(*mp));
    n = mp->next;
    if (n)
      pain_messages[mp->pain_idx].next = &pain_messages[n->pain_idx];
    else
      pain_messages[mp->pain_idx].next = NULL;
    mem_free(mp);
  }
  z_info->pain_max += 1;
  parser_destroy(p);
  return 0;
}
STATIC_OVL void
cleanup_pain(void)
{
  int idx, i;
  for (idx = 0; idx < z_info->pain_max; idx++) {
    for (i = 0; i < 3; i++) {
      string_free((char*)pain_messages[idx].messages[i]);
    }
  }
  mem_free(pain_messages);
}
STATIC_OVL enum parser_error
parse_pursuit_type(struct parser* p)
{
  struct monster_pursuit* h = parser_priv(p);
  struct monster_pursuit* mp = mem_zalloc(sizeof *mp);
  mp->next = h;
  mp->idx = parser_getuint(p, "index");
  parser_setpriv(p, mp);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_pursuit_message_vis(struct parser* p)
{
  struct monster_pursuit* mp = parser_priv(p);
  if (!mp) return PARSE_ERROR_MISSING_RECORD_HEADER;
  mp->msg_vis = string_make(parser_getstr(p, "message"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_pursuit_message_near(struct parser* p)
{
  struct monster_pursuit* mp = parser_priv(p);
  if (!mp) return PARSE_ERROR_MISSING_RECORD_HEADER;
  mp->msg_close = string_make(parser_getstr(p, "message"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_pursuit_message_far(struct parser* p)
{
  struct monster_pursuit* mp = parser_priv(p);
  if (!mp) return PARSE_ERROR_MISSING_RECORD_HEADER;
  mp->msg_far = string_make(parser_getstr(p, "message"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_parse_pursuit(void)
{
  struct parser* p = parser_new();
  parser_setpriv(p, NULL);
  parser_reg(p, "type uint index", parse_pursuit_type);
  parser_reg(p, "visible str message", parse_pursuit_message_vis);
  parser_reg(p, "close str message", parse_pursuit_message_near);
  parser_reg(p, "far str message", parse_pursuit_message_far);
  return p;
}
STATIC_OVL errr
run_parse_pursuit(struct parser* p)
{
  return parse_file_quit_not_found(p, "pursuit");
}
STATIC_OVL errr
finish_parse_pursuit(struct parser* p)
{
  struct monster_pursuit *mp, *n;
  z_info->pursuit_max = 0;
  mp = parser_priv(p);
  while (mp) {
    if (mp->idx > z_info->pursuit_max) z_info->pursuit_max = mp->idx;
    mp = mp->next;
  }
  pursuit_messages = mem_zalloc((z_info->pursuit_max + 1) * sizeof(*mp));
  for (mp = parser_priv(p); mp; mp = n) {
    memcpy(&pursuit_messages[mp->idx], mp, sizeof(*mp));
    n = mp->next;
    if (n)
      pursuit_messages[mp->idx].next = &pursuit_messages[n->idx];
    else
      pursuit_messages[mp->idx].next = NULL;
    mem_free(mp);
  }
  z_info->pursuit_max += 1;
  parser_destroy(p);
  return 0;
}
STATIC_OVL void
cleanup_pursuit(void)
{
  int idx;
  for (idx = 0; idx < z_info->pursuit_max; idx++) {
    string_free((char*)pursuit_messages[idx].msg_vis);
    string_free((char*)pursuit_messages[idx].msg_close);
    string_free((char*)pursuit_messages[idx].msg_far);
  }
  mem_free(pursuit_messages);
}
STATIC_OVL enum parser_error
parse_warning_type(struct parser* p)
{
  struct monster_warning* h = parser_priv(p);
  struct monster_warning* mw = mem_zalloc(sizeof *mw);
  mw->next = h;
  mw->idx = parser_getuint(p, "index");
  parser_setpriv(p, mw);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_warning_message_vis(struct parser* p)
{
  struct monster_warning* mw = parser_priv(p);
  if (!mw) return PARSE_ERROR_MISSING_RECORD_HEADER;
  mw->msg_vis = string_make(parser_getstr(p, "message"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_warning_message_invis(struct parser* p)
{
  struct monster_warning* mw = parser_priv(p);
  if (!mw) return PARSE_ERROR_MISSING_RECORD_HEADER;
  mw->msg_invis = string_make(parser_getstr(p, "message"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_warning_message_vis_silence(struct parser* p)
{
  struct monster_warning* mw = parser_priv(p);
  if (!mw) return PARSE_ERROR_MISSING_RECORD_HEADER;
  mw->msg_vis_silence = string_make(parser_getstr(p, "message"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_warning_message_invis_silence(struct parser* p)
{
  struct monster_warning* mw = parser_priv(p);
  if (!mw) return PARSE_ERROR_MISSING_RECORD_HEADER;
  mw->msg_invis_silence = string_make(parser_getstr(p, "message"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_parse_warning(void)
{
  struct parser* p = parser_new();
  parser_setpriv(p, NULL);
  parser_reg(p, "type uint index", parse_warning_type);
  parser_reg(p, "vis str message", parse_warning_message_vis);
  parser_reg(p, "invis str message", parse_warning_message_invis);
  parser_reg(p, "vis-silence str message", parse_warning_message_vis_silence);
  parser_reg(p, "invis-silence str message",
             parse_warning_message_invis_silence);
  return p;
}
STATIC_OVL errr
run_parse_warning(struct parser* p)
{
  return parse_file_quit_not_found(p, "warning");
}
STATIC_OVL errr
finish_parse_warning(struct parser* p)
{
  struct monster_warning *mw, *n;
  z_info->warning_max = 0;
  mw = parser_priv(p);
  while (mw) {
    if (mw->idx > z_info->warning_max) z_info->warning_max = mw->idx;
    mw = mw->next;
  }
  warning_messages = mem_zalloc((z_info->warning_max + 1) * sizeof(*mw));
  for (mw = parser_priv(p); mw; mw = n) {
    memcpy(&warning_messages[mw->idx], mw, sizeof(*mw));
    n = mw->next;
    if (n)
      warning_messages[mw->idx].next = &warning_messages[n->idx];
    else
      warning_messages[mw->idx].next = NULL;
    mem_free(mw);
  }
  z_info->warning_max += 1;
  parser_destroy(p);
  return 0;
}
STATIC_OVL void
cleanup_warning(void)
{
  int idx;
  for (idx = 0; idx < z_info->warning_max; idx++) {
    string_free((char*)warning_messages[idx].msg_vis);
    string_free((char*)warning_messages[idx].msg_invis);
    string_free((char*)warning_messages[idx].msg_vis_silence);
    string_free((char*)warning_messages[idx].msg_invis_silence);
  }
  mem_free(warning_messages);
}
STATIC_OVL enum parser_error
parse_mon_spell_name(struct parser* p)
{
  struct monster_spell* h = parser_priv(p);
  const char* name = parser_getstr(p, "name");
  struct monster_spell* s;
  int index;
  if (grab_name("monster spell", name, r_info_spell_flags,
                N_ELEMENTS(r_info_spell_flags) - 1, &index)) {
    return PARSE_ERROR_INVALID_SPELL_NAME;
  }
  s = mem_zalloc(sizeof(*s));
  s->next = h;
  s->index = index;
  s->max_range = z_info->max_range;
  s->level = mem_zalloc(sizeof(*(s->level)));
  parser_setpriv(p, s);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_mon_spell_message_type(struct parser* p)
{
  struct monster_spell* s = parser_priv(p);
  const char* type = parser_getsym(p, "type");
  int msg_index = message_lookup_by_name(type);
  if (!s) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  if (msg_index < 0) {
    return PARSE_ERROR_INVALID_MESSAGE;
  }
  s->msgt = msg_index;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_mon_spell_mana(struct parser* p)
{
  struct monster_spell* s = parser_priv(p);
  if (!s) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  s->mana = parser_getuint(p, "mana");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_mon_spell_best_range(struct parser* p)
{
  struct monster_spell* s = parser_priv(p);
  if (!s) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  s->best_range = parser_getuint(p, "range");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_mon_spell_max_range(struct parser* p)
{
  struct monster_spell* s = parser_priv(p);
  if (!s) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  s->max_range = parser_getuint(p, "range");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_mon_spell_desire(struct parser* p)
{
  struct monster_spell* s = parser_priv(p);
  if (!s) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  s->desire = parser_getuint(p, "desire");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_mon_spell_disturb(struct parser* p)
{
  struct monster_spell* s = parser_priv(p);
  if (!s) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  s->disturb_stealth = parser_getuint(p, "value") > 0;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_mon_spell_use_past_range(struct parser* p)
{
  struct monster_spell* s = parser_priv(p);
  if (!s) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  s->use_past_range = parser_getuint(p, "value");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_mon_spell_effect(struct parser* p)
{
  struct monster_spell* s = parser_priv(p);
  struct effect *effect, *new_effect;
  if (!s) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  new_effect = mem_zalloc(sizeof(*new_effect));
  if (s->effect) {
    effect = s->effect;
    while (effect->next) effect = effect->next;
    effect->next = new_effect;
  } else {
    s->effect = new_effect;
  }
  return grab_effect_data(p, new_effect);
}
STATIC_OVL enum parser_error
parse_mon_spell_dice(struct parser* p)
{
  struct monster_spell* s = parser_priv(p);
  struct effect* effect;
  dice_t* dice;
  const char* string;
  if (!s) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  effect = s->effect;
  if (effect == NULL) {
    return PARSE_ERROR_NONE;
  }
  while (effect->next) effect = effect->next;
  dice = dice_new();
  if (dice == NULL) {
    return PARSE_ERROR_INVALID_DICE;
  }
  string = parser_getstr(p, "dice");
  if (dice_parse_string(dice, string)) {
    dice_free(effect->dice);
    effect->dice = dice;
  } else {
    dice_free(dice);
    return PARSE_ERROR_INVALID_DICE;
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_mon_spell_expr(struct parser* p)
{
  struct monster_spell* s = parser_priv(p);
  struct effect* effect;
  expression_t* expression;
  expression_base_value_f function = NULL;
  const char* name;
  const char* base;
  const char* expr;
  if (!s) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  effect = s->effect;
  if (effect == NULL) {
    return PARSE_ERROR_NONE;
  }
  while (effect->next) effect = effect->next;
  if (effect->dice == NULL) {
    return PARSE_ERROR_NONE;
  }
  expression = expression_new();
  if (expression == NULL) {
    return PARSE_ERROR_INVALID_EXPRESSION;
  }
  name = parser_getsym(p, "name");
  base = parser_getsym(p, "base");
  expr = parser_getstr(p, "expr");
  function = effect_value_base_by_name(base);
  expression_set_base_value(expression, function);
  if (expression_add_operations_string(expression, expr) < 0) {
    expression_free(expression);
    return PARSE_ERROR_BAD_EXPRESSION_STRING;
  }
  if (dice_bind_expression(effect->dice, name, expression) < 0) {
    expression_free(expression);
    return PARSE_ERROR_UNBOUND_EXPRESSION;
  }
  expression_free(expression);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_mon_spell_effect_xtra(struct parser* p)
{
  struct monster_spell* s = parser_priv(p);
  struct effect *effect, *new_effect;
  if (!s) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  new_effect = mem_zalloc(sizeof(*new_effect));
  if (s->effect_xtra) {
    effect = s->effect_xtra;
    while (effect->next) effect = effect->next;
    effect->next = new_effect;
  } else {
    s->effect_xtra = new_effect;
  }
  return grab_effect_data(p, new_effect);
}
STATIC_OVL enum parser_error
parse_mon_spell_dice_xtra(struct parser* p)
{
  struct monster_spell* s = parser_priv(p);
  struct effect* effect;
  dice_t* dice;
  const char* string;
  if (!s) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  effect = s->effect_xtra;
  if (effect == NULL) {
    return PARSE_ERROR_NONE;
  }
  while (effect->next) effect = effect->next;
  dice = dice_new();
  if (dice == NULL) {
    return PARSE_ERROR_INVALID_DICE;
  }
  string = parser_getstr(p, "dice");
  if (dice_parse_string(dice, string)) {
    dice_free(effect->dice);
    effect->dice = dice;
  } else {
    dice_free(dice);
    return PARSE_ERROR_INVALID_DICE;
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_mon_spell_expr_xtra(struct parser* p)
{
  struct monster_spell* s = parser_priv(p);
  struct effect* effect;
  expression_t* expression;
  expression_base_value_f function = NULL;
  const char* name;
  const char* base;
  const char* expr;
  if (!s) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  effect = s->effect_xtra;
  if (effect == NULL) {
    return PARSE_ERROR_NONE;
  }
  while (effect->next) effect = effect->next;
  if (effect->dice == NULL) {
    return PARSE_ERROR_NONE;
  }
  expression = expression_new();
  if (expression == NULL) {
    return PARSE_ERROR_INVALID_EXPRESSION;
  }
  name = parser_getsym(p, "name");
  base = parser_getsym(p, "base");
  expr = parser_getstr(p, "expr");
  function = effect_value_base_by_name(base);
  expression_set_base_value(expression, function);
  if (expression_add_operations_string(expression, expr) < 0) {
    expression_free(expression);
    return PARSE_ERROR_BAD_EXPRESSION_STRING;
  }
  if (dice_bind_expression(effect->dice, name, expression) < 0) {
    expression_free(expression);
    return PARSE_ERROR_UNBOUND_EXPRESSION;
  }
  expression_free(expression);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_mon_spell_power_cutoff(struct parser* p)
{
  struct monster_spell* s = parser_priv(p);
  struct monster_spell_level *l, *new;
  if (!s) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  new = mem_zalloc(sizeof(*new));
  new->power = parser_getint(p, "power");
  l = s->level;
  while (l->next) {
    l = l->next;
  }
  l->next = new;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_mon_spell_lore_desc(struct parser* p)
{
  struct monster_spell* s = parser_priv(p);
  struct monster_spell_level* l;
  if (!s) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  l = s->level;
  while (l->next) {
    l = l->next;
  }
  l->lore_desc = string_append(l->lore_desc, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_mon_spell_message(struct parser* p)
{
  struct monster_spell* s = parser_priv(p);
  const char* msg = (parser_hasval(p, "text")) ? parser_getstr(p, "text") : "";
  struct monster_spell_level* l;
  if (!s) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  l = s->level;
  while (l->next) {
    l = l->next;
  }
  l->message = string_append(l->message, msg);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_mon_spell_blind_message(struct parser* p)
{
  struct monster_spell* s = parser_priv(p);
  const char* msg = (parser_hasval(p, "text")) ? parser_getstr(p, "text") : "";
  struct monster_spell_level* l;
  if (!s) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  l = s->level;
  while (l->next) {
    l = l->next;
  }
  l->blind_message = string_append(l->blind_message, msg);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_mon_spell_silence_message(struct parser* p)
{
  struct monster_spell* s = parser_priv(p);
  const char* msg = (parser_hasval(p, "text")) ? parser_getstr(p, "text") : "";
  struct monster_spell_level* l;
  if (!s) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  l = s->level;
  while (l->next) {
    l = l->next;
  }
  l->silence_message = string_append(l->silence_message, msg);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_mon_spell_blind_silence_message(struct parser* p)
{
  struct monster_spell* s = parser_priv(p);
  const char* msg = (parser_hasval(p, "text")) ? parser_getstr(p, "text") : "";
  struct monster_spell_level* l;
  if (!s) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  l = s->level;
  while (l->next) {
    l = l->next;
  }
  l->blind_silence_message = string_append(l->blind_silence_message, msg);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_mon_spell_smart_message(struct parser* p)
{
  struct monster_spell* s = parser_priv(p);
  const char* msg = (parser_hasval(p, "text")) ? parser_getstr(p, "text") : "";
  struct monster_spell_level* l;
  if (!s) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  l = s->level;
  while (l->next) {
    l = l->next;
  }
  l->smart_message = string_append(l->smart_message, msg);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_mon_spell_smart_blind_message(struct parser* p)
{
  struct monster_spell* s = parser_priv(p);
  const char* msg = (parser_hasval(p, "text")) ? parser_getstr(p, "text") : "";
  struct monster_spell_level* l;
  if (!s) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  l = s->level;
  while (l->next) {
    l = l->next;
  }
  l->smart_blind_message = string_append(l->smart_blind_message, msg);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_mon_spell_smart_silence_message(struct parser* p)
{
  struct monster_spell* s = parser_priv(p);
  const char* msg = (parser_hasval(p, "text")) ? parser_getstr(p, "text") : "";
  struct monster_spell_level* l;
  if (!s) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  l = s->level;
  while (l->next) {
    l = l->next;
  }
  l->smart_silence_message = string_append(l->smart_silence_message, msg);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_mon_spell_smart_blind_silence_message(struct parser* p)
{
  struct monster_spell* s = parser_priv(p);
  const char* msg = (parser_hasval(p, "text")) ? parser_getstr(p, "text") : "";
  struct monster_spell_level* l;
  if (!s) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  l = s->level;
  while (l->next) {
    l = l->next;
  }
  l->smart_blind_silence_message =
      string_append(l->smart_blind_silence_message, msg);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_mon_spell_save_message(struct parser* p)
{
  struct monster_spell* s = parser_priv(p);
  struct monster_spell_level* l;
  if (!s) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  l = s->level;
  while (l->next) {
    l = l->next;
  }
  l->save_message = string_append(l->save_message, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_mon_spell_no_save_message(struct parser* p)
{
  struct monster_spell* s = parser_priv(p);
  struct monster_spell_level* l;
  if (!s) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  l = s->level;
  while (l->next) {
    l = l->next;
  }
  l->no_save_message =
      string_append(l->no_save_message, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_parse_mon_spell(void)
{
  struct parser* p = parser_new();
  parser_setpriv(p, NULL);
  parser_reg(p, "name str name", parse_mon_spell_name);
  parser_reg(p, "msgt sym type", parse_mon_spell_message_type);
  parser_reg(p, "mana uint mana", parse_mon_spell_mana);
  parser_reg(p, "best-range uint range", parse_mon_spell_best_range);
  parser_reg(p, "max-range uint range", parse_mon_spell_max_range);
  parser_reg(p, "desire uint desire", parse_mon_spell_desire);
  parser_reg(p, "disturb uint value", parse_mon_spell_disturb);
  parser_reg(p, "use-past-range uint value", parse_mon_spell_use_past_range);
  parser_reg(p, "effect sym eff ?sym type ?int radius ?int other",
             parse_mon_spell_effect);
  parser_reg(p, "dice str dice", parse_mon_spell_dice);
  parser_reg(p, "expr sym name sym base str expr", parse_mon_spell_expr);
  parser_reg(p, "effect-xtra sym eff ?sym type ?int radius ?int other",
             parse_mon_spell_effect_xtra);
  parser_reg(p, "dice-xtra str dice", parse_mon_spell_dice_xtra);
  parser_reg(p, "expr-xtra sym name sym base str expr",
             parse_mon_spell_expr_xtra);
  parser_reg(p, "power-cutoff int power", parse_mon_spell_power_cutoff);
  parser_reg(p, "lore str text", parse_mon_spell_lore_desc);
  parser_reg(p, "message-vis ?str text", parse_mon_spell_message);
  parser_reg(p, "message-invis ?str text", parse_mon_spell_blind_message);
  parser_reg(p, "message-smart-vis ?str text", parse_mon_spell_smart_message);
  parser_reg(p, "message-smart-invis ?str text",
             parse_mon_spell_smart_blind_message);
  parser_reg(p, "message-silence-vis ?str text",
             parse_mon_spell_silence_message);
  parser_reg(p, "message-silence-invis ?str text",
             parse_mon_spell_blind_silence_message);
  parser_reg(p, "message-silence-smart-vis ?str text",
             parse_mon_spell_smart_silence_message);
  parser_reg(p, "message-silence-smart-invis ?str text",
             parse_mon_spell_smart_blind_silence_message);
  parser_reg(p, "message-save str text", parse_mon_spell_save_message);
  parser_reg(p, "message-no-save str text", parse_mon_spell_no_save_message);
  return p;
}
STATIC_OVL errr
run_parse_mon_spell(struct parser* p)
{
  return parse_file_quit_not_found(p, "monster_spell");
}
STATIC_OVL errr
finish_parse_mon_spell(struct parser* p)
{
  monster_spells = parser_priv(p);
  parser_destroy(p);
  return 0;
}
STATIC_OVL void
cleanup_mon_spell(void)
{
  struct monster_spell* rs = monster_spells;
  struct monster_spell* next;
  struct monster_spell_level* level;
  while (rs) {
    next = rs->next;
    level = rs->level;
    if (rs->effect_xtra) {
      free_effect(rs->effect_xtra);
    }
    free_effect(rs->effect);
    while (level) {
      struct monster_spell_level* next_level = level->next;
      string_free(level->lore_desc);
      string_free(level->message);
      string_free(level->blind_message);
      string_free(level->smart_message);
      string_free(level->smart_blind_message);
      string_free(level->silence_message);
      string_free(level->blind_silence_message);
      string_free(level->smart_silence_message);
      string_free(level->smart_blind_silence_message);
      string_free(level->save_message);
      string_free(level->no_save_message);
      mem_free(level);
      level = next_level;
    }
    mem_free(rs);
    rs = next;
  }
}
STATIC_OVL enum parser_error
parse_mon_base_name(struct parser* p)
{
  struct monster_base* h = parser_priv(p);
  struct monster_base* rb = mem_zalloc(sizeof *rb);
  rb->next = h;
  rb->name = string_make(parser_getstr(p, "name"));
  parser_setpriv(p, rb);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_mon_base_glyph(struct parser* p)
{
  struct monster_base* rb = parser_priv(p);
  if (!rb) return PARSE_ERROR_MISSING_RECORD_HEADER;
  rb->d_char = parser_getchar(p, "glyph");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_mon_base_pain(struct parser* p)
{
  struct monster_base* rb = parser_priv(p);
  int pain_idx;
  if (!rb) return PARSE_ERROR_MISSING_RECORD_HEADER;
  pain_idx = parser_getuint(p, "pain");
  if (pain_idx >= z_info->pain_max) return PARSE_ERROR_OUT_OF_BOUNDS;
  rb->pain = &pain_messages[pain_idx];
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_mon_base_pursuit(struct parser* p)
{
  struct monster_base* rb = parser_priv(p);
  int pursuit_idx;
  if (!rb) return PARSE_ERROR_MISSING_RECORD_HEADER;
  pursuit_idx = parser_getuint(p, "pursuit");
  if (pursuit_idx >= z_info->pursuit_max) return PARSE_ERROR_OUT_OF_BOUNDS;
  rb->pursuit = &pursuit_messages[pursuit_idx];
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_mon_base_warning(struct parser* p)
{
  struct monster_base* rb = parser_priv(p);
  int warning_idx;
  if (!rb) return PARSE_ERROR_MISSING_RECORD_HEADER;
  warning_idx = parser_getuint(p, "warning");
  if (warning_idx >= z_info->warning_max) return PARSE_ERROR_OUT_OF_BOUNDS;
  rb->warning = &warning_messages[warning_idx];
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_mon_base_flags(struct parser* p)
{
  struct monster_base* rb = parser_priv(p);
  char* flags;
  char* s;
  if (!rb) return PARSE_ERROR_MISSING_RECORD_HEADER;
  if (!parser_hasval(p, "flags")) return PARSE_ERROR_NONE;
  flags = string_make(parser_getstr(p, "flags"));
  s = strtok(flags, " |");
  while (s) {
    if (grab_flag(rb->flags, RF_SIZE, r_info_flags, s)) {
      plog(format("bad monster base flag: %s", s));
      string_free(flags);
      return PARSE_ERROR_INVALID_FLAG;
    }
    s = strtok(NULL, " |");
  }
  string_free(flags);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_mon_base_desc(struct parser* p)
{
  struct monster_base* rb = parser_priv(p);
  if (!rb) return PARSE_ERROR_MISSING_RECORD_HEADER;
  rb->text = string_append(rb->text, parser_getstr(p, "desc"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_parse_mon_base(void)
{
  struct parser* p = parser_new();
  parser_setpriv(p, NULL);
  parser_reg(p, "name str name", parse_mon_base_name);
  parser_reg(p, "glyph char glyph", parse_mon_base_glyph);
  parser_reg(p, "pain uint pain", parse_mon_base_pain);
  parser_reg(p, "pursuit uint pursuit", parse_mon_base_pursuit);
  parser_reg(p, "warning uint warning", parse_mon_base_warning);
  parser_reg(p, "flags ?str flags", parse_mon_base_flags);
  parser_reg(p, "desc str desc", parse_mon_base_desc);
  return p;
}
STATIC_OVL errr
run_parse_mon_base(struct parser* p)
{
  return parse_file_quit_not_found(p, "monster_base");
}
STATIC_OVL errr
finish_parse_mon_base(struct parser* p)
{
  rb_info = parser_priv(p);
  parser_destroy(p);
  return 0;
}
STATIC_OVL void
cleanup_mon_base(void)
{
  struct monster_base *rb, *next;
  rb = rb_info;
  while (rb) {
    next = rb->next;
    string_free(rb->text);
    string_free(rb->name);
    mem_free(rb);
    rb = next;
  }
}
STATIC_OVL enum parser_error
parse_monster_name(struct parser* p)
{
  struct monster_race* h = parser_priv(p);
  struct monster_race* r = mem_zalloc(sizeof *r);
  r->next = h;
  r->name = string_make(parser_getstr(p, "name"));
  parser_setpriv(p, r);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_monster_base(struct parser* p)
{
  struct monster_race* r = parser_priv(p);
  if (!r) return PARSE_ERROR_MISSING_RECORD_HEADER;
  r->base = lookup_monster_base(parser_getsym(p, "base"));
  if (r->base == NULL) return PARSE_ERROR_INVALID_MONSTER_BASE;
  r->d_char = r->base->d_char;
  rf_union(r->flags, r->base->flags);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_monster_depth(struct parser* p)
{
  struct monster_race* r = parser_priv(p);
  if (!r) return PARSE_ERROR_MISSING_RECORD_HEADER;
  r->level = parser_getint(p, "level");
  r->spell_power = r->level;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_monster_rarity(struct parser* p)
{
  struct monster_race* r = parser_priv(p);
  if (!r) return PARSE_ERROR_MISSING_RECORD_HEADER;
  r->rarity = parser_getint(p, "rarity");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_monster_glyph(struct parser* p)
{
  struct monster_race* r = parser_priv(p);
  if (!r) return PARSE_ERROR_MISSING_RECORD_HEADER;
  r->d_char = parser_getchar(p, "glyph");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_monster_color(struct parser* p)
{
  struct monster_race* r = parser_priv(p);
  const char* color;
  int attr;
  if (!r) return PARSE_ERROR_MISSING_RECORD_HEADER;
  color = parser_getsym(p, "color");
  if (strlen(color) > 1)
    attr = color_text_to_attr(color);
  else
    attr = color_char_to_attr(color[0]);
  if (attr < 0) return PARSE_ERROR_INVALID_COLOR;
  r->d_attr = attr;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_monster_speed(struct parser* p)
{
  struct monster_race* r = parser_priv(p);
  if (!r) return PARSE_ERROR_MISSING_RECORD_HEADER;
  r->speed = parser_getint(p, "speed");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_monster_health(struct parser* p)
{
  struct monster_race* r = parser_priv(p);
  struct random health;
  if (!r) return PARSE_ERROR_MISSING_RECORD_HEADER;
  health = parser_getrand(p, "dice");
  r->hdice = health.dice;
  r->hside = health.sides;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_monster_light(struct parser* p)
{
  struct monster_race* r = parser_priv(p);
  if (!r) return PARSE_ERROR_MISSING_RECORD_HEADER;
  r->light = parser_getint(p, "light");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_monster_sleep(struct parser* p)
{
  struct monster_race* r = parser_priv(p);
  if (!r) return PARSE_ERROR_MISSING_RECORD_HEADER;
  r->sleep = parser_getint(p, "sleep");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_monster_percept(struct parser* p)
{
  struct monster_race* r = parser_priv(p);
  if (!r) return PARSE_ERROR_MISSING_RECORD_HEADER;
  r->per = parser_getint(p, "per");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_monster_stealth(struct parser* p)
{
  struct monster_race* r = parser_priv(p);
  if (!r) return PARSE_ERROR_MISSING_RECORD_HEADER;
  r->stl = parser_getint(p, "stealth");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_monster_will(struct parser* p)
{
  struct monster_race* r = parser_priv(p);
  if (!r) return PARSE_ERROR_MISSING_RECORD_HEADER;
  r->wil = parser_getint(p, "will");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_monster_song(struct parser* p)
{
  struct monster_race* r = parser_priv(p);
  if (!r) return PARSE_ERROR_MISSING_RECORD_HEADER;
  r->song = parser_getint(p, "song");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_monster_protection(struct parser* p)
{
  struct monster_race* r = parser_priv(p);
  struct random dice;
  if (!r) return PARSE_ERROR_MISSING_RECORD_HEADER;
  r->evn = parser_getint(p, "evn");
  if (parser_hasval(p, "dice")) {
    dice = parser_getrand(p, "dice");
    r->pd = dice.dice;
    r->ps = dice.sides;
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_monster_blow(struct parser* p)
{
  struct monster_race* r = parser_priv(p);
  struct monster_blow* b;
  int att;
  if (!r) return PARSE_ERROR_MISSING_RECORD_HEADER;
  b = r->blow;
  if (!b) {
    r->blow = mem_zalloc(sizeof(struct monster_blow));
    b = r->blow;
  } else {
    while (b->next) b = b->next;
    b->next = mem_zalloc(sizeof(struct monster_blow));
    b = b->next;
  }
  b->method = findmeth(parser_getsym(p, "method"));
  if (!b->method) return PARSE_ERROR_UNRECOGNISED_BLOW;
  b->effect = findeff(parser_getsym(p, "effect"));
  if (!b->effect) return PARSE_ERROR_INVALID_EFFECT;
  att = parser_getuint(p, "att");
  if (parser_hasval(p, "damage")) {
    b->dice = parser_getrand(p, "damage");
  }
  b->dice.base = att;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_monster_flags(struct parser* p)
{
  struct monster_race* r = parser_priv(p);
  char* flags;
  char* s;
  if (!r) return PARSE_ERROR_MISSING_RECORD_HEADER;
  if (!parser_hasval(p, "flags")) return PARSE_ERROR_NONE;
  flags = string_make(parser_getstr(p, "flags"));
  s = strtok(flags, " |");
  while (s) {
    if (grab_flag(r->flags, RF_SIZE, r_info_flags, s)) {
      plog(format("bad monster race flag: %s", s));
      string_free(flags);
      return PARSE_ERROR_INVALID_FLAG;
    }
    s = strtok(NULL, " |");
  }
  string_free(flags);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_monster_desc(struct parser* p)
{
  struct monster_race* r = parser_priv(p);
  if (!r) return PARSE_ERROR_MISSING_RECORD_HEADER;
  r->text = string_append(r->text, parser_getstr(p, "desc"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_monster_ranged_freq(struct parser* p)
{
  struct monster_race* r = parser_priv(p);
  int pct;
  if (!r) return PARSE_ERROR_MISSING_RECORD_HEADER;
  pct = parser_getint(p, "freq");
  if (pct < 1 || pct > 100) return PARSE_ERROR_INVALID_SPELL_FREQ;
  r->freq_ranged = pct;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_monster_spell_power(struct parser* p)
{
  struct monster_race* r = parser_priv(p);
  if (!r) return PARSE_ERROR_MISSING_RECORD_HEADER;
  r->spell_power = parser_getuint(p, "power");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_monster_spells(struct parser* p)
{
  struct monster_race* r = parser_priv(p);
  char* flags;
  char* s;
  int ret = PARSE_ERROR_NONE;
  if (!r) return PARSE_ERROR_MISSING_RECORD_HEADER;
  flags = string_make(parser_getstr(p, "spells"));
  s = strtok(flags, " |");
  while (s) {
    if (grab_flag(r->spell_flags, RSF_SIZE, r_info_spell_flags, s)) {
      plog(format("bad monster spell flag: %s", s));
      ret = PARSE_ERROR_INVALID_FLAG;
      break;
    }
    s = strtok(NULL, " |");
  }
  mem_free(flags);
  return ret;
}
STATIC_OVL void
add_alternate_spell_message(struct monster_race* r, int s_idx,
                            enum monster_altmsg_type msg_type, const char* msg)
{
  struct monster_altmsg* alt = mem_alloc(sizeof(*alt));
  alt->next = r->spell_msgs;
  r->spell_msgs = alt;
  if (msg == NULL || contains_only_spaces(msg)) {
    alt->message = string_make("");
  } else {
    alt->message = string_make(msg);
  }
  alt->msg_type = msg_type;
  assert(s_idx >= 0 && s_idx <= 0xFFFF);
  alt->index = (uint16_t)s_idx;
}
STATIC_OVL enum parser_error
parse_monster_msg_vis(struct parser* p)
{
  struct monster_race* r = parser_priv(p);
  const char* spell = parser_getsym(p, "spell");
  const char* msg =
      (parser_hasval(p, "message")) ? parser_getstr(p, "message") : NULL;
  int s_idx;
  if (!r) return PARSE_ERROR_MISSING_RECORD_HEADER;
  if (grab_name("monster spell", spell, r_info_spell_flags,
                N_ELEMENTS(r_info_spell_flags) - 1, &s_idx))
    return PARSE_ERROR_INVALID_SPELL_NAME;
  add_alternate_spell_message(r, s_idx, MON_ALTMSG_SEEN, msg);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_monster_msg_invis(struct parser* p)
{
  struct monster_race* r = parser_priv(p);
  const char* spell = parser_getsym(p, "spell");
  const char* msg =
      (parser_hasval(p, "message")) ? parser_getstr(p, "message") : NULL;
  int s_idx;
  if (!r) return PARSE_ERROR_MISSING_RECORD_HEADER;
  if (grab_name("monster spell", spell, r_info_spell_flags,
                N_ELEMENTS(r_info_spell_flags) - 1, &s_idx))
    return PARSE_ERROR_INVALID_SPELL_NAME;
  add_alternate_spell_message(r, s_idx, MON_ALTMSG_UNSEEN, msg);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_monster_drop(struct parser* p)
{
  struct monster_race* r = parser_priv(p);
  struct monster_drop* d;
  struct object_kind* k;
  int tval, sval;
  if (!r) return PARSE_ERROR_MISSING_RECORD_HEADER;
  tval = tval_find_idx(parser_getsym(p, "tval"));
  if (tval < 0) return PARSE_ERROR_UNRECOGNISED_TVAL;
  sval = lookup_sval(tval, parser_getsym(p, "sval"));
  if (sval < 0) return PARSE_ERROR_UNRECOGNISED_SVAL;
  k = lookup_kind(tval, sval);
  if (!k) return PARSE_ERROR_UNRECOGNISED_SVAL;
  d = mem_zalloc(sizeof *d);
  d->kind = k;
  d->percent_chance = parser_getuint(p, "chance");
  d->dice = parser_getrand(p, "dice");
  d->next = r->drops;
  r->drops = d;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_monster_drop_artifact(struct parser* p)
{
  struct monster_race* r = parser_priv(p);
  struct monster_drop* d;
  const struct artifact* art;
  if (!r) return PARSE_ERROR_MISSING_RECORD_HEADER;
  art = lookup_artifact_name(parser_getstr(p, "name"));
  if (!art) return PARSE_ERROR_NO_ARTIFACT_NAME;
  d = mem_zalloc(sizeof *d);
  d->art = art;
  d->percent_chance = 100;
  d->next = r->drops;
  r->drops = d;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_monster_plural(struct parser* p)
{
  struct monster_race* r = parser_priv(p);
  if (r == NULL) return PARSE_ERROR_MISSING_RECORD_HEADER;
  if (parser_hasval(p, "plural")) {
    const char* plural = parser_getstr(p, "plural");
    if (strlen(plural) > 0)
      r->plural = string_make(plural);
    else
      r->plural = NULL;
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_monster_color_cycle(struct parser* p)
{
  struct monster_race* r = parser_priv(p);
  const char* group = parser_getsym(p, "group");
  const char* ccycle = parser_getsym(p, "cycle");
  if (r == NULL) return PARSE_ERROR_MISSING_RECORD_HEADER;
  if (group == NULL || strlen(group) == 0) return PARSE_ERROR_INVALID_VALUE;
  if (ccycle == NULL || strlen(ccycle) == 0) return PARSE_ERROR_INVALID_VALUE;
  visuals_cycler_set_cycle_for_race(r, group, ccycle);
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_parse_monster(void)
{
  struct parser* p = parser_new();
  parser_setpriv(p, NULL);
  parser_reg(p, "name str name", parse_monster_name);
  parser_reg(p, "plural ?str plural", parse_monster_plural);
  parser_reg(p, "base sym base", parse_monster_base);
  parser_reg(p, "depth int level", parse_monster_depth);
  parser_reg(p, "rarity int rarity", parse_monster_rarity);
  parser_reg(p, "glyph char glyph", parse_monster_glyph);
  parser_reg(p, "color sym color", parse_monster_color);
  parser_reg(p, "speed int speed", parse_monster_speed);
  parser_reg(p, "health rand dice", parse_monster_health);
  parser_reg(p, "light int light", parse_monster_light);
  parser_reg(p, "sleep int sleep", parse_monster_sleep);
  parser_reg(p, "percept int per", parse_monster_percept);
  parser_reg(p, "stealth int stealth", parse_monster_stealth);
  parser_reg(p, "will int will", parse_monster_will);
  parser_reg(p, "song int song", parse_monster_song);
  parser_reg(p, "prot int evn ?rand dice", parse_monster_protection);
  parser_reg(p, "blow sym method sym effect uint att ?rand damage",
             parse_monster_blow);
  parser_reg(p, "flags ?str flags", parse_monster_flags);
  parser_reg(p, "desc str desc", parse_monster_desc);
  parser_reg(p, "ranged-freq int freq", parse_monster_ranged_freq);
  parser_reg(p, "spell-power uint power", parse_monster_spell_power);
  parser_reg(p, "spells str spells", parse_monster_spells);
  parser_reg(p, "message-vis sym spell ?str message", parse_monster_msg_vis);
  parser_reg(p, "message-invis sym spell ?str message",
             parse_monster_msg_invis);
  parser_reg(p, "drop sym tval sym sval uint chance rand dice",
             parse_monster_drop);
  parser_reg(p, "drop-artifact str name", parse_monster_drop_artifact);
  parser_reg(p, "color-cycle sym group sym cycle", parse_monster_color_cycle);
  return p;
}
STATIC_OVL errr
run_parse_monster(struct parser* p)
{
  return parse_file_quit_not_found(p, "monster");
}
STATIC_OVL errr
finish_parse_monster(struct parser* p)
{
  struct monster_race *r, *n;
  size_t i;
  int ridx;
  z_info->r_max = 0;
  z_info->mon_blows_max = 0;
  r = parser_priv(p);
  while (r) {
    int max_blows = 0;
    struct monster_blow* b = r->blow;
    z_info->r_max++;
    while (b) {
      b = b->next;
      max_blows++;
    }
    if (max_blows > z_info->mon_blows_max) z_info->mon_blows_max = max_blows;
    r = r->next;
  }
  r_info = mem_zalloc((z_info->r_max + 1) * sizeof(*r));
  ridx = z_info->r_max - 1;
  for (r = parser_priv(p); r; r = n, ridx--) {
    struct monster_blow* b_new;
    assert(ridx >= 0);
    memcpy(&r_info[ridx], r, sizeof(*r));
    r_info[ridx].ridx = ridx;
    n = r->next;
    if (ridx < z_info->r_max - 1)
      r_info[ridx].next = &r_info[ridx + 1];
    else
      r_info[ridx].next = NULL;
    b_new = mem_zalloc(z_info->mon_blows_max * sizeof(*b_new));
    if (r->blow) {
      struct monster_blow *b_temp, *b_old = r->blow;
      for (i = 0; i < z_info->mon_blows_max; i++) {
        memcpy(&b_new[i], b_old, sizeof(*b_old));
        b_old = b_old->next;
        if (!b_old) break;
      }
      for (i = 0; i < z_info->mon_blows_max; i++)
        if (b_new[i].next) b_new[i].next = &b_new[i + 1];
      b_old = r->blow;
      b_temp = b_old;
      while (b_temp) {
        b_temp = b_old->next;
        mem_free(b_old);
        b_old = b_temp;
      }
    }
    r_info[ridx].blow = b_new;
    mem_free(r);
  }
  z_info->r_max += 1;
  l_list = mem_zalloc(z_info->r_max * sizeof(struct monster_lore));
  for (i = 0; i < z_info->r_max; i++) {
    struct monster_lore* l = &l_list[i];
    l->blows = mem_zalloc(z_info->mon_blows_max * sizeof(struct monster_blow));
    l->blow_known = mem_zalloc(z_info->mon_blows_max * sizeof(bool));
  }
  parser_destroy(p);
  return 0;
}
STATIC_OVL void
cleanup_monster(void)
{
  int ridx;
  for (ridx = 0; ridx < z_info->r_max; ridx++) {
    struct monster_race* r = &r_info[ridx];
    struct monster_altmsg* am;
    struct monster_drop* d;
    am = r->spell_msgs;
    while (am) {
      struct monster_altmsg* amn = am->next;
      string_free(am->message);
      mem_free(am);
      am = amn;
    }
    d = r->drops;
    while (d) {
      struct monster_drop* dn = d->next;
      mem_free(d);
      d = dn;
    }
    string_free(r->plural);
    string_free(r->text);
    string_free(r->name);
    mem_free(r->blow);
  }
  mem_free(r_info);
}
STATIC_OVL enum parser_error
parse_lore_name(struct parser* p)
{
  struct monster_race* race = lookup_monster(parser_getstr(p, "name"));
  struct monster_lore* l = NULL;
  if (race) {
    l = &l_list[race->ridx];
    l->ridx = race->ridx;
  }
  parser_setpriv(p, l);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_lore_base(struct parser* p)
{
  struct monster_lore* l = parser_priv(p);
  struct monster_base* base = lookup_monster_base(parser_getsym(p, "base"));
  if (!l) return PARSE_ERROR_NONE;
  if (base == NULL) return PARSE_ERROR_INVALID_MONSTER_BASE;
  l->all_known = true;
  rf_setall(l->flags);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_lore_counts(struct parser* p)
{
  struct monster_lore* l = parser_priv(p);
  if (!l) return PARSE_ERROR_NONE;
  l->tsights = parser_getint(p, "sights");
  l->deaths = parser_getint(p, "deaths");
  l->tkills = parser_getint(p, "kills");
  l->notice = parser_getint(p, "notice");
  l->ignore = parser_getint(p, "ignore");
  l->ranged = parser_getint(p, "ranged");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_lore_blow(struct parser* p)
{
  struct monster_lore* l = parser_priv(p);
  struct blow_method* method = NULL;
  struct blow_effect* effect = NULL;
  int seen = 0, index = 0;
  struct random dam = {0, 0, 0, 0};
  if (!l) return PARSE_ERROR_NONE;
  method = findmeth(parser_getsym(p, "method"));
  if (!method) return PARSE_ERROR_UNRECOGNISED_BLOW;
  if (parser_hasval(p, "effect")) {
    effect = findeff(parser_getsym(p, "effect"));
    if (!effect) return PARSE_ERROR_INVALID_EFFECT;
  }
  if (parser_hasval(p, "damage")) dam = parser_getrand(p, "damage");
  if (parser_hasval(p, "seen")) seen = parser_getint(p, "seen");
  if (parser_hasval(p, "index")) index = parser_getint(p, "index");
  if (index >= z_info->mon_blows_max) return PARSE_ERROR_TOO_MANY_ENTRIES;
  if (seen) {
    struct monster_blow* b = &l->blows[index];
    b->method = method;
    b->effect = effect;
    b->dice = dam;
    b->times_seen = seen;
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_lore_flags(struct parser* p)
{
  struct monster_lore* l = parser_priv(p);
  char* flags;
  char* s;
  if (!l) return PARSE_ERROR_NONE;
  if (!parser_hasval(p, "flags")) return PARSE_ERROR_NONE;
  flags = string_make(parser_getstr(p, "flags"));
  s = strtok(flags, " |");
  while (s) {
    (void)grab_flag(l->flags, RF_SIZE, r_info_flags, s);
    s = strtok(NULL, " |");
  }
  mem_free(flags);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_lore_spells(struct parser* p)
{
  struct monster_lore* l = parser_priv(p);
  char* flags;
  char* s;
  int ret = PARSE_ERROR_NONE;
  if (!l) return PARSE_ERROR_NONE;
  flags = string_make(parser_getstr(p, "spells"));
  s = strtok(flags, " |");
  while (s) {
    (void)grab_flag(l->spell_flags, RSF_SIZE, r_info_spell_flags, s);
    s = strtok(NULL, " |");
  }
  mem_free(flags);
  return ret;
}
STATIC_OVL enum parser_error
parse_lore_drop(struct parser* p)
{
  struct monster_lore* l = parser_priv(p);
  struct monster_drop* d;
  struct object_kind* k;
  int tval, sval;
  if (!l) return PARSE_ERROR_NONE;
  tval = tval_find_idx(parser_getsym(p, "tval"));
  if (tval < 0) return PARSE_ERROR_UNRECOGNISED_TVAL;
  sval = lookup_sval(tval, parser_getsym(p, "sval"));
  if (sval < 0) return PARSE_ERROR_UNRECOGNISED_SVAL;
  k = lookup_kind(tval, sval);
  if (!k) return PARSE_ERROR_UNRECOGNISED_SVAL;
  d = mem_zalloc(sizeof *d);
  d->kind = k;
  d->percent_chance = parser_getuint(p, "chance");
  d->dice = parser_getrand(p, "dice");
  d->next = l->drops;
  l->drops = d;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_lore_drop_artifact(struct parser* p)
{
  struct monster_lore* l = parser_priv(p);
  struct monster_drop* d;
  const char* name;
  if (!l) return PARSE_ERROR_NONE;
  name = parser_getstr(p, "name");
  d = mem_zalloc(sizeof *d);
  d->art = lookup_artifact_name(name);
  d->percent_chance = 100;
  d->next = l->drops;
  l->drops = d;
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_parse_lore(void)
{
  struct parser* p = parser_new();
  parser_setpriv(p, NULL);
  parser_reg(p, "name str name", parse_lore_name);
  parser_reg(p, "plural ?str plural", ignored);
  parser_reg(p, "base sym base", parse_lore_base);
  parser_reg(p, "depth int level", ignored);
  parser_reg(p, "rarity int rarity", ignored);
  parser_reg(p, "glyph char glyph", ignored);
  parser_reg(p, "color sym color", ignored);
  parser_reg(p, "speed int speed", ignored);
  parser_reg(p, "health rand dice", ignored);
  parser_reg(p, "light int light", ignored);
  parser_reg(p, "sleep int sleep", ignored);
  parser_reg(p, "percept int per", ignored);
  parser_reg(p, "stealth int stealth", ignored);
  parser_reg(p, "will int will", ignored);
  parser_reg(p, "song int song", ignored);
  parser_reg(p, "prot int evn ?rand dice", ignored);
  parser_reg(
      p,
      "counts int sights int deaths int kills int notice int ignore int ranged",
      parse_lore_counts);
  parser_reg(p, "blow sym method ?sym effect ?rand damage ?int seen ?int index",
             parse_lore_blow);
  parser_reg(p, "flags ?str flags", parse_lore_flags);
  parser_reg(p, "desc str desc", ignored);
  parser_reg(p, "ranged-freq int freq", ignored);
  parser_reg(p, "spell-power uint power", ignored);
  parser_reg(p, "spells str spells", parse_lore_spells);
  parser_reg(p, "message-vis sym spell ?str message", ignored);
  parser_reg(p, "message-invis sym spell ?str message", ignored);
  parser_reg(p, "drop sym tval sym sval uint chance rand dice",
             parse_lore_drop);
  parser_reg(p, "drop-artifact str name", parse_lore_drop_artifact);
  parser_reg(p, "color-cycle sym group sym cycle", ignored);
  return p;
}
STATIC_OVL errr
run_parse_lore(struct parser* p)
{
  if (parse_file(p, "lore")) {
    event_signal_message(EVENT_INITSTATUS, 0, "No monster lore file found");
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL errr
finish_parse_lore(struct parser* p)
{
  size_t i;
  for (i = 0; i < z_info->r_max; i++) {
    struct monster_lore* l = &l_list[i];
    struct monster_race* r = &r_info[i];
    int j;
    if (r->base) {
      rf_union(l->flags, r->base->flags);
    }
    for (j = 0; j < z_info->mon_blows_max; j++) {
      if (!r->blow) break;
      if (!(r->blow[j].effect || r->blow[j].method)) l->blows[j].times_seen = 0;
    }
    lore_update(r, l);
  }
  parser_destroy(p);
  return 0;
}
STATIC_OVL void
cleanup_lore(void)
{
  int ridx;
  for (ridx = 0; ridx < z_info->r_max; ridx++) {
    struct monster_lore* l = &l_list[ridx];
    struct monster_drop* d;
    d = l->drops;
    while (d) {
      struct monster_drop* dn = d->next;
      mem_free(d);
      d = dn;
    }
    mem_free(l->blows);
    mem_free(l->blow_known);
  }
  mem_free(l_list);
}
STATIC_OVL monster_list_t*
monster_list_new(void)
{
  monster_list_t* list = mem_zalloc(sizeof(monster_list_t));
  size_t size = cave_monster_max(cave);
  if (list == NULL) return NULL;
  list->entries = mem_zalloc(size * sizeof(monster_list_entry_t));
  if (list->entries == NULL) {
    mem_free(list);
    return NULL;
  }
  list->entries_size = size;
  return list;
}
STATIC_OVL void
monster_list_free(monster_list_t* list)
{
  if (list == NULL) return;
  if (list->entries != NULL) {
    mem_free(list->entries);
    list->entries = NULL;
  }
  mem_free(list);
  list = NULL;
}
STATIC_OVL void
monster_list_init(void)
{
  monster_list_subwindow = NULL;
}
STATIC_OVL void
monster_list_finalize(void)
{
  monster_list_free(monster_list_subwindow);
}
STATIC_OVL monster_list_t*
monster_list_shared_instance(void)
{
  if (monster_list_subwindow == NULL) {
    monster_list_subwindow = monster_list_new();
  }
  return monster_list_subwindow;
}
STATIC_OVL bool
monster_list_can_update(const monster_list_t* list)
{
  if (list == NULL || list->entries == NULL) return false;
  return (int)list->entries_size >= cave_monster_max(cave);
}
STATIC_OVL void
monster_list_reset(monster_list_t* list)
{
  if (list == NULL || list->entries == NULL) return;
  if ((int)list->entries_size < cave_monster_max(cave)) {
    list->entries = mem_realloc(
        list->entries, sizeof(list->entries[0]) * cave_monster_max(cave));
    list->entries_size = cave_monster_max(cave);
  }
  memset(list->entries, 0, list->entries_size * sizeof(monster_list_entry_t));
  memset(list->total_entries, 0, MONSTER_LIST_SECTION_MAX * sizeof(uint16_t));
  memset(list->total_monsters, 0, MONSTER_LIST_SECTION_MAX * sizeof(uint16_t));
  list->distinct_entries = 0;
  list->creation_turn = 0;
  list->sorted = false;
}
STATIC_OVL void
monster_list_collect(monster_list_t* list)
{
  int i;
  if (list == NULL || list->entries == NULL) return;
  if (!monster_list_can_update(list)) return;
  for (i = 1; i < cave_monster_max(cave); i++) {
    struct monster* mon = cave_monster(cave, i);
    monster_list_entry_t* entry = NULL;
    int j, field;
    bool los = false;
    if (!monster_is_visible(mon)) continue;
    for (j = 0; j < (int)list->entries_size; j++) {
      if (list->entries[j].race == NULL) {
        entry = &list->entries[j];
        memset(entry, 0, sizeof(monster_list_entry_t));
        entry->race = mon->race;
        break;
      } else if (list->entries[j].race == mon->race) {
        entry = &list->entries[j];
        break;
      }
    }
    if (entry == NULL) continue;
    entry->attr = mon->attr;
    los = projectable(cave, player->grid, mon->grid, PROJECT_NONE);
    field = (los) ? MONSTER_LIST_SECTION_LOS : MONSTER_LIST_SECTION_ESP;
    entry->count[field]++;
    if (mon->alertness >= ALERTNESS_ALERT) entry->alert[field]++;
    entry->dx[field] = mon->grid.x - player->grid.x;
    entry->dy[field] = mon->grid.y - player->grid.y;
  }
  for (i = 0; i < (int)list->entries_size; i++) {
    if (list->entries[i].race == NULL) continue;
    if (list->entries[i].count[MONSTER_LIST_SECTION_LOS] > 0)
      list->total_entries[MONSTER_LIST_SECTION_LOS]++;
    if (list->entries[i].count[MONSTER_LIST_SECTION_ESP] > 0)
      list->total_entries[MONSTER_LIST_SECTION_ESP]++;
    list->total_monsters[MONSTER_LIST_SECTION_LOS] +=
        list->entries[i].count[MONSTER_LIST_SECTION_LOS];
    list->total_monsters[MONSTER_LIST_SECTION_ESP] +=
        list->entries[i].count[MONSTER_LIST_SECTION_ESP];
    list->distinct_entries++;
  }
  list->creation_turn = turn;
  list->sorted = false;
}
STATIC_OVL int
monster_list_standard_compare(const void* a, const void* b)
{
  const struct monster_race* ar = ((monster_list_entry_t*)a)->race;
  const struct monster_race* br = ((monster_list_entry_t*)b)->race;
  if (ar == NULL || br == NULL) return 1;
  if (ar->level > br->level) return -1;
  if (ar->level < br->level) return 1;
  return 0;
}
STATIC_OVL int
monster_list_compare_exp(const void* a, const void* b)
{
  const struct monster_race* ar = ((monster_list_entry_t*)a)->race;
  const struct monster_race* br = ((monster_list_entry_t*)b)->race;
  long a_exp, b_exp;
  if (ar == NULL || br == NULL) return 1;
  a_exp = (long)ar->level;
  b_exp = (long)br->level;
  if (a_exp > b_exp) return -1;
  if (a_exp < b_exp) return 1;
  return 0;
}
STATIC_OVL void
monster_list_sort(monster_list_t* list,
                  int (*compare)(const void*, const void*))
{
  size_t elements;
  if (list == NULL || list->entries == NULL) return;
  if (list->sorted) return;
  elements = list->distinct_entries;
  if (elements <= 1) return;
  sort(list->entries, MIN(elements, list->entries_size),
       sizeof(list->entries[0]), compare);
  list->sorted = true;
}
STATIC_OVL int
monster_list_entry_line_color(const monster_list_entry_t* entry)
{
  if (rf_has(entry->race->flags, RF_UNIQUE))
    return COLOUR_VIOLET;
  else if (entry->race->level > player->depth)
    return COLOUR_RED;
  else
    return COLOUR_WHITE;
}
STATIC_OVL void
lore_learn_flag_if_visible(struct monster_lore* lore, const struct monster* mon,
                           int flag)
{
  if (monster_is_visible(mon)) {
    rf_on(lore->flags, flag);
  }
}
STATIC_OVL void
lore_update(const struct monster_race* race, struct monster_lore* lore)
{
  int i;
  bitflag mask[RF_SIZE];
  if (!race || !lore) return;
  create_mon_flag_mask(mask, RFT_OBV, RFT_ABIL_OBV, RFT_MAX);
  rf_union(lore->flags, mask);
  for (i = 0; i < z_info->mon_blows_max; i++) {
    if (!race->blow) break;
    if (lore->blow_known[i] || (lore->blows[i].times_seen) || lore->all_known) {
      lore->blow_known[i] = true;
      lore->blows[i].method = race->blow[i].method;
      lore->blows[i].effect = race->blow[i].effect;
      lore->blows[i].dice = race->blow[i].dice;
    }
  }
  if ((lore->tkills > 0) || lore->all_known) {
    lore->armour_known = true;
    lore->drop_known = true;
    create_mon_flag_mask(mask, RFT_RACE_A, RFT_RACE_N, RFT_DROP, RFT_MAX);
    rf_union(lore->flags, mask);
    rf_on(lore->flags, RF_FORCE_DEPTH);
  }
  if ((lore->ranged == UCHAR_MAX) || lore->all_known ||
      ((player && lore->tsights > 1) &&
       (10 - lore->tsights < player->state.skill_use[SKILL_PERCEPTION])))
    lore->sleep_known = true;
  if (lore->ranged == UCHAR_MAX || lore->all_known) {
    lore->ranged_freq_known = true;
  }
  if (lore->all_known) {
    rf_setall(lore->flags);
    rsf_copy(lore->spell_flags, race->spell_flags);
  }
}
STATIC_OVL void
cheat_monster_lore(const struct monster_race* race, struct monster_lore* lore)
{
  assert(race);
  assert(lore);
  lore->all_known = true;
  lore_update(race, lore);
}
STATIC_OVL void
wipe_monster_lore(const struct monster_race* race, struct monster_lore* lore)
{
  struct monster_blow* blows;
  bool* blow_known;
  struct monster_drop* d;
  assert(race);
  assert(lore);
  d = lore->drops;
  while (d) {
    struct monster_drop* dn = d->next;
    mem_free(d);
    d = dn;
  }
  blows = lore->blows;
  memset(blows, 0, z_info->mon_blows_max * sizeof(*blows));
  blow_known = lore->blow_known;
  memset(blow_known, 0, z_info->mon_blows_max * sizeof(*blow_known));
  memset(lore, 0, sizeof(*lore));
  lore->blows = blows;
  lore->blow_known = blow_known;
}
STATIC_OVL void
lore_do_probe(struct monster* mon)
{
  struct monster_lore* lore = get_lore(mon->race);
  lore->all_known = true;
  lore_update(mon->race, lore);
  if (player->upkeep->monster_race == mon->race)
    player->upkeep->redraw |= (PR_MONSTER);
}
STATIC_OVL bool
lore_is_fully_known(const struct monster_race* race)
{
  unsigned i;
  struct monster_lore* lore = get_lore(race);
  if (lore->all_known) return true;
  if (!lore->armour_known) return false;
  if (!lore->ranged_freq_known && race->freq_ranged) return false;
  if (!lore->drop_known) return false;
  if (!lore->sleep_known) return false;
  for (i = 0; i < z_info->mon_blows_max; i++) {
    if (!race->blow[i].method) break;
    if (!lore->blow_known[i]) return false;
  }
  for (i = 0; i < RF_SIZE; i++)
    if (!lore->flags[i]) return false;
  for (i = 0; i < RSF_SIZE; i++)
    if (lore->spell_flags[i] != race->spell_flags[i]) return false;
  lore->all_known = true;
  lore_update(race, lore);
  return true;
}
STATIC_OVL void
lore_treasure(struct monster* mon, int num_item)
{
  struct monster_lore* lore = get_lore(mon->race);
  assert(num_item >= 0);
  if (num_item > lore->drop_item) {
    lore->drop_item = num_item;
  }
  rf_on(lore->flags, RF_DROP_GOOD);
  rf_on(lore->flags, RF_DROP_GREAT);
  if (player->upkeep->monster_race == mon->race) {
    player->upkeep->redraw |= (PR_MONSTER);
  }
}
STATIC_OVL void
monster_flags_known(const struct monster_race* race,
                    const struct monster_lore* lore, bitflag flags[RF_SIZE])
{
  rf_copy(flags, race->flags);
  rf_inter(flags, lore->flags);
}
STATIC_OVL const char*
lore_describe_awareness(int16_t awareness)
{
  static const struct lore_awareness {
    int16_t threshold;
    const char* description;
  } lore_awareness_description[] = {
      {20, "is usually found asleep"},
      {15, "is often found asleep"},
      {10, "is sometimes found asleep"},
      {5, "is never found asleep"},
      {1, "is quick to notice intruders"},
      {0, "is very quick to notice intruders"},
      {SHRT_MAX, NULL},
  };
  const struct lore_awareness* current = lore_awareness_description;
  while (current->threshold != SHRT_MAX && current->description != NULL) {
    if (awareness > current->threshold) return current->description;
    current++;
  }
  return "is ever vigilant";
}
STATIC_OVL const char*
lore_describe_speed(uint8_t speed)
{
  static const struct lore_speed {
    uint8_t threshold;
    const char* description;
  } lore_speed_description[] = {
      {5, "incredibly quickly"}, {4, "extremely quickly"},
      {3, "very quickly"},       {2, "quickly"},
      {1, "normal speed"},       {0, "slowly"},
      {UCHAR_MAX, NULL},
  };
  const struct lore_speed* current = lore_speed_description;
  while (current->threshold != UCHAR_MAX && current->description != NULL) {
    if (speed > current->threshold) return current->description;
    current++;
  }
  return "erroneously";
}
STATIC_OVL void
lore_adjective_speed(textblock* tb, const struct monster_race* race)
{
  if (race->speed == 2) textblock_append(tb, "at ");
  textblock_append_c(tb, COLOUR_GREEN, "%s", lore_describe_speed(race->speed));
}
STATIC_OVL monster_sex_t
lore_monster_sex(const struct monster_race* race)
{
  if (rf_has(race->flags, RF_FEMALE))
    return MON_SEX_FEMALE;
  else if (rf_has(race->flags, RF_MALE))
    return MON_SEX_MALE;
  return MON_SEX_NEUTER;
}
STATIC_OVL const char*
lore_pronoun_nominative(monster_sex_t sex, bool title_case)
{
  static const char* lore_pronouns[MON_SEX_MAX][2] = {
      {"it", "It"},
      {"he", "He"},
      {"she", "She"},
  };
  int pronoun_index = MON_SEX_NEUTER, case_index = 0;
  if (sex < MON_SEX_MAX) pronoun_index = sex;
  if (title_case) case_index = 1;
  return lore_pronouns[pronoun_index][case_index];
}
STATIC_OVL const char*
lore_pronoun_accusative(monster_sex_t sex, bool title_case)
{
  static const char* lore_pronouns[MON_SEX_MAX][2] = {
      {"it", "It"},
      {"him", "Him"},
      {"her", "Her"},
  };
  int pronoun_index = MON_SEX_NEUTER, case_index = 0;
  if (sex < MON_SEX_MAX) pronoun_index = sex;
  if (title_case) case_index = 1;
  return lore_pronouns[pronoun_index][case_index];
}
STATIC_OVL const char*
lore_pronoun_possessive(monster_sex_t sex, bool title_case)
{
  static const char* lore_pronouns[MON_SEX_MAX][2] = {
      {"its", "Its"},
      {"his", "His"},
      {"her", "Her"},
  };
  int pronoun_index = MON_SEX_NEUTER, case_index = 0;
  if (sex < MON_SEX_MAX) pronoun_index = sex;
  if (title_case) case_index = 1;
  return lore_pronouns[pronoun_index][case_index];
}
STATIC_OVL void
lore_append_clause(textblock* tb, bitflag* f, int attr, const char* start,
                   const char* conjunction, const char* end)
{
  int count = rf_count(f);
  bool comma = count > 2;
  if (count) {
    int flag;
    textblock_append(tb, "%s", start);
    for (flag = rf_next(f, FLAG_START); flag; flag = rf_next(f, flag + 1)) {
      if (flag != rf_next(f, FLAG_START)) {
        if (comma) {
          textblock_append(tb, ",");
        }
        if (rf_next(f, flag + 1) == FLAG_END) {
          textblock_append(tb, " ");
          textblock_append(tb, "%s", conjunction);
        }
        textblock_append(tb, " ");
      }
      textblock_append_c(tb, attr, "%s", describe_race_flag(flag));
    }
    textblock_append(tb, "%s", end);
  }
}
STATIC_OVL void
lore_append_spell_clause(textblock* tb, bitflag* f,
                         const struct monster_race* race, int attr,
                         int dam_attr)
{
  int count = rsf_count(f);
  bool comma = count > 2;
  if (count) {
    int spell;
    for (spell = rsf_next(f, FLAG_START); spell;
         spell = rsf_next(f, spell + 1)) {
      random_value damage = mon_spell_lore_damage(spell);
      int archery_bonus = 0;
      archery_bonus = mon_spell_lore_archery_bonus(spell, race);
      if (spell != rsf_next(f, FLAG_START)) {
        if (comma) {
          textblock_append(tb, ",");
        }
        if (rsf_next(f, spell + 1) == FLAG_END) {
          textblock_append(tb, " or");
        }
        textblock_append(tb, " ");
      }
      textblock_append_c(tb, attr, "%s",
                         mon_spell_lore_description(spell, race));
      if (damage.dice && damage.sides && archery_bonus) {
        textblock_append_c(tb, dam_attr, " (+%d, %dd%d)", archery_bonus,
                           damage.dice, damage.sides);
      } else if (damage.dice && damage.sides) {
        textblock_append_c(tb, dam_attr, " (%dd%d)", damage.dice, damage.sides);
      }
    }
    textblock_append(tb, ".  ");
  }
}
STATIC_OVL void
lore_append_kills(textblock* tb, const struct monster_race* race,
                  const struct monster_lore* lore,
                  const bitflag known_flags[RF_SIZE])
{
  monster_sex_t msex = MON_SEX_NEUTER;
  bool out = true;
  assert(tb && race && lore);
  msex = lore_monster_sex(race);
  if (rf_has(known_flags, RF_UNIQUE)) {
    bool dead = (race->max_num == 0) ? true : false;
    if (lore->deaths) {
      textblock_append(tb, "%s has slain %d of your ancestors",
                       lore_pronoun_nominative(msex, true), lore->deaths);
      if (dead)
        textblock_append(tb, ", but you have taken revenge!  ");
      else
        textblock_append(tb, ", who %s unavenged.  ",
                         VERB_AGREEMENT(lore->deaths, "remains", "remain"));
    } else if (dead) {
      textblock_append(tb, "You have slain this foe.  ");
    } else {
      out = false;
    }
    if (!dead) {
      if (lore->psights) {
        textblock_append(tb, "You have encountered this foe.  ");
      } else {
        textblock_append(tb, "You are yet to encounter this foe.  ");
      }
    }
  } else if (lore->deaths) {
    textblock_append(
        tb, "%d of your predecessors %s been killed by this creature, ",
        lore->deaths, VERB_AGREEMENT(lore->deaths, "has", "have"));
    if (lore->pkills) {
      textblock_append(
          tb, "and you have slain %d of the %d you have encountered.  ",
          lore->pkills, lore->psights);
    } else if (lore->tkills) {
      textblock_append(tb, "and your predecessors have slain %d in return.  ",
                       lore->tkills);
    } else {
      textblock_append_c(tb, COLOUR_RED,
                         "and %s is not ever known to have been defeated.  ",
                         lore_pronoun_nominative(msex, false));
      if (lore->psights) {
        textblock_append(tb, "You have encountered %d.  ", lore->psights);
      } else {
        textblock_append(tb, "You are yet to encounter one.  ");
      }
    }
  } else {
    if (lore->psights && !lore->pkills) {
      textblock_append(tb, "You have encountered %d of these creatures, ",
                       lore->psights);
      if (lore->tkills) {
        textblock_append(tb, "and your predecessors have slain %d.  ",
                         lore->tkills);
      } else {
        textblock_append(tb, "but no battles to the death are recalled.  ");
      }
    } else if (lore->pkills) {
      textblock_append(tb,
                       "You have slain %d of the %d you have encountered.  ",
                       lore->pkills, lore->psights);
    } else {
      textblock_append(tb, "You have encountered none of these creatures, ");
      if (lore->tkills) {
        textblock_append(tb, "but your predecessors have slain %d.  ",
                         lore->tkills);
      } else {
        textblock_append(tb, "and no battles to the death are recalled.  ");
      }
    }
  }
  if (out) textblock_append(tb, "\n");
}
STATIC_OVL void
lore_append_flavor(textblock* tb, const struct monster_race* race)
{
  assert(tb && race);
  textblock_append(tb, "%s\n", race->text);
}
STATIC_OVL void
lore_append_movement(textblock* tb, const struct monster_race* race,
                     const struct monster_lore* lore,
                     bitflag known_flags[RF_SIZE])
{
  int f;
  bitflag flags[RF_SIZE];
  assert(tb && race && lore);
  textblock_append(tb, "This");
  create_mon_flag_mask(flags, RFT_RACE_A, RFT_MAX);
  rf_inter(flags, race->flags);
  for (f = rf_next(flags, FLAG_START); f; f = rf_next(flags, f + 1)) {
    textblock_append_c(tb, COLOUR_L_BLUE, " %s", describe_race_flag(f));
  }
  create_mon_flag_mask(flags, RFT_RACE_N, RFT_MAX);
  rf_inter(flags, race->flags);
  f = rf_next(flags, FLAG_START);
  if (f) {
    textblock_append_c(tb, COLOUR_L_BLUE, " %s", describe_race_flag(f));
  } else {
    textblock_append_c(tb, COLOUR_L_BLUE, " creature");
  }
  if (race->level == 0) {
    textblock_append_c(tb, COLOUR_YELLOW, " dwells at the gates of Angband");
  } else {
    if (rf_has(known_flags, RF_FORCE_DEPTH))
      textblock_append(tb, " is found ");
    else
      textblock_append(tb, " is normally found ");
    if (race == lookup_monster("Carcharoth")) {
      textblock_append_c(tb, COLOUR_YELLOW, "guarding the gates of Angband");
    } else if (race->level < z_info->dun_depth) {
      textblock_append(tb, "at depths of ");
      textblock_append_c(tb, COLOUR_YELLOW, "%d", race->level * 50);
      textblock_append(tb, " feet");
    } else {
      textblock_append(tb, "at depths of ");
      textblock_append_c(tb, COLOUR_YELLOW, "%d", z_info->dun_depth * 50);
      textblock_append(tb, " feet");
    }
  }
  textblock_append(tb, ", and");
  if (rf_has(known_flags, RF_NEVER_MOVE)) {
    textblock_append(tb, " cannot move");
  } else if (rf_has(known_flags, RF_HIDDEN_MOVE)) {
    textblock_append(tb, " never moves when you are looking");
  } else {
    textblock_append(tb, " moves");
  }
  if (flags_test(known_flags, RF_SIZE, RF_RAND_50, RF_RAND_25, FLAG_END)) {
    if (rf_has(known_flags, RF_RAND_50) && rf_has(known_flags, RF_RAND_25))
      textblock_append(tb, " extremely");
    else if (rf_has(known_flags, RF_RAND_50))
      textblock_append(tb, " somewhat");
    else if (rf_has(known_flags, RF_RAND_25))
      textblock_append(tb, " a bit");
    textblock_append(tb, " erratically");
    if (race->speed != 2) textblock_append(tb, ", and");
  }
  textblock_append(tb, " ");
  lore_adjective_speed(tb, race);
  textblock_append(tb, ".  ");
  if (rf_has(known_flags, RF_TERRITORIAL)) {
    monster_sex_t msex = lore_monster_sex(race);
    const char* initial_pronoun = lore_pronoun_nominative(msex, true);
    textblock_append(tb, "%s does not deign to pursue you.  ", initial_pronoun);
  }
}
STATIC_OVL void
lore_append_toughness(textblock* tb, const struct monster_race* race,
                      const struct monster_lore* lore,
                      bitflag known_flags[RF_SIZE])
{
  monster_sex_t msex = MON_SEX_NEUTER;
  assert(tb && race && lore);
  msex = lore_monster_sex(race);
  if (lore->armour_known) {
    textblock_append(tb, "%s has ", lore_pronoun_nominative(msex, true));
    if (rf_has(known_flags, RF_UNIQUE)) {
      textblock_append_c(tb, COLOUR_GREEN, "%d ",
                         race->hdice * (1 + race->hside) / 2);
    } else {
      textblock_append_c(tb, COLOUR_GREEN, "%dd%d ", race->hdice, race->hside);
    }
    textblock_append(tb, "health");
    textblock_append(tb, ", and a defence of ");
    if ((race->pd > 0) && (race->ps > 0)) {
      textblock_append_c(tb, COLOUR_SLATE, "[%+d, %dd%d]", race->evn, race->pd,
                         race->ps);
    } else {
      textblock_append_c(tb, COLOUR_SLATE, "[%+d]", race->evn);
    }
    textblock_append(tb, ".  ");
  }
}
STATIC_OVL void
lore_append_exp(textblock* tb, const struct monster_race* race,
                const struct monster_lore* lore, bitflag known_flags[RF_SIZE])
{
  long exp;
  monster_sex_t msex = MON_SEX_NEUTER;
  assert(tb && race && lore);
  if (!race->rarity) return;
  if (!lore->tkills && !lore->tsights) return;
  msex = lore_monster_sex(race);
  if (lore->psights) {
    if (rf_has(known_flags, RF_UNIQUE)) {
      textblock_append(tb, "Encountering %s was worth",
                       lore_pronoun_accusative(msex, false));
    } else {
      textblock_append(tb, "Encountering another would be worth");
    }
  } else {
    if (rf_has(known_flags, RF_UNIQUE)) {
      textblock_append(tb, "Encountering %s would be worth",
                       lore_pronoun_accusative(msex, false));
    } else {
      textblock_append(tb, "Encountering one would be worth");
    }
  }
  exp = adjusted_mon_exp(race, false);
  textblock_append(tb, " %ld experience.  ", (long)exp);
  if (lore->pkills) {
    if (rf_has(known_flags, RF_UNIQUE)) {
      textblock_append(tb, "Killing %s was worth",
                       lore_pronoun_accusative(msex, false));
    } else {
      textblock_append(tb, "Killing another would be worth");
    }
  } else {
    if (rf_has(known_flags, RF_UNIQUE)) {
      textblock_append(tb, "Killing %s would be worth",
                       lore_pronoun_accusative(msex, false));
    } else {
      textblock_append(tb, "Killing one would be worth");
    }
  }
  exp = adjusted_mon_exp(race, true);
  textblock_append(tb, " %ld.  ", (long)exp);
}
STATIC_OVL void
lore_append_drop(textblock* tb, const struct monster_race* race,
                 const struct monster_lore* lore, bitflag known_flags[RF_SIZE])
{
  int n = 0;
  monster_sex_t msex = MON_SEX_NEUTER;
  assert(tb && race && lore);
  if (!lore->drop_known) return;
  msex = lore_monster_sex(race);
  n = mon_create_drop_count(race, true);
  if (n > 0) {
    if (rf_has(race->flags, RF_TERRITORIAL)) {
      textblock_append(tb, "%s may be found with",
                       lore_pronoun_nominative(msex, true));
    } else {
      textblock_append(tb, "%s may carry", lore_pronoun_nominative(msex, true));
    }
    if (n == 1) {
      if (rf_has(known_flags, RF_DROP_GOOD) &&
          !rf_has(known_flags, RF_DROP_GREAT)) {
        textblock_append(tb, " a ");
      } else {
        textblock_append(tb, " an ");
      }
    } else if (n == 2) {
      textblock_append(tb, " one or two ");
    } else {
      textblock_append(tb, " up to %d ", n);
    }
    if (rf_has(known_flags, RF_DROP_GREAT)) {
      textblock_append_c(tb, COLOUR_BLUE, "exceptional ");
    } else if (rf_has(known_flags, RF_DROP_GOOD)) {
      textblock_append_c(tb, COLOUR_BLUE, "good ");
    }
    textblock_append(tb, "object%s.  ", PLURAL(n));
  }
}
STATIC_OVL void
lore_append_abilities(textblock* tb, const struct monster_race* race,
                      const struct monster_lore* lore,
                      bitflag known_flags[RF_SIZE])
{
  int flag;
  char start[40];
  const char* initial_pronoun;
  bitflag current_flags[RF_SIZE];
  monster_sex_t msex = MON_SEX_NEUTER;
  assert(tb && race && lore);
  msex = lore_monster_sex(race);
  initial_pronoun = lore_pronoun_nominative(msex, true);
  create_mon_flag_mask(current_flags, RFT_ABIL, RFT_ABIL_OBV, RFT_MAX);
  rf_inter(current_flags, known_flags);
  strnfmt(start, sizeof(start), "%s has the abilities: ", initial_pronoun);
  lore_append_clause(tb, current_flags, COLOUR_RED, start, "and", ".  ");
  if (race->light > 0) {
    if (streq(race->base->name, "person") || streq(race->base->name, "giant")) {
      textblock_append(tb, "%s can use a light source.  ", initial_pronoun);
    } else {
      textblock_append(tb, "%s radiate light.  ", initial_pronoun);
    }
  } else if (race->light < 0) {
    textblock_append(tb, "%s can produce an unnatural darkness.  ",
                     initial_pronoun);
  }
  create_mon_flag_mask(current_flags, RFT_MOVE, RFT_MAX);
  rf_inter(current_flags, known_flags);
  strnfmt(start, sizeof(start), "%s can ", initial_pronoun);
  lore_append_clause(tb, current_flags, COLOUR_WHITE, start, "and", ".  ");
  create_mon_flag_mask(current_flags, RFT_NOTE, RFT_MAX);
  rf_inter(current_flags, known_flags);
  for (flag = rf_next(current_flags, FLAG_START); flag;
       flag = rf_next(current_flags, flag + 1)) {
    textblock_append(tb, "%s %s.  ", initial_pronoun, describe_race_flag(flag));
  }
  create_mon_flag_mask(current_flags, RFT_MIND, RFT_MAX);
  rf_inter(current_flags, known_flags);
  strnfmt(start, sizeof(start), "%s is ", initial_pronoun);
  lore_append_clause(tb, current_flags, COLOUR_WHITE, start, "and", ".  ");
  create_mon_flag_mask(current_flags, RFT_VULN, RFT_VULN_I, RFT_MAX);
  rf_inter(current_flags, known_flags);
  strnfmt(start, sizeof(start), "%s is vulnerable to ", initial_pronoun);
  lore_append_clause(tb, current_flags, COLOUR_L_BLUE, start, "and", ".  ");
  create_mon_flag_mask(current_flags, RFT_RES, RFT_MAX);
  rf_inter(current_flags, known_flags);
  strnfmt(start, sizeof(start), "%s resists ", initial_pronoun);
  lore_append_clause(tb, current_flags, COLOUR_WHITE, start, "and", ".  ");
  create_mon_flag_mask(current_flags, RFT_PROT, RFT_MAX);
  rf_inter(current_flags, known_flags);
  strnfmt(start, sizeof(start), "%s cannot be ", initial_pronoun);
  lore_append_clause(tb, current_flags, COLOUR_YELLOW, start, "or", ".  ");
  create_mon_flag_mask(current_flags, RFT_GROUP, RFT_MAX);
  rf_inter(current_flags, known_flags);
  for (flag = rf_next(current_flags, FLAG_START); flag;
       flag = rf_next(current_flags, flag + 1)) {
    textblock_append(tb, "%s %s.  ", initial_pronoun, describe_race_flag(flag));
  }
}
STATIC_OVL void
lore_append_skills(textblock* tb, const struct monster_race* race,
                   const struct monster_lore* lore,
                   bitflag known_flags[RF_SIZE])
{
  monster_sex_t msex = MON_SEX_NEUTER;
  assert(tb && race && lore);
  msex = lore_monster_sex(race);
  if (lore->sleep_known) {
    const char* aware = lore_describe_awareness(race->sleep);
    textblock_append(tb, "%s has %d Will,", lore_pronoun_nominative(msex, true),
                     race->wil);
    if (player_active_ability(player, "Listen")) {
      textblock_append(tb, " %d Stealth,", race->stl);
    }
    textblock_append(tb, " %d Perception", race->per);
    if (rf_has(race->flags, RF_MINDLESS)) {
      textblock_append(tb, ".  ");
    } else {
      textblock_append(tb, ", and %s.  ", aware);
    }
  }
}
STATIC_OVL void
lore_append_spells(textblock* tb, const struct monster_race* race,
                   const struct monster_lore* lore,
                   bitflag known_flags[RF_SIZE])
{
  monster_sex_t msex = MON_SEX_NEUTER;
  const char* initial_pronoun;
  bitflag current_flags[RSF_SIZE];
  const struct monster_race* old_ref;
  assert(tb && race && lore);
  old_ref = ref_race;
  ref_race = race;
  msex = lore_monster_sex(race);
  initial_pronoun = lore_pronoun_nominative(msex, true);
  create_mon_spell_mask(current_flags, RST_INNATE, RST_NONE);
  rsf_inter(current_flags, lore->spell_flags);
  if (!rsf_is_empty(current_flags)) {
    textblock_append(tb, "%s may ", initial_pronoun);
    lore_append_spell_clause(tb, current_flags, race, COLOUR_L_RED,
                             COLOUR_UMBER);
  }
  create_mon_spell_mask(current_flags, RST_BREATH, RST_NONE);
  rsf_inter(current_flags, lore->spell_flags);
  if (!rsf_is_empty(current_flags)) {
    textblock_append(tb, "%s may breathe ", initial_pronoun);
    lore_append_spell_clause(tb, current_flags, race, COLOUR_L_RED,
                             COLOUR_WHITE);
  }
  create_mon_spell_mask(current_flags, RST_SPELL, RST_NONE);
  rsf_inter(current_flags, lore->spell_flags);
  if (!rsf_is_empty(current_flags)) {
    textblock_append(tb, "%s may attempt to ", initial_pronoun);
    lore_append_spell_clause(tb, current_flags, race, COLOUR_ORANGE,
                             COLOUR_WHITE);
  }
  ref_race = old_ref;
}
STATIC_OVL void
lore_append_attack(textblock* tb, const struct monster_race* race,
                   const struct monster_lore* lore,
                   bitflag known_flags[RF_SIZE])
{
  int i, known_attacks = 0, described_count = 0;
  monster_sex_t msex = MON_SEX_NEUTER;
  assert(tb && race && lore);
  msex = lore_monster_sex(race);
  for (i = 0; i < z_info->mon_blows_max; i++) {
    if (!race->blow[i].method) continue;
    if (lore->blow_known[i]) known_attacks++;
  }
  if (known_attacks == 0) {
    textblock_append(tb, "Nothing is known about %s attack.  ",
                     lore_pronoun_possessive(msex, false));
    return;
  }
  for (i = 0; i < z_info->mon_blows_max; i++) {
    random_value dice;
    const char* effect_str = NULL;
    if (!race->blow[i].method || !lore->blow_known[i]) continue;
    dice = race->blow[i].dice;
    effect_str = race->blow[i].effect->desc;
    if (described_count == 0)
      textblock_append(tb, "%s can ", lore_pronoun_nominative(msex, true));
    else if (described_count < known_attacks - 1)
      textblock_append(tb, ", ");
    else
      textblock_append(tb, ", or ");
    textblock_append(tb, "%s", race->blow[i].method->desc);
    if (effect_str && strlen(effect_str) > 0) {
      textblock_append(tb, " to ");
      textblock_append_c(tb, COLOUR_L_RED, "%s", effect_str);
      textblock_append(tb, " (");
      if (dice.base || (dice.dice && dice.sides)) {
        textblock_append_c(tb, COLOUR_L_WHITE, "%+d", dice.base);
        if (dice.dice && dice.sides) {
          textblock_append(tb, ", %dd%d", dice.dice, dice.sides);
        }
        textblock_append(tb, ")");
      }
    }
    described_count++;
  }
  assert(described_count == known_attacks);
  textblock_append(tb, ".  ");
}
STATIC_OVL struct monster_lore*
get_lore(const struct monster_race* race)
{
  assert(race);
  return &l_list[race->ridx];
}
STATIC_OVL void
write_lore_entries(ang_file* fff)
{
  int i, n;
  for (i = 0; i < z_info->r_max; i++) {
    struct monster_race* race = &r_info[i];
    struct monster_lore* lore = &l_list[i];
    if (!race->name) continue;
    if (!lore->tsights && !lore->all_known) continue;
    file_putf(fff, "name:%s\n", race->name);
    if (lore->all_known) file_putf(fff, "base:%s\n", race->base->name);
    file_putf(fff, "counts:%d:%d:%d:%d:%d:%d\n", lore->tsights, lore->deaths,
              lore->tkills, lore->notice, lore->ignore, lore->ranged);
    for (n = 0; n < z_info->mon_blows_max; n++) {
      if (!lore->blow_known[n] && !lore->all_known) continue;
      if (!lore->blows[n].method) continue;
      file_putf(fff, "blow:%s", lore->blows[n].method->name);
      file_putf(fff, ":%s", lore->blows[n].effect->name);
      file_putf(fff, ":%d+%dd%dM%d", lore->blows[n].dice.base,
                lore->blows[n].dice.dice, lore->blows[n].dice.sides,
                lore->blows[n].dice.m_bonus);
      file_putf(fff, ":%d", lore->blows[n].times_seen);
      file_putf(fff, ":%d", n);
      file_putf(fff, "\n");
    }
    write_flags(fff, "flags:", lore->flags, RF_SIZE, r_info_flags);
    rsf_inter(lore->spell_flags, race->spell_flags);
    write_flags(fff, "spells:", lore->spell_flags, RSF_SIZE,
                r_info_spell_flags);
    if (lore->drops) {
      struct monster_drop* drop = lore->drops;
      char name[120] = "";
      while (drop) {
        struct object_kind* kind = drop->kind;
        if (kind) {
          object_short_name(name, sizeof name, kind->name);
          file_putf(fff, "drop:%s:%s:%d:%d:%d\n", tval_find_name(kind->tval),
                    name, drop->percent_chance, drop->dice.dice,
                    drop->dice.sides);
        } else {
          assert(drop->art);
          file_putf(fff, "drop-artifact:%s\n", drop->art->name);
        }
        drop = drop->next;
      }
    }
    file_putf(fff, "\n");
  }
}
STATIC_OVL bool
lore_save(const char* name)
{
  char path[1024];
  path_build(path, sizeof(path), ANGBAND_DIR_USER, name);
  if (text_lines_to_file(path, write_lore_entries)) {
    msg("Failed to create file %s.new", path);
    return false;
  }
  return true;
}
STATIC_OVL void
init_race_allocs(void)
{
  int i;
  struct monster_race* race;
  struct alloc_entry* table;
  int16_t* num = mem_zalloc(z_info->max_depth * sizeof(int16_t));
  int16_t* already_counted = mem_zalloc(z_info->max_depth * sizeof(int16_t));
  alloc_race_size = 0;
  for (i = 1; i < z_info->r_max - 1; i++) {
    race = &r_info[i];
    if (race->rarity) {
      alloc_race_size++;
      num[race->level]++;
    }
  }
  for (i = 1; i < z_info->max_depth; i++) {
    num[i] += num[i - 1];
  }
  alloc_race_table = mem_zalloc(alloc_race_size * sizeof(struct alloc_entry));
  table = alloc_race_table;
  for (i = 1; i < z_info->r_max - 1; i++) {
    race = &r_info[i];
    if (race->rarity) {
      int p, lev, prev_lev_count, race_index;
      lev = race->level;
      p = (100 / race->rarity);
      prev_lev_count = (lev > 0) ? num[lev - 1] : 0;
      race_index = prev_lev_count + already_counted[lev];
      table[race_index].index = i;
      table[race_index].level = lev;
      table[race_index].prob1 = p;
      table[race_index].prob2 = p;
      table[race_index].prob3 = p;
      already_counted[lev]++;
    }
  }
  mem_free(already_counted);
  mem_free(num);
}
STATIC_OVL void
cleanup_race_allocs(void)
{
  mem_free(alloc_race_table);
}
STATIC_OVL void
get_mon_num_prep(bool (*get_mon_num_hook)(struct monster_race* race))
{
  int i;
  for (i = 0; i < alloc_race_size; i++) {
    struct alloc_entry* entry = &alloc_race_table[i];
    if (!get_mon_num_hook || (*get_mon_num_hook)(&r_info[entry->index])) {
      entry->prob2 = entry->prob1;
    } else {
      entry->prob2 = 0;
    }
  }
}
STATIC_OVL struct monster_race*
get_mon_race_aux(long total, const struct alloc_entry* table)
{
  int i;
  long value = randint0(total);
  for (i = 0; i < alloc_race_size; i++) {
    if (value < table[i].prob3) break;
    value -= table[i].prob3;
  }
  return &r_info[table[i].index];
}
STATIC_OVL struct monster_race*
get_mon_num(int level, bool special, bool allow_non_smart, bool vault)
{
  int i;
  long total = 0L;
  struct monster_race* race;
  struct alloc_entry* table = alloc_race_table;
  bool pursuing_monster = false;
  bool allow_24 = (level == z_info->dun_depth + 4);
  int generation_level = level;
  if (!special) {
    generation_level += player->state.flags[OF_DANGER];
    if (!vault) {
      if (player->on_the_run && (one_in_(2) || !allow_non_smart)) {
        pursuing_monster = true;
        generation_level = rand_range(17, 23);
      }
      if (level == 0) {
        pursuing_monster = true;
        generation_level = rand_range(17, 23);
      }
      if (pursuing_monster) {
      } else if (level == player->depth) {
        generation_level += damroll(2, 2) - damroll(2, 2);
      } else {
        generation_level += damroll(1, 2) - damroll(1, 2);
      }
    }
  }
  if (generation_level < 1) generation_level = 1;
  if (allow_24) {
    generation_level = MIN(generation_level, z_info->dun_depth + 4);
  } else {
    generation_level = MIN(generation_level, z_info->dun_depth + 3);
  }
  for (i = 0; i < alloc_race_size; i++) {
    if (table[i].level > generation_level) break;
    table[i].prob3 = 0;
    race = &r_info[table[i].index];
    if (!special && (table[i].level < generation_level)) continue;
    if (special && (table[i].level <= generation_level / 2)) continue;
    if (rf_has(race->flags, RF_UNIQUE) && (race->cur_num >= race->max_num))
      continue;
    if (rf_has(race->flags, RF_FORCE_DEPTH) && race->level > player->depth)
      continue;
    if (rf_has(race->flags, RF_NEVER_MOVE) && pursuing_monster) continue;
    if (rf_has(race->flags, RF_TERRITORIAL) && pursuing_monster) continue;
    if (!allow_non_smart && !rf_has(race->flags, RF_SMART) &&
        !rf_has(race->flags, RF_TERRITORIAL))
      continue;
    table[i].prob3 = table[i].prob2;
    total += table[i].prob3;
  }
  if (total <= 0) return NULL;
  race = get_mon_race_aux(total, table);
  return race;
}
STATIC_OVL void
delete_monster_idx(struct chunk* c, int m_idx)
{
  struct monster* mon = cave_monster(c, m_idx);
  struct loc grid;
  assert(m_idx > 0);
  assert(square_in_bounds(c, mon->grid));
  grid = mon->grid;
  mon->race->cur_num--;
  if (mon->race->light != 0)
    player->upkeep->update |= PU_UPDATE_VIEW | PU_MONSTERS;
  if (target_get_monster() == mon) target_set_monster(NULL);
  if (player->upkeep->health_who == mon) health_track(player->upkeep, NULL);
  square_set_mon(c, grid, 0);
  monster_remove_from_group(c, mon);
  struct object* obj = mon->held_obj;
  while (obj && (c == cave)) {
    struct object* next = obj->next;
    if (obj->known) {
      if (loc_is_zero(obj->known->grid) && (c == cave)) {
        delist_object(player->cave, obj->known);
        object_delete(player->cave, NULL, &obj->known);
      }
    }
    delist_object(c, obj);
    if (c == cave) {
      object_delete(cave, player->cave, &obj);
    }
    obj = next;
  }
  flow_free(c, &mon->flow);
  memset(mon, 0, sizeof(struct monster));
  c->mon_cnt--;
  square_light_spot(c, grid);
}
STATIC_OVL void
delete_monster(struct chunk* c, struct loc grid)
{
  assert(square_in_bounds(c, grid));
  if (square(c, grid)->mon > 0) {
    delete_monster_idx(c, square(c, grid)->mon);
  }
}
STATIC_OVL void
monster_index_move(int i1, int i2)
{
  struct monster* mon;
  struct object* obj;
  if (i1 == i2) return;
  mon = cave_monster(cave, i1);
  if (!mon) return;
  square_set_mon(cave, mon->grid, i2);
  mon->midx = i2;
  if (!monster_group_change_index(cave, i2, i1)) {
    quit("Bad monster group info!");
    monster_groups_verify(cave);
  }
  for (obj = mon->held_obj; obj; obj = obj->next) obj->held_m_idx = i2;
  if (target_get_monster() == mon) target_set_monster(cave_monster(cave, i2));
  if (player->upkeep->health_who == mon)
    player->upkeep->health_who = cave_monster(cave, i2);
  memcpy(cave_monster(cave, i2), cave_monster(cave, i1),
         sizeof(struct monster));
  memset(cave_monster(cave, i1), 0, sizeof(struct monster));
}
STATIC_OVL void
compact_monsters(struct chunk* c, int num_to_compact)
{
  int m_idx, num_compacted, iter;
  int max_lev, min_dis, chance;
  if (num_to_compact) msg("Compacting monsters...");
  for (num_compacted = 0, iter = 1; num_compacted < num_to_compact; iter++) {
    max_lev = 5 * iter;
    min_dis = 5 * (20 - iter);
    for (m_idx = 1; m_idx < cave_monster_max(c); m_idx++) {
      struct monster* mon = cave_monster(c, m_idx);
      if (!mon->race) continue;
      if (mon->race->level > max_lev) continue;
      if ((min_dis > 0) && (mon->cdis < min_dis)) continue;
      chance = 90;
      if (rf_has(mon->race->flags, RF_QUESTOR) && (iter < 1000)) chance = 100;
      if (rf_has(mon->race->flags, RF_UNIQUE)) chance = 99;
      if (randint0(100) < chance) continue;
      delete_monster(c, mon->grid);
      num_compacted++;
    }
  }
  for (m_idx = cave_monster_max(c) - 1; m_idx >= 1; m_idx--) {
    struct monster* mon = cave_monster(c, m_idx);
    if (mon->race) continue;
    monster_index_move(cave_monster_max(c) - 1, m_idx);
    c->mon_max--;
  }
}
STATIC_OVL void
wipe_mon_list(struct chunk* c, struct player* p)
{
  int m_idx, i;
  for (m_idx = cave_monster_max(c) - 1; m_idx >= 1; m_idx--) {
    struct monster* mon = cave_monster(c, m_idx);
    struct object* held_obj = mon ? mon->held_obj : NULL;
    if (!mon->race) continue;
    if (held_obj) {
      struct object* obj = held_obj;
      while (obj) {
        if (obj->oidx) {
          c->objects[obj->oidx] = NULL;
        }
        obj = obj->next;
      }
      object_pile_free(c, (p && c == cave) ? p->cave : NULL, held_obj);
    }
    mon->race->cur_num--;
    square_set_mon(c, mon->grid, 0);
    flow_free(c, &mon->flow);
    memset(mon, 0, sizeof(struct monster));
  }
  for (i = 1; i < z_info->level_monster_max; i++) {
    if (c->monster_groups[i]) {
      monster_group_free(c, c->monster_groups[i]);
    }
  }
  c->mon_max = 1;
  c->mon_cnt = 0;
  target_set_monster(0);
  health_track(p->upkeep, 0);
}
STATIC_OVL int16_t
mon_pop(struct chunk* c)
{
  int m_idx;
  if (cave_monster_max(c) < z_info->level_monster_max) {
    m_idx = cave_monster_max(c);
    c->mon_max++;
    c->mon_cnt++;
    return m_idx;
  }
  for (m_idx = 1; m_idx < cave_monster_max(c); m_idx++) {
    struct monster* mon = cave_monster(c, m_idx);
    if (!mon->race) {
      c->mon_cnt++;
      return m_idx;
    }
  }
  if (character_dungeon) msg("Too many monsters!");
  return 0;
}
STATIC_OVL void
set_hallucinatory_race(struct monster* mon)
{
  int tries = 1000;
  while (tries) {
    int race_idx = randint0(z_info->r_max);
    struct monster_race* race = &r_info[race_idx];
    if ((race->rarity != 0) && one_in_(race->rarity)) {
      mon->image_race = race;
      return;
    }
    tries--;
  }
  mon->image_race = mon->race;
}
STATIC_OVL void
new_wandering_destination(struct chunk* c, struct monster* mon)
{
  struct monster_race* race = mon->race;
  if (rf_has(race->flags, RF_NEVER_MOVE) ||
      rf_has(race->flags, RF_HIDDEN_MOVE) ||
      !(rf_has(race->flags, RF_SMART) ||
        rf_has(race->spell_flags, RSF_SHRIEK))) {
    return;
  }
  mon->wandering_dist = z_info->wander_range;
  monster_group_new_wandering_flow(c, mon, loc(0, 0));
}
STATIC_OVL int16_t
place_monster(struct chunk* c, struct loc grid, struct monster* mon,
              uint8_t origin)
{
  int16_t m_idx;
  struct monster* new_mon;
  struct monster_group_info info = mon->group_info;
  bool loading = mon->midx > 0;
  assert(square_in_bounds(c, grid));
  assert(!square_monster(c, grid));
  if (loading) {
    m_idx = mon->midx;
    c->mon_max++;
    c->mon_cnt++;
  } else {
    m_idx = mon_pop(c);
    if (!m_idx) return 0;
  }
  new_mon = cave_monster(c, m_idx);
  memcpy(new_mon, mon, sizeof(struct monster));
  new_mon->midx = m_idx;
  square_set_mon(c, grid, new_mon->midx);
  new_mon->grid = grid;
  assert(square_monster(c, grid) == new_mon);
  mon->origin = origin;
  monster_group_assign(c, new_mon, info, loading);
  new_wandering_destination(c, mon);
  update_mon(new_mon, c, true);
  new_mon->race->cur_num++;
  return m_idx;
}
STATIC_OVL bool
place_new_monster_one(struct chunk* c, struct loc grid,
                      struct monster_race* race, bool sleep, bool ignore_depth,
                      struct monster_group_info group_info, uint8_t origin)
{
  struct monster *mon, *leader;
  struct monster monster_body;
  int index = group_info.index;
  struct monster_group* group;
  assert(square_in_bounds(c, grid));
  assert(race && race->name);
  if (square_monster(c, grid)) return false;
  if (loc_eq(player->grid, grid)) return false;
  if (!square_is_monster_walkable(c, grid)) return false;
  if (square_iswarded(c, grid)) return false;
  if (rf_has(race->flags, RF_UNIQUE) && (race->cur_num >= race->max_num))
    return false;
  if (!ignore_depth) {
    if (rf_has(race->flags, RF_FORCE_DEPTH) && c->depth < race->level)
      return false;
    if (rf_has(race->flags, RF_SPECIAL_GEN)) return false;
  }
  if (OPT(player, cheat_hear)) {
    if (race->level > c->depth) {
      if (rf_has(race->flags, RF_UNIQUE)) {
        msg("Deep unique (%s).", race->name);
      } else {
        msg("Deep monster (%s).", race->name);
      }
    } else if (rf_has(race->flags, RF_UNIQUE)) {
      msg("Unique (%s).", race->name);
    }
  }
  mon = &monster_body;
  memset(mon, 0, sizeof(struct monster));
  mon->race = race;
  group = monster_group_by_index(c, index);
  if (group) {
    leader = cave_monster(c, group->leader);
  } else {
    leader = NULL;
  }
  if (race == lookup_monster("Morgoth, Lord of Darkness")) {
    mon->image_race = lookup_monster("Melkor, Rightful Lord of Arda");
  } else if (leader) {
    mon->image_race = leader->image_race;
  } else {
    set_hallucinatory_race(mon);
  }
  if (sleep) {
    int amount = 0;
    if (race->sleep) {
      amount = randint1(race->sleep);
    }
    if (leader) {
      amount = ALERTNESS_ALERT - leader->alertness;
    } else if (player->on_the_run) {
      if ((player->depth == 0) && (amount > 0)) {
        amount = damroll(1, 3);
      } else if ((race->level > player->depth + 2) &&
                 !square_isvault(c, grid) && (amount > 0)) {
        amount = damroll(1, 3);
      }
    }
    mon->alertness = ALERTNESS_ALERT - amount;
  }
  if (rf_has(race->flags, RF_UNIQUE)) {
    mon->maxhp = race->hdice * (1 + race->hside) / 2;
  } else {
    mon->maxhp = damroll(race->hdice, race->hside);
  }
  mon->mana = z_info->mana_max;
  mon->song = NULL;
  mon->hp = mon->maxhp;
  calc_monster_speed(mon);
  mon->min_range = 0;
  flow_new(c, &mon->flow);
  mon->energy = (uint8_t)randint0(10);
  if (mon->race->light != 0)
    player->upkeep->update |= PU_UPDATE_VIEW | PU_MONSTERS;
  mon->group_info.index = index ? index : monster_group_index_new(c);
  mon->group_info.role = group_info.role;
  if (!place_monster(c, grid, mon, origin)) return (false);
  if (rf_has(mon->race->flags, RF_TERRITORIAL)) {
    drop_loot(c, mon, grid, false);
  }
  return (true);
}
STATIC_OVL bool
place_escort_okay(struct monster_race* race)
{
  if (race->base != place_escort_race->base) return false;
  if (race->level > place_escort_race->level) return false;
  if (rf_has(race->flags, RF_UNIQUE)) return false;
  if (place_escort_race == race) return false;
  return true;
}
STATIC_OVL void
place_monster_unique_friend(struct chunk* c, struct loc grid,
                            struct monster_race* race, bool sleep,
                            struct monster_group_info group_info,
                            uint8_t origin)
{
  int i, r;
  for (r = 1; r < z_info->r_max; r++) {
    struct monster_race* race1 = &r_info[r];
    if ((race->base == race1->base) && rf_has(race1->flags, RF_UNIQUE_FRIEND)) {
      int start = randint0(8);
      for (i = start; i < 8 + start; i++) {
        struct loc try = loc_sum(grid, ddgrid_ddd[i % 8]);
        if (place_new_monster_one(c, try, race1, sleep, true, group_info,
                                  origin)) {
          break;
        }
      }
    }
  }
}
STATIC_OVL bool
place_new_monster_group(struct chunk* c, struct loc grid,
                        struct monster_race* race, bool sleep,
                        struct monster_group_info group_info, int total,
                        uint8_t origin)
{
  int n, i;
  int loc_num;
  struct loc* loc_list =
      mem_zalloc(sizeof(struct loc) * z_info->monster_group_max);
  assert(race);
  total = MIN(total, z_info->monster_group_max);
  loc_num = 1;
  loc_list[0] = grid;
  for (n = 0; (n < loc_num) && (loc_num < total); n++) {
    int start = randint0(8);
    for (i = start; (i < 8) && (loc_num < total); i++) {
      struct loc try = loc_sum(loc_list[n], ddgrid_ddd[i % 8]);
      if (!square_isempty(c, try)) continue;
      if (place_new_monster_one(c, try, race, sleep, false, group_info,
                                origin)) {
        loc_list[loc_num] = try;
        loc_num++;
      }
    }
  }
  mem_free(loc_list);
  return (loc_num > 1);
}
STATIC_OVL void
place_monster_escort(struct chunk* c, struct loc grid,
                     struct monster_race* race, bool sleep,
                     struct monster_group_info group_info, uint8_t origin)
{
  int n, i;
  int loc_num;
  int escort_size;
  int extras = 0;
  struct loc* loc_list =
      mem_zalloc(sizeof(struct loc) * z_info->monster_group_max);
  struct monster_race** escort_races =
      mem_zalloc(sizeof(struct monster_race*) * z_info->monster_group_max);
  struct monster_race* escort_race;
  assert(race);
  if (rf_has(race->flags, RF_ESCORTS)) {
    escort_size = rand_range(8, 16);
  } else {
    escort_size = rand_range(4, 7);
  }
  escort_size = MIN(escort_size, z_info->monster_group_max);
  place_escort_race = race;
  get_mon_num_prep(place_escort_okay);
  for (i = 0; i < escort_size; i++) {
    if (extras > 0) {
      escort_races[i] = escort_races[i - 1];
      extras--;
    } else {
      escort_races[i] = get_mon_num(race->level, true, false, false);
      if (escort_races[i] == NULL) continue;
      if (rf_has(escort_races[i]->flags, RF_FRIENDS)) {
        extras = rand_range(2, 3);
      } else if (rf_has(escort_races[i]->flags, RF_FRIEND)) {
        extras = rand_range(1, 2);
      } else {
        extras = 0;
      }
    }
  }
  escort_race = escort_races[0];
  loc_num = 1;
  loc_list[0] = grid;
  for (n = 0; (n < loc_num) && (loc_num < escort_size); n++) {
    int start = randint0(8);
    for (i = start; (i < 8) && (loc_num < escort_size); i++) {
      struct loc try = loc_sum(loc_list[n], ddgrid_ddd[i % 8]);
      if (!square_isempty(c, try)) continue;
      if (place_new_monster_one(c, try, escort_race, sleep, false, group_info,
                                origin)) {
        escort_race = escort_races[loc_num];
        loc_list[loc_num] = try;
        loc_num++;
      }
    }
  }
  get_mon_num_prep(NULL);
  mem_free(loc_list);
  mem_free(escort_races);
}
STATIC_OVL bool
place_new_monster(struct chunk* c, struct loc grid, struct monster_race* race,
                  bool sleep, bool group_ok,
                  struct monster_group_info group_info, uint8_t origin)
{
  assert(c);
  assert(race);
  if (!group_info.index) {
    group_info.index = monster_group_index_new(c);
  }
  if (!place_new_monster_one(c, grid, race, sleep, false, group_info, origin)) {
    return (false);
  }
  if (!group_ok) return (true);
  if (rf_has(race->flags, RF_UNIQUE_FRIEND)) {
    place_monster_unique_friend(c, grid, race, sleep, group_info, origin);
  } else if (rf_has(race->flags, RF_FRIENDS)) {
    int amount = (rand_range(6, 7) + (c->depth - race->level)) / 2;
    amount = MIN(MAX(amount, 2), 4);
    group_info.role = MON_GROUP_MEMBER;
    return place_new_monster_group(c, grid, race, sleep, group_info, amount,
                                   origin);
  } else if (rf_has(race->flags, RF_FRIEND)) {
    int amount = 1;
    if (randint1(4) <= c->depth - race->level + 2) amount++;
    group_info.role = MON_GROUP_MEMBER;
    return place_new_monster_group(c, grid, race, sleep, group_info, amount,
                                   origin);
  } else if (rf_has(race->flags, RF_ESCORT) ||
             rf_has(race->flags, RF_ESCORTS)) {
    group_info.role = MON_GROUP_SERVANT;
    place_monster_escort(c, grid, race, sleep, group_info, origin);
  }
  return true;
}
STATIC_OVL bool
pick_and_place_monster(struct chunk* c, struct loc grid, int depth, bool sleep,
                       bool group_okay, uint8_t origin)
{
  struct monster_race* race =
      get_mon_num(depth, false, sleep, origin == ORIGIN_DROP_VAULT);
  struct monster_group_info info = {0, 0};
  if (race) {
    return place_new_monster(c, grid, race, sleep, group_okay, info, origin);
  } else {
    return false;
  }
}
STATIC_OVL void
place_monster_by_flag(struct chunk* c, struct loc grid, int flg1, int flg2,
                      bool allow_unique, int max_depth, bool spell)
{
  bool got_race = false;
  int tries = 0;
  struct monster_race* race = NULL;
  int depth = max_depth;
  struct monster_group_info info = {0, 0};
  while (!got_race && (depth > 0)) {
    race = get_mon_num(depth, false, true, true);
    if (race && (allow_unique || !rf_has(race->flags, RF_UNIQUE))) {
      if (rf_has(race->flags, flg1)) {
        got_race = true;
        break;
      } else if ((flg2 > 0) && rf_has(race->flags, flg2)) {
        got_race = true;
        break;
      }
    }
    tries++;
    if (tries >= 100) {
      tries = 0;
      depth--;
    }
  }
  if (got_race) {
    place_new_monster_one(c, grid, race, true, false, info, ORIGIN_DROP_VAULT);
  }
}
STATIC_OVL void
place_monster_by_letter(struct chunk* c, struct loc grid, char ch,
                        bool allow_unique, int max_depth)
{
  bool got_race = false;
  int tries = 0;
  struct monster_race* race = NULL;
  int depth = max_depth;
  char stmp[2] = {'\0', '\0'};
  wchar_t wtmp[2];
  struct monster_group_info info = {0, 0};
  stmp[0] = ch;
  if (text_mbstowcs(wtmp, stmp, N_ELEMENTS(wtmp)) != 1) {
    return;
  }
  while (!got_race && (depth > 0)) {
    race = get_mon_num(depth, false, true, true);
    if (race->d_char == wtmp[0] &&
        (allow_unique || !rf_has(race->flags, RF_UNIQUE))) {
      got_race = true;
      break;
    }
    tries++;
    if (tries >= 100) {
      tries = 0;
      depth--;
    }
  }
  if (got_race) {
    place_new_monster_one(c, grid, race, true, false, info, ORIGIN_DROP_VAULT);
  }
}
STATIC_OVL bool
pick_and_place_monster_on_stairs(struct chunk* c, struct player* p, bool sleep,
                                 int depth, bool force_undead)
{
  struct loc stair, grid;
  struct monster* mon;
  bool displaced = false;
  bool placed = false;
  char dir[5];
  int tries = 0;
  if (in_tutorial() || p->game_type > 0) return false;
  if (!cave_find(c, &stair, square_isstairs)) return false;
  grid = stair;
  mon = square_monster(c, stair);
  if (mon || loc_eq(p->grid, stair)) {
    int d, start;
    if (mon && (rf_has(mon->race->flags, RF_NEVER_MOVE) ||
                rf_has(mon->race->flags, RF_HIDDEN_MOVE))) {
      return false;
    }
    start = randint0(8);
    for (d = start; d < 8 + start; d++) {
      struct loc grid1 = loc_sum(grid, ddgrid_ddd[d % 8]);
      if (!square_in_bounds(c, grid1)) continue;
      if (!(square_isempty(c, grid1) || square_isplayer(c, grid1))) {
        continue;
      }
      grid = grid1;
      displaced = true;
      break;
    }
    if (!displaced) return false;
  }
  if (displaced) {
    monster_swap(stair, grid);
    if (loc_eq(p->grid, grid)) {
      update_view(c, p);
    }
  }
  while (!placed && (tries < 50)) {
    int monster_level = depth;
    int feat = square_feat(c, stair)->fidx;
    if (feat == FEAT_LESS_SHAFT) {
      monster_level -= 2;
      my_strcpy(dir, "down", sizeof(dir));
    } else if (feat == FEAT_LESS) {
      monster_level -= 1;
      my_strcpy(dir, "down", sizeof(dir));
    } else if (feat == FEAT_MORE) {
      monster_level += 1;
      my_strcpy(dir, "up", sizeof(dir));
    } else if (feat == FEAT_MORE_SHAFT) {
      monster_level += 2;
      my_strcpy(dir, "up", sizeof(dir));
    }
    if (monster_level < 1) monster_level = 1;
    if (force_undead) {
      place_monster_by_flag(c, stair, RF_UNDEAD, -1, true,
                            MAX(monster_level + 3, 13), false);
      placed = true;
    } else {
      placed = pick_and_place_monster(c, stair, monster_level, false, true,
                                      ORIGIN_DROP);
    }
    tries++;
  }
  if (placed) {
    struct monster* mon1 = square_monster(c, stair);
    if (monster_is_visible(mon1)) {
      char message[240];
      if (monster_has_friends(mon1)) {
        strnfmt(message, sizeof(message),
                "A group of enemies come %s the stair", dir);
      } else {
        char m_name[80];
        monster_desc(m_name, sizeof(m_name), mon1, MDESC_STANDARD);
        strnfmt(message, sizeof(message), "%s comes %s the stair", m_name, dir);
      }
      if (displaced) {
        char who[80];
        if (loc_eq(p->grid, grid)) {
          my_strcpy(who, "you", 80);
        } else {
          monster_desc(who, sizeof(who), square_monster(c, grid),
                       MDESC_DIED_FROM);
        }
        msg("%s, forcing %s out of the way!", message, who);
      } else {
        msg("%s!", message);
      }
      return true;
    }
  }
  return false;
}
STATIC_OVL bool
pick_and_place_distant_monster(struct chunk* c, struct player* p, bool sleep,
                               int depth)
{
  struct loc grid;
  int attempts_left = 1000;
  assert(c);
  while (--attempts_left) {
    grid = loc(randint0(c->width), randint0(c->height));
    if (!square_isempty(c, grid)) continue;
    if (!los(c, grid, p->grid)) break;
  }
  if (!attempts_left) {
    if (OPT(p, cheat_xtra) || OPT(p, cheat_hear))
      msg("Warning! Could not allocate a new monster.");
    return false;
  }
  if (pick_and_place_monster(c, grid, depth, sleep, true, ORIGIN_DROP))
    return true;
  return false;
}
STATIC_OVL bool
monster_can_smell(struct monster* mon)
{
  int age = get_scent(cave, mon->grid);
  if (age == -1) return false;
  if (streq("wolf", mon->race->base->name)) {
    return true;
  } else if (streq("cat", mon->race->base->name)) {
    if (age <= SMELL_STRENGTH / 2) {
      return true;
    }
  }
  return false;
}
STATIC_OVL bool
monster_talks_to_friends(struct monster* mon)
{
  struct monster_race* race = mon->race;
  return rf_has(race->flags, RF_FRIENDS) || rf_has(race->flags, RF_FRIEND) ||
         rf_has(race->flags, RF_UNIQUE_FRIEND) ||
         rf_has(race->flags, RF_ESCORT) || rf_has(race->flags, RF_ESCORTS) ||
         rsf_has(race->spell_flags, RSF_SHRIEK);
}
STATIC_OVL bool
monster_can_exist(struct chunk* c, struct monster* mon, struct loc grid,
                  bool occupied_ok, bool can_dig)
{
  struct monster_race* race = mon->race;
  if (!square_in_bounds(c, grid)) return false;
  if (square_monster(c, grid) && !occupied_ok) return false;
  if (square_iswarded(c, grid)) return false;
  if (square_ischasm(c, grid)) {
    if (rf_has(race->flags, RF_FLYING)) {
      return true;
    } else {
      return false;
    }
  }
  if (square_ispassable(c, grid)) return true;
  if (square_isperm(c, grid)) return false;
  if (rf_has(race->flags, RF_PASS_WALL)) return true;
  if (rf_has(race->flags, RF_KILL_WALL) && (can_dig)) return true;
  if (rf_has(race->flags, RF_TUNNEL_WALL) && (can_dig)) return true;
  if (square_isdoor(c, grid) && rf_has(race->flags, RF_PASS_DOOR)) return true;
  return false;
}
STATIC_OVL int
success_chance(int sides, int skill, int difficulty)
{
  int i, j;
  int ways = 0;
  for (i = 1; i <= sides; i++)
    for (j = 1; j <= sides; j++)
      if (i + skill > j + difficulty) ways++;
  return ways;
}
STATIC_OVL int
monster_entry_chance(struct chunk* c, struct monster* mon, struct loc grid,
                     bool* bash)
{
  struct monster* mon1 = square_monster(c, grid);
  int move_chance = 100;
  if (!square_in_bounds(c, grid)) return 0;
  if (square_isperm(c, grid)) return 0;
  if (square_isplayer(c, grid)) {
    return 100;
  } else if (mon1) {
    if (!rf_has(mon1->race->flags, RF_NEVER_MOVE) &&
        !rf_has(mon1->race->flags, RF_HIDDEN_MOVE)) {
      if ((mon1->alertness < ALERTNESS_ALERT) &&
          (monster_group_leader(c, mon) != monster_group_leader(c, mon1))) {
        move_chance = 80;
      } else if ((mon1->stance == STANCE_FLEEING) &&
                 (mon->stance != STANCE_FLEEING)) {
        move_chance = 80;
      } else if ((mon1->stance != STANCE_FLEEING) &&
                 (mon->stance == STANCE_FLEEING)) {
        move_chance = 80;
      } else if (mon->race->level > mon1->race->level) {
        move_chance = 80;
      } else if (mon->race->level == mon1->race->level) {
        move_chance = 20;
      } else {
        move_chance = 10;
      }
    } else {
      return 0;
    }
  }
  if (square_iswarded(c, grid)) {
    int chance = success_chance(10, monster_skill(mon, SKILL_WILL), 20);
    if (mon->alertness < ALERTNESS_ALERT) {
      chance = 0;
    }
    move_chance = MIN(move_chance, chance);
  }
  if (square_ischasm(c, grid)) {
    if (!rf_has(mon->race->flags, RF_FLYING)) {
      return 0;
    }
  }
  if (square_ispassable(c, grid)) {
    return move_chance;
  } else {
    if (square_iswall(c, grid) && !square_isdoor(c, grid)) {
      if (rf_has(mon->race->flags, RF_PASS_WALL) ||
          rf_has(mon->race->flags, RF_KILL_WALL)) {
        return move_chance;
      } else if (rf_has(mon->race->flags, RF_TUNNEL_WALL) &&
                 (mon->alertness >= ALERTNESS_ALERT)) {
        return move_chance;
      }
      return 0;
    }
    if (square_isdoor(c, grid)) {
      int unlock_chance = 0;
      int bash_chance = 0;
      if (rf_has(mon->race->flags, RF_PASS_DOOR) ||
          rf_has(mon->race->flags, RF_PASS_WALL)) {
        return move_chance;
      }
      if ((mon->alertness < ALERTNESS_ALERT) && square_isvault(c, grid)) {
        return 0;
      }
      if (square_issecretdoor(c, grid) && square_isvault(c, grid)) {
        return 0;
      }
      if (rf_has(mon->race->flags, RF_OPEN_DOOR) &&
          !square_isjammeddoor(c, grid)) {
        if (!square_islockeddoor(c, grid)) {
          return move_chance;
        } else if (rf_has(mon->race->flags, RF_UNLOCK_DOOR)) {
          int difficulty = square_door_lock_power(c, grid) + 5;
          int skill = monster_skill(mon, SKILL_PERCEPTION);
          unlock_chance = success_chance(10, skill, difficulty);
        }
      }
      if (rf_has(mon->race->flags, RF_BASH_DOOR)) {
        int difficulty = square_islockeddoor(c, grid)
                             ? square_door_lock_power(c, grid)
                             : square_door_jam_power(c, grid);
        int skill = monster_stat(mon, STAT_STR) * 2;
        bash_chance = success_chance(10, skill, difficulty);
      }
      if ((unlock_chance > bash_chance) || (bash_chance == 0)) {
        *bash = false;
      } else {
        *bash = true;
      }
      return MIN(move_chance, MAX(unlock_chance, bash_chance));
    }
    return 0;
  }
}
STATIC_OVL int
adj_mon_count(struct loc grid)
{
  int d, count = 0;
  for (d = 0; d < 8; d++) {
    if (square_monster(cave, loc_sum(grid, ddgrid_ddd[d]))) {
      count++;
    }
  }
  return count;
}
STATIC_OVL int
distance_squared(struct loc grid1, struct loc grid2)
{
  int y_diff = grid1.y - grid2.y;
  int x_diff = grid1.x - grid2.x;
  return y_diff * y_diff + x_diff * x_diff;
}
STATIC_OVL void
monster_find_range(struct monster* mon)
{
  int flee_range = MIN(z_info->max_sight + z_info->flee_range, 255);
  if (mon->stance == STANCE_FLEEING) {
    mon->min_range = flee_range;
  } else {
    mon->min_range = 1;
    if (rf_has(mon->race->flags, RF_NEVER_MOVE)) {
      mon->min_range += 3;
    }
    if (rf_has(mon->race->flags, RF_SMART) &&
        rsf_has(mon->race->spell_flags, RSF_SHRIEK) &&
        (mon->stance != STANCE_AGGRESSIVE)) {
      mon->min_range = 10;
    }
  }
  if ((mon->cdis < z_info->turn_range) && (mon->mspeed < player->state.speed)) {
    mon->min_range = 1;
  }
  mon->best_range = mon->min_range;
  if ((mon->race->freq_ranged > 15) && !rf_has(mon->race->flags, RF_QUESTOR)) {
    if (monster_breathes(mon) && (mon->best_range < 6)) {
      mon->best_range = 2;
    } else if (mon->mana >= z_info->mana_max / 5) {
      mon->best_range =
          MAX(1, MIN(8, mon->best_range + (mon->race->freq_ranged - 15) / 5));
      mon->min_range = MAX(1, mon->best_range - 1);
    }
  }
  if (player->truce && (mon->min_range < 5)) {
    mon->min_range = 5;
    mon->best_range = 5;
  }
}
STATIC_OVL bool
monster_check_active(struct monster* mon)
{
  if (!loc_eq(mon->target.grid, loc(0, 0))) {
    return true;
  } else if (mon->stance == STANCE_FLEEING) {
    return true;
  } else if (rf_has(mon->race->flags, RF_QUESTOR) && player->on_the_run) {
    return true;
  } else if ((mon->race->level > 17) && (player->depth == 0)) {
    return true;
  } else if (rf_has(mon->race->flags, RF_SHORT_SIGHTED)) {
    if (mon->cdis <= 2) return true;
  } else {
    if (los(cave, mon->grid, player->grid)) return true;
    if (flow_dist(cave->player_noise, mon->grid) < 20) return true;
    if (monster_can_smell(mon)) return true;
  }
  return false;
}
STATIC_OVL bool
get_move_wander(struct monster* mon, struct loc* tgrid)
{
  struct loc grid1 = mon->grid, grid;
  struct monster_group* group =
      monster_group_by_index(cave, mon->group_info.index);
  struct monster_race* race = mon->race;
  bool random_move = false;
  bool no_move = false;
  int d;
  int dist;
  int closest = z_info->flow_max - 1;
  if (loc_eq(group->flow.centre, loc(0, 0))) {
    if (rf_has(race->flags, RF_NEVER_MOVE)) {
      return false;
    } else if (rf_has(race->flags, RF_SHORT_SIGHTED) ||
               rf_has(race->flags, RF_HIDDEN_MOVE)) {
      return false;
    } else {
      random_move = true;
    }
  } else {
    int group_size = monster_group_size(cave, mon);
    struct mon_group_list_entry* list_entry = group->member_list;
    int group_furthest = 0;
    int group_sleepers = 0;
    struct loc sleeper_grid = loc(0, 0);
    bitflag mask[RF_SIZE];
    bool hoarder = false;
    dist = flow_dist(group->flow, grid1);
    while (list_entry) {
      struct monster* mon1 = cave_monster(cave, list_entry->midx);
      if (mon1->alertness < ALERTNESS_UNWARY) {
        group_sleepers++;
        if (group_sleepers == 1) {
          sleeper_grid = mon1->grid;
        }
      }
      if (mon1->wandering_dist > group_furthest) {
        group_furthest = mon1->wandering_dist;
      }
      list_entry = list_entry->next;
    }
    if (player->depth == 0) {
      return false;
    }
    if (player->truce) {
      return false;
    }
    create_mon_flag_mask(mask, RFT_DROP, RFT_MAX);
    if (rf_is_inter(mon->race->flags, mask)) {
      hoarder = true;
    }
    if (rf_has(race->flags, RF_TERRITORIAL) && hoarder && (dist == 0)) {
      if (one_in_(100) && !in_tutorial() && !rf_has(race->flags, RF_NO_SLEEP)) {
        set_alertness(mon, rand_range(ALERTNESS_MIN, ALERTNESS_UNWARY - 1));
      }
      return false;
    }
    if (dist > z_info->wander_range) {
      monster_group_new_wandering_flow(cave, mon, loc(0, 0));
    }
    if ((group->wandering_pause == 0) && (dist <= 0)) {
      group->wandering_pause = randint1(50) * group_size;
    } else if (group->wandering_pause > 1) {
      random_move = true;
      group->wandering_pause--;
    } else if (group->wandering_pause == 1) {
      monster_group_new_wandering_flow(cave, mon, loc(0, 0));
      group->wandering_pause--;
    }
    if (dist >= mon->wandering_dist) {
      if (one_in_(20 * group_size)) {
        monster_group_new_wandering_flow(cave, mon, loc(0, 0));
      }
    }
    if (dist < group_furthest - group_size) {
      if (one_in_(2)) no_move = true;
    }
    if ((mon->alertness < ALERTNESS_ALERT) && (group_sleepers > 0)) {
      if (!loc_eq(group->flow.centre, sleeper_grid)) {
        monster_group_new_wandering_flow(cave, mon, sleeper_grid);
      }
      if (one_in_(2)) random_move = true;
    }
    if (!rf_has(race->flags, RF_TERRITORIAL) &&
        square_isvault(cave, mon->grid)) {
      random_move = true;
    }
    group->dist = dist;
  }
  if (no_move) return false;
  if (random_move) {
    if (!one_in_(4)) {
      return false;
    } else {
      grid = loc_sum(grid1, ddgrid_ddd[randint0(8)]);
      if (!square_in_bounds(cave, grid)) return false;
      if (square_isvault(cave, mon->grid) && !square_isvault(cave, grid))
        return false;
      *tgrid = grid;
    }
  } else {
    if (rf_has(race->flags, RF_SMART) && !rf_has(race->flags, RF_TERRITORIAL) &&
        (player->depth != z_info->dun_depth) &&
        square_isstairs(cave, mon->grid) && (mon->wandering_dist == 0)) {
      if (monster_is_visible(mon)) {
        if (square_isdownstairs(cave, mon->grid)) {
          add_monster_message(mon, MON_MSG_GO_DOWN_STAIRS, true);
        } else {
          add_monster_message(mon, MON_MSG_GO_UP_STAIRS, true);
        }
      }
      group->wandering_pause = 0;
      delete_monster(cave, mon->grid);
      return false;
    }
    for (d = 7; d >= 0; d--) {
      grid = loc_sum(grid1, ddgrid_ddd[d]);
      if (!square_in_bounds(cave, grid)) continue;
      dist = flow_dist(group->flow, grid);
      if (closest < dist) continue;
      closest = dist;
      *tgrid = grid;
    }
    if (closest == z_info->flow_max - 1) {
      return false;
    }
  }
  return true;
}
STATIC_OVL bool
get_move_find_safety(struct monster* mon, struct loc* tgrid)
{
  int i, j, d, x, y;
  int range = z_info->hide_range;
  int countdown = range;
  int least_cost = 100;
  struct loc least_cost_grid = loc(0, 0);
  int chance, cost, parent_cost;
  bool dummy;
  bool stair;
  struct loc origin = loc_diff(loc(range, range), mon->grid);
  uint8_t** safe_cost;
  safe_cost = mem_zalloc((range * 2 + 1) * sizeof(uint8_t*));
  for (i = 0; i < range * 2 + 1; i++) {
    safe_cost[i] = mem_zalloc((range * 2 + 1) * sizeof(uint8_t));
  }
  safe_cost[range][range] = 1;
  if ((ABS(mon->grid.y - player->grid.y) <= range) &&
      (ABS(mon->grid.x - player->grid.x) <= range)) {
    safe_cost[player->grid.y + origin.y][player->grid.x + origin.x] = 100;
  }
  for (d = 0; d < range; d++) {
    for (y = range - d; y <= range + d; y++) {
      for (x = range - d; x <= range + d; x++) {
        struct loc grid = loc(x, y);
        int x_tmp;
        if ((y != range - d) && (y != range + d)) {
          if (x == range + d) {
            x_tmp = 999;
          } else {
            x_tmp = range + d;
          }
        } else {
          x_tmp = x + 1;
        }
        if (!square_in_bounds_fully(cave, loc_diff(grid, origin))) {
          x = x_tmp;
          continue;
        }
        if ((safe_cost[y][x] == 0) || (safe_cost[y][x] >= 100)) {
          x = x_tmp;
          continue;
        }
        parent_cost = safe_cost[y][x];
        for (i = 0; i < 8; i++) {
          struct loc grid1 = loc_sum(grid, ddgrid_ddd[i]);
          struct loc actual = loc_diff(grid1, origin);
          if ((grid1.y < 0) || (grid1.y > range * 2) || (grid1.x < 0) ||
              (grid1.x > range * 2))
            continue;
          if ((safe_cost[grid1.y][grid1.x] == 0) ||
              ((safe_cost[grid1.y][grid1.x] > parent_cost + 1) &&
               (safe_cost[grid1.y][grid1.x] < 100))) {
            chance = monster_entry_chance(cave, mon, actual, &dummy);
            if (!chance) {
              safe_cost[grid1.y][grid1.x] = 100;
              continue;
            }
            cost = 100 / chance;
            if (distance(actual, player->grid) <= 1) {
              cost += 3;
            }
            safe_cost[grid1.y][grid1.x] = parent_cost + cost;
            stair = square_isstairs(cave, actual) &&
                    rf_has(mon->race->flags, RF_SMART) &&
                    !rf_has(mon->race->flags, RF_TERRITORIAL);
            if (!square_isview(cave, actual) || stair) {
              int this_cost = safe_cost[grid1.y][grid1.x];
              if (ABS(player->grid.y - actual.y) <
                  ABS(mon->grid.y - actual.y)) {
                this_cost *= 2;
              }
              if (ABS(player->grid.x - actual.x) <
                  ABS(mon->grid.x - actual.x)) {
                this_cost *= 2;
              }
              if (stair) {
                this_cost /= 2;
              }
              if ((least_cost > this_cost) ||
                  ((least_cost == this_cost) && one_in_(2))) {
                bool has_escape = false;
                for (j = 0; j < 8; j++) {
                  struct loc grid2 = loc_sum(actual, ddgrid_ddd[i]);
                  if (!square_in_bounds(cave, grid2)) continue;
                  if (!square_isview(cave, grid2) &&
                      monster_entry_chance(cave, mon, grid2, &dummy)) {
                    has_escape = true;
                    break;
                  }
                }
                if ((has_escape == false) && !stair) continue;
                least_cost = this_cost;
                least_cost_grid = grid1;
                countdown = 1 + least_cost - d;
              }
            }
          }
        }
        x = x_tmp;
      }
    }
    if (countdown-- <= 0) break;
  }
  for (i = 0; i < range * 2 + 1; i++) {
    mem_free(safe_cost[i]);
  }
  mem_free(safe_cost);
  if (least_cost < 50) {
    struct loc grid = loc_diff(least_cost_grid, origin);
    *tgrid = grid;
    mon->target.grid = grid;
    return true;
  }
  return false;
}
STATIC_OVL bool
get_move_retreat(struct monster* mon, struct loc* tgrid)
{
  struct monster_race* race = mon->race;
  int i;
  struct loc grid;
  bool dummy;
  if (rf_has(race->spell_flags, RSF_SHRIEK) &&
      (randint0(100) < race->freq_ranged)) {
    do_mon_spell(RSF_SHRIEK, mon, square_isview(cave, mon->grid));
    return false;
  }
  if (mon->cdis >= z_info->flee_range) {
    return false;
  }
  if (rf_has(race->flags, RF_SMART) && !rf_has(race->flags, RF_TERRITORIAL) &&
      (mon->stance == STANCE_FLEEING)) {
    if (square_isstairs(cave, mon->grid)) {
      *tgrid = mon->grid;
      return true;
    }
    for (i = 0; i < 8; i++) {
      grid = loc_sum(mon->grid, ddgrid_ddd[i]);
      if (square_isstairs(cave, grid) &&
          (monster_entry_chance(cave, mon, grid, &dummy) > 0) &&
          !square_isplayer(cave, grid)) {
        *tgrid = grid;
        return true;
      }
    }
  }
  if (race->freq_ranged >= 50) {
    int start = randint0(8);
    bool acceptable = false;
    int best_score = 0;
    struct loc best_grid = mon->grid;
    int dist;
    dist = distance_squared(mon->grid, player->grid);
    best_score += dist;
    if (projectable(cave, mon->grid, player->grid, PROJECT_STOP) &&
        (mon->cdis > 1)) {
      best_score += 100;
    }
    if (mon->cdis > 1) acceptable = true;
    cave->project_path_ignore = mon->grid;
    for (i = start; i < 8 + start; i++) {
      int score = 0;
      grid = loc_sum(mon->grid, ddgrid_ddd[i % 8]);
      dist = distance_squared(grid, player->grid);
      if (!square_in_bounds(cave, grid)) continue;
      if (square_isplayer(cave, grid)) continue;
      if (monster_entry_chance(cave, mon, grid, &dummy) < 50) continue;
      if (distance(grid, player->grid) == 1) continue;
      acceptable = true;
      score += dist;
      if (projectable(cave, grid, player->grid, PROJECT_STOP)) {
        score += 100;
      }
      if (score > best_score) {
        best_score = score;
        best_grid = grid;
      }
    }
    cave->project_path_ignore = loc(0, 0);
    if (acceptable) {
      *tgrid = best_grid;
      return true;
    } else if ((mon->stance != STANCE_FLEEING) &&
               !rf_has(race->flags, RF_UNIQUE) && monster_is_visible(mon)) {
      return false;
    }
  }
  if (!loc_eq(mon->target.grid, loc(0, 0))) {
    if (!square_isview(cave, mon->target.grid)) {
      int dist_y = ABS(player->grid.y - mon->target.grid.y);
      int dist_x = ABS(player->grid.x - mon->target.grid.x);
      if (((dist_y == 2) && (dist_x == 1)) ||
          ((dist_y == 1) && (dist_x == 2))) {
        for (i = 7; i >= 0; i--) {
          grid = loc_sum(mon->grid, ddgrid_ddd[i]);
          if (!square_in_bounds(cave, grid)) continue;
          if (square_isview(cave, grid)) continue;
          if (loc_eq(grid, mon->target.grid)) continue;
          if (monster_entry_chance(cave, mon, mon->target.grid, &dummy) >
              monster_entry_chance(cave, mon, grid, &dummy))
            continue;
          mon->target.grid = grid;
          break;
        }
      }
      *tgrid = mon->target.grid;
      return true;
    } else if (!square_isstairs(cave, mon->target.grid)) {
      mon->target.grid = loc(0, 0);
    }
  }
  if (!square_isview(cave, mon->grid)) {
    if (flow_dist(mon->flow, mon->grid) < z_info->flow_max) {
      bool done = false;
      for (i = 7; i >= 0; i--) {
        grid = loc_sum(mon->grid, ddgrid_ddd[i]);
        if (!square_in_bounds(cave, grid)) continue;
        if (flow_dist(mon->flow, grid) > flow_dist(mon->flow, mon->grid)) {
          if (!square_isview(cave, grid)) {
            *tgrid = grid;
            done = true;
            break;
          }
        }
      }
      if (done) return true;
    }
  } else {
    int prev_dist = flow_dist(mon->flow, mon->grid);
    int start = randint0(8);
    for (i = start; i < 8 + start; i++) {
      grid = loc_sum(mon->grid, ddgrid_ddd[i % 8]);
      if (!square_in_bounds(cave, grid)) continue;
      if (square_isview(cave, grid)) continue;
      if (monster_entry_chance(cave, mon, grid, &dummy) < 50) continue;
      if (flow_dist(mon->flow, grid) >= prev_dist) {
        *tgrid = grid;
        return true;
      }
    }
    if (get_move_find_safety(mon, tgrid) == true) return true;
    if (square_isview(cave, mon->grid) &&
        ((mon->cdis < z_info->turn_range) ||
         (mon->mspeed < player->state.speed)) &&
        !player->truce && (race->freq_ranged < 50)) {
      if (monster_is_visible(mon)) {
        add_monster_message(mon, MON_MSG_PANIC, true);
      }
      mon->tmp_morale = MAX(mon->tmp_morale + 60, 60);
      calc_morale(mon);
      calc_stance(mon);
      mflag_on(mon->mflag, MFLAG_AGGRESSIVE);
      return true;
    }
  }
  *tgrid = loc_diff(mon->grid, loc_diff(player->grid, mon->grid));
  return true;
}
STATIC_OVL void
get_move_advance(struct monster* mon, struct loc* tgrid)
{
  int i;
  int closest = z_info->flow_max;
  bool can_use_scent = false;
  struct monster_lore* lore = get_lore(mon->race);
  if (rf_has(mon->race->flags, RF_TERRITORIAL) &&
      !los(cave, player->grid, mon->grid)) {
    *tgrid = mon->grid;
    rf_on(lore->flags, RF_TERRITORIAL);
    if (one_in_(10) && (mon->alertness >= ALERTNESS_ALERT)) {
      set_alertness(mon, mon->alertness - 1);
    }
    return;
  }
  if (!loc_eq(mon->target.grid, loc(0, 0))) {
    *tgrid = mon->target.grid;
    return;
  }
  if (flow_dist(mon->flow, mon->grid) >= z_info->flow_max) {
    if (monster_can_smell(mon)) {
      can_use_scent = true;
    } else {
      if (los(cave, mon->grid, player->grid)) {
        get_move_retreat(mon, tgrid);
        return;
      } else {
        *tgrid = player->grid;
        return;
      }
    }
  }
  for (i = 7; i >= 0; i--) {
    struct loc grid = loc_sum(mon->grid, ddgrid_ddd[i]);
    if (!square_in_bounds(cave, grid)) continue;
    if (can_use_scent) {
      int age = get_scent(cave, grid);
      if (age == -1) continue;
      if (closest < age) continue;
      closest = age;
    } else {
      int dist = flow_dist(mon->flow, grid);
      if (closest < dist) continue;
      closest = dist;
    }
    *tgrid = grid;
  }
}
STATIC_OVL int
get_move_calc_vulnerability(struct loc mgrid)
{
  struct loc pgrid = player->grid;
  int vulnerability = 0;
  int dir = rough_direction(pgrid, mgrid);
  int dy = ddy[dir];
  int dx = ddx[dir];
  if (dy * dx == 0) {
    int i;
    struct loc grid[8] = {loc_sum(pgrid, loc(dx, dy)),
                          loc_sum(pgrid, loc(dx - dy, dx + dy)),
                          loc_sum(pgrid, loc(dx + dy, dy - dx)),
                          loc_sum(pgrid, loc(-dy, dx)),
                          loc_sum(pgrid, loc(dy, -dx)),
                          loc_sum(pgrid, loc(-dx - dy, dx - dy)),
                          loc_sum(pgrid, loc(dy - dx, -dx - dy)),
                          loc_sum(pgrid, loc(-dx, -dy))};
    for (i = 0; i < 5; i++) {
      if (square_isprojectable(cave, grid[i])) vulnerability++;
    }
    for (i = 1; i < 5; i++) {
      if (square_monster(cave, grid[i])) vulnerability++;
    }
    for (i = 5; i < 8; i++) {
      if (square_monster(cave, grid[i])) vulnerability += 2;
    }
  } else {
    int i;
    struct loc grid[8] = {
        loc_sum(pgrid, loc(dx, dy)),  loc_sum(pgrid, loc(0, dy)),
        loc_sum(pgrid, loc(dx, 0)),   loc_sum(pgrid, loc(-dy, dx)),
        loc_sum(pgrid, loc(dy, -dx)), loc_sum(pgrid, loc(0, -dy)),
        loc_sum(pgrid, loc(-dx, 0)),  loc_sum(pgrid, loc(-dx, -dy))};
    for (i = 0; i < 5; i++) {
      if (square_isprojectable(cave, grid[i])) vulnerability++;
    }
    for (i = 1; i < 5; i++) {
      if (square_monster(cave, grid[i])) vulnerability++;
    }
    for (i = 5; i < 8; i++) {
      if (square_monster(cave, grid[i])) vulnerability += 2;
    }
  }
  switch (health_level(player->chp, player->mhp)) {
    case HEALTH_WOUNDED:
      vulnerability += 1;
      break;
    case HEALTH_BADLY_WOUNDED:
      vulnerability += 1;
      break;
    case HEALTH_ALMOST_DEAD:
      vulnerability += 2;
      break;
  }
  if (player->timed[TMD_BLIND] || player->timed[TMD_IMAGE] ||
      player->timed[TMD_CONFUSED] || player->timed[TMD_AFRAID] ||
      player->timed[TMD_ENTRANCED] || (player->timed[TMD_STUN] > 50) ||
      player->timed[TMD_SLOW]) {
    vulnerability += 2;
  }
  return vulnerability;
}
STATIC_OVL int
get_move_calc_hesitance(struct monster* mon)
{
  int x, y;
  int hesitance = 1;
  for (y = -5; y <= +5; y++) {
    for (x = -5; x <= +5; x++) {
      struct loc grid = loc_sum(mon->grid, loc(x, y));
      if (!loc_eq(grid, mon->grid) && square_in_bounds(cave, grid)) {
        struct monster* mon1 = square_monster(cave, grid);
        if (mon1 && similar_monsters(mon, mon1) &&
            (distance(grid, player->grid) > 1) && (hesitance < 2)) {
          hesitance++;
        }
      }
    }
  }
  if ((mon->race->freq_ranged > 30) && (hesitance == 2)) {
    hesitance++;
  }
  return hesitance;
}
STATIC_OVL bool
get_move(struct monster* mon, struct loc* tgrid, bool* fear,
         bool must_use_target)
{
  struct monster_race* race = mon->race;
  struct monster_lore* lore = get_lore(race);
  int i, start;
  struct loc grid;
  *tgrid = mon->grid;
  if (rf_has(race->flags, RF_HIDDEN_MOVE) &&
      (square_isseen(cave, mon->grid) ||
       square_seen_by_keen_senses(cave, mon->grid))) {
    if (monster_is_visible(mon) && one_in_(50)) {
      rf_on(lore->flags, RF_HIDDEN_MOVE);
    }
    return false;
  }
  if (rf_has(race->flags, RF_QUESTOR) && player->truce) {
    return false;
  }
  if (rf_has(race->flags, RF_MINDLESS) && rf_has(race->flags, RF_TERRITORIAL) &&
      (mon->cdis > 5)) {
    return false;
  }
  if (rf_has(race->flags, RF_NEVER_MOVE)) {
    if (monster_is_visible(mon) && one_in_(20)) {
      rf_on(lore->flags, RF_NEVER_MOVE);
    }
    if (mon->cdis <= 1) {
      *fear = false;
      *tgrid = player->grid;
      return true;
    }
    return false;
  }
  if (must_use_target) {
    *tgrid = mon->target.grid;
    return true;
  }
  *fear = ((mon->min_range >= z_info->flee_range) ||
           (mon->stance == STANCE_FLEEING));
  if (*fear) {
    if ((mon->stance != STANCE_FLEEING) && (mon->cdis < z_info->turn_range) &&
        (player->state.speed > mon->mspeed)) {
      monster_find_range(mon);
      if (mon->min_range < mon->cdis) {
        *fear = false;
        *tgrid = player->grid;
        return true;
      }
    } else if (mon->cdis < z_info->flee_range) {
      get_move_retreat(mon, tgrid);
      return true;
    } else {
      return false;
    }
  }
  if (!*fear && (mon->cdis < mon->min_range - 2)) {
    if (get_move_retreat(mon, tgrid)) {
      *fear = true;
      return true;
    } else {
      *tgrid = player->grid;
    }
  }
  if (!*fear && (mon->cdis <= 1)) {
    if (rf_has(race->flags, RF_SMART)) {
      struct loc mgrid = mon->grid;
      int count = adj_mon_count(mgrid);
      int dy = player->grid.y - mon->grid.y;
      int dx = player->grid.x - mon->grid.x;
      start = randint0(8);
      for (i = start; i < 8 + start; i++) {
        grid = loc_sum(player->grid, ddgrid_ddd[i % 8]);
        if (distance(mon->grid, grid) == 1) {
          if (square_ispassable(cave, grid) && !square_monster(cave, grid)) {
            if ((adj_mon_count(grid) <= count) &&
                (rf_has(race->flags, RF_FLANKING) || one_in_(2))) {
              *tgrid = grid;
              return true;
            }
          }
        }
      }
      if (dy * dx == 0) {
        struct loc wall1 = loc(mgrid.x + dy, mgrid.y + dx);
        struct loc wall2 = loc(mgrid.x - dy, mgrid.y - dx);
        if (!square_isprojectable(cave, wall1) &&
            !square_isprojectable(cave, wall2)) {
          struct loc grid1 = loc_diff(wall1, loc(dx, dy));
          struct loc grid2 = loc_diff(mgrid, loc(dx, dy));
          struct loc grid3 = loc_diff(wall2, loc(dx, dy));
          struct loc grida = loc_sum(wall1, loc(dx, dy));
          struct loc gridb = loc_sum(wall2, loc(dx, dy));
          struct monster* mon1 = square_monster(cave, grid1);
          struct monster* mon2 = square_monster(cave, grid2);
          struct monster* mon3 = square_monster(cave, grid3);
          struct monster* mona = square_monster(cave, grida);
          struct monster* monb = square_monster(cave, gridb);
          if (mon1 || mon2 || mon3) {
            if (!mona && !monb) {
              *tgrid = one_in_(2) ? grida : gridb;
              return true;
            } else if (!mona) {
              *tgrid = grida;
              return true;
            } else if (!monb) {
              *tgrid = gridb;
              return true;
            }
          }
        }
      } else {
        struct loc gridn = loc_sum(mgrid, loc(0, -1));
        struct loc grids = loc_sum(mgrid, loc(0, 1));
        struct loc gride = loc_sum(mgrid, loc(1, 0));
        struct loc gridw = loc_sum(mgrid, loc(-1, 0));
        if (!square_isprojectable(cave, gridn) &&
            !square_isprojectable(cave, grids)) {
          struct loc grid1 = loc_diff(mgrid, loc(dx, -1));
          struct loc grid2 = loc_diff(mgrid, loc(dx, 0));
          struct loc grid3 = loc_diff(mgrid, loc(dx, 1));
          struct loc grida = loc_sum(mgrid, loc(dx, 0));
          struct monster* mon1 = square_monster(cave, grid1);
          struct monster* mon2 = square_monster(cave, grid2);
          struct monster* mon3 = square_monster(cave, grid3);
          struct monster* mona = square_monster(cave, grida);
          if (mon1 || mon2 || mon3) {
            if (!mona) {
              *tgrid = grida;
              return true;
            }
          }
        } else if (!square_isprojectable(cave, gride) &&
                   !square_isprojectable(cave, gridw)) {
          struct loc grid1 = loc_diff(mgrid, loc(-1, dy));
          struct loc grid2 = loc_diff(mgrid, loc(0, dy));
          struct loc grid3 = loc_diff(mgrid, loc(1, dy));
          struct loc grida = loc_sum(mgrid, loc(0, dy));
          struct monster* mon1 = square_monster(cave, grid1);
          struct monster* mon2 = square_monster(cave, grid2);
          struct monster* mon3 = square_monster(cave, grid3);
          struct monster* mona = square_monster(cave, grida);
          if (mon1 || mon2 || mon3) {
            if (!mona) {
              *tgrid = grida;
              return true;
            }
          }
        }
      }
    }
    *tgrid = player->grid;
    return true;
  }
  if (!*fear && rf_has(race->flags, RF_SMART) &&
      !rf_has(race->flags, RF_PASS_WALL) &&
      !rf_has(race->flags, RF_KILL_WALL) && (mon->stance == STANCE_CONFIDENT)) {
    int vulnerability = get_move_calc_vulnerability(mon->grid);
    int hesitance = get_move_calc_hesitance(mon);
    if (vulnerability < hesitance) {
      if (mon->min_range == 1) {
        if (square_isseen(cave, mon->grid) || square_isfire(cave, mon->grid)) {
          if (get_move_retreat(mon, tgrid)) {
            *fear = true;
          } else {
            *tgrid = player->grid;
          }
        } else {
          get_move_advance(mon, tgrid);
          if (mon->cdis > 1) *fear = true;
        }
        return true;
      } else if (square_isseen(cave, mon->grid) ||
                 square_isfire(cave, mon->grid)) {
        if (get_move_retreat(mon, tgrid)) {
          *fear = true;
        } else {
          *tgrid = player->grid;
        }
      }
    }
  }
  if ((!*fear) && (mon->cdis <= 3) && square_isview(cave, mon->grid) &&
      (rf_has(race->flags, RF_FRIENDS) || rf_has(race->flags, RF_FRIEND))) {
    if (projectable(cave, mon->grid, player->grid, PROJECT_CHCK) !=
        PROJECT_PATH_CLEAR) {
      start = randint0(8);
      for (i = start; i < 8 + start; i++) {
        grid = loc_sum(player->grid, ddgrid_ddd[i % 8]);
        if (!square_in_bounds(cave, grid)) continue;
        if (square_monster(cave, grid)) continue;
        if (!monster_can_exist(cave, mon, grid, false, true)) continue;
        *tgrid = grid;
        return true;
      }
    }
  }
  if (!*fear) {
    if (!square_isview(cave, mon->grid)) {
      get_move_advance(mon, tgrid);
    } else {
      mon->target.grid = player->grid;
      if (mon->cdis > mon->best_range) {
        *tgrid = player->grid;
      } else if ((mon->cdis > mon->min_range) && one_in_(2)) {
        *tgrid = player->grid;
      } else if (!square_isfire(cave, mon->grid)) {
        *tgrid = player->grid;
      } else {
        if (rf_has(race->flags, RF_RAND_50) ||
            rf_has(race->flags, RF_RAND_25)) {
          i = randint0(8);
          *tgrid = loc_sum(mon->grid, ddgrid_ddd[i]);
        }
      }
      if (loc_eq(*tgrid, player->grid)) {
        mon->target.grid = loc(0, 0);
        get_move_advance(mon, tgrid);
      }
    }
  } else {
    get_move_retreat(mon, tgrid);
  }
  if (loc_eq(*tgrid, mon->grid)) return false;
  return true;
}
STATIC_OVL int
make_move_choose_direction(struct loc offset)
{
  int dir = 0;
  int dx = offset.x, dy = offset.y;
  int ay = ABS(dy);
  int ax = ABS(dx);
  if (ay > (ax * 2)) {
    if (dy > 0) {
      dir = 2;
      if ((dx > 0) || (dx == 0 && turn % 2 == 0)) dir += 10;
    } else {
      dir = 8;
      if ((dx < 0) || (dx == 0 && turn % 2 == 0)) dir += 10;
    }
  } else if (ax > (ay * 2)) {
    if (dx > 0) {
      dir = 6;
      if ((dy < 0) || (dy == 0 && turn % 2 == 0)) dir += 10;
    } else {
      dir = 4;
      if ((dy > 0) || (dy == 0 && turn % 2 == 0)) dir += 10;
    }
  } else if (dy > 0) {
    if (dx > 0) {
      dir = 3;
      if ((ay < ax) || (ay == ax && turn % 2 == 0)) dir += 10;
    } else {
      dir = 1;
      if ((ay > ax) || (ay == ax && turn % 2 == 0)) dir += 10;
    }
  } else {
    if (dx > 0) {
      dir = 9;
      if ((ay > ax) || (ay == ax && turn % 2 == 0)) dir += 10;
    } else {
      dir = 7;
      if ((ay < ax) || (ay == ax && turn % 2 == 0)) dir += 10;
    }
  }
  return dir;
}
STATIC_OVL bool
make_move_get_route_to_target(struct monster* mon, struct loc* tgrid)
{
  int i, j;
  int dist_y, dist_x;
  struct loc grid, grid1, tar_grid = loc(0, 0);
  bool dummy;
  bool below = false;
  bool right = false;
  dist_y = ABS(mon->target.grid.y - mon->grid.y);
  dist_x = ABS(mon->target.grid.x - mon->grid.x);
  if (dist_y > dist_x) {
    if (mon->target.grid.y - mon->grid.y > 0) below = true;
    for (i = 0; i < 8; i++) {
      grid = loc_sum(mon->grid, ddgrid_ddd[i]);
      if (!square_in_bounds_fully(cave, grid)) continue;
      if (!monster_entry_chance(cave, mon, grid, &dummy)) continue;
      if ((below && (grid.y < mon->grid.y)) ||
          (!below && (grid.y > mon->grid.y))) {
        continue;
      } else if (grid.y == mon->grid.y) {
        for (j = 0; j < 8; j++) {
          grid1 = loc_sum(grid, ddgrid_ddd[j]);
          if ((below && (grid1.y > mon->grid.y)) ||
              (!below && (grid1.y < mon->grid.y))) {
            if (!monster_entry_chance(cave, mon, grid1, &dummy)) continue;
            tar_grid = grid;
          }
        }
      } else {
        *tgrid = grid;
        return true;
      }
    }
  } else if (dist_x > dist_y) {
    if (mon->target.grid.x - mon->grid.x > 0) right = true;
    for (i = 0; i < 8; i++) {
      grid = loc_sum(mon->grid, ddgrid_ddd[i]);
      if (!square_in_bounds_fully(cave, grid)) continue;
      if (!monster_entry_chance(cave, mon, grid, &dummy)) continue;
      if ((right && (grid.x < mon->grid.x)) ||
          (!right && (grid.x > mon->grid.x))) {
        continue;
      } else if (grid.x == mon->grid.x) {
        for (j = 0; j < 8; j++) {
          grid1 = loc_sum(grid, ddgrid_ddd[j]);
          if ((right && (grid1.x > mon->grid.x)) ||
              (!right && (grid1.x < mon->grid.x))) {
            if (!monster_entry_chance(cave, mon, grid1, &dummy)) continue;
            tar_grid = grid;
          }
        }
      } else {
        *tgrid = grid;
        return true;
      }
    }
  } else {
    return false;
  }
  if (!loc_eq(tar_grid, loc(0, 0))) {
    *tgrid = tar_grid;
    return true;
  }
  return false;
}
STATIC_OVL void
make_confused_move(struct monster* mon, struct loc grid)
{
  bool seen = monster_is_visible(mon) && square_isseen(cave, grid);
  if (!square_in_bounds_fully(cave, grid)) return;
  if (square_ischasm(cave, grid)) {
    if (!rf_has(mon->race->flags, RF_FLYING) && !square_monster(cave, grid)) {
      monster_swap(mon->grid, grid);
    }
  } else if (square_iswall(cave, grid)) {
    if (square_isdoor(cave, grid)) {
      if (seen) add_monster_message(mon, MON_MSG_STAGGER_DOOR, true);
    } else if (square_isrubble(cave, grid)) {
      if (seen) add_monster_message(mon, MON_MSG_STAGGER_RUBBLE, true);
    } else {
      if (seen) add_monster_message(mon, MON_MSG_STAGGER_WALL, true);
    }
    if (player->upkeep->health_who == mon)
      player->upkeep->redraw |= (PR_HEALTH);
  } else {
  }
}
STATIC_OVL bool
make_move(struct monster* mon, struct loc* tgrid, bool fear, bool* bash)
{
  int i, j;
  int dir0, dir;
  struct loc current = mon->grid, next;
  bool avoid = false;
  bool passable = false;
  bool look_again = false;
  int chance;
  static struct move_data {
    int move_chance;
    bool move_bash;
  } moves_data[8];
  dir0 = make_move_choose_direction(loc_diff(*tgrid, current));
  if (loc_eq(*tgrid, mon->grid)) {
    if (mon->cdis == 1) {
      *tgrid = player->grid;
    } else {
      return false;
    }
  }
  if ((mon->m_timed[MON_TMD_CONF]) &&
      !rf_has(mon->race->flags, RF_NEVER_MOVE)) {
    if (dir0 > 10) dir0 -= 10;
    i = damroll(3, 2) - damroll(3, 2);
    dir0 = cycle[chome[dir0] + i];
  }
  if ((distance(*tgrid, current) <= 1) && !mon->m_timed[MON_TMD_CONF]) {
    chance = monster_entry_chance(cave, mon, *tgrid, bash);
    if (chance >= 50) {
      if ((chance >= 100) || (randint0(100) < chance)) {
        return true;
      } else {
        return false;
      }
    }
  }
  for (i = 0; i <= 8; i++) {
    if (i == 8) break;
    dir = side_dirs[dir0][i];
    next = loc_sum(current, ddgrid[dir]);
    if (!square_in_bounds(cave, next)) continue;
    moves_data[i].move_chance = monster_entry_chance(cave, mon, next, bash);
    moves_data[i].move_bash = *bash;
    if (mon->m_timed[MON_TMD_CONF]) break;
    if (moves_data[i].move_chance == 0) continue;
    if (fear) {
      if (!loc_eq(mon->target.grid, loc(0, 0)) && (i >= 2) &&
          (distance(mon->grid, mon->target.grid) > 1)) {
        if (make_move_get_route_to_target(mon, tgrid)) {
          chance = monster_entry_chance(cave, mon, *tgrid, bash);
          if (randint0(100) < chance) {
            return true;
          }
          return (false);
        } else if (i >= 3) {
          if (monster_is_visible(mon) && (square_isfire(cave, current)) &&
              !player->truce && (mon->race->freq_ranged < 50)) {
            add_monster_message(mon, MON_MSG_PANIC, true);
            mon->tmp_morale = MAX(mon->tmp_morale + 60, 60);
            calc_morale(mon);
            calc_stance(mon);
            mflag_on(mon->mflag, MFLAG_AGGRESSIVE);
          }
        }
      }
      if ((i == 0) && loc_eq(next, player->grid)) {
        mon->target.grid = loc(0, 0);
      }
      if (monster_is_visible(mon)) {
        if (square_isview(cave, current)) {
          if ((!square_isview(cave, next)) &&
              (moves_data[i].move_chance > 40)) {
            break;
          }
        } else {
          if (square_isview(cave, next)) {
            moves_data[i].move_chance = 0;
            continue;
          }
        }
      } else {
        if (!square_isview(cave, current)) {
          if (square_isview(cave, next)) {
            moves_data[i].move_chance = 0;
            continue;
          }
        }
      }
    }
    if (square_iswarded(cave, next) && (!fear) && one_in_(5)) {
      break;
    }
    if ((i == 0) && (moves_data[i].move_chance >= 80)) {
      if ((fear) && (mon->cdis <= 2) && (distance(player->grid, next) <= 1)) {
        avoid = true;
      } else {
        break;
      }
    } else if (((i == 1) || (i == 2)) && (moves_data[i].move_chance >= 50)) {
      if ((moves_data[0].move_chance >= moves_data[i].move_chance)) {
        if (avoid) {
          if (distance(player->grid, next) == 0) {
            i = 0;
          }
        } else {
          i = 0;
        }
      }
      break;
    }
    if (!passable) {
      passable = true;
      if (i >= 3) {
        break;
      }
    }
    if (i == 7) look_again = true;
  }
  if (look_again) {
    if (!passable) {
      return false;
    }
    for (j = 0; j < 8; j++) {
      if (moves_data[j].move_chance) {
        i = j;
        break;
      }
    }
  }
  if (i >= 8) {
    return false;
  }
  dir = side_dirs[dir0][i];
  *bash = moves_data[i].move_bash;
  if ((dir == DIR_NONE) || (dir == DIR_UNKNOWN)) {
    return false;
  }
  *tgrid = loc_sum(current, ddgrid[dir]);
  if (mon->m_timed[MON_TMD_CONF] && (moves_data[i].move_chance <= 25)) {
    make_confused_move(mon, *tgrid);
    if (!moves_data[i].move_chance) return false;
  }
  if ((moves_data[i].move_chance < 100) &&
      (randint0(100) > moves_data[i].move_chance)) {
    return false;
  }
  if ((fear) && square_isplayer(cave, *tgrid) && !player->truce) {
    if (monster_is_visible(mon)) {
      add_monster_message(mon, MON_MSG_PANIC, true);
    }
    mon->tmp_morale = MAX(mon->tmp_morale + 60, 60);
    calc_morale(mon);
    calc_stance(mon);
    mflag_on(mon->mflag, MFLAG_AGGRESSIVE);
  }
  return true;
}
STATIC_OVL void
process_move_exchange_places(struct monster* mon)
{
  struct monster_lore* lore = get_lore(mon->race);
  char m_name1[80];
  char m_name2[80];
  monster_desc(m_name1, sizeof(m_name1), mon, (MDESC_PRO_VIS | MDESC_OBJE));
  monster_desc(m_name2, sizeof(m_name2), mon, MDESC_PRO_VIS);
  add_monster_message(mon, MON_MSG_EXCHANGE, true);
  monster_swap(mon->grid, player->grid);
  if (!player->timed[TMD_AFRAID] && !player->timed[TMD_ENTRANCED] &&
      (player->timed[TMD_STUN] <= 100)) {
    msg("You attack %s as %s slips past.", m_name1, m_name2);
    py_attack_real(player, mon->grid, ATT_OPPORTUNITY);
  }
  if (monster_is_visible(mon)) {
    rf_on(lore->flags, RF_EXCHANGE);
  }
  player_handle_post_move(player, true, true);
}
STATIC_OVL bool
process_move_push_aside(struct monster* mon, struct monster* mon1)
{
  int i, dir = 0;
  struct loc grid;
  for (i = 0; i < 10; i++) {
    if (!loc_eq(loc_diff(mon1->grid, mon->grid), ddgrid[i])) continue;
    dir = i;
    break;
  }
  if (one_in_(2)) dir += 10;
  for (i = 0; i < 7; i++) {
    int side_dir = side_dirs[dir][i];
    grid = loc_sum(mon1->grid, ddgrid[side_dir]);
    if (!square_in_bounds_fully(cave, grid)) continue;
    if (monster_can_exist(cave, mon1, grid, false, true)) {
      monster_swap(mon1->grid, grid);
      return true;
    }
  }
  return false;
}
STATIC_OVL void
process_move_grab_objects(struct monster* mon, struct loc new)
{
  struct monster_lore* lore = get_lore(mon->race);
  struct object* obj = square_object(cave, new);
  bool visible = monster_is_visible(mon);
  char m_name[80];
  if (in_tutorial()) {
    return;
  }
  if (!rf_has(mon->race->flags, RF_TAKE_ITEM)) return;
  monster_desc(m_name, sizeof(m_name), mon, MDESC_STANDARD);
  obj = square_object(cave, new);
  while (obj) {
    char o_name[80];
    bool useless = obj_is_cursed(obj) || obj_is_broken(obj);
    struct object* next = obj->next;
    object_desc(o_name, sizeof(o_name), obj, ODESC_PREFIX | ODESC_FULL, player);
    if (useless && visible && square_isview(cave, new)) {
      msg("%s looks at %s, but moves on.", m_name, o_name);
    } else {
      struct object* taken = object_new();
      rf_on(lore->flags, RF_TAKE_ITEM);
      object_copy(taken, obj);
      taken->oidx = 0;
      if (obj->known) {
        taken->known = object_new();
        object_copy(taken->known, obj->known);
        taken->known->oidx = 0;
        taken->known->grid = loc(0, 0);
      }
      if (monster_carry(cave, mon, taken)) {
        if (square_isseen(cave, new) && !ignore_item_ok(player, obj)) {
          msg("%s picks up %s.", m_name, o_name);
        }
        square_delete_object(cave, new, obj, true, true);
      } else {
        if (taken->known) {
          object_delete(player->cave, NULL, &taken->known);
        }
        object_delete(cave, player->cave, &taken);
      }
    }
    obj = next;
  }
}
STATIC_OVL void
process_move(struct monster* mon, struct loc tgrid, bool bash)
{
  struct monster_race* race = mon->race;
  struct monster_lore* lore = get_lore(race);
  struct loc current = mon->grid, next = tgrid;
  bool do_move = true;
  bool do_view = false;
  bool did_swap = false;
  bool did_pass_door = false;
  bool did_open_door = false;
  bool did_unlock_door = false;
  bool did_bash_door = false;
  bool did_pass_wall = false;
  bool did_kill_wall = false;
  bool did_tunnel_wall = false;
  if (!square_in_bounds(cave, next)) return;
  if (rf_has(race->flags, RF_HIDDEN_MOVE) &&
      (square_isseen(cave, tgrid) || square_seen_by_keen_senses(cave, tgrid))) {
    if (!rf_has(lore->flags, RF_HIDDEN_MOVE)) {
      if (monster_is_visible(mon) && (one_in_(50))) {
        rf_on(lore->flags, RF_HIDDEN_MOVE);
      }
    }
    return;
  }
  if (square_isplayer(cave, next)) {
    if (mon->alertness < ALERTNESS_ALERT) {
      set_alertness(mon, rand_range(ALERTNESS_ALERT, ALERTNESS_ALERT + 5));
      mon->skip_next_turn = false;
    } else if (!player->truce) {
      if (rf_has(race->flags, RF_EXCHANGE) && one_in_(4) &&
          (adj_mon_count(mon->grid) >= adj_mon_count(player->grid))) {
        process_move_exchange_places(mon);
      } else {
        (void)make_attack_normal(mon, player);
      }
    }
    do_move = false;
  }
  if (do_move) {
    if (square_iswall(cave, next)) {
      if (rf_has(race->flags, RF_PASS_WALL)) {
        did_pass_wall = true;
      } else if (rf_has(race->flags, RF_KILL_WALL)) {
        bool note = false;
        int noise_dist = 10;
        if (square_isview(cave, next)) {
          do_view = true;
          did_kill_wall = true;
        } else if (mon->cdis <= noise_dist) {
          note = true;
        }
        if (square_isdoor(cave, next)) {
          square_set_feat(cave, next, FEAT_BROKEN);
          if (note) {
            disturb(player, false);
            msg("You hear a door being smashed open.");
          }
          mon->noise += 10;
        } else {
          square_set_feat(cave, next, FEAT_FLOOR);
          if (note) {
            disturb(player, false);
            msg("You hear grinding noises.");
          }
          mon->noise += 15;
        }
      } else if (rf_has(race->flags, RF_TUNNEL_WALL) &&
                 !square_iscloseddoor(cave, next)) {
        bool note = false;
        int noise_dist = 10;
        do_move = false;
        if (square_isview(cave, next)) {
          do_view = true;
          did_tunnel_wall = true;
        } else if (mon->cdis <= noise_dist) {
          note = true;
        }
        if (square_isrubble(cave, next)) {
          square_set_feat(cave, next, FEAT_FLOOR);
          if (note) {
            disturb(player, false);
            msg("You hear grinding noises.");
          }
          mon->noise += 15;
        } else {
          square_set_feat(cave, next, FEAT_RUBBLE);
          if (note) {
            disturb(player, false);
            msg("You hear grinding noises.");
          }
          mon->noise += 15;
        }
      } else if (square_iscloseddoor(cave, next)) {
        if (rf_has(race->flags, RF_PASS_DOOR)) {
          did_pass_door = true;
        } else if (bash) {
          if (square_isview(cave, next)) {
            disturb(player, false);
            msg("The door bursts open!");
            do_view = true;
          } else if (mon->cdis < 20) {
            disturb(player, false);
            msg("You hear a door burst open!");
          }
          did_bash_door = true;
          mon->noise += 10;
          if (one_in_(2)) {
            square_set_feat(cave, next, FEAT_BROKEN);
          } else {
            square_set_feat(cave, next, FEAT_OPEN);
          }
        } else {
          if (square_islockeddoor(cave, next)) {
            did_unlock_door = true;
            square_set_feat(cave, next, FEAT_CLOSED);
            do_move = false;
            if (square_isview(cave, next)) {
              msg("You hear a 'click'.");
            }
          } else {
            did_open_door = true;
            square_set_feat(cave, next, FEAT_OPEN);
            if (!one_in_(5)) do_move = false;
          }
          if (square_isview(cave, next)) {
            do_view = true;
          }
        }
      } else {
        return;
      }
    } else if (square_iswarded(cave, next)) {
      if (square_isseen(cave, next)) {
        msg("The glyph of warding is broken!");
        square_unmark(cave, next);
      }
      square_destroy_trap(cave, next);
    }
  }
  if (do_move) {
    struct monster* mon1 = square_monster(cave, next);
    if (mon1) {
      did_swap = true;
      if (!monster_can_exist(cave, mon1, mon->grid, true, true)) {
        if (!process_move_push_aside(mon, mon1)) {
          do_move = false;
        }
      }
    }
  }
  if (do_move) {
    struct monster* mon1;
    if (rf_has(race->flags, RF_FLANKING) &&
        (distance(current, player->grid) == 1) &&
        (distance(next, player->grid) == 1) &&
        (mon->alertness >= ALERTNESS_ALERT) &&
        (mon->stance != STANCE_FLEEING) && !mon->m_timed[MON_TMD_CONF] &&
        !did_swap) {
      add_monster_message(mon, MON_MSG_FLANK, false);
      make_attack_normal(mon, player);
      if (monster_is_visible(mon)) {
        rf_on(lore->flags, RF_FLANKING);
      }
    }
    monster_swap(current, next);
    if (!mon->race) return;
    if (loc_eq(mon->target.grid, next)) {
      mon->target.grid = loc(0, 0);
    }
    mon1 = square_monster(cave, current);
    if (mon1) {
      mflag_on(mon1->mflag, MFLAG_PUSHED);
    } else {
      mon->previous_action[0] = rough_direction(current, next);
    }
    if (!square_isview(cave, next) && rf_has(race->flags, RF_FRIENDS) &&
        monster_can_smell(mon) && (get_scent(cave, current) == -1) &&
        loc_eq(mon->target.grid, loc(0, 0))) {
      int i;
      bool alerted_others = false;
      for (i = cave_monster_max(cave) - 1; i >= 1; i--) {
        mon1 = cave_monster(cave, i);
        if (!mon1->race) continue;
        if (race->base != mon1->race->base) continue;
        if (!loc_eq(mon->target.grid, loc(0, 0))) continue;
        if (get_scent(cave, mon1->grid) < SMELL_STRENGTH - 10) continue;
        if (!los(cave, mon->grid, mon1->grid)) continue;
        make_alert(mon, 0);
        mflag_on(mon1->mflag, MFLAG_ACTIVE);
        mon1->target.grid = next;
        alerted_others = true;
      }
      if (alerted_others) {
        message_pursuit(mon);
      }
    }
    if (monster_is_visible(mon)) {
      if (did_pass_door) {
        add_monster_message(mon, MON_MSG_PASS_DOOR, true);
      }
      disturb(player, false);
    }
    process_move_grab_objects(mon, next);
  }
  if (do_view) {
    player->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
  }
  if (monster_is_visible(mon)) {
    if (did_pass_door) rf_on(lore->flags, RF_PASS_DOOR);
    if (did_open_door) rf_on(lore->flags, RF_OPEN_DOOR);
    if (did_unlock_door) rf_on(lore->flags, RF_UNLOCK_DOOR);
    if (did_bash_door) rf_on(lore->flags, RF_BASH_DOOR);
    if (did_pass_wall) rf_on(lore->flags, RF_PASS_WALL);
    if (did_kill_wall) rf_on(lore->flags, RF_KILL_WALL);
    if (did_tunnel_wall) rf_on(lore->flags, RF_TUNNEL_WALL);
  }
}
STATIC_OVL void
monster_turn_wander(struct monster* mon)
{
  struct monster_group* group =
      monster_group_by_index(cave, mon->group_info.index);
  struct loc tgrid;
  bool fear = false;
  bool bash = false;
  const struct artifact* crown = lookup_artifact_name("of Morgoth");
  if (rsf_has(mon->race->spell_flags, RSF_SNG_PIERCE) &&
      (mon->song != lookup_song("Piercing")) &&
      (mon->alertness < ALERTNESS_ALERT) && (mon->mana >= z_info->mana_cost) &&
      is_artifact_created(crown)) {
    do_mon_spell(RSF_SNG_PIERCE, mon, square_isview(cave, mon->grid));
  }
  if (one_in_(10) && !loc_eq(group->flow.centre, loc(0, 0))) {
    update_flow(cave, &group->flow, mon);
  }
  if (!get_move_wander(mon, &tgrid)) return;
  if (!make_move(mon, &tgrid, fear, &bash)) return;
  process_move(mon, tgrid, bash);
}
STATIC_OVL bool
monster_has_sleeping_kin(struct monster* mon)
{
  int i;
  bool has_kin = false;
  for (i = cave_monster_max(cave) - 1; i >= 1; i--) {
    struct monster* mon1 = cave_monster(cave, i);
    if (!mon1->race) continue;
    if (mon->race->base != mon1->race->base) continue;
    if (!los(cave, mon->grid, mon1->grid)) continue;
    if (mon1->alertness >= ALERTNESS_ALERT) continue;
    has_kin = true;
  }
  return has_kin;
}
STATIC_OVL void
tell_allies(struct monster* mon, int flag)
{
  int i;
  bool warned = false;
  for (i = cave_monster_max(cave) - 1; i >= 1; i--) {
    struct monster* mon1 = cave_monster(cave, i);
    int dist;
    if (!mon1->race) continue;
    if (mon->race->base != mon1->race->base) continue;
    if ((mon1->alertness >= ALERTNESS_ALERT) && mflag_has(mon1->mflag, flag)) {
      continue;
    }
    dist = distance(mon->grid, mon1->grid);
    if (!los(cave, mon->grid, mon1->grid)) {
      dist *= 2;
    }
    if (dist > 15) continue;
    if (!warned) {
      message_warning(mon);
      warned = true;
    }
    if (mon1->alertness >= ALERTNESS_ALERT) {
      mflag_on(mon1->mflag, (MFLAG_ACTIVE | flag));
    }
  }
}
STATIC_OVL void
monster_turn_hit_by_ranged(struct monster* mon)
{
  if (((mon->best_range == 1) && !square_isroom(cave, mon->grid)) ||
      !square_isview(cave, mon->grid)) {
    mflag_on(mon->mflag, MFLAG_AGGRESSIVE);
    if (rf_has(mon->race->flags, RF_SMART) && monster_talks_to_friends(mon)) {
      tell_allies(mon, MFLAG_AGGRESSIVE);
    }
    if (mon->race->freq_ranged) mflag_on(mon->mflag, MFLAG_ALWAYS_CAST);
    calc_monster_speed(mon);
  }
  mflag_off(mon->mflag, MFLAG_HIT_BY_RANGED);
}
STATIC_OVL void
monster_turn_hit_by_melee(struct monster* mon)
{
  if ((mon->cdis > 1) && !mflag_has(mon->mflag, MFLAG_PUSHED)) {
    mflag_on(mon->mflag, MFLAG_AGGRESSIVE);
    if (rf_has(mon->race->flags, RF_SMART) && monster_talks_to_friends(mon)) {
      tell_allies(mon, MFLAG_AGGRESSIVE);
    }
    if (mon->race->freq_ranged) mflag_on(mon->mflag, MFLAG_ALWAYS_CAST);
    calc_monster_speed(mon);
  }
  mflag_off(mon->mflag, MFLAG_HIT_BY_MELEE);
}
STATIC_OVL bool
multiply_monster(const struct monster* mon)
{
  struct loc grid;
  struct monster_group_info info = {0, 0};
  if (scatter_ext(cave, &grid, 1, mon->grid, 1, true, square_isempty) > 0) {
    return place_new_monster(cave, grid, mon->race, false, false, info,
                             ORIGIN_DROP_BREED);
  }
  return false;
}
STATIC_OVL bool
monster_turn_multiply(struct monster* mon)
{
  int k = 0, y, x;
  struct monster_lore* lore = get_lore(mon->race);
  if (!rf_has(mon->race->flags, RF_MULTIPLY)) return false;
  if (cave_monster_count(cave) > z_info->level_monster_max - 50) return false;
  for (y = mon->grid.y - 1; y <= mon->grid.y + 1; y++) {
    for (x = mon->grid.x - 1; x <= mon->grid.x + 1; x++) {
      if (!square_in_bounds(cave, loc(x, y))) continue;
      if (square(cave, loc(x, y))->mon > 0) k++;
    }
  }
  if ((k < 4) && one_in_(k * z_info->repro_monster_rate)) {
    if (multiply_monster(mon)) {
      if (monster_is_visible(mon)) {
        sound(MSG_MULTIPLY);
        rf_on(lore->flags, RF_MULTIPLY);
      }
      return true;
    }
  }
  return false;
}
STATIC_OVL bool
monster_turn_random_move(struct monster* mon)
{
  struct monster_lore* lore = get_lore(mon->race);
  int chance = 0;
  if (rf_has(mon->race->flags, RF_RAND_25)) {
    chance += 25;
    if (monster_is_visible(mon)) rf_on(lore->flags, RF_RAND_25);
  }
  if (rf_has(mon->race->flags, RF_RAND_50)) {
    chance += 50;
    if (monster_is_visible(mon)) rf_on(lore->flags, RF_RAND_50);
  }
  if (mon->cdis == 1) {
    chance /= 2;
  }
  return randint0(100) < chance;
}
STATIC_OVL void
monster_turn(struct monster* mon)
{
  struct song* mastery = lookup_song("Mastery");
  int i;
  struct loc tgrid = loc(0, 0), grid;
  bool random_move = false;
  bool fear = false;
  bool bash = false;
  bool must_use_target = false;
  mon->skip_this_turn = false;
  if (player_is_singing(player, mastery)) {
    int pskill =
        song_bonus(player, player->state.skill_use[SKILL_SONG], mastery);
    int mskill = monster_skill(mon, SKILL_WILL) + 5 +
                 flow_dist(cave->player_noise, mon->grid);
    if (skill_check(source_player(), pskill, mskill,
                    source_monster(mon->midx)) > 0) {
      mon->skip_this_turn = true;
      return;
    }
  }
  if (mon->song) {
    int dist = flow_dist(cave->player_noise, mon->grid);
    if ((mon->mana == 0) || ((mon->song == lookup_song("Piercing")) &&
                             (mon->alertness >= ALERTNESS_ALERT))) {
      if (monster_is_visible(mon)) {
        add_monster_message(mon, MON_MSG_END_SONG, false);
      } else if (dist <= 30) {
        msg("The song ends.");
      }
      mon->song = NULL;
    } else {
      mon->mana--;
      effect_simple(mon->song->effect->index, source_monster(mon->midx), "0", 0,
                    0, 0, NULL);
    }
  }
  if ((mon->race->light != 0) &&
      (mon->cdis < z_info->max_sight + ABS(mon->race->light))) {
    player->upkeep->update |= (PU_UPDATE_VIEW);
  }
  for (i = MAX_ACTION - 1; i > 0; i--) {
    mon->previous_action[i] = mon->previous_action[i - 1];
  }
  mon->previous_action[0] = ACTION_MISC;
  if (mon->alertness < ALERTNESS_ALERT) {
    monster_turn_wander(mon);
    return;
  }
  mon->flow.centre = player->grid;
  update_flow(cave, &mon->flow, mon);
  if (mon->min_range == 0) {
    monster_find_range(mon);
  }
  if (monster_check_active(mon)) {
    mflag_on(mon->mflag, MFLAG_ACTIVE);
  } else {
    mflag_off(mon->mflag, MFLAG_ACTIVE);
  }
  if (mflag_has(mon->mflag, MFLAG_HIT_BY_RANGED)) {
    monster_turn_hit_by_ranged(mon);
  }
  if (mflag_has(mon->mflag, MFLAG_HIT_BY_MELEE)) {
    monster_turn_hit_by_melee(mon);
  }
  if (one_in_(2) && rf_has(mon->race->flags, RF_SMART) &&
      square_isview(cave, mon->grid) && monster_has_sleeping_kin(mon) &&
      monster_talks_to_friends(mon)) {
    tell_allies(mon, MFLAG_ACTIVE);
    calc_monster_speed(mon);
  }
  mflag_off(mon->mflag, MFLAG_CHARGED);
  mflag_off(mon->mflag, MFLAG_PUSHED);
  if (!mflag_has(mon->mflag, MFLAG_ACTIVE)) {
    monster_turn_wander(mon);
    return;
  }
  if (player->upkeep->health_who == mon) player->upkeep->redraw |= (PR_HEALTH);
  if (monster_turn_multiply(mon)) return;
  if ((randint0(100) < monster_cast_chance(mon)) && make_ranged_attack(mon)) {
    return;
  }
  random_move = monster_turn_random_move(mon);
  if (!random_move) {
    if ((mon->stance == STANCE_AGGRESSIVE) && (!mon->race->freq_ranged)) {
      mon->target.grid = loc(0, 0);
    }
    if (square_isview(cave, mon->grid) && (mon->stance != STANCE_FLEEING)) {
      mon->target.grid = loc(0, 0);
    }
    if (!loc_eq(mon->target.grid, loc(0, 0))) {
      must_use_target = true;
    }
  }
  if (random_move) {
    int start = randint0(8);
    bool dummy, no_move = rf_has(mon->race->flags, RF_NEVER_MOVE);
    if (((mon->min_range >= z_info->flee_range) ||
         (mon->stance == STANCE_FLEEING)) &&
        !no_move) {
      fear = true;
    }
    for (i = start; i < 8 + start; i++) {
      grid = loc_sum(mon->grid, ddgrid_ddd[i % 8]);
      if (monster_entry_chance(cave, mon, grid, &dummy) != 0) {
        tgrid = grid;
        break;
      }
    }
    if (loc_eq(tgrid, loc(0, 0))) return;
    if (no_move && !square_isplayer(cave, tgrid)) return;
  } else {
    if ((mon->stance == STANCE_FLEEING) && (mon->morale < -200) &&
        !rf_has(mon->race->flags, RF_FLYING) && one_in_(2)) {
      struct loc chasm = loc(0, 0);
      for (i = 0; i < 8; i++) {
        grid = loc_sum(mon->grid, ddgrid_ddd[i]);
        if (!square_in_bounds(cave, grid)) continue;
        if (square_ischasm(cave, grid)) {
          chasm = grid;
          break;
        }
      }
      if (!loc_eq(chasm, loc(0, 0))) {
        monster_swap(mon->grid, chasm);
        return;
      }
    }
    if (!get_move(mon, &tgrid, &fear, must_use_target)) {
      return;
    }
  }
  if (loc_eq(tgrid, mon->grid)) {
    if (rf_has(mon->race->flags, RF_SMART) &&
        !rf_has(mon->race->flags, RF_TERRITORIAL) &&
        (mon->stance == STANCE_FLEEING) && square_isstairs(cave, tgrid)) {
      if (monster_is_visible(mon)) {
        if (square_isdownstairs(cave, tgrid)) {
          add_monster_message(mon, MON_MSG_FLEE_DOWN_STAIRS, true);
        } else {
          add_monster_message(mon, MON_MSG_FLEE_UP_STAIRS, true);
        }
      }
      player_opportunist_or_zone(player, tgrid, player->grid, true);
      delete_monster(cave, tgrid);
      return;
    }
    if ((mon->cdis > 1) && mon->race->freq_ranged) {
      make_ranged_attack(mon);
    }
    return;
  }
  if (!make_move(mon, &tgrid, fear, &bash)) return;
  process_move(mon, tgrid, bash);
}
STATIC_OVL void
regen_monster(struct monster* mon, int num)
{
  int regen_period = z_info->mon_regen_hp_period;
  if (mon->hp < mon->maxhp) {
    if (rf_has(mon->race->flags, RF_REGENERATE)) regen_period /= 5;
    mon->hp += regen_amount(turn / 10, mon->maxhp, regen_period);
    if (mon->hp > mon->maxhp) mon->hp = mon->maxhp;
    if (mon->hp == mon->maxhp) mon->min_range = 0;
    if (player->upkeep->health_who == mon)
      player->upkeep->redraw |= (PR_HEALTH);
  }
  if (mon->mana != z_info->mana_max) {
    if (!mon->song) {
      mon->mana += regen_amount(turn / 10, z_info->mana_max,
                                z_info->mon_regen_sp_period);
      if (mon->mana > z_info->mana_max) mon->mana = z_info->mana_max;
      if (mon->mana == z_info->mana_max) mon->min_range = 0;
    }
  }
}
STATIC_OVL void
process_monster_recover(struct monster* mon)
{
  int i;
  if (mflag_has(mon->mflag, MFLAG_SUMMONED)) {
    int still_singing = false;
    for (i = 1; i < cave_monster_max(cave); i++) {
      struct monster* mon1 = cave_monster(cave, i);
      if (!mon1->race) continue;
      if (mon1->song == lookup_song("Oaths")) {
        still_singing = true;
        break;
      }
    }
    if (!still_singing && one_in_(2)) {
      delete_monster(cave, mon->grid);
      return;
    }
  }
  for (i = 0; i < MON_TMD_MAX; i++) {
    if (mon->m_timed[i]) {
      mon_dec_timed(mon, i, 1, MON_TMD_FLG_NOTIFY);
    }
  }
  if (mon->tmp_morale != 0) {
    mon->tmp_morale *= 9;
    mon->tmp_morale /= 10;
  }
  if (player->upkeep->health_who == mon) player->upkeep->redraw |= (PR_HEALTH);
  if (!los(cave, mon->grid, player->grid) &&
      (mon->alertness >= ALERTNESS_ALERT) && (mon->stance != STANCE_FLEEING) &&
      (mon->race->sleep > 0)) {
    int bonus = player_active_ability(player, "Vanish") ? 15 : 25;
    int result = skill_check(source_monster(mon->midx),
                             monster_skill(mon, SKILL_PERCEPTION) + bonus,
                             player->state.skill_use[SKILL_STEALTH] +
                                 flow_dist(cave->player_noise, mon->grid),
                             source_player());
    if (result < 0) {
      set_alertness(mon, MAX(mon->alertness + result, ALERTNESS_UNWARY));
    }
  }
  calc_morale(mon);
  calc_stance(mon);
}
STATIC_OVL void
process_monsters(int minimum_energy)
{
  int i;
  bool regen = false;
  if (OPT(player, cheat_timestop)) return;
  if (turn % 10 == 0) regen = true;
  for (i = cave_monster_max(cave) - 1; i >= 1; i--) {
    struct monster* mon;
    bool moving;
    if (player->is_dead || player->upkeep->generate_level) break;
    mon = cave_monster(cave, i);
    if (!mon->race) continue;
    if (mflag_has(mon->mflag, MFLAG_HANDLED)) continue;
    if (mon->energy < minimum_energy) continue;
    moving = mon->energy >= z_info->move_energy ? true : false;
    mflag_on(mon->mflag, MFLAG_HANDLED);
    if (regen) regen_monster(mon, 1);
    mon->energy += turn_energy(mon->mspeed);
    if (!moving) continue;
    process_monster_recover(mon);
    mon->energy -= z_info->move_energy;
    if (mon->alertness < ALERTNESS_UNWARY) continue;
    if (mon->skip_next_turn) {
      mon->previous_action[0] = ACTION_MISC;
      mon->skip_next_turn = false;
      continue;
    }
    cave->mon_current = i;
    monster_turn(mon);
    cave->mon_current = -1;
  }
  player->upkeep->update |= PU_MONSTERS;
}
STATIC_OVL void
reset_monsters(void)
{
  int i;
  struct monster* mon;
  for (i = cave_monster_max(cave) - 1; i >= 1; i--) {
    mon = cave_monster(cave, i);
    mflag_off(mon->mflag, MFLAG_HANDLED);
  }
}
STATIC_OVL void
message_pain(struct monster* mon, int dam)
{
  int msg_code = MON_MSG_UNHARMED;
  struct monster_race* race =
      player->timed[TMD_IMAGE] ? mon->image_race : mon->race;
  if (race->base->pain == NULL) return;
  if (dam > 0) {
    long newhp = (long)(mon->hp);
    long oldhp = newhp + (long)(dam);
    long tmp = (newhp * 100L) / oldhp;
    int percentage = (int)(tmp);
    if (percentage > 66)
      msg_code = MON_MSG_66;
    else if (percentage > 33)
      msg_code = MON_MSG_33;
    else
      msg_code = MON_MSG_0;
  }
  add_monster_message(mon, msg_code, false);
}
STATIC_OVL void
message_pursuit(struct monster* mon)
{
  int msg_code = MON_MSG_NONE;
  int dist = distance(player->grid, mon->grid);
  struct monster_race* race =
      player->timed[TMD_IMAGE] ? mon->image_race : mon->race;
  if (race->base->pursuit == NULL) return;
  if (monster_is_visible(mon)) {
    msg_code = MON_MSG_PURSUE_VIS;
  } else if (dist < 20) {
    msg_code = MON_MSG_PURSUE_CLOSE;
  } else {
    msg_code = MON_MSG_PURSUE_FAR;
  }
  add_monster_message(mon, msg_code, false);
}
STATIC_OVL void
message_warning(struct monster* mon)
{
  int msg_code = MON_MSG_NONE;
  bool silence = player_is_singing(player, lookup_song("Silence"));
  struct monster_race* race =
      player->timed[TMD_IMAGE] ? mon->image_race : mon->race;
  if (race->base->warning == NULL) return;
  if (monster_is_visible(mon)) {
    if (silence) {
      msg_code = MON_MSG_WARN_VIS_SIL;
    } else {
      msg_code = MON_MSG_WARN_VIS;
    }
  } else if (silence) {
    msg_code = MON_MSG_WARN_INVIS_SIL;
  } else {
    msg_code = MON_MSG_WARN_INVIS;
  }
  add_monster_message(mon, msg_code, false);
  cave->monster_noise.centre = mon->grid;
  update_flow(cave, &cave->monster_noise, NULL);
  monsters_hear(false, false, -10);
  mon->noise += 10;
}
STATIC_OVL bool
redundant_monster_message(struct monster* mon, int msg_code)
{
  assert(mon);
  assert(msg_code >= 0);
  assert(msg_code < MON_MSG_MAX);
  for (int i = 0; i < size_mon_hist; i++) {
    if (mon == mon_message_hist[i].mon &&
        msg_code == mon_message_hist[i].message_code) {
      return true;
    }
  }
  return false;
}
STATIC_OVL int
message_flags(const struct monster* mon)
{
  int flags = 0;
  if (!panel_contains(mon->grid.y, mon->grid.x)) {
    flags |= 0x01;
  }
  if (!monster_is_visible(mon)) {
    flags |= 0x02;
  }
  return flags;
}
STATIC_OVL void
store_monster(struct monster* mon, int msg_code)
{
  if (size_mon_hist < 400) {
    mon_message_hist[size_mon_hist].mon = mon;
    mon_message_hist[size_mon_hist].message_code = msg_code;
    size_mon_hist++;
  }
}
STATIC_OVL bool
stack_message(struct monster* mon, int msg_code, int flags)
{
  int i;
  struct monster_race* race =
      player->timed[TMD_IMAGE] ? mon->image_race : mon->race;
  for (i = 0; i < size_mon_msg; i++) {
    if (mon_msg[i].race == race && mon_msg[i].flags == flags &&
        mon_msg[i].msg_code == msg_code) {
      mon_msg[i].count++;
      store_monster(mon, msg_code);
      return true;
    }
  }
  return false;
}
STATIC_OVL int
what_delay(int msg_code, int delay)
{
  if (msg_code == MON_MSG_DIE || msg_code == MON_MSG_DESTROYED) {
    return 2;
  } else {
    return delay ? 1 : 0;
  }
}
STATIC_OVL bool
add_monster_message(struct monster* mon, int msg_code, bool delay)
{
  assert(msg_code >= 0);
  assert(msg_code < MON_MSG_MAX);
  int flags = message_flags(mon);
  if (!redundant_monster_message(mon, msg_code) &&
      !stack_message(mon, msg_code, flags) && size_mon_msg < 200) {
    mon_msg[size_mon_msg].race =
        player->timed[TMD_IMAGE] ? mon->image_race : mon->race;
    mon_msg[size_mon_msg].flags = flags;
    mon_msg[size_mon_msg].msg_code = msg_code;
    mon_msg[size_mon_msg].count = 1;
    mon_msg[size_mon_msg].delay = what_delay(msg_code, delay);
    size_mon_msg++;
    store_monster(mon, msg_code);
    player->upkeep->notice |= PN_MON_MESSAGE;
    return true;
  } else {
    return false;
  }
}
STATIC_OVL void
get_subject(char* buf, size_t buflen, struct monster_race* race, int count,
            bool invisible, bool offscreen)
{
  if (invisible) {
    if (count == 1) {
      my_strcpy(buf, "It", buflen);
    } else {
      strnfmt(buf, buflen, "%d monsters", count);
    }
  } else {
    if (rf_has(race->flags, RF_UNIQUE)) {
      my_strcpy(buf, race->name, buflen);
    } else if (count == 1) {
      strnfmt(buf, buflen, "The %s", race->name);
    } else {
      if (race->plural != NULL) {
        strnfmt(buf, buflen, "%d %s", count, race->plural);
      } else {
        strnfmt(buf, buflen, "%d %s", count, race->name);
        plural_aux(buf, buflen);
      }
    }
    if (rf_has(race->flags, RF_NAME_COMMA)) {
      my_strcat(buf, ",", buflen);
    }
  }
  if (offscreen) my_strcat(buf, " (offscreen)", buflen);
  my_strcat(buf, " ", buflen);
}
STATIC_OVL void
get_message_text(char* buf, size_t buflen, int msg_code,
                 const struct monster_race* race, bool do_plural)
{
  assert(msg_code < MON_MSG_MAX);
  assert(race != NULL);
  assert(race->base != NULL);
  const char* source = msg_repository[msg_code].msg;
  switch (msg_code) {
    case MON_MSG_66: {
      assert(race->base->pain != NULL);
      source = race->base->pain->messages[0];
      break;
    }
    case MON_MSG_33: {
      assert(race->base->pain != NULL);
      source = race->base->pain->messages[1];
      break;
    }
    case MON_MSG_0: {
      assert(race->base->pain != NULL);
      source = race->base->pain->messages[2];
      break;
    }
    case MON_MSG_PURSUE_VIS: {
      assert(race->base->pursuit != NULL);
      source = race->base->pursuit->msg_vis;
      break;
    }
    case MON_MSG_PURSUE_CLOSE: {
      assert(race->base->pursuit != NULL);
      source = race->base->pursuit->msg_close;
      break;
    }
    case MON_MSG_PURSUE_FAR: {
      assert(race->base->pursuit != NULL);
      source = race->base->pursuit->msg_far;
      break;
    }
    case MON_MSG_WARN_VIS: {
      assert(race->base->warning != NULL);
      source = race->base->warning->msg_vis;
      break;
    }
    case MON_MSG_WARN_INVIS: {
      assert(race->base->warning != NULL);
      source = race->base->warning->msg_invis;
      break;
    }
    case MON_MSG_WARN_VIS_SIL: {
      assert(race->base->warning != NULL);
      source = race->base->warning->msg_vis_silence;
      break;
    }
    case MON_MSG_WARN_INVIS_SIL: {
      assert(race->base->warning != NULL);
      source = race->base->warning->msg_invis_silence;
      break;
    }
  }
  int state = 0;
  size_t maxlen = strlen(source);
  size_t pos = 0;
  for (size_t i = 0; i < maxlen && pos < buflen - 1; i++) {
    char cur = source[i];
    if (state == 0 && cur == '[') {
      state = 1;
    } else if (state == 1 && cur == '|') {
      state = 2;
    } else if (state != 0 && cur == ']') {
      state = 0;
    } else if (state == 0 || (state == 1 && do_plural == false) ||
               (state == 2 && do_plural == true)) {
      buf[pos++] = cur;
    }
  }
  assert(state == 0);
  buf[pos] = 0;
}
STATIC_OVL bool
skip_subject(int msg_code)
{
  assert(msg_code >= 0);
  assert(msg_code < MON_MSG_MAX);
  return msg_repository[msg_code].omit_subject;
}
STATIC_OVL int
get_message_type(int msg_code, const struct monster_race* race)
{
  int type = msg_repository[msg_code].type;
  if (type == MSG_KILL) {
    if (rf_has(race->flags, RF_UNIQUE)) {
      if (race->base == lookup_monster_base("Morgoth")) {
        type = MSG_KILL_KING;
      } else {
        type = MSG_KILL_UNIQUE;
      }
    }
  }
  return type;
}
STATIC_OVL void
show_message(struct monster_race_message* msg)
{
  char subject[60] = "";
  char body[60];
  if (!skip_subject(msg->msg_code)) {
    get_subject(subject, sizeof(subject), msg->race, msg->count,
                msg->flags & 0x02, msg->flags & 0x01);
  }
  get_message_text(body, sizeof(body), msg->msg_code, msg->race,
                   msg->count > 1);
  msgt(get_message_type(msg->msg_code, msg->race), "%s%s", subject, body);
}
STATIC_OVL void
show_monster_messages(void)
{
  for (int delay = 0; delay < 3; delay++) {
    for (int i = 0; i < size_mon_msg; i++) {
      struct monster_race_message* msg = &mon_msg[i];
      if (msg->delay == delay) {
        show_message(msg);
      }
    }
  }
  size_mon_msg = size_mon_hist = 0;
}
STATIC_OVL bool
monster_is_undead(const struct monster* mon)
{
  return rf_has(mon->race->flags, RF_UNDEAD);
}
STATIC_OVL bool
monster_is_nonliving(const struct monster* mon)
{
  return (monster_is_undead(mon) || rf_has(mon->race->flags, RF_RAUKO) ||
          rf_has(mon->race->flags, RF_STONE) ||
          (mon->race->base == lookup_monster_base("deathblade")));
}
STATIC_OVL bool
monster_is_living(const struct monster* mon)
{
  return !monster_is_nonliving(mon);
}
STATIC_OVL bool
monster_is_invisible(const struct monster* mon)
{
  return rf_has(mon->race->flags, RF_INVISIBLE);
}
STATIC_OVL bool
monster_is_unique(const struct monster* mon)
{
  return rf_has(mon->race->flags, RF_UNIQUE);
}
STATIC_OVL bool
monster_is_smart(const struct monster* mon)
{
  return rf_has(mon->race->flags, RF_SMART);
}
STATIC_OVL bool
monster_has_friends(const struct monster* mon)
{
  return rf_has(mon->race->flags, RF_FRIEND) ||
         rf_has(mon->race->flags, RF_FRIENDS) ||
         rf_has(mon->race->flags, RF_ESCORT) ||
         rf_has(mon->race->flags, RF_ESCORTS);
}
STATIC_OVL bool
monster_breathes(const struct monster* mon)
{
  bitflag breaths[RSF_SIZE];
  create_mon_spell_mask(breaths, RST_BREATH, RST_NONE);
  rsf_inter(breaths, mon->race->spell_flags);
  return rsf_is_empty(breaths) ? false : true;
}
STATIC_OVL bool
monster_is_in_view(const struct monster* mon)
{
  return mflag_has(mon->mflag, MFLAG_VIEW);
}
STATIC_OVL bool
monster_is_visible(const struct monster* mon)
{
  return mflag_has(mon->mflag, MFLAG_VISIBLE);
}
STATIC_OVL bool
monster_is_listened(const struct monster* mon)
{
  return mflag_has(mon->mflag, MFLAG_LISTENED);
}
STATIC_OVL spell_tag_t
spell_tag_lookup(const char* tag)
{
  if (strncmp(tag, "name", 4) == 0)
    return SPELL_TAG_NAME;
  else if (strncmp(tag, "pronoun", 7) == 0)
    return SPELL_TAG_PRONOUN;
  else
    return SPELL_TAG_NONE;
}
STATIC_OVL const char*
find_alternate_spell_message(const struct monster_race* r, int s_idx,
                             enum monster_altmsg_type msg_type)
{
  const struct monster_altmsg* am = r->spell_msgs;
  while (1) {
    if (!am) {
      return NULL;
    }
    if (am->index == s_idx && am->msg_type == msg_type) {
      return am->message;
    }
    am = am->next;
  }
}
STATIC_OVL void
spell_message(struct monster* mon, const struct monster_spell* spell, bool seen)
{
  const char punct[] = ".!?;:,'";
  char buf[1024] = "\0";
  const char* next;
  const char* s;
  const char* tag;
  const char* in_cursor;
  size_t end = 0;
  struct monster_spell_level* level = spell->level;
  bool smart = rf_has(mon->race->flags, RF_SMART);
  bool silence = player_is_singing(player, lookup_song("Silence"));
  bool is_leading;
  while (level->next && mon->race->spell_power >= level->next->power) {
    level = level->next;
  }
  if (!seen) {
    in_cursor = find_alternate_spell_message(mon->race, spell->index,
                                             MON_ALTMSG_UNSEEN);
    if (in_cursor == NULL) {
      if (smart &&
          (level->smart_blind_silence_message || level->smart_blind_message)) {
        if (silence && level->smart_blind_silence_message) {
          in_cursor = level->smart_blind_silence_message;
        } else {
          in_cursor = level->smart_blind_message;
        }
      } else {
        if (silence && level->blind_silence_message) {
          in_cursor = level->blind_silence_message;
        } else {
          in_cursor = level->blind_message;
        }
      }
      if (in_cursor == NULL) {
        msg("No message-invis for monster spell %d "
            "cast by %s%s.  Please report this "
            "bug.",
            (int)spell->index, (silence) ? "silenced " : "", mon->race->name);
        return;
      }
    } else if (in_cursor[0] == '\0') {
      return;
    }
  } else {
    in_cursor =
        find_alternate_spell_message(mon->race, spell->index, MON_ALTMSG_SEEN);
    if (in_cursor == NULL) {
      if (smart && (level->smart_silence_message || level->smart_message)) {
        if (silence && level->smart_silence_message) {
          in_cursor = level->smart_silence_message;
        } else {
          in_cursor = level->smart_message;
        }
      } else {
        if (silence && level->silence_message) {
          in_cursor = level->silence_message;
        } else {
          in_cursor = level->message;
        }
      }
      if (in_cursor == NULL) {
        msg("No message-vis for monster spell %d "
            "cast by %s%s.  Please report this "
            "bug.",
            (int)spell->index, (silence) ? "silenced " : "", mon->race->name);
        return;
      }
    } else if (in_cursor[0] == '\0') {
      return;
    }
  }
  next = strchr(in_cursor, '{');
  is_leading = (next == in_cursor);
  while (next) {
    strnfcat(buf, 1024, &end, "%.*s", (int)(next - in_cursor), in_cursor);
    s = next + 1;
    while (*s && isalpha((unsigned char)*s)) s++;
    if (*s == '}') {
      tag = next + 1;
      in_cursor = s + 1;
      switch (spell_tag_lookup(tag)) {
        case SPELL_TAG_NAME: {
          char m_name[80];
          int mdesc_mode = (MDESC_IND_HID | MDESC_PRO_HID);
          if (is_leading) {
            mdesc_mode |= MDESC_CAPITAL;
          }
          if (!strchr(punct, *in_cursor)) {
            mdesc_mode |= MDESC_COMMA;
          }
          monster_desc(m_name, sizeof(m_name), mon, mdesc_mode);
          strnfcat(buf, sizeof(buf), &end, "%s", m_name);
          break;
        }
        case SPELL_TAG_PRONOUN: {
          char m_poss[80];
          monster_desc(m_poss, sizeof(m_poss), mon, MDESC_PRO_VIS | MDESC_POSS);
          strnfcat(buf, sizeof(buf), &end, "%s", m_poss);
          break;
        }
        default: {
          break;
        }
      }
    } else {
      in_cursor = next + 1;
    }
    next = strchr(in_cursor, '{');
    is_leading = false;
  }
  strnfcat(buf, 1024, &end, "%s", in_cursor);
  msgt(spell->msgt, "%s", buf);
}
STATIC_OVL int
monster_cast_chance(struct monster* mon)
{
  int chance = mon->race->freq_ranged;
  if (!chance) return 0;
  if (mflag_has(mon->mflag, MFLAG_ALWAYS_CAST)) chance = 100;
  if (mon->m_timed[MON_TMD_CONF]) chance = 0;
  if (player->truce) chance = 0;
  if (mon->m_timed[MON_TMD_STUN]) chance /= 2;
  return chance;
}
STATIC_OVL const struct monster_spell*
monster_spell_by_index(int index)
{
  const struct monster_spell* spell = monster_spells;
  while (spell) {
    if (spell->index == index) break;
    spell = spell->next;
  }
  return spell;
}
STATIC_OVL bool
spell_check_for_save(const struct monster_spell* spell)
{
  struct effect* effect = spell->effect;
  bool save = false;
  while (effect) {
    if ((effect->index == EF_TIMED_INC) ||
        (effect->index == EF_TIMED_INC_NO_RES)) {
      save = player_inc_check(player, effect->subtype, false);
    } else {
      struct monster* mon =
          cave->mon_current > 0 ? cave_monster(cave, cave->mon_current) : NULL;
      save = player_saving_throw(player, mon, 0);
    }
    effect = effect->next;
  }
  return save;
}
STATIC_OVL void
do_mon_spell(int index, struct monster* mon, bool seen)
{
  const struct monster_spell* spell = monster_spell_by_index(index);
  struct monster_spell_level* level = spell->level;
  bool ident = false;
  bool afraid = player->timed[TMD_AFRAID] && (spell->index == RSF_SCARE);
  if (spell->effect_xtra && seen && one_in_(2)) seen = false;
  disturb(player, spell->disturb_stealth);
  spell_message(mon, spell, seen);
  while (level->next && mon->race->spell_power >= level->next->power) {
    level = level->next;
  }
  if (spell->effect_xtra && !seen) {
    effect_do(spell->effect_xtra, source_monster(mon->midx), NULL, &ident, true,
              0, NULL);
  }
  if (level->save_message && spell_check_for_save(spell) && !afraid) {
    msg("%s", level->save_message);
  } else {
    if (level->no_save_message) {
      msg("%s", level->no_save_message);
    }
    effect_do(spell->effect, source_monster(mon->midx), NULL, &ident, true, 0,
              NULL);
  }
}
STATIC_OVL bool
mon_spell_is_valid(int index)
{
  return index > RSF_NONE && index < RSF_MAX;
}
STATIC_OVL bool
mon_spell_is_archery(int index)
{
  return (mon_spell_types[index].type & RST_ARCHERY) ? true : false;
}
STATIC_OVL bool
mon_spell_is_breath(int index)
{
  return (mon_spell_types[index].type & RST_BREATH) ? true : false;
}
STATIC_OVL bool
mon_spell_is_innate(int index)
{
  return (mon_spell_types[index].type & RST_INNATE) ? true : false;
}
STATIC_OVL bool
mon_spell_is_distant(int index)
{
  return (mon_spell_types[index].type & RST_DISTANT) ? true : false;
}
STATIC_OVL bool
mon_spell_is_song(int index)
{
  return (mon_spell_types[index].type & RST_SONG) ? true : false;
}
STATIC_OVL void
monster_get_target_dist_grid(struct monster* mon, int* dist, struct loc* grid)
{
  if (dist) {
    *dist = mon->cdis;
  }
  if (grid) {
    *grid = player->grid;
  }
}
STATIC_OVL void
remove_bad_spells(struct monster* mon, bitflag f[RSF_SIZE])
{
  int tdist;
  struct loc tgrid;
  int path, i;
  monster_get_target_dist_grid(mon, &tdist, &tgrid);
  path = projectable(cave, mon->grid, tgrid, PROJECT_STOP);
  if (path == PROJECT_PATH_NO) {
    rsf_wipe(f);
    return;
  }
  for (i = FLAG_START; i != FLAG_END; i = rsf_next(f, i + 1)) {
    const struct monster_spell* spell;
    if (!rsf_has(f, i)) continue;
    spell = monster_spell_by_index(i);
    if (mon_spell_is_archery(i) && (path == PROJECT_PATH_NOT_CLEAR)) {
      rsf_off(f, i);
    }
    if (spell->mana > mon->mana) {
      rsf_off(f, i);
    }
    if (rf_has(mon->race->flags, RF_MINDLESS)) {
      continue;
    }
    if (tdist > spell->max_range) {
      rsf_off(f, i);
    }
    if (((tdist == 1) || (mon->stance == STANCE_FLEEING) || player->truce) &&
        (mon_spell_is_distant(i))) {
      rsf_off(f, i);
    }
    if ((mon->stance == STANCE_FLEEING) && mon_spell_is_breath(i)) {
      rsf_off(f, i);
    }
    if (mon_spell_is_song(i)) {
      const struct artifact* crown = lookup_artifact_name("of Morgoth");
      if (player->truce) {
        rsf_off(f, i);
      }
      if (rf_has(mon->race->flags, RF_QUESTOR) && !is_artifact_created(crown)) {
        rsf_off(f, i);
      }
    }
    if (i == RSF_EARTHQUAKE) {
      struct loc grid = player->grid;
      if (mon->grid.y > grid.y) {
        grid.y--;
      } else if (mon->grid.y < grid.y) {
        grid.y++;
      }
      if (mon->grid.x > grid.x) {
        grid.x--;
      } else if (mon->grid.x < grid.x) {
        grid.x++;
      }
      if (square_monster(cave, grid)) {
        rsf_off(f, i);
      }
    }
    if ((i == RSF_DARKNESS) && !square_islit(cave, player->grid)) {
      rsf_off(f, i);
    }
  }
}
STATIC_OVL void
create_mon_spell_mask(bitflag* f, ...)
{
  const struct mon_spell_info* rs;
  int i;
  va_list args;
  rsf_wipe(f);
  va_start(args, f);
  for (i = va_arg(args, int); i != RST_NONE; i = va_arg(args, int)) {
    for (rs = mon_spell_types; rs->index < RSF_MAX; rs++) {
      if (rs->type & i) {
        rsf_on(f, rs->index);
      }
    }
  }
  va_end(args);
  return;
}
STATIC_OVL const char*
mon_spell_lore_description(int index, const struct monster_race* race)
{
  if (mon_spell_is_valid(index)) {
    const struct monster_spell* spell = monster_spell_by_index(index);
    struct monster_spell_level* level = spell->level;
    while (level->next && race->spell_power >= level->next->power) {
      level = level->next;
    }
    return level->lore_desc;
  } else {
    return "";
  }
}
STATIC_OVL random_value
mon_spell_lore_damage(int index)
{
  random_value val = {0, 0, 0, 0};
  if (mon_spell_is_valid(index) &&
      (mon_spell_is_innate(index) || mon_spell_is_breath(index))) {
    const struct monster_spell* spell = monster_spell_by_index(index);
    if (spell->effect->dice != NULL) {
      (void)dice_roll(spell->effect->dice, &val);
    }
  }
  return val;
}
STATIC_OVL int
mon_spell_lore_archery_bonus(int index, const struct monster_race* race)
{
  int power = 0;
  if (mon_spell_is_valid(index) && mon_spell_is_archery(index)) {
    power = race->spell_power;
  }
  return power;
}
STATIC_OVL enum parser_error
parse_summon_name(struct parser* p)
{
  struct summon* h = parser_priv(p);
  struct summon* s = mem_zalloc(sizeof *s);
  s->next = h;
  parser_setpriv(p, s);
  s->name = string_make(parser_getstr(p, "name"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_summon_message_type(struct parser* p)
{
  struct summon* s = parser_priv(p);
  int msg_index;
  const char* type;
  assert(s);
  type = parser_getsym(p, "type");
  msg_index = message_lookup_by_name(type);
  if (msg_index < 0) return PARSE_ERROR_INVALID_MESSAGE;
  s->message_type = msg_index;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_summon_unique(struct parser* p)
{
  struct summon* s = parser_priv(p);
  int unique = 0;
  assert(s);
  unique = parser_getint(p, "allowed");
  if (unique) {
    s->unique_allowed = true;
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_summon_base(struct parser* p)
{
  struct summon* s = parser_priv(p);
  struct monster_base* base;
  struct monster_base_list* b = mem_zalloc(sizeof(*b));
  assert(s);
  base = lookup_monster_base(parser_getsym(p, "base"));
  if (base == NULL) {
    mem_free(b);
    return PARSE_ERROR_INVALID_MONSTER_BASE;
  }
  b->base = base;
  b->next = s->bases;
  s->bases = b;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_summon_race_flag(struct parser* p)
{
  struct summon* s = parser_priv(p);
  int flag;
  assert(s);
  flag = lookup_flag(mon_race_flags, parser_getsym(p, "flag"));
  if (flag == FLAG_END) {
    return PARSE_ERROR_INVALID_FLAG;
  } else {
    s->race_flag = flag;
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_summon_fallback(struct parser* p)
{
  struct summon* s = parser_priv(p);
  assert(s);
  s->fallback_name = string_make(parser_getstr(p, "fallback"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_summon_desc(struct parser* p)
{
  struct summon* s = parser_priv(p);
  assert(s);
  s->desc = string_make(parser_getstr(p, "desc"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_parse_summon(void)
{
  struct parser* p = parser_new();
  parser_setpriv(p, NULL);
  parser_reg(p, "name str name", parse_summon_name);
  parser_reg(p, "msgt sym type", parse_summon_message_type);
  parser_reg(p, "uniques int allowed", parse_summon_unique);
  parser_reg(p, "base sym base", parse_summon_base);
  parser_reg(p, "race-flag sym flag", parse_summon_race_flag);
  parser_reg(p, "fallback str fallback", parse_summon_fallback);
  parser_reg(p, "desc str desc", parse_summon_desc);
  return p;
}
STATIC_OVL errr
run_parse_summon(struct parser* p)
{
  return parse_file_quit_not_found(p, "summon");
}
STATIC_OVL errr
finish_parse_summon(struct parser* p)
{
  struct summon *summon, *next;
  int index;
  summon_max = 0;
  summon = parser_priv(p);
  while (summon) {
    summon_max++;
    summon = summon->next;
  }
  summons = mem_zalloc((summon_max + 1) * sizeof(*summon));
  index = summon_max - 1;
  for (summon = parser_priv(p); summon; summon = next, index--) {
    memcpy(&summons[index], summon, sizeof(*summon));
    next = summon->next;
    summons[index].next = NULL;
    mem_free(summon);
  }
  summon_max += 1;
  for (index = 0; index < summon_max; index++) {
    char* name = summons[index].fallback_name;
    summons[index].fallback = summon_name_to_idx(name);
  }
  parser_destroy(p);
  return 0;
}
STATIC_OVL void
cleanup_summon(void)
{
  int idx;
  for (idx = 0; idx < summon_max; idx++) {
    struct monster_base_list* s = summons[idx].bases;
    while (s) {
      struct monster_base_list* next = s->next;
      mem_free(s);
      s = next;
    }
    string_free(summons[idx].desc);
    string_free(summons[idx].fallback_name);
    string_free(summons[idx].name);
  }
  mem_free(summons);
}
STATIC_OVL int
summon_name_to_idx(const char* name)
{
  int i;
  for (i = 0; i < summon_max; i++) {
    if (name && summons[i].name && streq(name, summons[i].name)) {
      return i;
    }
  }
  return -1;
}
STATIC_OVL int
summon_message_type(int summon_type)
{
  return summons[summon_type].message_type;
}
STATIC_OVL int
summon_fallback_type(int summon_type)
{
  return summons[summon_type].fallback;
}
STATIC_OVL const char*
summon_desc(int type)
{
  if (type < 0 || type >= summon_max) return 0;
  return summons[type].desc;
}
STATIC_OVL bool
summon_specific_okay(struct monster_race* race)
{
  struct summon* summon = &summons[summon_specific_type];
  struct monster_base_list* bases = summon->bases;
  bool unique = rf_has(race->flags, RF_UNIQUE);
  if (!summon->unique_allowed && unique) {
    return false;
  }
  while (bases) {
    if (race->base == bases->base) break;
    if (bases->next == NULL) return false;
    bases = bases->next;
  }
  if (summon->race_flag && !rf_has(race->flags, summon->race_flag)) {
    return false;
  }
  if (summon_specific_type == summon_name_to_idx("KIN")) {
    return (!unique && race->base == kin_base);
  }
  return true;
}
STATIC_OVL int
summon_specific(struct loc grid, int lev, int type)
{
  int d;
  struct loc near = grid;
  struct monster_race* race;
  struct monster_group_info info = {0, 0};
  for (d = 1; d < 5; ++d) {
    if (scatter_ext(cave, &near, 1, grid, d, true, square_allows_summon) > 0)
      break;
  }
  if (d == 5) return 0;
  summon_specific_type = type;
  get_mon_num_prep(summon_specific_okay);
  race = get_mon_num(lev, false, true, false);
  get_mon_num_prep(NULL);
  if (!race) return 0;
  if (!place_new_monster(cave, near, race, false, false, info,
                         ORIGIN_DROP_SUMMON)) {
    return 0;
  }
  return 1;
}
STATIC_OVL int
mon_timed_name_to_idx(const char* name)
{
  for (size_t i = 0; i < MON_TMD_MAX; i++) {
    if (streq(name, teffects[i].name)) return i;
  }
  return -1;
}
STATIC_OVL bool
mon_set_timed(struct monster* mon, int effect_type, int timer, int flag)
{
  assert(mon != NULL);
  assert(mon->race != NULL);
  assert(effect_type >= 0);
  assert(effect_type < MON_TMD_MAX);
  assert(timer >= 0);
  struct mon_timed_effect* effect = &teffects[effect_type];
  int m_note = 0;
  int old_timer = mon->m_timed[effect_type];
  if (timer > effect->max_timer) {
    timer = effect->max_timer;
  }
  if (old_timer == timer) {
    return false;
  } else if (timer == 0) {
    m_note = effect->message_end;
    flag |= MON_TMD_FLG_NOTIFY;
  } else if (old_timer == 0) {
    m_note = effect->message_begin;
    flag |= MON_TMD_FLG_NOTIFY;
  } else if (timer > old_timer) {
    m_note = effect->message_increase;
  }
  mon->m_timed[effect_type] = timer;
  calc_monster_speed(mon);
  if (m_note && !(flag & MON_TMD_FLG_NOMESSAGE) &&
      (flag & MON_TMD_FLG_NOTIFY) && monster_is_visible(mon)) {
    add_monster_message(mon, m_note, true);
  }
  if (player->upkeep->health_who == mon) player->upkeep->redraw |= (PR_HEALTH);
  player->upkeep->redraw |= (PR_MONLIST);
  return true;
}
STATIC_OVL bool
mon_inc_timed(struct monster* mon, int effect_type, int timer, int flag)
{
  assert(effect_type >= 0);
  assert(effect_type < MON_TMD_MAX);
  assert(timer > 0);
  struct mon_timed_effect* effect = &teffects[effect_type];
  int new_value = timer;
  if (mon->m_timed[effect_type] == 0 && timer < 2) {
    timer = 2;
  }
  switch (effect->stacking) {
    case STACK_NO: {
      new_value = mon->m_timed[effect_type];
      if (new_value == 0) {
        new_value = timer;
      }
      break;
    }
    case STACK_MAX: {
      new_value = MAX(mon->m_timed[effect_type], timer);
      break;
    }
    case STACK_INCR: {
      new_value = mon->m_timed[effect_type] + timer;
      break;
    }
  }
  return mon_set_timed(mon, effect_type, new_value, flag);
}
STATIC_OVL bool
mon_dec_timed(struct monster* mon, int effect_type, int timer, int flag)
{
  assert(effect_type >= 0);
  assert(effect_type < MON_TMD_MAX);
  assert(timer > 0);
  int new_level = mon->m_timed[effect_type] - timer;
  if (new_level < 0) {
    new_level = 0;
  }
  return mon_set_timed(mon, effect_type, new_level, flag);
}
STATIC_OVL bool
mon_clear_timed(struct monster* mon, int effect_type, int flag)
{
  assert(effect_type >= 0);
  assert(effect_type < MON_TMD_MAX);
  if (mon->m_timed[effect_type] == 0) {
    return false;
  } else {
    return mon_set_timed(mon, effect_type, 0, flag);
  }
}
STATIC_OVL const char*
describe_race_flag(int flag)
{
  const struct monster_flag* rf = &monster_flag_table[flag];
  if (flag <= RF_NONE || flag >= RF_MAX) return "";
  return rf->desc;
}
STATIC_OVL void
create_mon_flag_mask(bitflag* f, ...)
{
  const struct monster_flag* rf;
  int i;
  va_list args;
  rf_wipe(f);
  va_start(args, f);
  for (i = va_arg(args, int); i != RFT_MAX; i = va_arg(args, int)) {
    for (rf = monster_flag_table; rf->index < RF_MAX; rf++)
      if (rf->type == i) rf_on(f, rf->index);
  }
  va_end(args);
  return;
}
STATIC_OVL struct monster_race*
lookup_monster(const char* name)
{
  int i;
  struct monster_race* closest = NULL;
  for (i = 0; i < z_info->r_max; i++) {
    struct monster_race* race = &r_info[i];
    if (!race->name) continue;
    if (my_stricmp(name, race->name) == 0) return race;
    if (!closest && my_stristr(race->name, name)) closest = race;
  }
  return closest;
}
STATIC_OVL struct monster_base*
lookup_monster_base(const char* name)
{
  struct monster_base* base;
  for (base = rb_info; base; base = base->next) {
    if (streq(name, base->name)) return base;
  }
  return NULL;
}
STATIC_OVL bool
match_monster_bases(const struct monster_base* base, ...)
{
  bool ok = false;
  va_list vp;
  char* name;
  va_start(vp, base);
  while (!ok && ((name = va_arg(vp, char*)) != NULL))
    ok = base == lookup_monster_base(name);
  va_end(vp);
  return ok;
}
STATIC_OVL void
monster_fall_in_chasm(struct loc grid)
{
  struct monster* mon = square_monster(cave, grid);
  struct monster_race* race = mon ? mon->race : NULL;
  ;
  char m_name[80];
  int dice;
  int dam;
  if (!mon) return;
  if (square_ischasm(cave, grid) && !rf_has(race->flags, RF_FLYING)) {
    monster_desc(m_name, sizeof(m_name), mon, MDESC_DEFAULT);
    if (monster_is_visible(mon)) {
      if (mon->morale < -200) {
        msg("%s leaps into the abyss!", m_name);
      } else {
        msg("%s topples into the abyss!", m_name);
      }
    }
    event_signal(EVENT_MESSAGE_FLUSH);
    if (player->depth == z_info->dun_depth - 2) {
      dice = 3;
    } else {
      dice = 6;
    }
    dam = damroll(dice, 4);
    if (monster_is_visible(mon)) {
      event_signal_combat_attack(EVENT_COMBAT_ATTACK, source_grid(grid),
                                 source_monster(mon->midx), true, -1, -1, -1,
                                 -1, false);
      event_signal_combat_damage(EVENT_COMBAT_DAMAGE, dice, 4, dam, -1, -1, 0,
                                 0, PROJ_HURT, false);
    }
    if (mon->hp <= dam) {
      monster_death(mon, player, true, NULL, false);
      delete_monster(cave, grid);
    } else {
      delete_monster(cave, grid);
    }
  }
}
STATIC_OVL void
monster_opportunist_or_zone(struct player* p, struct loc grid_to)
{
  int y, x;
  for (y = p->grid.y - 1; y <= p->grid.y + 1; y++) {
    for (x = p->grid.x - 1; x <= p->grid.x + 1; x++) {
      struct loc grid = loc(x, y);
      char m_name[80];
      struct monster* mon = square_monster(cave, grid);
      if (mon && (mon->alertness >= ALERTNESS_ALERT) &&
          !mon->m_timed[MON_TMD_CONF] && !mon->skip_next_turn &&
          (mon->stance != STANCE_FLEEING) && !mon->skip_this_turn) {
        bool opp = rf_has(mon->race->flags, RF_OPPORTUNIST);
        bool zone = rf_has(mon->race->flags, RF_ZONE);
        struct monster_lore* lore = get_lore(mon->race);
        if (opp && (distance(grid_to, grid) > 1)) {
          monster_desc(m_name, sizeof(m_name), mon, MDESC_STANDARD);
          msg("%s attacks you as you step away.", m_name);
          make_attack_normal(mon, p);
          if (monster_is_visible(mon)) {
            rf_on(lore->flags, RF_OPPORTUNIST);
          }
        }
        if (zone && (distance(grid_to, p->grid) == 1)) {
          monster_desc(m_name, sizeof(m_name), mon, MDESC_POSS);
          msg("You move through %s zone of control.", m_name);
          make_attack_normal(mon, p);
          if (monster_is_visible(mon)) {
            rf_on(lore->flags, RF_ZONE);
          }
        }
      }
    }
  }
}
STATIC_OVL void
monster_swap(struct loc grid1, struct loc grid2)
{
  struct monster* mon;
  int m1 = square(cave, grid1)->mon;
  int m2 = square(cave, grid2)->mon;
  bool m1_is_monster = false;
  if (loc_eq(grid1, grid2)) return;
  if (m1 > 0) {
    m1_is_monster = true;
    mon = cave_monster(cave, m1);
    player_opportunist_or_zone(player, grid1, grid2, false);
    if (mon->hp <= 0) return;
    if (mon->noise == 0) {
      mon->noise = 5;
    }
    mon->grid = grid2;
    update_mon(mon, cave, true);
    if (mon->race->light != 0)
      player->upkeep->update |= PU_UPDATE_VIEW | PU_MONSTERS;
    player->upkeep->redraw |= (PR_MONLIST);
  } else if (m1 < 0) {
    monster_opportunist_or_zone(player, grid2);
    if (player->chp < 0) return;
    player->grid = grid2;
    player->upkeep->update |= (PU_PANEL | PU_UPDATE_VIEW | PU_DISTANCE);
    player->upkeep->redraw |= (PR_MONLIST);
    cmd_disable_repeat_floor_item();
  }
  if (m2 > 0) {
    mon = cave_monster(cave, m2);
    if (mon->noise == 0) {
      mon->noise = 5;
    }
    mon->grid = grid1;
    update_mon(mon, cave, true);
    if (mon->race->light != 0)
      player->upkeep->update |= PU_UPDATE_VIEW | PU_MONSTERS;
    player->upkeep->redraw |= (PR_MONLIST);
  } else if (m2 < 0) {
    player->grid = grid1;
    player->upkeep->update |= (PU_PANEL | PU_UPDATE_VIEW | PU_DISTANCE);
    player->upkeep->redraw |= (PR_MONLIST);
    cmd_disable_repeat_floor_item();
  }
  square_set_mon(cave, grid1, m2);
  square_set_mon(cave, grid2, m1);
  square_light_spot(cave, grid1);
  square_light_spot(cave, grid2);
  if (player_active_ability(player, "Polearm Mastery") && m1_is_monster) {
    player_polearm_passive_attack(player, grid1, grid2);
  }
  if (m1 > 0) monster_fall_in_chasm(grid2);
  if (m2 > 0) monster_fall_in_chasm(grid1);
  if ((m1 < 0) || (m2 < 0)) {
    event_signal(EVENT_SEEFLOOR);
  }
}
STATIC_OVL bool
monster_can_see(struct chunk* c, struct monster* mon, struct loc grid)
{
  return los(c, mon->grid, grid);
}
STATIC_OVL void
monsters_hear(bool player_centered, bool main_roll, int difficulty)
{
  int i;
  int m_perception;
  int result;
  int noise_dist;
  int difficulty_roll;
  int difficulty_roll_alt;
  int combat_noise_bonus = 0;
  int combat_sight_bonus = 0;
  struct song* silence = lookup_song("Silence");
  if (player->is_dead || !player->upkeep->playing ||
      player->upkeep->generate_level)
    return;
  if (turn == 0) return;
  if (OPT(player, cheat_timestop)) return;
  if (main_roll) {
    if (player->attacked) {
      combat_noise_bonus += 2;
      combat_sight_bonus += 2;
      player->attacked = false;
      player->consecutive_attacks++;
    }
    if (player->been_attacked) {
      combat_noise_bonus += 2;
      combat_sight_bonus += 2;
      player->been_attacked = false;
    }
  }
  difficulty_roll = difficulty + randint1(10);
  difficulty_roll_alt = difficulty + randint1(10);
  if (player->cursed && player_centered) {
    difficulty_roll = MIN(difficulty_roll, difficulty_roll_alt);
  }
  if (player_is_singing(player, silence)) {
    difficulty_roll +=
        song_bonus(player, player->state.skill_use[SKILL_SONG], silence);
  }
  for (i = cave_monster_max(cave) - 1; i >= 1; i--) {
    struct monster* mon = cave_monster(cave, i);
    if (!mon->race) continue;
    if (rf_has(mon->race->flags, RF_SHORT_SIGHTED) && (mon->cdis > 2)) {
      continue;
    }
    if (player_centered) {
      noise_dist = flow_dist(cave->player_noise, mon->grid);
    } else {
      noise_dist = flow_dist(cave->monster_noise, mon->grid);
    }
    m_perception =
        monster_skill(mon, SKILL_PERCEPTION) - noise_dist + combat_noise_bonus;
    m_perception -= player_bane_bonus(player, mon);
    m_perception += monster_elf_bane_bonus(mon, player);
    if (player->on_the_run) {
      m_perception += 5;
    }
    if (mon->alertness >= ALERTNESS_ALERT) {
      m_perception -= mon->alertness;
    }
    if (player->state.flags[OF_AGGRAVATE] &&
        (mon->alertness >= ALERTNESS_UNWARY) &&
        !rf_has(mon->race->flags, RF_MINDLESS)) {
      m_perception += player->state.flags[OF_AGGRAVATE] * 10;
      if (monster_is_in_view(mon)) {
        equip_learn_flag(player, OF_AGGRAVATE);
      }
    }
    if (los(cave, mon->grid, player->grid) &&
        (mon->alertness >= ALERTNESS_UNWARY)) {
      int d, dir, open_squares = 0;
      struct loc grid;
      for (d = 0; d < 8; d++) {
        dir = cycle[d];
        grid = loc_sum(player->grid, ddgrid[dir]);
        if (square_ispassable(cave, grid)) {
          open_squares++;
        }
      }
      if (player_active_ability(player, "Disguise")) {
        m_perception += (open_squares + combat_sight_bonus) / 2;
      } else {
        m_perception += open_squares + combat_sight_bonus;
      }
    }
    result = (m_perception + randint1(10)) - difficulty_roll;
    if (OPT(player, cheat_skill_rolls)) {
      msg("{%d+%d v %d+%d = %d}.", result - m_perception + difficulty_roll,
          m_perception, difficulty_roll - difficulty, difficulty, result);
    }
    if (result > 0) {
      struct monster_lore* lore = get_lore(mon->race);
      set_alertness(mon, mon->alertness + result);
      if (mon->alertness < ALERTNESS_ALERT) {
        if (monster_is_visible(mon) && (lore->ignore < UCHAR_MAX)) {
          lore->ignore++;
        }
      } else {
        if (monster_is_visible(mon) && (lore->notice < UCHAR_MAX)) {
          lore->notice++;
        }
      }
    }
  }
}
STATIC_OVL int32_t
adjusted_mon_exp(const struct monster_race* race, bool kill)
{
  int32_t exp;
  int mexp = race->level * 10;
  struct monster_lore* lore = get_lore(race);
  if (kill) {
    if (rf_has(race->flags, RF_UNIQUE)) {
      exp = mexp;
    } else {
      exp = (mexp) / (lore->pkills + 1);
    }
  } else {
    if (rf_has(race->flags, RF_UNIQUE)) {
      exp = mexp;
    } else {
      exp = (mexp) / (lore->psights + 1);
    }
  }
  return exp;
}
STATIC_OVL int
mon_create_drop_count(const struct monster_race* race, bool maximize)
{
  int number = 0;
  if (maximize) {
    if (rf_has(race->flags, RF_DROP_33)) number++;
    if (rf_has(race->flags, RF_DROP_100)) number++;
    if (rf_has(race->flags, RF_DROP_1D2)) number += 2;
    if (rf_has(race->flags, RF_DROP_2D2)) number += 4;
    if (rf_has(race->flags, RF_DROP_3D2)) number += 6;
    if (rf_has(race->flags, RF_DROP_4D2)) number += 8;
  } else {
    if (rf_has(race->flags, RF_DROP_33) && percent_chance(33)) number++;
    if (rf_has(race->flags, RF_DROP_100)) number++;
    if (rf_has(race->flags, RF_DROP_1D2)) number += damroll(1, 2);
    if (rf_has(race->flags, RF_DROP_2D2)) number += damroll(2, 2);
    if (rf_has(race->flags, RF_DROP_3D2)) number += damroll(3, 2);
    if (rf_has(race->flags, RF_DROP_4D2)) number += damroll(4, 2);
  }
  return number;
}
STATIC_OVL int
mon_create_drop(struct chunk* c, struct monster* mon, struct loc grid,
                bool stats)
{
  struct monster_drop* drop;
  bool great, good;
  bool visible;
  int number = 0, count = 0, level, j;
  struct object* obj;
  assert(mon);
  great = rf_has(mon->race->flags, RF_DROP_GREAT);
  good = rf_has(mon->race->flags, RF_DROP_GOOD);
  visible = monster_is_visible(mon) || monster_is_unique(mon);
  number = mon_create_drop_count(mon->race, false);
  level = mon->race->level;
  for (drop = mon->race->drops; drop; drop = drop->next) {
    if (percent_chance((int)drop->percent_chance)) {
      if (drop->kind) {
        obj = mem_zalloc(sizeof(*obj));
        object_prep(obj, drop->kind, level, RANDOMISE);
        obj->number = randcalc(drop->dice, 0, RANDOMISE);
        if (streq(mon->race->base->name, "deathblade")) {
          apply_magic(obj, c->depth, false, false, false);
        }
      } else {
        const struct artifact* art;
        struct object_kind* kind;
        assert(drop->art);
        art = drop->art;
        kind = lookup_kind(art->tval, art->sval);
        obj = mem_zalloc(sizeof(*obj));
        object_prep(obj, kind, 100, RANDOMISE);
        obj->artifact = art;
        copy_artifact_data(obj, obj->artifact);
        mark_artifact_created(art, true);
      }
      if (!obj) continue;
      obj->origin = visible || stats ? mon->origin : ORIGIN_DROP_UNKNOWN;
      obj->origin_depth = convert_depth_to_origin(c->depth);
      obj->origin_race = mon->race;
      number--;
      count++;
      drop_near(c, &obj, 0, grid, true, false);
    }
  }
  for (j = 0; j < number; j++) {
    obj = make_object(c, level, good, great, lookup_drop("not useless"));
    if (!obj) continue;
    obj->origin = visible || stats ? mon->origin : ORIGIN_DROP_UNKNOWN;
    obj->origin_depth = convert_depth_to_origin(c->depth);
    obj->origin_race = mon->race;
    count++;
    drop_near(c, &obj, 0, grid, true, false);
  }
  return count;
}
STATIC_OVL void
drop_loot(struct chunk* c, struct monster* mon, struct loc grid, bool stats)
{
  int dump_item;
  struct object* obj = mon->held_obj;
  bool visible = monster_is_visible(mon) || monster_is_unique(mon);
  bool stair = square_isstairs(c, grid) || square_isshaft(c, grid);
  if (rf_has(mon->race->flags, RF_STONE) && !stair) {
    square_set_feat(c, grid, FEAT_RUBBLE);
  }
  while (obj) {
    struct object* next = obj->next;
    obj->held_m_idx = 0;
    pile_excise(&mon->held_obj, obj);
    if (!visible && !stats) obj->origin = ORIGIN_DROP_UNKNOWN;
    drop_near(c, &obj, 0, grid, (c == cave), false);
    obj = next;
  }
  mon->held_obj = NULL;
  dump_item = mon_create_drop(c, mon, grid, stats);
  if (visible && dump_item && stats) {
    lore_treasure(mon, dump_item);
  }
}
STATIC_OVL void
monster_death(struct monster* mon, struct player* p, bool by_player,
              const char* note, bool stats)
{
  int32_t new_exp;
  struct monster_race* race = mon->race;
  struct monster_lore* lore = get_lore(mon->race);
  char m_name[80];
  char buf[80];
  int desc_mode = MDESC_DEFAULT | ((note) ? MDESC_COMMA : 0);
  int multiplier = 1;
  int soundfx = MSG_KILL;
  bool chasm =
      square_ischasm(cave, mon->grid) && !rf_has(mon->race->flags, RF_FLYING);
  monster_desc(m_name, sizeof(m_name), mon, desc_mode);
  if (rf_has(race->flags, RF_UNIQUE)) {
    if (race->base == lookup_monster_base("Morgoth")) {
      soundfx = MSG_KILL_KING;
      p->morgoth_slain = true;
      msg("BUG: Morgoth has been defeated in combat.");
      msg("But this is not possible within the fates Illuvatar has decreed.");
      msg("Please post an 'ultimate bug-report' on http://angband.live/forums/ "
          "explaining how this happened.");
      msg("But for now, let's run with it, since it's undeniably impressive.");
      event_signal_poem(EVENT_POEM, "ultimate_bug", 5, 15);
    } else {
      soundfx = MSG_KILL_UNIQUE;
    }
  }
  if (note) {
    if (strlen(note) <= 1) {
    } else {
      notice_stuff(p);
      my_strcap(m_name);
      msgt(soundfx, "%s%s", m_name, note);
    }
  } else {
    notice_stuff(p);
    if (!monster_is_visible(mon)) {
      if (by_player && (distance(mon->grid, p->grid) == 1)) {
        msgt(soundfx, "You have killed %s.", m_name);
      }
    } else if (monster_is_nonliving(mon)) {
      if (streq(race->base->name, "deathblade")) {
        if (by_player) {
          msgt(soundfx, "You have subdued %s.", m_name);
        } else {
          my_strcap(m_name);
          msgt(soundfx, "%s has been subdued.", m_name);
        }
      } else {
        if (by_player) {
          msgt(soundfx, "You have destroyed %s.", m_name);
        } else {
          my_strcap(m_name);
          msgt(soundfx, "%s has been destroyed.", m_name);
        }
      }
    } else {
      if (by_player) {
        msgt(soundfx, "You have slain %s.", m_name);
      } else {
        my_strcap(m_name);
        msgt(soundfx, "%s has been slain.", m_name);
      }
    }
  }
  new_exp = adjusted_mon_exp(race, true);
  player_exp_gain(p, new_exp);
  p->kill_exp += new_exp;
  if (rf_has(race->flags, RF_UNIQUE)) {
    char unique_name[80];
    race->max_num = 0;
    monster_desc(unique_name, sizeof(unique_name), mon, MDESC_DIED_FROM);
    if (streq(race->base->name, "deathblade")) {
      strnfmt(buf, sizeof(buf), "Subdued %s", unique_name);
    } else if (monster_is_nonliving(mon)) {
      strnfmt(buf, sizeof(buf), "Destroyed %s", unique_name);
    } else {
      strnfmt(buf, sizeof(buf), "Killed %s", unique_name);
    }
    history_add(p, buf, HIST_SLAY_UNIQUE);
  }
  if (lore->pkills < SHRT_MAX) lore->pkills++;
  if (lore->tkills < SHRT_MAX) lore->tkills++;
  if (!mon->encountered) {
    new_exp = adjusted_mon_exp(mon->race, false);
    player_exp_gain(p, new_exp);
    p->encounter_exp += new_exp;
    mon->encountered = true;
    lore->psights++;
    if (lore->tsights < SHRT_MAX) lore->tsights++;
  }
  lore_update(mon->race, lore);
  monster_race_track(p->upkeep, mon->race);
  if (rf_has(race->flags, RF_ESCORT) || rf_has(race->flags, RF_ESCORTS)) {
    multiplier = 4;
  }
  scare_onlooking_friends(mon, -40 * multiplier);
  if (!chasm && !rf_has(mon->race->flags, RF_TERRITORIAL)) {
    drop_loot(cave, mon, mon->grid, false);
  }
  p->upkeep->redraw |= PR_MONLIST;
  delete_monster_idx(cave, mon->midx);
}
STATIC_OVL bool
mon_take_hit(struct monster* mon, struct player* p, int dam, const char* note)
{
  if (p->upkeep->health_who == mon) p->upkeep->redraw |= (PR_HEALTH);
  if (dam == 0) return false;
  mon->hp -= dam;
  if (mon->hp <= 0) {
    monster_death(mon, p, true, note, false);
    return true;
  }
  if (dam > 0) {
    make_alert(mon, dam);
    if (dam > 0) mon->min_range = 0;
  }
  mflag_on(mon->mflag, MFLAG_ACTIVE);
  return false;
}
STATIC_OVL bool
similar_monsters(struct monster* mon1, struct monster* mon2)
{
  bitflag mask[RF_SIZE];
  if (!mon1 || !mon2) return false;
  if (mon1->race->base == mon2->race->base) return true;
  create_mon_flag_mask(mask, RFT_RACE_N, RFT_MAX);
  rf_inter(mask, mon1->race->flags);
  if (rf_is_inter(mask, mon2->race->flags)) return true;
  return false;
}
STATIC_OVL void
scare_onlooking_friends(const struct monster* mon, int amount)
{
  int i;
  for (i = 1; i < cave_monster_max(cave); i++) {
    struct monster* mon1 = cave_monster(cave, i);
    ;
    struct monster_race* race = mon1->race;
    if (!race) continue;
    if ((mon1->alertness >= ALERTNESS_ALERT) &&
        !rf_has(race->flags, RF_NO_FEAR) &&
        similar_monsters((struct monster*)mon, mon1) &&
        los(cave, mon1->grid, mon->grid)) {
      mon1->tmp_morale += amount;
    }
  }
  return;
}
STATIC_OVL bool
monster_carry(struct chunk* c, struct monster* mon, struct object* obj)
{
  struct object* held_obj;
  for (held_obj = mon->held_obj; held_obj; held_obj = held_obj->next) {
    if (object_mergeable(held_obj, obj, OSTACK_MONSTER)) {
      object_absorb(held_obj, obj);
      return true;
    }
  }
  obj->grid = loc(0, 0);
  obj->held_m_idx = mon->midx;
  list_object(c, obj);
  if (obj->known) {
    obj->known->oidx = obj->oidx;
    player->cave->objects[obj->oidx] = obj->known;
  }
  pile_insert(&mon->held_obj, obj);
  return true;
}
STATIC_OVL enum parser_error
parse_chest_trap_name(struct parser* p)
{
  const char* name = parser_getstr(p, "name");
  struct chest_trap* h = parser_priv(p);
  struct chest_trap* t = mem_zalloc(sizeof *t);
  if (h) {
    h->next = t;
    t->flag = h->flag ? h->flag * 2 : 1;
  } else {
    chest_traps = t;
  }
  t->name = string_make(name);
  parser_setpriv(p, t);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_chest_trap_effect(struct parser* p)
{
  struct chest_trap* t = parser_priv(p);
  struct effect* effect;
  struct effect* new_effect = mem_zalloc(sizeof(*new_effect));
  if (!t) return PARSE_ERROR_MISSING_RECORD_HEADER;
  if (t->effect) {
    effect = t->effect;
    while (effect->next) effect = effect->next;
    effect->next = new_effect;
  } else
    t->effect = new_effect;
  return grab_effect_data(p, new_effect);
}
STATIC_OVL enum parser_error
parse_chest_trap_dice(struct parser* p)
{
  struct chest_trap* t = parser_priv(p);
  dice_t* dice = NULL;
  struct effect* effect = t->effect;
  const char* string = NULL;
  if (!t) return PARSE_ERROR_MISSING_RECORD_HEADER;
  if (effect == NULL) return PARSE_ERROR_NONE;
  while (effect->next) effect = effect->next;
  dice = dice_new();
  if (dice == NULL) return PARSE_ERROR_INVALID_DICE;
  string = parser_getstr(p, "dice");
  if (dice_parse_string(dice, string)) {
    effect->dice = dice;
  } else {
    dice_free(dice);
    return PARSE_ERROR_INVALID_DICE;
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_chest_trap_msg(struct parser* p)
{
  struct chest_trap* t = parser_priv(p);
  if (!t) return PARSE_ERROR_MISSING_RECORD_HEADER;
  t->msg = string_append(t->msg, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_chest_trap_msg_save(struct parser* p)
{
  struct chest_trap* t = parser_priv(p);
  if (!t) return PARSE_ERROR_MISSING_RECORD_HEADER;
  t->msg_save = string_append(t->msg_save, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_chest_trap_msg_bad(struct parser* p)
{
  struct chest_trap* t = parser_priv(p);
  if (!t) return PARSE_ERROR_MISSING_RECORD_HEADER;
  t->msg_bad = string_append(t->msg_bad, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_chest_trap_msg_death(struct parser* p)
{
  struct chest_trap* t = parser_priv(p);
  if (!t) return PARSE_ERROR_MISSING_RECORD_HEADER;
  t->msg_death = string_append(t->msg_death, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_parse_chest_trap(void)
{
  struct parser* p = parser_new();
  parser_setpriv(p, NULL);
  parser_reg(p, "name str name", parse_chest_trap_name);
  parser_reg(p, "effect sym eff ?sym type ?int radius ?int other",
             parse_chest_trap_effect);
  parser_reg(p, "dice str dice", parse_chest_trap_dice);
  parser_reg(p, "msg str text", parse_chest_trap_msg);
  parser_reg(p, "msg-save str text", parse_chest_trap_msg_save);
  parser_reg(p, "msg-bad str text", parse_chest_trap_msg_bad);
  parser_reg(p, "msg-death str text", parse_chest_trap_msg_death);
  return p;
}
STATIC_OVL errr
run_parse_chest_trap(struct parser* p)
{
  return parse_file_quit_not_found(p, "chest_trap");
}
STATIC_OVL errr
finish_parse_chest_trap(struct parser* p)
{
  parser_destroy(p);
  return 0;
}
STATIC_OVL void
cleanup_chest_trap(void)
{
  struct chest_trap* trap = chest_traps;
  while (trap) {
    struct chest_trap* old = trap;
    string_free(trap->name);
    string_free(trap->msg);
    string_free(trap->msg_save);
    string_free(trap->msg_bad);
    string_free(trap->msg_death);
    free_effect(trap->effect);
    trap = trap->next;
    mem_free(old);
  }
}
STATIC_OVL const char*
chest_trap_name(const struct object* obj)
{
  int16_t trap_value = obj->pval;
  if (trap_value < 0) {
    return (trap_value == -1) ? "unlocked" : "disarmed";
  } else if (trap_value > 0) {
    struct chest_trap *trap = chest_traps, *found = NULL;
    while (trap) {
      if (trap_value & trap->flag) {
        if (found) {
          return "multiple traps";
        }
        found = trap;
      }
      trap = trap->next;
    }
    if (found) {
      return found->name;
    }
  }
  return "empty";
}
STATIC_OVL bool
is_trapped_chest(const struct object* obj)
{
  if (!tval_is_chest(obj)) return false;
  if (obj->pval <= 0) return false;
  return (obj->pval == 1) ? false : true;
}
STATIC_OVL bool
is_locked_chest(const struct object* obj)
{
  if (!tval_is_chest(obj)) return false;
  return (obj->pval > 0);
}
STATIC_OVL void
unlock_chest(struct object* obj)
{
  obj->pval = (0 - obj->pval);
}
STATIC_OVL struct object*
chest_check(const struct player* p, struct loc grid,
            enum chest_query check_type)
{
  struct object* obj;
  for (obj = square_object(cave, grid); obj; obj = obj->next) {
    if (ignore_item_ok(p, obj)) continue;
    switch (check_type) {
      case CHEST_ANY:
        if (tval_is_chest(obj)) return obj;
        break;
      case CHEST_OPENABLE:
        if (tval_is_chest(obj) && (obj->pval != 0)) return obj;
        break;
      case CHEST_TRAPPED:
        if (is_trapped_chest(obj) && obj->known && obj->known->pval) return obj;
        break;
    }
  }
  return NULL;
}
STATIC_OVL int
count_chests(struct loc* grid, enum chest_query check_type)
{
  int d, count;
  count = 0;
  for (d = 0; d < 9; d++) {
    struct loc grid1 = loc_sum(player->grid, ddgrid_ddd[d]);
    if (!chest_check(player, grid1, check_type)) continue;
    ++count;
    *grid = grid1;
  }
  return count;
}
STATIC_OVL struct drop*
choose_chest_contents(void)
{
  struct drop* theme;
  int pick, count = 0;
  for (theme = drops; theme; theme = theme->next) {
    if (theme->chest) count++;
  }
  pick = randint0(count);
  for (theme = drops; theme; theme = theme->next) {
    if (theme->chest) count--;
    if (count == pick) break;
  }
  assert(theme);
  return theme;
}
STATIC_OVL void
chest_death(struct loc grid, struct object* chest)
{
  int number = 1, level;
  struct drop* theme;
  if (!chest->pval) return;
  if (strstr(chest->kind->name, "Small")) {
    number = rand_range(2, 3);
  } else if (strstr(chest->kind->name, "Large")) {
    number = 4;
  } else if (strstr(chest->kind->name, "present")) {
    number = 1;
  }
  level = ABS(chest->pval);
  theme = choose_chest_contents();
  while (number > 0) {
    int quality = randint1(level);
    struct object* treasure;
    bool good = false, great = false;
    if (strstr(chest->kind->name, "steel")) {
      quality += 5;
    } else if (strstr(chest->kind->name, "jewelled")) {
      quality += 10;
    } else if (strstr(chest->kind->name, "present")) {
      quality += 20;
    }
    if (quality > 10) {
      if (quality <= 15) {
        good = true;
      } else if (quality <= 20) {
        great = true;
      } else {
        good = true;
        great = true;
      }
    }
    treasure = make_object(cave, level, good, great, theme);
    if (!treasure) continue;
    if (tval_is_chest(treasure)) {
      object_delete(cave, player->cave, &treasure);
      continue;
    }
    treasure->origin = ORIGIN_CHEST;
    treasure->origin_depth = chest->origin_depth;
    drop_near(cave, &treasure, 0, grid, true, false);
    number--;
  }
  chest->pval = 0;
  chest->known->pval = 0;
}
STATIC_OVL void
chest_trap(struct object* obj)
{
  uint8_t flags;
  struct chest_trap* trap;
  bool ident = false;
  int old[TMD_MAX];
  if (obj->pval <= 0) return;
  memcpy(old, player->timed, TMD_MAX);
  assert(obj->pval < (int)N_ELEMENTS(chest_trap_list));
  flags = chest_trap_list[obj->pval];
  for (trap = chest_traps; trap; trap = trap->next) {
    if (flags & trap->flag) {
      bool save = false;
      if (trap->msg_save) {
        int difficulty = player->state.stat_use[STAT_DEX] * 2;
        if (skill_check(source_none(), 2, difficulty, source_player()) <= 0) {
          save = true;
        }
      }
      if (save) {
        msg(trap->msg_save);
      } else {
        if (trap->msg) {
          msg(trap->msg);
        }
        if (trap->effect) {
          effect_do(trap->effect, source_chest_trap(trap), obj, &ident, false,
                    DIR_NONE, NULL);
          if (trap->msg_bad) {
            if (player_timed_inc_happened(player, old, TMD_MAX)) {
              msg(trap->msg_bad);
            } else {
              msg("You resist the effects.");
            }
          }
        }
      }
      if (trap->destroy) {
        obj->pval = 0;
        break;
      }
    }
  }
}
STATIC_OVL bool
do_cmd_open_chest(struct loc grid, struct object* obj)
{
  bool flag = true;
  bool more = false;
  if (strstr(obj->kind->name, "present")) {
    time_t c = time((time_t*)0);
    struct tm* tp = localtime(&c);
    if ((tp->tm_mon == 11) && (tp->tm_mday >= 20) && (tp->tm_mday < 25)) {
      if (get_check("Are you sure you wish to open your present before "
                    "Christmas? ")) {
        msg("You have a very bad feeling about this.");
        player->cursed = true;
      } else {
        return false;
      }
    }
  }
  if (obj->pval > 0) {
    int score = player->state.skill_use[SKILL_PERCEPTION];
    int power = 1 + (obj->pval / 4);
    int difficulty = power + 5;
    flag = false;
    if (player->timed[TMD_BLIND] || no_light(player) ||
        player->timed[TMD_CONFUSED] || player->timed[TMD_IMAGE]) {
      difficulty += 5;
    }
    if (skill_check(source_player(), score, difficulty, source_none()) > 0) {
      msg("You have picked the lock.");
      flag = true;
    } else {
      more = true;
      event_signal(EVENT_INPUT_FLUSH);
      msgt(MSG_LOCKPICK_FAIL, "You failed to pick the lock.");
    }
  }
  if (flag) {
    chest_trap(obj);
    chest_death(grid, obj);
    player->upkeep->notice |= PN_IGNORE;
  }
  if (obj->pval == 0) obj->known->notice |= OBJ_NOTICE_IGNORE;
  square_light_spot(cave, grid);
  return (more);
}
STATIC_OVL bool
do_cmd_disarm_chest(struct object* obj)
{
  int result;
  bool more = false;
  int score = player->state.skill_use[SKILL_PERCEPTION];
  int difficulty = 1 + (obj->pval / 4);
  if (player->timed[TMD_BLIND] || no_light(player) ||
      player->timed[TMD_CONFUSED] || player->timed[TMD_IMAGE]) {
    difficulty += 5;
  }
  result = skill_check(source_player(), score, difficulty, source_none());
  if (!obj->known->pval || ignore_item_ok(player, obj)) {
    msg("I don't see any traps.");
  } else if (!is_trapped_chest(obj)) {
    msg("The chest is not trapped.");
  } else if (result > 0) {
    msgt(MSG_DISARM, "You have disarmed the chest.");
    obj->pval = (0 - obj->pval);
  } else if (result > -3) {
    more = true;
    event_signal(EVENT_INPUT_FLUSH);
    msg("You failed to disarm the chest.");
  } else {
    msg("You set off a trap!");
    chest_trap(obj);
  }
  return more;
}
STATIC_OVL void
object_base_name(char* buf, size_t max, int tval, bool plural)
{
  struct object_base* kb = &kb_info[tval];
  size_t end = 0;
  if (kb->name && kb->name[0])
    (void)obj_desc_name_format(buf, max, end, kb->name, NULL, plural);
}
STATIC_OVL void
object_kind_name(char* buf, size_t max, const struct object_kind* kind,
                 bool easy_know)
{
  if (!easy_know && !kind->aware && kind->flavor)
    my_strcpy(buf, kind->flavor->text, max);
  else
    (void)obj_desc_name_format(buf, max, 0, kind->name, NULL, false);
}
STATIC_OVL const char*
obj_desc_get_modstr(const struct object_kind* kind)
{
  if (tval_can_have_flavor_k(kind))
    return kind->flavor ? kind->flavor->text : "";
  return "";
}
STATIC_OVL const char*
obj_desc_get_basename(const struct object* obj, bool aware, bool terse,
                      uint32_t mode, const struct player* p)
{
  bool show_flavor = !terse && obj->kind->flavor;
  if (aware && p && !OPT(p, show_flavors)) show_flavor = false;
  if (obj->artifact &&
      (aware || object_is_known_artifact(obj) || terse || !obj->kind->flavor))
    return obj->kind->name;
  switch (obj->tval) {
    case TV_NOTE:
    case TV_USELESS:
    case TV_METAL:
    case TV_FLASK:
    case TV_CHEST:
    case TV_ARROW:
    case TV_BOW:
    case TV_HAFTED:
    case TV_POLEARM:
    case TV_SWORD:
    case TV_DIGGING:
    case TV_BOOTS:
    case TV_GLOVES:
    case TV_CLOAK:
    case TV_CROWN:
    case TV_HELM:
    case TV_SHIELD:
    case TV_SOFT_ARMOR:
    case TV_MAIL:
    case TV_LIGHT:
    case TV_FOOD:
      return obj->kind->name;
    case TV_AMULET:
      return (show_flavor ? "& # Amulet~" : "& Amulet~");
    case TV_RING:
      return (show_flavor ? "& # Ring~" : "& Ring~");
    case TV_STAFF:
      return (show_flavor ? "& # Sta|ff|ves|" : "& Sta|ff|ves|");
    case TV_HORN:
      return (show_flavor ? "& # Horn~" : "& Horn~");
    case TV_POTION:
      return (show_flavor ? "& # Potion~" : "& Potion~");
    case TV_HERB:
      return (show_flavor ? "& # Herb~" : "& Herb~");
  }
  return "(nothing)";
}
STATIC_OVL size_t
obj_desc_name_prefix(char* buf, size_t max, size_t end,
                     const struct object* obj, const char* basename,
                     const char* modstr, bool terse, uint16_t number)
{
  if (number == 0) {
    strnfcat(buf, max, &end, "no more ");
  } else if (number > 1) {
    strnfcat(buf, max, &end, "%u ", number);
  } else if (object_is_known_artifact(obj)) {
    strnfcat(buf, max, &end, "the ");
  } else if (*basename == '&') {
    bool an = false;
    const char* lookahead = basename + 1;
    while (*lookahead == ' ') lookahead++;
    if (*lookahead == '#') {
      if (modstr && is_a_vowel(*modstr)) an = true;
    } else if (is_a_vowel(*lookahead)) {
      an = true;
    }
    if (!terse) {
      if (an)
        strnfcat(buf, max, &end, "an ");
      else
        strnfcat(buf, max, &end, "a ");
    }
  }
  return end;
}
STATIC_OVL size_t
obj_desc_name_format(char* buf, size_t max, size_t end, const char* fmt,
                     const char* modstr, bool pluralise)
{
  while (*fmt) {
    if (*fmt == '&') {
      while (*fmt == ' ' || *fmt == '&') fmt++;
      continue;
    } else if (*fmt == '~') {
      char prev = *(fmt - 1);
      if (!pluralise) {
        fmt++;
        continue;
      }
      if (prev == 's' || prev == 'h' || prev == 'x')
        strnfcat(buf, max, &end, "es");
      else
        strnfcat(buf, max, &end, "s");
    } else if (*fmt == '|') {
      const char* singular = fmt + 1;
      const char* plural = strchr(singular, '|');
      const char* endmark = NULL;
      if (plural) {
        plural++;
        endmark = strchr(plural, '|');
      }
      if (!singular || !plural || !endmark) return end;
      if (!pluralise)
        strnfcat(buf, max, &end, "%.*s", (int)(plural - singular) - 1,
                 singular);
      else
        strnfcat(buf, max, &end, "%.*s", (int)(endmark - plural), plural);
      fmt = endmark;
    } else if (*fmt == '#') {
      end = obj_desc_name_format(buf, max, end, modstr, NULL, pluralise);
    } else
      buf[end++] = *fmt;
    fmt++;
  }
  buf[end] = 0;
  return end;
}
STATIC_OVL size_t
obj_desc_name(char* buf, size_t max, size_t end, const struct object* obj,
              bool prefix, uint32_t mode, bool terse, const struct player* p)
{
  bool spoil = mode & ODESC_SPOIL ? true : false;
  uint16_t number =
      (mode & ODESC_ALTNUM) ? (mode & 0xFFFF0000) >> 16 : obj->number;
  bool aware = object_flavor_is_aware(obj) || spoil;
  bool plural = !(mode & ODESC_SINGULAR) && !obj->artifact &&
                (number != 1 || (mode & ODESC_PLURAL));
  const char* basename = obj_desc_get_basename(obj, aware, terse, mode, p);
  const char* modstr = obj_desc_get_modstr(obj->kind);
  if (prefix)
    end = obj_desc_name_prefix(buf, max, end, obj, basename, modstr, terse,
                               number);
  end = obj_desc_name_format(buf, max, end, basename, modstr, plural);
  if (object_is_known_artifact(obj))
    strnfcat(buf, max, &end, " %s", obj->artifact->name);
  else if (obj->known->ego && !(mode & ODESC_NOEGO))
    strnfcat(buf, max, &end, " %s", obj->ego->name);
  else if (aware && !obj->artifact && obj->kind->flavor) {
    if (terse)
      strnfcat(buf, max, &end, " '%s'", obj->kind->name);
    else
      strnfcat(buf, max, &end, " of %s", obj->kind->name);
  }
  return end;
}
STATIC_OVL size_t
obj_desc_chest(const struct object* obj, char* buf, size_t max, size_t end)
{
  if (!tval_is_chest(obj)) return end;
  if (obj->pval && !obj->known->pval) return end;
  strnfcat(buf, max, &end, " (%s)", chest_trap_name(obj));
  return end;
}
STATIC_OVL size_t
obj_desc_combat(const struct object* obj, char* buf, size_t max, size_t end,
                uint32_t mode, const struct player* p)
{
  int att = obj->att == SPECIAL_VALUE ? 0 : obj->att;
  int evn = obj->evn == SPECIAL_VALUE ? 0 : obj->evn;
  int ds = obj->ds == SPECIAL_VALUE ? 0 : obj->ds;
  int ps = obj->ps == SPECIAL_VALUE ? 0 : obj->ps;
  if (obj->kind && kf_has(obj->kind->kind_flags, KF_SHOW_DICE)) {
    ds += hand_and_a_half_bonus((struct player*)p, obj);
    strnfcat(buf, max, &end, " (%+d,%dd%d)", att, obj->dd, ds);
  } else if (tval_is_ammo(obj) && att) {
    strnfcat(buf, max, &end, " (%+d)", att);
  } else if (att) {
    strnfcat(buf, max, &end, " (%+d)", att);
  }
  if (obj->pd && ps) {
    strnfcat(buf, max, &end, " [%+d,%dd%d]", evn, obj->pd, ps);
  } else if (evn) {
    strnfcat(buf, max, &end, " [%+d]", evn);
  }
  return end;
}
STATIC_OVL size_t
obj_desc_light(const struct object* obj, char* buf, size_t max, size_t end)
{
  if (tval_is_light(obj) && !of_has(obj->flags, OF_NO_FUEL))
    strnfcat(buf, max, &end, " (%d turns)", obj->timeout);
  return end;
}
STATIC_OVL size_t
obj_desc_mods(const struct object* obj, char* buf, size_t max, size_t end)
{
  int i, j, num_mods = 0;
  int mods[OBJ_MOD_MAX] = {0};
  for (i = 0; i < OBJ_MOD_MAX; i++) {
    if ((obj->modifiers[i] != 0) && (obj->modifiers[i] != SPECIAL_VALUE)) {
      if (!num_mods) {
        mods[num_mods++] = obj->modifiers[i];
        continue;
      }
      for (j = 0; j < num_mods; j++)
        if (mods[j] == obj->modifiers[i]) break;
      if (j == num_mods) mods[num_mods++] = obj->modifiers[i];
    }
  }
  if (!num_mods) return end;
  strnfcat(buf, max, &end, " <");
  for (j = 0; j < num_mods; j++) {
    if (j) strnfcat(buf, max, &end, ", ");
    strnfcat(buf, max, &end, "%+d", mods[j]);
  }
  strnfcat(buf, max, &end, ">");
  return end;
}
STATIC_OVL size_t
obj_desc_charges(const struct object* obj, char* buf, size_t max, size_t end,
                 uint32_t mode)
{
  bool aware = object_flavor_is_aware(obj);
  if (!tval_can_have_charges(obj)) return end;
  if (aware || player_active_ability(player, "Channeling")) {
    strnfcat(buf, max, &end, " (%d charge%s)", obj->pval, PLURAL(obj->pval));
  } else if ((obj->used > 0) && !(obj->notice & OBJ_NOTICE_EMPTY)) {
    strnfcat(buf, max, &end, " (used %d time%s)", obj->used, PLURAL(obj->used));
  }
  return end;
}
STATIC_OVL size_t
obj_desc_inscrip(const struct object* obj, char* buf, size_t max, size_t end,
                 const struct player* p)
{
  const char* u[6] = {0, 0, 0, 0, 0, 0};
  int n = 0;
  if (obj->note) u[n++] = quark_str(obj->note);
  if (!object_flavor_is_aware(obj)) {
    if (tval_can_have_charges(obj) && (obj->pval == 0)) u[n++] = "empty";
    if (object_flavor_was_tried(obj)) u[n++] = "tried";
  }
  if (of_has(obj->known->flags, OF_CURSED)) {
    u[n++] = "cursed";
  }
  if (p && ignore_item_ok(p, obj)) u[n++] = "ignore";
  if (!object_runes_known(obj) && (obj->known->notice & OBJ_NOTICE_ASSESSED))
    u[n++] = "??";
  if (n) {
    int i;
    for (i = 0; i < n; i++) {
      if (i == 0) strnfcat(buf, max, &end, " {");
      strnfcat(buf, max, &end, "%s", u[i]);
      if (i < n - 1) strnfcat(buf, max, &end, ", ");
    }
    strnfcat(buf, max, &end, "}");
  }
  return end;
}
STATIC_OVL size_t
object_desc(char* buf, size_t max, const struct object* obj, uint32_t mode,
            const struct player* p)
{
  bool prefix = mode & ODESC_PREFIX ? true : false;
  bool spoil = mode & ODESC_SPOIL ? true : false;
  bool terse = mode & ODESC_TERSE ? true : false;
  size_t end = 0;
  if (!obj || !obj->known) return strnfmt(buf, max, "(nothing)");
  if (obj->known->ego && !spoil) obj->ego->everseen = true;
  if (object_flavor_is_aware(obj) && !spoil) obj->kind->everseen = true;
  end = obj_desc_name(buf, max, end, obj, prefix, mode, terse, p);
  if (mode & ODESC_COMBAT) {
    if (tval_is_chest(obj))
      end = obj_desc_chest(obj, buf, max, end);
    else if (tval_is_light(obj))
      end = obj_desc_light(obj, buf, max, end);
    end = obj_desc_combat(obj->known, buf, max, end, mode, p);
  }
  if (mode & ODESC_EXTRA) {
    end = obj_desc_mods(obj->known, buf, max, end);
    end = obj_desc_charges(obj, buf, max, end, mode);
    end = obj_desc_inscrip(obj, buf, max, end, p);
  }
  return end;
}
STATIC_OVL int
slot_by_name(struct player* p, const char* name)
{
  int i;
  for (i = 0; i < p->body.count; i++) {
    if (streq(name, p->body.slots[i].name)) {
      break;
    }
  }
  assert(i < p->body.count);
  return i;
}
STATIC_OVL int
slot_by_type(struct player* p, int type, bool full)
{
  int i, fallback = p->body.count;
  for (i = 0; i < p->body.count; i++) {
    if (type == p->body.slots[i].type) {
      if (full) {
        if (p->body.slots[i].obj != NULL) break;
      } else {
        if (p->body.slots[i].obj == NULL) break;
      }
      if (fallback == p->body.count) fallback = i;
    }
  }
  return (i != p->body.count) ? i : fallback;
}
STATIC_OVL bool
slot_type_is(const struct player* p, int slot, int type)
{
  struct player_body body = p ? p->body : bodies[0];
  return body.slots[slot].type == type ? true : false;
}
STATIC_OVL struct object*
slot_object(struct player* p, int slot)
{
  assert(slot >= 0 && slot < p->body.count);
  if (p->body.slots && p->body.slots[slot].obj) {
    return p->body.slots[slot].obj;
  }
  return NULL;
}
STATIC_OVL struct object*
equipped_item_by_slot_name(struct player* p, const char* name)
{
  if (p->body.slots) {
    return slot_object(p, slot_by_name(p, name));
  }
  return NULL;
}
STATIC_OVL int
object_slot(struct player_body body, const struct object* obj)
{
  int i;
  for (i = 0; i < body.count; i++) {
    if (obj == body.slots[i].obj) {
      break;
    }
  }
  return i;
}
STATIC_OVL bool
object_is_equipped(struct player_body body, const struct object* obj)
{
  return object_slot(body, obj) < body.count - 2;
}
STATIC_OVL bool
object_is_carried(struct player* p, const struct object* obj)
{
  return pile_contains(p->gear, obj);
}
STATIC_OVL bool
object_is_in_quiver(const struct player* p, const struct object* obj)
{
  struct player_body body = p->body;
  return (object_slot(body, obj) < body.count) &&
         !object_is_equipped(body, obj);
}
STATIC_OVL uint16_t
object_pack_total(struct player* p, const struct object* obj,
                  bool ignore_inscrip, struct object** first)
{
  uint16_t total = 0;
  char first_label = '\0';
  struct object* cursor;
  if (first) {
    *first = NULL;
  }
  for (cursor = p->gear; cursor; cursor = cursor->next) {
    bool like;
    if (cursor == obj) {
      like = !object_is_equipped(p->body, obj);
    } else if (ignore_inscrip) {
      like = object_similar(obj, cursor, OSTACK_PACK);
    } else {
      like = object_stackable(obj, cursor, OSTACK_PACK);
    }
    if (like) {
      total += cursor->number;
      if (first) {
        char test_label = gear_to_label(p, cursor);
        if (!*first) {
          *first = cursor;
          first_label = test_label;
        } else {
          if (test_label >= 'a' && test_label <= 'z') {
            if (first_label == '\0' ||
                (first_label >= 'a' && first_label <= 'z' &&
                 test_label < first_label)) {
              *first = cursor;
              first_label = test_label;
            }
          } else if (test_label >= '0' && test_label <= '9') {
            if (first_label == '\0' ||
                (first_label >= 'a' && first_label <= 'z') ||
                (first_label >= '0' && first_label <= '9' &&
                 test_label < first_label)) {
              *first = cursor;
              first_label = test_label;
            }
          }
        }
      }
    }
  }
  return total;
}
STATIC_OVL int
pack_slots_used(const struct player* p)
{
  const struct object* obj;
  int pack_slots = 0;
  for (obj = p->gear; obj; obj = obj->next) {
    if (!object_is_equipped(p->body, obj) && !object_is_in_quiver(p, obj)) {
      pack_slots++;
    }
  }
  return pack_slots;
}
STATIC_OVL const char*
equip_mention(struct player* p, int slot)
{
  int type = p->body.slots[slot].type;
  if (slot_table[type].name_in_desc)
    return format(slot_table[type].mention, p->body.slots[slot].name);
  else
    return slot_table[type].mention;
}
STATIC_OVL const char*
equip_describe(struct player* p, int slot)
{
  int type = p->body.slots[slot].type;
  if (slot_table[type].name_in_desc)
    return format(slot_table[type].describe, p->body.slots[slot].name);
  else
    return slot_table[type].describe;
}
STATIC_OVL int
wield_slot(const struct object* obj)
{
  switch (obj->tval) {
    case TV_BOW:
      return slot_by_type(player, EQUIP_BOW, false);
    case TV_AMULET:
      return slot_by_type(player, EQUIP_AMULET, false);
    case TV_CLOAK:
      return slot_by_type(player, EQUIP_CLOAK, false);
    case TV_SHIELD:
      return slot_by_type(player, EQUIP_SHIELD, false);
    case TV_GLOVES:
      return slot_by_type(player, EQUIP_GLOVES, false);
    case TV_BOOTS:
      return slot_by_type(player, EQUIP_BOOTS, false);
    case TV_ARROW:
      return slot_by_type(player, EQUIP_QUIVER, false);
  }
  if (tval_is_melee_weapon(obj))
    return slot_by_type(player, EQUIP_WEAPON, false);
  else if (tval_is_ring(obj))
    return slot_by_type(player, EQUIP_RING, false);
  else if (tval_is_light(obj))
    return slot_by_type(player, EQUIP_LIGHT, false);
  else if (tval_is_body_armor(obj))
    return slot_by_type(player, EQUIP_BODY_ARMOR, false);
  else if (tval_is_head_armor(obj))
    return slot_by_type(player, EQUIP_HAT, false);
  return -1;
}
STATIC_OVL bool
minus_ac(struct player* p)
{
  int i, count = 0;
  struct object* obj = NULL;
  if (!p->gear) return false;
  for (i = 0; i < p->body.count; i++) {
    if (slot_type_is(p, i, EQUIP_WEAPON)) continue;
    if (slot_type_is(p, i, EQUIP_BOW)) continue;
    if (slot_type_is(p, i, EQUIP_RING)) continue;
    if (slot_type_is(p, i, EQUIP_AMULET)) continue;
    if (slot_type_is(p, i, EQUIP_LIGHT)) continue;
    if (slot_type_is(p, i, EQUIP_QUIVER)) continue;
    count++;
  }
  for (i = p->body.count - 1; i >= 0; i--) {
    if (slot_type_is(p, i, EQUIP_WEAPON)) continue;
    if (slot_type_is(p, i, EQUIP_BOW)) continue;
    if (slot_type_is(p, i, EQUIP_RING)) continue;
    if (slot_type_is(p, i, EQUIP_AMULET)) continue;
    if (slot_type_is(p, i, EQUIP_LIGHT)) continue;
    if (slot_type_is(p, i, EQUIP_QUIVER)) continue;
    if (one_in_(count--)) break;
  }
  obj = slot_object(p, i);
  if (obj && slot_type_is(p, i, EQUIP_SHIELD) && tval_is_weapon(obj)) {
    obj = NULL;
  }
  if (obj) {
    char o_name[80];
    object_desc(o_name, sizeof(o_name), obj, ODESC_BASE, p);
    if (obj->el_info[ELEM_ACID].flags & EL_INFO_IGNORE) {
      msg("Your %s is unaffected!", o_name);
    } else if ((obj->ps <= 0) && (obj->evn <= 0)) {
      bool none_left;
      struct object* destroyed =
          gear_object_for_use(p, obj, 1, false, &none_left);
      object_delete(p->cave, NULL, &destroyed->known);
      object_delete(cave, p->cave, &destroyed);
      msg("Your %s is destroyed!", o_name);
    } else {
      msg("Your %s is damaged!", o_name);
      if (obj->evn >= 0) {
        obj->evn--;
      } else {
        obj->ps--;
      }
      p->upkeep->update |= (PU_BONUS);
      p->upkeep->redraw |= (PR_EQUIP);
    }
    return true;
  } else {
    return false;
  }
}
STATIC_OVL char
gear_to_label(struct player* p, struct object* obj)
{
  const char labels[] = "abcdefgimnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
  int i;
  if (object_is_equipped(p->body, obj) || object_is_in_quiver(p, obj)) {
    return labels[equipped_item_slot(p->body, obj)];
  }
  for (i = 0; i < z_info->pack_size; i++) {
    if (p->upkeep->inven[i] == obj) {
      return labels[i];
    }
  }
  return '\0';
}
STATIC_OVL bool
gear_excise_object(struct player* p, struct object* obj)
{
  int i;
  pile_excise(&p->gear_k, obj->known);
  pile_excise(&p->gear, obj);
  p->upkeep->total_weight -= (obj->number * obj->weight);
  for (i = 0; i < p->body.count; i++) {
    if (slot_object(p, i) == obj) {
      p->body.slots[i].obj = NULL;
      p->upkeep->equip_cnt--;
    }
  }
  calc_inventory(p);
  p->upkeep->update |= (PU_BONUS);
  p->upkeep->notice |= (PN_COMBINE);
  p->upkeep->redraw |= (PR_INVEN | PR_EQUIP);
  return true;
}
STATIC_OVL struct object*
gear_last_item(struct player* p)
{
  return pile_last_item(p->gear);
}
STATIC_OVL void
gear_insert_end(struct player* p, struct object* obj)
{
  pile_insert_end(&p->gear, obj);
  pile_insert_end(&p->gear_k, obj->known);
}
STATIC_OVL struct object*
gear_object_for_use(struct player* p, struct object* obj, int num, bool message,
                    bool* none_left)
{
  struct object* usable;
  struct object* first_remainder = NULL;
  char name[80];
  char label = gear_to_label(p, obj);
  bool artifact = (obj->known->artifact != NULL);
  num = MIN(num, obj->number);
  if (obj->number > num) {
    usable = object_split(obj, num);
    p->upkeep->total_weight -= (num * obj->weight);
    if (message) {
      uint16_t total;
      if (object_is_equipped(p->body, obj) || tval_can_have_charges(obj) ||
          obj->timeout > 0) {
        total = obj->number;
      } else {
        total = object_pack_total(p, obj, false, &first_remainder);
        assert(total >= first_remainder->number);
        if (total == first_remainder->number) {
          first_remainder = NULL;
        }
      }
      object_desc(name, sizeof(name), obj,
                  ODESC_PREFIX | ODESC_FULL | ODESC_ALTNUM | (total << 16), p);
    }
  } else {
    if (message) {
      if (artifact) {
        object_desc(name, sizeof(name), obj, ODESC_FULL | ODESC_SINGULAR, p);
      } else {
        uint16_t total;
        if (object_is_equipped(p->body, obj) || tval_can_have_charges(obj) ||
            obj->timeout > 0) {
          total = obj->number;
        } else {
          total = object_pack_total(p, obj, false, &first_remainder);
        }
        assert(total >= num);
        total -= num;
        if (!total || total <= first_remainder->number) {
          first_remainder = NULL;
        }
        object_desc(name, sizeof(name), obj,
                    ODESC_PREFIX | ODESC_FULL | ODESC_ALTNUM | (total << 16),
                    p);
      }
    }
    usable = obj;
    gear_excise_object(p, usable);
    *none_left = true;
    if (tracked_object_is(p->upkeep, obj)) track_object(p->upkeep, NULL);
    cmd_disable_repeat();
  }
  p->upkeep->update |= (PU_BONUS);
  p->upkeep->notice |= (PN_COMBINE);
  p->upkeep->redraw |= (PR_INVEN | PR_EQUIP);
  if (message) {
    if (artifact) {
      msg("You no longer have the %s (%c).", name, label);
    } else if (first_remainder) {
      label = gear_to_label(p, first_remainder);
      msg("You have %s (1st %c).", name, label);
    } else {
      msg("You have %s (%c).", name, label);
    }
  }
  return usable;
}
STATIC_OVL bool
handle_stickied_removal(struct player* p, struct object* obj)
{
  if (!object_is_equipped(player->body, obj) || !obj_is_cursed(obj)) {
    return false;
  }
  if (player_active_ability(player, "Curse Breaking")) {
    msg("With a great strength of will, you break the curse!");
    uncurse_object(obj);
    return false;
  }
  msg("You cannot bear to part with it.");
  return true;
}
STATIC_OVL int
inven_carry_num(const struct player* p, const struct object* obj)
{
  int max_weight = (weight_limit(p->state) * 3) / 2;
  int num_lim, num_to_quiver, num_left, i;
  if (p->upkeep->total_weight > max_weight) {
    return 0;
  }
  if (p->upkeep->total_weight + obj->weight * obj->number <= max_weight) {
    num_lim = obj->number;
  } else {
    num_lim = (max_weight - p->upkeep->total_weight) / obj->weight;
    if (!num_lim) {
      return 0;
    }
  }
  num_to_quiver = 0;
  for (i = 0; i < p->body.count; i++) {
    struct object* q_obj = p->body.slots[i].obj;
    int num_already = q_obj ? q_obj->number : 0;
    if (!slot_type_is(p, i, EQUIP_QUIVER)) continue;
    if (!tval_is_ammo(obj)) continue;
    if (!num_already || object_stackable(q_obj, obj, OSTACK_PACK)) {
      num_to_quiver += obj->kind->base->max_stack - num_already;
    }
  }
  if (num_to_quiver >= num_lim || z_info->pack_size - pack_slots_used(p) > 0) {
    return num_lim;
  }
  num_left = num_lim - num_to_quiver;
  for (i = 0; i < z_info->pack_size; i++) {
    struct object* inven_obj = p->upkeep->inven[i];
    if (inven_obj && object_stackable(inven_obj, obj, OSTACK_PACK)) {
      num_left -= inven_obj->kind->base->max_stack - inven_obj->number;
      if (num_left <= 0) break;
    }
  }
  return num_lim - MAX(num_left, 0);
}
STATIC_OVL bool
inven_carry_okay(const struct object* obj)
{
  return inven_carry_num(player, obj) > 0;
}
STATIC_OVL void
inven_item_charges(struct object* obj)
{
  if (tval_can_have_charges(obj) && object_flavor_is_aware(obj)) {
    msg("You have %d charge%s remaining.", obj->pval, PLURAL(obj->pval));
  }
}
STATIC_OVL void
inven_carry(struct player* p, struct object* obj, bool absorb, bool message)
{
  bool combining = false;
  if (absorb) {
    struct object* combine_item = NULL;
    struct object* gear_obj = p->gear;
    while ((combine_item == NULL) && (gear_obj != NULL)) {
      if (!object_is_equipped(p->body, gear_obj) &&
          object_mergeable(gear_obj, obj, OSTACK_PACK)) {
        combine_item = gear_obj;
      }
      gear_obj = gear_obj->next;
    }
    if (combine_item) {
      p->upkeep->total_weight += (obj->number * obj->weight);
      object_absorb(combine_item->known, obj->known);
      obj->known = NULL;
      object_absorb(combine_item, obj);
      combine_item->known->number = combine_item->number;
      obj = combine_item;
      combining = true;
    }
  }
  if (!combining) {
    assert(pack_slots_used(p) <= z_info->pack_size);
    gear_insert_end(p, obj);
    apply_autoinscription(p, obj);
    obj->held_m_idx = 0;
    obj->grid = loc(0, 0);
    obj->known->grid = loc(0, 0);
    p->upkeep->total_weight += (obj->number * obj->weight);
    p->upkeep->notice |= (PN_COMBINE);
  }
  p->upkeep->update |= (PU_BONUS | PU_INVEN);
  p->upkeep->redraw |= (PR_INVEN);
  update_stuff(p);
  if (message) {
    char o_name[80];
    struct object* first;
    uint16_t total;
    char label;
    if (tval_can_have_charges(obj) || obj->timeout > 0) {
      total = obj->number;
      first = obj;
    } else {
      total = object_pack_total(p, obj, false, &first);
    }
    assert(first && total >= first->number);
    object_desc(o_name, sizeof(o_name), obj,
                ODESC_PREFIX | ODESC_FULL | ODESC_ALTNUM | (total << 16), p);
    label = gear_to_label(p, first);
    if (total > first->number) {
      msg("You have %s (1st %c).", o_name, label);
    } else {
      assert(first == obj);
      msg("You have %s (%c).", o_name, label);
    }
  }
  if (object_is_in_quiver(p, obj)) sound(MSG_QUIVER);
}
STATIC_OVL void
inven_wield(struct object* obj, int slot)
{
  struct object *wielded, *old = player->body.slots[slot].obj;
  struct object* weapon = equipped_item_by_slot_name(player, "weapon");
  int shield_slot = slot_by_name(player, "arm");
  const char* fmt;
  char o_name[80];
  bool dummy = false;
  int num = tval_is_ammo(obj) ? ((object_is_carried(player, obj))
                                     ? obj->number
                                     : inven_carry_num(player, obj))
                              : 1;
  struct ability* ability;
  bool less_effective = weapon && (slot == shield_slot) &&
                        of_has(weapon->flags, OF_HAND_AND_A_HALF) && !old;
  if (old == NULL) player->upkeep->equip_cnt++;
  player->upkeep->energy_use = z_info->move_energy;
  player->previous_action[0] = ACTION_MISC;
  if (object_is_carried(player, obj)) {
    if (obj->number > num) {
      wielded = gear_object_for_use(player, obj, num, false, &dummy);
      assert(wielded->number == num);
      player->upkeep->total_weight += wielded->weight * num;
      wielded->next = obj->next;
      obj->next = wielded;
      wielded->prev = obj;
      if (wielded->next) (wielded->next)->prev = wielded;
      wielded->known->next = obj->known->next;
      obj->known->next = wielded->known;
      wielded->known->prev = obj->known;
      if (wielded->known->next) (wielded->known->next)->prev = wielded->known;
    } else {
      wielded = obj;
    }
  } else {
    wielded = floor_object_for_use(player, obj, num, false, &dummy);
    inven_carry(player, wielded, false, false);
  }
  player->body.slots[slot].obj = wielded;
  if (of_has(obj->flags, OF_TWO_HANDED) && slot_object(player, shield_slot)) {
    inven_takeoff(player->body.slots[shield_slot].obj);
  }
  if ((slot == shield_slot) && weapon && of_has(weapon->flags, OF_TWO_HANDED)) {
    inven_takeoff(weapon);
  }
  object_learn_on_wield(player, wielded);
  if (tval_is_melee_weapon(wielded))
    fmt = "You are wielding %s (%c).";
  else if (wielded->tval == TV_BOW)
    fmt = "You are shooting with %s (%c).";
  else if (tval_is_light(wielded))
    fmt = "Your light source is %s (%c).";
  else if (tval_is_ammo(wielded))
    fmt = "In your quiver you have %s (%c)";
  else
    fmt = "You are wearing %s (%c).";
  object_desc(o_name, sizeof(o_name), wielded, ODESC_PREFIX | ODESC_FULL,
              player);
  msgt(MSG_WIELD, fmt, o_name, gear_to_label(player, wielded));
  if (obj_is_cursed(wielded)) {
    msgt(MSG_CURSED, "You have a bad feeling about this...");
    of_on(obj->known->flags, OF_CURSED);
  }
  if (less_effective) {
    object_desc(o_name, sizeof(o_name), weapon, ODESC_BASE, player);
    msg("You are no longer able to wield your %s as effectively.", o_name);
  }
  for (ability = wielded->abilities; ability; ability = ability->next) {
    if (!player_has_ability(player, ability)) {
      add_ability(&player->item_abilities, ability);
      activate_ability(&player->item_abilities, ability);
    }
  }
  combine_pack(player);
  pack_overflow(old);
  player->upkeep->notice |= (PN_IGNORE);
  player->upkeep->update |= (PU_BONUS | PU_INVEN | PU_UPDATE_VIEW);
  player->upkeep->redraw |= (PR_INVEN | PR_EQUIP | PR_ARC | PR_ARMOR);
  player->upkeep->redraw |= (PR_MELEE | PR_STATS | PR_HP | PR_MANA | PR_SPEED);
  update_stuff(player);
  cmd_disable_repeat();
}
STATIC_OVL void
inven_takeoff(struct object* obj)
{
  int slot = equipped_item_slot(player->body, obj);
  const char* act;
  char o_name[80];
  struct ability* ability;
  if (slot == player->body.count) return;
  object_desc(o_name, sizeof(o_name), obj, ODESC_PREFIX | ODESC_FULL, player);
  if (slot_type_is(player, slot, EQUIP_WEAPON))
    act = "You were wielding";
  else if (slot_type_is(player, slot, EQUIP_BOW))
    act = "You were holding";
  else if (slot_type_is(player, slot, EQUIP_LIGHT))
    act = "You were holding";
  else
    act = "You were wearing";
  player->body.slots[slot].obj = NULL;
  player->upkeep->equip_cnt--;
  for (ability = obj->abilities; ability; ability = ability->next) {
    remove_ability(&player->item_abilities, ability);
  }
  player->upkeep->update |= (PU_BONUS | PU_INVEN | PU_UPDATE_VIEW);
  player->upkeep->notice |= (PN_IGNORE);
  update_stuff(player);
  msgt(MSG_WIELD, "%s %s (%c).", act, o_name, gear_to_label(player, obj));
  return;
}
STATIC_OVL void
inven_drop(struct object* obj, int amt)
{
  struct object* dropped;
  bool none_left = false;
  bool equipped = false;
  bool quiver;
  char name[80];
  char label;
  if (amt <= 0) return;
  if (!object_is_carried(player, obj)) return;
  label = gear_to_label(player, obj);
  quiver = object_is_in_quiver(player, obj);
  if (amt > obj->number) amt = obj->number;
  if (object_is_equipped(player->body, obj)) {
    equipped = true;
    inven_takeoff(obj);
  }
  dropped = gear_object_for_use(player, obj, amt, false, &none_left);
  object_desc(name, sizeof(name), dropped, ODESC_PREFIX | ODESC_FULL, player);
  msg("You drop %s (%c).", name, label);
  if (dropped->artifact) {
    object_desc(name, sizeof(name), dropped, ODESC_FULL | ODESC_SINGULAR,
                player);
    msg("You no longer have the %s (%c).", name, label);
  } else {
    struct object* first;
    struct object* desc_target;
    uint16_t total;
    if (equipped || tval_can_have_charges(obj) || obj->timeout > 0) {
      first = NULL;
      if (none_left) {
        total = 0;
        desc_target = dropped;
      } else {
        total = obj->number;
        desc_target = obj;
      }
    } else {
      total = object_pack_total(player, obj, false, &first);
      desc_target = (total) ? obj : dropped;
    }
    object_desc(name, sizeof(name), desc_target,
                ODESC_PREFIX | ODESC_FULL | ODESC_ALTNUM | (total << 16),
                player);
    if (!first) {
      msg("You have %s (%c).", name, label);
    } else {
      label = gear_to_label(player, first);
      if (total > first->number) {
        msg("You have %s (1st %c).", name, label);
      } else {
        msg("You have %s (%c).", name, label);
      }
    }
  }
  drop_near(cave, &dropped, 0, player->grid, false, true);
  if (quiver) sound(MSG_QUIVER);
  event_signal(EVENT_INVENTORY);
  event_signal(EVENT_EQUIPMENT);
}
STATIC_OVL bool
inven_destroy(struct object* obj, int amt)
{
  struct object* destroyed;
  bool none_left = false;
  bool equipped = false;
  bool quiver;
  char name[80];
  char out_val[160];
  char label;
  int num = obj->number;
  if (amt <= 0) return false;
  if (!object_is_carried(player, obj)) return false;
  label = gear_to_label(player, obj);
  quiver = object_is_in_quiver(player, obj);
  if (amt > obj->number) amt = obj->number;
  obj->number = amt;
  object_desc(name, sizeof(name), obj, ODESC_PREFIX | ODESC_FULL, player);
  obj->number = num;
  strnfmt(out_val, sizeof(out_val), "Really destroy %s? ", name);
  if (!get_check(out_val)) return false;
  if (object_is_equipped(player->body, obj)) {
    equipped = true;
    inven_takeoff(obj);
  }
  destroyed = gear_object_for_use(player, obj, amt, false, &none_left);
  msg("You destroy %s (%c).", name, label);
  if (destroyed->artifact) {
    object_desc(name, sizeof(name), destroyed, ODESC_FULL | ODESC_SINGULAR,
                player);
    msg("You no longer have the %s (%c).", name, label);
  } else {
    struct object* first;
    struct object* desc_target;
    uint16_t total;
    if (equipped || tval_can_have_charges(obj)) {
      first = NULL;
      if (none_left) {
        total = 0;
        desc_target = destroyed;
      } else {
        total = obj->number;
        desc_target = obj;
      }
    } else {
      total = object_pack_total(player, obj, false, &first);
      desc_target = (total) ? obj : destroyed;
    }
    object_desc(name, sizeof(name), desc_target,
                ODESC_PREFIX | ODESC_FULL | ODESC_ALTNUM | (total << 16),
                player);
    if (!first) {
      msg("You have %s (%c).", name, label);
    } else {
      label = gear_to_label(player, first);
      if (total > first->number) {
        msg("You have %s (1st %c).", name, label);
      } else {
        msg("You have %s (%c).", name, label);
      }
    }
  }
  object_delete(player->cave, NULL, &destroyed->known);
  object_delete(cave, player->cave, &destroyed);
  if (quiver) sound(MSG_QUIVER);
  event_signal(EVENT_INVENTORY);
  event_signal(EVENT_EQUIPMENT);
  return true;
}
STATIC_OVL bool
inven_can_stack_partial(const struct object* obj1, const struct object* obj2)
{
  if (!object_stackable(obj1, obj2, OSTACK_PACK)) {
    return false;
  }
  if (obj1->number == obj1->kind->base->max_stack) {
    return false;
  }
  return true;
}
STATIC_OVL void
combine_pack(struct player* p)
{
  struct object *obj1, *obj2, *prev;
  bool display_message = false;
  bool disable_repeat = false;
  obj1 = gear_last_item(p);
  while (obj1) {
    assert(obj1->kind);
    prev = obj1->prev;
    for (obj2 = p->gear; obj2 && obj2 != obj1; obj2 = obj2->next) {
      assert(obj2->kind);
      if (object_mergeable(obj2, obj1, OSTACK_PACK)) {
        int quiver1_slot = slot_by_name(p, "first quiver");
        struct object* quiver1_obj = slot_object(p, quiver1_slot);
        int quiver2_slot = slot_by_name(p, "second quiver");
        struct object* quiver2_obj = slot_object(p, quiver2_slot);
        if (obj1 == quiver1_obj) {
          if (obj2 == quiver2_obj) {
            p->body.slots[quiver1_slot].obj = quiver2_obj;
            p->body.slots[quiver2_slot].obj = NULL;
            --p->upkeep->equip_cnt;
          } else {
            p->body.slots[quiver1_slot].obj = obj2;
          }
        } else if (obj1 == quiver2_obj) {
          if (obj2 == quiver1_obj) {
            p->body.slots[quiver2_slot].obj = NULL;
            --p->upkeep->equip_cnt;
          } else {
            p->body.slots[quiver2_slot].obj = obj2;
          }
        }
        display_message = true;
        disable_repeat = true;
        object_absorb(obj2->known, obj1->known);
        obj1->known = NULL;
        object_absorb(obj2, obj1);
        obj2->known->number = obj2->number;
        break;
      } else {
        if (inven_can_stack_partial(obj2, obj1)) {
          object_absorb_partial(obj2->known, obj1->known);
          object_absorb_partial(obj2, obj1);
          obj2->known->number = obj2->number;
          obj1->known->number = obj1->number;
          break;
        }
      }
    }
    obj1 = prev;
  }
  calc_inventory(p);
  event_signal(EVENT_INVENTORY);
  event_signal(EVENT_EQUIPMENT);
  if (display_message) {
    msg("You combine some items in your pack.");
    if (disable_repeat) cmd_disable_repeat();
  }
}
STATIC_OVL bool
pack_is_full(void)
{
  return pack_slots_used(player) == z_info->pack_size;
}
STATIC_OVL bool
pack_is_overfull(void)
{
  return pack_slots_used(player) > z_info->pack_size;
}
STATIC_OVL void
pack_overflow(struct object* obj)
{
  int i;
  char o_name[80];
  if (!pack_is_overfull()) return;
  disturb(player, false);
  msg("Your pack overflows!");
  for (i = 1; i <= z_info->pack_size; i++)
    if (!player->upkeep->inven[i]) break;
  if (!obj) {
    obj = player->upkeep->inven[i - 1];
  }
  assert(obj != NULL);
  object_desc(o_name, sizeof(o_name), obj, ODESC_PREFIX | ODESC_FULL, player);
  msg("You drop %s.", o_name);
  gear_excise_object(player, obj);
  drop_near(cave, &obj, 0, player->grid, false, true);
  msg("You no longer have %s.", o_name);
  if (player->upkeep->notice) notice_stuff(player);
  if (player->upkeep->update) update_stuff(player);
  if (player->upkeep->redraw) redraw_stuff(player);
}
STATIC_OVL bool
player_has_throwable(struct player* p, bool show_msg)
{
  struct object* thrown;
  int nthrow = scan_items(&thrown, 1, player, USE_INVEN, obj_is_throwing);
  if (nthrow <= 0) {
    if (show_msg) {
      msg("You don't have anything designed for throwing in your inventory.");
    }
    return false;
  }
  return true;
}
STATIC_OVL bool
player_has_throwable_prereq(void)
{
  return player_has_throwable(player, true);
}
STATIC_OVL void
init_ignore(void)
{
  int i;
  num_ego_types = z_info->e_max;
  ego_ignore_types = mem_zalloc(z_info->e_max * sizeof(bool*));
  for (i = 0; i < z_info->e_max; i++)
    ego_ignore_types[i] = mem_zalloc(ITYPE_MAX * sizeof(bool));
}
STATIC_OVL void
cleanup_ignore(void)
{
  int i;
  for (i = 0; i < num_ego_types; i++) mem_free(ego_ignore_types[i]);
  mem_free(ego_ignore_types);
}
STATIC_OVL void
ignore_birth_init(void)
{
  int i, j;
  for (i = 0; i < z_info->k_max; i++) k_info[i].ignore = false;
  for (i = ITYPE_NONE; i < ITYPE_MAX; i++) ignore_level[i] = IGNORE_NONE;
  for (i = 0; i < z_info->e_max; i++)
    for (j = ITYPE_NONE; j < ITYPE_MAX; j++) ego_ignore_types[i][j] = 0;
}
STATIC_OVL void
rune_add_autoinscription(struct object* obj, int i)
{
  char current_note[80] = "";
  if (!rune_note(i)) return;
  if (obj->note && strstr(quark_str(obj->note), quark_str(rune_note(i))))
    return;
  if (obj->note)
    my_strcpy(current_note, quark_str(obj->note), sizeof(current_note));
  my_strcat(current_note, quark_str(rune_note(i)), sizeof(current_note));
  obj->note = quark_add(current_note);
}
STATIC_OVL void
rune_autoinscribe(struct player* p, int i)
{
  struct object* obj;
  if (!player_knows_rune(p, i)) {
    return;
  }
  if (cave)
    for (obj = square_object(cave, p->grid); obj; obj = obj->next)
      if (object_has_rune(obj, i)) rune_add_autoinscription(obj, i);
  for (obj = p->gear; obj; obj = obj->next)
    if (object_has_rune(obj, i)) rune_add_autoinscription(obj, i);
}
STATIC_OVL void
runes_autoinscribe(struct player* p, struct object* obj)
{
  int i, rune_max = max_runes();
  for (i = 0; i < rune_max; i++)
    if (object_has_rune(obj, i) && player_knows_rune(p, i))
      rune_add_autoinscription(obj, i);
}
STATIC_OVL const char*
get_autoinscription(struct object_kind* kind, bool aware)
{
  if (!kind)
    return NULL;
  else if (aware)
    return quark_str(kind->note_aware);
  else
    return quark_str(kind->note_unaware);
}
STATIC_OVL int
apply_autoinscription(struct player* p, struct object* obj)
{
  char o_name[80];
  bool aware = obj->kind->aware;
  const char* note = obj ? get_autoinscription(obj->kind, aware) : NULL;
  if (aware && quark_str(obj->note) && quark_str(obj->kind->note_unaware) &&
      streq(quark_str(obj->note), quark_str(obj->kind->note_unaware)) &&
      (!note || !streq(quark_str(obj->note), note)))
    obj->note = 0;
  runes_autoinscribe(p, obj);
  if (!note) return 0;
  if (obj->note) return 0;
  if (!object_is_carried(p, obj)) return 0;
  if (ignore_item_ok(p, obj)) return 0;
  object_desc(o_name, sizeof(o_name), obj, ODESC_PREFIX | ODESC_FULL, p);
  if (note[0] != 0)
    obj->note = quark_add(note);
  else
    obj->note = 0;
  msg("You autoinscribe %s.", o_name);
  return 1;
}
STATIC_OVL int
remove_autoinscription(int16_t kind)
{
  struct object_kind* k = objkind_byid(kind);
  if (!k) return 0;
  if (!k->aware) {
    if (!k->note_unaware) {
      return 0;
    } else {
      k->note_unaware = 0;
      return 1;
    }
  }
  if (!k->note_aware) return 0;
  k->note_aware = 0;
  return 1;
}
STATIC_OVL int
add_autoinscription(int16_t kind, const char* inscription, bool aware)
{
  struct object_kind* k = objkind_byid(kind);
  if (!k) return 0;
  if (!inscription) return remove_autoinscription(kind);
  if (aware)
    k->note_aware = quark_add(inscription);
  else
    k->note_unaware = quark_add(inscription);
  return 1;
}
STATIC_OVL void
autoinscribe_ground(struct player* p)
{
  struct object* obj;
  for (obj = square_object(cave, p->grid); obj; obj = obj->next)
    apply_autoinscription(p, obj);
}
STATIC_OVL void
autoinscribe_pack(struct player* p)
{
  struct object* obj;
  for (obj = p->gear; obj; obj = obj->next) apply_autoinscription(p, obj);
}
STATIC_OVL void
object_ignore_flavor_of(const struct object* obj)
{
  if (object_flavor_is_aware(obj))
    obj->kind->ignore |= IGNORE_IF_AWARE;
  else
    obj->kind->ignore |= IGNORE_IF_UNAWARE;
}
STATIC_OVL ignore_type_t
ignore_type_of(const struct object* obj)
{
  size_t i;
  for (i = 0; i < N_ELEMENTS(quality_mapping); i++) {
    if (quality_mapping[i].tval == obj->tval) {
      if (quality_mapping[i].identifier[0]) {
        if (!strstr(obj->kind->name, quality_mapping[i].identifier)) continue;
      }
      return quality_mapping[i].ignore_type;
    }
  }
  return ITYPE_MAX;
}
STATIC_OVL bool
ego_has_ignore_type(struct ego_item* ego, ignore_type_t itype)
{
  struct poss_item* poss;
  for (poss = ego->poss_items; poss; poss = poss->next) {
    size_t i;
    struct object_kind* kind = &k_info[poss->kidx];
    for (i = 0; i < N_ELEMENTS(quality_mapping); i++)
      if ((quality_mapping[i].tval == kind->tval) &&
          (quality_mapping[i].ignore_type == itype) &&
          strstr(kind->name, quality_mapping[i].identifier))
        return true;
  }
  return false;
}
STATIC_OVL int
cmp_object_trait(int bonus, int base)
{
  int amt = base;
  if (amt > 0) amt = 0;
  return CMP(bonus, amt);
}
STATIC_OVL int
is_object_good(const struct object* obj)
{
  int good = 0;
  good += cmp_object_trait(obj->att, obj->kind->att);
  good += cmp_object_trait(obj->dd, obj->kind->dd);
  good += cmp_object_trait(obj->ds, obj->kind->ds);
  good += cmp_object_trait(obj->evn, obj->kind->evn);
  good += cmp_object_trait(obj->pd, obj->kind->pd);
  good += cmp_object_trait(obj->ps, obj->kind->ps);
  return good;
}
STATIC_OVL uint8_t
ignore_level_of(const struct object* obj)
{
  uint8_t value = 0;
  if (object_runes_known(obj)) {
    int isgood = is_object_good(obj);
    if (isgood > 0) {
      value = IGNORE_GOOD;
    } else if (isgood < 0) {
      value = IGNORE_BAD;
    } else {
      value = IGNORE_AVERAGE;
    }
    if (obj->ego)
      value = IGNORE_ALL;
    else if (obj->artifact)
      value = IGNORE_MAX;
  } else {
    if ((obj->known->notice & OBJ_NOTICE_ASSESSED) && !obj->artifact)
      value = IGNORE_ALL;
    else
      value = IGNORE_MAX;
  }
  return value;
}
STATIC_OVL void
kind_ignore_clear(struct object_kind* kind)
{
  kind->ignore = 0;
  player->upkeep->notice |= PN_IGNORE;
}
STATIC_OVL void
ego_ignore(struct object* obj)
{
  assert(obj->ego);
  ego_ignore_types[obj->ego->eidx][ignore_type_of(obj)] = true;
  player->upkeep->notice |= PN_IGNORE;
}
STATIC_OVL void
ego_ignore_clear(struct object* obj)
{
  assert(obj->ego);
  ego_ignore_types[obj->ego->eidx][ignore_type_of(obj)] = false;
  player->upkeep->notice |= PN_IGNORE;
}
STATIC_OVL void
ego_ignore_toggle(int e_idx, int itype)
{
  ego_ignore_types[e_idx][itype] = !ego_ignore_types[e_idx][itype];
  player->upkeep->notice |= PN_IGNORE;
}
STATIC_OVL bool
ego_is_ignored(int e_idx, int itype)
{
  return ego_ignore_types[e_idx][itype];
}
STATIC_OVL bool
kind_is_ignored_aware(const struct object_kind* kind)
{
  return (kind->ignore & IGNORE_IF_AWARE) ? true : false;
}
STATIC_OVL bool
kind_is_ignored_unaware(const struct object_kind* kind)
{
  return (kind->ignore & IGNORE_IF_UNAWARE) ? true : false;
}
STATIC_OVL void
kind_ignore_when_aware(struct object_kind* kind)
{
  kind->ignore |= IGNORE_IF_AWARE;
  player->upkeep->notice |= PN_IGNORE;
}
STATIC_OVL void
kind_ignore_when_unaware(struct object_kind* kind)
{
  kind->ignore |= IGNORE_IF_UNAWARE;
  player->upkeep->notice |= PN_IGNORE;
}
STATIC_OVL bool
object_is_ignored(const struct object* obj)
{
  uint8_t type;
  if (!obj->known) return false;
  if (obj->known->notice & OBJ_NOTICE_IGNORE) return true;
  if (obj->artifact || check_for_inscrip(obj, "!k") ||
      check_for_inscrip(obj, "!*"))
    return false;
  if (object_flavor_is_aware(obj) ? kind_is_ignored_aware(obj->kind)
                                  : kind_is_ignored_unaware(obj->kind))
    return true;
  type = ignore_type_of(obj);
  if (type == ITYPE_MAX) return false;
  if (obj->known->ego && ego_is_ignored(obj->ego->eidx, type)) return true;
  if ((obj->known->notice & OBJ_NOTICE_ASSESSED) && !obj->artifact &&
      ignore_level[type] == IGNORE_ALL)
    return true;
  if (ignore_level_of(obj) <= ignore_level[type])
    return true;
  else
    return false;
}
STATIC_OVL bool
ignore_item_ok(const struct player* p, const struct object* obj)
{
  if (p->unignoring) return false;
  return object_is_ignored(obj);
}
STATIC_OVL bool
ignore_known_item_ok(const struct player* p, const struct object* obj)
{
  struct object* base_obj = cave->objects[obj->oidx];
  if (p->unignoring) return false;
  assert(base_obj);
  return object_is_ignored(base_obj);
}
STATIC_OVL void
ignore_drop(struct player* p)
{
  struct object* obj;
  for (obj = gear_last_item(p); obj; obj = obj->prev) {
    assert(obj->kind);
    if (!ignore_item_ok(p, obj)) continue;
    if (!check_for_inscrip(obj, "!d") && !check_for_inscrip(obj, "!*")) {
      struct command* drop_cmd;
      if (object_is_equipped(p->body, obj)) {
        if (!verify_object("Really take off and drop", obj, p)) {
          const char* inscription = quark_str(obj->note);
          if (inscription == NULL) {
            obj->note = quark_add("!d");
          } else {
            char buffer[1024];
            my_strcpy(buffer, inscription, sizeof(buffer));
            my_strcat(buffer, "!d", sizeof(buffer));
            obj->note = quark_add(buffer);
          }
          continue;
        }
      }
      p->upkeep->dropping = true;
      cmdq_push(CMD_DROP);
      drop_cmd = cmdq_peek();
      assert(drop_cmd);
      cmd_set_arg_item(drop_cmd, "item", obj);
      cmd_set_arg_number(drop_cmd, "quantity", obj->number);
      drop_cmd->is_background_command = true;
    }
  }
  p->upkeep->update |= (PU_INVEN);
  p->upkeep->notice |= (PN_COMBINE);
}
STATIC_OVL const char*
ignore_name_for_type(ignore_type_t type)
{
  size_t i;
  for (i = ITYPE_NONE + 1; i < ITYPE_MAX; i++) {
    if (quality_choices[i].enum_val == type) return quality_choices[i].name;
  }
  return "unknown";
}
STATIC_OVL void
info_out_list(textblock* tb, const char* list[], size_t count)
{
  size_t i;
  for (i = 0; i < count; i++) {
    textblock_append(tb, "%s", list[i]);
    if (i != (count - 1)) textblock_append(tb, ", ");
  }
  textblock_append(tb, ".\n");
}
STATIC_OVL size_t
element_info_collect(const bool list[], const char* recepticle[])
{
  int i, count = 0;
  for (i = 0; i < ELEM_MAX; i++) {
    if (list[i]) recepticle[count++] = projections[i].name;
  }
  return count;
}
STATIC_OVL bool
describe_stats(textblock* tb, const struct object* obj, oinfo_detail_t mode)
{
  size_t count = 0, i;
  bool detail = false;
  bool suppress_details = mode & (OINFO_EGO | OINFO_FAKE) ? true : false;
  bool known_effect = false;
  if (obj->known->ego) known_effect = true;
  if (tval_can_have_flavor_k(obj->kind) && object_flavor_is_aware(obj)) {
    known_effect = true;
  }
  for (i = 0; i < OBJ_MOD_MAX; i++) {
    if (obj->modifiers[i]) {
      count++;
      detail = true;
    }
  }
  if (!count) return false;
  for (i = 0; i < OBJ_MOD_MAX; i++) {
    const char* desc = lookup_obj_property(OBJ_PROPERTY_MOD, i)->name;
    int val = obj->known->modifiers[i];
    if (!val) continue;
    if (detail && !suppress_details) {
      int attr = (val > 0) ? COLOUR_L_GREEN : COLOUR_RED;
      textblock_append_c(tb, attr, "%+i %s.\n", val, desc);
    } else if (known_effect) {
      textblock_append(tb, "Affects your %s\n", desc);
    }
  }
  return true;
}
STATIC_OVL bool
describe_elements(textblock* tb, const struct element_info el_info[])
{
  const char* r_descs[ELEM_MAX];
  const char* v_descs[ELEM_MAX];
  size_t i, count;
  bool list[ELEM_MAX], prev = false;
  for (i = 0; i < ELEM_MAX; i++) list[i] = (el_info[i].res_level == 1);
  count = element_info_collect(list, r_descs);
  if (count) {
    textblock_append(tb, "Provides resistance to ");
    info_out_list(tb, r_descs, count);
    prev = true;
  }
  for (i = 0; i < ELEM_MAX; i++) list[i] = (el_info[i].res_level == -1);
  count = element_info_collect(list, v_descs);
  if (count) {
    textblock_append(tb, "Makes you vulnerable to ");
    info_out_list(tb, v_descs, count);
    prev = true;
  }
  return prev;
}
STATIC_OVL bool
describe_protects(textblock* tb, const bitflag flags[OF_SIZE])
{
  const char* p_descs[OF_MAX];
  int i, count = 0;
  for (i = 1; i < OF_MAX; i++) {
    struct obj_property* prop = lookup_obj_property(OBJ_PROPERTY_FLAG, i);
    if (!prop || (prop->subtype != OFT_PROT)) continue;
    if (of_has(flags, prop->index)) {
      p_descs[count++] = prop->desc;
    }
  }
  if (!count) return false;
  textblock_append(tb, "Provides protection from ");
  info_out_list(tb, p_descs, count);
  return true;
}
STATIC_OVL bool
describe_ignores(textblock* tb, const struct element_info el_info[])
{
  const char* descs[ELEM_MAX];
  size_t i, count;
  bool list[ELEM_MAX];
  for (i = 0; i < ELEM_MAX; i++) list[i] = (el_info[i].flags & EL_INFO_IGNORE);
  count = element_info_collect(list, descs);
  if (!count) return false;
  textblock_append(tb, "Cannot be harmed by ");
  info_out_list(tb, descs, count);
  return true;
}
STATIC_OVL bool
describe_hates(textblock* tb, const struct element_info el_info[])
{
  const char* descs[ELEM_MAX];
  size_t i, count = 0;
  bool list[ELEM_MAX];
  for (i = 0; i < ELEM_MAX; i++) list[i] = (el_info[i].flags & EL_INFO_HATES);
  count = element_info_collect(list, descs);
  if (!count) return false;
  textblock_append(tb, "Can be destroyed by ");
  info_out_list(tb, descs, count);
  return true;
}
STATIC_OVL bool
describe_sustains(textblock* tb, const bitflag flags[OF_SIZE])
{
  const char* descs[STAT_MAX];
  int i, count = 0;
  for (i = 0; i < STAT_MAX; i++) {
    struct obj_property* prop = lookup_obj_property(OBJ_PROPERTY_STAT, i);
    if (of_has(flags, sustain_flag(prop->index))) descs[count++] = prop->name;
  }
  if (!count) return false;
  textblock_append(tb, "Sustains ");
  info_out_list(tb, descs, count);
  return true;
}
STATIC_OVL bool
describe_misc_magic(textblock* tb, const bitflag flags[OF_SIZE])
{
  int i;
  bool printed = false;
  for (i = 1; i < OF_MAX; i++) {
    struct obj_property* prop = lookup_obj_property(OBJ_PROPERTY_FLAG, i);
    if (!prop || prop->subtype == OFT_PROT) continue;
    if (of_has(flags, prop->index) && prop->desc &&
        !contains_only_spaces(prop->desc)) {
      textblock_append(tb, "%s.  ", prop->desc);
      printed = true;
    }
  }
  if (printed) textblock_append(tb, "\n");
  return printed;
}
STATIC_OVL bool
describe_abilities(textblock* tb, const struct object* obj, oinfo_detail_t mode)
{
  const char* name[8];
  int ac = 0;
  struct ability* ability;
  bool known, known_kind, known_ego;
  known = (mode & OINFO_SPOIL) || (mode & OINFO_SMITH);
  known_kind = obj->kind && obj->kind->aware;
  known_ego = obj->ego && obj->ego->aware;
  for (ability = obj->abilities; ability; ability = ability->next) {
    if (!known &&
        (!known_kind || !locate_ability(obj->kind->abilities, ability)) &&
        (!known_ego || !locate_ability(obj->ego->abilities, ability)) &&
        (!locate_ability(obj->known->abilities, ability))) {
      continue;
    }
    assert(ac < (int)N_ELEMENTS(name));
    name[ac++] = ability->name;
  }
  if (ac) {
    if (ac == 1) {
      textblock_append(tb, "It grants you the ability: ");
    } else {
      textblock_append(tb, "It grants you the abilities: ");
    }
    info_out_list(tb, name, ac);
    return true;
  }
  return false;
}
STATIC_OVL bool
describe_archery(textblock* tb, const struct object* obj)
{
  if (tval_is_launcher(obj)) {
    textblock_append(tb,
                     "It can shoot arrows %d squares (with "
                     "your current strength).",
                     archery_range(obj));
    textblock_append(tb, "\n");
    return true;
  }
  if (tval_is_ammo(obj)) {
    struct object* bow = equipped_item_by_slot_name(player, "shooting");
    if (bow) {
      if (obj->number == 1) {
        textblock_append(tb,
                         "It can be shot %d "
                         "squares (with your current strength "
                         "and bow).",
                         archery_range(bow));
      } else {
        textblock_append(tb,
                         "They can be shot %d "
                         "squares (with your current strength "
                         "and bow).",
                         archery_range(bow));
      }
    } else {
      if (obj->number == 1) {
        textblock_append(tb, "It can be shot by a bow.");
      } else {
        textblock_append(tb, "They can be shot by a bow.");
      }
    }
    textblock_append(tb, "\n");
    return true;
  }
  return false;
}
STATIC_OVL bool
describe_throwing(textblock* tb, const struct object* obj)
{
  if (obj_is_throwing(obj)) {
    textblock_append(tb,
                     "It can be thrown effectively (%d "
                     "squares with your current strength).",
                     throwing_range(obj));
    textblock_append(tb, "\n");
    return true;
  }
  return false;
}
STATIC_OVL bool
describe_slays(textblock* tb, const struct object* obj, oinfo_detail_t mode)
{
  int i, count = 0;
  bool known = (mode & OINFO_SPOIL) || (mode & OINFO_SMITH);
  const bool* s = known ? obj->slays : obj->known->slays;
  if (!s) return false;
  known = (mode & OINFO_SPOIL) || (mode & OINFO_SMITH);
  for (i = 1; i < z_info->slay_max; i++) {
    if (s[i]) {
      count++;
    }
  }
  if (!count) return false;
  if (tval_is_weapon(obj) || tval_is_fuel(obj))
    textblock_append(tb, "Slays ");
  else
    textblock_append(tb, "It causes your melee attacks to slay ");
  assert(count >= 1);
  for (i = 1; i < z_info->slay_max; i++) {
    if (!s[i]) continue;
    textblock_append(tb, "%s", slays[i].name);
    if (count > 1)
      textblock_append(tb, ", ");
    else
      textblock_append(tb, ".\n");
    count--;
  }
  return true;
}
STATIC_OVL bool
describe_brands(textblock* tb, const struct object* obj, oinfo_detail_t mode)
{
  int i, count = 0;
  bool known = (mode & OINFO_SPOIL) || (mode & OINFO_SMITH);
  bool* b = known ? obj->brands : obj->known->brands;
  if (!b) return false;
  for (i = 1; i < z_info->brand_max; i++) {
    if (b[i]) {
      count++;
    }
  }
  if (!count) return false;
  if (tval_is_weapon(obj) || tval_is_fuel(obj))
    textblock_append(tb, "Branded with ");
  else
    textblock_append(tb, "It brands your melee attacks with ");
  assert(count >= 1);
  for (i = 1; i < z_info->brand_max; i++) {
    if (!b[i]) continue;
    textblock_append(tb, "%s", brands[i].name);
    if (count > 1)
      textblock_append(tb, ", ");
    else
      textblock_append(tb, ".\n");
    count--;
  }
  return true;
}
STATIC_OVL void
get_known_flags(const struct object* obj, const oinfo_detail_t mode,
                bitflag flags[OF_SIZE])
{
  if ((mode & OINFO_EGO) || (mode & OINFO_SPOIL) || (mode & OINFO_SMITH)) {
    object_flags(obj, flags);
  } else {
    object_flags_known(obj, flags);
  }
  if (mode & OINFO_TERSE) {
    of_diff(flags, obj->kind->base->flags);
  }
}
STATIC_OVL void
get_known_elements(const struct object* obj, const oinfo_detail_t mode,
                   struct element_info el_info[])
{
  size_t i;
  for (i = 0; i < ELEM_MAX; i++) {
    if (player->obj_k->el_info[i].res_level || (mode & OINFO_SPOIL) ||
        (mode & OINFO_SMITH))
      el_info[i].res_level = obj->known->el_info[i].res_level;
    else
      el_info[i].res_level = 0;
    el_info[i].flags = obj->known->el_info[i].flags;
    if (obj->el_info[i].flags & EL_INFO_IGNORE) {
      if (obj->el_info[i].flags & EL_INFO_HATES)
        el_info[i].flags &= ~(EL_INFO_HATES);
      else
        el_info[i].flags &= ~(EL_INFO_IGNORE);
    }
    if (mode & OINFO_TERSE) el_info[i].flags &= ~(EL_INFO_HATES);
  }
}
STATIC_OVL bool
obj_known_light(const struct object* obj, oinfo_detail_t mode,
                const bitflag flags[OF_SIZE], int* intensity, bool* uses_fuel,
                int* refuel_turns)
{
  bool no_fuel;
  bool is_light = tval_is_light(obj);
  if (!is_light) return false;
  *intensity = (mode & OINFO_SMITH) ? obj->kind->pval : obj->pval;
  if (of_has(flags, OF_LIGHT)) {
    ++*intensity;
  }
  if (*intensity == 0) return false;
  no_fuel = of_has(flags, OF_NO_FUEL) ? true : false;
  if (no_fuel || obj->artifact) {
    *uses_fuel = false;
  } else {
    *uses_fuel = true;
  }
  if (is_light && of_has(flags, OF_TAKES_FUEL)) {
    *refuel_turns = z_info->fuel_lamp;
  } else {
    *refuel_turns = 0;
  }
  return true;
}
STATIC_OVL bool
describe_light(textblock* tb, const struct object* obj, oinfo_detail_t mode,
               const bitflag flags[OF_SIZE])
{
  int intensity = 0;
  bool uses_fuel = false;
  int refuel_turns = 0;
  bool terse = mode & OINFO_TERSE ? true : false;
  if (!obj_known_light(obj, mode, flags, &intensity, &uses_fuel, &refuel_turns))
    return false;
  if (tval_is_light(obj)) {
    textblock_append(tb, "Intensity ");
    textblock_append_c(tb, COLOUR_L_GREEN, "%d", intensity);
    textblock_append(tb, " light.");
    if (!obj->artifact && !uses_fuel)
      textblock_append(tb, "  No fuel required.");
    if (!terse) {
      if (refuel_turns)
        textblock_append(tb, "  Refills other lanterns up to %d turns of fuel.",
                         refuel_turns);
    }
    textblock_append(tb, "\n");
  }
  return true;
}
STATIC_OVL bool
describe_origin(textblock* tb, const struct object* obj, bool terse)
{
  char loot_spot[80];
  char name[80];
  int origin;
  const char* dropper = NULL;
  const char* article;
  bool unique = false;
  bool comma = false;
  if (terse && !obj_can_wear(obj)) return false;
  origin = obj->origin;
  if (obj->origin_depth)
    strnfmt(loot_spot, sizeof(loot_spot), "at %d feet", obj->origin_depth * 50);
  else
    my_strcpy(loot_spot, "on the surface", sizeof(loot_spot));
  if (obj->origin_race) {
    dropper = obj->origin_race->name;
    if (rf_has(obj->origin_race->flags, RF_UNIQUE)) {
      unique = true;
    }
    if (rf_has(obj->origin_race->flags, RF_NAME_COMMA)) {
      comma = true;
    }
  } else {
    dropper = "monster lost to history";
  }
  article = is_a_vowel(dropper[0]) ? "an " : "a ";
  if (unique)
    my_strcpy(name, dropper, sizeof(name));
  else {
    my_strcpy(name, article, sizeof(name));
    my_strcat(name, dropper, sizeof(name));
  }
  if (comma) {
    my_strcat(name, ",", sizeof(name));
  }
  switch (origins[origin].args) {
    case -1:
      return false;
    case 0:
      textblock_append(tb, "%s", origins[origin].desc);
      break;
    case 1:
      textblock_append(tb, origins[origin].desc, loot_spot);
      break;
    case 2:
      textblock_append(tb, origins[origin].desc, name, loot_spot);
      break;
  }
  textblock_append(tb, "\n\n");
  return true;
}
STATIC_OVL void
describe_flavor_text(textblock* tb, const struct object* obj, bool ego,
                     bool smith)
{
  if (obj->artifact && obj->artifact->text) {
    textblock_append(tb, "%s\n\n", obj->artifact->text);
  } else if (obj->kind->tval == TV_NOTE &&
             streq(obj->kind->name, "tutorial note")) {
    textblock* note_tb = tutorial_expand_message(obj->pval);
    textblock_append_textblock(tb, note_tb);
    textblock_free(note_tb);
  } else if (object_flavor_is_aware(obj) || ego || smith) {
    bool did_desc = false;
    if (!ego && obj->kind->text) {
      textblock_append(tb, "%s", obj->kind->text);
      did_desc = true;
    }
    if ((ego || (obj->ego != NULL)) && obj->ego->text) {
      if (did_desc) textblock_append(tb, "  ");
      textblock_append(tb, "%s\n\n", obj->ego->text);
    } else if (did_desc) {
      textblock_append(tb, "\n\n");
    }
  }
}
STATIC_OVL textblock*
object_info_out(const struct object* obj, int mode)
{
  bitflag flags[OF_SIZE];
  struct element_info el_info[ELEM_MAX];
  bool something = false;
  bool terse = mode & OINFO_TERSE ? true : false;
  bool subjective = mode & OINFO_SUBJ ? true : false;
  bool ego = mode & OINFO_EGO ? true : false;
  bool smith = mode & OINFO_SMITH ? true : false;
  textblock* tb = textblock_new();
  assert(obj->known);
  if (obj->kind != obj->known->kind) {
    textblock_append(tb, "\n\nYou do not know what this is.\n");
    return tb;
  }
  get_known_flags(obj, mode, flags);
  get_known_elements(obj, mode, el_info);
  if (subjective) describe_origin(tb, obj, terse);
  if (!terse) describe_flavor_text(tb, obj, ego, smith);
  if (!object_runes_known(obj) && (obj->known->notice & OBJ_NOTICE_ASSESSED) &&
      !tval_is_useable(obj)) {
    textblock_append(
        tb, "You do not know the full extent of this item's powers.\n");
    something = true;
  }
  if (describe_stats(tb, obj, mode)) something = true;
  if (describe_slays(tb, obj, mode)) something = true;
  if (describe_brands(tb, obj, mode)) something = true;
  if (describe_elements(tb, el_info)) something = true;
  if (describe_protects(tb, flags)) something = true;
  if (describe_sustains(tb, flags)) something = true;
  if (describe_misc_magic(tb, flags)) something = true;
  if (describe_abilities(tb, obj, mode)) something = true;
  if (describe_archery(tb, obj)) something = true;
  if (describe_throwing(tb, obj)) something = true;
  if (describe_light(tb, obj, mode, flags)) something = true;
  if (describe_ignores(tb, el_info)) something = true;
  if (describe_hates(tb, el_info)) something = true;
  if (something) textblock_append(tb, "\n");
  if (!something && !terse && !smith && !object_effect(obj))
    textblock_append(
        tb, "\n\nThis item does not seem to possess any special abilities.");
  return tb;
}
STATIC_OVL textblock*
object_info(const struct object* obj, oinfo_detail_t mode)
{
  mode |= OINFO_SUBJ;
  return object_info_out(obj, mode);
}
STATIC_OVL textblock*
object_info_ego(struct ego_item* ego)
{
  struct object_kind* kind = NULL;
  struct object obj = OBJECT_NULL;
  size_t i;
  textblock* result;
  for (i = 0; i < z_info->k_max; i++) {
    kind = &k_info[i];
    if (!kind->name) continue;
    if (i == ego->poss_items->kidx) break;
  }
  obj.kind = kind;
  obj.tval = kind->tval;
  obj.sval = kind->sval;
  obj.ego = ego;
  ego_apply_magic(&obj, 0);
  result = object_info_out(&obj, OINFO_NONE | OINFO_EGO);
  object_wipe(&obj);
  return result;
}
STATIC_OVL void
object_info_chardump(ang_file* f, const struct object* obj, int indent,
                     int wrap)
{
  textblock* tb = object_info_out(obj, OINFO_TERSE | OINFO_SUBJ);
  textblock_to_file(tb, f, indent, wrap);
  textblock_free(tb);
}
STATIC_OVL void
object_info_spoil(ang_file* f, const struct object* obj, int wrap)
{
  textblock* tb = object_info_out(obj, OINFO_SPOIL);
  textblock_to_file(tb, f, 0, wrap);
  textblock_free(tb);
}
STATIC_OVL bool
grab_element_flag(struct element_info* info, const char* flag_name)
{
  char* under = strchr(flag_name, '_');
  size_t i;
  if (!under) {
    return false;
  }
  for (i = 0; i < ELEM_MAX; i++) {
    if (streq(under + 1, element_names[i])) {
      if (!strncmp(flag_name, "IGNORE", under - flag_name)) {
        info[i].flags |= EL_INFO_IGNORE;
        return true;
      }
      if (!strncmp(flag_name, "HATES", under - flag_name)) {
        info[i].flags |= EL_INFO_HATES;
        return true;
      }
    }
  }
  return false;
}
STATIC_OVL enum parser_error
write_dummy_object_record(struct artifact* art, const char* name)
{
  struct object_kind *temp, *dummy;
  int i;
  char mod_name[100];
  z_info->k_max += 1;
  temp = mem_realloc(k_info, (z_info->k_max + 1) * sizeof(*temp));
  if (!temp) {
    return PARSE_ERROR_INTERNAL;
  }
  k_info = temp;
  dummy = &k_info[z_info->k_max - 1];
  memset(dummy, 0, sizeof(*dummy));
  dummy->tval = art->tval;
  dummy->base = &kb_info[dummy->tval];
  strnfmt(mod_name, sizeof(mod_name), "& %s~", name);
  dummy->name = string_make(mod_name);
  dummy->kidx = z_info->k_max - 1;
  dummy->level = art->level;
  for (i = 0; i < TV_MAX; i++) {
    if (kb_info[i].tval == dummy->tval) {
      kb_info[i].num_svals++;
      dummy->sval = kb_info[i].num_svals;
      break;
    }
  }
  if (i == TV_MAX) return PARSE_ERROR_INTERNAL;
  art->sval = dummy->sval;
  dummy->d_char = '*';
  dummy->d_attr = COLOUR_RED;
  art->d_attr = dummy->d_attr;
  of_copy(dummy->flags, kb_info[i].flags);
  kf_copy(dummy->kind_flags, kb_info[i].kind_flags);
  (void)memcpy(dummy->el_info, kb_info[i].el_info,
               sizeof(dummy->el_info[0]) * ELEM_MAX);
  kf_on(dummy->kind_flags, KF_INSTA_ART);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_projection_code(struct parser* p)
{
  const char* code = parser_getstr(p, "code");
  struct projection* h = parser_priv(p);
  int index = h ? h->index + 1 : 0;
  struct projection* projection = mem_zalloc(sizeof *projection);
  parser_setpriv(p, projection);
  projection->next = h;
  projection->index = index;
  if ((index < ELEM_MAX) && !streq(code, element_names[index])) {
    return PARSE_ERROR_ELEMENT_NAME_MISMATCH;
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_projection_name(struct parser* p)
{
  const char* name = parser_getstr(p, "name");
  struct projection* projection = parser_priv(p);
  if (!projection) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  string_free(projection->name);
  projection->name = string_make(name);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_projection_type(struct parser* p)
{
  const char* type = parser_getstr(p, "type");
  struct projection* projection = parser_priv(p);
  if (!projection) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  string_free(projection->type);
  projection->type = string_make(type);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_projection_desc(struct parser* p)
{
  const char* desc = parser_getstr(p, "desc");
  struct projection* projection = parser_priv(p);
  if (!projection) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  string_free(projection->desc);
  projection->desc = string_make(desc);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_projection_player_desc(struct parser* p)
{
  const char* desc = parser_getstr(p, "desc");
  struct projection* projection = parser_priv(p);
  if (!projection) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  string_free(projection->player_desc);
  projection->player_desc = string_make(desc);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_projection_blind_desc(struct parser* p)
{
  const char* desc = parser_getstr(p, "desc");
  struct projection* projection = parser_priv(p);
  if (!projection) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  string_free(projection->blind_desc);
  projection->blind_desc = string_make(desc);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_projection_message_type(struct parser* p)
{
  int msg_index;
  const char* type;
  struct projection* projection = parser_priv(p);
  if (!projection) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  type = parser_getsym(p, "type");
  msg_index = message_lookup_by_name(type);
  if (msg_index < 0) {
    return PARSE_ERROR_INVALID_MESSAGE;
  }
  projection->msgt = msg_index;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_projection_damaging(struct parser* p)
{
  int damaging = parser_getuint(p, "answer");
  struct projection* projection = parser_priv(p);
  if (!projection) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  projection->damaging = (damaging == 1) ? true : false;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_projection_evade(struct parser* p)
{
  int evade = parser_getuint(p, "answer");
  struct projection* projection = parser_priv(p);
  if (!projection) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  projection->evade = (evade == 1) ? true : false;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_projection_obvious(struct parser* p)
{
  int obvious = parser_getuint(p, "answer");
  struct projection* projection = parser_priv(p);
  if (!projection) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  projection->obvious = (obvious == 1) ? true : false;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_projection_wake(struct parser* p)
{
  int wake = parser_getuint(p, "answer");
  struct projection* projection = parser_priv(p);
  if (!projection) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  projection->wake = (wake == 1) ? true : false;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_projection_color(struct parser* p)
{
  struct projection* projection = parser_priv(p);
  const char* color;
  if (!projection) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  color = parser_getsym(p, "color");
  if (strlen(color) > 1) {
    projection->color = color_text_to_attr(color);
  } else {
    projection->color = color_char_to_attr(color[0]);
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_parse_projection(void)
{
  struct parser* p = parser_new();
  parser_setpriv(p, NULL);
  parser_reg(p, "code str code", parse_projection_code);
  parser_reg(p, "name str name", parse_projection_name);
  parser_reg(p, "type str type", parse_projection_type);
  parser_reg(p, "desc str desc", parse_projection_desc);
  parser_reg(p, "player-desc str desc", parse_projection_player_desc);
  parser_reg(p, "blind-desc str desc", parse_projection_blind_desc);
  parser_reg(p, "msgt sym type", parse_projection_message_type);
  parser_reg(p, "damaging uint answer", parse_projection_damaging);
  parser_reg(p, "evade uint answer", parse_projection_evade);
  parser_reg(p, "obvious uint answer", parse_projection_obvious);
  parser_reg(p, "wake uint answer", parse_projection_wake);
  parser_reg(p, "color sym color", parse_projection_color);
  return p;
}
STATIC_OVL errr
run_parse_projection(struct parser* p)
{
  return parse_file_quit_not_found(p, "projection");
}
STATIC_OVL errr
finish_parse_projection(struct parser* p)
{
  struct projection *projection, *next = NULL;
  int element_count = 0, count = 0;
  z_info->projection_max = 0;
  projection = parser_priv(p);
  while (projection) {
    z_info->projection_max++;
    if (projection->type && streq(projection->type, "element")) {
      element_count++;
    }
    projection = projection->next;
  }
  if (element_count + 1 < (int)N_ELEMENTS(element_names)) {
    quit_fmt("Too few elements in projection.txt!");
  } else if (element_count + 1 > (int)N_ELEMENTS(element_names)) {
    quit_fmt("Too many elements in projection.txt!");
  }
  projections = mem_zalloc((z_info->projection_max) * sizeof(*projection));
  count = z_info->projection_max - 1;
  for (projection = parser_priv(p); projection; projection = next, count--) {
    memcpy(&projections[count], projection, sizeof(*projection));
    next = projection->next;
    mem_free(projection);
  }
  parser_destroy(p);
  return 0;
}
STATIC_OVL void
cleanup_projection(void)
{
  int idx;
  for (idx = 0; idx < z_info->projection_max; idx++) {
    string_free(projections[idx].name);
    string_free(projections[idx].type);
    string_free(projections[idx].desc);
    string_free(projections[idx].player_desc);
    string_free(projections[idx].blind_desc);
  }
  mem_free(projections);
}
STATIC_OVL enum parser_error
parse_object_base_defaults(struct parser* p)
{
  const char* label;
  int value;
  struct kb_parsedata* d = parser_priv(p);
  assert(d);
  label = parser_getsym(p, "label");
  value = parser_getint(p, "value");
  if (streq(label, "break-chance")) {
    d->defaults.break_perc = value;
  } else if (streq(label, "max-stack")) {
    d->defaults.max_stack = value;
  } else {
    return PARSE_ERROR_UNDEFINED_DIRECTIVE;
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_base_name(struct parser* p)
{
  struct object_base* kb;
  struct kb_parsedata* d = parser_priv(p);
  assert(d);
  kb = mem_alloc(sizeof *kb);
  memcpy(kb, &d->defaults, sizeof(*kb));
  kb->next = d->kb;
  d->kb = kb;
  kb->tval = tval_find_idx(parser_getsym(p, "tval"));
  if (kb->tval == -1) {
    return PARSE_ERROR_UNRECOGNISED_TVAL;
  }
  if (parser_hasval(p, "name")) {
    kb->name = string_make(parser_getstr(p, "name"));
  }
  kb->num_svals = 0;
  kb->smith_slays = mem_zalloc(z_info->slay_max * sizeof(*(kb->smith_slays)));
  kb->smith_brands =
      mem_zalloc(z_info->brand_max * sizeof(*(kb->smith_brands)));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_base_graphics(struct parser* p)
{
  struct object_base* kb;
  const char* color;
  struct kb_parsedata* d = parser_priv(p);
  assert(d);
  kb = d->kb;
  if (!kb) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  color = parser_getsym(p, "color");
  if (strlen(color) > 1) {
    kb->attr = color_text_to_attr(color);
  } else {
    kb->attr = color_char_to_attr(color[0]);
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_base_break(struct parser* p)
{
  struct object_base* kb;
  struct kb_parsedata* d = parser_priv(p);
  assert(d);
  kb = d->kb;
  if (!kb) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  kb->break_perc = parser_getint(p, "breakage");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_base_max_stack(struct parser* p)
{
  struct kb_parsedata* d = parser_priv(p);
  struct object_base* kb;
  assert(d);
  kb = d->kb;
  if (!kb) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  kb->max_stack = parser_getint(p, "size");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_base_smith_attack(struct parser* p)
{
  struct object_base* kb;
  struct kb_parsedata* d = parser_priv(p);
  assert(d);
  kb = d->kb;
  if (!kb) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  kb->smith_attack_valid = true;
  kb->smith_attack_artistry = parser_getint(p, "artistry");
  kb->smith_attack_artefact = parser_getint(p, "artefact");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_base_flags(struct parser* p)
{
  struct object_base* kb;
  char *s, *t;
  struct kb_parsedata* d = parser_priv(p);
  assert(d);
  kb = d->kb;
  if (!kb) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  s = string_make(parser_getstr(p, "flags"));
  t = strtok(s, " |");
  while (t) {
    bool found = false;
    if (!grab_flag(kb->flags, OF_SIZE, obj_flags, t)) {
      found = true;
    }
    if (!grab_flag(kb->kind_flags, KF_SIZE, kind_flags, t)) {
      found = true;
    }
    if (grab_element_flag(kb->el_info, t)) {
      found = true;
    }
    if (!found) {
      break;
    }
    t = strtok(NULL, " |");
  }
  string_free(s);
  return t ? PARSE_ERROR_INVALID_FLAG : PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_base_smith_values(struct parser* p)
{
  struct object_base* kb;
  char *s, *t;
  struct kb_parsedata* d = parser_priv(p);
  assert(d);
  kb = d->kb;
  if (!kb) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  s = string_make(parser_getstr(p, "values"));
  t = strtok(s, " |");
  while (t) {
    int value = 0;
    int index = 0;
    bool found = false;
    if (!grab_index_and_int(&value, &index, obj_mods, "", t)) {
      found = true;
      kb->smith_modifiers[index] = value;
    }
    if (!grab_index_and_int(&value, &index, element_names, "RES_", t)) {
      found = true;
      if (kb->smith_el_info[index].res_level == 0) {
        kb->smith_el_info[index].res_level = value;
      } else {
        kb->smith_el_info[index].res_level = 2;
      }
    }
    if (!found) {
      break;
    }
    t = strtok(NULL, " |");
  }
  string_free(s);
  return t ? PARSE_ERROR_INVALID_VALUE : PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_base_smith_flags(struct parser* p)
{
  struct object_base* kb;
  char *s, *t;
  struct kb_parsedata* d = parser_priv(p);
  assert(d);
  kb = d->kb;
  if (!kb) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  s = string_make(parser_getstr(p, "flags"));
  t = strtok(s, " |");
  while (t) {
    bool found = false;
    if (!grab_flag(kb->smith_flags, OF_SIZE, obj_flags, t)) {
      found = true;
    }
    if (grab_element_flag(kb->smith_el_info, t)) {
      found = true;
    }
    if (!found) {
      break;
    }
    t = strtok(NULL, " |");
  }
  string_free(s);
  return t ? PARSE_ERROR_INVALID_FLAG : PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_base_smith_slay(struct parser* p)
{
  struct object_base* kb;
  const char* s;
  int i;
  struct kb_parsedata* d = parser_priv(p);
  assert(d);
  kb = d->kb;
  if (!kb) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  s = parser_getstr(p, "code");
  for (i = 1; i < z_info->slay_max; i++) {
    if (streq(s, slays[i].code)) break;
  }
  if (i == z_info->slay_max) {
    return PARSE_ERROR_UNRECOGNISED_SLAY;
  }
  if (!kb->smith_slays) {
    kb->smith_slays = mem_zalloc(z_info->slay_max * sizeof(bool));
  }
  kb->smith_slays[i] = true;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_base_smith_brand(struct parser* p)
{
  struct object_base* kb;
  const char* s;
  int i;
  struct kb_parsedata* d = parser_priv(p);
  assert(d);
  kb = d->kb;
  if (!kb) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  s = parser_getstr(p, "code");
  for (i = 1; i < z_info->brand_max; i++) {
    if (streq(s, brands[i].code)) break;
  }
  if (i == z_info->brand_max) {
    return PARSE_ERROR_UNRECOGNISED_BRAND;
  }
  if (!kb->smith_brands) {
    kb->smith_brands = mem_zalloc(z_info->brand_max * sizeof(bool));
  }
  kb->smith_brands[i] = true;
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_parse_object_base(void)
{
  struct parser* p = parser_new();
  struct kb_parsedata* d = mem_zalloc(sizeof(*d));
  parser_setpriv(p, d);
  parser_reg(p, "default sym label int value", parse_object_base_defaults);
  parser_reg(p, "name sym tval ?str name", parse_object_base_name);
  parser_reg(p, "graphics sym color", parse_object_base_graphics);
  parser_reg(p, "break int breakage", parse_object_base_break);
  parser_reg(p, "max-stack int size", parse_object_base_max_stack);
  parser_reg(p, "smith-attack int artistry int artefact",
             parse_object_base_smith_attack);
  parser_reg(p, "flags str flags", parse_object_base_flags);
  parser_reg(p, "smith-values str values", parse_object_base_smith_values);
  parser_reg(p, "smith-flags str flags", parse_object_base_smith_flags);
  parser_reg(p, "slay str code", parse_object_base_smith_slay);
  parser_reg(p, "brand str code", parse_object_base_smith_brand);
  return p;
}
STATIC_OVL errr
run_parse_object_base(struct parser* p)
{
  return parse_file_quit_not_found(p, "object_base");
}
STATIC_OVL errr
finish_parse_object_base(struct parser* p)
{
  struct object_base* kb;
  struct object_base* next = NULL;
  struct kb_parsedata* d = parser_priv(p);
  assert(d);
  kb_info = mem_zalloc(TV_MAX * sizeof(*kb_info));
  for (kb = d->kb; kb; kb = next) {
    if (kb->tval < TV_MAX && kb->tval >= 0) {
      memcpy(&kb_info[kb->tval], kb, sizeof(*kb));
    } else {
      string_free(kb->name);
    }
    next = kb->next;
    mem_free(kb);
  }
  mem_free(d);
  parser_destroy(p);
  return 0;
}
STATIC_OVL void
cleanup_object_base(void)
{
  int idx;
  for (idx = 0; idx < TV_MAX; idx++) {
    string_free(kb_info[idx].name);
    mem_free(kb_info[idx].smith_slays);
    mem_free(kb_info[idx].smith_brands);
  }
  mem_free(kb_info);
}
STATIC_OVL enum parser_error
parse_slay_code(struct parser* p)
{
  const char* code = parser_getstr(p, "code");
  struct slay* h = parser_priv(p);
  struct slay* slay = mem_zalloc(sizeof *slay);
  slay->next = h;
  parser_setpriv(p, slay);
  slay->code = string_make(code);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_slay_name(struct parser* p)
{
  const char* name = parser_getstr(p, "name");
  struct slay* slay = parser_priv(p);
  if (!slay) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  string_free(slay->name);
  slay->name = string_make(name);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_slay_race_flag(struct parser* p)
{
  int flag;
  struct slay* slay = parser_priv(p);
  if (!slay) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  flag = lookup_flag(mon_race_flags, parser_getsym(p, "flag"));
  if (flag == FLAG_END) {
    return PARSE_ERROR_INVALID_FLAG;
  }
  slay->race_flag = flag;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_slay_dice(struct parser* p)
{
  struct slay* slay = parser_priv(p);
  if (!slay) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  slay->dice = parser_getuint(p, "dice");
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_parse_slay(void)
{
  struct parser* p = parser_new();
  parser_setpriv(p, NULL);
  parser_reg(p, "code str code", parse_slay_code);
  parser_reg(p, "name str name", parse_slay_name);
  parser_reg(p, "race-flag sym flag", parse_slay_race_flag);
  parser_reg(p, "dice uint dice", parse_slay_dice);
  return p;
}
STATIC_OVL errr
run_parse_slay(struct parser* p)
{
  return parse_file_quit_not_found(p, "slay");
}
STATIC_OVL errr
finish_parse_slay(struct parser* p)
{
  struct slay *slay, *next = NULL;
  int count = 1;
  errr result = PARSE_ERROR_NONE;
  z_info->slay_max = 0;
  slay = parser_priv(p);
  while (slay) {
    if (z_info->slay_max >= 254) {
      result = PARSE_ERROR_TOO_MANY_ENTRIES;
      break;
    }
    z_info->slay_max++;
    slay = slay->next;
  }
  slays = mem_zalloc((z_info->slay_max + 1) * sizeof(*slay));
  for (slay = parser_priv(p); slay; slay = next, count++) {
    next = slay->next;
    if (count <= z_info->slay_max) {
      memcpy(&slays[count], slay, sizeof(*slay));
      slays[count].next = NULL;
    }
    mem_free(slay);
  }
  z_info->slay_max += 1;
  parser_destroy(p);
  return result;
}
STATIC_OVL void
cleanup_slay(void)
{
  int idx;
  for (idx = 0; idx < z_info->slay_max; idx++) {
    string_free(slays[idx].code);
    string_free(slays[idx].name);
  }
  mem_free(slays);
}
STATIC_OVL enum parser_error
parse_brand_code(struct parser* p)
{
  const char* code = parser_getstr(p, "code");
  struct brand* h = parser_priv(p);
  struct brand* brand = mem_zalloc(sizeof *brand);
  brand->next = h;
  parser_setpriv(p, brand);
  brand->code = string_make(code);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_brand_name(struct parser* p)
{
  const char* name = parser_getstr(p, "name");
  struct brand* brand = parser_priv(p);
  if (!brand) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  string_free(brand->name);
  brand->name = string_make(name);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_brand_desc(struct parser* p)
{
  const char* desc = parser_getstr(p, "desc");
  struct brand* brand = parser_priv(p);
  if (!brand) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  string_free(brand->desc);
  brand->desc = string_make(desc);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_brand_dice(struct parser* p)
{
  struct brand* brand = parser_priv(p);
  if (!brand) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  brand->dice = parser_getuint(p, "dice");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_brand_vuln_dice(struct parser* p)
{
  struct brand* brand = parser_priv(p);
  if (!brand) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  brand->vuln_dice = parser_getuint(p, "dice");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_brand_resist_flag(struct parser* p)
{
  int flag;
  struct brand* brand = parser_priv(p);
  if (!brand) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  flag = lookup_flag(mon_race_flags, parser_getsym(p, "flag"));
  if (flag == FLAG_END) {
    return PARSE_ERROR_INVALID_FLAG;
  }
  brand->resist_flag = flag;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_brand_vuln_flag(struct parser* p)
{
  int flag;
  struct brand* brand = parser_priv(p);
  if (!brand) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  flag = lookup_flag(mon_race_flags, parser_getsym(p, "flag"));
  if (flag == FLAG_END) {
    return PARSE_ERROR_INVALID_FLAG;
  }
  brand->vuln_flag = flag;
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_parse_brand(void)
{
  struct parser* p = parser_new();
  parser_setpriv(p, NULL);
  parser_reg(p, "code str code", parse_brand_code);
  parser_reg(p, "name str name", parse_brand_name);
  parser_reg(p, "desc str desc", parse_brand_desc);
  parser_reg(p, "dice uint dice", parse_brand_dice);
  parser_reg(p, "vuln-dice uint dice", parse_brand_vuln_dice);
  parser_reg(p, "resist-flag sym flag", parse_brand_resist_flag);
  parser_reg(p, "vuln-flag sym flag", parse_brand_vuln_flag);
  return p;
}
STATIC_OVL errr
run_parse_brand(struct parser* p)
{
  return parse_file_quit_not_found(p, "brand");
}
STATIC_OVL errr
finish_parse_brand(struct parser* p)
{
  struct brand *brand, *next = NULL;
  int count = 1;
  errr result = PARSE_ERROR_NONE;
  z_info->brand_max = 0;
  brand = parser_priv(p);
  while (brand) {
    if (z_info->brand_max >= 254) {
      result = PARSE_ERROR_TOO_MANY_ENTRIES;
      break;
    }
    z_info->brand_max++;
    brand = brand->next;
  }
  brands = mem_zalloc((z_info->brand_max + 1) * sizeof(*brand));
  for (brand = parser_priv(p); brand; brand = next, count++) {
    next = brand->next;
    if (count <= z_info->brand_max) {
      memcpy(&brands[count], brand, sizeof(*brand));
      brands[count].next = NULL;
    }
    mem_free(brand);
  }
  z_info->brand_max += 1;
  parser_destroy(p);
  return result;
}
STATIC_OVL void
cleanup_brand(void)
{
  int idx;
  for (idx = 0; idx < z_info->brand_max; idx++) {
    string_free(brands[idx].code);
    string_free(brands[idx].name);
    string_free(brands[idx].desc);
  }
  mem_free(brands);
}
STATIC_OVL enum parser_error
parse_object_name(struct parser* p)
{
  const char* name = parser_getstr(p, "name");
  struct object_kind* h = parser_priv(p);
  struct object_kind* k = mem_zalloc(sizeof *k);
  k->next = h;
  parser_setpriv(p, k);
  k->name = string_make(name);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_graphics(struct parser* p)
{
  wchar_t glyph = parser_getchar(p, "glyph");
  const char* color = parser_getsym(p, "color");
  struct object_kind* k = parser_priv(p);
  if (!k) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  k->d_char = glyph;
  if (strlen(color) > 1) {
    k->d_attr = color_text_to_attr(color);
  } else {
    k->d_attr = color_char_to_attr(color[0]);
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_type(struct parser* p)
{
  struct object_kind* k = parser_priv(p);
  int tval;
  if (!k) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  tval = tval_find_idx(parser_getsym(p, "tval"));
  if (tval < 0) {
    return PARSE_ERROR_UNRECOGNISED_TVAL;
  }
  k->tval = tval;
  k->base = &kb_info[k->tval];
  k->base->num_svals++;
  k->sval = k->base->num_svals;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_pval(struct parser* p)
{
  struct object_kind* k = parser_priv(p);
  if (!k) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  k->pval = parser_getint(p, "pval");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_level(struct parser* p)
{
  struct object_kind* k = parser_priv(p);
  if (!k) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  k->level = parser_getint(p, "level");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_weight(struct parser* p)
{
  struct object_kind* k = parser_priv(p);
  if (!k) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  k->weight = parser_getint(p, "weight");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_cost(struct parser* p)
{
  struct object_kind* k = parser_priv(p);
  if (!k) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  k->cost = parser_getint(p, "cost");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_attack(struct parser* p)
{
  struct object_kind* k = parser_priv(p);
  struct random hd;
  if (!k) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  k->att = parser_getint(p, "att");
  hd = parser_getrand(p, "hd");
  k->dd = hd.dice;
  k->ds = hd.sides;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_defence(struct parser* p)
{
  struct object_kind* k = parser_priv(p);
  struct random hd;
  if (!k) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  k->evn = parser_getint(p, "evn");
  hd = parser_getrand(p, "hd");
  k->pd = hd.dice;
  k->ps = hd.sides;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_alloc(struct parser* p)
{
  struct object_kind* k = parser_priv(p);
  struct allocation* a;
  if (!k) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  a = k->alloc;
  if (!a) {
    k->alloc = mem_zalloc(sizeof(struct allocation));
    a = k->alloc;
  } else {
    while (a->next) a = a->next;
    a->next = mem_zalloc(sizeof(struct allocation));
    a = a->next;
  }
  a->locale = parser_getuint(p, "locale");
  a->chance = parser_getuint(p, "chance");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_flags(struct parser* p)
{
  struct object_kind* k = parser_priv(p);
  char *s, *t;
  if (!k) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  s = string_make(parser_getstr(p, "flags"));
  t = strtok(s, " |");
  while (t) {
    bool found = false;
    if (!grab_flag(k->flags, OF_SIZE, obj_flags, t)) {
      found = true;
    }
    if (!grab_flag(k->kind_flags, KF_SIZE, kind_flags, t)) {
      found = true;
    }
    if (grab_element_flag(k->el_info, t)) {
      found = true;
    }
    if (!found) {
      break;
    }
    t = strtok(NULL, " |");
  }
  string_free(s);
  return t ? PARSE_ERROR_INVALID_FLAG : PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_charges(struct parser* p)
{
  struct object_kind* k = parser_priv(p);
  if (!k) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  k->charge = parser_getrand(p, "charges");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_effect(struct parser* p)
{
  struct object_kind* k = parser_priv(p);
  struct effect *effect, *new_effect;
  if (!k) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  new_effect = mem_zalloc(sizeof(*new_effect));
  if (k->effect) {
    effect = k->effect;
    while (effect->next) effect = effect->next;
    effect->next = new_effect;
  } else {
    k->effect = new_effect;
  }
  return grab_effect_data(p, new_effect);
}
STATIC_OVL enum parser_error
parse_object_dice(struct parser* p)
{
  struct object_kind* k = parser_priv(p);
  dice_t* dice;
  struct effect* effect;
  const char* string;
  if (!k) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  effect = k->effect;
  if (effect == NULL) {
    return PARSE_ERROR_NONE;
  }
  while (effect->next) effect = effect->next;
  dice = dice_new();
  if (dice == NULL) {
    return PARSE_ERROR_INVALID_DICE;
  }
  string = parser_getstr(p, "dice");
  if (dice_parse_string(dice, string)) {
    dice_free(effect->dice);
    effect->dice = dice;
  } else {
    dice_free(dice);
    return PARSE_ERROR_INVALID_DICE;
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_expr(struct parser* p)
{
  struct object_kind* k = parser_priv(p);
  struct effect* effect;
  expression_t* expression;
  expression_base_value_f function;
  const char* name;
  const char* base;
  const char* expr;
  enum parser_error result;
  if (!k) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  effect = k->effect;
  if (effect == NULL) {
    return PARSE_ERROR_NONE;
  }
  while (effect->next) effect = effect->next;
  if (effect->dice == NULL) {
    return PARSE_ERROR_NONE;
  }
  name = parser_getsym(p, "name");
  base = parser_getsym(p, "base");
  expr = parser_getstr(p, "expr");
  expression = expression_new();
  if (expression == NULL) {
    return PARSE_ERROR_INVALID_EXPRESSION;
  }
  function = effect_value_base_by_name(base);
  expression_set_base_value(expression, function);
  if (expression_add_operations_string(expression, expr) < 0) {
    result = PARSE_ERROR_BAD_EXPRESSION_STRING;
  } else if (dice_bind_expression(effect->dice, name, expression) < 0) {
    result = PARSE_ERROR_UNBOUND_EXPRESSION;
  } else {
    result = PARSE_ERROR_NONE;
  }
  expression_free(expression);
  return result;
}
STATIC_OVL enum parser_error
parse_object_thrown_effect(struct parser* p)
{
  struct object_kind* k = parser_priv(p);
  struct effect *effect, *new_effect;
  if (!k) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  new_effect = mem_zalloc(sizeof(*new_effect));
  if (k->thrown_effect) {
    effect = k->thrown_effect;
    while (effect->next) effect = effect->next;
    effect->next = new_effect;
  } else {
    k->thrown_effect = new_effect;
  }
  return grab_effect_data(p, new_effect);
}
STATIC_OVL enum parser_error
parse_object_thrown_effect_dice(struct parser* p)
{
  struct object_kind* k = parser_priv(p);
  dice_t* dice;
  struct effect* effect;
  const char* string;
  if (!k) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  effect = k->thrown_effect;
  if (effect == NULL) {
    return PARSE_ERROR_NONE;
  }
  while (effect->next) effect = effect->next;
  dice = dice_new();
  if (dice == NULL) {
    return PARSE_ERROR_INVALID_DICE;
  }
  string = parser_getstr(p, "dice");
  if (dice_parse_string(dice, string)) {
    dice_free(effect->dice);
    effect->dice = dice;
  } else {
    dice_free(dice);
    return PARSE_ERROR_INVALID_DICE;
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_thrown_effect_expr(struct parser* p)
{
  struct object_kind* k = parser_priv(p);
  struct effect* effect;
  expression_t* expression;
  expression_base_value_f function;
  const char* name;
  const char* base;
  const char* expr;
  enum parser_error result;
  if (!k) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  effect = k->thrown_effect;
  if (effect == NULL) {
    return PARSE_ERROR_NONE;
  }
  while (effect->next) effect = effect->next;
  if (effect->dice == NULL) {
    return PARSE_ERROR_NONE;
  }
  name = parser_getsym(p, "name");
  base = parser_getsym(p, "base");
  expr = parser_getstr(p, "expr");
  expression = expression_new();
  if (expression == NULL) {
    return PARSE_ERROR_INVALID_EXPRESSION;
  }
  function = effect_value_base_by_name(base);
  expression_set_base_value(expression, function);
  if (expression_add_operations_string(expression, expr) < 0) {
    result = PARSE_ERROR_BAD_EXPRESSION_STRING;
  } else if (dice_bind_expression(effect->dice, name, expression) < 0) {
    result = PARSE_ERROR_UNBOUND_EXPRESSION;
  } else {
    result = PARSE_ERROR_NONE;
  }
  expression_free(expression);
  return result;
}
STATIC_OVL enum parser_error
parse_object_msg(struct parser* p)
{
  struct object_kind* k = parser_priv(p);
  if (!k) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  k->effect_msg = string_append(k->effect_msg, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_desc(struct parser* p)
{
  struct object_kind* k = parser_priv(p);
  if (!k) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  k->text = string_append(k->text, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_values(struct parser* p)
{
  struct object_kind* k = parser_priv(p);
  char *s, *t;
  if (!k) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  s = string_make(parser_getstr(p, "values"));
  t = strtok(s, " |");
  while (t) {
    int value = 0;
    int index = 0;
    bool found = false;
    if (!grab_rand_value(k->modifiers, obj_mods, t)) {
      found = true;
    }
    if (!grab_index_and_int(&value, &index, element_names, "RES_", t)) {
      found = true;
      k->el_info[index].res_level = value;
    }
    if (!found) {
      break;
    }
    t = strtok(NULL, " |");
  }
  string_free(s);
  return t ? PARSE_ERROR_INVALID_VALUE : PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_slay(struct parser* p)
{
  struct object_kind* k = parser_priv(p);
  const char* s = parser_getstr(p, "code");
  int i;
  if (!k) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  for (i = 1; i < z_info->slay_max; i++) {
    if (streq(s, slays[i].code)) break;
  }
  if (i == z_info->slay_max) {
    return PARSE_ERROR_UNRECOGNISED_SLAY;
  }
  if (!k->slays) {
    k->slays = mem_zalloc(z_info->slay_max * sizeof(bool));
  }
  k->slays[i] = true;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_brand(struct parser* p)
{
  struct object_kind* k = parser_priv(p);
  const char* s = parser_getstr(p, "code");
  int i;
  if (!k) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  for (i = 1; i < z_info->brand_max; i++) {
    if (streq(s, brands[i].code)) break;
  }
  if (i == z_info->brand_max) {
    return PARSE_ERROR_UNRECOGNISED_BRAND;
  }
  if (!k->brands) {
    k->brands = mem_zalloc(z_info->brand_max * sizeof(bool));
  }
  k->brands[i] = true;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_special(struct parser* p)
{
  struct object_kind* k = parser_priv(p);
  const char* dice_string = parser_getsym(p, "value");
  dice_t* dice;
  if (!k) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  dice = dice_new();
  if (!dice_parse_string(dice, dice_string)) {
    dice_free(dice);
    return PARSE_ERROR_NOT_RANDOM;
  }
  dice_random_value(dice, &k->special1);
  if (parser_hasval(p, "min")) {
    k->special2 = parser_getint(p, "min");
  }
  dice_free(dice);
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_parse_object(void)
{
  struct parser* p = parser_new();
  parser_setpriv(p, NULL);
  parser_reg(p, "name str name", parse_object_name);
  parser_reg(p, "type sym tval", parse_object_type);
  parser_reg(p, "pval int pval", parse_object_pval);
  parser_reg(p, "graphics char glyph sym color", parse_object_graphics);
  parser_reg(p, "depth int level", parse_object_level);
  parser_reg(p, "weight int weight", parse_object_weight);
  parser_reg(p, "cost int cost", parse_object_cost);
  parser_reg(p, "alloc uint locale uint chance", parse_object_alloc);
  parser_reg(p, "attack int att rand hd", parse_object_attack);
  parser_reg(p, "defence int evn rand hd", parse_object_defence);
  parser_reg(p, "flags str flags", parse_object_flags);
  parser_reg(p, "charges rand charges", parse_object_charges);
  parser_reg(p, "effect sym eff ?sym type ?int radius ?int other",
             parse_object_effect);
  parser_reg(p, "dice str dice", parse_object_dice);
  parser_reg(p, "expr sym name sym base str expr", parse_object_expr);
  parser_reg(p, "thrown-effect sym eff ?sym type ?int radius ?int other",
             parse_object_thrown_effect);
  parser_reg(p, "thrown-dice str dice", parse_object_thrown_effect_dice);
  parser_reg(p, "thrown-expr sym name sym base str expr",
             parse_object_thrown_effect_expr);
  parser_reg(p, "msg str text", parse_object_msg);
  parser_reg(p, "values str values", parse_object_values);
  parser_reg(p, "desc str text", parse_object_desc);
  parser_reg(p, "slay str code", parse_object_slay);
  parser_reg(p, "brand str code", parse_object_brand);
  parser_reg(p, "special sym value ?int min", parse_object_special);
  return p;
}
STATIC_OVL errr
run_parse_object(struct parser* p)
{
  return parse_file_quit_not_found(p, "object");
}
STATIC_OVL errr
finish_parse_object(struct parser* p)
{
  struct object_kind *k, *next = NULL;
  int kidx;
  z_info->k_max = 0;
  z_info->obj_alloc_max = 0;
  k = parser_priv(p);
  while (k) {
    int max_alloc = 0;
    struct allocation* a = k->alloc;
    z_info->k_max++;
    while (a) {
      a = a->next;
      max_alloc++;
    }
    if (max_alloc > z_info->obj_alloc_max) z_info->obj_alloc_max = max_alloc;
    k = k->next;
  }
  k_info = mem_zalloc((z_info->k_max + 1) * sizeof(*k));
  kidx = z_info->k_max - 1;
  for (k = parser_priv(p); k; k = next, kidx--) {
    struct allocation* a_new;
    assert(kidx >= 0);
    memcpy(&k_info[kidx], k, sizeof(*k));
    k_info[kidx].kidx = kidx;
    kf_union(k_info[kidx].kind_flags, kb_info[k->tval].kind_flags);
    next = k->next;
    if (kidx < z_info->k_max - 1) {
      k_info[kidx].next = &k_info[kidx + 1];
    } else {
      k_info[kidx].next = NULL;
    }
    a_new = mem_zalloc(z_info->obj_alloc_max * sizeof(*a_new));
    if (k->alloc) {
      struct allocation *a_temp, *a_old = k->alloc;
      int i;
      for (i = 0; i < z_info->obj_alloc_max; i++) {
        memcpy(&a_new[i], a_old, sizeof(*a_old));
        a_old = a_old->next;
        if (!a_old) break;
      }
      for (i = 0; i < z_info->obj_alloc_max; i++)
        if (a_new[i].next) a_new[i].next = &a_new[i + 1];
      a_old = k->alloc;
      a_temp = a_old;
      while (a_temp) {
        a_temp = a_old->next;
        mem_free(a_old);
        a_old = a_temp;
      }
    }
    k_info[kidx].alloc = a_new;
    mem_free(k);
  }
  z_info->k_max += 1;
  z_info->ordinary_kind_max = z_info->k_max;
  parser_destroy(p);
  return 0;
}
STATIC_OVL void
cleanup_object(void)
{
  int idx;
  for (idx = 0; idx < z_info->k_max; idx++) {
    struct object_kind* kind = &k_info[idx];
    string_free(kind->name);
    string_free(kind->text);
    string_free(kind->effect_msg);
    mem_free(kind->brands);
    mem_free(kind->slays);
    release_ability_list(kind->abilities);
    free_effect(kind->effect);
    free_effect(kind->thrown_effect);
    mem_free(kind->alloc);
  }
  mem_free(k_info);
}
STATIC_OVL enum parser_error
parse_drop_name(struct parser* p)
{
  const char* name = parser_getstr(p, "name");
  struct drop* h = parser_priv(p);
  struct drop* d = mem_zalloc(sizeof *d);
  d->next = h;
  parser_setpriv(p, d);
  d->name = string_make(name);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_drop_chest(struct parser* p)
{
  struct drop* d = parser_priv(p);
  int chest;
  if (!d) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  chest = parser_getuint(p, "chest");
  d->chest = (chest == 1) ? true : false;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_drop_base(struct parser* p)
{
  struct poss_item* poss;
  int i;
  int tval = tval_find_idx(parser_getsym(p, "tval"));
  bool found_one_kind = false;
  struct drop* d = parser_priv(p);
  if (!d) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  if (tval < 0) {
    return PARSE_ERROR_UNRECOGNISED_TVAL;
  }
  for (i = 0; i < z_info->k_max; i++) {
    if (k_info[i].tval != tval) continue;
    poss = mem_zalloc(sizeof(struct poss_item));
    poss->kidx = i;
    poss->next = d->poss;
    d->poss = poss;
    found_one_kind = true;
  }
  return (!found_one_kind) ? PARSE_ERROR_NO_KIND_FOR_DROP_TYPE
                           : PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_drop_not_base(struct parser* p)
{
  struct poss_item* imposs;
  int i;
  int tval = tval_find_idx(parser_getsym(p, "tval"));
  bool found_one_kind = false;
  struct drop* d = parser_priv(p);
  if (!d) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  if (tval < 0) {
    return PARSE_ERROR_UNRECOGNISED_TVAL;
  }
  for (i = 0; i < z_info->k_max; i++) {
    if (k_info[i].tval != tval) continue;
    imposs = mem_zalloc(sizeof(struct poss_item));
    imposs->kidx = i;
    imposs->next = d->imposs;
    d->imposs = imposs;
    found_one_kind = true;
  }
  return (!found_one_kind) ? PARSE_ERROR_NO_KIND_FOR_DROP_TYPE
                           : PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_drop_item(struct parser* p)
{
  struct poss_item* poss;
  int tval = tval_find_idx(parser_getsym(p, "tval"));
  int sval = lookup_sval(tval, parser_getsym(p, "sval"));
  int kidx;
  struct drop* d = parser_priv(p);
  if (!d) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  if (tval < 0) {
    return PARSE_ERROR_UNRECOGNISED_TVAL;
  }
  if (sval < 0) {
    return PARSE_ERROR_UNRECOGNISED_SVAL;
  }
  kidx = lookup_kind(tval, sval)->kidx;
  if (kidx < 0) {
    return PARSE_ERROR_INVALID_ITEM_NUMBER;
  }
  poss = mem_zalloc(sizeof(struct poss_item));
  poss->kidx = kidx;
  poss->next = d->poss;
  d->poss = poss;
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_parse_drop(void)
{
  struct parser* p = parser_new();
  parser_setpriv(p, NULL);
  parser_reg(p, "name str name", parse_drop_name);
  parser_reg(p, "chest uint chest", parse_drop_chest);
  parser_reg(p, "base sym tval", parse_drop_base);
  parser_reg(p, "not-base sym tval", parse_drop_not_base);
  parser_reg(p, "item sym tval sym sval", parse_drop_item);
  return p;
}
STATIC_OVL errr
run_parse_drop(struct parser* p)
{
  return parse_file_quit_not_found(p, "drop");
}
STATIC_OVL errr
finish_parse_drop(struct parser* p)
{
  struct drop *d, *n;
  int idx;
  z_info->drop_max = 0;
  d = parser_priv(p);
  while (d) {
    z_info->drop_max++;
    d = d->next;
  }
  drops = mem_zalloc((z_info->drop_max + 1) * sizeof(*d));
  idx = z_info->drop_max - 1;
  for (d = parser_priv(p); d; d = n, idx--) {
    assert(idx >= 0);
    memcpy(&drops[idx], d, sizeof(*d));
    drops[idx].idx = idx;
    n = d->next;
    if (idx < z_info->drop_max - 1) {
      drops[idx].next = &drops[idx + 1];
    } else {
      drops[idx].next = NULL;
    }
    mem_free(d);
  }
  z_info->drop_max += 1;
  parser_destroy(p);
  return 0;
}
STATIC_OVL void
cleanup_drop(void)
{
  int idx;
  for (idx = 0; idx < z_info->drop_max; idx++) {
    struct drop* drop = &drops[idx];
    struct poss_item* poss;
    string_free(drop->name);
    poss = drop->poss;
    while (poss) {
      struct poss_item* next = poss->next;
      mem_free(poss);
      poss = next;
    }
    poss = drop->imposs;
    while (poss) {
      struct poss_item* next = poss->next;
      mem_free(poss);
      poss = next;
    }
  }
  mem_free(drops);
}
STATIC_OVL enum parser_error
parse_ego_name(struct parser* p)
{
  const char* name = parser_getstr(p, "name");
  struct ego_item* h = parser_priv(p);
  struct ego_item* e = mem_zalloc(sizeof *e);
  e->next = h;
  parser_setpriv(p, e);
  e->name = string_make(name);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_ego_alloc(struct parser* p)
{
  struct ego_item* e = parser_priv(p);
  const char* tmp = parser_getstr(p, "minmax");
  int amin, amax;
  if (!e) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  e->rarity = parser_getint(p, "common");
  if (grab_int_range(&amin, &amax, tmp, "to")) {
    return PARSE_ERROR_INVALID_ALLOCATION;
  }
  if (amin > 255 || amax > 255 || amin < 0 || amax < 0) {
    return PARSE_ERROR_OUT_OF_BOUNDS;
  }
  e->level = amin;
  e->alloc_max = amax;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_ego_cost(struct parser* p)
{
  struct ego_item* e = parser_priv(p);
  if (!e) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  e->cost = parser_getint(p, "cost");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_ego_max_attack(struct parser* p)
{
  struct ego_item* e = parser_priv(p);
  if (!e) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  e->att = parser_getuint(p, "att");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_ego_dam_dice(struct parser* p)
{
  struct ego_item* e = parser_priv(p);
  if (!e) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  e->dd = parser_getuint(p, "dice");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_ego_dam_sides(struct parser* p)
{
  struct ego_item* e = parser_priv(p);
  if (!e) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  e->ds = parser_getuint(p, "sides");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_ego_max_evasion(struct parser* p)
{
  struct ego_item* e = parser_priv(p);
  if (!e) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  e->evn = parser_getuint(p, "evn");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_ego_prot_dice(struct parser* p)
{
  struct ego_item* e = parser_priv(p);
  if (!e) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  e->pd = parser_getuint(p, "dice");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_ego_prot_sides(struct parser* p)
{
  struct ego_item* e = parser_priv(p);
  if (!e) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  e->ps = parser_getuint(p, "sides");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_ego_max_pval(struct parser* p)
{
  struct ego_item* e = parser_priv(p);
  if (!e) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  e->pval = parser_getuint(p, "pval");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_ego_type(struct parser* p)
{
  struct poss_item* poss;
  int i;
  int tval = tval_find_idx(parser_getsym(p, "tval"));
  bool found_one_kind = false;
  struct ego_item* e = parser_priv(p);
  if (!e) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  if (tval < 0) {
    return PARSE_ERROR_UNRECOGNISED_TVAL;
  }
  for (i = 0; i < z_info->k_max; i++) {
    if (k_info[i].tval != tval) continue;
    poss = mem_zalloc(sizeof(struct poss_item));
    poss->kidx = i;
    poss->next = e->poss_items;
    e->poss_items = poss;
    found_one_kind = true;
  }
  if (!found_one_kind) {
    return PARSE_ERROR_NO_KIND_FOR_EGO_TYPE;
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_ego_item(struct parser* p)
{
  struct poss_item* poss;
  int tval = tval_find_idx(parser_getsym(p, "tval"));
  int sval = lookup_sval(tval, parser_getsym(p, "sval"));
  struct ego_item* e = parser_priv(p);
  if (!e) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  if (tval < 0) {
    return PARSE_ERROR_UNRECOGNISED_TVAL;
  }
  if (sval < 0) {
    return PARSE_ERROR_UNRECOGNISED_SVAL;
  }
  poss = mem_zalloc(sizeof(struct poss_item));
  poss->kidx = lookup_kind(tval, sval)->kidx;
  poss->next = e->poss_items;
  e->poss_items = poss;
  return (poss->kidx <= 0) ? PARSE_ERROR_INVALID_ITEM_NUMBER : PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_ego_flags(struct parser* p)
{
  struct ego_item* e = parser_priv(p);
  char* flags;
  char* t;
  if (!e) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  if (!parser_hasval(p, "flags")) {
    return PARSE_ERROR_NONE;
  }
  flags = string_make(parser_getstr(p, "flags"));
  t = strtok(flags, " |");
  while (t) {
    bool found = false;
    if (!grab_flag(e->flags, OF_SIZE, obj_flags, t)) {
      found = true;
    }
    if (!grab_flag(e->kind_flags, KF_SIZE, kind_flags, t)) {
      found = true;
    }
    if (grab_element_flag(e->el_info, t)) {
      found = true;
    }
    if (!found) {
      break;
    }
    t = strtok(NULL, " |");
  }
  string_free(flags);
  return t ? PARSE_ERROR_INVALID_FLAG : PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_ego_values(struct parser* p)
{
  struct ego_item* e = parser_priv(p);
  char *s, *t;
  if (!e) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  if (!parser_hasval(p, "values")) {
    return PARSE_ERROR_MISSING_FIELD;
  }
  s = string_make(parser_getstr(p, "values"));
  t = strtok(s, " |");
  while (t) {
    bool found = false;
    int value = 0;
    int index = 0;
    if (!grab_int_value(e->modifiers, obj_mods, t)) {
      found = true;
    }
    if (!grab_index_and_int(&value, &index, element_names, "RES_", t)) {
      found = true;
      e->el_info[index].res_level = value;
    }
    if (!found) {
      break;
    }
    t = strtok(NULL, " |");
  }
  string_free(s);
  return t ? PARSE_ERROR_INVALID_VALUE : PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_ego_slay(struct parser* p)
{
  struct ego_item* e = parser_priv(p);
  const char* s = parser_getstr(p, "code");
  int i;
  if (!e) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  for (i = 1; i < z_info->slay_max; i++) {
    if (streq(s, slays[i].code)) break;
  }
  if (i == z_info->slay_max) {
    return PARSE_ERROR_UNRECOGNISED_SLAY;
  }
  if (!e->slays) {
    e->slays = mem_zalloc(z_info->slay_max * sizeof(bool));
  }
  e->slays[i] = true;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_ego_brand(struct parser* p)
{
  struct ego_item* e = parser_priv(p);
  const char* s = parser_getstr(p, "code");
  int i;
  if (!e) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  for (i = 1; i < z_info->brand_max; i++) {
    if (streq(s, brands[i].code)) break;
  }
  if (i == z_info->brand_max) return PARSE_ERROR_UNRECOGNISED_BRAND;
  if (!e->brands) {
    e->brands = mem_zalloc(z_info->brand_max * sizeof(bool));
  }
  e->brands[i] = true;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_ego_ability(struct parser* p)
{
  struct ego_item* e = parser_priv(p);
  int skill = lookup_skill(parser_getsym(p, "skill"));
  struct ability *a, *n;
  if (!e) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  if (skill < 0) {
    return PARSE_ERROR_INVALID_SKILL;
  }
  a = lookup_ability(skill, parser_getsym(p, "ability"));
  if (!a) {
    return PARSE_ERROR_INVALID_ABILITY;
  }
  n = mem_zalloc(sizeof(*n));
  memcpy(n, a, sizeof(*n));
  n->next = e->abilities;
  e->abilities = n;
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_parse_ego(void)
{
  struct parser* p = parser_new();
  parser_setpriv(p, NULL);
  parser_reg(p, "name str name", parse_ego_name);
  parser_reg(p, "alloc int common str minmax", parse_ego_alloc);
  parser_reg(p, "cost int cost", parse_ego_cost);
  parser_reg(p, "max-attack uint att", parse_ego_max_attack);
  parser_reg(p, "dam-dice uint dice", parse_ego_dam_dice);
  parser_reg(p, "dam-sides uint sides", parse_ego_dam_sides);
  parser_reg(p, "max-evasion uint evn", parse_ego_max_evasion);
  parser_reg(p, "prot-dice uint dice", parse_ego_prot_dice);
  parser_reg(p, "prot-sides uint sides", parse_ego_prot_sides);
  parser_reg(p, "max-pval uint pval", parse_ego_max_pval);
  parser_reg(p, "type sym tval", parse_ego_type);
  parser_reg(p, "item sym tval sym sval", parse_ego_item);
  parser_reg(p, "flags ?str flags", parse_ego_flags);
  parser_reg(p, "values str values", parse_ego_values);
  parser_reg(p, "slay str code", parse_ego_slay);
  parser_reg(p, "brand str code", parse_ego_brand);
  parser_reg(p, "ability sym skill sym ability", parse_ego_ability);
  return p;
}
STATIC_OVL errr
run_parse_ego(struct parser* p)
{
  return parse_file_quit_not_found(p, "special");
}
STATIC_OVL errr
finish_parse_ego(struct parser* p)
{
  struct ego_item *e, *n;
  int eidx;
  z_info->e_max = 0;
  e = parser_priv(p);
  while (e) {
    z_info->e_max++;
    e = e->next;
  }
  e_info = mem_zalloc((z_info->e_max + 1) * sizeof(*e));
  eidx = z_info->e_max - 1;
  for (e = parser_priv(p); e; e = n, eidx--) {
    assert(eidx >= 0);
    memcpy(&e_info[eidx], e, sizeof(*e));
    e_info[eidx].eidx = eidx;
    n = e->next;
    if (eidx < z_info->e_max - 1) {
      e_info[eidx].next = &e_info[eidx + 1];
    } else {
      e_info[eidx].next = NULL;
    }
    mem_free(e);
  }
  z_info->e_max += 1;
  parser_destroy(p);
  return 0;
}
STATIC_OVL void
cleanup_ego(void)
{
  int idx;
  for (idx = 0; idx < z_info->e_max; idx++) {
    struct ego_item* ego = &e_info[idx];
    struct poss_item* poss;
    string_free(ego->name);
    mem_free(ego->brands);
    mem_free(ego->slays);
    release_ability_list(ego->abilities);
    poss = ego->poss_items;
    while (poss) {
      struct poss_item* next = poss->next;
      mem_free(poss);
      poss = next;
    }
  }
  mem_free(e_info);
}
STATIC_OVL enum parser_error
parse_artifact_name(struct parser* p)
{
  size_t i;
  const char* name = parser_getstr(p, "name");
  struct artifact* h = parser_priv(p);
  struct artifact* a = mem_zalloc(sizeof *a);
  a->next = h;
  parser_setpriv(p, a);
  a->name = string_make(name);
  for (i = ELEM_BASE_MIN; i < ELEM_HIGH_MIN; i++) {
    a->el_info[i].flags |= EL_INFO_IGNORE;
  }
  a->d_attr = 255;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_artifact_base_object(struct parser* p)
{
  struct artifact* a = parser_priv(p);
  int tval, sval;
  const char* sval_name;
  if (!a) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  tval = tval_find_idx(parser_getsym(p, "tval"));
  if (tval < 0) {
    return PARSE_ERROR_UNRECOGNISED_TVAL;
  }
  a->tval = tval;
  sval_name = parser_getsym(p, "sval");
  sval = lookup_sval(a->tval, sval_name);
  if (sval < 0) {
    return write_dummy_object_record(a, sval_name);
  }
  a->sval = sval;
  if (a->d_attr == 255) {
    a->d_attr = lookup_kind(a->tval, a->sval)->d_attr;
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_artifact_color(struct parser* p)
{
  const char* color = parser_getsym(p, "color");
  struct artifact* a = parser_priv(p);
  struct object_kind* k;
  if (!a) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  if (strlen(color) > 1) {
    a->d_attr = color_text_to_attr(color);
  } else {
    a->d_attr = color_char_to_attr(color[0]);
  }
  k = lookup_kind(a->tval, a->sval);
  assert(k);
  if (kf_has(k->kind_flags, KF_INSTA_ART)) {
    k->d_attr = a->d_attr;
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_artifact_graphics(struct parser* p)
{
  wchar_t glyph = parser_getchar(p, "glyph");
  const char* color = parser_getsym(p, "color");
  struct artifact* a = parser_priv(p);
  struct object_kind* k;
  if (!a) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  k = lookup_kind(a->tval, a->sval);
  assert(k);
  if (!kf_has(k->kind_flags, KF_INSTA_ART)) {
    return PARSE_ERROR_NOT_SPECIAL_ARTIFACT;
  }
  k->d_char = glyph;
  if (strlen(color) > 1) {
    k->d_attr = color_text_to_attr(color);
  } else {
    k->d_attr = color_char_to_attr(color[0]);
  }
  a->d_attr = k->d_attr;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_artifact_pval(struct parser* p)
{
  struct artifact* a = parser_priv(p);
  if (!a) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  a->pval = parser_getint(p, "pval");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_artifact_level(struct parser* p)
{
  struct artifact* a = parser_priv(p);
  if (!a) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  a->level = parser_getint(p, "level");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_artifact_rarity(struct parser* p)
{
  struct artifact* a = parser_priv(p);
  if (!a) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  a->rarity = parser_getint(p, "rarity");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_artifact_weight(struct parser* p)
{
  struct artifact* a = parser_priv(p);
  struct object_kind* k;
  if (!a) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  k = lookup_kind(a->tval, a->sval);
  assert(k);
  a->weight = parser_getint(p, "weight");
  if (k->kidx >= z_info->ordinary_kind_max) {
    k->weight = a->weight;
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_artifact_cost(struct parser* p)
{
  struct artifact* a = parser_priv(p);
  struct object_kind* k;
  if (!a) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  k = lookup_kind(a->tval, a->sval);
  assert(k);
  a->cost = parser_getint(p, "cost");
  if (k->kidx >= z_info->ordinary_kind_max) {
    k->cost = a->cost;
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_artifact_attack(struct parser* p)
{
  struct artifact* a = parser_priv(p);
  struct random d;
  if (!a) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  a->att = parser_getint(p, "att");
  d = parser_getrand(p, "dice");
  a->dd = d.dice;
  a->ds = d.sides;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_artifact_defence(struct parser* p)
{
  struct artifact* a = parser_priv(p);
  struct random d;
  if (!a) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  a->evn = parser_getint(p, "evn");
  d = parser_getrand(p, "dice");
  a->pd = d.dice;
  a->ps = d.sides;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_artifact_flags(struct parser* p)
{
  struct artifact* a = parser_priv(p);
  char *s, *t;
  if (!a) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  if (!parser_hasval(p, "flags")) {
    return PARSE_ERROR_NONE;
  }
  s = string_make(parser_getstr(p, "flags"));
  t = strtok(s, " |");
  while (t) {
    bool found = false;
    if (!grab_flag(a->flags, OF_SIZE, obj_flags, t)) {
      found = true;
    }
    if (grab_element_flag(a->el_info, t)) {
      found = true;
    }
    if (!found) {
      break;
    }
    t = strtok(NULL, " |");
  }
  string_free(s);
  return t ? PARSE_ERROR_INVALID_FLAG : PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_artifact_values(struct parser* p)
{
  struct artifact* a = parser_priv(p);
  char *s, *t;
  if (!a) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  s = string_make(parser_getstr(p, "values"));
  t = strtok(s, " |");
  while (t) {
    bool found = false;
    int value = 0;
    int index = 0;
    if (!grab_int_value(a->modifiers, obj_mods, t)) {
      found = true;
    }
    if (!grab_index_and_int(&value, &index, element_names, "RES_", t)) {
      found = true;
      a->el_info[index].res_level = value;
    }
    if (!found) {
      break;
    }
    t = strtok(NULL, " |");
  }
  string_free(s);
  return t ? PARSE_ERROR_INVALID_VALUE : PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_artifact_desc(struct parser* p)
{
  struct artifact* a = parser_priv(p);
  if (!a) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  a->text = string_append(a->text, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_artifact_slay(struct parser* p)
{
  struct artifact* a = parser_priv(p);
  const char* s = parser_getstr(p, "code");
  int i;
  if (!a) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  for (i = 1; i < z_info->slay_max; i++) {
    if (streq(s, slays[i].code)) break;
  }
  if (i == z_info->slay_max) {
    return PARSE_ERROR_UNRECOGNISED_SLAY;
  }
  if (!a->slays) {
    a->slays = mem_zalloc(z_info->slay_max * sizeof(bool));
  }
  a->slays[i] = true;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_artifact_brand(struct parser* p)
{
  struct artifact* a = parser_priv(p);
  const char* s = parser_getstr(p, "code");
  int i;
  if (!a) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  for (i = 1; i < z_info->brand_max; i++) {
    if (streq(s, brands[i].code)) break;
  }
  if (i == z_info->brand_max) {
    return PARSE_ERROR_UNRECOGNISED_BRAND;
  }
  if (!a->brands) {
    a->brands = mem_zalloc(z_info->brand_max * sizeof(bool));
  }
  a->brands[i] = true;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_artifact_ability(struct parser* p)
{
  struct artifact* a = parser_priv(p);
  int skill;
  struct ability *b, *n;
  if (!a) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  skill = lookup_skill(parser_getsym(p, "skill"));
  if (skill < 0) {
    return PARSE_ERROR_INVALID_SKILL;
  }
  b = lookup_ability(skill, parser_getsym(p, "ability"));
  if (!b) {
    return PARSE_ERROR_INVALID_ABILITY;
  }
  n = mem_zalloc(sizeof(*n));
  memcpy(n, b, sizeof(*n));
  n->next = a->abilities;
  a->abilities = n;
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_parse_artifact(void)
{
  struct parser* p = parser_new();
  parser_setpriv(p, NULL);
  parser_reg(p, "name str name", parse_artifact_name);
  parser_reg(p, "base-object sym tval sym sval", parse_artifact_base_object);
  parser_reg(p, "color sym color", parse_artifact_color);
  parser_reg(p, "graphics char glyph sym color", parse_artifact_graphics);
  parser_reg(p, "pval int pval", parse_artifact_pval);
  parser_reg(p, "depth int level", parse_artifact_level);
  parser_reg(p, "rarity int rarity", parse_artifact_rarity);
  parser_reg(p, "weight int weight", parse_artifact_weight);
  parser_reg(p, "cost int cost", parse_artifact_cost);
  parser_reg(p, "attack int att rand dice", parse_artifact_attack);
  parser_reg(p, "defence int evn rand dice", parse_artifact_defence);
  parser_reg(p, "flags ?str flags", parse_artifact_flags);
  parser_reg(p, "values str values", parse_artifact_values);
  parser_reg(p, "desc str text", parse_artifact_desc);
  parser_reg(p, "slay str code", parse_artifact_slay);
  parser_reg(p, "brand str code", parse_artifact_brand);
  parser_reg(p, "ability sym skill sym ability", parse_artifact_ability);
  return p;
}
STATIC_OVL errr
run_parse_artifact(struct parser* p)
{
  return parse_file_quit_not_found(p, "artefact");
}
STATIC_OVL errr
finish_parse_artifact(struct parser* p)
{
  struct artifact *a, *n;
  int none, aidx;
  z_info->a_max = 0;
  a = parser_priv(p);
  while (a) {
    z_info->a_max++;
    a = a->next;
  }
  a_info = mem_zalloc((z_info->a_max + 1) * sizeof(*a));
  aup_info = mem_zalloc((z_info->a_max + 1) * sizeof(*aup_info));
  aidx = z_info->a_max;
  for (a = parser_priv(p); a; a = n, aidx--) {
    assert(aidx > 0);
    memcpy(&a_info[aidx], a, sizeof(*a));
    a_info[aidx].aidx = aidx;
    if (a_info[aidx].d_attr == 255) {
      a_info[aidx].d_attr = 0;
    }
    n = a->next;
    a_info[aidx].next = (aidx < z_info->a_max) ? &a_info[aidx + 1] : NULL;
    mem_free(a);
    aup_info[aidx].aidx = aidx;
  }
  z_info->a_max += 1;
  none = tval_find_idx("none");
  pile_kind = lookup_kind(none, lookup_sval(none, "<pile>"));
  parser_destroy(p);
  return 0;
}
STATIC_OVL void
cleanup_artifact(void)
{
  int idx;
  for (idx = 0; idx < z_info->a_max; idx++) {
    struct artifact* art = &a_info[idx];
    string_free(art->name);
    string_free(art->text);
    mem_free(art->brands);
    mem_free(art->slays);
    release_ability_list(art->abilities);
  }
  mem_free(a_info);
  mem_free(aup_info);
}
STATIC_OVL errr
run_parse_randart(struct parser* p)
{
  return parse_file_quit_not_found(p, "randart");
}
STATIC_OVL errr
finish_parse_randart(struct parser* p)
{
  struct artifact *a, *n;
  int aidx;
  int old_max = z_info->a_max, new_max = z_info->a_max;
  a = parser_priv(p);
  while (a) {
    ++new_max;
    a = a->next;
  }
  if (!old_max && new_max) {
    ++new_max;
  }
  if (new_max > 65535) {
    plog_fmt(
        "Too many artifacts (%d) after reading the "
        "randart file!",
        new_max);
    return PARSE_ERROR_TOO_MANY_ENTRIES;
  }
  a_info = mem_realloc(a_info, new_max * sizeof(*a));
  aup_info = mem_realloc(aup_info, new_max * sizeof(*aup_info));
  if (!old_max && new_max) {
    memset(&a_info[0], 0, sizeof(a_info[0]));
    memset(&aup_info[0], 0, sizeof(aup_info[0]));
  }
  aidx = new_max - 1;
  for (a = parser_priv(p); a; a = n, aidx--) {
    assert(aidx >= old_max);
    memcpy(&a_info[aidx], a, sizeof(*a));
    a_info[aidx].aidx = aidx;
    n = a->next;
    a_info[aidx].next = (aidx < z_info->a_max) ? &a_info[aidx + 1] : NULL;
    mem_free(a);
    aup_info[aidx].aidx = aidx;
    aup_info[aidx].created = false;
    aup_info[aidx].seen = false;
    aup_info[aidx].everseen = false;
  }
  z_info->a_max = new_max;
  parser_destroy(p);
  return 0;
}
STATIC_OVL enum parser_error
parse_object_property_name(struct parser* p)
{
  const char* name = parser_getstr(p, "name");
  struct obj_property* h = parser_priv(p);
  struct obj_property* prop = mem_zalloc(sizeof *prop);
  prop->next = h;
  parser_setpriv(p, prop);
  prop->name = string_make(name);
  prop->smith_cat = SMITH_CAT_MAX;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_property_type(struct parser* p)
{
  struct obj_property* prop = parser_priv(p);
  const char* name = parser_getstr(p, "type");
  if (!prop) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  if (streq(name, "stat")) {
    prop->type = OBJ_PROPERTY_STAT;
  } else if (streq(name, "skill")) {
    prop->type = OBJ_PROPERTY_SKILL;
  } else if (streq(name, "mod")) {
    prop->type = OBJ_PROPERTY_MOD;
  } else if (streq(name, "flag")) {
    prop->type = OBJ_PROPERTY_FLAG;
  } else if (streq(name, "slay")) {
    prop->type = OBJ_PROPERTY_SLAY;
  } else if (streq(name, "brand")) {
    prop->type = OBJ_PROPERTY_BRAND;
  } else if (streq(name, "ignore")) {
    prop->type = OBJ_PROPERTY_IGNORE;
  } else if (streq(name, "resistance")) {
    prop->type = OBJ_PROPERTY_RESIST;
  } else if (streq(name, "vulnerability")) {
    prop->type = OBJ_PROPERTY_VULN;
  } else {
    return PARSE_ERROR_INVALID_PROPERTY;
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_property_subtype(struct parser* p)
{
  struct obj_property* prop = parser_priv(p);
  const char* name = parser_getstr(p, "subtype");
  if (!prop) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  if (streq(name, "sustain")) {
    prop->subtype = OFT_SUST;
  } else if (streq(name, "protection")) {
    prop->subtype = OFT_PROT;
  } else if (streq(name, "misc ability")) {
    prop->subtype = OFT_MISC;
  } else if (streq(name, "basic")) {
    prop->subtype = OFT_BASIC;
  } else if (streq(name, "melee")) {
    prop->subtype = OFT_MELEE;
  } else if (streq(name, "bad")) {
    prop->subtype = OFT_BAD;
  } else {
    return PARSE_ERROR_INVALID_SUBTYPE;
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_property_id_type(struct parser* p)
{
  struct obj_property* prop = parser_priv(p);
  const char* name = parser_getstr(p, "id");
  if (!prop) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  if (streq(name, "on effect")) {
    prop->id_type = OFID_NORMAL;
  } else if (streq(name, "timed")) {
    prop->id_type = OFID_TIMED;
  } else if (streq(name, "on wield")) {
    prop->id_type = OFID_WIELD;
  } else {
    return PARSE_ERROR_INVALID_ID_TYPE;
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_property_code(struct parser* p)
{
  struct obj_property* prop = parser_priv(p);
  const char* code = parser_getstr(p, "code");
  int index = -1;
  if (!prop) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  if (!prop->type) {
    return PARSE_ERROR_MISSING_OBJ_PROP_TYPE;
  }
  if (prop->type == OBJ_PROPERTY_STAT) {
    index = code_index_in_array(obj_mods, code);
  } else if (prop->type == OBJ_PROPERTY_SKILL) {
    index = code_index_in_array(obj_mods, code);
  } else if (prop->type == OBJ_PROPERTY_MOD) {
    index = code_index_in_array(obj_mods, code);
  } else if (prop->type == OBJ_PROPERTY_FLAG) {
    index = code_index_in_array(obj_flags, code);
  } else if (prop->type == OBJ_PROPERTY_SLAY) {
    index = lookup_slay(code);
  } else if (prop->type == OBJ_PROPERTY_BRAND) {
    index = lookup_brand(code);
  } else if (prop->type == OBJ_PROPERTY_IGNORE) {
    index = code_index_in_array(element_names, code);
  } else if (prop->type == OBJ_PROPERTY_RESIST) {
    index = code_index_in_array(element_names, code);
  } else if (prop->type == OBJ_PROPERTY_VULN) {
    index = code_index_in_array(element_names, code);
  }
  if (index >= 0) {
    prop->index = index;
  } else {
    return PARSE_ERROR_INVALID_OBJ_PROP_CODE;
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_property_smith_cat(struct parser* p)
{
  struct obj_property* prop = parser_priv(p);
  const char* name = parser_getstr(p, "type");
  if (!prop) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  if (streq(name, "stat")) {
    prop->smith_cat = SMITH_CAT_STAT;
  } else if (streq(name, "sustain")) {
    prop->smith_cat = SMITH_CAT_SUSTAIN;
  } else if (streq(name, "skill")) {
    prop->smith_cat = SMITH_CAT_SKILL;
  } else if (streq(name, "melee")) {
    prop->smith_cat = SMITH_CAT_MELEE;
  } else if (streq(name, "slay")) {
    prop->smith_cat = SMITH_CAT_SLAY;
  } else if (streq(name, "resist")) {
    prop->smith_cat = SMITH_CAT_RESIST;
  } else if (streq(name, "curse")) {
    prop->smith_cat = SMITH_CAT_CURSE;
  } else if (streq(name, "misc")) {
    prop->smith_cat = SMITH_CAT_MISC;
  } else {
    return PARSE_ERROR_INVALID_SMITHING_CATEGORY;
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_property_smith_diff(struct parser* p)
{
  struct obj_property* prop = parser_priv(p);
  if (!prop) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  prop->smith_diff = parser_getint(p, "difficulty");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_property_smith_cost(struct parser* p)
{
  struct obj_property* prop = parser_priv(p);
  const char* name = parser_getsym(p, "type");
  if (!prop) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  if (streq(name, "STR")) {
    prop->smith_cost_type = SMITH_COST_STR;
  } else if (streq(name, "DEX")) {
    prop->smith_cost_type = SMITH_COST_DEX;
  } else if (streq(name, "CON")) {
    prop->smith_cost_type = SMITH_COST_CON;
  } else if (streq(name, "GRA")) {
    prop->smith_cost_type = SMITH_COST_GRA;
  } else if (streq(name, "EXP")) {
    prop->smith_cost_type = SMITH_COST_EXP;
  } else {
    return PARSE_ERROR_INVALID_SMITHING_COST_TYPE;
  }
  prop->smith_cost = parser_getint(p, "cost");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_property_smith_exclude_base(struct parser* p)
{
  struct obj_property* prop = parser_priv(p);
  const char* yesno = parser_getstr(p, "yesno");
  if (!prop) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  if (streq(yesno, "yes")) {
    prop->smith_exclude_base = true;
  } else if (streq(yesno, "no")) {
    prop->smith_exclude_base = false;
  } else {
    return PARSE_ERROR_INVALID_OPTION;
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_property_adjective(struct parser* p)
{
  struct obj_property* prop = parser_priv(p);
  const char* adj = parser_getstr(p, "adj");
  if (!prop) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  string_free(prop->adjective);
  prop->adjective = string_make(adj);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_property_neg_adj(struct parser* p)
{
  struct obj_property* prop = parser_priv(p);
  const char* adj = parser_getstr(p, "neg_adj");
  if (!prop) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  string_free(prop->neg_adj);
  prop->neg_adj = string_make(adj);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_property_msg(struct parser* p)
{
  struct obj_property* prop = parser_priv(p);
  const char* msg = parser_getstr(p, "msg");
  if (!prop) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  string_free(prop->msg);
  prop->msg = string_make(msg);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_property_slay_msg(struct parser* p)
{
  struct obj_property* prop = parser_priv(p);
  const char* msg = parser_getstr(p, "msg");
  if (!prop) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  string_free(prop->slay_msg);
  prop->slay_msg = string_make(msg);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_object_property_desc(struct parser* p)
{
  struct obj_property* prop = parser_priv(p);
  const char* desc = parser_getstr(p, "desc");
  if (!prop) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  string_free(prop->desc);
  prop->desc = string_make(desc);
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_parse_object_property(void)
{
  struct parser* p = parser_new();
  parser_setpriv(p, NULL);
  parser_reg(p, "name str name", parse_object_property_name);
  parser_reg(p, "code str code", parse_object_property_code);
  parser_reg(p, "smith-cat str type", parse_object_property_smith_cat);
  parser_reg(p, "smith-difficulty int difficulty",
             parse_object_property_smith_diff);
  parser_reg(p, "smith-cost sym type int cost",
             parse_object_property_smith_cost);
  parser_reg(p, "smith-exclude-base str yesno",
             parse_object_property_smith_exclude_base);
  parser_reg(p, "type str type", parse_object_property_type);
  parser_reg(p, "subtype str subtype", parse_object_property_subtype);
  parser_reg(p, "id-type str id", parse_object_property_id_type);
  parser_reg(p, "adjective str adj", parse_object_property_adjective);
  parser_reg(p, "neg-adjective str neg_adj", parse_object_property_neg_adj);
  parser_reg(p, "msg str msg", parse_object_property_msg);
  parser_reg(p, "slay-msg str msg", parse_object_property_slay_msg);
  parser_reg(p, "desc str desc", parse_object_property_desc);
  return p;
}
STATIC_OVL errr
run_parse_object_property(struct parser* p)
{
  return parse_file_quit_not_found(p, "object_property");
}
STATIC_OVL errr
finish_parse_object_property(struct parser* p)
{
  struct obj_property *prop, *n;
  int idx;
  z_info->property_max = 0;
  prop = parser_priv(p);
  while (prop) {
    z_info->property_max++;
    prop = prop->next;
  }
  obj_properties = mem_zalloc((z_info->property_max + 1) * sizeof(*prop));
  idx = z_info->property_max;
  for (prop = parser_priv(p); prop; prop = n, idx--) {
    assert(idx > 0);
    memcpy(&obj_properties[idx], prop, sizeof(*prop));
    n = prop->next;
    mem_free(prop);
  }
  z_info->property_max += 1;
  parser_destroy(p);
  return 0;
}
STATIC_OVL void
cleanup_object_property(void)
{
  int idx;
  for (idx = 0; idx < z_info->property_max; idx++) {
    struct obj_property* prop = &obj_properties[idx];
    string_free(prop->name);
    string_free(prop->adjective);
    string_free(prop->neg_adj);
    string_free(prop->slay_msg);
    string_free(prop->msg);
    string_free(prop->desc);
  }
  mem_free(obj_properties);
}
STATIC_OVL void
init_rune(void)
{
  int i, j, count;
  count = 0;
  for (i = 1; i < OF_MAX; i++) {
    struct obj_property* prop = lookup_obj_property(OBJ_PROPERTY_FLAG, i);
    if (prop->subtype == OFT_NONE) continue;
    if (prop->subtype == OFT_BASIC) continue;
    count++;
  }
  for (i = 0; i < OBJ_MOD_MAX; i++) {
    count++;
  }
  for (i = 0; i < ELEM_MAX; i++) {
    count++;
  }
  for (i = 1; i < z_info->brand_max; i++) {
    bool counted = false;
    if (brands[i].name) {
      for (j = 1; j < i; j++) {
        if (streq(brands[i].name, brands[j].name)) {
          counted = true;
        }
      }
      if (!counted) {
        count++;
      }
    }
  }
  for (i = 1; i < z_info->slay_max; i++) {
    bool counted = false;
    if (slays[i].name) {
      for (j = 1; j < i; j++) {
        if (same_monsters_slain(i, j)) {
          counted = true;
        }
      }
      if (!counted) {
        count++;
      }
    }
  }
  rune_max = count;
  rune_list = mem_zalloc(rune_max * sizeof(struct rune));
  count = 0;
  for (i = 0; i < OBJ_MOD_MAX; i++) {
    struct obj_property* prop = lookup_obj_property(OBJ_PROPERTY_MOD, i);
    rune_list[count++] = (struct rune){RUNE_VAR_MOD, i, 0, prop->name};
  }
  for (i = 0; i < ELEM_MAX; i++) {
    rune_list[count++] =
        (struct rune){RUNE_VAR_RESIST, i, 0, projections[i].name};
  }
  for (i = 1; i < z_info->brand_max; i++) {
    bool counted = false;
    if (brands[i].name) {
      for (j = 1; j < i; j++) {
        if (streq(brands[i].name, brands[j].name)) {
          counted = true;
        }
      }
      if (!counted) {
        rune_list[count++] =
            (struct rune){RUNE_VAR_BRAND, i, 0, brands[i].name};
      }
    }
  }
  for (i = 1; i < z_info->slay_max; i++) {
    bool counted = false;
    if (slays[i].name) {
      for (j = 1; j < i; j++) {
        if (same_monsters_slain(i, j)) {
          counted = true;
        }
      }
      if (!counted) {
        rune_list[count++] = (struct rune){RUNE_VAR_SLAY, i, 0, slays[i].name};
      }
    }
  }
  for (i = 1; i < OF_MAX; i++) {
    struct obj_property* prop = lookup_obj_property(OBJ_PROPERTY_FLAG, i);
    if (prop->subtype == OFT_NONE) continue;
    if (prop->subtype == OFT_BASIC) continue;
    rune_list[count++] = (struct rune){RUNE_VAR_FLAG, i, 0, prop->name};
  }
}
STATIC_OVL int
rune_index(size_t variety, int index)
{
  size_t i;
  for (i = 0; i < rune_max; i++)
    if ((rune_list[i].variety == variety) && (rune_list[i].index == index))
      return i;
  return -1;
}
STATIC_OVL void
cleanup_rune(void)
{
  mem_free(rune_list);
}
STATIC_OVL int
max_runes(void)
{
  return rune_max;
}
STATIC_OVL enum rune_variety
rune_variety(size_t i)
{
  return rune_list[i].variety;
}
STATIC_OVL bool
player_knows_rune(struct player* p, size_t i)
{
  struct rune* r = &rune_list[i];
  switch (r->variety) {
    case RUNE_VAR_MOD: {
      if (p->obj_k->modifiers[r->index]) return true;
      break;
    }
    case RUNE_VAR_RESIST: {
      if (p->obj_k->el_info[r->index].res_level) return true;
      break;
    }
    case RUNE_VAR_BRAND: {
      assert(r->index < z_info->brand_max);
      if (p->obj_k->brands[r->index]) {
        return true;
      }
      break;
    }
    case RUNE_VAR_SLAY: {
      assert(r->index < z_info->slay_max);
      if (p->obj_k->slays[r->index]) {
        return true;
      }
      break;
    }
    case RUNE_VAR_FLAG: {
      if (of_has(p->obj_k->flags, r->index)) return true;
      break;
    }
    default: {
      break;
    }
  }
  return false;
}
STATIC_OVL const char*
rune_name(size_t i)
{
  struct rune* r = &rune_list[i];
  if (r->variety == RUNE_VAR_BRAND)
    return format("%s brand", r->name);
  else if (r->variety == RUNE_VAR_SLAY)
    return format("slay %s", r->name);
  else if (r->variety == RUNE_VAR_RESIST)
    return format("resist %s", r->name);
  else
    return format("%s", r->name);
  return NULL;
}
STATIC_OVL const char*
rune_desc(size_t i)
{
  struct rune* r = &rune_list[i];
  switch (r->variety) {
    case RUNE_VAR_MOD: {
      return format("Object gives the player a magical bonus to %s.", r->name);
      break;
    }
    case RUNE_VAR_RESIST: {
      return format("Object affects the player's resistance to %s.", r->name);
      break;
    }
    case RUNE_VAR_BRAND: {
      return format("Object brands the player's attacks with %s.", r->name);
      break;
    }
    case RUNE_VAR_SLAY: {
      return format(
          "Object makes the player's attacks against %s more powerful.",
          r->name);
      break;
    }
    case RUNE_VAR_FLAG: {
      return format("Object gives the player the property of %s.", r->name);
      break;
    }
    default: {
      break;
    }
  }
  return NULL;
}
STATIC_OVL quark_t
rune_note(size_t i)
{
  return rune_list[i].note;
}
STATIC_OVL void
rune_set_note(size_t i, const char* inscription)
{
  struct rune* r = &rune_list[i];
  if (!inscription)
    r->note = 0;
  else
    r->note = quark_add(inscription);
}
STATIC_OVL bool
player_knows_flag(struct player* p, int f)
{
  return of_has(p->obj_k->flags, f);
}
STATIC_OVL bool
player_knows_brand(struct player* p, int i)
{
  return p->obj_k->brands[i];
}
STATIC_OVL bool
player_knows_slay(struct player* p, int i)
{
  return p->obj_k->slays[i];
}
STATIC_OVL bool
player_knows_ego(struct player* p, struct ego_item* ego)
{
  int i;
  if (!ego) return false;
  if (!of_is_subset(p->obj_k->flags, ego->flags)) return false;
  for (i = 0; i < OBJ_MOD_MAX; i++) {
    if ((ABS(ego->modifiers[i]) > 0) && !p->obj_k->modifiers[i]) {
      return false;
    }
  }
  for (i = 0; i < ELEM_MAX; i++)
    if (ego->el_info[i].res_level && !p->obj_k->el_info[i].res_level)
      return false;
  for (i = 1; i < z_info->brand_max; i++) {
    if (ego->brands && ego->brands[i] && !player_knows_brand(p, i)) {
      return false;
    }
  }
  for (i = 1; i < z_info->slay_max; i++) {
    if (ego->slays && ego->slays[i] && !player_knows_slay(p, i)) {
      return false;
    }
  }
  return true;
}
STATIC_OVL bool
object_is_known_artifact(const struct object* obj)
{
  if (!obj->known) return false;
  return obj->known->artifact ? true : false;
}
STATIC_OVL bool
object_has_rune(const struct object* obj, int rune_no)
{
  struct rune* r = &rune_list[rune_no];
  switch (r->variety) {
    case RUNE_VAR_MOD: {
      if (obj->modifiers[r->index] != 0) return true;
      break;
    }
    case RUNE_VAR_RESIST: {
      if (obj->el_info[r->index].res_level != 0) return true;
      break;
    }
    case RUNE_VAR_BRAND: {
      if (obj->brands) {
        int i;
        for (i = 0; i < z_info->brand_max; i++) {
          if (obj->brands[i] && streq(brands[i].name, r->name)) {
            return true;
          }
        }
      }
      break;
    }
    case RUNE_VAR_SLAY: {
      if (obj->slays) {
        int i;
        for (i = 0; i < z_info->slay_max; i++) {
          if (obj->slays[i] && same_monsters_slain(r->index, i)) {
            return true;
          }
        }
      }
      break;
    }
    case RUNE_VAR_FLAG: {
      if (of_has(obj->flags, r->index)) return true;
      break;
    }
    default:
      break;
  }
  return false;
}
STATIC_OVL bool
object_runes_known(const struct object* obj)
{
  int i;
  if (!obj->known) return false;
  for (i = 0; i < OBJ_MOD_MAX; i++)
    if (obj->modifiers[i] != obj->known->modifiers[i]) return false;
  for (i = 0; i < ELEM_MAX; i++)
    if ((obj->el_info[i].res_level != 0) &&
        (obj->known->el_info[i].res_level == 0))
      return false;
  if (obj->brands) {
    if (!obj->known->brands) return false;
    for (i = 0; i < z_info->brand_max; i++) {
      if (obj->brands[i] && !obj->known->brands[i]) {
        return false;
      }
    }
  }
  if (obj->slays) {
    if (!obj->known->slays) return false;
    for (i = 0; i < z_info->slay_max; i++) {
      if (obj->slays[i] && !obj->known->slays[i]) {
        return false;
      }
    }
  }
  if (!of_is_subset(obj->known->flags, obj->flags)) return false;
  return true;
}
STATIC_OVL bool
object_flag_is_known(const struct player* p, const struct object* obj, int flag)
{
  if (object_runes_known(obj)) return true;
  if (of_has(p->obj_k->flags, flag)) return true;
  if (of_has(obj->known->flags, flag)) return true;
  return false;
}
STATIC_OVL bool
object_element_is_known(const struct player* p, const struct object* obj,
                        int element)
{
  if (element < 0 || element >= ELEM_MAX) return false;
  if (object_runes_known(obj)) return true;
  if (p->obj_k->el_info[element].res_level) return true;
  if (obj->known->el_info[element].res_level) return true;
  return false;
}
STATIC_OVL void
object_set_base_known(struct player* p, struct object* obj)
{
  assert(obj->known);
  obj->known->kind = obj->kind;
  obj->known->tval = obj->tval;
  obj->known->sval = obj->sval;
  obj->known->weight = obj->weight;
  obj->known->number = obj->number;
  if (!obj->known->dd) {
    obj->known->dd = obj->kind->dd * p->obj_k->dd;
  }
  if (!obj->known->ds) {
    obj->known->ds = obj->kind->ds * p->obj_k->ds;
  }
  if (!obj->known->pd) {
    obj->known->pd = obj->kind->pd * p->obj_k->pd;
  }
  if (!obj->known->ps) {
    obj->known->ps = obj->kind->ps * p->obj_k->ps;
  }
  if (!obj->known->att) {
    obj->known->att = obj->kind->att * p->obj_k->att;
  }
  if (!obj->known->evn) {
    obj->known->evn = obj->kind->evn * p->obj_k->evn;
  }
  if ((obj->kind->aware && obj->kind->flavor) ||
      (!tval_is_wearable(obj) && !obj->kind->flavor)) {
    obj->known->pval = obj->pval;
  }
}
STATIC_OVL void
object_see(struct player* p, struct object* obj)
{
  struct object* known_obj = p->cave->objects[obj->oidx];
  struct loc grid = obj->grid;
  if (known_obj == NULL) {
    struct object* new_obj;
    assert(!obj->known);
    new_obj = object_new();
    obj->known = new_obj;
    new_obj->kind = obj->kind;
    new_obj->tval = obj->tval;
    new_obj->sval = obj->sval;
    new_obj->number = obj->number;
    p->cave->objects[obj->oidx] = new_obj;
    new_obj->oidx = obj->oidx;
    if (obj->held_m_idx) return;
    new_obj->grid = grid;
    pile_insert_end(&p->cave->squares[grid.y][grid.x].obj, new_obj);
  } else {
    struct loc old = known_obj->grid;
    assert(known_obj == obj->known);
    known_obj->kind = obj->kind;
    known_obj->tval = obj->tval;
    known_obj->sval = obj->sval;
    known_obj->number = obj->number;
    if (obj->held_m_idx) return;
    if (!square_holds_object(p->cave, grid, known_obj)) {
      if (!loc_is_zero(old) && square_holds_object(p->cave, old, known_obj)) {
        square_excise_object(p->cave, old, known_obj);
      }
      known_obj->grid = grid;
      pile_insert_end(&p->cave->squares[grid.y][grid.x].obj, known_obj);
    }
  }
}
STATIC_OVL void
object_touch(struct player* p, struct object* obj)
{
  obj->known->artifact = obj->artifact;
  obj->known->notice |= OBJ_NOTICE_ASSESSED;
  player_know_object(p, obj);
  if (obj->artifact && !is_artifact_seen(obj->artifact)) {
    const struct artifact* art = obj->artifact;
    int new_exp = 100;
    mark_artifact_seen(art, true);
    player_exp_gain(p, new_exp);
    p->ident_exp += new_exp;
    history_find_artifact(p, art);
  }
}
STATIC_OVL void
player_know_object(struct player* p, struct object* obj)
{
  int i, flag;
  bool seen = true;
  if (!obj) return;
  if (!obj->known) return;
  if (obj->kind != obj->known->kind) return;
  if (obj->kind && !(obj->known->notice & OBJ_NOTICE_ASSESSED)) {
    object_set_base_known(p, obj);
    return;
  }
  if (player_active_ability(p, "Item Lore")) {
    object_flavor_aware(p, obj);
  }
  if (player_active_ability(p, "Lore-Master")) {
    while (!object_runes_known(obj)) {
      object_learn_unknown_rune(p, obj);
    }
  }
  obj->known->dd = obj->dd * p->obj_k->dd;
  obj->known->ds = obj->ds * p->obj_k->ds;
  obj->known->pd = obj->pd * p->obj_k->pd;
  obj->known->ps = obj->ps * p->obj_k->ps;
  obj->known->att = obj->att * p->obj_k->att;
  obj->known->evn = obj->evn * p->obj_k->evn;
  if (!tval_is_chest(obj)) obj->known->pval = obj->pval;
  for (i = 0; i < OBJ_MOD_MAX; i++) {
    if (p->obj_k->modifiers[i]) {
      obj->known->modifiers[i] = obj->modifiers[i];
    } else {
      obj->known->modifiers[i] = 0;
    }
  }
  for (i = 0; i < ELEM_MAX; i++) {
    if (p->obj_k->el_info[i].res_level == 1) {
      obj->known->el_info[i].res_level = obj->el_info[i].res_level;
      obj->known->el_info[i].flags = obj->el_info[i].flags;
    } else {
      obj->known->el_info[i].res_level = 0;
      obj->known->el_info[i].flags = 0;
    }
  }
  of_wipe(obj->known->flags);
  for (flag = of_next(p->obj_k->flags, FLAG_START); flag != FLAG_END;
       flag = of_next(p->obj_k->flags, flag + 1)) {
    if (of_has(obj->flags, flag)) {
      of_on(obj->known->flags, flag);
    }
  }
  if (obj->brands) {
    bool known_brand = false;
    for (i = 1; i < z_info->brand_max; i++) {
      if (player_knows_brand(p, i) && obj->brands[i]) {
        if (!obj->known->brands) {
          obj->known->brands = mem_zalloc(z_info->brand_max * sizeof(bool));
        }
        obj->known->brands[i] = true;
        known_brand = true;
      } else if (obj->known->brands) {
        obj->known->brands[i] = false;
      }
    }
    if (!known_brand && obj->known->brands) {
      mem_free(obj->known->brands);
      obj->known->brands = NULL;
    }
  }
  if (obj->slays) {
    bool known_slay = false;
    for (i = 1; i < z_info->slay_max; i++) {
      if (player_knows_slay(p, i) && obj->slays[i]) {
        if (!obj->known->slays) {
          obj->known->slays = mem_zalloc(z_info->slay_max * sizeof(bool));
        }
        obj->known->slays[i] = true;
        known_slay = true;
      } else if (obj->known->slays) {
        obj->known->slays[i] = false;
      }
    }
    if (!known_slay && obj->known->slays) {
      mem_free(obj->known->slays);
      obj->known->slays = NULL;
    }
  }
  if (player_knows_ego(p, obj->ego)) {
    seen = obj->ego->everseen;
    obj->known->ego = obj->ego;
  } else {
    obj->known->ego = NULL;
  }
  if (tval_is_jewelry(obj)) {
    if (object_runes_known(obj)) {
      seen = (obj->artifact) ? true : obj->kind->everseen;
      object_flavor_aware(p, obj);
    }
  } else if (obj->kind->kidx >= z_info->ordinary_kind_max) {
    seen = true;
    object_flavor_aware(p, obj);
  }
  if (!seen) {
    char o_name[80];
    if (object_is_carried(p, obj)) {
      object_desc(o_name, sizeof(o_name), obj, ODESC_PREFIX | ODESC_FULL, p);
      msg("You have %s (%c).", o_name, gear_to_label(p, obj));
    } else if (cave && square_holds_object(cave, p->grid, obj)) {
      object_desc(o_name, sizeof(o_name), obj, ODESC_PREFIX | ODESC_FULL, p);
      msg("On the ground: %s.", o_name);
    }
  }
  if (object_runes_known(obj)) {
    for (i = 0; i < ELEM_MAX; i++) {
      obj->known->el_info[i].res_level = obj->el_info[i].res_level;
      obj->known->el_info[i].flags = obj->el_info[i].flags;
    }
    of_wipe(obj->known->flags);
    of_copy(obj->known->flags, obj->flags);
  }
}
STATIC_OVL void
update_player_object_knowledge(struct player* p)
{
  int i;
  struct object* obj;
  if (cave)
    for (i = 0; i < cave->obj_max; i++) player_know_object(p, cave->objects[i]);
  for (obj = p->gear; obj; obj = obj->next) player_know_object(p, obj);
  if (cave) autoinscribe_ground(p);
  autoinscribe_pack(p);
  event_signal(EVENT_INVENTORY);
  event_signal(EVENT_EQUIPMENT);
}
STATIC_OVL void
player_learn_rune(struct player* p, size_t i, bool message)
{
  struct rune* r = &rune_list[i];
  bool learned = false;
  switch (r->variety) {
    case RUNE_VAR_MOD: {
      if (!p->obj_k->modifiers[r->index]) {
        p->obj_k->modifiers[r->index] = 1;
        learned = true;
      }
      break;
    }
    case RUNE_VAR_RESIST: {
      if (!p->obj_k->el_info[r->index].res_level) {
        p->obj_k->el_info[r->index].res_level = 1;
        learned = true;
      }
      break;
    }
    case RUNE_VAR_BRAND: {
      assert(r->index < z_info->brand_max);
      if (!player_knows_brand(p, r->index)) {
        int j;
        for (j = 1; j < z_info->brand_max; j++) {
          if (streq(brands[r->index].name, brands[j].name)) {
            p->obj_k->brands[j] = true;
            learned = true;
          }
        }
      }
      break;
    }
    case RUNE_VAR_SLAY: {
      assert(r->index < z_info->slay_max);
      if (!player_knows_slay(p, r->index)) {
        int j;
        for (j = 1; j < z_info->slay_max; j++) {
          if (same_monsters_slain(r->index, j)) {
            p->obj_k->slays[j] = true;
            learned = true;
          }
        }
      }
      break;
    }
    case RUNE_VAR_FLAG: {
      if (of_on(p->obj_k->flags, r->index)) learned = true;
      break;
    }
    default: {
      learned = false;
      break;
    }
  }
  if (!learned) return;
  if (message)
    msgt(MSG_RUNE, "You have learned the property of %s.", rune_name(i));
  update_player_object_knowledge(p);
}
STATIC_OVL void
player_learn_flag(struct player* p, int flag)
{
  player_learn_rune(p, rune_index(RUNE_VAR_FLAG, flag), true);
  update_player_object_knowledge(p);
}
STATIC_OVL void
player_learn_slay(struct player* p, int index)
{
  if (!player_knows_slay(p, index)) {
    int i;
    for (i = 1; i < z_info->slay_max; i++) {
      if (same_monsters_slain(i, index)) {
        break;
      }
    }
    assert(i < z_info->slay_max);
    player_learn_rune(p, rune_index(RUNE_VAR_SLAY, i), true);
    update_player_object_knowledge(p);
  }
}
STATIC_OVL void
player_learn_brand(struct player* p, int index)
{
  if (!player_knows_brand(p, index)) {
    int i;
    for (i = 1; i < z_info->brand_max; i++) {
      if (streq(brands[i].name, brands[index].name)) {
        break;
      }
    }
    assert(i < z_info->brand_max);
    player_learn_rune(p, rune_index(RUNE_VAR_BRAND, i), true);
    update_player_object_knowledge(p);
  }
}
STATIC_OVL void
player_learn_all_runes(struct player* p)
{
  size_t i;
  for (i = 0; i < rune_max; i++) player_learn_rune(p, i, false);
}
STATIC_OVL void
mod_message(struct object* obj, int mod)
{
  switch (mod) {
    case OBJ_MOD_STR:
      if (obj->modifiers[OBJ_MOD_STR] > 0)
        msg("You feel stronger.");
      else if (obj->modifiers[OBJ_MOD_STR] < 0)
        msg("You feel less strong");
      break;
    case OBJ_MOD_DEX:
      if (obj->modifiers[OBJ_MOD_DEX] > 0)
        msg("You feel more agile.");
      else if (obj->modifiers[OBJ_MOD_DEX] < 0)
        msg("You feel less agile.");
      break;
    case OBJ_MOD_CON:
      if (obj->modifiers[OBJ_MOD_CON] > 0)
        msg("You feel mmore resilient.");
      else if (obj->modifiers[OBJ_MOD_CON] < 0)
        msg("You feel less resilient.");
      break;
    case OBJ_MOD_GRA:
      if (obj->modifiers[OBJ_MOD_GRA] > 0)
        msg("You feel more attuned to the world.");
      else if (obj->modifiers[OBJ_MOD_GRA] < 0)
        msg("You feel less attuned to the world.");
      break;
    case OBJ_MOD_MELEE:
      if (obj->modifiers[OBJ_MOD_MELEE] > 0)
        msg("You feel more in control of your weapon.");
      else if (obj->modifiers[OBJ_MOD_MELEE] < 0)
        msg("You feel less in control of your weapon.");
      break;
    case OBJ_MOD_ARCHERY:
      if (obj->modifiers[OBJ_MOD_ARCHERY] > 0)
        msg("You feel more accurate at archery.");
      else if (obj->modifiers[OBJ_MOD_ARCHERY] < 0)
        msg("You feel less accurate at archery.");
      break;
    case OBJ_MOD_STEALTH:
      if (obj->modifiers[OBJ_MOD_STEALTH] > 0)
        msg("Your movements become quieter.");
      else if (obj->modifiers[OBJ_MOD_STEALTH] < 0)
        msg("Your movements become less quiet.");
      break;
    case OBJ_MOD_PERCEPTION:
      if (obj->modifiers[OBJ_MOD_PERCEPTION] > 0)
        msg("You feel more perceptive.");
      else if (obj->modifiers[OBJ_MOD_PERCEPTION] < 0)
        msg("You feel less perceptive.");
      break;
    case OBJ_MOD_WILL:
      if (obj->modifiers[OBJ_MOD_WILL] > 0)
        msg("You feel more firm of will.");
      else if (obj->modifiers[OBJ_MOD_WILL] < 0)
        msg("You feel less firm of will.");
      break;
    case OBJ_MOD_SMITHING:
      if (obj->modifiers[OBJ_MOD_SMITHING] > 0)
        msg("You feel a desire to craft things with your hands.");
      else if (obj->modifiers[OBJ_MOD_SMITHING] < 0)
        msg("You feel less able to craft things.");
      break;
    case OBJ_MOD_SONG:
      if (obj->modifiers[OBJ_MOD_SONG] > 0)
        msg("You are filled with inspiration.");
      else if (obj->modifiers[OBJ_MOD_SONG] < 0)
        msg("You feel a loss of inspiration.");
      break;
    case OBJ_MOD_DAMAGE_SIDES:
      if (obj->modifiers[OBJ_MOD_DAMAGE_SIDES] > 0)
        msg("You feel more forceful in melee.");
      else if (obj->modifiers[OBJ_MOD_DAMAGE_SIDES] < 0)
        msg("You feel less forceful in melee.");
      break;
    default:
      break;
  }
}
STATIC_OVL int
object_find_unknown_rune(struct player* p, struct object* obj)
{
  size_t i, num = 0;
  int* poss_runes;
  int chosen = -1;
  if (object_runes_known(obj)) return -1;
  poss_runes = mem_zalloc(rune_max * sizeof(int));
  for (i = 0; i < rune_max; i++)
    if (object_has_rune(obj, i) && !player_knows_rune(p, i))
      poss_runes[num++] = i;
  if (num) {
    chosen = poss_runes[randint0(num)];
  }
  mem_free(poss_runes);
  return chosen;
}
STATIC_OVL void
object_learn_unknown_rune(struct player* p, struct object* obj)
{
  int i = object_find_unknown_rune(p, obj);
  if (i < 0) {
    obj->known->notice |= OBJ_NOTICE_ASSESSED;
    player_know_object(player, obj);
    return;
  }
  player_learn_rune(p, i, true);
}
STATIC_OVL void
object_learn_on_wield(struct player* p, struct object* obj)
{
  bitflag f[OF_SIZE], obvious_mask[OF_SIZE];
  int i, flag;
  char o_name[80];
  assert(obj->known);
  object_desc(o_name, sizeof(o_name), obj, ODESC_BASE, p);
  if (obj->known->notice & OBJ_NOTICE_WORN) {
    return;
  } else {
    obj->known->notice |= OBJ_NOTICE_WORN;
  }
  object_flavor_tried(obj);
  create_obj_flag_mask(obvious_mask, true, OFID_WIELD, OFT_MAX);
  for (i = 0; i < STAT_MAX; i++) {
    int sust = sustain_flag(i);
    if (obj->modifiers[i]) {
      of_on(obvious_mask, sust);
    }
  }
  object_flags(obj, f);
  of_inter(f, obvious_mask);
  for (flag = of_next(f, FLAG_START); flag != FLAG_END;
       flag = of_next(f, flag + 1)) {
    if (!of_has(p->obj_k->flags, flag)) {
      if (p->upkeep->playing) {
        flag_message(flag, o_name);
      }
      player_learn_rune(p, rune_index(RUNE_VAR_FLAG, flag), true);
    }
  }
  for (i = 0; i < OBJ_MOD_MAX; i++) {
    if (obj->modifiers[i] && !p->obj_k->modifiers[i]) {
      if (p->upkeep->playing) {
        mod_message(obj, i);
      }
      player_learn_rune(p, rune_index(RUNE_VAR_MOD, i), true);
    }
  }
  if (obj->ego && obj->ego->abilities) {
    struct ability* ability = obj->ego->abilities;
    while (ability) {
      msg("You have gained the ability '%s'.", ability->name);
      ability = ability->next;
    }
  }
  if (obj->artifact && obj->artifact->abilities) {
    struct ability* ability = obj->artifact->abilities;
    while (ability) {
      msg("You have gained the ability '%s'.", ability->name);
      ability = ability->next;
    }
  }
}
STATIC_OVL void
equip_learn_flag(struct player* p, int flag)
{
  int i;
  bitflag f[OF_SIZE];
  of_wipe(f);
  of_on(f, flag);
  if (!flag) return;
  for (i = 0; i < p->body.count; i++) {
    struct object* obj = slot_object(p, i);
    if (!obj) continue;
    assert(obj->known);
    if (of_has(obj->flags, flag)) {
      if (!of_has(p->obj_k->flags, flag)) {
        char o_name[80];
        object_desc(o_name, sizeof(o_name), obj, ODESC_BASE, p);
        flag_message(flag, o_name);
        player_learn_rune(p, rune_index(RUNE_VAR_FLAG, flag), true);
      }
    } else if (!object_runes_known(obj)) {
      of_on(obj->known->flags, flag);
    }
  }
}
STATIC_OVL void
equip_learn_element(struct player* p, int element)
{
  int i;
  if (element < 0 || element >= ELEM_MAX) return;
  if (p->obj_k->el_info[element].res_level == 1) return;
  for (i = 0; i < p->body.count; i++) {
    struct object* obj = slot_object(p, i);
    if (!obj) continue;
    assert(obj->known);
    if (obj->el_info[element].res_level != 0) {
      char o_name[80];
      object_desc(o_name, sizeof(o_name), obj, ODESC_BASE, p);
      msg("Your %s glows.", o_name);
      player_learn_rune(p, rune_index(RUNE_VAR_RESIST, element), true);
    } else if (!object_runes_known(obj)) {
      obj->known->el_info[element].res_level = 1;
      obj->known->el_info[element].flags = obj->el_info[element].flags;
    }
  }
}
STATIC_OVL void
equip_learn_after_time(struct player* p)
{
  int i, flag;
  bitflag f[OF_SIZE], timed_mask[OF_SIZE];
  create_obj_flag_mask(timed_mask, true, OFID_TIMED, OFT_MAX);
  object_flags(p->obj_k, f);
  of_negate(f);
  of_inter(timed_mask, f);
  if (of_is_empty(timed_mask)) return;
  for (i = 0; i < p->body.count; i++) {
    char o_name[80];
    struct object* obj = slot_object(p, i);
    if (!obj) continue;
    assert(obj->known);
    object_desc(o_name, sizeof(o_name), obj, ODESC_BASE, p);
    object_flags(obj, f);
    of_inter(f, timed_mask);
    for (flag = of_next(f, FLAG_START); flag != FLAG_END;
         flag = of_next(f, flag + 1)) {
      if (!of_has(p->obj_k->flags, flag)) {
        flag_message(flag, o_name);
      }
      player_learn_rune(p, rune_index(RUNE_VAR_FLAG, flag), true);
    }
    if (!object_runes_known(obj)) {
      of_union(obj->known->flags, timed_mask);
    }
  }
}
STATIC_OVL bool
easy_know(const struct object* obj)
{
  assert(obj->kind);
  if (obj->kind->aware && kf_has(obj->kind->kind_flags, KF_EASY_KNOW))
    return true;
  else
    return false;
}
STATIC_OVL bool
object_flavor_is_aware(const struct object* obj)
{
  assert(obj->kind);
  return obj->kind->aware;
}
STATIC_OVL bool
object_flavor_was_tried(const struct object* obj)
{
  assert(obj->kind);
  return obj->kind->tried;
}
STATIC_OVL void
object_flavor_aware(struct player* p, struct object* obj)
{
  int y, x;
  int new_exp = 100;
  if (obj->kind->aware) return;
  obj->kind->aware = true;
  if (!cave) return;
  player_exp_gain(p, new_exp);
  p->ident_exp += new_exp;
  update_player_object_knowledge(p);
  p->upkeep->notice |= PN_IGNORE;
  for (y = 1; y < cave->height; y++) {
    for (x = 1; x < cave->width; x++) {
      bool light = false;
      const struct object* floor_obj;
      struct loc grid = loc(x, y);
      for (floor_obj = square_object(cave, grid); floor_obj;
           floor_obj = floor_obj->next)
        if (floor_obj->kind == obj->kind) {
          light = true;
          break;
        }
      if (light) square_light_spot(cave, grid);
    }
  }
}
STATIC_OVL void
object_flavor_tried(struct object* obj)
{
  assert(obj);
  assert(obj->kind);
  if (obj->kind->kidx >= z_info->ordinary_kind_max) {
    return;
  }
  obj->kind->tried = true;
}
STATIC_OVL int
object_value_base(const struct object* obj)
{
  int value = 0;
  struct object_kind* kind = obj->kind;
  if (object_flavor_is_aware(obj)) {
    value += (obj->att - kind->att) * 100;
    value += (obj->evn - kind->evn) * 100;
    value += (obj->ps - kind->ps) * obj->pd * 100;
    value += (obj->pd - kind->pd) * obj->ps * 100;
    value += (obj->ds - kind->ds) * 100;
    value += (obj->dd - kind->dd) * obj->ds * 100;
    if (tval_is_ammo(obj)) value /= 10;
    value += kind->cost;
  } else {
    switch (obj->tval) {
      case TV_FOOD:
        return 5;
      case TV_POTION:
        return 20;
      case TV_STAFF:
        return 70;
      case TV_HORN:
        return 90;
      case TV_RING:
        return 45;
      case TV_AMULET:
        return 45;
    }
  }
  return value;
}
STATIC_OVL int
object_value_real(const struct object* obj)
{
  int value, i;
  struct object_kind* kind = obj->kind;
  if (!kind->cost) return 0;
  value = kind->cost;
  if (obj->known->artifact) {
    const struct artifact* art = obj->artifact;
    if (!art->cost) return 0;
    value = art->cost;
  } else if (obj->known->ego) {
    struct ego_item* ego = obj->ego;
    if (!ego->cost) return 0;
    value += ego->cost;
  }
  switch (obj->tval) {
    case TV_ARROW:
    case TV_BOW:
    case TV_DIGGING:
    case TV_HAFTED:
    case TV_POLEARM:
    case TV_SWORD:
    case TV_BOOTS:
    case TV_GLOVES:
    case TV_HELM:
    case TV_CROWN:
    case TV_SHIELD:
    case TV_CLOAK:
    case TV_SOFT_ARMOR:
    case TV_MAIL:
    case TV_LIGHT:
    case TV_AMULET:
    case TV_RING: {
      for (i = 0; i < OBJ_MOD_MAX; i++) {
        if (i < STAT_MAX) {
          value += (obj->known->modifiers[i] * 300);
        } else if (i < SKILL_MAX) {
          if (obj->known->modifiers[i] < 0) {
            return 0;
          } else {
            value += (obj->known->modifiers[i] * 100);
          }
        } else if (i == OBJ_MOD_TUNNEL) {
          if (obj->known->modifiers[i] < 0) {
            return 0;
          } else {
            value += (obj->known->modifiers[i] * 50);
          }
        }
      }
      if (of_has(obj->known->flags, OF_SPEED)) value += 1000;
      break;
    }
  }
  switch (obj->tval) {
    case TV_STAFF: {
      value += ((value / 20) * (obj->known->pval / obj->known->number));
      break;
    }
    case TV_RING:
    case TV_AMULET: {
      if (obj->known->att < 0) return 0;
      if (obj->known->evn < 0) return 0;
      value += ((obj->known->att + obj->known->evn + obj->known->ps) * 100);
      break;
    }
    case TV_BOOTS:
    case TV_GLOVES:
    case TV_CLOAK:
    case TV_CROWN:
    case TV_HELM:
    case TV_SHIELD:
    case TV_SOFT_ARMOR:
    case TV_MAIL: {
      value += ((obj->known->att - kind->att) * 100);
      value += ((obj->known->evn - kind->evn) * 100);
      value += ((obj->known->ps - kind->ps) * obj->pd * 50);
      value += ((obj->known->pd - kind->pd) * obj->ps * 50);
      break;
    }
    case TV_BOW:
    case TV_DIGGING:
    case TV_HAFTED:
    case TV_SWORD:
    case TV_POLEARM: {
      value += ((obj->known->att - kind->att) * 100);
      value += ((obj->known->evn - kind->evn) * 100);
      value += ((obj->known->ds - kind->ds) * obj->known->dd * 51);
      value += ((obj->known->dd - kind->dd) * obj->known->ds * 51);
      break;
    }
    case TV_ARROW: {
      value += ((obj->known->att - kind->att) * 10);
      break;
    }
  }
  if (value < 0) value = 0;
  return value;
}
STATIC_OVL int
object_value(const struct object* obj)
{
  int value;
  if (obj->known) {
    value = object_value_real(obj);
  } else {
    value = object_value_base(obj);
  }
  return value;
}
STATIC_OVL object_list_t*
object_list_new(void)
{
  object_list_t* list = mem_zalloc(sizeof(object_list_t));
  size_t size = MAX_ITEMLIST;
  if (list == NULL) return NULL;
  list->entries = mem_zalloc(size * sizeof(object_list_entry_t));
  if (list->entries == NULL) {
    mem_free(list);
    return NULL;
  }
  list->entries_size = size;
  return list;
}
STATIC_OVL void
object_list_free(object_list_t* list)
{
  if (list == NULL) return;
  if (list->entries != NULL) {
    mem_free(list->entries);
    list->entries = NULL;
  }
  mem_free(list);
}
STATIC_OVL void
object_list_init(void)
{
  object_list_subwindow = NULL;
}
STATIC_OVL void
object_list_finalize(void)
{
  object_list_free(object_list_subwindow);
}
STATIC_OVL object_list_t*
object_list_shared_instance(void)
{
  if (object_list_subwindow == NULL) {
    object_list_subwindow = object_list_new();
  }
  return object_list_subwindow;
}
STATIC_OVL bool
object_list_needs_update(const object_list_t* list)
{
  if (list == NULL || list->entries == NULL) return false;
  return true;
}
STATIC_OVL void
object_list_reset(object_list_t* list)
{
  if (list == NULL || list->entries == NULL) return;
  if (!object_list_needs_update(list)) return;
  memset(list->entries, 0, list->entries_size * sizeof(object_list_entry_t));
  memset(list->total_entries, 0, OBJECT_LIST_SECTION_MAX * sizeof(uint16_t));
  memset(list->total_objects, 0, OBJECT_LIST_SECTION_MAX * sizeof(uint16_t));
  list->distinct_entries = 0;
  list->creation_turn = 0;
  list->sorted = false;
}
STATIC_OVL bool
object_list_should_ignore_object(const struct player* p,
                                 const struct object* obj)
{
  assert(obj->kind);
  if (ignore_known_item_ok(p, obj)) return true;
  return false;
}
STATIC_OVL void
object_list_collect(object_list_t* list)
{
  int i;
  struct loc pgrid = player->grid;
  if (list == NULL || list->entries == NULL) return;
  if (!object_list_needs_update(list)) return;
  for (i = 1; i < player->cave->obj_max; i++) {
    object_list_entry_t* entry = NULL;
    int entry_index;
    int current_distance;
    int entry_distance;
    struct loc grid;
    int field;
    bool los = false;
    struct object* obj = player->cave->objects[i];
    if (!obj) continue;
    if (loc_is_zero(obj->grid)) {
      continue;
    } else {
      grid = obj->grid;
    }
    los = projectable(cave, pgrid, grid, PROJECT_NONE) || loc_eq(grid, pgrid);
    field = (los) ? OBJECT_LIST_SECTION_LOS : OBJECT_LIST_SECTION_NO_LOS;
    if (object_list_should_ignore_object(player, obj)) continue;
    for (entry_index = 0; entry_index < (int)list->entries_size;
         entry_index++) {
      int j;
      struct object* list_obj = list->entries[entry_index].object;
      if (list_obj == NULL) {
        list->entries[entry_index].object = obj;
        for (j = 0; j < OBJECT_LIST_SECTION_MAX; j++)
          list->entries[entry_index].count[j] = 0;
        list->entries[entry_index].dy = grid.y - pgrid.y;
        list->entries[entry_index].dx = grid.x - pgrid.x;
        entry = &list->entries[entry_index];
        break;
      }
    }
    if (entry == NULL) return;
    if (obj->kind == cave->objects[obj->oidx]->kind)
      entry->count[field] += obj->number;
    else
      entry->count[field] = 1;
    current_distance = (grid.y - pgrid.y) * (grid.y - pgrid.y) +
                       (grid.x - pgrid.x) * (grid.x - pgrid.x);
    entry_distance = entry->dy * entry->dy + entry->dx * entry->dx;
    if (current_distance < entry_distance) {
      entry->dy = grid.y - pgrid.y;
      entry->dx = grid.x - pgrid.x;
    }
  }
  for (i = 0; i < (int)list->entries_size; i++) {
    if (list->entries[i].object == NULL) continue;
    if (list->entries[i].count[OBJECT_LIST_SECTION_LOS] > 0)
      list->total_entries[OBJECT_LIST_SECTION_LOS]++;
    if (list->entries[i].count[OBJECT_LIST_SECTION_NO_LOS] > 0)
      list->total_entries[OBJECT_LIST_SECTION_NO_LOS]++;
    list->total_objects[OBJECT_LIST_SECTION_LOS] +=
        list->entries[i].count[OBJECT_LIST_SECTION_LOS];
    list->total_objects[OBJECT_LIST_SECTION_NO_LOS] +=
        list->entries[i].count[OBJECT_LIST_SECTION_NO_LOS];
    list->distinct_entries++;
  }
  list->creation_turn = turn;
  list->sorted = false;
}
STATIC_OVL int
object_list_distance_compare(const void* a, const void* b)
{
  const object_list_entry_t* ae = (object_list_entry_t*)a;
  const object_list_entry_t* be = (object_list_entry_t*)b;
  int a_distance = ae->dy * ae->dy + ae->dx * ae->dx;
  int b_distance = be->dy * be->dy + be->dx * be->dx;
  if (a_distance < b_distance)
    return -1;
  else if (a_distance > b_distance)
    return 1;
  return 0;
}
STATIC_OVL int
object_list_standard_compare(const void* a, const void* b)
{
  int result;
  const struct object* ao =
      cave->objects[(((object_list_entry_t*)a)->object)->oidx];
  const struct object* bo =
      cave->objects[(((object_list_entry_t*)b)->object)->oidx];
  if (ao == NULL || bo == NULL) return 1;
  result = compare_items(ao, bo);
  if (result == 0) result = object_list_distance_compare(a, b);
  return result;
}
STATIC_OVL void
object_list_sort(object_list_t* list, int (*compare)(const void*, const void*))
{
  size_t elements;
  if (list == NULL || list->entries == NULL) return;
  if (list->sorted) return;
  elements = list->distinct_entries;
  if (elements <= 1) return;
  sort(list->entries, elements, sizeof(list->entries[0]), compare);
  list->sorted = true;
}
STATIC_OVL int
object_list_entry_line_attribute(const object_list_entry_t* entry)
{
  int attr;
  struct object* base_obj;
  if (entry == NULL || entry->object == NULL || entry->object->kind == NULL)
    return COLOUR_WHITE;
  base_obj = cave->objects[entry->object->oidx];
  if (base_obj->known->artifact)
    attr = COLOUR_VIOLET;
  else if (!object_flavor_is_aware(base_obj))
    attr = COLOUR_L_RED;
  else if (base_obj->kind->cost == 0)
    attr = COLOUR_SLATE;
  else
    attr = COLOUR_WHITE;
  return attr;
}
STATIC_OVL void
object_list_format_name(const object_list_entry_t* entry, char* line_buffer,
                        size_t size)
{
  char name[80];
  const char* chunk;
  char* source;
  bool has_singular_prefix;
  bool los = false;
  int field;
  struct loc pgrid = player->grid;
  struct object* base_obj;
  struct loc grid;
  bool object_is_recognized_artifact;
  if (entry == NULL || entry->object == NULL || entry->object->kind == NULL)
    return;
  base_obj = cave->objects[entry->object->oidx];
  grid = entry->object->grid;
  object_is_recognized_artifact = object_is_known_artifact(base_obj);
  switch (entry->object->kind->tval) {
    case TV_SOFT_ARMOR:
      if (object_is_recognized_artifact)
        has_singular_prefix = true;
      else if (base_obj->kind->sval == lookup_sval(TV_SOFT_ARMOR, "Robe"))
        has_singular_prefix = true;
      else
        has_singular_prefix = false;
      break;
    case TV_MAIL:
      if (object_is_recognized_artifact)
        has_singular_prefix = true;
      else
        has_singular_prefix = false;
      break;
    default:
      has_singular_prefix = true;
      break;
  }
  if (entry->object->kind != base_obj->kind) has_singular_prefix = true;
  los = projectable(cave, pgrid, grid, PROJECT_NONE) || loc_eq(grid, pgrid);
  field = los ? OBJECT_LIST_SECTION_LOS : OBJECT_LIST_SECTION_NO_LOS;
  object_desc(
      name, sizeof(name), base_obj,
      ODESC_PREFIX | ODESC_FULL | ODESC_ALTNUM | (entry->count[field] << 16),
      player);
  if (!has_singular_prefix && entry->count[field] == 1) {
    chunk = " ";
    source = name;
  } else {
    chunk = strtok(name, " ");
    source = NULL;
  }
  strnfmt(line_buffer, size, "%3.3s ", chunk);
  chunk = strtok(source, "\0");
  my_strcat(line_buffer, chunk, size);
}
STATIC_OVL void
alloc_init_objects(void)
{
  int i;
  struct allocation* allocation;
  struct object_kind* kind;
  struct alloc_entry* table;
  int16_t* num = mem_zalloc(z_info->max_depth * sizeof(int16_t));
  int16_t* already_counted = mem_zalloc(z_info->max_depth * sizeof(int16_t));
  alloc_kind_size = 0;
  for (i = 1; i < z_info->k_max - 1; i++) {
    kind = &k_info[i];
    allocation = kind->alloc;
    while (allocation) {
      alloc_kind_size++;
      num[allocation->locale]++;
      allocation = allocation->next;
    }
  }
  for (i = 1; i < z_info->max_depth; i++) {
    num[i] += num[i - 1];
  }
  alloc_kind_table =
      mem_zalloc_alt(alloc_kind_size * sizeof(struct alloc_entry));
  table = alloc_kind_table;
  for (i = 1; i < z_info->k_max - 1; i++) {
    kind = &k_info[i];
    allocation = kind->alloc;
    while (allocation) {
      int p, lev, prev_lev_count, kind_index;
      lev = allocation->locale;
      p = allocation->chance ? (100 / allocation->chance) : 0;
      prev_lev_count = (lev > 0) ? num[lev - 1] : 0;
      kind_index = prev_lev_count + already_counted[lev];
      table[kind_index].index = i;
      table[kind_index].level = lev;
      table[kind_index].prob1 = p;
      table[kind_index].prob2 = p;
      table[kind_index].prob3 = p;
      already_counted[lev]++;
      allocation = allocation->next;
    }
  }
  mem_free(already_counted);
  mem_free(num);
}
STATIC_OVL void
alloc_init_egos(void)
{
  int* num = mem_zalloc((z_info->max_obj_depth + 1) * sizeof(int));
  int* level_total = mem_zalloc((z_info->max_obj_depth + 1) * sizeof(int));
  int i;
  for (i = 0; i < z_info->e_max; i++) {
    struct ego_item* ego = &e_info[i];
    if (ego->rarity) {
      alloc_ego_size++;
      num[ego->level]++;
    }
  }
  for (i = 1; i < z_info->max_obj_depth; i++) num[i] += num[i - 1];
  alloc_ego_table = mem_zalloc(alloc_ego_size * sizeof(struct alloc_entry));
  for (i = 0; i < z_info->e_max; i++) {
    struct ego_item* ego = &e_info[i];
    if (ego->rarity) {
      int min_level = ego->level;
      int y = (min_level > 0) ? num[min_level - 1] : 0;
      int z = y + level_total[min_level];
      alloc_ego_table[z].index = i;
      alloc_ego_table[z].level = min_level;
      alloc_ego_table[z].prob1 = ego->rarity;
      alloc_ego_table[z].prob2 = ego->rarity;
      alloc_ego_table[z].prob3 = ego->rarity;
      level_total[min_level]++;
    }
  }
  mem_free(level_total);
  mem_free(num);
}
STATIC_OVL void
init_obj_make(void)
{
  alloc_init_objects();
  alloc_init_egos();
}
STATIC_OVL void
cleanup_obj_make(void)
{
  mem_free(alloc_ego_table);
  mem_free_alt(alloc_kind_table);
}
STATIC_OVL struct ego_item*
ego_find_random(struct object* obj, int level, bool only_good)
{
  int i;
  long total = 0L;
  struct alloc_entry* table = alloc_ego_table;
  for (i = 0; i < alloc_ego_size; i++) {
    struct ego_item* ego = &e_info[table[i].index];
    struct poss_item* poss;
    table[i].prob3 = 0;
    if (table[i].level > level) continue;
    if ((ego->alloc_max > 0) && (player->depth > ego->alloc_max)) continue;
    if (only_good && of_has(ego->flags, OF_CURSED)) continue;
    if (only_good && (ego->cost == 0)) continue;
    for (poss = ego->poss_items; poss; poss = poss->next)
      if (poss->kidx == obj->kind->kidx) {
        table[i].prob3 = table[i].prob2;
        break;
      }
    total += table[i].prob3;
  }
  if (total) {
    long value = randint0(total);
    for (i = 0; i < alloc_ego_size; i++) {
      if (value < table[i].prob3) {
        return &e_info[table[i].index];
      } else {
        value = value - table[i].prob3;
      }
    }
  }
  return NULL;
}
STATIC_OVL void
ego_apply_magic(struct object* obj, bool smithing)
{
  int i;
  struct ego_item* ego = obj->ego;
  struct ability* ability = ego->abilities;
  while (ability) {
    add_ability(&obj->abilities, ability);
    ability = ability->next;
  }
  if (smithing) {
    bool flip_sign;
    if (ego->att) obj->att += 1;
    if (ego->evn) obj->evn += 1;
    if (ego->dd) obj->dd += 1;
    if (ego->ds) obj->ds += 1;
    if (ego->pd) obj->pd += 1;
    if (ego->ps) obj->ps += 1;
    obj->pval = extract_kind_pval(obj->kind, AVERAGE, &flip_sign);
    if (ego->pval > 0) {
      obj->pval += (of_has(ego->flags, OF_CURSED)) ? -1 : 1;
    }
    for (i = 0; i < OBJ_MOD_MAX; i++) {
      int min_m = randcalc(obj->kind->modifiers[i], 0, MINIMISE);
      int max_m =
          randcalc(obj->kind->modifiers[i], z_info->dun_depth, MAXIMISE);
      if (min_m == SPECIAL_VALUE) {
        min_m = randcalc(obj->kind->special1, 0, MINIMISE);
        if (!min_m && obj->kind->special2) {
          min_m = obj->kind->special2;
        }
      }
      if (max_m == SPECIAL_VALUE) {
        max_m = randcalc(obj->kind->special1, z_info->dun_depth, MAXIMISE);
        if (!max_m && obj->kind->special2) {
          max_m = obj->kind->special2;
        }
      }
      if (min_m || max_m) {
        if (min_m >= 0) {
          obj->modifiers[i] = MAX(1, obj->pval);
        } else if (max_m > 0) {
          if (obj->pval) {
            obj->modifiers[i] = (max_m >= -min_m) ? obj->pval : -obj->pval;
          } else {
            obj->modifiers[i] = (max_m >= -min_m) ? 1 : -1;
          }
        } else {
          obj->modifiers[i] = MIN(-1, -obj->pval);
        }
        if (flip_sign) {
          obj->modifiers[i] *= -1;
        }
      } else if (ego->modifiers[i]) {
        obj->modifiers[i] =
            (ego->modifiers[i] > 0) ? MAX(1, obj->pval) : MIN(-1, -obj->pval);
        if (flip_sign) {
          obj->modifiers[i] *= -1;
        }
      }
    }
  } else {
    if (ego->att) obj->att += randint1(ego->att);
    if (ego->evn) obj->evn += randint1(ego->evn);
    if (ego->dd) obj->dd += randint1(ego->dd);
    if (ego->ds) obj->ds += randint1(ego->ds);
    if (ego->pd) obj->pd += randint1(ego->pd);
    if (ego->ps) obj->ps += randint1(ego->ps);
    if (ego->pval > 0) {
      bool flip_sign;
      int pval = extract_kind_pval(obj->kind, AVERAGE, &flip_sign);
      if (of_has(ego->flags, OF_CURSED)) {
        pval -= randint1(ego->pval);
      } else {
        pval += randint1(ego->pval);
      }
      for (i = 0; i < OBJ_MOD_MAX; i++) {
        int min_m = randcalc(obj->kind->modifiers[i], 0, MINIMISE);
        int max_m =
            randcalc(obj->kind->modifiers[i], z_info->dun_depth, MAXIMISE);
        if (min_m == SPECIAL_VALUE) {
          min_m = randcalc(obj->kind->special1, 0, MINIMISE);
          if (!min_m && obj->kind->special2) {
            min_m = obj->kind->special2;
          }
        }
        if (max_m == SPECIAL_VALUE) {
          max_m = randcalc(obj->kind->special1, z_info->dun_depth, MAXIMISE);
          if (!max_m && obj->kind->special2) {
            max_m = obj->kind->special2;
          }
        }
        if (min_m || max_m) {
          if (min_m >= 0) {
            obj->modifiers[i] = pval;
          } else if (max_m > 0) {
            obj->modifiers[i] = (max_m >= -min_m) ? pval : -pval;
          } else {
            obj->modifiers[i] = -pval;
          }
          if (flip_sign) {
            obj->modifiers[i] *= -1;
          }
        } else if (ego->modifiers[i]) {
          obj->modifiers[i] = (ego->modifiers[i] > 0) ? pval : -pval;
          if (flip_sign) {
            obj->modifiers[i] *= -1;
          }
        }
      }
    }
  }
  of_union(obj->flags, ego->flags);
  copy_slays(&obj->slays, ego->slays);
  copy_brands(&obj->brands, ego->brands);
  for (i = 0; i < ELEM_MAX; i++) {
    if (ego->el_info[i].res_level != 0) {
      obj->el_info[i].res_level = ego->el_info[i].res_level;
    }
    obj->el_info[i].flags |= ego->el_info[i].flags;
  }
}
STATIC_OVL bool
make_special_item(struct object* obj, int level, bool only_good)
{
  if (obj->artifact || obj->ego) return false;
  if (level > 0 && one_in_(z_info->great_ego)) {
    if (level < z_info->dun_depth) {
      int level1 = rand_range(level + 1, z_info->dun_depth);
      int level2 = rand_range(level + 1, z_info->dun_depth);
      level = MIN(level1, level2);
    } else {
      level++;
    }
    if (level >= z_info->max_obj_depth) level = z_info->max_obj_depth - 1;
  }
  obj->ego = ego_find_random(obj, level, only_good);
  if (obj->ego) {
    ego_apply_magic(obj, false);
    return true;
  }
  return false;
}
STATIC_OVL void
copy_artifact_data(struct object* obj, const struct artifact* art)
{
  int i;
  struct ability* ability = art->abilities;
  for (i = 0; i < OBJ_MOD_MAX; i++) obj->modifiers[i] = art->modifiers[i];
  obj->att = art->att;
  obj->dd = art->dd;
  obj->ds = art->ds;
  obj->evn = art->evn;
  obj->pd = art->pd;
  obj->ps = art->ps;
  obj->weight = art->weight;
  obj->pval = art->pval;
  while (ability) {
    add_ability(&obj->abilities, ability);
    ability = ability->next;
  }
  of_union(obj->flags, art->flags);
  copy_slays(&obj->slays, art->slays);
  copy_brands(&obj->brands, art->brands);
  for (i = 0; i < ELEM_MAX; i++) {
    if (art->el_info[i].res_level != 0) {
      obj->el_info[i].res_level = art->el_info[i].res_level;
    }
    obj->el_info[i].flags |= art->el_info[i].flags;
  }
}
STATIC_OVL bool
too_many_artefacts(void)
{
  int i;
  for (i = 0; i < player->num_artefacts; i++) {
    if (percent_chance(10)) return true;
  }
  return false;
}
STATIC_OVL struct object*
make_artifact_special(int level)
{
  int i;
  struct object* new_obj;
  if (OPT(player, birth_no_artifacts)) return NULL;
  if (too_many_artefacts()) return NULL;
  for (i = 0; i < z_info->a_max; ++i) {
    const struct artifact* art = &a_info[i];
    struct object_kind* kind = lookup_kind(art->tval, art->sval);
    if (!art->name) continue;
    if (!kind) continue;
    if (!kf_has(kind->kind_flags, KF_INSTA_ART)) continue;
    if (of_has(art->flags, OF_NO_RANDOM)) continue;
    if (is_artifact_created(art)) continue;
    if (art->level > level) {
      int d = (art->level - level) * 2;
      if (randint0(d) != 0) continue;
    }
    if (!one_in_(art->rarity)) continue;
    new_obj = object_new();
    object_prep(new_obj, kind, art->level, RANDOMISE);
    new_obj->artifact = art;
    copy_artifact_data(new_obj, art);
    mark_artifact_created(art, true);
    return new_obj;
  }
  return NULL;
}
STATIC_OVL bool
make_artifact(struct object* obj, int lev)
{
  int i;
  if (OPT(player, birth_no_artifacts)) return false;
  if (too_many_artefacts()) return false;
  for (i = 0; !obj->artifact && i < z_info->a_max; i++) {
    const struct artifact* art = &a_info[i];
    struct object_kind* kind = lookup_kind(art->tval, art->sval);
    if (!art->name) continue;
    if (!kind) continue;
    if (kf_has(kind->kind_flags, KF_INSTA_ART)) continue;
    if (of_has(art->flags, OF_NO_RANDOM)) continue;
    if (is_artifact_created(art)) continue;
    if (art->tval != obj->tval) continue;
    if (art->sval != obj->sval) continue;
    if (art->level > lev) {
      int d = (art->level - lev) * 2;
      if (randint0(d) != 0) continue;
    }
    if (!one_in_(art->rarity)) continue;
    obj->artifact = art;
    obj->number = 1;
  }
  if (obj->artifact) {
    copy_artifact_data(obj, obj->artifact);
    mark_artifact_created(obj->artifact, true);
    return true;
  }
  return false;
}
STATIC_OVL bool
make_fake_artifact(struct object* obj, const struct artifact* artifact)
{
  struct object_kind* kind;
  if (!artifact->tval) return false;
  kind = lookup_kind(artifact->tval, artifact->sval);
  if (!kind) return false;
  object_prep(obj, kind, 0, MAXIMISE);
  obj->artifact = artifact;
  copy_artifact_data(obj, artifact);
  return (true);
}
STATIC_OVL void
apply_magic_weapon(struct object* obj, int level)
{
  bool boost_dam = false;
  bool boost_att = false;
  if (tval_is_ammo(obj)) {
    obj->att += 3;
    return;
  } else {
    if (percent_chance(level)) {
      boost_dam = true;
      boost_att = true;
    } else if (one_in_(2)) {
      boost_dam = true;
    } else {
      boost_att = true;
    }
  }
  if (boost_dam) {
    obj->ds++;
  }
  if (boost_att) {
    obj->att++;
  }
}
STATIC_OVL void
apply_magic_armour(struct object* obj, int level)
{
  bool boost_prot = false;
  bool boost_other = false;
  if (tval_is_cloak(obj) ||
      (tval_is_body_armor(obj) &&
       (obj->sval == lookup_sval(TV_SOFT_ARMOR, "Robe") ||
        obj->sval == lookup_sval(TV_SOFT_ARMOR, "Filthy Rag")))) {
    boost_other = true;
  } else if ((obj->att >= 0) && (obj->evn >= 0)) {
    boost_prot = true;
  } else {
    if (percent_chance(level)) {
      boost_prot = true;
      boost_other = true;
    } else if (one_in_(2)) {
      boost_prot = true;
    } else {
      boost_other = true;
    }
  }
  if (boost_other) {
    if ((obj->att < 0) && (obj->evn < 0)) {
      if (one_in_(2))
        obj->evn++;
      else
        obj->att++;
    } else if (obj->att < 0) {
      obj->att++;
    } else {
      obj->evn++;
    }
  }
  if (boost_prot) {
    obj->ps++;
  }
}
STATIC_OVL void
apply_magic(struct object* obj, int lev, bool allow_artifacts, bool good,
            bool great)
{
  int i;
  bool fine = false;
  bool special = false;
  lev = MIN(lev, z_info->max_depth - 1);
  if (percent_chance(lev * 2)) fine = true;
  if (percent_chance(lev * 2)) special = true;
  if (good) {
    if (one_in_(2)) {
      fine = true;
    } else {
      special = true;
    }
  }
  if (great) {
    fine = true;
    special = true;
  }
  if (allow_artifacts) {
    int rolls = 0;
    if (special) rolls = 2;
    if (good && great) rolls = 8;
    for (i = 0; i < rolls; i++) {
      if (make_artifact(obj, lev)) return;
    }
  }
  if (tval_is_held_weapon(obj)) {
    int sval = lookup_sval(TV_SWORD, "Deathblade");
    if (obj->kind == lookup_kind(TV_SWORD, sval)) {
      while (one_in_(2)) obj->att++;
    } else {
      if (special && !make_special_item(obj, lev, good || great)) {
        fine = true;
      }
      if (fine) {
        apply_magic_weapon(obj, lev);
      }
      if (of_has(obj->flags, OF_THROWING)) {
        obj->weight = obj->kind->weight;
        if (one_in_(2)) {
          obj->number = rand_range(2, 5);
        }
      }
    }
  } else if (tval_is_ammo(obj)) {
    if (special) {
      (void)make_special_item(obj, lev, good || great);
      if (obj->number > 1) obj->number /= 2;
    } else if (fine) {
      apply_magic_weapon(obj, lev);
      if (obj->number > 1) obj->number /= 2;
    }
  } else if (tval_is_armor(obj)) {
    if (special && !make_special_item(obj, lev, good || great)) {
      fine = true;
    }
    if (fine) {
      apply_magic_armour(obj, lev);
    }
  } else if (tval_is_jewelry(obj)) {
    if ((obj->att < 0) || (obj->evn < 0)) {
      of_on(obj->flags, OF_CURSED);
    }
    for (i = 0; i < OBJ_MOD_MAX; i++) {
      if (obj->modifiers[i] < 0) {
        of_on(obj->flags, OF_CURSED);
      }
    }
  } else if (tval_is_light(obj)) {
    if (special) {
      (void)make_special_item(obj, lev, good || great);
    }
  } else if (tval_is_chest(obj)) {
    obj->pval = lev;
    if (fine) obj->pval += 2;
    if (special) obj->pval += 2;
    obj->pval = MAX(1, MIN(obj->pval, 25));
  }
}
STATIC_OVL int
eval_special_value(struct object_kind* kind, int lev)
{
  int val = randcalc(kind->special1, lev, RANDOMISE);
  if (!val && (kind->special2 != 0)) {
    val = kind->special2;
  }
  return val;
}
STATIC_OVL void
object_prep(struct object* obj, struct object_kind* k, int lev,
            aspect rand_aspect)
{
  int i;
  struct ability* ability = k->abilities;
  memset(obj, 0, sizeof(*obj));
  obj->kind = k;
  obj->image_kind = &k_info[randint0(z_info->k_max)];
  obj->tval = k->tval;
  obj->sval = k->sval;
  if (k->att == SPECIAL_VALUE) {
    obj->att = eval_special_value(k, lev);
  } else {
    obj->att = k->att;
  }
  obj->dd = k->dd;
  obj->ds = k->ds;
  if (k->evn == SPECIAL_VALUE) {
    obj->evn = eval_special_value(k, lev);
  } else {
    obj->evn = k->evn;
  }
  obj->pd = k->pd;
  if (k->ps == SPECIAL_VALUE) {
    obj->ps = eval_special_value(k, lev);
  } else {
    obj->ps = k->ps;
  }
  if ((tval_is_weapon(obj) || tval_is_armor(obj)) && !tval_is_ammo(obj)) {
    obj->weight = k->weight;
    switch (rand_aspect) {
      case EXTREMIFY:
      case MINIMISE: {
        while (obj->weight * 2 > k->weight * 3) obj->weight -= 5;
        break;
      }
      case AVERAGE: {
        break;
      }
      case MAXIMISE: {
        while (obj->weight * 3 < k->weight * 2) obj->weight += 5;
        break;
      }
      case RANDOMISE: {
        obj->weight = Rand_normal(k->weight, k->weight / 6 + 1);
        obj->weight = (obj->weight * 2 + 9) / 10;
        obj->weight *= 5;
        while (obj->weight * 3 < k->weight * 2) obj->weight += 5;
        while (obj->weight * 2 > k->weight * 3) obj->weight -= 5;
        break;
      }
      default: {
        obj->weight = k->weight;
      }
    }
  } else {
    obj->weight = k->weight;
  }
  obj->number = 1;
  of_copy(obj->flags, k->base->flags);
  of_copy(obj->flags, k->flags);
  if (tval_can_have_charges(obj))
    obj->pval = randcalc(k->charge, lev, rand_aspect);
  if (tval_is_light(obj)) {
    if (of_has(obj->flags, OF_BURNS_OUT)) {
      if (one_in_(3) && character_generated) {
        obj->timeout = rand_range(500, z_info->default_torch);
      } else {
        obj->timeout = z_info->default_torch;
      }
    } else if (of_has(obj->flags, OF_TAKES_FUEL)) {
      if (one_in_(3)) {
        obj->timeout = rand_range(500, z_info->default_lamp);
      } else {
        obj->timeout = z_info->default_lamp;
      }
    }
    obj->pval = k->pval;
  }
  if (tval_is_fuel(obj)) obj->pval = k->pval;
  for (i = 0; i < OBJ_MOD_MAX; i++) {
    obj->modifiers[i] = randcalc(k->modifiers[i], lev, rand_aspect);
    if (obj->modifiers[i] == SPECIAL_VALUE) {
      obj->modifiers[i] = eval_special_value(k, lev);
    }
  }
  copy_slays(&obj->slays, k->slays);
  copy_brands(&obj->brands, k->brands);
  for (i = 0; i < ELEM_MAX; i++) {
    obj->el_info[i].res_level = k->el_info[i].res_level;
    obj->el_info[i].flags = k->el_info[i].flags;
    obj->el_info[i].flags |= k->base->el_info[i].flags;
  }
  while (ability) {
    add_ability(&obj->abilities, ability);
    ability = ability->next;
  }
}
STATIC_OVL struct drop*
lookup_drop(const char* name)
{
  int i;
  for (i = 0; i < z_info->drop_max; i++) {
    struct drop* drop = &drops[i];
    if (streq(name, drop->name)) return drop;
  }
  return NULL;
}
STATIC_OVL bool
drop_is(struct drop* drop, const char* name)
{
  return streq(name, drop->name);
}
STATIC_OVL void
get_obj_num_prep(struct drop* drop)
{
  int i;
  for (i = 0; i < alloc_kind_size; i++) {
    struct alloc_entry* entry = &alloc_kind_table[i];
    if (drop) {
      struct poss_item* item;
      if (drop->poss) {
        entry->prob2 = 0;
        item = drop->poss;
        while (item) {
          if ((int)item->kidx == entry->index) {
            entry->prob2 = entry->prob1;
            break;
          }
          item = item->next;
        }
      } else if (drop->imposs) {
        entry->prob2 = entry->prob1;
        item = drop->imposs;
        while (item) {
          if ((int)item->kidx == entry->index) {
            entry->prob2 = 0;
            break;
          }
          item = item->next;
        }
      } else {
        quit("Invalid object drop type!");
      }
    } else {
      entry->prob2 = entry->prob1;
    }
  }
}
STATIC_OVL struct object_kind*
get_obj_num(int level)
{
  int i, j, p;
  long total = 0, value;
  struct alloc_entry* table = alloc_kind_table;
  if ((level > 0) && one_in_(z_info->great_obj)) {
    if (level < z_info->max_depth) {
      int x = rand_range(level + 1, z_info->max_depth);
      int y = rand_range(level + 1, z_info->max_depth);
      level = MIN(x, y);
    } else {
      level++;
    }
  }
  level = MIN(level, z_info->max_obj_depth);
  level = MAX(level, 0);
  for (i = 0; i < alloc_kind_size; i++) {
    if (table[i].level > level) break;
    table[i].prob3 = 0;
    table[i].prob3 = table[i].prob2;
    total += table[i].prob3;
  }
  if (total <= 0) return NULL;
  value = randint0(total);
  for (i = 0; i < alloc_kind_size; i++) {
    if (value < table[i].prob3) break;
    value = value - table[i].prob3;
  }
  p = randint0(100);
  if (p < 60) {
    j = i;
    value = randint0(total);
    for (i = 0; i < alloc_kind_size; i++) {
      if (value < table[i].prob3) break;
      value = value - table[i].prob3;
    }
    if (table[i].level < table[j].level) i = j;
  }
  if (p < 10) {
    j = i;
    value = randint0(total);
    for (i = 0; i < alloc_kind_size; i++) {
      if (value < table[i].prob3) break;
      value = value - table[i].prob3;
    }
    if (table[i].level < table[j].level) i = j;
  }
  return &k_info[table[i].index];
}
STATIC_OVL struct object*
make_object(struct chunk* c, int lev, bool good, bool great, struct drop* drop)
{
  struct object_kind* kind = NULL;
  struct object* new_obj;
  int base = good || great ? lev + 3 : lev;
  int prob = ((good || great) ? 10 : 1000);
  if (drop && drop_is(drop, "jewellery")) prob /= 2;
  if (one_in_(prob)) {
    new_obj = make_artifact_special(lev);
    if (new_obj) return new_obj;
  }
  if (drop) {
    get_obj_num_prep(drop);
  } else if (great) {
    get_obj_num_prep(lookup_drop("great"));
  } else if (good) {
    get_obj_num_prep(lookup_drop("good"));
  }
  kind = get_obj_num(base);
  if (drop || good || great) {
    get_obj_num_prep(NULL);
  }
  if (!kind) return NULL;
  new_obj = object_new();
  object_prep(new_obj, kind, lev, RANDOMISE);
  if (tval_is_ammo(new_obj)) {
    if (one_in_(3)) {
      new_obj->number = damroll(4, 6);
    } else {
      new_obj->number = 12;
      if (one_in_(2)) {
        new_obj->number += 12;
        if (one_in_(3)) {
          new_obj->number += 12;
        }
      }
    }
  } else if (tval_is_metal(new_obj)) {
    new_obj->number = damroll(2, 40);
  }
  apply_magic(new_obj, lev, true, good, great);
  return new_obj;
}
STATIC_OVL int
extract_kind_pval(const struct object_kind* kind, aspect rand_aspect,
                  bool* flip_sign_out)
{
  int pval_l = 0, pval_s = 0, pval_h = 0, i;
  bool all_zero = true, all_mixed_signs = true, all_negative = true,
       all_mixed_more_neg = true, flip_sign;
  for (i = 0; i < OBJ_MOD_MAX; ++i) {
    int min_m = randcalc(kind->modifiers[i], 0, MINIMISE);
    int max_m = randcalc(kind->modifiers[i], z_info->dun_depth, MAXIMISE);
    if (min_m == SPECIAL_VALUE) {
      min_m = randcalc(kind->special1, 0, MINIMISE);
      if (!min_m && kind->special2) {
        min_m = kind->special2;
      }
    }
    if (max_m == SPECIAL_VALUE) {
      max_m = randcalc(kind->special1, z_info->dun_depth, MAXIMISE);
      if (!max_m && kind->special2) {
        max_m = kind->special2;
      }
    }
    if (min_m || max_m) {
      int this_l, this_s, this_h;
      assert(max_m >= min_m);
      if (min_m >= 0) {
        all_negative = false;
        all_mixed_signs = false;
        this_l = min_m;
        this_s = MAX(1, min_m);
        this_h = max_m;
      } else if (max_m > 0) {
        all_negative = false;
        this_s = 1;
        if (max_m >= -min_m) {
          all_mixed_more_neg = false;
          this_l = min_m;
          this_h = max_m;
        } else {
          this_l = -max_m;
          this_h = -min_m;
        }
      } else {
        all_mixed_signs = false;
        this_l = -max_m;
        this_s = MAX(1, -max_m);
        this_h = -min_m;
      }
      if (all_zero) {
        all_zero = false;
        pval_l = this_l;
        pval_s = this_s;
        pval_h = this_h;
      } else {
        if (all_mixed_signs) {
          assert(pval_s == 1 && this_s == 1);
          if (pval_h != this_h || pval_l != this_l) {
            if (pval_h > this_h) {
              pval_h = this_h;
            }
            if (pval_l < this_l) {
              pval_l = this_l;
            }
          }
        } else {
          if (pval_h > this_h) {
            pval_h = this_h;
          }
          if (pval_s > this_s) {
            pval_s = this_s;
          }
          if (this_l >= 0 && pval_l > this_l) {
            pval_l = this_l;
          }
        }
      }
    }
  }
  flip_sign =
      !all_zero && (all_negative || (all_mixed_signs && all_mixed_more_neg));
  if (flip_sign_out) {
    *flip_sign_out = flip_sign;
  }
  if (rand_aspect == MINIMISE) {
    return (flip_sign) ? -pval_h : pval_l;
  }
  if (rand_aspect == MAXIMISE) {
    return (flip_sign) ? -pval_l : pval_h;
  }
  return (flip_sign) ? -pval_s : pval_s;
}
STATIC_OVL void
write_pile(ang_file* fff)
{
  file_putf(fff, "Pile integrity failure at %s:%d\n\n", fail_file, fail_line);
  file_putf(fff, "Guilty object\n=============\n");
  if (fail_object && fail_object->kind) {
    file_putf(fff, "Name: %s\n", fail_object->kind->name);
    if (fail_prev) {
      file_putf(fff, "Previous: ");
      if (fail_object->prev && fail_object->prev->kind) {
        file_putf(fff, "%s\n", fail_object->prev->kind->name);
      } else {
        file_putf(fff, "bad object\n");
      }
    }
    if (fail_next) {
      file_putf(fff, "Next: ");
      if (fail_object->next && fail_object->next->kind) {
        file_putf(fff, "%s\n", fail_object->next->kind->name);
      } else {
        file_putf(fff, "bad object\n");
      }
    }
    file_putf(fff, "\n");
  }
  if (fail_pile) {
    file_putf(fff, "Guilty pile\n=============\n");
    while (fail_pile) {
      if (fail_pile->kind) {
        file_putf(fff, "Name: %s\n", fail_pile->kind->name);
      } else {
        file_putf(fff, "bad object\n");
      }
      fail_pile = fail_pile->next;
    }
  }
}
STATIC_OVL void
pile_integrity_fail(struct object* pile, struct object* obj, const char* file,
                    int line)
{
  char path[1024];
  fail_pile = pile;
  fail_object = obj;
  fail_prev = (obj->prev != NULL);
  fail_next = (obj->next != NULL);
  fail_file = file;
  fail_line = line;
  path_build(path, sizeof(path), ANGBAND_DIR_USER, "pile_error.txt");
  if (text_lines_to_file(path, write_pile)) {
    quit_fmt("Failed to create file %s.new", path);
  }
  quit_fmt("Pile integrity failure, details written to %s", path);
}
STATIC_OVL void
pile_check_integrity(const char* op, struct object* pile,
                     struct object* hilight)
{
  struct object* obj = pile;
  struct object* prev = NULL;
  while (obj) {
    if (obj->prev != prev) {
      pile_integrity_fail(pile, obj, "<stdin>", 53618);
    }
    prev = obj;
    obj = obj->next;
  };
  for (obj = pile; obj; obj = obj->next) {
    struct object* check;
    for (check = obj->next; check; check = check->next) {
      if (check->next == obj) {
        pile_integrity_fail(pile, check, "<stdin>", 53629);
      }
    }
  }
}
STATIC_OVL void
pile_insert(struct object** pile, struct object* obj)
{
  if (obj->prev || obj->next) {
    pile_integrity_fail(NULL, obj, "<stdin>", 53643);
  }
  if (*pile) {
    obj->next = *pile;
    (*pile)->prev = obj;
  }
  *pile = obj;
  pile_check_integrity("insert", *pile, obj);
}
STATIC_OVL void
pile_insert_end(struct object** pile, struct object* obj)
{
  if (obj->prev) {
    pile_integrity_fail(NULL, obj, "<stdin>", 53664);
  }
  if (*pile) {
    struct object* end = pile_last_item(*pile);
    end->next = obj;
    obj->prev = end;
  } else {
    *pile = obj;
  }
  pile_check_integrity("insert_end", *pile, obj);
}
STATIC_OVL void
pile_excise(struct object** pile, struct object* obj)
{
  struct object* prev = obj->prev;
  struct object* next = obj->next;
  if (!pile_contains(*pile, obj)) {
    pile_integrity_fail(*pile, obj, "<stdin>", 53688);
  }
  pile_check_integrity("excise [pre]", *pile, obj);
  if (*pile == obj) {
    if (prev) {
      pile_integrity_fail(*pile, obj, "<stdin>", 53695);
    }
    *pile = next;
  } else {
    if (obj->prev == NULL) {
      pile_integrity_fail(*pile, obj, "<stdin>", 53701);
    }
    prev->next = next;
    obj->prev = NULL;
  }
  if (next) {
    next->prev = prev;
    obj->next = NULL;
  }
  pile_check_integrity("excise [post]", *pile, NULL);
}
STATIC_OVL struct object*
pile_last_item(struct object* const pile)
{
  struct object* obj = pile;
  pile_check_integrity("last_item", pile, NULL);
  if (!pile) return NULL;
  while (obj->next) obj = obj->next;
  return obj;
}
STATIC_OVL bool
pile_contains(const struct object* top, const struct object* obj)
{
  const struct object* pile_obj = top;
  while (pile_obj) {
    if (obj == pile_obj) return true;
    pile_obj = pile_obj->next;
  }
  return false;
}
STATIC_OVL struct object*
object_new(void)
{
  return mem_zalloc(sizeof(struct object));
}
STATIC_OVL void
object_free(struct object* obj)
{
  mem_free(obj->slays);
  mem_free(obj->brands);
  release_ability_list(obj->abilities);
  mem_free(obj);
}
STATIC_OVL void
object_delete(struct chunk* c, struct chunk* p_c, struct object** obj_address)
{
  struct object* obj = *obj_address;
  struct object* prev = obj->prev;
  struct object* next = obj->next;
  if (next) {
    if (prev) {
      prev->next = next;
      next->prev = prev;
    } else {
      next->prev = NULL;
    }
  } else if (prev) {
    prev->next = NULL;
  }
  if (player && player->upkeep && obj == player->upkeep->object)
    player->upkeep->object = NULL;
  if (c && p_c && obj->oidx && (obj == c->objects[obj->oidx]) &&
      p_c->objects[obj->oidx]) {
    obj->grid = loc(0, 0);
    obj->prev = NULL;
    obj->next = NULL;
    obj->held_m_idx = 0;
    obj->known->notice |= OBJ_NOTICE_IMAGINED;
    return;
  }
  if (p_c && p_c->objects && obj->oidx && (obj == p_c->objects[obj->oidx]))
    p_c->objects[obj->oidx] = NULL;
  if (c && c->objects && obj->oidx && (obj == c->objects[obj->oidx]))
    c->objects[obj->oidx] = NULL;
  object_free(obj);
  *obj_address = NULL;
}
STATIC_OVL void
object_pile_free(struct chunk* c, struct chunk* p_c, struct object* obj)
{
  struct object *current = obj, *next;
  while (current) {
    next = current->next;
    object_delete(c, p_c, &current);
    current = next;
  }
}
STATIC_OVL bool
object_similar(const struct object* obj1, const struct object* obj2,
               object_stack_t mode)
{
  int i;
  if (object_is_equipped(player->body, obj1)) return false;
  if (object_is_equipped(player->body, obj2)) return false;
  if (mode & OSTACK_LIST && obj1->kind != obj1->known->kind) return false;
  if (mode & OSTACK_LIST && obj2->kind != obj2->known->kind) return false;
  if (obj1 == obj2) return false;
  if (obj1->kind != obj2->kind) return false;
  if (!of_is_equal(obj1->flags, obj2->flags)) return false;
  for (i = 0; i < ELEM_MAX; i++) {
    if (obj1->el_info[i].res_level != obj2->el_info[i].res_level) return false;
    if ((obj1->el_info[i].flags & (EL_INFO_HATES | EL_INFO_IGNORE)) !=
        (obj2->el_info[i].flags & (EL_INFO_HATES | EL_INFO_IGNORE)))
      return false;
  }
  if (obj1->artifact || obj2->artifact) return false;
  if (tval_is_chest(obj1) || tval_is_note(obj1)) {
    return false;
  } else if (tval_is_edible(obj1) || tval_is_potion(obj1) ||
             tval_is_horn(obj1)) {
  } else if (tval_can_have_charges(obj1)) {
    return false;
  } else if (tval_is_weapon(obj1) || tval_is_armor(obj1) ||
             tval_is_jewelry(obj1) || tval_is_light(obj1)) {
    bool obj1_is_known = object_runes_known(obj1);
    bool obj2_is_known = object_runes_known(obj2);
    if (obj1->weight != obj2->weight) return false;
    if (obj1->att != obj2->att) return false;
    if (obj1->dd != obj2->dd) return false;
    if (obj1->ds != obj2->ds) return false;
    if (obj1->evn != obj2->evn) return false;
    if (obj1->pd != obj2->pd) return false;
    if (obj1->ps != obj2->ps) return false;
    for (i = 0; i < OBJ_MOD_MAX; i++)
      if (obj1->modifiers[i] != obj2->modifiers[i]) return (false);
    if (obj1->ego != obj2->ego) return false;
    if ((obj1->timeout || obj2->timeout) && !tval_is_light(obj1))
      return false;
    else if ((obj1->timeout != obj2->timeout) && tval_is_light(obj1))
      return false;
    if (mode & OSTACK_LIST && (obj1_is_known != obj2_is_known)) return false;
  } else {
  }
  return true;
}
STATIC_OVL bool
object_stackable(const struct object* obj1, const struct object* obj2,
                 object_stack_t mode)
{
  if (object_similar(obj1, obj2, mode)) {
    return !obj1->note || !obj2->note || obj1->note == obj2->note;
  }
  return false;
}
STATIC_OVL bool
object_mergeable(const struct object* obj1, const struct object* obj2,
                 object_stack_t mode)
{
  int total = obj1->number + obj2->number;
  if (total > obj1->kind->base->max_stack) {
    return false;
  }
  return object_stackable(obj1, obj2, mode);
}
STATIC_OVL void
object_origin_combine(struct object* obj1, const struct object* obj2)
{
  if (obj1->origin_race != obj2->origin_race) {
    bool uniq1 =
        (obj1->origin_race && rf_has(obj1->origin_race->flags, RF_UNIQUE));
    bool uniq2 =
        (obj2->origin_race && rf_has(obj2->origin_race->flags, RF_UNIQUE));
    if (uniq1 && !uniq2) {
      ;
    } else if (uniq2 && !uniq1) {
      obj1->origin = obj2->origin;
      obj1->origin_depth = obj2->origin_depth;
      obj1->origin_race = obj2->origin_race;
    } else {
      obj1->origin = ORIGIN_MIXED;
    }
  } else if (obj1->origin != obj2->origin ||
             obj1->origin_depth != obj2->origin_depth) {
    obj1->origin = ORIGIN_MIXED;
  }
}
STATIC_OVL void
object_absorb_merge(struct object* obj1, const struct object* obj2)
{
  int total;
  obj1->notice |= obj2->notice;
  if (obj2->note) obj1->note = obj2->note;
  if (tval_can_have_charges(obj1)) {
    total = obj1->pval + obj2->pval;
    obj1->pval = total >= MAX_PVAL ? MAX_PVAL : total;
  }
  object_origin_combine(obj1, obj2);
}
STATIC_OVL void
object_absorb_partial(struct object* obj1, struct object* obj2)
{
  int smallest = MIN(obj1->number, obj2->number);
  int largest = MAX(obj1->number, obj2->number);
  int newsz1, newsz2;
  int difference = obj1->kind->base->max_stack - largest;
  newsz1 = largest + difference;
  newsz2 = smallest - difference;
  obj1->number = newsz1;
  obj2->number = newsz2;
  object_absorb_merge(obj1, obj2);
}
STATIC_OVL void
object_absorb(struct object* obj1, struct object* obj2)
{
  struct object* known = obj2->known;
  int total = obj1->number + obj2->number;
  obj1->number = MIN(total, obj1->kind->base->max_stack);
  object_absorb_merge(obj1, obj2);
  if (known) {
    if (!loc_is_zero(known->grid)) {
      square_excise_object(player->cave, known->grid, known);
    }
    delist_object(player->cave, known);
    object_delete(player->cave, NULL, &known);
  }
  object_delete(cave, player->cave, &obj2);
}
STATIC_OVL void
object_wipe(struct object* obj)
{
  mem_free(obj->slays);
  mem_free(obj->brands);
  release_ability_list(obj->abilities);
  memset(obj, 0, sizeof(*obj));
}
STATIC_OVL void
object_copy(struct object* dest, const struct object* src)
{
  memcpy(dest, src, sizeof(struct object));
  if (src->slays) {
    dest->slays = mem_zalloc(z_info->slay_max * sizeof(bool));
    memcpy(dest->slays, src->slays, z_info->slay_max * sizeof(bool));
  }
  if (src->brands) {
    dest->brands = mem_zalloc(z_info->brand_max * sizeof(bool));
    memcpy(dest->brands, src->brands, z_info->brand_max * sizeof(bool));
  }
  if (src->abilities) {
    dest->abilities = copy_ability_list(src->abilities);
  }
  dest->prev = NULL;
  dest->next = NULL;
}
STATIC_OVL void
object_copy_amt(struct object* dest, struct object* src, int amt)
{
  object_copy(dest, src);
  dest->number = amt;
  dest->note = src->note;
  if (tval_can_have_charges(src)) dest->pval = src->pval * amt / src->number;
}
STATIC_OVL struct object*
object_split(struct object* src, int amt)
{
  struct object *dest = object_new(), *dest_known;
  object_copy(dest, src);
  if (src->known) {
    src->known->number = src->number;
    dest_known = object_new();
    object_copy(dest_known, src->known);
    dest->known = dest_known;
  }
  assert(src->number > amt);
  distribute_charges(src, dest, amt);
  if (src->known) distribute_charges(src->known, dest->known, amt);
  dest->number = amt;
  src->number -= amt;
  if (src->note) dest->note = src->note;
  if (src->known) {
    dest->known->number = dest->number;
    src->known->number = src->number;
    dest->known->note = src->known->note;
  }
  if (dest->known) dest->known->oidx = 0;
  dest->oidx = 0;
  return dest;
}
STATIC_OVL struct object*
floor_object_for_use(struct player* p, struct object* obj, int num,
                     bool message, bool* none_left)
{
  struct object* usable;
  char name[80];
  num = MIN(num, obj->number);
  if (obj->number > num) {
    usable = object_split(obj, num);
  } else {
    usable = obj;
    square_excise_object(p->cave, usable->grid, usable->known);
    delist_object(p->cave, usable->known);
    square_excise_object(cave, usable->grid, usable);
    delist_object(cave, usable);
    *none_left = true;
    if (tracked_object_is(p->upkeep, obj)) track_object(p->upkeep, NULL);
    cmd_disable_repeat();
  }
  usable->known->grid = loc(0, 0);
  usable->grid = loc(0, 0);
  if (message) {
    if (usable == obj) obj->number = 0;
    object_desc(name, sizeof(name), obj, ODESC_PREFIX | ODESC_FULL, p);
    if (usable == obj) obj->number = num;
    msg("You see %s.", name);
  }
  return usable;
}
STATIC_OVL bool
floor_destroy(struct object* obj, int amt)
{
  bool none_left;
  char name[80];
  char out_val[160];
  int num = obj->number;
  struct object* destroyed;
  obj->number = amt;
  object_desc(name, sizeof(name), obj, ODESC_PREFIX | ODESC_FULL, player);
  obj->number = num;
  strnfmt(out_val, sizeof(out_val), "Really destroy %s? ", name);
  if (!get_check(out_val)) {
    return false;
  }
  destroyed = floor_object_for_use(player, obj, amt, true, &none_left);
  msg("You destroy %s.", name);
  if (destroyed->known) {
    struct object* known = destroyed->known;
    if (!loc_is_zero(known->grid))
      square_excise_object(player->cave, known->grid, known);
    delist_object(player->cave, known);
    object_delete(player->cave, NULL, &known);
  }
  delist_object(cave, destroyed);
  object_delete(cave, player->cave, &destroyed);
  return true;
}
STATIC_OVL struct object*
floor_get_oldest_ignored(const struct player* p, struct chunk* c,
                         struct loc grid)
{
  struct object *obj, *ignore = NULL;
  for (obj = square_object(c, grid); obj; obj = obj->next)
    if (ignore_item_ok(p, obj)) ignore = obj;
  return ignore;
}
STATIC_OVL bool
floor_carry(struct chunk* c, struct loc grid, struct object* drop, bool* note)
{
  int n = 0;
  struct object *obj, *ignore = floor_get_oldest_ignored(player, c, grid);
  if (!square_isobjectholding(c, grid)) return false;
  for (obj = square_object(c, grid); obj; obj = obj->next) {
    if (object_mergeable(obj, drop, OSTACK_FLOOR)) {
      object_absorb(obj, drop);
      if (square_isview(c, grid)) {
        square_note_spot(c, grid);
      }
      if (ignore_item_ok(player, obj)) {
        *note = false;
      }
      return true;
    }
    n++;
  }
  if (n >= z_info->floor_size) {
    if (ignore) {
      struct chunk* p_c = (c == cave) ? player->cave : NULL;
      square_excise_object(c, grid, ignore);
      delist_object(c, ignore);
      object_delete(c, p_c, &ignore);
    } else {
      return false;
    }
  }
  drop->grid = grid;
  drop->held_m_idx = 0;
  pile_insert(&c->squares[grid.y][grid.x].obj, drop);
  list_object(c, drop);
  if (drop->known) {
    drop->known->oidx = drop->oidx;
    drop->known->held_m_idx = 0;
    drop->known->grid = loc(0, 0);
    player->cave->objects[drop->oidx] = drop->known;
  }
  square_note_spot(c, grid);
  square_light_spot(c, grid);
  if (ignore_item_ok(player, drop)) {
    *note = false;
  }
  return true;
}
STATIC_OVL void
floor_carry_fail(struct chunk* c, struct object* drop, bool broke)
{
  struct object* known = drop->known;
  if (known) {
    char o_name[80];
    const char* verb =
        broke ? VERB_AGREEMENT(drop->number, "breaks", "break")
              : VERB_AGREEMENT(drop->number, "disappears", "disappear");
    object_desc(o_name, sizeof(o_name), drop, ODESC_BASE, player);
    msg("The %s %s.", o_name, verb);
    if (!loc_is_zero(known->grid))
      square_excise_object(player->cave, known->grid, known);
    delist_object(player->cave, known);
    object_delete(player->cave, NULL, &known);
  }
  delist_object(c, drop);
  object_delete(c, player->cave, &drop);
}
STATIC_OVL void
drop_find_grid(const struct player* p, struct chunk* c, struct object* drop,
               bool prefer_pile, struct loc* grid)
{
  int best_score = -1;
  struct loc start = *grid;
  struct loc best = start;
  int i, dy, dx;
  struct object* obj;
  for (dy = -3; dy <= 3; dy++) {
    for (dx = -3; dx <= 3; dx++) {
      bool combine = false;
      int dist = (dy * dy) + (dx * dx);
      struct loc try = loc_sum(start, loc(dx, dy));
      int num_shown = 0;
      int num_ignored = 0;
      int score;
      if ((dist > 10) || !square_in_bounds_fully(c, try) ||
          !los(c, start, try) || !square_isfloor(c, try) ||
          square_istrap(c, try))
        continue;
      for (obj = square_object(c, try); obj; obj = obj->next) {
        if (object_mergeable(obj, drop, OSTACK_FLOOR)) combine = true;
        if (!ignore_item_ok(p, obj))
          num_shown++;
        else
          num_ignored++;
      }
      if (!combine) num_shown++;
      if ((num_shown + num_ignored) > z_info->floor_size &&
          !floor_get_oldest_ignored(p, c, try))
        continue;
      score = 1000 - (dist + (prefer_pile ? 0 : num_shown * 5));
      if ((score < best_score) || ((score == best_score) && one_in_(2)))
        continue;
      best_score = score;
      best = try;
    }
  }
  if (best_score >= 0) {
    *grid = best;
    return;
  } else if (!drop->artifact) {
    return;
  }
  for (i = 0; i < 2000; i++) {
    if (i < 1000) {
      best = rand_loc(best, 1, 1);
      best.x = MAX(0, MIN(best.x, c->width - 1));
      best.y = MAX(0, MIN(best.y, c->height - 1));
    } else {
      best = loc(randint0(c->width), randint0(c->height));
    }
    if (square_canputitem(c, best)) {
      *grid = best;
      return;
    }
  }
}
STATIC_OVL void
drop_near(struct chunk* c, struct object** dropped, int chance, struct loc grid,
          bool verbose, bool prefer_pile)
{
  char o_name[80];
  struct loc best = grid;
  bool dont_ignore = verbose && !ignore_item_ok(player, *dropped);
  object_desc(o_name, sizeof(o_name), *dropped, ODESC_BASE, player);
  if (!((*dropped)->artifact) && (randint0(100) < chance)) {
    floor_carry_fail(c, *dropped, true);
    return;
  }
  drop_find_grid(player, c, *dropped, prefer_pile, &best);
  if (floor_carry(c, best, *dropped, &dont_ignore)) {
    if (dont_ignore && (square(c, best)->mon < 0)) {
      sound(MSG_DROP);
      msg("You feel something roll beneath your feet.");
    }
  } else {
    floor_carry_fail(c, *dropped, false);
  }
}
STATIC_OVL void
push_object(struct loc grid)
{
  struct feature* feat_old = square_feat(cave, grid);
  struct object* obj = square_object(cave, grid);
  struct queue* queue = q_new(z_info->floor_size);
  struct trap* trap = square_trap(cave, grid);
  while (obj) {
    struct object* next = obj->next;
    struct object* newobj = object_new();
    object_copy(newobj, obj);
    newobj->oidx = 0;
    newobj->grid = loc(0, 0);
    if (newobj->known) {
      newobj->known = object_new();
      object_copy(newobj->known, obj->known);
      newobj->known->oidx = 0;
      newobj->known->grid = loc(0, 0);
    }
    q_push_ptr(queue, newobj);
    delist_object(cave, obj);
    object_delete(cave, player->cave, &obj);
    obj = next;
  }
  square_set_obj(cave, grid, NULL);
  square_force_floor(cave, grid);
  square_add_door(cave, grid, false);
  while (q_len(queue) > 0) {
    obj = q_pop_ptr(queue);
    drop_near(cave, &obj, 0, grid, false, false);
  }
  square_set_feat(cave, grid, feat_old->fidx);
  if (trap && !square_istrappable(cave, grid)) {
    square_destroy_trap(cave, grid);
  }
  q_free(queue);
}
STATIC_OVL void
floor_item_charges(struct object* obj)
{
  if (!tval_can_have_charges(obj)) return;
  if (!object_flavor_is_aware(obj)) return;
  msg("There %s %d charge%s remaining.", (obj->pval != 1) ? "are" : "is",
      obj->pval, (obj->pval != 1) ? "s" : "");
}
STATIC_OVL int
scan_floor(struct object** items, int max_size, struct player* p,
           object_floor_t mode, item_tester tester)
{
  struct object* obj;
  int num = 0;
  if (!square_in_bounds(cave, p->grid)) return 0;
  for (obj = square_object(cave, p->grid); obj; obj = obj->next) {
    if (num >= max_size) break;
    if ((mode & OFLOOR_TEST) && !object_test(tester, obj)) continue;
    if ((mode & OFLOOR_SENSE) && (!obj->known)) continue;
    if ((mode & OFLOOR_VISIBLE) && ignore_item_ok(p, obj)) continue;
    items[num++] = obj;
    if (mode & OFLOOR_TOP) break;
  }
  return num;
}
STATIC_OVL int
scan_distant_floor(struct object** items, int max_size, struct player* p,
                   struct loc grid)
{
  struct object* obj;
  int num = 0;
  if (!square_in_bounds(p->cave, grid)) return 0;
  for (obj = square_object(p->cave, grid); obj; obj = obj->next) {
    if (num >= max_size) break;
    if (obj->kind == unknown_item_kind) continue;
    if (ignore_known_item_ok(p, obj)) continue;
    items[num++] = cave->objects[obj->oidx];
  }
  return num;
}
STATIC_OVL int
scan_items(struct object** item_list, size_t item_max, struct player* p,
           int mode, item_tester tester)
{
  bool use_inven = ((mode & USE_INVEN) ? true : false);
  bool use_equip = ((mode & USE_EQUIP) ? true : false);
  bool use_floor = ((mode & USE_FLOOR) ? true : false);
  int floor_max = z_info->floor_size;
  struct object** floor_list = mem_zalloc(floor_max * sizeof(struct object*));
  int floor_num;
  int i;
  size_t item_num = 0;
  if (use_inven)
    for (i = 0; i < z_info->pack_size && item_num < item_max; i++) {
      if (object_test(tester, p->upkeep->inven[i]))
        item_list[item_num++] = p->upkeep->inven[i];
    }
  if (use_equip)
    for (i = 0; i < p->body.count && item_num < item_max; i++) {
      if (object_test(tester, slot_object(p, i)))
        item_list[item_num++] = slot_object(p, i);
    }
  if (use_floor) {
    floor_num = scan_floor(floor_list, floor_max, p,
                           OFLOOR_TEST | OFLOOR_SENSE | OFLOOR_VISIBLE, tester);
    for (i = 0; i < floor_num && item_num < item_max; i++)
      item_list[item_num++] = floor_list[i];
  }
  mem_free(floor_list);
  return item_num;
}
STATIC_OVL bool
item_is_available(struct object* obj)
{
  if (object_is_carried(player, obj)) return true;
  if (cave && square_holds_object(cave, player->grid, obj)) return true;
  return false;
}
STATIC_OVL struct obj_property*
lookup_obj_property(int type, int index)
{
  struct obj_property* prop;
  int i;
  for (i = 0; i < z_info->property_max; i++) {
    prop = &obj_properties[i];
    if ((prop->type == type) && (prop->index == index)) {
      return prop;
    }
    if ((type == OBJ_PROPERTY_MOD) &&
        ((prop->type == OBJ_PROPERTY_STAT) ||
         (prop->type == OBJ_PROPERTY_SKILL)) &&
        (prop->index == index)) {
      return prop;
    }
  }
  return NULL;
}
STATIC_OVL void
create_obj_flag_mask(bitflag* f, int id, ...)
{
  int i, j;
  va_list args;
  of_wipe(f);
  va_start(args, id);
  for (i = va_arg(args, int); i != OFT_MAX; i = va_arg(args, int)) {
    for (j = 1; j < z_info->property_max; j++) {
      struct obj_property* prop = &obj_properties[j];
      if (prop->type != OBJ_PROPERTY_FLAG) continue;
      if ((id && prop->id_type == i) || (!id && prop->subtype == i)) {
        of_on(f, prop->index);
      }
    }
  }
  va_end(args);
  return;
}
STATIC_OVL void
insert_name(char* buf, size_t size, char* msg, char* name)
{
  const char* next;
  const char* s;
  const char* tag;
  const char* in_cursor;
  size_t end = 0;
  in_cursor = msg;
  next = strchr(in_cursor, '{');
  while (next) {
    strnfcat(buf, 1024, &end, "%.*s", (int)(next - in_cursor), in_cursor);
    s = next + 1;
    while (*s && isalpha((unsigned char)*s)) s++;
    if (*s == '}') {
      tag = next + 1;
      in_cursor = s + 1;
      if (strncmp(tag, "name", 4) == 0) {
        strnfcat(buf, 1024, &end, "%s", name);
      }
    } else {
      in_cursor = next + 1;
    }
    next = strchr(in_cursor, '{');
  }
  strnfcat(buf, 1024, &end, "%s", in_cursor);
}
STATIC_OVL void
flag_message(int flag, char* name)
{
  struct obj_property* prop = lookup_obj_property(OBJ_PROPERTY_FLAG, flag);
  char buf[1024] = "\0";
  if (!prop->msg) return;
  insert_name(buf, 1024, prop->msg, name);
  msg("%s", buf);
}
STATIC_OVL bool
flag_slay_message(int flag, char* name, char* message, int len)
{
  struct obj_property* prop = lookup_obj_property(OBJ_PROPERTY_FLAG, flag);
  char buf[1024] = "\0";
  if (!prop->slay_msg) return false;
  insert_name(buf, 1024, prop->slay_msg, name);
  my_strcpy(message, buf, len);
  return true;
}
STATIC_OVL void
element_message(int elem, char* name, bool vuln)
{
  struct obj_property* prop = lookup_obj_property(OBJ_PROPERTY_RESIST, elem);
  char buf[1024] = "\0";
  if (vuln) prop = lookup_obj_property(OBJ_PROPERTY_VULN, elem);
  if (!prop->msg) return;
  insert_name(buf, 1024, prop->msg, name);
  msg("%s", buf);
}
STATIC_OVL int
sustain_flag(int stat)
{
  if (stat < 0 || stat >= STAT_MAX) return -1;
  return stat + 1;
}
STATIC_OVL int
lookup_slay(const char* code)
{
  int i;
  for (i = 1; i < z_info->slay_max; i++) {
    if (streq(slays[i].code, code)) return i;
  }
  return -1;
}
STATIC_OVL int
lookup_brand(const char* code)
{
  int i;
  for (i = 1; i < z_info->brand_max; i++) {
    if (streq(brands[i].code, code)) return i;
  }
  return -1;
}
STATIC_OVL bool
same_monsters_slain(int slay1, int slay2)
{
  if (slays[slay1].race_flag != slays[slay2].race_flag) return false;
  return true;
}
STATIC_OVL void
copy_slays(bool** dest, bool* source)
{
  int i, j;
  if (!source) return;
  if (!(*dest)) {
    *dest = mem_zalloc(z_info->slay_max * sizeof(bool));
  }
  for (i = 0; i < z_info->slay_max; i++) {
    (*dest)[i] |= source[i];
  }
  for (i = 0; i < z_info->slay_max; i++) {
    for (j = 0; j < i; j++) {
      if ((*dest)[i] && (*dest)[j] && same_monsters_slain(i, j)) {
        (*dest)[j] = false;
      }
    }
  }
}
STATIC_OVL void
copy_brands(bool** dest, bool* source)
{
  int i, j;
  if (!source) return;
  if (!(*dest)) *dest = mem_zalloc(z_info->brand_max * sizeof(bool));
  for (i = 0; i < z_info->brand_max; i++) (*dest)[i] |= source[i];
  for (i = 0; i < z_info->brand_max; i++) {
    for (j = 0; j < i; j++) {
      if ((*dest)[i] && (*dest)[j] && streq(brands[i].name, brands[j].name)) {
        (*dest)[j] = false;
      }
    }
  }
}
STATIC_OVL int
brand_count(const bool* brands_on)
{
  int i, count = 0;
  for (i = 0; i < z_info->brand_max; i++) {
    if (brands_on[i]) {
      count++;
    }
  }
  return count;
}
STATIC_OVL int
slay_count(const bool* slays_on)
{
  int i, count = 0;
  for (i = 0; i < z_info->slay_max; i++) {
    if (slays_on[i]) {
      count++;
    }
  }
  return count;
}
STATIC_OVL bool
react_to_slay(struct slay* slay, const struct monster* mon)
{
  if (!slay->name) return false;
  if (!mon->race) return false;
  if (rf_has(mon->race->flags, slay->race_flag)) return true;
  return false;
}
STATIC_OVL int
slay_bonus(struct player* p, struct object* obj, const struct monster* mon,
           int* slay, int* brand)
{
  int i, dice = 0;
  bool scare = false;
  struct monster_lore* lore = get_lore(mon->race);
  if (!obj) return dice;
  for (i = 1; i < z_info->brand_max; i++) {
    struct brand* b = &brands[i];
    if (!obj->brands || !obj->brands[i]) continue;
    if (!rf_has(mon->race->flags, b->resist_flag)) {
      dice += b->dice;
      if (b->vuln_flag && rf_has(mon->race->flags, b->vuln_flag)) {
        dice += b->vuln_dice;
        scare = true;
      }
      *brand = i;
    } else {
      rf_on(lore->flags, b->resist_flag);
    }
  }
  for (i = 1; i < z_info->slay_max; i++) {
    struct slay* s = &slays[i];
    if (!obj->slays || !obj->slays[i]) continue;
    if (react_to_slay(s, mon)) {
      dice += s->dice;
      scare = true;
      *slay = i;
    } else {
      rf_on(lore->flags, s->race_flag);
    }
  }
  if (scare) {
    scare_onlooking_friends(mon, -20);
  }
  return dice;
}
STATIC_OVL bool
brand_message(struct brand* brand, const struct monster* mon)
{
  char buf[1024] = "\0";
  char m_name[80];
  monster_desc(m_name, sizeof(m_name), mon, MDESC_TARG);
  if (!brand->desc) return false;
  insert_name(buf, 1024, brand->desc, m_name);
  msg("%s", buf);
  return true;
}
STATIC_OVL void
learn_brand_slay_helper(struct player* p, struct object* obj1,
                        struct object* obj2, const struct monster* mon)
{
  struct monster_lore* lore = get_lore(mon->race);
  int i;
  for (i = 1; i < z_info->brand_max; i++) {
    struct brand* b;
    bool learn = false;
    if (obj1 && obj1->brands && obj1->brands[i]) {
      learn = true;
    }
    if (obj2 && obj2->brands && obj2->brands[i]) {
      learn = true;
    }
    if (!learn) continue;
    b = &brands[i];
    if (!b->resist_flag || !rf_has(mon->race->flags, b->resist_flag)) {
      if (!player_knows_brand(p, i)) {
        player_learn_brand(p, i);
        brand_message(b, mon);
      }
      if (b->resist_flag) {
        lore_learn_flag_if_visible(lore, mon, b->resist_flag);
      }
      if (b->vuln_flag) {
        lore_learn_flag_if_visible(lore, mon, b->vuln_flag);
      }
    } else if (player_knows_brand(p, i)) {
      lore_learn_flag_if_visible(lore, mon, b->resist_flag);
    }
  }
  for (i = 1; i < z_info->slay_max; ++i) {
    struct slay* s;
    bool learn = false;
    if (obj1 && obj1->slays && obj1->slays[i]) {
      learn = true;
    }
    if (obj2 && obj2->slays && obj2->slays[i]) {
      learn = true;
    }
    if (!learn) {
      continue;
    }
    s = &slays[i];
    if (react_to_slay(s, mon)) {
      lore_learn_flag_if_visible(lore, mon, s->race_flag);
      if (monster_is_visible(mon)) {
        if (!player_knows_slay(p, i)) {
          char o_name[80];
          object_desc(o_name, sizeof(o_name), obj1, ODESC_BASE, p);
          msg("Your %s strikes truly.", o_name);
          player_learn_slay(p, i);
        }
      }
    } else if (player_knows_slay(p, i)) {
      lore_learn_flag_if_visible(lore, mon, s->race_flag);
    }
  }
}
STATIC_OVL void
learn_brand_slay_from_melee(struct player* p, struct object* weapon,
                            const struct monster* mon)
{
  learn_brand_slay_helper(p, weapon, NULL, mon);
}
STATIC_OVL void
learn_brand_slay_from_launch(struct player* p, struct object* missile,
                             struct object* launcher, const struct monster* mon)
{
  assert(missile && launcher);
  learn_brand_slay_helper(p, missile, launcher, mon);
}
STATIC_OVL void
learn_brand_slay_from_throw(struct player* p, struct object* missile,
                            const struct monster* mon)
{
  assert(missile);
  learn_brand_slay_helper(p, missile, NULL, mon);
}
STATIC_OVL int
att_valid(struct object* obj)
{
  struct object_base* base = obj->kind->base;
  struct object_kind* kind;
  if (base->smith_attack_valid) return true;
  if (strstr(base->name, "Ring")) {
    kind = lookup_kind(base->tval, lookup_sval(base->tval, "Accuracy"));
    if (kind == obj->kind) return true;
    if (obj->artifact) return true;
  }
  return false;
}
STATIC_OVL int
att_max(struct object* obj, bool assume_artistry)
{
  struct object_base* base = obj->kind->base;
  struct object_kind* kind = obj->kind;
  struct ego_item* ego = obj->ego;
  int att = kind->att;
  bool artistry = assume_artistry || player_active_ability(player, "Artistry");
  if (artistry) att += base->smith_attack_artistry;
  if (!tval_is_weapon(obj)) att = MIN(0, att);
  if (ego) att += ego->att;
  if (obj->artifact) att += base->smith_attack_artefact;
  if (strstr(base->name, "Ring")) {
    kind = lookup_kind(base->tval, lookup_sval(base->tval, "Accuracy"));
    if (kind == obj->kind) att = 4;
    if (obj->artifact) att = 4;
  }
  return att;
}
STATIC_OVL int
att_min(struct object* obj)
{
  struct object_base* base = obj->kind->base;
  struct object_kind* kind = obj->kind;
  struct ego_item* ego = obj->ego;
  int att = kind->att;
  if (ego && (ego->att > 0)) att += 1;
  if (strstr(base->name, "Ring")) {
    kind = lookup_kind(base->tval, lookup_sval(base->tval, "Accuracy"));
    if (kind == obj->kind) att = 1;
    ;
  }
  return att;
}
STATIC_OVL int
ds_valid(struct object* obj)
{
  return tval_is_melee_weapon(obj) || tval_is_launcher(obj);
}
STATIC_OVL int
ds_max(struct object* obj, bool assume_artistry)
{
  struct object_kind* kind = obj->kind;
  struct ego_item* ego = obj->ego;
  int ds = kind->ds;
  bool artistry = assume_artistry || player_active_ability(player, "Artistry");
  if (artistry) ds += 1;
  if (ego) ds += ego->ds;
  if (obj->artifact) ds += 2;
  return ds;
}
STATIC_OVL int
ds_min(struct object* obj)
{
  struct object_kind* kind = obj->kind;
  struct ego_item* ego = obj->ego;
  int ds = kind->ds;
  if (ds_valid(obj) && ego && (ego->ds > 0)) ds += 1;
  return ds;
}
STATIC_OVL int
evn_valid(struct object* obj)
{
  struct object_base* base = obj->kind->base;
  struct object_kind* kind;
  if (tval_is_armor(obj)) return true;
  if (tval_is_melee_weapon(obj) && !tval_is_digger(obj)) return true;
  if (strstr(base->name, "Ring")) {
    kind = lookup_kind(base->tval, lookup_sval(base->tval, "Evasion"));
    if (kind == obj->kind) return true;
    if (obj->artifact) return true;
  }
  return false;
}
STATIC_OVL int
evn_max(struct object* obj, bool assume_artistry)
{
  struct object_kind* kind = obj->kind;
  struct object_base* base = kind->base;
  struct ego_item* ego = obj->ego;
  int evn = kind->evn;
  bool artistry = assume_artistry || player_active_ability(player, "Artistry");
  if (tval_is_armor(obj) && artistry) evn += 1;
  if (ego) evn += ego->evn;
  if (obj->artifact) evn += 1;
  if (strstr(base->name, "Ring")) {
    kind = lookup_kind(base->tval, lookup_sval(base->tval, "Evasion"));
    if (kind == obj->kind) evn = 4;
    if (obj->artifact) evn = 4;
  }
  return evn;
}
STATIC_OVL int
evn_min(struct object* obj)
{
  struct object_kind* kind = obj->kind;
  struct object_base* base = kind->base;
  struct ego_item* ego = obj->ego;
  int evn = kind->evn;
  if (ego && (ego->evn > 0)) evn += 1;
  if (strstr(base->name, "Ring")) {
    kind = lookup_kind(base->tval, lookup_sval(base->tval, "Evasion"));
    if (kind == obj->kind) evn = 1;
  }
  return evn;
}
STATIC_OVL int
ps_valid(struct object* obj)
{
  struct object_base* base = obj->kind->base;
  struct object_kind* kind;
  if (tval_is_armor(obj)) return true;
  if (strstr(base->name, "Ring")) {
    kind = lookup_kind(base->tval, lookup_sval(base->tval, "Protection"));
    if (kind == obj->kind) return true;
    if (obj->artifact) return true;
  }
  return false;
}
STATIC_OVL int
ps_max(struct object* obj, bool assume_artistry)
{
  struct object_kind* kind = obj->kind;
  struct object_base* base = kind->base;
  struct ego_item* ego = obj->ego;
  int ps = kind->ps;
  bool artistry = assume_artistry || player_active_ability(player, "Artistry");
  if (artistry) ps += 1;
  if (strstr(base->name, "Cloak")) ps = 0;
  if (strstr(base->name, "Soft Armor")) {
    if (kind == lookup_kind(base->tval, lookup_sval(base->tval, "Filthy Rag")))
      ps = 0;
    if (kind == lookup_kind(base->tval, lookup_sval(base->tval, "Robe")))
      ps = 0;
  }
  if (ego) ps += ego->ps;
  if (obj->artifact) ps += 2;
  if (strstr(base->name, "Ring")) {
    kind = lookup_kind(base->tval, lookup_sval(base->tval, "Protection"));
    if (kind == obj->kind) ps = 3;
    if (obj->artifact) ps = 3;
  }
  return ps;
}
STATIC_OVL int
ps_min(struct object* obj)
{
  struct object_kind* kind = obj->kind;
  struct object_base* base = kind->base;
  struct ego_item* ego = obj->ego;
  int ps = kind->ps;
  if (ego && (ego->ps > 0)) ps += 1;
  if (strstr(base->name, "Ring")) {
    kind = lookup_kind(base->tval, lookup_sval(base->tval, "Protection"));
    if (kind == obj->kind) ps = 1;
  }
  return ps;
}
STATIC_OVL int
pval_valid(struct object* obj)
{
  int i;
  for (i = 0; i < OBJ_MOD_MAX; i++) {
    if (obj->modifiers[i] != 0) return true;
  }
  return (obj->pval != 0);
}
STATIC_OVL int
pval_default(struct object* obj)
{
  int pval = extract_kind_pval(obj->kind, AVERAGE, NULL);
  if (obj->ego && obj->ego->pval > 0) {
    pval += obj_is_cursed(obj) ? -1 : 1;
  }
  return pval;
}
STATIC_OVL int
pval_max(struct object* obj)
{
  int pval = extract_kind_pval(obj->kind, MAXIMISE, NULL);
  if (obj->artifact) {
    pval += 4;
  } else if (tval_is_jewelry(obj)) {
    pval = 4;
  }
  if (obj->ego) {
    if (obj_is_cursed(obj)) {
      if (obj->ego->pval > 0) pval -= 1;
    } else {
      pval += obj->ego->pval;
    }
  }
  return pval;
}
STATIC_OVL int
pval_min(struct object* obj)
{
  int pval = extract_kind_pval(obj->kind, MINIMISE, NULL);
  if (obj->artifact) {
    pval -= 4;
  } else if (tval_is_jewelry(obj)) {
    pval = -4;
  }
  if (obj->ego) {
    if (obj_is_cursed(obj)) {
      if (obj->ego->pval > 0) pval -= obj->ego->pval;
    } else if (obj->ego->pval > 0) {
      pval += 1;
    }
  }
  return pval;
}
STATIC_OVL int
wgt_valid(struct object* obj)
{
  switch (obj->tval) {
    case TV_ARROW:
    case TV_RING:
    case TV_AMULET:
    case TV_LIGHT:
    case TV_HORN: {
      return false;
    }
  }
  return true;
}
STATIC_OVL int
wgt_max(struct object* obj)
{
  return obj->kind->weight * 2;
}
STATIC_OVL int
wgt_min(struct object* obj)
{
  return ((obj->kind->weight + 9) / 10) * 5;
}
STATIC_OVL void
modify_numbers(struct object* obj, int choice, int* pval)
{
  switch (choice) {
    case SMITH_NUM_INC_ATT: {
      if (tval_is_ammo(obj) && !obj->artifact) {
        obj->att += 3;
      } else {
        obj->att++;
      }
      break;
    }
    case SMITH_NUM_DEC_ATT: {
      if (tval_is_ammo(obj) && !obj->artifact) {
        obj->att -= 3;
      } else {
        obj->att--;
      }
      break;
    }
    case SMITH_NUM_INC_DS:
      obj->ds++;
      break;
    case SMITH_NUM_DEC_DS:
      obj->ds--;
      break;
    case SMITH_NUM_INC_EVN:
      obj->evn++;
      break;
    case SMITH_NUM_DEC_EVN:
      obj->evn--;
      break;
    case SMITH_NUM_INC_PS:
      obj->ps++;
      break;
    case SMITH_NUM_DEC_PS:
      obj->ps--;
      break;
    case SMITH_NUM_INC_PVAL: {
      (*pval)++;
      break;
    }
    case SMITH_NUM_DEC_PVAL: {
      (*pval)--;
      break;
    }
    case SMITH_NUM_INC_WGT:
      obj->weight += 5;
      break;
    case SMITH_NUM_DEC_WGT:
      obj->weight -= 5;
      break;
  }
  return;
}
STATIC_OVL bool
object_is_mithril(const struct object* obj)
{
  return of_has(obj->flags, OF_MITHRIL);
}
STATIC_OVL bool
melt_mithril_item(struct player* p, struct object* obj)
{
  struct object_kind* mithril_kind =
      lookup_kind(TV_METAL, lookup_sval(TV_METAL, "Piece of Mithril"));
  int slots_needed = (obj->weight - 1) / mithril_kind->base->max_stack;
  int empty_slots = z_info->pack_size - pack_slots_used(p);
  if (object_is_equipped(p->body, obj)) slots_needed++;
  if (slots_needed > 0) {
    int remainder = obj->weight % mithril_kind->base->max_stack;
    if (remainder) {
      struct object* gear_obj;
      for (gear_obj = p->gear; gear_obj; gear_obj = gear_obj->next) {
        if (gear_obj->tval == mithril_kind->tval &&
            gear_obj->sval == mithril_kind->sval &&
            gear_obj->number + remainder <= mithril_kind->base->max_stack &&
            !object_is_equipped(p->body, gear_obj)) {
          --slots_needed;
          break;
        }
      }
    }
  }
  if (empty_slots < slots_needed) {
    msg("You do not have enough room in your pack.");
    if (slots_needed - empty_slots == 1) {
      msg("You must free up another slot.");
    } else {
      msg("You must free up %d more slots.", slots_needed - empty_slots);
    }
    return false;
  }
  if (get_check("Are you sure you wish to melt this item down? ")) {
    struct object* new = object_new();
    struct object* new_k = object_new();
    int16_t pieces_remaining = obj->weight;
    object_prep(new, mithril_kind, p->depth, RANDOMISE);
    if (tracked_object_is(p->upkeep, obj)) track_object(p->upkeep, NULL);
    gear_excise_object(p, obj);
    assert(obj->known);
    object_delete(p->cave, NULL, &obj->known);
    object_delete(cave, p->cave, &obj);
    cmd_disable_repeat();
    while (pieces_remaining > new->kind->base->max_stack) {
      struct object* new2 = object_new();
      struct object* new2_k = object_new();
      pieces_remaining -= new->kind->base->max_stack;
      object_prep(new2, mithril_kind, 0, MINIMISE);
      new2->number = new->kind->base->max_stack;
      object_copy(new2_k, new2);
      new2->known = new2_k;
      object_touch(p, new2);
      inven_carry(p, new2, true, false);
    }
    new->number = (uint8_t)pieces_remaining;
    object_copy(new_k, new);
    new->known = new_k;
    object_touch(p, new);
    inven_carry(p, new, true, false);
    return true;
  }
  return false;
}
STATIC_OVL int
mithril_items_carried(struct player* p)
{
  int number = 0;
  struct object* obj;
  for (obj = p->gear; obj; obj = obj->next) {
    if (of_has(obj->flags, OF_MITHRIL)) {
      number++;
    }
  }
  return number;
}
STATIC_OVL int
mithril_carried(struct player* p)
{
  int weight = 0;
  struct object* obj;
  struct object_kind* kind =
      lookup_kind(TV_METAL, lookup_sval(TV_METAL, "Piece of Mithril"));
  for (obj = p->gear; obj; obj = obj->next) {
    if (obj->kind == kind) {
      weight += obj->number;
    }
  }
  return weight;
}
STATIC_OVL void
use_mithril(struct player* p, int cost)
{
  struct object* obj = p->gear;
  struct object_kind* kind =
      lookup_kind(TV_METAL, lookup_sval(TV_METAL, "Piece of Mithril"));
  int to_go = cost;
  while (obj && to_go) {
    if (obj->kind == kind) {
      int amount = MIN(to_go, obj->number);
      bool none_left = false;
      struct object *src = obj, *used;
      obj = obj->next;
      used = gear_object_for_use(p, src, amount, true, &none_left);
      assert(used->known);
      object_delete(p->cave, NULL, &used->known);
      object_delete(cave, p->cave, &used);
      to_go -= amount;
    } else {
      obj = obj->next;
    }
  }
}
STATIC_OVL void
dif_mod(int value, int positive_base, int* dif_inc)
{
  int mod = 1 + ((positive_base - 1) / 5);
  if (value > 0) {
    *dif_inc += positive_base * value + mod * (value * (value - 1) / 2);
  }
}
STATIC_OVL void
adjust_smithing_cost(int diff, struct obj_property* prop,
                     struct smithing_cost* smithing_cost)
{
  if (diff <= 0) return;
  switch (prop->smith_cost_type) {
    case SMITH_COST_STR:
      smithing_cost->stat[STAT_STR] += diff * prop->smith_cost;
      break;
    case SMITH_COST_DEX:
      smithing_cost->stat[STAT_DEX] += diff * prop->smith_cost;
      break;
    case SMITH_COST_CON:
      smithing_cost->stat[STAT_CON] += diff * prop->smith_cost;
      break;
    case SMITH_COST_GRA:
      smithing_cost->stat[STAT_GRA] += diff * prop->smith_cost;
      break;
    case SMITH_COST_EXP:
      smithing_cost->exp += diff * prop->smith_cost;
      break;
  }
}
STATIC_OVL int
object_difficulty(struct object* obj, struct smithing_cost* smithing_cost)
{
  struct object_kind* kind = obj->kind;
  int att = (kind->att == SPECIAL_VALUE) ? 0 : kind->att;
  int evn = (kind->evn == SPECIAL_VALUE) ? 0 : kind->evn;
  int ps = (kind->ps == SPECIAL_VALUE) ? 0 : kind->ps;
  bitflag flags[OF_MAX];
  int dif_inc = 0, dif_dec = 0;
  int i, weight_factor, diff, new, base;
  int smith_brands = 0;
  struct ability* ability = obj->abilities;
  int dif_mult = 100;
  int drain = player->state.skill_use[SKILL_SMITHING] +
              square_forge_bonus(cave, player->grid);
  int cat = 0;
  bool jewelry = tval_is_jewelry(obj);
  smithing_cost->stat[STAT_STR] = 0;
  smithing_cost->stat[STAT_DEX] = 0;
  smithing_cost->stat[STAT_CON] = 0;
  smithing_cost->stat[STAT_GRA] = 0;
  smithing_cost->exp = 0;
  smithing_cost->mithril = 0;
  smithing_cost->uses = 1;
  smithing_cost->drain = 0;
  smithing_cost->weaponsmith = 0;
  smithing_cost->armoursmith = 0;
  smithing_cost->jeweller = 0;
  smithing_cost->enchantment = 0;
  smithing_cost->artistry = 0;
  smithing_cost->artifice = 0;
  of_copy(flags, obj->flags);
  if (tval_is_horn(obj)) {
    dif_inc += kind->level;
    if (strstr(obj->kind->name, "Terror")) {
      smithing_cost->stat[STAT_GRA] += 1;
    } else if (strstr(obj->kind->name, "Thunder")) {
      smithing_cost->stat[STAT_DEX] += 1;
    } else if (strstr(obj->kind->name, "Force")) {
      smithing_cost->stat[STAT_STR] += 1;
    } else if (strstr(obj->kind->name, "Blasting")) {
      smithing_cost->stat[STAT_CON] += 1;
    }
  } else if (!jewelry) {
    dif_inc += kind->level / 2;
  }
  if (obj->weight == 0) {
    weight_factor = 1100;
  } else if (obj->weight > kind->weight) {
    weight_factor = 100 * obj->weight / kind->weight;
  } else {
    weight_factor = 100 * kind->weight / obj->weight;
  }
  dif_inc += (weight_factor - 100) / 10;
  diff = obj->att - att;
  if (tval_is_ammo(obj) && (diff > 0)) {
    int old_dif_inc = dif_inc;
    dif_mod(diff, 5, &dif_inc);
    dif_inc = (dif_inc - old_dif_inc) / 2;
  } else {
    dif_mod(diff, 5, &dif_inc);
  }
  diff = obj->evn - evn;
  dif_mod(diff, 5, &dif_inc);
  diff = (obj->ds - kind->ds);
  dif_mod(diff, 8 + obj->dd, &dif_inc);
  base = (ps > 0) ? ((ps + 1) * kind->pd) : 0;
  new = (obj->ps > 0) ? ((obj->ps + 1) * obj->pd) : 0;
  diff = new - base;
  dif_mod(diff, 4, &dif_inc);
  for (i = 1; i < z_info->property_max; i++) {
    struct obj_property* prop = &obj_properties[i];
    switch (prop->type) {
      case OBJ_PROPERTY_STAT:
      case OBJ_PROPERTY_SKILL:
      case OBJ_PROPERTY_MOD: {
        diff = obj->modifiers[prop->index];
        if (!jewelry && prop->smith_exclude_base) {
          diff -= randcalc(obj->kind->modifiers[prop->index], 0, AVERAGE);
        }
        if (diff != 0) {
          dif_mod(diff, prop->smith_diff, &dif_inc);
          adjust_smithing_cost(diff, prop, smithing_cost);
        }
        break;
      }
      case OBJ_PROPERTY_FLAG: {
        if (of_has(flags, prop->index) &&
            (jewelry || !prop->smith_exclude_base ||
             !of_has(kind->flags, prop->index))) {
          if (prop->smith_diff > 0) {
            dif_inc += prop->smith_diff;
            adjust_smithing_cost(1, prop, smithing_cost);
          } else if (prop->smith_diff < 0) {
            dif_dec -= prop->smith_diff;
          }
        }
        break;
      }
      case OBJ_PROPERTY_RESIST: {
        if (obj->el_info[prop->index].res_level == 1 &&
            (jewelry || !prop->smith_exclude_base ||
             kind->el_info[prop->index].res_level == 0)) {
          dif_inc += prop->smith_diff;
          adjust_smithing_cost(1, prop, smithing_cost);
        }
        break;
      }
      case OBJ_PROPERTY_SLAY: {
        if (obj->slays && obj->slays[prop->index] &&
            (jewelry || !prop->smith_exclude_base ||
             !(kind->slays && kind->slays[prop->index]))) {
          dif_inc += prop->smith_diff;
        }
        break;
      }
      case OBJ_PROPERTY_BRAND: {
        if (obj->brands && obj->brands[prop->index] &&
            (jewelry || !prop->smith_exclude_base ||
             !(kind->brands && kind->brands[prop->index]))) {
          dif_inc += prop->smith_diff;
          adjust_smithing_cost(1, prop, smithing_cost);
          smith_brands++;
        }
        break;
      }
    }
  }
  if (smith_brands > 1) {
    dif_inc += (smith_brands - 1) * 20;
  }
  while (ability) {
    dif_inc += 5 + ability->level / 2;
    smithing_cost->exp += 500;
    ability = ability->next;
  }
  if (of_has(kind->flags, OF_MITHRIL)) {
    smithing_cost->mithril += obj->weight;
  }
  if (obj->artifact) {
    smithing_cost->uses += 2;
  }
  dif_dec = MIN(dif_dec, 8);
  diff = dif_inc - dif_dec;
  if (tval_is_ring(obj) || tval_is_light(obj) || tval_is_cloak(obj) ||
      tval_is_gloves(obj) || tval_is_boots(obj) || tval_is_ammo(obj)) {
    dif_mult += 20;
  }
  if (of_has(kind->flags, OF_ENCHANTABLE)) {
    dif_mult -= 20;
  }
  diff = diff * dif_mult / 100;
  if (tval_is_ammo(obj) && (obj->number == 1)) diff /= 2;
  if ((diff > drain) && player_active_ability(player, "Masterpiece")) {
    smithing_cost->drain += diff - drain;
  }
  for (i = 0; i < MAX_SMITHING_TVALS; i++) {
    if (smithing_tvals[i].tval == obj->tval) {
      cat = smithing_tvals[i].category;
    }
  }
  if ((cat == SMITH_TYPE_WEAPON) &&
      !player_active_ability(player, "Weaponsmith")) {
    smithing_cost->weaponsmith = 1;
  }
  if ((cat == SMITH_TYPE_ARMOUR) &&
      !player_active_ability(player, "Armoursmith")) {
    smithing_cost->armoursmith = 1;
  }
  if ((cat == SMITH_TYPE_JEWELRY) &&
      !player_active_ability(player, "Jeweller")) {
    smithing_cost->jeweller = 1;
  }
  if (obj->artifact && !player_active_ability(player, "Artifice")) {
    smithing_cost->artifice = 1;
  }
  if (obj->ego && !player_active_ability(player, "Enchantment")) {
    smithing_cost->enchantment = 1;
  }
  if ((att_valid(obj) && (obj->att > att_max(obj, false))) ||
      (ds_valid(obj) && (obj->ds > ds_max(obj, false))) ||
      (evn_valid(obj) && (obj->evn > evn_max(obj, false))) ||
      (ps_valid(obj) && (obj->ps > ps_max(obj, false)))) {
    smithing_cost->artistry = 1;
  }
  return diff;
}
STATIC_OVL int
too_difficult(struct object* obj)
{
  struct smithing_cost dummy;
  int dif = object_difficulty(obj, &dummy);
  int ability = player->state.skill_use[SKILL_SMITHING] +
                square_forge_bonus(cave, player->grid);
  if (player_active_ability(player, "Masterpiece")) {
    ability += player->skill_base[SKILL_SMITHING];
  }
  return ability < dif;
}
STATIC_OVL bool
check_stat_drain(struct player* p, int stat, int cost)
{
  int usable_stat = p->stat_base[stat] + p->stat_drain[stat];
  if (cost <= 0) return true;
  return usable_stat - cost >= -5;
}
STATIC_OVL bool
smith_affordable(struct object* obj, struct smithing_cost* smithing_cost)
{
  int stat;
  if (!obj->kind) return false;
  if (too_difficult(obj)) return false;
  for (stat = 0; stat < STAT_MAX; stat++) {
    if (!check_stat_drain(player, stat, smithing_cost->stat[stat])) {
      return false;
    }
  }
  if (smithing_cost->exp > player->new_exp) return false;
  if ((smithing_cost->mithril > 0) &&
      (smithing_cost->mithril > mithril_carried(player))) {
    return false;
  }
  if (square_forge_uses(cave, player->grid) < smithing_cost->uses) {
    return false;
  }
  if (smithing_cost->weaponsmith || smithing_cost->armoursmith ||
      smithing_cost->jeweller || smithing_cost->enchantment ||
      smithing_cost->artistry || smithing_cost->artifice) {
    return false;
  }
  return true;
}
STATIC_OVL void
smith_pay_costs(struct smithing_cost* smithing_cost)
{
  int stat;
  for (stat = 0; stat < STAT_MAX; stat++) {
    if (smithing_cost->stat[stat] > 0) {
      player->stat_drain[stat] -= smithing_cost->stat[stat];
    }
  }
  if (smithing_cost->exp > 0) {
    player->new_exp -= smithing_cost->exp;
  }
  if (smithing_cost->mithril > 0) {
    use_mithril(player, smithing_cost->mithril);
  }
  if (smithing_cost->uses > 0) {
    int uses = square_forge_uses(cave, player->grid);
    assert(uses >= smithing_cost->uses);
    square_set_forge(cave, player->grid, uses - smithing_cost->uses);
  }
  if (smithing_cost->drain > 0) {
    player->skill_base[SKILL_SMITHING] -= smithing_cost->drain;
  }
  player->upkeep->update |= (PU_BONUS);
  player->upkeep->redraw |= (PR_EXP | PR_BASIC);
}
STATIC_OVL void
set_base_values(struct object* obj)
{
  int i;
  if (obj->kind->att == SPECIAL_VALUE) {
    obj->att = 1;
  }
  if (obj->kind->evn == SPECIAL_VALUE) {
    obj->evn = 1;
  }
  if (obj->kind->ps == SPECIAL_VALUE) {
    obj->ps = 1;
  }
  for (i = 0; i < OBJ_MOD_MAX; i++) {
    if ((obj->kind->modifiers[i].base == SPECIAL_VALUE) ||
        (obj->kind->modifiers[i].m_bonus)) {
      obj->modifiers[i] = 1;
      obj->pval = 1;
    }
  }
}
STATIC_OVL void
create_base_object(struct object_kind* kind, struct object* obj)
{
  memset(obj, 0, sizeof(*obj));
  object_prep(obj, kind, 0, AVERAGE);
  set_base_values(obj);
  if (tval_is_light(obj)) {
    obj->pval = 0;
    if (of_has(obj->flags, OF_TAKES_FUEL)) {
      obj->timeout = 0;
    }
  }
  if (tval_is_ammo(obj)) {
    obj->number = 24;
  }
}
STATIC_OVL void
create_special(struct object* obj, struct ego_item* ego)
{
  struct object_kind* kind = obj->kind;
  if (obj->slays) mem_free(obj->slays);
  if (obj->brands) mem_free(obj->brands);
  if (obj->abilities) {
    release_ability_list(obj->abilities);
  }
  create_base_object(kind, obj);
  obj->ego = ego;
  ego_apply_magic(obj, true);
}
STATIC_OVL void
artefact_copy(struct artifact* a_dst, struct artifact* a_src)
{
  mem_free(a_dst->slays);
  mem_free(a_dst->brands);
  release_ability_list(a_dst->abilities);
  memcpy(a_dst, a_src, sizeof(struct artifact));
  a_dst->next = NULL;
  a_dst->slays = NULL;
  a_dst->brands = NULL;
  a_dst->abilities = NULL;
  if (a_src->slays) {
    a_dst->slays = mem_zalloc(z_info->slay_max * sizeof(bool));
    memcpy(a_dst->slays, a_src->slays, z_info->slay_max * sizeof(bool));
  }
  if (a_src->brands) {
    a_dst->brands = mem_zalloc(z_info->brand_max * sizeof(bool));
    memcpy(a_dst->brands, a_src->brands, z_info->brand_max * sizeof(bool));
  }
  if (a_src->abilities) {
    a_dst->abilities = copy_ability_list(a_src->abilities);
  }
}
STATIC_OVL void
add_artefact_details(struct artifact* art, struct object* obj)
{
  int i;
  struct smithing_cost dummy;
  art->aidx = (z_info->a_max) ? z_info->a_max : 1;
  art->tval = obj->tval;
  art->sval = obj->sval;
  art->pval = obj->pval;
  art->att = obj->att;
  art->evn = obj->evn;
  art->dd = obj->dd;
  art->ds = obj->ds;
  art->pd = obj->pd;
  art->ps = obj->ps;
  art->weight = obj->weight;
  of_union(art->flags, obj->flags);
  for (i = 0; i < OBJ_MOD_MAX; i++) {
    art->modifiers[i] = obj->modifiers[i];
  }
  for (i = 0; i < ELEM_MAX; i++) {
    art->el_info[i].res_level = obj->el_info[i].res_level;
    art->el_info[i].flags = obj->el_info[i].flags;
  }
  copy_slays(&art->slays, obj->slays);
  copy_brands(&art->brands, obj->brands);
  if (obj->abilities) {
    struct ability* ability = obj->abilities;
    while (ability) {
      add_ability(&art->abilities, ability);
      ability = ability->next;
    }
  }
  art->level = object_difficulty(obj, &dummy);
  art->rarity = 10;
}
STATIC_OVL bool
applicable_property(struct obj_property* prop, struct object* obj)
{
  struct object_base* base = obj->kind->base;
  bool valid = false;
  int idx = prop ? prop->index : -1;
  char name[80];
  assert(idx >= 0);
  switch (prop->type) {
    case OBJ_PROPERTY_STAT:
    case OBJ_PROPERTY_SKILL:
    case OBJ_PROPERTY_MOD: {
      if (base->smith_modifiers[idx] != 0) valid = true;
      break;
    }
    case OBJ_PROPERTY_FLAG: {
      if (of_has(base->smith_flags, idx)) valid = true;
      break;
    }
    case OBJ_PROPERTY_RESIST: {
      if (base->smith_el_info[idx].res_level >= 1) valid = true;
      break;
    }
    case OBJ_PROPERTY_VULN: {
      if ((base->smith_el_info[idx].res_level == -1) ||
          (base->smith_el_info[idx].res_level == 2))
        valid = true;
      break;
    }
    case OBJ_PROPERTY_SLAY: {
      if (base->smith_slays && (base->smith_slays[idx])) valid = true;
      break;
    }
    case OBJ_PROPERTY_BRAND: {
      if (base->smith_brands && (base->smith_brands[idx])) valid = true;
      break;
    }
  }
  object_short_name(name, sizeof(name), obj->kind->name);
  if (streq(name, "War Hammer") && (prop->type == OBJ_PROPERTY_SKILL) &&
      (idx == OBJ_MOD_SMITHING)) {
    valid = true;
  }
  return valid;
}
STATIC_OVL bool
object_has_property(struct obj_property* prop, struct object* obj,
                    bool negative)
{
  int idx = prop ? prop->index : -1;
  assert(idx >= 0);
  switch (prop->type) {
    case OBJ_PROPERTY_STAT: {
      return negative ? obj->modifiers[idx] < 0 : obj->modifiers[idx] > 0;
      break;
    }
    case OBJ_PROPERTY_SKILL:
    case OBJ_PROPERTY_MOD: {
      return obj->modifiers[idx] != 0;
      break;
    }
    case OBJ_PROPERTY_FLAG: {
      return of_has(obj->flags, idx);
      break;
    }
    case OBJ_PROPERTY_RESIST: {
      return obj->el_info[idx].res_level == 1;
      break;
    }
    case OBJ_PROPERTY_VULN: {
      return obj->el_info[idx].res_level == -1;
      break;
    }
    case OBJ_PROPERTY_SLAY: {
      return (obj->slays != NULL) && (obj->slays[idx] == true);
      break;
    }
    case OBJ_PROPERTY_BRAND: {
      return (obj->brands != NULL) && (obj->brands[idx] == true);
      break;
    }
  }
  return false;
}
STATIC_OVL void
add_object_property(struct obj_property* prop, struct object* obj,
                    bool negative)
{
  int idx = prop ? prop->index : -1;
  assert(idx >= 0);
  switch (prop->type) {
    case OBJ_PROPERTY_STAT:
    case OBJ_PROPERTY_SKILL:
    case OBJ_PROPERTY_MOD: {
      obj->modifiers[idx] = negative ? -1 : 1;
      break;
    }
    case OBJ_PROPERTY_FLAG: {
      of_on(obj->flags, idx);
      break;
    }
    case OBJ_PROPERTY_RESIST: {
      obj->el_info[idx].res_level = 1;
      break;
    }
    case OBJ_PROPERTY_VULN: {
      obj->el_info[idx].res_level = -1;
      break;
    }
    case OBJ_PROPERTY_SLAY: {
      if (!obj->slays) {
        obj->slays = mem_zalloc(z_info->slay_max * sizeof(bool));
      }
      obj->slays[idx] = true;
      break;
    }
    case OBJ_PROPERTY_BRAND: {
      if (!obj->brands) {
        obj->brands = mem_zalloc(z_info->brand_max * sizeof(bool));
      }
      obj->brands[idx] = true;
      break;
    }
  }
}
STATIC_OVL void
remove_object_property(struct obj_property* prop, struct object* obj)
{
  int idx = prop ? prop->index : -1;
  int min_m, max_m;
  assert(idx >= 0);
  switch (prop->type) {
    case OBJ_PROPERTY_STAT:
    case OBJ_PROPERTY_SKILL:
    case OBJ_PROPERTY_MOD: {
      min_m = randcalc(obj->kind->modifiers[idx], 0, MINIMISE);
      max_m = randcalc(obj->kind->modifiers[idx], z_info->dun_depth, MAXIMISE);
      if (min_m == SPECIAL_VALUE) {
        min_m = randcalc(obj->kind->special1, 0, MINIMISE);
        if (!min_m && obj->kind->special2) {
          min_m = obj->kind->special2;
        }
      }
      if (max_m == SPECIAL_VALUE) {
        max_m = randcalc(obj->kind->special1, z_info->dun_depth, MAXIMISE);
        if (!max_m && obj->kind->special2) {
          max_m = obj->kind->special2;
        }
      }
      if (min_m || max_m) {
        bool flip_sign;
        if (min_m >= 0) {
          obj->modifiers[idx] = 1;
        } else if (max_m > 0) {
          obj->modifiers[idx] = (max_m >= -min_m) ? 1 : -1;
        } else {
          obj->modifiers[idx] = -1;
        }
        (void)extract_kind_pval(obj->kind, AVERAGE, &flip_sign);
        if (flip_sign) {
          obj->modifiers[idx] *= -1;
        }
      } else {
        obj->modifiers[idx] = 0;
      }
      break;
    }
    case OBJ_PROPERTY_FLAG: {
      of_off(obj->flags, idx);
      break;
    }
    case OBJ_PROPERTY_RESIST:
    case OBJ_PROPERTY_VULN: {
      obj->el_info[idx].res_level = 0;
      break;
    }
    case OBJ_PROPERTY_SLAY: {
      obj->slays[idx] = false;
      for (idx = 0; idx < z_info->slay_max; idx++) {
        if (obj->slays[idx]) break;
      }
      if (idx == z_info->slay_max) {
        mem_free(obj->slays);
        obj->slays = NULL;
      }
      break;
    }
    case OBJ_PROPERTY_BRAND: {
      obj->brands[idx] = false;
      for (idx = 0; idx < z_info->brand_max; idx++) {
        if (obj->brands[idx]) break;
      }
      if (idx == z_info->brand_max) {
        mem_free(obj->brands);
        obj->brands = NULL;
      }
      break;
    }
  }
}
STATIC_OVL void
create_smithing_item(struct object* obj, struct smithing_cost* cost)
{
  struct object* created = object_new();
  char o_name[80];
  player->smithing_leftover = 0;
  msg("You complete your work.");
  smith_pay_costs(cost);
  if (obj->artifact) {
    uint16_t aidx = (z_info->a_max) ? z_info->a_max : 1;
    assert(aidx == obj->artifact->aidx);
    z_info->a_max = aidx + 1;
    a_info = mem_realloc(a_info, z_info->a_max * sizeof(struct artifact));
    aup_info = mem_realloc(aup_info, z_info->a_max * sizeof(*aup_info));
    if (aidx == 1) {
      memset(&a_info[0], 0, sizeof(a_info[0]));
      memset(&aup_info[0], 0, sizeof(aup_info[0]));
    }
    memset(&a_info[aidx], 0, sizeof(a_info[aidx]));
    artefact_copy(&a_info[aidx], (struct artifact*)obj->artifact);
    a_info[aidx].name = string_make(a_info[aidx].name);
    player->self_made_arts++;
    aup_info[aidx].aidx = aidx;
    aup_info[aidx].created = true;
    aup_info[aidx].seen = true;
    aup_info[aidx].everseen = true;
    obj->artifact = &a_info[aidx];
    if (obj->known) {
      obj->known->artifact = obj->artifact;
    }
  }
  object_copy(created, obj);
  created->known = object_new();
  if (obj->known) {
    object_copy(created->known, obj->known);
  } else {
    object_set_base_known(player, created->known);
  }
  if (tval_is_light(created)) {
    created->pval = created->kind->pval;
    if (obj->known) {
      created->known->pval = created->kind->pval;
    }
  }
  object_touch(player, created);
  object_flavor_aware(player, created);
  while (!object_runes_known(created)) {
    object_learn_unknown_rune(player, created);
  }
  object_desc(o_name, sizeof(o_name), created, ODESC_COMBAT | ODESC_EXTRA,
              player);
  history_add(player,
              format("Made %s  %d.%d lb", o_name,
                     (created->weight * created->number) / 10,
                     (created->weight * created->number) % 10),
              HIST_OBJECT_SMITHED);
  inven_carry(player, created, false, true);
}
STATIC_OVL void
start_smithing(struct player* p, int turns)
{
  p->upkeep->smithing = true;
  cmd_set_repeat(turns);
  p->upkeep->update |= (PU_BONUS);
  p->upkeep->redraw |= (PR_STATE);
  handle_stuff(p);
}
STATIC_OVL void
do_cmd_smith_aux(bool flush)
{
  bool forge = square_isforge(cave, player->grid);
  bool useless = (square_forge_uses(cave, player->grid) == 0);
  struct object* obj;
  int turns = 0;
  struct smithing_cost cost;
  if (!player->upkeep->smithing) {
    if (forge && useless) {
      msg("The resources of this forge are exhausted.");
      msg("You will be able to browse options but not make new things.");
    }
    obj = smith_object(&cost);
    if (!obj) return;
    if (player->smithing_leftover > 0) {
      turns = player->smithing_leftover;
    } else {
      turns = MAX(10, object_difficulty(obj, &cost) * 10);
      player->smithing_leftover = turns;
      msg("You begin your work.");
    }
    player->stealth_mode = STEALTH_MODE_OFF;
    if (flush) {
      cmdq_push(CMD_SMITH);
      cmdq_pop(CTX_GAME);
    }
    start_smithing(player, turns);
  }
  player->upkeep->energy_use = z_info->move_energy;
  if (cmd_get_nrepeats() == 1) {
    obj = smith_object(&cost);
    create_smithing_item(obj, &cost);
    player->upkeep->smithing = false;
  }
  handle_stuff(player);
}
STATIC_OVL void
do_cmd_smith(struct command* cmd)
{
  do_cmd_smith_aux(false);
}
STATIC_OVL bool
tval_is_staff(const struct object* obj)
{
  return obj->tval == TV_STAFF;
}
STATIC_OVL bool
tval_is_note(const struct object* obj)
{
  return obj->tval == TV_NOTE;
}
STATIC_OVL bool
tval_is_horn(const struct object* obj)
{
  return obj->tval == TV_HORN;
}
STATIC_OVL bool
tval_is_potion(const struct object* obj)
{
  return obj->tval == TV_POTION;
}
STATIC_OVL bool
tval_is_food(const struct object* obj)
{
  return obj->tval == TV_FOOD;
}
STATIC_OVL bool
tval_is_food_k(const struct object_kind* kind)
{
  return kind->tval == TV_FOOD;
}
STATIC_OVL bool
tval_is_herb(const struct object* obj)
{
  return obj->tval == TV_HERB;
}
STATIC_OVL bool
tval_is_herb_k(const struct object_kind* kind)
{
  return kind->tval == TV_HERB;
}
STATIC_OVL bool
tval_is_light(const struct object* obj)
{
  return obj->tval == TV_LIGHT;
}
STATIC_OVL bool
tval_is_light_k(const struct object_kind* kind)
{
  return kind->tval == TV_LIGHT;
}
STATIC_OVL bool
tval_is_ring(const struct object* obj)
{
  return obj->tval == TV_RING;
}
STATIC_OVL bool
tval_is_chest(const struct object* obj)
{
  return obj->tval == TV_CHEST;
}
STATIC_OVL bool
tval_is_metal(const struct object* obj)
{
  return obj->tval == TV_METAL;
}
STATIC_OVL bool
tval_is_fuel(const struct object* obj)
{
  return obj->tval == TV_FLASK;
}
STATIC_OVL bool
tval_is_digger(const struct object* obj)
{
  return obj->tval == TV_DIGGING;
}
STATIC_OVL bool
tval_can_have_nourishment(const struct object* obj)
{
  return obj->tval == TV_FOOD || obj->tval == TV_POTION || obj->tval == TV_HERB;
}
STATIC_OVL bool
tval_can_have_charges(const struct object* obj)
{
  return obj->tval == TV_STAFF;
}
STATIC_OVL bool
tval_is_cloak(const struct object* obj)
{
  return obj->tval == TV_CLOAK;
}
STATIC_OVL bool
tval_is_gloves(const struct object* obj)
{
  return obj->tval == TV_GLOVES;
}
STATIC_OVL bool
tval_is_boots(const struct object* obj)
{
  return obj->tval == TV_BOOTS;
}
STATIC_OVL bool
tval_is_sword(const struct object* obj)
{
  return obj->tval == TV_SWORD;
}
STATIC_OVL bool
tval_is_shield(const struct object* obj)
{
  return obj->tval == TV_SHIELD;
}
STATIC_OVL bool
tval_is_body_armor(const struct object* obj)
{
  switch (obj->tval) {
    case TV_SOFT_ARMOR:
    case TV_MAIL:
      return true;
    default:
      return false;
  }
}
STATIC_OVL bool
tval_is_head_armor(const struct object* obj)
{
  return obj->tval == TV_HELM || obj->tval == TV_CROWN;
}
STATIC_OVL bool
tval_is_ammo(const struct object* obj)
{
  switch (obj->tval) {
    case TV_ARROW:
      return true;
    default:
      return false;
  }
}
STATIC_OVL bool
tval_is_sharp(const struct object* obj)
{
  switch (obj->tval) {
    case TV_ARROW:
    case TV_SWORD:
    case TV_POLEARM:
      return true;
    default:
      return false;
  }
}
STATIC_OVL bool
tval_is_launcher(const struct object* obj)
{
  return obj->tval == TV_BOW;
}
STATIC_OVL bool
tval_is_useable(const struct object* obj)
{
  switch (obj->tval) {
    case TV_LIGHT:
    case TV_ARROW:
    case TV_HORN:
    case TV_STAFF:
    case TV_POTION:
    case TV_FOOD:
    case TV_HERB:
      return true;
    default:
      return false;
  }
}
STATIC_OVL bool
tval_is_jewelry(const struct object* obj)
{
  return obj->tval == TV_RING || obj->tval == TV_AMULET;
}
STATIC_OVL bool
tval_is_weapon(const struct object* obj)
{
  switch (obj->tval) {
    case TV_SWORD:
    case TV_HAFTED:
    case TV_POLEARM:
    case TV_DIGGING:
    case TV_BOW:
    case TV_ARROW:
      return true;
    default:
      return false;
  }
}
STATIC_OVL bool
tval_is_armor(const struct object* obj)
{
  switch (obj->tval) {
    case TV_MAIL:
    case TV_SOFT_ARMOR:
    case TV_SHIELD:
    case TV_CLOAK:
    case TV_CROWN:
    case TV_HELM:
    case TV_BOOTS:
    case TV_GLOVES:
      return true;
    default:
      return false;
  }
}
STATIC_OVL bool
tval_is_melee_weapon(const struct object* obj)
{
  switch (obj->tval) {
    case TV_SWORD:
    case TV_HAFTED:
    case TV_POLEARM:
    case TV_DIGGING:
      return true;
    default:
      return false;
  }
}
STATIC_OVL bool
tval_is_held_weapon(const struct object* obj)
{
  switch (obj->tval) {
    case TV_BOW:
    case TV_SWORD:
    case TV_HAFTED:
    case TV_POLEARM:
    case TV_DIGGING:
      return true;
    default:
      return false;
  }
}
STATIC_OVL bool
tval_has_variable_power(const struct object* obj)
{
  switch (obj->tval) {
    case TV_ARROW:
    case TV_BOW:
    case TV_DIGGING:
    case TV_HAFTED:
    case TV_POLEARM:
    case TV_SWORD:
    case TV_BOOTS:
    case TV_GLOVES:
    case TV_HELM:
    case TV_CROWN:
    case TV_SHIELD:
    case TV_CLOAK:
    case TV_SOFT_ARMOR:
    case TV_MAIL:
    case TV_LIGHT:
    case TV_AMULET:
    case TV_RING:
      return true;
    default:
      return false;
  }
}
STATIC_OVL bool
tval_is_wearable(const struct object* obj)
{
  switch (obj->tval) {
    case TV_BOW:
    case TV_DIGGING:
    case TV_HAFTED:
    case TV_POLEARM:
    case TV_SWORD:
    case TV_BOOTS:
    case TV_GLOVES:
    case TV_HELM:
    case TV_CROWN:
    case TV_SHIELD:
    case TV_CLOAK:
    case TV_SOFT_ARMOR:
    case TV_MAIL:
    case TV_LIGHT:
    case TV_AMULET:
    case TV_RING:
      return true;
    default:
      return false;
  }
}
STATIC_OVL bool
tval_is_edible(const struct object* obj)
{
  switch (obj->tval) {
    case TV_FOOD:
    case TV_HERB:
      return true;
    default:
      return false;
  }
}
STATIC_OVL bool
tval_can_have_flavor_k(const struct object_kind* kind)
{
  switch (kind->tval) {
    case TV_AMULET:
    case TV_RING:
    case TV_STAFF:
    case TV_HORN:
    case TV_POTION:
    case TV_HERB:
      return true;
    default:
      return false;
  }
}
STATIC_OVL char*
de_armour(const char* name)
{
  char newname[40];
  char* armour;
  my_strcpy(newname, name, sizeof(newname));
  armour = strstr(newname, "armour");
  if (armour) my_strcpy(armour + 4, "r", 2);
  return string_make(newname);
}
STATIC_OVL int
tval_find_idx(const char* name)
{
  size_t i;
  char *mod_name, *pe;
  unsigned long r = strtoul(name, &pe, 10);
  if (pe != name) {
    return (contains_only_spaces(pe) && r < TV_MAX) ? (int)r : -1;
  }
  mod_name = de_armour(name);
  for (i = 0; i < N_ELEMENTS(tval_names); i++) {
    if (!my_stricmp(mod_name, tval_names[i].name)) {
      string_free(mod_name);
      return tval_names[i].tval;
    }
  }
  string_free(mod_name);
  return -1;
}
STATIC_OVL const char*
tval_find_name(int tval)
{
  size_t i = 0;
  for (i = 0; i < N_ELEMENTS(tval_names); i++) {
    if (tval == tval_names[i].tval) return tval_names[i].name;
  }
  return "unknown";
}
STATIC_OVL int
tval_sval_count(const char* name)
{
  size_t i, num = 0;
  int tval = tval_find_idx(name);
  if (tval < 0) return 0;
  for (i = 0; i < z_info->k_max; i++) {
    struct object_kind* kind = &k_info[i];
    if (!kind->tval) continue;
    if (kind->tval != tval) continue;
    num++;
  }
  return num;
}
STATIC_OVL int
tval_sval_list(const char* name, int* list, int max_size)
{
  size_t i;
  int num = 0;
  int tval = tval_find_idx(name);
  if (tval < 0) return 0;
  for (i = 0; i < z_info->k_max; i++) {
    struct object_kind* kind = &k_info[i];
    if (!kind->tval) continue;
    if (kind->tval != tval) continue;
    if (num >= max_size) break;
    list[num++] = kind->sval;
  }
  return num;
}
STATIC_OVL void
flavor_assign_fixed(void)
{
  int i;
  struct flavor* f;
  for (f = flavors; f; f = f->next) {
    if (f->sval == SV_UNKNOWN) continue;
    for (i = 0; i < z_info->k_max; i++) {
      struct object_kind* k = &k_info[i];
      if (k->tval == f->tval && k->sval == f->sval) k->flavor = f;
    }
  }
}
STATIC_OVL void
flavor_assign_random(uint8_t tval)
{
  int i;
  int flavor_count = 0;
  int choice;
  struct flavor* f;
  for (f = flavors; f; f = f->next)
    if (f->tval == tval && f->sval == SV_UNKNOWN) flavor_count++;
  for (i = 0; i < z_info->k_max; i++) {
    if (k_info[i].tval != tval || k_info[i].flavor) continue;
    if (!flavor_count) quit_fmt("Not enough flavors for tval %d.", tval);
    choice = randint0(flavor_count);
    for (f = flavors; f; f = f->next) {
      if (f->tval != tval || f->sval != SV_UNKNOWN) continue;
      if (choice == 0) {
        k_info[i].flavor = f;
        f->sval = k_info[i].sval;
        flavor_count--;
        break;
      }
      choice--;
    }
  }
}
STATIC_OVL void
flavor_init(void)
{
  int i;
  Rand_quick = true;
  Rand_value = seed_flavor;
  if (turn == 1) {
    struct flavor* f;
    for (i = 0; i < z_info->k_max; i++) {
      k_info[i].flavor = NULL;
    }
    for (f = flavors; f; f = f->next) {
      f->sval = SV_UNKNOWN;
    }
    cleanup_parser(&flavor_parser);
    run_parser(&flavor_parser);
  }
  flavor_assign_fixed();
  flavor_assign_random(TV_RING);
  flavor_assign_random(TV_AMULET);
  flavor_assign_random(TV_STAFF);
  flavor_assign_random(TV_HORN);
  flavor_assign_random(TV_HERB);
  flavor_assign_random(TV_POTION);
  Rand_quick = false;
  for (i = 0; i < z_info->k_max; i++) {
    struct object_kind* kind = &k_info[i];
    if (!kind->name) continue;
    if (!kind->flavor) kind->aware = true;
  }
}
STATIC_OVL void
flavor_set_all_aware(void)
{
  int i;
  for (i = 0; i < z_info->k_max; i++) {
    struct object_kind* kind = &k_info[i];
    if (!kind->name) continue;
    if (kind->flavor) kind->aware = true;
  }
}
STATIC_OVL void
object_flags(const struct object* obj, bitflag flags[OF_SIZE])
{
  of_wipe(flags);
  if (!obj) return;
  of_copy(flags, obj->flags);
}
STATIC_OVL void
object_flags_known(const struct object* obj, bitflag flags[OF_SIZE])
{
  object_flags(obj, flags);
  of_inter(flags, obj->known->flags);
  if (!obj->kind) {
    return;
  }
  if (object_flavor_is_aware(obj)) {
    of_union(flags, obj->kind->flags);
  }
  if (obj->ego && easy_know(obj)) {
    of_union(flags, obj->ego->flags);
  }
}
STATIC_OVL bool
object_test(item_tester tester, const struct object* obj)
{
  if (!obj) return false;
  return !tester || tester(obj);
}
STATIC_OVL unsigned
check_for_inscrip(const struct object* obj, const char* inscrip)
{
  unsigned i = 0;
  const char* s;
  if (!obj->note) return 0;
  s = quark_str(obj->note);
  if (!s) return 0;
  do {
    s = strstr(s, inscrip);
    if (!s) break;
    i++;
    s++;
  } while (s);
  return i;
}
STATIC_OVL unsigned
check_for_inscrip_with_int(const struct object* obj, const char* inscrip,
                           int* ival)
{
  unsigned i = 0;
  size_t inlen = strlen(inscrip);
  const char* s;
  if (!obj->note) return 0;
  s = quark_str(obj->note);
  if (!s) return 0;
  do {
    s = strstr(s, inscrip);
    if (!s) break;
    if (isdigit(s[inlen])) {
      if (i == 0) {
        long inarg = strtol(s + inlen, 0, 10);
        *ival = (inarg < INT_MAX) ? (int)inarg : INT_MAX;
      }
      i++;
    }
    s++;
  } while (s);
  return i;
}
STATIC_OVL struct object_kind*
lookup_kind(int tval, int sval)
{
  int k;
  for (k = 0; k < z_info->k_max; k++) {
    struct object_kind* kind = &k_info[k];
    if (kind->tval == tval && kind->sval == sval) return kind;
  }
  msg("No object: %d:%d (%s)", tval, sval, tval_find_name(tval));
  return NULL;
}
STATIC_OVL struct object_kind*
lookup_selfmade_kind(int tval)
{
  int k;
  for (k = 0; k < z_info->k_max; k++) {
    struct object_kind* kind = &k_info[k];
    if (kind->tval == tval && kf_has(kind->kind_flags, KF_SMITH_ART)) {
      return kind;
    }
  }
  return NULL;
}
STATIC_OVL struct object_kind*
objkind_byid(int kidx)
{
  if (kidx < 0 || kidx >= z_info->k_max) return NULL;
  return &k_info[kidx];
}
STATIC_OVL const struct artifact*
lookup_artifact_name(const char* name)
{
  int i;
  int a_idx = -1;
  for (i = 0; i < z_info->a_max; i++) {
    const struct artifact* art = &a_info[i];
    if (art->name && streq(name, art->name)) return art;
    if (strlen(name) >= 3 && art->name && my_stristr(art->name, name) &&
        a_idx == -1)
      a_idx = i;
  }
  return a_idx > 0 ? &a_info[a_idx] : NULL;
}
STATIC_OVL struct ego_item*
lookup_ego_item(const char* name, int tval, int sval)
{
  int i;
  for (i = 0; i < z_info->e_max; i++) {
    struct ego_item* ego = &e_info[i];
    struct poss_item* poss_item = ego->poss_items;
    if (!ego->name) continue;
    if (!streq(name, ego->name)) continue;
    while (poss_item) {
      struct object_kind* kind = lookup_kind(tval, sval);
      if (kind->kidx == poss_item->kidx) {
        return ego;
      }
      poss_item = poss_item->next;
    }
  }
  return NULL;
}
STATIC_OVL int
lookup_sval(int tval, const char* name)
{
  int k;
  char* pe;
  unsigned long r = strtoul(name, &pe, 10);
  if (pe != name) {
    return (contains_only_spaces(pe) && r < INT_MAX) ? (int)r : -1;
  }
  for (k = 0; k < z_info->k_max; k++) {
    struct object_kind* kind = &k_info[k];
    char cmp_name[1024];
    if (!kind || !kind->name || kind->tval != tval) continue;
    obj_desc_name_format(cmp_name, sizeof cmp_name, 0, kind->name, 0, false);
    if (!my_stricmp(cmp_name, name)) return kind->sval;
  }
  return -1;
}
STATIC_OVL void
object_short_name(char* buf, size_t max, const char* name)
{
  size_t j, k;
  size_t len = strlen(name);
  for (j = 0, k = 0; j < len && k < max - 1; j++) {
    if (j == 0 && name[0] == '&' && name[1] == ' ') j += 2;
    if (name[j] == '~') continue;
    buf[k++] = name[j];
  }
  buf[k] = 0;
}
STATIC_OVL int
compare_types(const struct object* o1, const struct object* o2)
{
  if (o1->tval == o2->tval)
    return CMP(o1->sval, o2->sval);
  else
    return CMP(o1->tval, o2->tval);
}
STATIC_OVL int
compare_items(const struct object* o1, const struct object* o2)
{
  if (o1->artifact && o2->artifact) return compare_types(o1, o2);
  if (o1->artifact) return -1;
  if (o2->artifact) return 1;
  if (!object_flavor_is_aware(o1) && !object_flavor_is_aware(o2))
    return compare_types(o1, o2);
  if (!object_flavor_is_aware(o1)) return -1;
  if (!object_flavor_is_aware(o2)) return 1;
  if (o1->kind->cost == 0 && o2->kind->cost != 0) return 1;
  if (o1->kind->cost != 0 && o2->kind->cost == 0) return -1;
  return compare_types(o1, o2);
}
STATIC_OVL uint8_t
convert_depth_to_origin(int depth)
{
  if (depth < 0) return 0;
  if (depth > 255) return 255;
  return (uint8_t)depth;
}
STATIC_OVL int
obj_digging_score(const struct object* obj)
{
  int base = 0;
  if (!obj) return 0;
  if (of_has(obj->flags, OF_DIG_1)) base = 1;
  if (of_has(obj->flags, OF_DIG_2)) base = 2;
  return base + obj->modifiers[OBJ_MOD_TUNNEL];
}
STATIC_OVL bool
obj_can_dig(const struct object* obj)
{
  return obj_digging_score(obj) > 0;
}
STATIC_OVL bool
obj_has_charges(const struct object* obj)
{
  if (!tval_can_have_charges(obj)) return false;
  if (obj->pval <= 0) return false;
  return true;
}
STATIC_OVL bool
obj_can_refuel(const struct object* obj)
{
  const struct object* light = equipped_item_by_slot_name(player, "light");
  if (!light || of_has(light->flags, OF_NO_FUEL)) return false;
  if (of_has(light->flags, OF_TAKES_FUEL)) {
    if (tval_is_fuel(obj)) {
      return true;
    } else if (tval_is_light(obj) && of_has(obj->flags, OF_TAKES_FUEL) &&
               obj->timeout > 0) {
      return true;
    }
  }
  if (of_has(light->flags, OF_BURNS_OUT)) {
    if (tval_is_light(obj) && of_has(obj->flags, OF_BURNS_OUT) &&
        obj->timeout > 0) {
      return true;
    }
  }
  return false;
}
STATIC_OVL bool
obj_can_takeoff(const struct object* obj)
{
  return !obj_has_flag(obj, OF_CURSED) ||
         player_active_ability(player, "Curse Breaking");
}
STATIC_OVL bool
obj_can_throw(const struct object* obj)
{
  return !object_is_equipped(player->body, obj) ||
         (tval_is_melee_weapon(obj) && obj_can_takeoff(obj));
}
STATIC_OVL bool
obj_can_wear(const struct object* obj)
{
  return (wield_slot(obj) >= 0);
}
STATIC_OVL bool
obj_can_fire(const struct object* obj)
{
  return obj->tval == player->state.ammo_tval;
}
STATIC_OVL bool
obj_is_throwing(const struct object* obj)
{
  return of_has(obj->flags, OF_THROWING);
}
STATIC_OVL bool
obj_is_cursed(const struct object* obj)
{
  return of_has(obj->flags, OF_CURSED);
}
STATIC_OVL bool
obj_is_broken(const struct object* obj)
{
  return (object_value(obj) <= 0);
}
STATIC_OVL bool
obj_has_inscrip(const struct object* obj)
{
  return (obj->note ? true : false);
}
STATIC_OVL bool
obj_has_flag(const struct object* obj, int flag)
{
  if (of_has(obj->flags, flag)) {
    return true;
  }
  return false;
}
STATIC_OVL bool
obj_is_useable(const struct object* obj)
{
  if (tval_is_useable(obj)) return true;
  if (object_effect(obj)) return true;
  if (tval_is_wearable(obj) && !object_is_equipped(player->body, obj))
    return true;
  if (obj_can_refuel(obj)) return true;
  if (tval_is_ammo(obj)) return obj->tval == player->state.ammo_tval;
  return false;
}
STATIC_OVL bool
obj_nourishes(const struct object* obj)
{
  struct effect* effect = obj->kind->effect;
  if (!effect) return false;
  while (effect) {
    if (effect->index == EF_NOURISH && effect->dice) {
      random_value rv;
      (void)dice_roll(effect->dice, &rv);
      if (rv.base > 0) {
        return true;
      }
    }
    effect = effect->next;
  }
  return false;
}
STATIC_OVL struct effect*
object_effect(const struct object* obj)
{
  if (obj->kind->effect)
    return obj->kind->effect;
  else
    return NULL;
}
STATIC_OVL bool
obj_needs_aim(const struct object* obj)
{
  const struct effect* effect = object_effect(obj);
  return effect_aim(effect) || tval_is_ammo(obj);
}
STATIC_OVL bool
obj_allows_vertical_aim(const struct object* obj)
{
  const struct effect* effect = object_effect(obj);
  while (effect) {
    if (effect->index == EF_TERRAIN_BEAM && effect->other == 1) {
      return true;
    }
    effect = effect->next;
  }
  return false;
}
STATIC_OVL void
distribute_charges(struct object* source, struct object* dest, int amt)
{
  if (tval_can_have_charges(source)) {
    dest->pval = source->pval * amt / source->number;
    if (amt < source->number) source->pval -= dest->pval;
  }
}
STATIC_OVL void
uncurse_object(struct object* obj)
{
  if (!of_off(obj->flags, OF_CURSED)) {
    msg("Attempt to uncurse non-cursed object - please report this bug");
  }
  of_off(obj->known->flags, OF_CURSED);
  player->upkeep->notice |= (PN_COMBINE);
  player->upkeep->update |= (PU_BONUS);
  player->upkeep->redraw |= (PR_EQUIP | PR_INVEN);
}
STATIC_OVL bool
verify_object(const char* prompt, const struct object* obj,
              const struct player* p)
{
  char o_name[80];
  char out_val[160];
  object_desc(o_name, sizeof(o_name), obj, ODESC_PREFIX | ODESC_FULL, p);
  strnfmt(out_val, sizeof(out_val), "%s %s? ", prompt, o_name);
  return (get_check(out_val));
}
STATIC_OVL msg_tag_t
msg_tag_lookup(const char* tag)
{
  if (strncmp(tag, "name", 4) == 0) {
    return MSG_TAG_NAME;
  } else if (strncmp(tag, "kind", 4) == 0) {
    return MSG_TAG_KIND;
  } else if (strncmp(tag, "s", 1) == 0) {
    return MSG_TAG_VERB;
  } else if (strncmp(tag, "is", 2) == 0) {
    return MSG_TAG_VERB_IS;
  } else {
    return MSG_TAG_NONE;
  }
}
STATIC_OVL void
print_custom_message(const struct object* obj, const char* string, int msg_type,
                     const struct player* p)
{
  char buf[1024] = "\0";
  const char* next;
  const char* s;
  const char* tag;
  size_t end = 0;
  if (!string) return;
  next = strchr(string, '{');
  while (next) {
    strnfcat(buf, 1024, &end, "%.*s", (int)(next - string), string);
    s = next + 1;
    while (*s && isalpha((unsigned char)*s)) s++;
    if (*s == '}') {
      tag = next + 1;
      string = s + 1;
      switch (msg_tag_lookup(tag)) {
        case MSG_TAG_NAME:
          if (obj) {
            end += object_desc(buf, 1024, obj, ODESC_PREFIX | ODESC_BASE, p);
          } else {
            strnfcat(buf, 1024, &end, "hands");
          }
          break;
        case MSG_TAG_KIND:
          if (obj) {
            object_kind_name(&buf[end], 1024 - end, obj->kind, true);
            end += strlen(&buf[end]);
          } else {
            strnfcat(buf, 1024, &end, "hands");
          }
          break;
        case MSG_TAG_VERB:
          if (obj && obj->number == 1) {
            strnfcat(buf, 1024, &end, "s");
          }
          break;
        case MSG_TAG_VERB_IS:
          if ((!obj) || (obj->number > 1)) {
            strnfcat(buf, 1024, &end, "are");
          } else {
            strnfcat(buf, 1024, &end, "is");
          }
        default:
          break;
      }
    } else
      string = next + 1;
    next = strchr(string, '{');
  }
  strnfcat(buf, 1024, &end, "%s", string);
  msgt(msg_type, "%s", buf);
}
STATIC_OVL bool
is_artifact_created(const struct artifact* art)
{
  assert(art->aidx == aup_info[art->aidx].aidx);
  return aup_info[art->aidx].created;
}
STATIC_OVL bool
is_artifact_seen(const struct artifact* art)
{
  assert(art->aidx == aup_info[art->aidx].aidx);
  return aup_info[art->aidx].seen;
}
STATIC_OVL bool
is_artifact_everseen(const struct artifact* art)
{
  assert(art->aidx == aup_info[art->aidx].aidx);
  return aup_info[art->aidx].everseen;
}
STATIC_OVL void
mark_artifact_created(const struct artifact* art, bool created)
{
  assert(art->aidx == aup_info[art->aidx].aidx);
  aup_info[art->aidx].created = created;
}
STATIC_OVL void
mark_artifact_seen(const struct artifact* art, bool seen)
{
  assert(art->aidx == aup_info[art->aidx].aidx);
  aup_info[art->aidx].seen = seen;
}
STATIC_OVL void
mark_artifact_everseen(const struct artifact* art, bool seen)
{
  assert(art->aidx == aup_info[art->aidx].aidx);
  aup_info[art->aidx].everseen = seen;
}
STATIC_OVL void
write_abilities(ang_file* fff, const struct ability* abils)
{
  struct ability* ability = (struct ability*)abils;
  static const char* skill_names[] = {"Melee",    "Archery",    "Evasion",
                                      "Stealth",  "Perception", "Will",
                                      "Smithing", "Song",       ""};
  while (ability) {
    file_putf(fff, "ability:");
    file_putf(fff, "%s:", skill_names[ability->skill]);
    file_putf(fff, "%s\n", ability->name);
    ability = ability->next;
  }
}
STATIC_OVL void
write_self_made_artefact_entries(ang_file* fff)
{
  int i;
  static const char* obj_flags[] = {"NONE",
                                    "SUST_STR",
                                    "SUST_DEX",
                                    "SUST_CON",
                                    "SUST_GRA",
                                    "PROT_FEAR",
                                    "PROT_BLIND",
                                    "PROT_CONF",
                                    "PROT_STUN",
                                    "PROT_HALLU",
                                    "SLOW_DIGEST",
                                    "REGEN",
                                    "SEE_INVIS",
                                    "FREE_ACT",
                                    "RADIANCE",
                                    "LIGHT",
                                    "SPEED",
                                    "SHARPNESS",
                                    "SHARPNESS2",
                                    "VAMPIRIC",
                                    "BURNS_OUT",
                                    "TAKES_FUEL",
                                    "NO_FUEL",
                                    "COWARDICE",
                                    "HUNGER",
                                    "DARKNESS",
                                    "DANGER",
                                    "HAUNTED",
                                    "AGGRAVATE",
                                    "CURSED",
                                    "DIG_1",
                                    "DIG_2",
                                    "THROWING",
                                    "INDESTRUCTIBLE",
                                    "NO_SMITHING",
                                    "NO_RANDOM",
                                    "MITHRIL",
                                    "AXE",
                                    "POLEARM",
                                    "ENCHANTABLE",
                                    "HAND_AND_A_HALF",
                                    "TWO_HANDED",
                                    "MAX",
                                    NULL};
  for (i = z_info->a_max - player->self_made_arts; i < z_info->a_max; i++) {
    const struct artifact* art = &a_info[i];
    char name[120] = "";
    struct object_kind* kind = lookup_kind(art->tval, art->sval);
    int j;
    if (!art->name) continue;
    file_putf(fff, "# %s\n", art->text);
    file_putf(fff, "name:%s\n", art->name);
    object_short_name(name, sizeof name, kind->name);
    file_putf(fff, "base-object:%s:%s\n", tval_find_name(art->tval), name);
    if (kind->kidx >= z_info->ordinary_kind_max) {
      const char* attr = attr_to_text(kind->d_attr);
      file_putf(fff, "graphics:%c:%s\n", kind->d_char, attr);
    }
    file_putf(fff, "pval:%d\n", art->pval);
    file_putf(fff, "depth:%d\n", art->level);
    file_putf(fff, "rarity:%d\n", art->rarity);
    file_putf(fff, "weight:%d\n", art->weight);
    file_putf(fff, "cost:%d\n", art->cost);
    file_putf(fff, "attack:%d:%dd%d\n", art->att, art->dd, art->ds);
    file_putf(fff, "defence:%d:%dd%d\n", art->evn, art->pd, art->ps);
    write_flags(fff, "flags:", art->flags, OF_SIZE, obj_flags);
    write_mods(fff, art->modifiers);
    write_elements(fff, art->el_info);
    if (art->slays) {
      for (j = 1; j < z_info->slay_max; j++) {
        if (art->slays[j]) {
          file_putf(fff, "slay:%s\n", slays[j].code);
        }
      }
    }
    if (art->brands) {
      for (j = 1; j < z_info->brand_max; j++) {
        if (art->brands[j]) {
          file_putf(fff, "brand:%s\n", brands[j].code);
        }
      }
    }
    write_abilities(fff, art->abilities);
    file_putf(fff, "\n");
  }
}
STATIC_OVL const char*
option_type_name(int page)
{
  const char* result;
  switch (page) {
    case OP_INTERFACE:
      result = "interface";
      break;
    case OP_BIRTH:
      result = "birth";
      break;
    case OP_CHEAT:
      result = "cheat";
      break;
    case OP_SCORE:
      result = "score";
      break;
    case OP_SPECIAL:
      result = "special";
      break;
    default:
      result = "unknown";
      break;
  }
  return result;
}
STATIC_OVL const char*
option_name(int opt)
{
  if (opt >= OPT_MAX) return NULL;
  return options[opt].name;
}
STATIC_OVL const char*
option_desc(int opt)
{
  if (opt >= OPT_MAX) return NULL;
  return options[opt].description;
}
STATIC_OVL int
option_type(int opt)
{
  if (opt >= OPT_MAX) return 0;
  return options[opt].type;
}
STATIC_OVL bool
option_is_cheat(int opt)
{
  return (option_type(opt) == OP_CHEAT);
}
STATIC_OVL bool
option_set(const char* name, int val)
{
  size_t opt;
  for (opt = 0; opt < OPT_MAX; opt++) {
    if (!options[opt].name || !streq(options[opt].name, name)) continue;
    player->opts.opt[opt] = val ? true : false;
    if (val && option_is_cheat(opt)) player->opts.opt[opt + 1] = true;
    return true;
  }
  return false;
}
STATIC_OVL void
options_init_cheat(void)
{
  int i;
  for (i = 0; i < OPT_MAX; i++) {
    if (option_is_cheat(i)) {
      player->opts.opt[i] = false;
      player->opts.opt[i + 1] = false;
    }
  }
}
STATIC_OVL void
options_init_defaults(struct player_options* opts)
{
  int opt;
  for (opt = 0; opt < OPT_MAX; opt++) (*opts).opt[opt] = options[opt].normal;
  options_restore_custom(opts, OP_BIRTH);
  options_restore_custom(opts, OP_INTERFACE);
  (*opts).delay_factor = 40;
  (*opts).hitpoint_warn = 3;
}
STATIC_OVL bool
options_save_custom(struct player_options* opts, int page)
{
  const char* page_name = option_type_name(page);
  bool success = true;
  char path[1024], file_name[80];
  ang_file* f;
  strnfmt(file_name, sizeof(file_name), "customized_%s_options.txt", page_name);
  path_build(path, sizeof(path), ANGBAND_DIR_USER, file_name);
  f = file_open(path, MODE_WRITE, FTYPE_TEXT);
  if (f) {
    int opt;
    if (!file_putf(f, "# These are customized defaults for the %s options.\n",
                   page_name)) {
      success = false;
    }
    if (!file_put(f,
                  "# All lines begin with \"option:\" followed by the internal "
                  "option name.\n")) {
      success = false;
    }
    if (!file_put(f,
                  "# After the name is a colon followed by yes or no for the "
                  "option's state.\n")) {
      success = false;
    }
    for (opt = 0; opt < OPT_MAX; opt++) {
      if (options[opt].type == page) {
        if (!file_putf(f, "# %s\n", options[opt].description)) {
          success = false;
        }
        if (!file_putf(f, "option:%s:%s\n", options[opt].name,
                       ((*opts).opt[opt]) ? "yes" : "no")) {
          success = false;
        }
      }
    }
    if (!file_close(f)) {
      success = false;
    }
  } else {
    success = false;
  }
  return success;
}
STATIC_OVL bool
options_restore_custom(struct player_options* opts, int page)
{
  const char* page_name = option_type_name(page);
  char path[1024], buf[1024], file_name[80];
  ang_file* f;
  int linenum;
  strnfmt(file_name, sizeof(file_name), "customized_%s_options.txt", page_name);
  path_build(path, sizeof(path), ANGBAND_DIR_USER, file_name);
  if (!file_exists(path)) {
    options_restore_maintainer(opts, page);
    return true;
  }
  f = file_open(path, MODE_READ, FTYPE_TEXT);
  if (!f) {
    return false;
  }
  linenum = 1;
  while (file_getl(f, buf, sizeof(buf))) {
    char *sub = strstr(buf, "option:"), *com;
    int opt;
    if (!sub) {
      sub = strchr(buf, '#');
      if (sub) {
        *sub = '\0';
      }
      if (!contains_only_spaces(buf)) {
        msg("Line %d of the customized %s options is "
            "not parseable.",
            linenum, page_name);
      }
      ++linenum;
      continue;
    }
    *sub = '\0';
    com = strchr(buf, '#');
    if (com) {
      *com = '\0';
      if (!contains_only_spaces(buf)) {
        msg("Line %d of the customized %s options is "
            "not parseable.",
            linenum, page_name);
      }
      ++linenum;
      continue;
    }
    if (!contains_only_spaces(buf)) {
      msg("Line %d of the customized %s options is not "
          "parseable.",
          linenum, page_name);
      ++linenum;
      continue;
    }
    sub += 7;
    opt = 0;
    while (1) {
      size_t lname;
      if (opt >= OPT_MAX) {
        msg("Unrecognized option at line %d of the "
            "customized %s options.",
            linenum, page_name);
        break;
      }
      if (options[opt].type != page || !options[opt].name) {
        ++opt;
        continue;
      }
      lname = strlen(options[opt].name);
      if (strncmp(options[opt].name, sub, lname) == 0 && sub[lname] == ':') {
        if (strncmp("yes", sub + lname + 1, 3) == 0 &&
            contains_only_spaces(sub + lname + 4)) {
          (*opts).opt[opt] = true;
        } else if (strncmp("no", sub + lname + 1, 2) == 0 &&
                   contains_only_spaces(sub + lname + 3)) {
          (*opts).opt[opt] = false;
        } else {
          msg("Value at line %d of the "
              "customized %s options is not "
              "yes or no.",
              linenum, page_name);
        }
        break;
      }
      ++opt;
    }
    ++linenum;
  }
  if (!file_close(f)) {
    return false;
  }
  return true;
}
STATIC_OVL void
options_restore_maintainer(struct player_options* opts, int page)
{
  int opt;
  for (opt = 0; opt < OPT_MAX; opt++)
    if (options[opt].type == page) {
      (*opts).opt[opt] = options[opt].normal;
    }
}
STATIC_OVL void
options_list_challenge(void)
{
  int opt;
  for (opt = 0; opt < OPT_MAX; opt++) {
    if ((options[opt].type == OP_BIRTH) && (player->opts.opt[opt] == true)) {
      history_add(player, format("Challenge: %s", option_desc(opt)),
                  HIST_CHALLENGE_OPTS);
    }
  }
}
STATIC_OVL void
init_options(void)
{
  int opt, page;
  for (page = 0; page < OPT_PAGE_MAX; page++) {
    int page_opts = 0;
    for (opt = 0; opt < OPT_MAX; opt++) {
      if ((options[opt].type == page) && (page_opts < OPT_PAGE_PER))
        option_page[page][page_opts++] = opt;
    }
    while (page_opts < OPT_PAGE_PER) option_page[page][page_opts++] = OPT_none;
  }
}
STATIC_OVL struct parser*
parser_new(void)
{
  struct parser* p = mem_zalloc(sizeof *p);
  return p;
}
STATIC_OVL struct parser_hook*
findhook(struct parser* p, const char* dir)
{
  struct parser_hook* h = p->hooks;
  while (h) {
    if (streq(h->dir, dir)) break;
    h = h->next;
  }
  return h;
}
STATIC_OVL void
parser_freeold(struct parser* p)
{
  struct parser_value* v;
  while (p->fhead) {
    int t = p->fhead->spec.type & ~PARSE_T_OPT;
    v = (struct parser_value*)p->fhead->spec.next;
    if (t == PARSE_T_SYM || t == PARSE_T_STR) mem_free(p->fhead->u.sval);
    mem_free(p->fhead);
    p->fhead = v;
  }
}
STATIC_OVL bool
parse_random(const char* str, random_value* bonus)
{
  bool negative = false;
  int values[4] = {0, 0, 0, 0};
  int i = 0, min_i = 1;
  if (str[0] == '-') {
    negative = true;
    ++str;
  }
  while (1) {
    if (*str == 'd') {
      if (i > 2) {
        return false;
      }
      if (i < 2) {
        i = 2;
        values[1] = 1;
      }
      min_i = 3;
      ++str;
    } else if (*str == 'M') {
      if (i == 2) {
        return false;
      }
      i = 3;
      min_i = 4;
      ++str;
    } else {
      char* pe;
      unsigned long uv = strtoul(str, &pe, 10);
      if (pe == str) {
        if (!contains_only_spaces(str) || i < min_i) {
          return false;
        }
        break;
      } else if (uv > INT_MAX || *str == '+') {
        return false;
      }
      str = pe;
      if (i == 0) {
        if (*str == 'd') {
          i = 1;
        } else if (*str == '+') {
          ++str;
          min_i = 3;
        } else {
          if (!contains_only_spaces(pe)) {
            return false;
          }
          values[0] = (int)uv;
          break;
        }
      } else if (i == 4) {
        return false;
      }
      values[i] = (int)uv;
      ++i;
    }
  }
  bonus->base = values[0];
  bonus->dice = values[1];
  bonus->sides = values[2];
  bonus->m_bonus = values[3];
  if (negative) {
    bonus->base *= -1;
    bonus->base -= bonus->m_bonus;
    bonus->base -= bonus->dice * (bonus->sides + 1);
  }
  return true;
}
STATIC_OVL enum parser_error
parser_parse(struct parser* p, const char* line)
{
  char* cline;
  char* tok;
  struct parser_hook* h;
  struct parser_spec* s;
  struct parser_value* v;
  char* sp = NULL;
  assert(p);
  assert(line);
  parser_freeold(p);
  p->lineno++;
  p->colno = 1;
  p->fhead = NULL;
  p->ftail = NULL;
  while (*line && (isspace(*line))) line++;
  if (!*line || *line == '#') return PARSE_ERROR_NONE;
  cline = string_make(line);
  tok = strtok(cline, ":");
  if (!tok) {
    mem_free(cline);
    p->error = PARSE_ERROR_MISSING_FIELD;
    return PARSE_ERROR_MISSING_FIELD;
  }
  h = findhook(p, tok);
  if (!h) {
    my_strcpy(p->errmsg, tok, sizeof(p->errmsg));
    p->error = PARSE_ERROR_UNDEFINED_DIRECTIVE;
    mem_free(cline);
    return PARSE_ERROR_UNDEFINED_DIRECTIVE;
  }
  for (s = h->fhead; s; s = s->next) {
    int t = s->type & ~PARSE_T_OPT;
    p->colno++;
    if (t == PARSE_T_INT || t == PARSE_T_SYM || t == PARSE_T_RAND ||
        t == PARSE_T_UINT) {
      tok = strtok(sp, ":");
      sp = NULL;
    } else if (t == PARSE_T_CHAR) {
      tok = strtok(sp, "");
      if (tok) sp = tok + 2;
    } else {
      tok = strtok(sp, "");
      sp = NULL;
    }
    if (!tok) {
      if (!(s->type & PARSE_T_OPT)) {
        my_strcpy(p->errmsg, s->name, sizeof(p->errmsg));
        p->error = PARSE_ERROR_MISSING_FIELD;
        mem_free(cline);
        return PARSE_ERROR_MISSING_FIELD;
      }
      break;
    }
    v = mem_alloc(sizeof *v);
    v->spec.next = NULL;
    v->spec.type = s->type;
    v->spec.name = s->name;
    if (t == PARSE_T_INT) {
      char* z = NULL;
      v->u.ival = strtol(tok, &z, 0);
      if (z == tok) {
        mem_free(v);
        mem_free(cline);
        my_strcpy(p->errmsg, s->name, sizeof(p->errmsg));
        p->error = PARSE_ERROR_NOT_NUMBER;
        return PARSE_ERROR_NOT_NUMBER;
      }
    } else if (t == PARSE_T_UINT) {
      char* z = NULL;
      v->u.uval = strtoul(tok, &z, 0);
      if (z == tok || *tok == '-') {
        mem_free(v);
        mem_free(cline);
        my_strcpy(p->errmsg, s->name, sizeof(p->errmsg));
        p->error = PARSE_ERROR_NOT_NUMBER;
        return PARSE_ERROR_NOT_NUMBER;
      }
    } else if (t == PARSE_T_CHAR) {
      text_mbstowcs(&v->u.cval, tok, 1);
    } else if (t == PARSE_T_SYM || t == PARSE_T_STR) {
      v->u.sval = string_make(tok);
    } else if (t == PARSE_T_RAND) {
      if (!parse_random(tok, &v->u.rval)) {
        mem_free(v);
        mem_free(cline);
        my_strcpy(p->errmsg, s->name, sizeof(p->errmsg));
        p->error = PARSE_ERROR_NOT_RANDOM;
        return PARSE_ERROR_NOT_RANDOM;
      }
    }
    if (!p->fhead)
      p->fhead = v;
    else
      p->ftail->spec.next = &v->spec;
    p->ftail = v;
  }
  mem_free(cline);
  p->error = h->func(p);
  return p->error;
}
STATIC_OVL void*
parser_priv(struct parser* p)
{
  return p->priv;
}
STATIC_OVL void
parser_setpriv(struct parser* p, void* v)
{
  p->priv = v;
}
STATIC_OVL int
parse_type(const char* s)
{
  int rv = 0;
  if (s[0] == '?') {
    rv |= PARSE_T_OPT;
    s++;
  }
  if (streq(s, "int")) return PARSE_T_INT | rv;
  if (streq(s, "sym")) return PARSE_T_SYM | rv;
  if (streq(s, "str")) return PARSE_T_STR | rv;
  if (streq(s, "rand")) return PARSE_T_RAND | rv;
  if (streq(s, "uint")) return PARSE_T_UINT | rv;
  if (streq(s, "char")) return PARSE_T_CHAR | rv;
  return PARSE_T_NONE;
}
STATIC_OVL void
clean_specs(struct parser_hook* h)
{
  struct parser_spec* s;
  mem_free(h->dir);
  while (h->fhead) {
    s = h->fhead;
    h->fhead = h->fhead->next;
    mem_free((void*)s->name);
    mem_free(s);
  }
}
STATIC_OVL void
parser_destroy(struct parser* p)
{
  struct parser_hook* h;
  parser_freeold(p);
  while (p->hooks) {
    h = p->hooks->next;
    clean_specs(p->hooks);
    mem_free(p->hooks);
    p->hooks = h;
  }
  mem_free(p);
}
STATIC_OVL errr
parse_specs(struct parser_hook* h, char* fmt)
{
  char* name;
  char* stype = NULL;
  int type;
  struct parser_spec* s;
  assert(h);
  assert(fmt);
  name = strtok(fmt, " ");
  if (!name) return -EINVAL;
  h->dir = string_make(name);
  h->fhead = NULL;
  h->ftail = NULL;
  while (name) {
    stype = strtok(NULL, " ");
    if (!stype) break;
    name = strtok(NULL, " ");
    if (!name) {
      clean_specs(h);
      return -EINVAL;
    }
    type = parse_type(stype);
    if (type == PARSE_T_NONE) {
      clean_specs(h);
      return -EINVAL;
    }
    if (!(type & PARSE_T_OPT) && h->ftail && (h->ftail->type & PARSE_T_OPT)) {
      clean_specs(h);
      return -EINVAL;
    }
    if (h->ftail && ((h->ftail->type & ~PARSE_T_OPT) == PARSE_T_STR)) {
      clean_specs(h);
      return -EINVAL;
    }
    s = mem_alloc(sizeof *s);
    s->type = type;
    s->name = string_make(name);
    s->next = NULL;
    if (h->fhead)
      h->ftail->next = s;
    else
      h->fhead = s;
    h->ftail = s;
  }
  return 0;
}
STATIC_OVL errr
parser_reg(struct parser* p, const char* fmt,
           enum parser_error (*func)(struct parser* p))
{
  errr r;
  char* cfmt;
  struct parser_hook* h;
  assert(p);
  assert(fmt);
  assert(func);
  h = mem_alloc(sizeof *h);
  cfmt = string_make(fmt);
  h->next = p->hooks;
  h->func = func;
  r = parse_specs(h, cfmt);
  if (r) {
    mem_free(h);
    mem_free(cfmt);
    return r;
  }
  p->hooks = h;
  mem_free(cfmt);
  return 0;
}
STATIC_OVL enum parser_error
ignored(struct parser* p)
{
  return PARSE_ERROR_NONE;
}
STATIC_OVL bool
parser_hasval(struct parser* p, const char* name)
{
  struct parser_value* v;
  for (v = p->fhead; v; v = (struct parser_value*)v->spec.next) {
    if (streq(v->spec.name, name)) return true;
  }
  return false;
}
STATIC_OVL struct parser_value*
parser_getval(struct parser* p, const char* name)
{
  struct parser_value* v;
  for (v = p->fhead; v; v = (struct parser_value*)v->spec.next) {
    if (streq(v->spec.name, name)) {
      return v;
    }
  }
  quit_fmt("parser_getval error: name is %s\n", name);
  return 0;
}
STATIC_OVL const char*
parser_getsym(struct parser* p, const char* name)
{
  struct parser_value* v = parser_getval(p, name);
  assert((v->spec.type & ~PARSE_T_OPT) == PARSE_T_SYM);
  return v->u.sval;
}
STATIC_OVL int
parser_getint(struct parser* p, const char* name)
{
  struct parser_value* v = parser_getval(p, name);
  assert((v->spec.type & ~PARSE_T_OPT) == PARSE_T_INT);
  return v->u.ival;
}
STATIC_OVL unsigned int
parser_getuint(struct parser* p, const char* name)
{
  struct parser_value* v = parser_getval(p, name);
  assert((v->spec.type & ~PARSE_T_OPT) == PARSE_T_UINT);
  return v->u.uval;
}
STATIC_OVL const char*
parser_getstr(struct parser* p, const char* name)
{
  struct parser_value* v = parser_getval(p, name);
  assert((v->spec.type & ~PARSE_T_OPT) == PARSE_T_STR);
  return v->u.sval;
}
STATIC_OVL struct random
parser_getrand(struct parser* p, const char* name)
{
  struct parser_value* v = parser_getval(p, name);
  assert((v->spec.type & ~PARSE_T_OPT) == PARSE_T_RAND);
  return v->u.rval;
}
STATIC_OVL wchar_t
parser_getchar(struct parser* p, const char* name)
{
  struct parser_value* v = parser_getval(p, name);
  assert((v->spec.type & ~PARSE_T_OPT) == PARSE_T_CHAR);
  return v->u.cval;
}
STATIC_OVL int
parser_getstate(struct parser* p, struct parser_state* s)
{
  s->error = p->error;
  s->line = p->lineno;
  s->col = p->colno;
  s->msg = p->errmsg;
  return s->error != PARSE_ERROR_NONE;
}
STATIC_OVL void
parser_setstate(struct parser* p, unsigned int col, const char* msg)
{
  p->colno = col;
  my_strcpy(p->errmsg, msg, sizeof(p->errmsg));
}
STATIC_OVL enum parser_error
parse_ability_skill(struct parser* p)
{
  const char* name = parser_getstr(p, "name");
  int index = lookup_skill(name);
  if (index < 0) return PARSE_ERROR_UNRECOGNISED_SKILL;
  skill_index = (unsigned int)index;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_ability_name(struct parser* p)
{
  const char* name = parser_getstr(p, "name");
  struct ability* last = parser_priv(p);
  struct ability* a = mem_zalloc(sizeof *a);
  if (last) {
    last->next = a;
  } else {
    abilities = a;
  }
  parser_setpriv(p, a);
  a->name = string_make(name);
  a->skill = skill_index;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_ability_level(struct parser* p)
{
  struct ability* a = parser_priv(p);
  if (!a) return PARSE_ERROR_MISSING_RECORD_HEADER;
  a->level = parser_getint(p, "level");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_ability_prereq(struct parser* p)
{
  int skill = lookup_skill(parser_getsym(p, "skill"));
  const char* name = parser_getsym(p, "ability");
  struct ability* a = parser_priv(p);
  int i;
  if (!a) return PARSE_ERROR_MISSING_RECORD_HEADER;
  if (skill < 0) return PARSE_ERROR_INVALID_SKILL;
  prereq_list[prereq_num].skill = skill;
  prereq_list[prereq_num].name = string_make(name);
  for (i = 0; i < MAX_PREREQS; i++) {
    if (!a->prereq_index[i]) break;
  }
  if (i == MAX_PREREQS) return PARSE_ERROR_TOO_MANY_ABILITY_PREREQS;
  a->prereq_index[i] = prereq_num;
  prereq_num++;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_ability_type(struct parser* p)
{
  struct poss_item* poss;
  int i;
  int tval = tval_find_idx(parser_getstr(p, "tval"));
  bool found_one_kind = false;
  struct ability* a = parser_priv(p);
  if (!a) return PARSE_ERROR_MISSING_RECORD_HEADER;
  if (tval < 0) return PARSE_ERROR_UNRECOGNISED_TVAL;
  for (i = 0; i < z_info->k_max; i++) {
    if (k_info[i].tval != tval) continue;
    poss = mem_zalloc(sizeof(struct poss_item));
    poss->kidx = i;
    poss->next = a->poss_items;
    a->poss_items = poss;
    found_one_kind = true;
  }
  if (!found_one_kind) return PARSE_ERROR_NO_KIND_FOR_ABILITY;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_ability_item(struct parser* p)
{
  struct poss_item* poss;
  int tval = tval_find_idx(parser_getsym(p, "tval"));
  int sval = lookup_sval(tval, parser_getsym(p, "sval"));
  struct ability* a = parser_priv(p);
  if (!a) return PARSE_ERROR_MISSING_RECORD_HEADER;
  if (tval < 0) return PARSE_ERROR_UNRECOGNISED_TVAL;
  if (sval < 0) return PARSE_ERROR_UNRECOGNISED_SVAL;
  poss = mem_zalloc(sizeof(struct poss_item));
  poss->kidx = lookup_kind(tval, sval)->kidx;
  poss->next = a->poss_items;
  a->poss_items = poss;
  if (poss->kidx <= 0) return PARSE_ERROR_INVALID_ITEM_NUMBER;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_ability_desc(struct parser* p)
{
  struct ability* a = parser_priv(p);
  if (!a) return PARSE_ERROR_MISSING_RECORD_HEADER;
  a->desc = string_append(a->desc, parser_getstr(p, "desc"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_parse_ability(void)
{
  struct parser* p = parser_new();
  parser_setpriv(p, NULL);
  prereq_num = 1;
  parser_reg(p, "skill str name", parse_ability_skill);
  parser_reg(p, "name str name", parse_ability_name);
  parser_reg(p, "level int level", parse_ability_level);
  parser_reg(p, "prerequisite sym skill sym ability", parse_ability_prereq);
  parser_reg(p, "type str tval", parse_ability_type);
  parser_reg(p, "item sym tval sym sval", parse_ability_item);
  parser_reg(p, "desc str desc", parse_ability_desc);
  return p;
}
STATIC_OVL errr
run_parse_ability(struct parser* p)
{
  return parse_file_quit_not_found(p, "ability");
}
STATIC_OVL errr
finish_parse_ability(struct parser* p)
{
  struct ability* a;
  for (a = abilities; a; a = a->next) {
    int i = 0;
    while (a->prereq_index[i]) {
      int idx = a->prereq_index[i];
      struct ability* pre = mem_zalloc(sizeof *pre);
      struct ability* stored =
          lookup_ability(prereq_list[idx].skill, prereq_list[idx].name);
      if (!stored) return PARSE_ERROR_INVALID_ABILITY;
      memcpy(pre, stored, sizeof(*pre));
      pre->next = a->prerequisites;
      a->prerequisites = pre;
      i++;
    }
  }
  while (prereq_num > 1) {
    --prereq_num;
    string_free((char*)prereq_list[prereq_num].name);
    prereq_list[prereq_num].name = NULL;
  }
  parser_destroy(p);
  return 0;
}
STATIC_OVL void
cleanup_ability(void)
{
  struct ability* a = abilities;
  while (a) {
    struct ability* a_next = a->next;
    struct ability* pre = a->prerequisites;
    struct poss_item* poss = a->poss_items;
    while (poss) {
      struct poss_item* poss_next = poss->next;
      mem_free(poss);
      poss = poss_next;
    }
    while (pre) {
      struct ability* pre_next = pre->next;
      mem_free(pre);
      pre = pre_next;
    }
    string_free(a->name);
    string_free(a->desc);
    mem_free(a);
    a = a_next;
  }
}
STATIC_OVL struct ability*
lookup_ability(int skill, const char* name)
{
  struct ability* ability = abilities;
  if (skill < 0) {
    msg("Invalid skill index passed to lookup_ability()!");
    return NULL;
  }
  while (ability) {
    if ((ability->skill == skill) && streq(ability->name, name)) {
      return ability;
    }
    ability = ability->next;
  }
  return NULL;
}
STATIC_OVL int
count_abilities(struct ability* ability, int skill)
{
  int count = 0;
  assert(0 <= skill && skill <= SKILL_MAX);
  while (ability) {
    if ((skill == SKILL_MAX) || (skill == ability->skill)) {
      count++;
    }
    ability = ability->next;
  }
  return count;
}
STATIC_OVL bool
ability_is_active(const struct ability* ability)
{
  return ability->active;
}
STATIC_OVL int
test_ability(const char* name, struct ability* test, ability_predicate pred)
{
  int skill, count = 0;
  bool found = false;
  if (!test) return 0;
  for (skill = 0; skill < SKILL_MAX; skill++) {
    struct ability* ability = lookup_ability(skill, name);
    if (ability) {
      struct ability* thisa = test;
      found = true;
      while (thisa) {
        if (streq(thisa->name, name) && (thisa->skill == skill)) {
          if (!pred || (pred && pred(thisa))) {
            count++;
          }
        }
        thisa = thisa->next;
      }
    }
  }
  if (!found) {
    assert(0);
  }
  return count;
}
STATIC_OVL bool
applicable_ability(struct ability* ability, struct object* obj)
{
  struct poss_item* poss = ability->poss_items;
  for (poss = ability->poss_items; poss; poss = poss->next) {
    if (poss->kidx == obj->kind->kidx) return true;
  }
  if (of_has(obj->flags, OF_THROWING) && (ability->skill == SKILL_MELEE) &&
      streq(ability->name, "Throwing Mastery")) {
    return true;
  }
  return false;
}
STATIC_OVL struct ability*
locate_ability(struct ability* ability, struct ability* test)
{
  while (ability) {
    if ((ability->skill == test->skill) && streq(ability->name, test->name))
      break;
    ability = ability->next;
  }
  return ability;
}
STATIC_OVL void
add_ability(struct ability** set, struct ability* add)
{
  struct ability* new;
  new = *set;
  if (locate_ability(new, add)) return;
  new = mem_zalloc(sizeof(*new));
  memcpy(new, add, sizeof(*new));
  new->next = *set;
  *set = new;
}
STATIC_OVL void
activate_ability(struct ability** set, struct ability* activate)
{
  struct ability* ability;
  for (ability = *set; ability; ability = ability->next) {
    if (streq(ability->name, activate->name)) {
      ability->active = true;
      break;
    }
  }
}
STATIC_OVL void
remove_ability(struct ability** ability, struct ability* remove)
{
  struct ability *current = *ability, *prev = NULL, *next = NULL;
  while (current) {
    next = current->next;
    if ((current->skill == remove->skill) &&
        streq(current->name, remove->name)) {
      break;
    }
    prev = current;
    current = next;
  }
  if (current) {
    if (prev) {
      prev->next = next;
    } else {
      *ability = next;
    }
    mem_free(current);
  }
}
STATIC_OVL bool
player_has_ability(struct player* p, struct ability* ability)
{
  if (!ability) return false;
  if (locate_ability(p->abilities, ability)) return true;
  if (locate_ability(p->item_abilities, ability)) return true;
  return false;
}
STATIC_OVL int
player_active_ability(struct player* p, const char* name)
{
  int count;
  if (!p) return 0;
  count = test_ability(name, p->abilities, ability_is_active);
  count += test_ability(name, p->item_abilities, ability_is_active);
  return count;
}
STATIC_OVL bool
player_has_prereq_abilities(struct player* p, struct ability* ability)
{
  struct ability* prereqs = ability->prerequisites;
  if (prereqs) {
    while (prereqs) {
      struct ability* possessed = p->abilities;
      while (possessed) {
        if (streq(possessed->name, prereqs->name) &&
            (possessed->skill == prereqs->skill)) {
          return true;
        }
        possessed = possessed->next;
      }
      prereqs = prereqs->next;
    }
    return false;
  }
  return true;
}
STATIC_OVL int
player_ability_cost(struct player* p, struct ability* ability)
{
  int skill = ability->skill;
  int num = count_abilities(p->abilities, skill);
  int cost = (num + 1) * z_info->ability_cost;
  int affinity = p->race->skill_adj[skill] + p->house->skill_adj[skill];
  cost -= affinity * z_info->ability_cost;
  return MAX(0, cost);
}
STATIC_OVL bool
player_can_gain_ability(struct player* p, struct ability* ability)
{
  return player_ability_cost(p, ability) <= p->new_exp;
}
STATIC_OVL bool
player_gain_ability(struct player* p, struct ability* ability)
{
  struct ability* new;
  int cost = player_ability_cost(p, ability);
  if (cost > p->new_exp) {
    msg("You do not have enough experience to acquire this ability.");
    return false;
  }
  if (!get_check("Are you sure you wish to gain this ability? ")) {
    return false;
  }
  p->new_exp -= cost;
  add_ability(&p->abilities, ability);
  new = locate_ability(p->abilities, ability);
  new->active = true;
  p->upkeep->update |= (PU_BONUS);
  p->upkeep->redraw |= (PR_EXP);
  return true;
}
STATIC_OVL void
release_ability_list(struct ability* head)
{
  while (head) {
    struct ability* tgt = head;
    head = head->next;
    mem_free(tgt);
  }
}
STATIC_OVL struct ability*
copy_ability_list(const struct ability* head)
{
  struct ability *dest_head, *dest_tail;
  if (!head) {
    return NULL;
  }
  dest_head = mem_alloc(sizeof(*dest_head));
  memcpy(dest_head, head, sizeof(*dest_head));
  dest_tail = dest_head;
  while (head->next) {
    head = head->next;
    dest_tail->next = mem_alloc(sizeof(*(dest_tail->next)));
    dest_tail = dest_tail->next;
    memcpy(dest_tail, head, sizeof(*dest_tail));
  }
  dest_tail->next = NULL;
  return dest_head;
}
STATIC_OVL bool
valid_charge(struct player* p, struct loc grid, int attack_type)
{
  int d, i;
  int delta_y = grid.y - p->grid.y;
  int delta_x = grid.x - p->grid.x;
  if (player_active_ability(p, "Charge") && (p->state.speed > 1) &&
      ((attack_type == ATT_MAIN) || (attack_type == ATT_FLANKING) ||
       (attack_type == ATT_CONTROLLED_RETREAT))) {
    for (i = -1; i <= 1; i++) {
      d = cycle[chome[dir_from_delta(delta_y, delta_x)] + i];
      if (p->previous_action[1] == d) {
        return true;
      }
    }
  }
  return false;
}
STATIC_OVL void
possible_follow_through(struct player* p, struct loc grid, int attack_type)
{
  int d, i;
  struct loc new_grid;
  int delta_y = grid.y - p->grid.y;
  int delta_x = grid.x - p->grid.x;
  if (player_active_ability(p, "Follow-Through") && !p->timed[TMD_CONFUSED] &&
      ((attack_type == ATT_MAIN) || (attack_type == ATT_FLANKING) ||
       (attack_type == ATT_CONTROLLED_RETREAT) ||
       (attack_type == ATT_FOLLOW_THROUGH))) {
    for (i = 1; i < 8; i++) {
      struct monster* mon;
      d = cycle[chome[dir_from_delta(delta_y, delta_x)] + i];
      new_grid = loc_sum(p->grid, ddgrid[d]);
      mon = square_monster(cave, new_grid);
      if (mon && monster_is_visible(mon) &&
          (!OPT(p, forgo_attacking_unwary) ||
           (mon->alertness >= ALERTNESS_ALERT))) {
        msg("You continue your attack!");
        py_attack_real(p, new_grid, ATT_FOLLOW_THROUGH);
        return;
      }
    }
  }
}
STATIC_OVL void
py_cruel_blow(int crit_bonus_dice, struct monster* mon)
{
  char m_name[80];
  if (player_active_ability(player, "Cruel Blow")) {
    if (crit_bonus_dice <= 0) return;
    if (rf_has(mon->race->flags, RF_RES_CRIT)) return;
    monster_desc(m_name, sizeof(m_name), mon, MDESC_TARG);
    if (skill_check(source_player(), crit_bonus_dice * 4,
                    monster_skill(mon, SKILL_WILL),
                    source_monster(mon->midx)) > 0) {
      msg("%s reels in pain!", m_name);
      mon_inc_timed(mon, MON_TMD_CONF, crit_bonus_dice + 1, 0);
      scare_onlooking_friends(mon, -20);
    }
  }
}
STATIC_OVL int
prt_after_sharpness(struct player* p, const struct object* obj, int* flag)
{
  int protection = 100;
  struct song* sharp = lookup_song("Sharpness");
  if (!obj) return 0;
  if (of_has(obj->flags, OF_SHARPNESS)) {
    *flag = OF_SHARPNESS;
    protection = 50;
  }
  if (of_has(obj->flags, OF_SHARPNESS2)) {
    *flag = OF_SHARPNESS2;
    protection = 0;
  }
  if (player_is_singing(p, sharp)) {
    if (tval_is_sharp(obj)) {
      protection -= song_bonus(p, p->state.skill_use[SKILL_SONG], sharp);
    }
  }
  return MAX(protection, 0);
}
STATIC_OVL void
attack_punctuation(char* punctuation, size_t len, int net_dam,
                   int crit_bonus_dice)
{
  if (net_dam == 0) {
    my_strcpy(punctuation, "...", len);
  } else if (crit_bonus_dice <= 0) {
    my_strcpy(punctuation, ".", len);
  } else {
    size_t i;
    for (i = 0; (i < (size_t)crit_bonus_dice) && (i < len - 1); i++) {
      punctuation[i] = '!';
    }
    punctuation[i] = '\0';
  }
}
STATIC_OVL bool
whirlwind_possible(struct player* p)
{
  int d, dir;
  struct loc grid;
  if (p->timed[TMD_RAGE]) return true;
  if (!player_active_ability(p, "Whirlwind Attack")) {
    return false;
  }
  for (d = 0; d < 8; d++) {
    dir = cycle[d];
    grid = loc_sum(p->grid, ddgrid[dir]);
    if (square_iswall(cave, grid)) {
      return false;
    }
  }
  return true;
}
STATIC_OVL void
whirlwind(struct player* p, struct loc grid)
{
  int i, dir, dir0;
  bool clockwise = one_in_(2);
  if (p->timed[TMD_RAGE]) {
    msg("You strike out at everything around you!");
  }
  dir = dir_from_delta(grid.y - p->grid.y, grid.x - p->grid.x);
  dir0 = chome[dir];
  for (i = 0; i < 8; i++) {
    struct loc adj_grid;
    struct monster* mon;
    if (clockwise) {
      dir = cycle[dir0 + i];
    } else {
      dir = cycle[dir0 - i];
    }
    adj_grid = loc_sum(p->grid, ddgrid[dir]);
    mon = square_monster(cave, adj_grid);
    if (mon) {
      if (p->timed[TMD_RAGE]) {
        py_attack_real(p, adj_grid, ATT_RAGE);
      } else if ((i == 0) || !OPT(p, forgo_attacking_unwary) ||
                 (mon->alertness >= ALERTNESS_ALERT)) {
        py_attack_real(p, adj_grid, ATT_WHIRLWIND);
      }
    }
  }
}
STATIC_OVL void
py_attack_real(struct player* p, struct loc grid, int attack_type)
{
  struct monster* mon = square_monster(cave, grid);
  struct monster_race* race = mon ? mon->race : NULL;
  char m_name[80];
  char name[80];
  struct object* obj = equipped_item_by_slot_name(p, "weapon");
  int blows = 1;
  int num = 0;
  int attack_mod = 0, total_attack_mod = 0, total_evasion_mod = 0;
  int hit_result = 0;
  int dam = 0, prt = 0;
  int net_dam = 0;
  int prt_percent = 100;
  int stealth_bonus = 0;
  int mdd, mds;
  bool monster_riposte = false;
  bool abort_attack = false;
  bool charge = false;
  bool rapid_attack = false;
  char verb[20];
  char punct[20];
  int weight;
  const struct artifact* crown = lookup_artifact_name("of Morgoth");
  my_strcpy(verb, "punch", sizeof(verb));
  monster_desc(m_name, sizeof(m_name), mon, MDESC_TARG);
  if (monster_is_visible(mon)) {
    monster_race_track(p->upkeep, mon->race);
    health_track(p->upkeep, mon);
  }
  if (p->timed[TMD_AFRAID]) {
    msgt(MSG_AFRAID, "You are too afraid to attack %s!", m_name);
    return;
  }
  if (obj && check_for_inscrip(obj, "!a") && !p->truce) {
    if (!get_check("Are you sure you wish to attack? ")) {
      abort_attack = true;
    }
  }
  if (p->truce && !get_check("Are you sure you wish to attack? ")) {
    abort_attack = true;
  }
  if (!obj && !get_check("Are you sure you wish to attack with no weapon? ")) {
    abort_attack = true;
  }
  if (obj) {
    object_short_name(name, sizeof(name), obj->kind->name);
    if (tval_is_digger(obj) && streq(name, "Shovel") &&
        !get_check("Are you sure you wish to attack with your shovel? ")) {
      abort_attack = true;
    }
  }
  if (abort_attack) {
    if (!p->attacked) {
      p->previous_action[0] = ACTION_NOTHING;
      p->upkeep->energy_use = 0;
    }
    return;
  }
  if (obj) {
    weight = obj->weight;
    my_strcpy(verb, "hit", sizeof(verb));
  } else {
    weight = 0;
  }
  mdd = p->state.mdd;
  mds = p->state.mds;
  attack_mod = p->state.skill_use[SKILL_MELEE];
  p->attacked = true;
  if (player_active_ability(p, "Rapid Attack")) {
    blows++;
    rapid_attack = true;
  }
  if (p->state.mds2 > 0) {
    blows++;
  }
  if ((attack_type != ATT_MAIN) && (attack_type != ATT_FLANKING) &&
      (attack_type != ATT_CONTROLLED_RETREAT)) {
    blows = 1;
    mds = total_mds(p, &p->state, obj, 0);
    if (rapid_attack) {
      rapid_attack = false;
      attack_mod += 3;
    }
  }
  while (num++ < blows) {
    bool do_knock_back = false;
    bool knocked = false;
    bool off_hand_blow = false;
    if (charge) {
      charge = false;
      attack_mod -= 3;
      mds = p->state.mds;
    }
    if ((num == blows) && (num != 1) && (p->state.mds2 > 0)) {
      off_hand_blow = true;
      rapid_attack = false;
      attack_mod += p->state.offhand_mel_mod;
      mdd = p->state.mdd2;
      mds = p->state.mds2;
      obj = equipped_item_by_slot_name(p, "arm");
      weight = obj->weight;
    }
    if ((num == 1) && valid_charge(p, grid, attack_type)) {
      int str_adjustment = 3;
      if (rapid_attack) str_adjustment -= 3;
      charge = true;
      attack_mod += 3;
      mds = total_mds(p, &p->state, obj, str_adjustment);
    }
    if (((attack_type == ATT_MAIN) || (attack_type == ATT_FLANKING) ||
         (attack_type == ATT_CONTROLLED_RETREAT)) &&
        !charge) {
      stealth_bonus = stealth_melee_bonus(mon);
    }
    total_attack_mod = total_player_attack(p, mon, attack_mod + stealth_bonus);
    total_evasion_mod = total_monster_evasion(p, mon, false);
    hit_result = hit_roll(total_attack_mod, total_evasion_mod, source_player(),
                          source_monster(mon->midx), true);
    if (hit_result > 0) {
      int crit_bonus_dice = 0, slay_bonus_dice = 0, total_dice = 0;
      int effective_strength = p->state.stat_use[STAT_STR];
      bool fatal_blow = false;
      bool living = monster_is_living(mon);
      int slay = 0, brand = 0, flag = 0;
      mflag_on(mon->mflag, MFLAG_HIT_BY_MELEE);
      if (charge) mflag_on(mon->mflag, MFLAG_CHARGED);
      crit_bonus_dice =
          crit_bonus(p, hit_result, weight, race, SKILL_MELEE, false);
      slay_bonus_dice = slay_bonus(p, obj, mon, &slay, &brand);
      total_dice = mdd + slay_bonus_dice + crit_bonus_dice;
      dam = damroll(total_dice, mds);
      prt = damroll(race->pd, race->ps);
      prt_percent = prt_after_sharpness(p, obj, &flag);
      prt = (prt * prt_percent) / 100;
      net_dam = MAX(dam - prt, 0);
      attack_punctuation(punct, sizeof(punct), net_dam, crit_bonus_dice);
      if (stealth_bonus) {
        msgt(MSG_HIT, "You stealthily attack %s%s", m_name, punct);
      } else if (charge) {
        msgt(MSG_HIT, "You charge %s%s", m_name, punct);
      } else {
        msgt(MSG_HIT, "You hit %s%s", m_name, punct);
      }
      event_signal_combat_damage(EVENT_COMBAT_DAMAGE, total_dice, mds, dam,
                                 race->pd, race->ps, prt, prt_percent,
                                 PROJ_HURT, true);
      effective_strength = p->state.stat_use[STAT_STR];
      if (charge) effective_strength += 3;
      if (rapid_attack) effective_strength -= 3;
      if (off_hand_blow) effective_strength -= 3;
      if (effective_strength > weight / 10) {
        effective_strength = weight / 10;
      } else if ((effective_strength < 0) &&
                 (-effective_strength > weight / 10)) {
        effective_strength = -(weight / 10);
      }
      if (two_handed_melee(p)) {
        effective_strength += 2;
      }
      if (player_active_ability(p, "Knock Back") &&
          (attack_type != ATT_OPPORTUNIST) &&
          !rf_has(race->flags, RF_NEVER_MOVE) &&
          (skill_check(source_player(), effective_strength * 2,
                       monster_stat(mon, STAT_CON) * 2,
                       source_monster(mon->midx)) > 0)) {
        do_knock_back = true;
      }
      if (slay || brand) {
        learn_brand_slay_from_melee(p, obj, mon);
      }
      if (flag && !player_knows_flag(p, flag)) {
        char o_name[80];
        char desc[80];
        object_desc(o_name, sizeof(o_name), obj, ODESC_BASE, p);
        if (flag_slay_message(flag, m_name, desc, strlen(desc))) {
          msg("Your %s %s.", o_name, desc);
        }
        player_learn_flag(p, flag);
      }
      fatal_blow = mon_take_hit(mon, p, net_dam, NULL);
      if (do_knock_back) {
        event_signal_hit(EVENT_HIT, net_dam, PROJ_SOUND, fatal_blow, grid);
      } else {
        event_signal_hit(EVENT_HIT, net_dam, PROJ_HURT, fatal_blow, grid);
      }
      if (fatal_blow) {
        if (obj && of_has(obj->flags, OF_VAMPIRIC) && living) {
          if (p->chp < p->mhp) {
            effect_simple(EF_HEAL_HP, source_player(), "m7", 0, 0, 0, NULL);
            if (!player_knows_flag(p, OF_VAMPIRIC)) {
              char o_name[80];
              char desc[80];
              object_desc(o_name, sizeof(o_name), obj, ODESC_BASE, p);
              if (flag_slay_message(OF_VAMPIRIC, m_name, desc, strlen(desc))) {
                msg("Your %s %s.", o_name, desc);
              }
              player_learn_flag(p, OF_VAMPIRIC);
            }
          }
        }
        if (player_is_singing(p, lookup_song("Slaying"))) {
          p->wrath += 100;
          p->upkeep->update |= PU_BONUS;
          p->upkeep->redraw |= PR_SONG;
        }
        possible_follow_through(p, grid, attack_type);
        break;
      } else {
        if (do_knock_back) {
          knocked = knock_back(p->grid, grid);
        }
        if (rf_has(mon->race->flags, RF_QUESTOR) &&
            !is_artifact_created(crown)) {
          if (net_dam >= 10) {
            if (p->morgoth_hits == 0) {
              msg("The force of your blow knocks the Iron Crown off balance.");
              p->morgoth_hits++;
            } else if (p->morgoth_hits == 1) {
              drop_iron_crown(mon,
                              "You knock his crown from off his brow, and it "
                              "falls to the ground nearby.");
              p->morgoth_hits++;
            }
          }
        }
        if (net_dam) {
          py_cruel_blow(crit_bonus_dice, mon);
        }
      }
    } else {
      msgt(MSG_MISS, "You miss %s.", m_name);
      if (square_ispit(cave, p->grid) && one_in_(3)) {
        msg("(It is very hard to dodge or attack from within a pit.)");
      }
      if (square_iswebbed(cave, p->grid) && one_in_(3)) {
        msg("(It is very hard to dodge or attack from within a web.)");
      }
      if (rf_has(race->flags, RF_RIPOSTE) && !monster_riposte &&
          !mon->m_timed[MON_TMD_CONF] && (mon->stance != STANCE_FLEEING) &&
          !mon->skip_this_turn && !mon->skip_next_turn &&
          (hit_result <= -10 - (2 * race->blow[0].dice.dice))) {
        if (monster_is_visible(mon)) {
          struct monster_lore* lore = get_lore(mon->race);
          rf_on(lore->flags, RF_RIPOSTE);
        }
        msg("%s ripostes!", m_name);
        make_attack_normal(mon, p);
        monster_riposte = true;
      }
    }
    make_alert(mon, 0);
    if (knocked) break;
  }
  break_truce(p, false);
}
STATIC_OVL void
py_attack(struct player* p, struct loc grid, int attack_type)
{
  p->previous_action[0] = ACTION_MISC;
  if (whirlwind_possible(p) && (adj_mon_count(p->grid) > 1) &&
      !p->timed[TMD_AFRAID]) {
    whirlwind(p, grid);
  } else {
    py_attack_real(p, grid, attack_type);
  }
}
STATIC_OVL int
breakage_chance(const struct object* obj, bool hit_wall)
{
  int perc = obj->kind->base->break_perc;
  if (obj->artifact) return 0;
  if (tval_is_light(obj)) {
    if (of_has(obj->flags, OF_NO_FUEL)) {
      if (obj->pval == 1) {
        perc = 0;
      } else if (obj->pval == 7) {
        perc = 0;
      }
    }
  } else if (tval_is_ammo(obj)) {
    if (player_active_ability(player, "Careful Shot")) perc /= 2;
    if (player_active_ability(player, "Flaming Arrows")) perc = 100;
  } else if ((perc != 100) &&
             player_active_ability(player, "Throwing Mastery")) {
    perc = 0;
  }
  if (hit_wall) {
    perc *= 2;
    perc = MIN(perc, 100);
  }
  if (of_has(obj->flags, OF_THROWING)) {
    if (hit_wall) {
      perc /= 4;
    } else {
      perc = 0;
    }
  }
  return perc;
}
STATIC_OVL int
archery_range(const struct object* bow)
{
  int range;
  range = (bow->dd * total_ads(player, &player->state, bow, false) * 3) / 2;
  return MIN(range, z_info->max_range);
}
STATIC_OVL int
throwing_range(const struct object* obj)
{
  int div = obj->weight + 20;
  int range = (weight_limit(player->state) / 5) / div;
  if (range < 1) range = 1;
  return MIN(range, z_info->max_range);
}
STATIC_OVL bool
do_radiance(struct player* p, struct loc grid)
{
  if (square_isglow(cave, grid)) return false;
  sqinfo_on(square(cave, grid)->info, SQUARE_GLOW);
  sqinfo_on(square(cave, grid)->info, SQUARE_MARK);
  p->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
  update_stuff(p);
  return true;
}
STATIC_OVL bool
thrown_potion_effects(struct player* p, struct object* obj, bool* is_dead,
                      struct monster* mon)
{
  struct loc grid = mon->grid;
  bool ident = false;
  bool used = true;
  bool aware = object_flavor_is_aware(obj);
  char m_name[80];
  char m_poss[80];
  monster_desc(m_name, sizeof(m_name), mon, MDESC_DEFAULT);
  monster_desc(m_poss, sizeof(m_poss), mon, MDESC_PRO_VIS | MDESC_POSS);
  if (obj->kind->thrown_effect) {
    used = effect_do(obj->kind->thrown_effect, source_monster(mon->midx), obj,
                     &ident, aware, DIR_NONE, NULL);
  } else {
    used = false;
  }
  if (!square_monster(cave, grid)) {
    *is_dead = true;
  }
  if (ident && !aware) {
    char o_name[80];
    object_flavor_aware(p, obj);
    object_desc(o_name, sizeof(o_name), obj,
                ODESC_PREFIX | ODESC_FULL | ODESC_ALTNUM | (1 << 16), p);
    msg("You threw %s.", o_name);
    p->upkeep->notice |= (PN_COMBINE);
    p->upkeep->redraw |= (PR_INVEN | PR_EQUIP);
  }
  if (used) p->upkeep->redraw |= (PR_HEALTH);
  handle_stuff(p);
  return used;
}
STATIC_OVL void
attacks_of_opportunity(struct player* p, struct loc safe)
{
  int i;
  int start = randint0(8);
  int opportunity_attacks = 0;
  for (i = start; i < 8 + start; i++) {
    struct loc grid = loc_sum(p->grid, ddgrid_ddd[i % 8]);
    struct monster* mon = square_monster(cave, grid);
    if (!square_in_bounds(cave, grid)) continue;
    if (player_active_ability(p, "Point Blank Archery") && loc_eq(safe, grid)) {
      continue;
    }
    if (mon) {
      if ((mon->alertness >= ALERTNESS_ALERT) && !mon->m_timed[MON_TMD_CONF] &&
          (mon->stance != STANCE_FLEEING) &&
          !rf_has(mon->race->flags, RF_MINDLESS) && !mon->skip_next_turn &&
          !mon->skip_this_turn) {
        opportunity_attacks++;
        if (opportunity_attacks == 1) {
          msg("You provoke attacks of opportunity from adjacent enemies!");
        }
        make_attack_normal(mon, p);
      }
    }
  }
  return;
}
STATIC_OVL struct attack_result
make_ranged_shot(struct player* p, struct object* ammo, struct monster* mon,
                 bool undo_rapid, bool attack_penalty, bool one_shot)
{
  struct attack_result result = {0, 0, 0, false};
  struct object* bow = equipped_item_by_slot_name(p, "shooting");
  struct monster_race* race = mon->race;
  int attack_mod = p->state.skill_use[SKILL_ARCHERY] + ammo->att;
  int total_attack_mod, total_evasion_mod;
  int prt_percent;
  int slay_bonus_dice;
  int total_dd, total_ds;
  int dam, prt;
  int arrow_slay = 0, arrow_brand = 0, arrow_flag = 0;
  int bow_slay = 0, bow_brand = 0;
  char m_name[80];
  if (undo_rapid) {
    attack_mod += 3;
  }
  total_attack_mod = total_player_attack(p, mon, attack_mod);
  if (attack_penalty) {
    total_attack_mod = 0;
  }
  total_evasion_mod = total_monster_evasion(p, mon, true);
  result.hit = hit_roll(total_attack_mod, total_evasion_mod, source_player(),
                        source_monster(mon->midx), true);
  if (result.hit <= 0) {
    return result;
  }
  prt_percent = prt_after_sharpness(p, ammo, &arrow_flag);
  if (percent_chance(100 - prt_percent)) {
    result.pierce = true;
  }
  result.crit_dice =
      crit_bonus(p, result.hit, bow->weight, race, SKILL_ARCHERY, false);
  slay_bonus_dice = slay_bonus(p, ammo, mon, &arrow_slay, &arrow_brand);
  slay_bonus_dice += slay_bonus(p, bow, mon, &bow_slay, &bow_brand);
  if (player_active_ability(p, "Flaming Arrows")) {
    struct monster_lore* lore = get_lore(race);
    if (rf_has(race->flags, RF_RES_FIRE)) {
      if (monster_is_visible(mon)) {
        rf_on(lore->flags, RF_RES_FIRE);
      }
    } else {
      slay_bonus_dice += 1;
      if (rf_has(race->flags, RF_HURT_FIRE)) {
        slay_bonus_dice += 1;
        rf_on(lore->flags, RF_RES_FIRE);
        scare_onlooking_friends(mon, -20);
      }
    }
  }
  total_dd = bow->dd + result.crit_dice + slay_bonus_dice;
  total_ds = MAX(total_ads(p, &p->state, bow, one_shot), 0);
  dam = damroll(total_dd, total_ds);
  prt = damroll(race->pd, race->ps);
  prt = (prt * prt_percent) / 100;
  result.dmg = MAX(0, dam - prt);
  monster_desc(m_name, sizeof(m_name), mon, MDESC_DEFAULT);
  if (bow_slay || bow_brand || arrow_slay || arrow_brand) {
    learn_brand_slay_from_launch(p, ammo, bow, mon);
  }
  if (arrow_flag) {
    char o_name[80];
    char desc[80];
    object_desc(o_name, sizeof(o_name), ammo, ODESC_BASE, p);
    if (flag_slay_message(arrow_flag, m_name, desc, strlen(desc))) {
      msg("Your %s %s.", o_name, desc);
    }
    player_learn_flag(p, arrow_flag);
  }
  event_signal_combat_damage(EVENT_COMBAT_DAMAGE, total_dd, total_ds,
                             result.dmg, race->pd, race->ps, prt, prt_percent,
                             PROJ_HURT, false);
  return result;
}
STATIC_OVL struct attack_result
make_ranged_throw(struct player* p, struct object* obj, struct monster* mon,
                  bool undo_rapid, bool attack_penalty, bool one_shot)
{
  struct attack_result result = {0, 0, 0, false};
  struct object* weapon = equipped_item_by_slot_name(p, "weapon");
  struct monster_race* race = mon->race;
  int attack_mod = p->state.skill_use[SKILL_MELEE] + obj->att;
  int total_attack_mod, total_evasion_mod;
  int prt_percent;
  int slay_bonus_dice;
  int total_dd, total_ds;
  int dam, prt;
  int slay = 0, brand = 0, flag = 0;
  if (weapon) {
    attack_mod -= weapon->att;
    attack_mod -= blade_bonus(p, weapon);
    attack_mod -= axe_bonus(p, weapon);
    attack_mod -= polearm_bonus(p, weapon);
  }
  if (!of_has(obj->flags, OF_THROWING)) {
    attack_mod -= 5;
  }
  attack_mod += blade_bonus(p, obj);
  attack_mod += axe_bonus(p, obj);
  attack_mod += polearm_bonus(p, obj);
  if (player_active_ability(p, "Throwing Mastery")) attack_mod += 5;
  total_attack_mod = total_player_attack(p, mon, attack_mod);
  if (attack_penalty) {
    total_attack_mod = 0;
  }
  total_evasion_mod = total_monster_evasion(p, mon, false);
  result.hit = hit_roll(total_attack_mod, total_evasion_mod, source_player(),
                        source_monster(mon->midx), true);
  if (result.hit <= 0) {
    return result;
  }
  prt_percent = prt_after_sharpness(p, obj, &flag);
  result.crit_dice =
      crit_bonus(p, result.hit, obj->weight, mon->race, SKILL_MELEE, false);
  slay_bonus_dice = slay_bonus(p, obj, mon, &slay, &brand);
  total_dd = obj->dd + result.crit_dice + slay_bonus_dice;
  total_ds = MAX(total_mds(p, &p->state, obj, 0), 0);
  if (!of_has(obj->flags, OF_THROWING)) total_ds /= 2;
  dam = damroll(total_dd, total_ds);
  prt = damroll(race->pd, race->ps);
  prt = (prt * prt_percent) / 100;
  result.dmg = MAX(0, dam - prt);
  if (slay || brand) {
    learn_brand_slay_from_throw(p, obj, mon);
  }
  if (flag) {
    char m_name[80];
    char o_name[80];
    char desc[80];
    monster_desc(m_name, sizeof(m_name), mon, MDESC_DEFAULT);
    object_desc(o_name, sizeof(o_name), obj, ODESC_BASE, p);
    if (flag_slay_message(flag, m_name, desc, strlen(desc))) {
      msg("Your %s %s.", o_name, desc);
    }
    player_learn_flag(p, flag);
  }
  event_signal_combat_damage(EVENT_COMBAT_DAMAGE, total_dd, total_ds,
                             result.dmg, race->pd, race->ps, prt, prt_percent,
                             PROJ_HURT, false);
  return result;
}
STATIC_OVL void
ranged_helper(struct player* p, struct object* obj, int dir, int range,
              int shots, bool archery, bool radiance)
{
  int i;
  ranged_attack attack;
  int path_n;
  struct loc path_g[256];
  struct loc grid = p->grid;
  struct loc target = loc_sum(grid, loc(99 * ddx[dir], 99 * ddy[dir]));
  struct loc first = loc(0, 0);
  bool none_left = false;
  bool noticed_radiance = false;
  bool targets_remaining = false;
  bool rapid_fire = player_active_ability(p, "Rapid Fire");
  bool hit_body = false;
  bool is_potion;
  struct object* bow = equipped_item_by_slot_name(p, "shooting");
  struct object* missile;
  int shot;
  const struct artifact* crown = lookup_artifact_name("of Morgoth");
  if ((dir == DIR_TARGET) && target_okay(range)) {
    target_get(&target);
  }
  if (p->timed[TMD_AFRAID]) {
    msg("You are too afraid to aim properly!");
    return;
  }
  sound(MSG_SHOOT);
  if (archery) {
    attack = make_ranged_shot;
    if (rapid_fire && obj->number > 1) {
      shots = 2;
    }
  } else {
    attack = make_ranged_throw;
  }
  is_potion = tval_is_potion(obj);
  p->upkeep->energy_use = z_info->move_energy;
  p->previous_action[0] = ACTION_MISC;
  path_n = project_path(cave, path_g, range, grid, &target, 0);
  handle_stuff(p);
  noticed_radiance = radiance && do_radiance(p, grid);
  for (shot = 0; shot < shots; shot++) {
    bool hit_wall = false;
    bool ghost_arrow = false;
    int missed_monsters = 0;
    struct loc final_grid = (path_n > 0) ? path_g[path_n - 1] : p->grid;
    if ((shot > 0) && !targets_remaining) break;
    targets_remaining = false;
    for (i = 0; i < path_n; ++i) {
      struct monster* mon = NULL;
      bool see = square_isseen(cave, path_g[i]);
      if (!square_isprojectable(cave, path_g[i])) {
        if (!ghost_arrow) {
          hit_wall = true;
          final_grid = grid;
          if (panel_contains(grid.y, grid.x)) {
            bool sees[1] = {square_isview(cave, grid)};
            int dist[1] = {0};
            struct loc blast_grid[1] = {grid};
            event_signal_blast(EVENT_EXPLOSION, PROJ_ARROW, 1, dist, true, sees,
                               blast_grid, grid);
          }
        }
        break;
      }
      grid = path_g[i];
      mon = square_monster(cave, grid);
      if (ghost_arrow) {
        if (mon && (!OPT(p, forgo_attacking_unwary) ||
                    (mon->alertness >= ALERTNESS_ALERT))) {
          targets_remaining = true;
        }
        continue;
      }
      noticed_radiance = radiance && do_radiance(p, grid);
      event_signal_missile(EVENT_MISSILE, obj, see, grid.y, grid.x);
      if (mon) {
        bool potion_effect = false;
        bool attack_penalty = false;
        int visible = monster_is_visible(mon);
        const char* note_dies =
            monster_is_nonliving(mon) ? " is destroyed." : " dies.";
        struct attack_result result;
        int pdam = 0;
        first = grid;
        p->attacked = true;
        if ((dir == DIR_TARGET) && target_okay(range)) {
          if (!loc_eq(grid, target)) {
            attack_penalty = true;
          }
        } else if (missed_monsters > 0) {
          attack_penalty = true;
        } else {
          if (monster_is_visible(mon)) {
            monster_race_track(p->upkeep, mon->race);
            health_track(p->upkeep, mon);
            target_set_monster(mon);
          }
        }
        result = attack(p, obj, mon, rapid_fire, attack_penalty, shots == 1);
        if (result.hit > 0) {
          char o_name[80];
          bool fatal_blow = false;
          hit_body = true;
          mflag_on(mon->mflag, MFLAG_HIT_BY_RANGED);
          object_desc(o_name, sizeof(o_name), obj, ODESC_FULL | ODESC_SINGULAR,
                      p);
          if (!visible) {
            msgt(MSG_SHOOT_HIT, "The %s finds a mark.", o_name);
          } else {
            char m_name[80];
            char punct[20];
            attack_punctuation(punct, sizeof(punct), result.dmg,
                               result.crit_dice);
            monster_desc(m_name, sizeof(m_name), mon, MDESC_OBJE);
            if (result.pierce) {
              msgt(MSG_SHOOT_HIT, "The %s pierces %s%s", o_name, m_name, punct);
            } else {
              msgt(MSG_SHOOT_HIT, "The %s hits %s%s", o_name, m_name, punct);
            }
          }
          if (is_potion) {
            pdam = mon->hp;
            msg("The bottle breaks.");
            potion_effect = thrown_potion_effects(p, obj, &fatal_blow, mon);
            pdam -= mon->hp;
            if (pdam < 0) pdam = 0;
          }
          if (!potion_effect) {
            fatal_blow = mon_take_hit(mon, p, result.dmg, note_dies);
            event_signal_hit(EVENT_HIT, result.dmg, PROJ_HURT, fatal_blow,
                             grid);
            if (fatal_blow) {
              if (player_is_singing(p, lookup_song("Slaying"))) {
                p->wrath += 100;
                p->upkeep->update |= PU_BONUS;
                p->upkeep->redraw |= PR_SONG;
              }
            }
          }
          if (!fatal_blow) {
            targets_remaining = true;
            if (result.dmg == 0) {
              make_alert(mon, 0);
            }
            if (rf_has(mon->race->flags, RF_QUESTOR) &&
                !is_artifact_created(crown)) {
              if (result.dmg >= 10) {
                if (p->morgoth_hits == 0) {
                  msg("The force of your %s knocks the Iron Crown off balance.",
                      archery ? "shot" : "blow");
                  p->morgoth_hits++;
                } else if (player->morgoth_hits == 1) {
                  drop_iron_crown(mon,
                                  "You knock his crown from off his brow, and "
                                  "it falls to the ground nearby.");
                  p->morgoth_hits++;
                }
              }
            }
            if ((!potion_effect || (pdam > 0)) && !monster_is_visible(mon)) {
              message_pain(mon, pdam ? pdam : result.dmg);
            }
            if (archery && player_active_ability(p, "Crippling Shot") &&
                (result.crit_dice >= 1) && (result.dmg > 0) &&
                !rf_has(mon->race->flags, RF_RES_CRIT)) {
              if (skill_check(source_player(), result.crit_dice * 4,
                              monster_skill(mon, SKILL_WILL),
                              source_monster(mon->midx)) > 0) {
                msg("Your shot cripples %^s!", mon);
                mon_inc_timed(mon, result.crit_dice + 1, MON_TMD_SLOW, false);
              }
            }
          }
          if (!result.pierce) {
            ghost_arrow = true;
            final_grid = grid;
          }
        } else {
          targets_remaining = true;
        }
        missed_monsters++;
      }
    }
    if (bow && !of_has(bow->known->flags, OF_RADIANCE) && noticed_radiance) {
      char o_full_name[80];
      char o_short_name[80];
      object_desc(o_short_name, sizeof(o_short_name), obj, ODESC_BASE, p);
      player_learn_flag(p, OF_RADIANCE);
      object_desc(o_full_name, sizeof(o_full_name), obj,
                  ODESC_PREFIX | ODESC_FULL | ODESC_ALTNUM | (1 << 16), p);
      msg("The arrow leaves behind a trail of light!");
      msg("You recognize your %s to be %s", o_short_name, o_full_name);
    }
    break_truce(p, false);
    if (object_is_carried(p, obj)) {
      missile = gear_object_for_use(p, obj, 1, true, &none_left);
    } else {
      missile = floor_object_for_use(p, obj, 1, true, &none_left);
    }
    missile->notice |= OBJ_NOTICE_PICKUP;
    drop_near(cave, &missile, breakage_chance(missile, hit_wall), final_grid,
              true, false);
  }
  if (!hit_body && is_potion) {
    msg("The bottle breaks.");
  }
  p->attacked = true;
  if (archery) {
    if (player_active_ability(p, "Point Blank Archery")) {
      attacks_of_opportunity(p, first);
    } else {
      attacks_of_opportunity(p, loc(0, 0));
    }
  }
}
STATIC_OVL void
do_cmd_fire(struct command* cmd)
{
  int dir, range;
  int shots = 1;
  struct object* bow = equipped_item_by_slot_name(player, "shooting");
  struct object* obj;
  bool radiance;
  if (!bow || !player->state.ammo_tval) {
    msg("You have nothing to fire with.");
    return;
  }
  if (cmd_get_item(cmd, "item", &obj, "Fire which ammunition?",
                   "You have no suitable ammunition to fire.", obj_can_fire,
                   USE_EQUIP) != CMD_OK)
    return;
  if (!item_is_available(obj)) {
    msg("That item is not within your reach.");
    return;
  }
  if (obj->tval != player->state.ammo_tval) {
    msg("That ammo cannot be fired by your current weapon.");
    return;
  }
  range = archery_range(bow);
  if (cmd_get_target(cmd, "target", &dir, range, false) == CMD_OK) {
    player_confuse_dir(player, &dir, false);
    if (player->timed[TMD_AFRAID]) {
      msgt(MSG_AFRAID, "You are too afraid to aim properly!");
      return;
    }
  } else {
    return;
  }
  radiance = of_has(bow->flags, OF_RADIANCE);
  ranged_helper(player, obj, dir, range, shots, true, radiance);
}
STATIC_OVL void
do_cmd_throw(struct command* cmd)
{
  int dir;
  int shots = 1;
  int range;
  struct object* obj;
  if (player->upkeep->command_wrk == USE_EQUIP)
    player->upkeep->command_wrk = USE_INVEN;
  if (cmd_get_item(cmd, "item", &obj, "Throw which item?",
                   "You have nothing to throw.", obj_can_throw,
                   USE_EQUIP | USE_QUIVER | USE_INVEN | USE_FLOOR |
                       SHOW_THROWING) != CMD_OK)
    return;
  range = throwing_range(obj);
  if (cmd_get_target(cmd, "target", &dir, range, false) == CMD_OK) {
    player_confuse_dir(player, &dir, false);
    if (player->timed[TMD_AFRAID]) {
      msgt(MSG_AFRAID, "You are too afraid to aim properly!");
      return;
    }
  } else {
    return;
  }
  if (object_is_equipped(player->body, obj)) {
    assert(obj_can_takeoff(obj) && tval_is_melee_weapon(obj));
    if (handle_stickied_removal(player, obj)) {
      return;
    }
    inven_takeoff(obj);
  }
  ranged_helper(player, obj, dir, range, shots, false, false);
}
STATIC_OVL void
do_cmd_fire_quiver1(void)
{
  struct object* bow = equipped_item_by_slot_name(player, "shooting");
  struct object* ammo = equipped_item_by_slot_name(player, "first quiver");
  if (!bow || !player->state.ammo_tval) {
    msg("You have nothing to fire with.");
    return;
  }
  if (!ammo) {
    msg("You have no ammunition in the first quiver to fire.");
    return;
  }
  if (ammo->tval != player->state.ammo_tval) {
    msg("The ammunition in the first quiver is not compatible with your "
        "launcher.");
    return;
  }
  cmdq_push(CMD_FIRE);
  cmd_set_arg_item(cmdq_peek(), "item", ammo);
}
STATIC_OVL void
do_cmd_fire_quiver2(void)
{
  struct object* bow = equipped_item_by_slot_name(player, "shooting");
  struct object* ammo = equipped_item_by_slot_name(player, "second quiver");
  if (!bow || !player->state.ammo_tval) {
    msg("You have nothing to fire with.");
    return;
  }
  if (!ammo) {
    msg("You have no ammunition in the second quiver to fire.");
    return;
  }
  if (ammo->tval != player->state.ammo_tval) {
    msg("The ammunition in the second quiver is not compatible with your "
        "launcher.");
    return;
  }
  cmdq_push(CMD_FIRE);
  cmd_set_arg_item(cmdq_peek(), "item", ammo);
}
STATIC_OVL void
do_cmd_fire_at_nearest(void)
{
  int dir = DIR_TARGET;
  struct object* ammo = NULL;
  struct object* bow = equipped_item_by_slot_name(player, "shooting");
  struct object* ammo1 = equipped_item_by_slot_name(player, "first quiver");
  struct object* ammo2 = equipped_item_by_slot_name(player, "second quiver");
  if (!bow || !player->state.ammo_tval) {
    msg("You have nothing to fire with.");
    return;
  }
  if (ammo1) {
    ammo = ammo1;
  } else if (ammo2) {
    ammo = ammo2;
  }
  if (!ammo) {
    msg("You have no ammunition in the quiver to fire.");
    return;
  }
  if (!target_set_closest((TARGET_KILL | TARGET_QUIET), NULL)) return;
  cmdq_push(CMD_FIRE);
  cmd_set_arg_item(cmdq_peek(), "item", ammo);
  cmd_set_arg_target(cmdq_peek(), "target", dir);
}
STATIC_OVL void
do_cmd_automatic_throw(void)
{
  struct object* thrown;
  int nthrow = scan_items(&thrown, 1, player, USE_INVEN, obj_is_throwing);
  int range;
  if (nthrow <= 0) {
    msg("You don't have anything designed for throwing in your inventory.");
    return;
  }
  range = throwing_range(thrown);
  assert(range > 0);
  if (!target_okay(range)) {
    struct point_set* targets =
        target_get_monsters(TARGET_KILL | TARGET_QUIET, NULL, false);
    struct monster* target = NULL;
    int target_range = range + 1;
    int ntgt = point_set_size(targets), i = 0;
    while (1) {
      if (i >= ntgt) {
        point_set_dispose(targets);
        if (!target) {
          msg("No clear target for automatic throwing.");
          return;
        }
        target_set_monster(target);
        health_track(player->upkeep, target);
        break;
      }
      if (distance(player->grid, targets->pts[i]) < target_range) {
        target = square_monster(cave, targets->pts[i]);
        assert(target);
      }
      ++i;
    }
  }
  cmdq_push(CMD_THROW);
  cmd_set_arg_item(cmdq_peek(), "item", thrown);
  cmd_set_arg_target(cmdq_peek(), "target", DIR_TARGET);
}
STATIC_OVL void
save_birth_data(birther* tosave)
{
  int i;
  tosave->race = player->race;
  tosave->house = player->house;
  tosave->sex = player->sex;
  tosave->age = player->age;
  tosave->wt = player->wt_birth;
  tosave->ht = player->ht_birth;
  for (i = 0; i < STAT_MAX; i++)
    tosave->stat[i] = player->stat_base[i] -
                      (player->race->stat_adj[i] + player->house->stat_adj[i]);
  if (tosave->history) {
    string_free(tosave->history);
  }
  tosave->history = player->history;
  player->history = NULL;
  my_strcpy(tosave->name, player->full_name, sizeof(tosave->name));
}
STATIC_OVL void
load_birth_data(birther* saved, birther* prev_player)
{
  int i;
  birther temp;
  memset(&temp, 0, sizeof(birther));
  if (prev_player) save_birth_data(&temp);
  player->race = saved->race;
  player->house = saved->house;
  player->sex = saved->sex;
  player->age = saved->age;
  player->wt = player->wt_birth = saved->wt;
  player->ht = player->ht_birth = saved->ht;
  for (i = 0; i < STAT_MAX; i++) {
    player->stat_base[i] = saved->stat[i];
  }
  if (player->history) {
    string_free(player->history);
  }
  player->history = string_make(saved->history);
  my_strcpy(player->full_name, saved->name, sizeof(player->full_name));
  if (prev_player) {
    if (prev_player->history) {
      string_free(prev_player->history);
    }
    *prev_player = temp;
  }
}
STATIC_OVL void
get_bonuses(struct player* p)
{
  p->upkeep->update |= (PU_BONUS | PU_HP);
  update_stuff(p);
  p->chp = p->mhp;
  calc_voice(p, true);
  p->csp = p->msp;
}
STATIC_OVL char*
get_history(struct history_chart* chart, struct player* p)
{
  struct history_entry* entry;
  char* res = NULL;
  while (chart) {
    int roll = randint1(100);
    for (entry = chart->entries; entry; entry = entry->next)
      if (roll <= entry->roll) break;
    assert(entry);
    res = string_append(res, entry->text);
    if (strstr(entry->text, "house of") && streq(p->race->name, "Noldor")) {
      res = string_append(res, " ");
      res = string_append(res, p->house->short_name);
      res = string_append(res, ".");
    }
    chart = entry->succ;
  }
  return res;
}
STATIC_OVL void
get_ahw(struct player* p)
{
  p->age = p->race->b_age + randint1(p->race->m_age);
  p->ht = p->ht_birth = Rand_normal(p->race->base_hgt, p->race->mod_hgt);
  p->wt = p->wt_birth = Rand_normal(p->race->base_wgt, p->race->mod_wgt);
}
STATIC_OVL void
player_embody(struct player* p)
{
  char buf[80];
  int i;
  assert(p->race);
  memcpy(&p->body, &bodies[p->race->body], sizeof(p->body));
  my_strcpy(buf, bodies[p->race->body].name, sizeof(buf));
  p->body.name = string_make(buf);
  p->body.slots = mem_zalloc(p->body.count * sizeof(struct equip_slot));
  for (i = 0; i < p->body.count; i++) {
    p->body.slots[i].type = bodies[p->race->body].slots[i].type;
    my_strcpy(buf, bodies[p->race->body].slots[i].name, sizeof(buf));
    p->body.slots[i].name = string_make(buf);
  }
}
STATIC_OVL void
player_init(struct player* p)
{
  int i;
  struct player_options opts_save = p->opts;
  player_cleanup_members(p);
  memset(p, 0, sizeof(struct player));
  for (i = 0; z_info && i < z_info->a_max; i++) {
    mark_artifact_created(&a_info[i], false);
    mark_artifact_seen(&a_info[i], false);
  }
  for (i = 1; z_info && i < z_info->k_max; i++) {
    struct object_kind* kind = &k_info[i];
    kind->tried = false;
    kind->aware = false;
  }
  for (i = 1; z_info && i < z_info->r_max; i++) {
    struct monster_race* race = &r_info[i];
    struct monster_lore* lore = get_lore(race);
    race->cur_num = 0;
    race->max_num = 100;
    if (rf_has(race->flags, RF_UNIQUE)) race->max_num = 1;
    lore->pkills = 0;
    lore->psights = 0;
  }
  p->upkeep = mem_zalloc(sizeof(struct player_upkeep));
  p->upkeep->inven =
      mem_zalloc((z_info->pack_size + 1) * sizeof(struct object*));
  p->timed = mem_zalloc(TMD_MAX * sizeof(int16_t));
  p->vaults = mem_zalloc(z_info->v_max * sizeof(int16_t));
  p->obj_k = mem_zalloc(sizeof(struct object));
  p->obj_k->brands = mem_zalloc(z_info->brand_max * sizeof(bool));
  p->obj_k->slays = mem_zalloc(z_info->slay_max * sizeof(bool));
  p->opts = opts_save;
  turn = 1;
  p->race = races;
  p->house = houses;
  p->sex = sexes;
}
STATIC_OVL void
wield_all(struct player* p)
{
  struct object *obj, *new_pile = NULL, *new_known_pile = NULL;
  int slot;
  for (obj = p->gear; obj; obj = obj->next) {
    struct object* obj_temp;
    assert(obj);
    slot = wield_slot(obj);
    if (slot < 0 || slot >= p->body.count) continue;
    obj_temp = slot_object(p, slot);
    if (obj_temp) continue;
    if ((obj->number > 1) && !tval_is_ammo(obj)) {
      struct object* new = object_split(obj, obj->number - 1);
      pile_insert(&new_pile, new);
      pile_insert(&new_known_pile, new->known);
    }
    p->body.slots[slot].obj = obj;
    object_learn_on_wield(p, obj);
    p->upkeep->equip_cnt++;
  }
  if (new_pile) {
    pile_insert_end(&p->gear, new_pile);
    pile_insert_end(&p->gear_k, new_known_pile);
  }
  return;
}
STATIC_OVL bool
player_make_simple(const char* nrace, const char* nhouse, const char* nsex,
                   const char* nplayer)
{
  int ir = 0, ih = 0, is = 0;
  if (nrace) {
    const struct player_race* rc = races;
    int nr = 0;
    while (1) {
      if (!rc) return false;
      if (streq(rc->name, nrace)) break;
      rc = rc->next;
      ++ir;
      ++nr;
    }
    while (rc) {
      rc = rc->next;
      ++nr;
    }
    ir = nr - ir - 1;
  }
  if (nhouse) {
    const struct player_house* hc = houses;
    int nh = 0;
    while (1) {
      if (!hc) return false;
      if (streq(hc->name, nhouse)) break;
      hc = hc->next;
      ++ih;
      ++nh;
    }
    while (hc) {
      hc = hc->next;
      ++nh;
    }
    ih = nh - ih - 1;
  }
  if (nsex) {
    const struct player_sex* sc = sexes;
    int ns = 0;
    while (1) {
      if (!sc) return false;
      if (streq(sc->name, nsex)) break;
      sc = sc->next;
      ++is;
      ++ns;
    }
    while (sc) {
      sc = sc->next;
      ++ns;
    }
    is = ns - is - 1;
  }
  cmdq_push(CMD_BIRTH_INIT);
  cmdq_push(CMD_BIRTH_RESET);
  cmdq_push(CMD_CHOOSE_RACE);
  cmd_set_arg_choice(cmdq_peek(), "choice", ir);
  cmdq_push(CMD_CHOOSE_HOUSE);
  cmd_set_arg_choice(cmdq_peek(), "choice", ih);
  cmdq_push(CMD_CHOOSE_SEX);
  cmd_set_arg_choice(cmdq_peek(), "choice", is);
  cmdq_push(CMD_NAME_CHOICE);
  cmd_set_arg_string(cmdq_peek(), "name",
                     (nplayer == NULL) ? "Simple" : nplayer);
  cmdq_push(CMD_ACCEPT_CHARACTER);
  cmdq_execute(CTX_BIRTH);
  return true;
}
STATIC_OVL void
player_outfit(struct player* p)
{
  int i;
  const struct start_item* si;
  struct object *obj, *known_obj;
  p->upkeep->total_weight = 0;
  p->obj_k->dd = 1;
  p->obj_k->ds = 1;
  p->obj_k->pd = 1;
  p->obj_k->ps = 1;
  p->obj_k->att = 1;
  p->obj_k->evn = 1;
  for (i = 1; i < OF_MAX; i++) {
    struct obj_property* prop = lookup_obj_property(OBJ_PROPERTY_FLAG, i);
    if (prop->subtype == OFT_BASIC) of_on(p->obj_k->flags, i);
  }
  for (si = p->race->start_items; si; si = si->next) {
    int num = rand_range(si->min, si->max);
    struct object_kind* kind = lookup_kind(si->tval, si->sval);
    assert(kind);
    obj = object_new();
    object_prep(obj, kind, 0, MINIMISE);
    obj->number = num;
    obj->origin = ORIGIN_BIRTH;
    known_obj = object_new();
    obj->known = known_obj;
    object_set_base_known(p, obj);
    object_flavor_aware(p, obj);
    obj->known->pval = obj->pval;
    obj->known->notice |= OBJ_NOTICE_ASSESSED;
    inven_carry(p, obj, true, false);
    kind->everseen = true;
  }
  wield_all(p);
}
STATIC_OVL void
recalculate_stats(int* stats_local_local)
{
  int i;
  for (i = 0; i < STAT_MAX; i++) {
    player->stat_base[i] = stats_local_local[i];
  }
  get_bonuses(player);
  event_signal(EVENT_HP);
  event_signal(EVENT_STATS);
}
STATIC_OVL void
reset_stats(int stats_local[STAT_MAX], int points_spent_local[STAT_MAX],
            int points_inc_local[STAT_MAX], int* points_left_local,
            bool update_display)
{
  int i;
  *points_left_local = 13;
  for (i = 0; i < STAT_MAX; i++) {
    stats_local[i] = 0;
    points_spent_local[i] = 0;
    points_inc_local[i] = birth_stat_costs[stats_local[i] + 4 + 1];
  }
  if (update_display) {
    recalculate_stats(stats_local);
    event_signal_birthpoints(points_spent_local, points_inc_local,
                             *points_left_local);
  }
}
STATIC_OVL bool
buy_stat(int choice, int stats_local[STAT_MAX],
         int points_spent_local[STAT_MAX], int points_inc_local[STAT_MAX],
         int* points_left_local, bool update_display)
{
  if (!(choice >= STAT_MAX || choice < 0)) {
    int stat_cost = birth_stat_costs[stats_local[choice] + 4 + 1];
    assert(stat_cost == points_inc_local[choice]);
    if (stat_cost <= *points_left_local) {
      stats_local[choice]++;
      points_spent_local[choice] += stat_cost;
      points_inc_local[choice] = birth_stat_costs[stats_local[choice] + 4 + 1];
      *points_left_local -= stat_cost;
      if (update_display) {
        event_signal_birthpoints(points_spent_local, points_inc_local,
                                 *points_left_local);
        recalculate_stats(stats_local);
      }
      return true;
    }
  }
  return false;
}
STATIC_OVL bool
sell_stat(int choice, int stats_local[STAT_MAX],
          int points_spent_local[STAT_MAX], int points_inc_local[STAT_MAX],
          int* points_left_local, bool update_display)
{
  if (!(choice >= STAT_MAX || choice < 0) && (stats_local[choice] > 0)) {
    int stat_cost = birth_stat_costs[stats_local[choice] + 4];
    stats_local[choice]--;
    points_spent_local[choice] -= stat_cost;
    points_inc_local[choice] = birth_stat_costs[stats_local[choice] + 4 + 1];
    *points_left_local += stat_cost;
    if (update_display) {
      event_signal_birthpoints(points_spent_local, points_inc_local,
                               *points_left_local);
      recalculate_stats(stats_local);
    }
    return true;
  }
  return false;
}
STATIC_OVL void
finalise_stats(struct player* p)
{
  int i;
  for (i = 0; i < STAT_MAX; i++) {
    p->stat_base[i] += p->race->stat_adj[i] + p->house->stat_adj[i];
  }
}
STATIC_OVL void
player_generate(struct player* p, const struct player_race* r,
                const struct player_house* h, const struct player_sex* s,
                bool old_history)
{
  if (!h) h = p->house;
  if (!r) r = p->race;
  if (!s) s = p->sex;
  p->house = h;
  p->race = r;
  p->sex = s;
  if (!p->house) {
    p->house = player_house_from_count(0);
  }
  p->exp = p->new_exp = z_info->start_exp;
  get_bonuses(p);
  get_ahw(p);
  p->timed[TMD_FOOD] = PY_FOOD_FULL - 1;
  if (!old_history) {
    if (p->history) {
      string_free(p->history);
    }
    p->history = get_history(p->race->history, p);
  }
}
STATIC_OVL void
do_birth_reset(bool use_quickstart, birther* quickstart_prev_local)
{
  if (use_quickstart && quickstart_prev_local)
    load_birth_data(quickstart_prev_local, NULL);
  player_generate(player, NULL, NULL, NULL,
                  use_quickstart && quickstart_prev_local);
  player->depth = 1;
  get_bonuses(player);
}
STATIC_OVL void
do_cmd_birth_init(struct command* cmd)
{
  char* buf;
  character_dungeon = false;
  if (player->ht_birth) {
    int i, total_stat_cost = 0;
    bool stats_ok = true;
    buf = find_roman_suffix_start(player->full_name);
    if (buf) {
      int success = int_to_roman(
          roman_to_int(buf) + 1, buf,
          sizeof(player->full_name) - (buf - (char*)&player->full_name));
      if (!success) {
        msg("Sorry, could not deal with suffix");
      }
    }
    for (i = 0; i < STAT_MAX; i++) {
      int stat = player->stat_base[i];
      if (stat > 6) {
        stats_ok = false;
        break;
      }
      while (stat) {
        total_stat_cost += birth_stat_costs[4 + 1 + stat];
        if (total_stat_cost > 13) {
          stats_ok = false;
          break;
        }
      }
      if (!stats_ok) break;
    }
    if (stats_ok) {
      save_birth_data(&quickstart_prev);
      quickstart_allowed = true;
    }
  } else {
    player_generate(player, player_id2race(0), player_house_from_count(0),
                    player_id2sex(0), false);
    quickstart_allowed = false;
  }
  event_signal_flag(EVENT_ENTER_BIRTH, quickstart_allowed);
}
STATIC_OVL void
do_cmd_birth_reset(struct command* cmd)
{
  player_init(player);
  reset_stats(stats, points_spent, points_inc, &points_left, false);
  init_skills(true, false);
  do_birth_reset(quickstart_allowed, &quickstart_prev);
}
STATIC_OVL void
do_cmd_choose_race(struct command* cmd)
{
  int choice;
  cmd_get_arg_choice(cmd, "choice", &choice);
  player_generate(player, player_id2race(choice), NULL, NULL, false);
  init_skills(true, true);
}
STATIC_OVL void
do_cmd_choose_house(struct command* cmd)
{
  int choice;
  cmd_get_arg_choice(cmd, "choice", &choice);
  player_generate(player, NULL, player_house_from_count(choice), NULL, false);
  init_skills(true, true);
}
STATIC_OVL void
do_cmd_choose_sex(struct command* cmd)
{
  int choice;
  cmd_get_arg_choice(cmd, "choice", &choice);
  player_generate(player, NULL, NULL, player_id2sex(choice), false);
  init_skills(true, true);
}
STATIC_OVL void
do_cmd_buy_stat(struct command* cmd)
{
  int choice;
  cmd_get_arg_choice(cmd, "choice", &choice);
  buy_stat(choice, stats, points_spent, points_inc, &points_left, true);
}
STATIC_OVL void
do_cmd_sell_stat(struct command* cmd)
{
  int choice;
  cmd_get_arg_choice(cmd, "choice", &choice);
  sell_stat(choice, stats, points_spent, points_inc, &points_left, true);
}
STATIC_OVL void
do_cmd_reset_stats(struct command* cmd)
{
  reset_stats(stats, points_spent, points_inc, &points_left, true);
}
STATIC_OVL void
do_cmd_refresh_stats(struct command* cmd)
{
  event_signal_birthpoints(points_spent, points_inc, points_left);
}
STATIC_OVL void
do_cmd_choose_name(struct command* cmd)
{
  const char* str;
  cmd_get_arg_string(cmd, "name", &str);
  my_strcpy(player->full_name, str, sizeof(player->full_name));
}
STATIC_OVL void
do_cmd_choose_history(struct command* cmd)
{
  const char* str;
  if (player->history) string_free(player->history);
  cmd_get_arg_string(cmd, "history", &str);
  player->history = string_make(str);
}
STATIC_OVL void
do_cmd_accept_character(struct command* cmd)
{
  options_init_cheat();
  ignore_birth_init();
  history_clear(player);
  history_add(player, "Began the quest to recover a Silmaril.",
              HIST_PLAYER_BIRTH);
  message_add(" ", MSG_GENERIC);
  message_add("  ", MSG_GENERIC);
  message_add("====================", MSG_GENERIC);
  message_add("  ", MSG_GENERIC);
  message_add(" ", MSG_GENERIC);
  player_embody(player);
  finalise_stats(player);
  finalise_skills();
  player->obj_k->modifiers[OBJ_MOD_TUNNEL] = 1;
  seed_randart = randint0(0x10000000);
  seed_flavor = randint0(0x10000000);
  flavor_init();
  player_outfit(player);
  player->is_dead = false;
  character_generated = true;
  player->upkeep->playing = true;
  cmd_disable_repeat();
  string_free(prev.history);
  prev.history = NULL;
  string_free(quickstart_prev.history);
  quickstart_prev.history = NULL;
  event_signal(EVENT_LEAVE_BIRTH);
}
STATIC_OVL char*
find_roman_suffix_start(const char* buf)
{
  const char* start = strrchr(buf, ' ');
  const char* p;
  if (start) {
    start++;
    p = start;
    while (*p) {
      if (*p != 'I' && *p != 'V' && *p != 'X' && *p != 'L' && *p != 'C' &&
          *p != 'D' && *p != 'M') {
        start = NULL;
        break;
      }
      ++p;
    }
  }
  return (char*)start;
}
STATIC_OVL int
int_to_roman(int n, char* roman, size_t bufsize)
{
  char roman_symbol_labels[13][3] = {"M",  "CM", "D",  "CD", "C",  "XC", "L",
                                     "XL", "X",  "IX", "V",  "IV", "I"};
  int roman_symbol_values[13] = {1000, 900, 500, 400, 100, 90, 50,
                                 40,   10,  9,   5,   4,   1};
  roman[0] = '\0';
  if (n < 1) return 0;
  while (n > 0) {
    int i = 0;
    while (n < roman_symbol_values[i]) i++;
    if (strlen(roman) + strlen(roman_symbol_labels[i]) + 1 > bufsize) break;
    my_strcat(roman, roman_symbol_labels[i], bufsize);
    n -= roman_symbol_values[i];
  }
  if (n > 0) {
    roman[0] = '\0';
    return 0;
  }
  return 1;
}
STATIC_OVL int
roman_to_int(const char* roman)
{
  size_t i;
  int n = 0;
  char* p;
  char roman_token_chr1[] = "MDCLXVI";
  const char* roman_token_chr2[] = {0, 0, "DM", 0, "LC", 0, "VX"};
  int roman_token_vals[7][3] = {{1000},       {500}, {100, 400, 900}, {50},
                                {10, 40, 90}, {5},   {1, 4, 9}};
  if (strlen(roman) == 0) return -1;
  for (i = 0; i < strlen(roman); i++) {
    char c1, c2;
    int c1i, c2i;
    c1 = roman[i];
    c2 = roman[i + 1];
    p = strchr(roman_token_chr1, c1);
    if (p)
      c1i = p - roman_token_chr1;
    else
      return -1;
    c2i = 0;
    if (roman_token_chr2[c1i] && c2) {
      p = strchr(roman_token_chr2[c1i], c2);
      if (p) {
        c2i = (p - roman_token_chr2[c1i]) + 1;
        i++;
      }
    }
    n += roman_token_vals[c1i][c2i];
  }
  return n;
}
STATIC_OVL uint8_t
total_mdd(struct player* p, const struct object* obj)
{
  uint8_t dd;
  if (!obj) {
    dd = 1;
  } else {
    dd = obj->dd;
  }
  dd += p->state.to_mdd;
  return dd;
}
STATIC_OVL uint8_t
total_mds(struct player* p, struct player_state* state,
          const struct object* obj, int str_adjustment)
{
  uint8_t mds;
  int int_mds;
  int str_to_mds;
  int divisor;
  str_to_mds = state->stat_use[STAT_STR] + str_adjustment;
  if (!obj) {
    int_mds = 1;
    int_mds += str_to_mds;
  } else {
    int_mds = obj->ds;
    if (two_handed_melee(p)) {
      divisor = 10;
      int_mds += hand_and_a_half_bonus(p, obj);
    } else {
      divisor = 10;
    }
    if (player_active_ability(p, "Momentum")) {
      divisor /= 2;
    }
    if ((str_to_mds > 0) && (str_to_mds > (obj->weight / divisor))) {
      int_mds += obj->weight / divisor;
    } else if ((str_to_mds < 0) && (str_to_mds < -(obj->weight / divisor))) {
      int_mds += -(obj->weight / divisor);
    } else {
      int_mds += str_to_mds;
    }
  }
  int_mds += state->to_mds;
  if (player_active_ability(p, "Power")) {
    int_mds += 1;
  }
  mds = (int_mds < 0) ? 0 : int_mds;
  return mds;
}
STATIC_OVL int
hand_and_a_half_bonus(struct player* p, const struct object* obj)
{
  if (p && obj && obj->kind && of_has(obj->kind->flags, OF_HAND_AND_A_HALF) &&
      (equipped_item_by_slot_name(p, "weapon") == obj) &&
      (equipped_item_by_slot_name(p, "arm") == NULL)) {
    return 2;
  }
  return 0;
}
STATIC_OVL bool
two_handed_melee(struct player* p)
{
  struct object* obj = equipped_item_by_slot_name(p, "weapon");
  if (!obj) return false;
  if (of_has(obj->kind->flags, OF_TWO_HANDED) ||
      hand_and_a_half_bonus(p, obj)) {
    return true;
  }
  return false;
}
STATIC_OVL int
blade_bonus(struct player* p, const struct object* obj)
{
  if (player_has(p, PF_BLADE_PROFICIENCY) && (tval_is_sword(obj))) {
    return 1;
  }
  return 0;
}
STATIC_OVL int
axe_bonus(struct player* p, const struct object* obj)
{
  if (player_has(p, PF_AXE_PROFICIENCY) && of_has(obj->kind->flags, OF_AXE)) {
    return 1;
  }
  return 0;
}
STATIC_OVL int
polearm_bonus(struct player* p, const struct object* obj)
{
  if (player_active_ability(p, "Polearm Mastery") &&
      of_has(obj->kind->flags, OF_POLEARM)) {
    return 1;
  }
  return 0;
}
STATIC_OVL uint8_t
total_ads(struct player* p, struct player_state* state,
          const struct object* obj, bool single_shot)
{
  uint8_t ads;
  int int_ads;
  int str_to_ads;
  str_to_ads = state->stat_use[STAT_STR];
  if (player_active_ability(p, "Rapid Fire") && !single_shot) {
    str_to_ads -= 3;
  }
  int_ads = obj->ds;
  if ((str_to_ads > 0) && (str_to_ads > (obj->weight / 10))) {
    int_ads += obj->weight / 10;
  } else if ((str_to_ads < 0) && (str_to_ads < -(obj->weight / 10))) {
    int_ads += -(obj->weight / 10);
  } else {
    int_ads += str_to_ads;
  }
  int_ads += state->to_ads;
  ads = (int_ads < 0) ? 0 : int_ads;
  return ads;
}
STATIC_OVL bool
earlier_object(struct object* orig, struct object* new)
{
  if (!new) return false;
  if (!orig) return true;
  if (tval_is_ammo(orig) && tval_is_ammo(new)) {
    if ((player->state.ammo_tval == orig->tval) &&
        (player->state.ammo_tval != new->tval))
      return false;
    if ((player->state.ammo_tval != orig->tval) &&
        (player->state.ammo_tval == new->tval))
      return true;
  }
  if (orig->tval > new->tval) return false;
  if (orig->tval < new->tval) return true;
  if (!object_flavor_is_aware(new)) return false;
  if (!object_flavor_is_aware(orig)) return true;
  if (orig->sval < new->sval) return false;
  if (orig->sval > new->sval) return true;
  if (new->kind->flavor && !object_flavor_is_aware(new)) return false;
  if (orig->kind->flavor && !object_flavor_is_aware(orig)) return true;
  if (tval_is_light(orig)) {
    if (orig->pval > new->pval) return false;
    if (orig->pval < new->pval) return true;
  }
  if (tval_is_ammo(orig)) {
    if (object_value(orig) < object_value(new)) return false;
    if (object_value(orig) > object_value(new)) return true;
  } else {
    if (object_value(orig) > object_value(new)) return false;
    if (object_value(orig) < object_value(new)) return true;
  }
  return false;
}
STATIC_OVL int
equipped_item_slot(struct player_body body, struct object* item)
{
  int i;
  if (item == NULL) return body.count;
  for (i = 0; i < body.count; i++)
    if (item == body.slots[i].obj) break;
  return i;
}
STATIC_OVL void
calc_inventory(struct player* p)
{
  int old_inven_cnt = p->upkeep->inven_cnt;
  int n_max = 1 + z_info->pack_size + p->body.count;
  struct object** old_pack = mem_zalloc(z_info->pack_size * sizeof(*old_pack));
  bool* assigned = mem_alloc(n_max * sizeof(*assigned));
  struct object* current;
  int i, j;
  for (current = p->gear, j = 0; current; current = current->next, ++j) {
    assert(j < n_max);
    assigned[j] =
        object_is_equipped(p->body, current) || object_is_in_quiver(p, current);
  }
  for (; j < n_max; ++j) {
    assigned[j] = false;
  }
  for (i = 0; i < z_info->pack_size; i++) {
    old_pack[i] = p->upkeep->inven[i];
  }
  p->upkeep->inven_cnt = 0;
  for (i = 0; i <= z_info->pack_size; i++) {
    struct object* first = NULL;
    int jfirst = -1;
    j = 0;
    current = p->gear;
    while (1) {
      if (!current) break;
      assert(j < n_max);
      if (!assigned[j]) {
        if (earlier_object(first, current)) {
          first = current;
          jfirst = j;
        }
      }
      current = current->next;
      ++j;
    }
    p->upkeep->inven[i] = first;
    if (first) {
      ++p->upkeep->inven_cnt;
      assigned[jfirst] = true;
    }
  }
  if (character_dungeon && p->upkeep->inven_cnt == old_inven_cnt) {
    for (i = 0; i < z_info->pack_size; i++) {
      if (old_pack[i] && p->upkeep->inven[i] != old_pack[i] &&
          !object_is_equipped(p->body, old_pack[i]) &&
          !object_is_in_quiver(p, old_pack[i])) {
        msg("You re-arrange your pack.");
        break;
      }
    }
  }
  mem_free(assigned);
  mem_free(old_pack);
}
STATIC_OVL void
calc_voice(struct player* p, bool update)
{
  int i, msp, tmp;
  tmp = 20 * 100;
  if (p->state.stat_use[STAT_GRA] >= 0) {
    for (i = 0; i < p->state.stat_use[STAT_GRA]; i++) {
      tmp = tmp * 12 / 10;
    }
  } else {
    for (i = 0; i < -(p->state.stat_use[STAT_GRA]); i++) {
      tmp = tmp * 10 / 12;
    }
  }
  msp = tmp / 100;
  if (!update) return;
  if (p->msp != msp) {
    i = 100;
    if (p->msp) i = ((100 * p->csp) / p->msp);
    p->msp = msp;
    p->csp = ((i * p->msp) / 100) + (((i * p->msp) % 100 >= 50) ? 1 : 0);
    if (p->csp >= msp) {
      p->csp = msp;
    }
    p->upkeep->redraw |= (PR_MANA);
  }
}
STATIC_OVL void
calc_hitpoints(struct player* p)
{
  int i, mhp, tmp;
  tmp = 20 * 100;
  if (p->state.stat_use[STAT_CON] >= 0) {
    for (i = 0; i < p->state.stat_use[STAT_CON]; i++) {
      tmp = tmp * 12 / 10;
    }
  } else {
    for (i = 0; i < -(p->state.stat_use[STAT_CON]); i++) {
      tmp = tmp * 10 / 12;
    }
  }
  mhp = tmp / 100;
  if (p->mhp != mhp) {
    i = 100;
    if (p->mhp) i = ((100 * p->chp) / p->mhp);
    p->mhp = mhp;
    p->chp = ((i * p->mhp) / 100) + (((i * p->mhp) % 100 >= 50) ? 1 : 0);
    if (p->chp >= mhp) {
      p->chp = mhp;
    }
    p->upkeep->redraw |= (PR_HP);
  }
}
STATIC_OVL int
light_up_to(struct object* obj)
{
  int radius = obj->pval;
  if (of_has(obj->flags, OF_DARKNESS)) {
    while ((radius > -2) && one_in_(3)) {
      radius--;
    }
  } else if (obj->timeout < 100) {
    while ((radius > 0) && one_in_(3)) {
      radius--;
    }
  }
  return radius;
}
STATIC_OVL int
hate_level(struct loc grid, int multiplier)
{
  int dist;
  dist = MAX(flow_dist(cave->monster_noise, grid), 1);
  return (50 * multiplier) / dist;
}
STATIC_OVL bool
weapon_glows(struct object* obj, int near)
{
  int i, total_hate = 0;
  struct loc grid, obj_grid;
  if (!character_dungeon) return false;
  if (!tval_is_melee_weapon(obj) || !obj->slays) return false;
  obj_grid = loc_is_zero(obj->grid) ? player->grid : obj->grid;
  assert(near >= 0);
  grid.x = obj_grid.x - near;
  grid.y = obj_grid.y - near;
  while (1) {
    if (square_in_bounds(cave, grid) && square_isview(cave, grid)) {
      break;
    }
    ++grid.x;
    if (grid.x > obj_grid.x + near) {
      ++grid.y;
      if (grid.y > obj_grid.y + 1) {
        return false;
      }
      grid.x = obj_grid.x - near;
    }
  }
  cave->monster_noise.centre = obj_grid;
  update_flow(cave, &cave->monster_noise, NULL);
  for (i = 1; i < cave_monster_max(cave); i++) {
    bool target = false;
    int j, multiplier = 1;
    struct monster* mon = cave_monster(cave, i);
    struct monster_race* race = mon->race;
    if (!race) continue;
    for (j = 0; j < z_info->slay_max; j++) {
      if (obj->slays[j] && rf_has(race->flags, slays[j].race_flag)) {
        target = true;
        break;
      }
    }
    if (!target) continue;
    if (rf_has(race->flags, RF_UNIQUE)) multiplier *= 2;
    if (!monster_has_friends(mon)) multiplier *= 2;
    total_hate += hate_level(mon->grid, multiplier);
  }
  for (i = 0; i < z_info->slay_max; i++) {
    if (slays[i].race_flag == RF_SPIDER) break;
  }
  if (i < z_info->slay_max && obj->slays[i]) {
    for (grid.y = obj_grid.y - 2; grid.y <= obj_grid.y + 2; grid.y++) {
      for (grid.x = obj_grid.x - 2; grid.x <= obj_grid.x + 2; grid.x++) {
        if (square_in_bounds(cave, grid) && square_iswebbed(cave, grid)) {
          total_hate += hate_level(grid, 1);
        }
      }
    }
  }
  return total_hate >= 15;
}
STATIC_OVL void
calc_light(struct player* p)
{
  int i;
  int new_light = 0;
  struct object* main_weapon = equipped_item_by_slot_name(player, "weapon");
  struct object* second_weapon = equipped_item_by_slot_name(player, "arm");
  struct song* trees = lookup_song("the Trees");
  new_light = 0;
  for (i = 0; i < p->body.count; i++) {
    struct object* obj = slot_object(p, i);
    if (!obj) continue;
    if (of_has(obj->flags, OF_LIGHT)) new_light++;
    if (of_has(obj->flags, OF_DARKNESS)) new_light--;
    if (tval_is_light(obj)) {
      if (of_has(obj->flags, OF_NO_FUEL)) {
        new_light += obj->pval;
      } else if (obj->timeout > 0) {
        new_light += light_up_to(obj);
      }
    }
  }
  if (main_weapon && weapon_glows(main_weapon, 0)) new_light++;
  if (second_weapon && weapon_glows(second_weapon, 0)) new_light++;
  if (p->timed[TMD_DARKENED] && (new_light > 0)) new_light--;
  if (p->upkeep->smithing) new_light += 2;
  if (player_is_singing(p, trees)) {
    new_light += song_bonus(p, p->state.skill_use[SKILL_SONG], trees);
  }
  if (p->upkeep->cur_light != new_light) {
    p->upkeep->cur_light = new_light;
    p->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
  }
  return;
}
STATIC_OVL int
weight_limit(struct player_state state)
{
  int i;
  int limit = 1000;
  int str = state.stat_use[STAT_STR];
  if (str >= 0) {
    for (i = 0; i < str; i++) {
      limit = limit * 12 / 10;
    }
  } else {
    for (i = 0; i < -str; i++) {
      limit = limit * 10 / 12;
    }
  }
  return limit;
}
STATIC_OVL int
weight_remaining(struct player* p)
{
  return weight_limit(p->state) - p->upkeep->total_weight;
}
STATIC_OVL void
calc_bonuses(struct player* p, struct player_state* state, bool known_only,
             bool update)
{
  int i, j;
  struct object* launcher = equipped_item_by_slot_name(p, "shooting");
  struct object* weapon = equipped_item_by_slot_name(p, "weapon");
  struct object* off = equipped_item_by_slot_name(p, "arm");
  bitflag f[OF_SIZE];
  int armour_weight = 0;
  struct song* song;
  if (!player_active_ability(p, "Two Weapon Fighting") && off &&
      tval_is_weapon(off)) {
    msg("You can no longer wield both weapons.");
    inven_takeoff(off);
  }
  memset(state, 0, sizeof *state);
  state->speed = 2;
  state->el_info[ELEM_FIRE].res_level = 1;
  state->el_info[ELEM_COLD].res_level = 1;
  state->el_info[ELEM_POIS].res_level = 1;
  for (i = 0; i < SKILL_MAX; i++) {
    state->skill_misc_mod[i] = p->race->skill_adj[i] + p->house->skill_adj[i];
  }
  pf_copy(state->pflags, p->race->pflags);
  for (i = 0; i < p->body.count; i++) {
    struct object* obj = slot_object(p, i);
    if (obj) {
      if (known_only) {
        object_flags_known(obj, f);
      } else {
        object_flags(obj, f);
      }
      for (j = 0; j < OF_MAX; j++) {
        if (of_has(f, j)) {
          state->flags[j]++;
        }
      }
      for (j = 0; j < STAT_MAX; j++) {
        state->stat_equip_mod[j] += obj->modifiers[j];
      }
      for (j = 0; j < SKILL_MAX; j++) {
        state->skill_equip_mod[j] += obj->modifiers[STAT_MAX + j];
        if (j == SKILL_EVASION) {
          state->skill_equip_mod[j] += obj->evn;
        }
      }
      if (obj->modifiers[OBJ_MOD_DAMAGE_SIDES]) {
        state->to_mds += obj->modifiers[OBJ_MOD_DAMAGE_SIDES];
        state->to_ads += obj->modifiers[OBJ_MOD_DAMAGE_SIDES];
      }
      for (j = 0; j < ELEM_MAX; j++) {
        if (!known_only || obj->known->el_info[j].res_level) {
          state->el_info[j].res_level += obj->el_info[j].res_level;
        }
      }
      if (tval_is_armor(obj)) {
        armour_weight += obj->weight;
      }
      if (tval_is_weapon(obj)) continue;
      state->skill_equip_mod[SKILL_MELEE] += obj->att;
      state->skill_equip_mod[SKILL_ARCHERY] += obj->att;
    }
  }
  if (weapon && player_active_ability(p, "Parry")) {
    state->skill_equip_mod[SKILL_EVASION] += weapon->evn;
  }
  for (i = 0; i < ELEM_MAX; i++) {
    if (state->el_info[i].res_level < 1) {
      state->el_info[i].res_level -= 2;
    }
    if ((i == ELEM_DARK) && character_dungeon) {
      state->el_info[i].res_level = square_light(cave, p->grid);
    }
  }
  state->stat_misc_mod[STAT_STR] += player_active_ability(p, "Strength");
  state->stat_misc_mod[STAT_DEX] += player_active_ability(p, "Dexterity");
  state->stat_misc_mod[STAT_CON] += player_active_ability(p, "Constitution");
  state->stat_misc_mod[STAT_GRA] += player_active_ability(p, "Grace");
  if (player_active_ability(p, "Strength in Adversity")) {
    if (health_level(p->chp, p->mhp) <= HEALTH_BADLY_WOUNDED) {
      state->stat_misc_mod[STAT_STR]++;
      state->stat_misc_mod[STAT_GRA]++;
    }
    if (health_level(p->chp, p->mhp) <= HEALTH_ALMOST_DEAD) {
      state->stat_misc_mod[STAT_STR]++;
      state->stat_misc_mod[STAT_GRA]++;
    }
  }
  if (player_active_ability(p, "Rapid Attack")) {
    state->skill_misc_mod[SKILL_MELEE] -= 3;
  }
  if (player_active_ability(p, "Rapid Fire")) {
    state->skill_misc_mod[SKILL_ARCHERY] -= 3;
  }
  if (player_active_ability(p, "Poison Resistance")) {
    state->el_info[ELEM_POIS].res_level += 1;
  }
  if (player_timed_grade_eq(p, TMD_STUN, "Heavy Stun")) {
    for (i = 0; i < SKILL_MAX; i++) {
      state->skill_misc_mod[i] -= 4;
    }
  } else if (player_timed_grade_eq(p, TMD_STUN, "Stun")) {
    for (i = 0; i < SKILL_MAX; i++) {
      state->skill_misc_mod[i] -= 2;
    }
  }
  if (player_timed_grade_eq(p, TMD_FOOD, "Weak")) {
    state->stat_misc_mod[STAT_STR] -= 1;
  }
  if (p->timed[TMD_RAGE]) {
    state->stat_misc_mod[STAT_STR] += 1;
    state->stat_misc_mod[STAT_DEX] -= 1;
    state->stat_misc_mod[STAT_CON] += 1;
    state->stat_misc_mod[STAT_GRA] -= 1;
  }
  if (p->timed[TMD_STR]) {
    state->stat_misc_mod[STAT_STR] += 3;
    state->flags[OF_SUST_STR] += 1;
  }
  if (p->timed[TMD_DEX]) {
    state->stat_misc_mod[STAT_DEX] += 3;
    state->flags[OF_SUST_DEX] += 1;
  }
  if (p->timed[TMD_CON]) {
    state->stat_misc_mod[STAT_CON] += 3;
    state->flags[OF_SUST_CON] += 1;
  }
  if (p->timed[TMD_GRA]) {
    state->stat_misc_mod[STAT_GRA] += 3;
    state->flags[OF_SUST_GRA] += 1;
  }
  if (p->timed[TMD_FAST]) {
    state->speed += 1;
  }
  if (p->timed[TMD_SLOW]) {
    state->speed -= 1;
  }
  if (p->timed[TMD_SINVIS]) {
    state->flags[OF_SEE_INVIS] += 1;
    state->flags[OF_PROT_BLIND] += 1;
    state->flags[OF_PROT_HALLU] += 1;
  }
  if (player_active_ability(p, "Mind Over Body")) {
    state->flags[OF_HUNGER] -= 1;
  }
  if (player_active_ability(p, "Clarity")) {
    state->flags[OF_PROT_CONF] += 1;
    state->flags[OF_PROT_STUN] += 1;
    state->flags[OF_PROT_HALLU] += 1;
  }
  for (i = 0; i < STAT_MAX; i++) {
    state->stat_use[i] = p->stat_base[i] + state->stat_equip_mod[i] +
                         p->stat_drain[i] + state->stat_misc_mod[i];
    if (!p->body.name) {
      state->stat_use[i] += p->race->stat_adj[i] + p->house->stat_adj[i];
    }
    state->stat_use[i] = MIN(state->stat_use[i], BASE_STAT_MAX);
    state->stat_use[i] = MAX(state->stat_use[i], BASE_STAT_MIN);
  }
  j = p->upkeep->total_weight;
  i = weight_limit(*state);
  if (j > i) state->speed -= 1;
  state->speed += state->flags[OF_SPEED];
  if (p->stealth_mode) {
    if (p->previous_action[0] != ACTION_STAND) state->speed -= 1;
    state->skill_misc_mod[SKILL_STEALTH] += z_info->stealth_bonus;
  }
  if (player_is_sprinting(p)) {
    state->speed += 1;
  }
  state->speed = MIN(3, MAX(1, state->speed));
  if (state->flags[OF_REGEN]) state->flags[OF_HUNGER] += 1;
  state->skill_equip_mod[SKILL_STEALTH] -= armour_weight / 100;
  state->skill_misc_mod[SKILL_STEALTH] -= player_song_noise(p);
  state->skill_stat_mod[SKILL_MELEE] = state->stat_use[STAT_DEX];
  state->skill_stat_mod[SKILL_ARCHERY] = state->stat_use[STAT_DEX];
  state->skill_stat_mod[SKILL_EVASION] = state->stat_use[STAT_DEX];
  state->skill_stat_mod[SKILL_STEALTH] = state->stat_use[STAT_DEX];
  state->skill_stat_mod[SKILL_PERCEPTION] = state->stat_use[STAT_GRA];
  state->skill_stat_mod[SKILL_WILL] = state->stat_use[STAT_GRA];
  state->skill_stat_mod[SKILL_SMITHING] = state->stat_use[STAT_GRA];
  state->skill_stat_mod[SKILL_SONG] = state->stat_use[STAT_GRA];
  state->skill_use[SKILL_SONG] =
      p->skill_base[SKILL_SONG] + state->skill_equip_mod[SKILL_SONG] +
      state->skill_stat_mod[SKILL_SONG] + state->skill_misc_mod[SKILL_SONG];
  song = lookup_song("Slaying");
  if (player_is_singing(p, song)) {
    int pskill = state->skill_use[SKILL_SONG];
    state->skill_misc_mod[SKILL_MELEE] += song_bonus(p, pskill, song);
    state->skill_misc_mod[SKILL_ARCHERY] += song_bonus(p, pskill, song);
  }
  song = lookup_song("Aule");
  if (player_is_singing(p, song)) {
    int pskill = state->skill_use[SKILL_SONG];
    state->skill_misc_mod[SKILL_SMITHING] += song_bonus(p, pskill, song);
  }
  song = lookup_song("Staying");
  if (player_is_singing(p, song)) {
    int pskill = state->skill_use[SKILL_SONG];
    state->skill_misc_mod[SKILL_WILL] += song_bonus(p, pskill, song);
  }
  song = lookup_song("Freedom");
  if (player_is_singing(p, song)) {
    state->flags[OF_FREE_ACT] += 1;
  }
  if (launcher) {
    state->skill_equip_mod[SKILL_ARCHERY] += launcher->att;
    state->ammo_tval = TV_ARROW;
    state->add = launcher->dd;
    state->ads = total_ads(p, state, launcher, false);
  }
  if (weapon) {
    state->skill_equip_mod[SKILL_MELEE] += weapon->att;
    state->skill_misc_mod[SKILL_MELEE] += blade_bonus(p, weapon) +
                                          axe_bonus(p, weapon) +
                                          polearm_bonus(p, weapon);
  }
  if (player_active_ability(p, "Versatility") &&
      (p->skill_base[SKILL_ARCHERY] > p->skill_base[SKILL_MELEE])) {
    state->skill_misc_mod[SKILL_MELEE] +=
        (p->skill_base[SKILL_ARCHERY] - p->skill_base[SKILL_MELEE]) / 2;
  }
  state->mdd = total_mdd(p, weapon);
  state->mds = total_mds(p, state, weapon,
                         player_active_ability(p, "Rapid Attack") ? -3 : 0);
  if (player_active_ability(p, "Two Weapon Fighting") && off &&
      tval_is_weapon(off)) {
    if (weapon) {
      state->offhand_mel_mod -= weapon->att + blade_bonus(p, weapon) +
                                axe_bonus(p, weapon) + polearm_bonus(p, weapon);
    }
    if (player_active_ability(p, "Rapid Attack")) {
      state->offhand_mel_mod += 3;
    }
    state->offhand_mel_mod += off->att + blade_bonus(p, off) +
                              axe_bonus(p, off) + polearm_bonus(p, off) - 3;
    state->mdd2 = total_mdd(p, off);
    state->mds2 = total_mds(p, state, off, -3);
  }
  if (p->timed[TMD_ENTRANCED] ||
      player_timed_grade_eq(p, TMD_STUN, "Knocked Out")) {
    state->skill_misc_mod[SKILL_EVASION] =
        -5 -
        (p->skill_base[SKILL_EVASION] + state->skill_equip_mod[SKILL_EVASION] +
         state->skill_stat_mod[SKILL_EVASION]);
  }
  for (i = 0; i < SKILL_SONG; i++) {
    state->skill_use[i] = p->skill_base[i] + state->skill_equip_mod[i] +
                          state->skill_stat_mod[i] + state->skill_misc_mod[i];
  }
  state->p_min = protection_roll(p, PROJ_HURT, true, MINIMISE);
  state->p_max = protection_roll(p, PROJ_HURT, true, MINIMISE);
  return;
}
STATIC_OVL void
update_bonuses(struct player* p)
{
  int i;
  struct player_state state = p->state;
  struct player_state known_state = p->known_state;
  calc_bonuses(p, &state, false, true);
  calc_bonuses(p, &known_state, true, true);
  for (i = 0; i < STAT_MAX; i++) {
    if (state.stat_use[i] != p->state.stat_use[i]) {
      p->upkeep->redraw |= (PR_STATS);
      if (i == STAT_CON) p->upkeep->update |= (PU_HP);
      if (i == STAT_GRA) p->upkeep->update |= (PU_MANA);
    }
  }
  if (state.flags[OF_SEE_INVIS] != p->state.flags[OF_SEE_INVIS])
    p->upkeep->update |= (PU_MONSTERS);
  if (state.speed != p->state.speed) p->upkeep->redraw |= (PR_SPEED);
  p->upkeep->redraw |= (PR_TERRAIN);
  if ((state.skill_use[SKILL_MELEE] != p->state.skill_use[SKILL_MELEE]) ||
      (state.mdd != p->state.mdd) || (state.mds != p->state.mds) ||
      (state.mdd2 != p->state.mdd2) || (state.mds2 != p->state.mds2)) {
    p->upkeep->redraw |= (PR_MELEE);
  }
  if ((state.skill_use[SKILL_ARCHERY] != p->state.skill_use[SKILL_ARCHERY]) ||
      (state.add != p->state.add) || (state.ads != p->state.ads)) {
    p->upkeep->redraw |= (PR_ARC);
  }
  if (state.skill_use[SKILL_EVASION] != p->state.skill_use[SKILL_EVASION] ||
      state.p_min != p->state.p_min || state.p_max != p->state.p_max) {
    p->upkeep->redraw |= (PR_ARMOR);
  }
  memcpy(&p->state, &state, sizeof(state));
  memcpy(&p->known_state, &known_state, sizeof(known_state));
  update_player_object_knowledge(p);
}
STATIC_OVL void
health_track(struct player_upkeep* upkeep, struct monster* mon)
{
  upkeep->health_who = mon;
  upkeep->redraw |= PR_HEALTH;
}
STATIC_OVL void
monster_race_track(struct player_upkeep* upkeep, struct monster_race* race)
{
  if (player->timed[TMD_IMAGE] || player->timed[TMD_RAGE]) return;
  upkeep->monster_race = race;
  upkeep->redraw |= (PR_MONSTER);
}
STATIC_OVL void
track_object(struct player_upkeep* upkeep, struct object* obj)
{
  upkeep->object = obj;
  upkeep->object_kind = NULL;
  upkeep->redraw |= (PR_OBJECT);
}
STATIC_OVL void
track_object_kind(struct player_upkeep* upkeep, struct object_kind* kind)
{
  upkeep->object = NULL;
  upkeep->object_kind = kind;
  upkeep->redraw |= (PR_OBJECT);
}
STATIC_OVL void
track_object_cancel(struct player_upkeep* upkeep)
{
  upkeep->object = NULL;
  upkeep->object_kind = NULL;
  upkeep->redraw |= (PR_OBJECT);
}
STATIC_OVL bool
tracked_object_is(struct player_upkeep* upkeep, struct object* obj)
{
  return (upkeep->object == obj);
}
STATIC_OVL void
notice_stuff(struct player* p)
{
  if (!p->upkeep->notice) return;
  if (p->upkeep->notice & PN_IGNORE) {
    p->upkeep->notice &= ~(PN_IGNORE);
    ignore_drop(p);
  }
  if (p->upkeep->notice & PN_COMBINE) {
    p->upkeep->notice &= ~(PN_COMBINE);
    combine_pack(p);
  }
  if (p->upkeep->notice & PN_MON_MESSAGE) {
    p->upkeep->notice &= ~(PN_MON_MESSAGE);
    show_monster_messages();
  }
}
STATIC_OVL void
update_stuff(struct player* p)
{
  if (!p->upkeep->update) return;
  if (p->upkeep->update & (PU_INVEN)) {
    p->upkeep->update &= ~(PU_INVEN);
    calc_inventory(p);
  }
  if (p->upkeep->update & (PU_BONUS)) {
    p->upkeep->update &= ~(PU_BONUS);
    update_bonuses(p);
  }
  if (p->upkeep->update & (PU_TORCH)) {
    p->upkeep->update &= ~(PU_TORCH);
    calc_light(p);
  }
  if (p->upkeep->update & (PU_HP)) {
    p->upkeep->update &= ~(PU_HP);
    calc_hitpoints(p);
  }
  if (p->upkeep->update & (PU_MANA)) {
    p->upkeep->update &= ~(PU_MANA);
    calc_voice(p, true);
  }
  if (!character_generated) return;
  if (!map_is_visible()) return;
  if (p->upkeep->update & (PU_UPDATE_VIEW)) {
    p->upkeep->update &= ~(PU_UPDATE_VIEW);
    update_view(cave, p);
  }
  if (p->upkeep->update & (PU_DISTANCE)) {
    p->upkeep->update &= ~(PU_DISTANCE);
    p->upkeep->update &= ~(PU_MONSTERS);
    update_monsters(true);
  }
  if (p->upkeep->update & (PU_MONSTERS)) {
    p->upkeep->update &= ~(PU_MONSTERS);
    update_monsters(false);
  }
  if (p->upkeep->update & (PU_PANEL)) {
    p->upkeep->update &= ~(PU_PANEL);
    event_signal(EVENT_PLAYERMOVED);
  }
}
STATIC_OVL void
redraw_stuff(struct player* p)
{
  size_t i;
  uint32_t redraw = p->upkeep->redraw;
  if (!redraw) return;
  if (!character_generated) return;
  if (!map_is_visible()) redraw &= PR_SUBWINDOW;
  if (((player_resting_count(p) % 100) || (p->upkeep->running % 100)) &&
      !(redraw & (PR_MESSAGE | PR_MAP)))
    return;
  for (i = 0; i < N_ELEMENTS(redraw_events); i++) {
    const struct flag_event_trigger* hnd = &redraw_events[i];
    if (redraw & hnd->flag) event_signal(hnd->event);
  }
  if (redraw & PR_MAP) {
    event_signal_point(EVENT_MAP, -1, -1);
  }
  p->upkeep->redraw &= ~redraw;
  if (!map_is_visible()) return;
  event_signal(EVENT_END);
}
STATIC_OVL void
handle_stuff(struct player* p)
{
  if (p->upkeep->update) update_stuff(p);
  if (p->upkeep->redraw) redraw_stuff(p);
}
STATIC_OVL void
history_init(struct player_history* h)
{
  h->next = 0;
  h->length = 20;
  h->entries = mem_zalloc(h->length * sizeof(*h->entries));
}
STATIC_OVL void
history_realloc(struct player_history* h)
{
  h->length += 20;
  h->entries = mem_realloc(h->entries, h->length * sizeof *h->entries);
}
STATIC_OVL void
history_clear(struct player* p)
{
  struct player_history* h = &p->hist;
  if (h->entries) {
    mem_free(h->entries);
    h->entries = NULL;
  }
  h->next = 0;
  h->length = 0;
}
STATIC_OVL bool
history_add_full(struct player* p, bitflag* type, int aidx, int dlev,
                 int turnno, const char* text)
{
  struct player_history* h = &p->hist;
  if (!h->entries)
    history_init(h);
  else if (h->next == h->length)
    history_realloc(h);
  hist_copy(h->entries[h->next].type, type);
  h->entries[h->next].dlev = dlev;
  h->entries[h->next].a_idx = aidx;
  h->entries[h->next].turn = turnno;
  my_strcpy(h->entries[h->next].event, text, sizeof(h->entries[h->next].event));
  h->next++;
  return true;
}
STATIC_OVL bool
history_add_with_flags(struct player* p, const char* text,
                       bitflag flags[HIST_SIZE],
                       const struct artifact* artifact)
{
  return history_add_full(p, flags, artifact ? artifact->aidx : 0, p->depth,
                          p->turn, text);
}
STATIC_OVL bool
history_add(struct player* p, const char* text, int type)
{
  bitflag flags[HIST_SIZE];
  hist_wipe(flags);
  hist_on(flags, type);
  return history_add_with_flags(p, text, flags, NULL);
}
STATIC_OVL bool
history_is_artifact_known(struct player* p, const struct artifact* artifact)
{
  struct player_history* h = &p->hist;
  size_t i = h->next;
  assert(artifact);
  while (i--) {
    if (hist_has(h->entries[i].type, HIST_ARTIFACT_KNOWN) &&
        h->entries[i].a_idx == artifact->aidx)
      return true;
  }
  return false;
}
STATIC_OVL bool
history_mark_artifact_known(struct player_history* h,
                            const struct artifact* artifact)
{
  assert(artifact);
  size_t i = h->next;
  while (i--) {
    if (h->entries[i].a_idx == artifact->aidx) {
      hist_off(h->entries[i].type, HIST_ARTIFACT_UNKNOWN);
      hist_on(h->entries[i].type, HIST_ARTIFACT_KNOWN);
      return true;
    }
  }
  return false;
}
STATIC_OVL bool
history_mark_artifact_lost(struct player_history* h,
                           const struct artifact* artifact)
{
  assert(artifact);
  size_t i = h->next;
  while (i--) {
    if (h->entries[i].a_idx == artifact->aidx) {
      hist_on(h->entries[i].type, HIST_ARTIFACT_LOST);
      return true;
    }
  }
  return false;
}
STATIC_OVL void
get_artifact_name(char* buf, size_t len, const struct artifact* artifact)
{
  struct object body = OBJECT_NULL;
  struct object known_body = OBJECT_NULL;
  struct object* fake = &body;
  struct object* known_obj = &known_body;
  make_fake_artifact(fake, artifact);
  fake->known = known_obj;
  object_copy(known_obj, fake);
  object_desc(buf, len, fake, ODESC_PREFIX | ODESC_BASE | ODESC_SPOIL, NULL);
  object_wipe(known_obj);
  object_wipe(fake);
}
STATIC_OVL void
history_find_artifact(struct player* p, const struct artifact* artifact)
{
  assert(artifact != NULL);
  if (!history_mark_artifact_known(&p->hist, artifact)) {
    char o_name[80];
    char text[80];
    get_artifact_name(o_name, sizeof(o_name), artifact);
    strnfmt(text, sizeof(text), "Found %s", o_name);
    bitflag flags[HIST_SIZE];
    hist_wipe(flags);
    hist_on(flags, HIST_ARTIFACT_KNOWN);
    history_add_with_flags(p, text, flags, artifact);
  }
}
STATIC_OVL void
history_lose_artifact(struct player* p, const struct artifact* artifact)
{
  assert(artifact != NULL);
  if (!history_mark_artifact_lost(&p->hist, artifact)) {
    char o_name[80];
    char text[80];
    get_artifact_name(o_name, sizeof(o_name), artifact);
    strnfmt(text, sizeof(text), "Missed %s", o_name);
    bitflag flags[HIST_SIZE];
    hist_wipe(flags);
    hist_on(flags, HIST_ARTIFACT_UNKNOWN);
    hist_on(flags, HIST_ARTIFACT_LOST);
    history_add_with_flags(p, text, flags, artifact);
  }
}
STATIC_OVL void
history_unmask_unknown(struct player* p)
{
  struct player_history* h = &p->hist;
  size_t i = h->next;
  while (i--) {
    if (hist_has(h->entries[i].type, HIST_ARTIFACT_UNKNOWN)) {
      hist_off(h->entries[i].type, HIST_ARTIFACT_UNKNOWN);
      hist_on(h->entries[i].type, HIST_ARTIFACT_KNOWN);
    }
  }
}
STATIC_OVL size_t
history_get_list(struct player* p, struct history_info** list)
{
  struct player_history* h = &p->hist;
  *list = h->entries;
  return h->next;
}
STATIC_OVL bool
is_valid_pf(struct player* p, struct loc grid)
{
  if (!square_isknown(p->cave, grid)) return true;
  if (square_isvisibletrap(p->cave, grid)) {
    return false;
  }
  if (square_ispassable(p->cave, grid)) {
    return true;
  }
  if (square_iscloseddoor(p->cave, grid) || square_isrubble(p->cave, grid)) {
    return true;
  }
  return false;
}
STATIC_OVL void
get_pathfind_region(void)
{
  top_left.x = MAX(player->grid.x - 100 / 2, 0);
  top_left.y = MAX(player->grid.y - 100 / 2, 0);
  bottom_right.x = MIN(player->grid.x + 100 / 2 - 1, cave->width);
  bottom_right.y = MIN(player->grid.y + 100 / 2 - 1, cave->height);
}
STATIC_OVL int
path_dist(struct loc grid)
{
  return path_distance[grid.y - top_left.y][grid.x - top_left.x];
}
STATIC_OVL void
set_path_dist(struct loc grid, int dist)
{
  assert(grid.y >= top_left.y);
  assert(grid.x >= top_left.x);
  assert(grid.y < bottom_right.y);
  assert(grid.x < bottom_right.x);
  path_distance[grid.y - top_left.y][grid.x - top_left.x] = dist;
}
STATIC_OVL void
path_dist_info_init(void)
{
  struct loc grid;
  for (grid.y = 0; grid.y < 100; grid.y++)
    for (grid.x = 0; grid.x < 100; grid.x++) path_distance[grid.y][grid.x] = -1;
  for (grid.y = top_left.y; grid.y < bottom_right.y; grid.y++)
    for (grid.x = top_left.x; grid.x < bottom_right.x; grid.x++)
      if (is_valid_pf(player, grid)) set_path_dist(grid, 500);
  set_path_dist(player->grid, 0);
}
STATIC_OVL bool
set_up_path_distances(struct loc grid)
{
  int i;
  struct point_set* reached;
  get_pathfind_region();
  path_dist_info_init();
  if ((grid.x >= top_left.x) && (grid.x < bottom_right.x) &&
      (grid.y >= top_left.y) && (grid.y < bottom_right.y)) {
    if ((square(cave, grid)->mon > 0) &&
        monster_is_visible(square_monster(cave, grid))) {
      set_path_dist(grid, 500);
    }
  } else {
    bell();
    return false;
  }
  reached = point_set_new(100 * 100);
  add_to_point_set(reached, player->grid);
  for (i = 0; i < reached->n; i++) {
    int k, cur_distance = path_dist(reached->pts[i]) + 1;
    for (k = 0; k < 8; k++) {
      struct loc next = loc_sum(reached->pts[i], ddgrid_ddd[k]);
      if ((next.y < top_left.y) || (next.y >= bottom_right.y) ||
          (next.x < top_left.x) || (next.x >= bottom_right.x) ||
          (path_dist(next) <= cur_distance) || (path_dist(next) > 500)) {
        continue;
      }
      set_path_dist(next, cur_distance);
      add_to_point_set(reached, next);
    }
  }
  point_set_dispose(reached);
  if (path_dist(grid) == -1 || path_dist(grid) == 500) {
    bell();
    return false;
  }
  return true;
}
STATIC_OVL bool
find_path(struct loc grid)
{
  struct loc new = grid;
  if (loc_eq(new, player->grid)) return false;
  if (!set_up_path_distances(grid)) return false;
  path_step_idx = 0;
  while (!loc_eq(new, player->grid)) {
    int k, next_distance = path_dist(new) - 1;
    for (k = 0; k < 8; k++) {
      struct loc next = loc_sum(new, ddgrid_ddd[k]);
      if (next.y < top_left.y || next.y >= bottom_right.y ||
          next.x < top_left.x || next.x >= bottom_right.x) {
        continue;
      }
      if (path_dist(next) == next_distance) break;
    }
    if (path_step_idx >= 500) return false;
    path_step_dir[path_step_idx++] = 10 - ddd[k];
    new = loc_sum(new, ddgrid_ddd[k]);
  }
  path_step_idx--;
  assert(path_step_idx >= 0);
  return true;
}
STATIC_OVL int
pathfind_direction_to(struct loc from, struct loc to)
{
  int adx = ABS(to.x - from.x);
  int ady = ABS(to.y - from.y);
  int dx = to.x - from.x;
  int dy = to.y - from.y;
  if (dx == 0 && dy == 0) return DIR_NONE;
  if (dx >= 0 && dy >= 0) {
    if (adx < ady * 2 && ady < adx * 2)
      return DIR_SE;
    else if (adx > ady)
      return DIR_E;
    else
      return DIR_S;
  } else if (dx > 0 && dy < 0) {
    if (adx < ady * 2 && ady < adx * 2)
      return DIR_NE;
    else if (adx > ady)
      return DIR_E;
    else
      return DIR_N;
  } else if (dx < 0 && dy > 0) {
    if (adx < ady * 2 && ady < adx * 2)
      return DIR_SW;
    else if (adx > ady)
      return DIR_W;
    else
      return DIR_S;
  } else if (dx <= 0 && dy <= 0) {
    if (adx < ady * 2 && ady < adx * 2)
      return DIR_NW;
    else if (adx > ady)
      return DIR_W;
    else
      return DIR_N;
  }
  assert(0);
  return DIR_UNKNOWN;
}
STATIC_OVL bool
see_wall(int dir, struct loc grid)
{
  grid = loc_sum(grid, ddgrid[dir]);
  if (!square_in_bounds(cave, grid)) return false;
  if (square_iswebbed(cave, grid)) return true;
  if (!square_seemslikewall(cave, grid)) return false;
  if (!square_isknown(cave, grid)) return false;
  return true;
}
STATIC_OVL void
run_init(int dir)
{
  int i;
  struct loc grid;
  bool deepleft, deepright;
  bool shortleft, shortright;
  player->upkeep->running_firststep = true;
  run_cur_dir = dir;
  run_old_dir = dir;
  run_open_area = true;
  run_break_right = false;
  run_break_left = false;
  deepleft = deepright = false;
  shortright = shortleft = false;
  grid = loc_sum(player->grid, ddgrid[dir]);
  i = chome[dir];
  if (see_wall(cycle[i + 1], player->grid)) {
    run_break_left = true;
    shortleft = true;
  } else if (see_wall(cycle[i + 1], grid)) {
    run_break_left = true;
    deepleft = true;
  }
  if (see_wall(cycle[i - 1], player->grid)) {
    run_break_right = true;
    shortright = true;
  } else if (see_wall(cycle[i - 1], grid)) {
    run_break_right = true;
    deepright = true;
  }
  if (run_break_left && run_break_right) {
    run_open_area = false;
    if (dir & 0x01) {
      if (deepleft && !deepright)
        run_old_dir = cycle[i - 1];
      else if (deepright && !deepleft)
        run_old_dir = cycle[i + 1];
    } else if (see_wall(cycle[i], player->grid)) {
      if (shortleft && !shortright)
        run_old_dir = cycle[i - 2];
      else if (shortright && !shortleft)
        run_old_dir = cycle[i + 2];
    }
  }
}
STATIC_OVL bool
run_test(const struct player* p)
{
  int prev_dir;
  int new_dir;
  struct loc grid;
  int i, max, inv;
  int option, option2;
  option = 0;
  option2 = 0;
  prev_dir = run_old_dir;
  max = (prev_dir & 0x01) + 1;
  for (i = -max; i <= max; i++) {
    struct object* obj;
    new_dir = cycle[chome[prev_dir] + i];
    grid = loc_sum(p->grid, ddgrid[new_dir]);
    if (square(cave, grid)->mon > 0) {
      struct monster* mon = square_monster(cave, grid);
      if (monster_is_visible(mon)) {
        return true;
      }
    }
    if (square_isvisibletrap(cave, grid)) {
      return true;
    }
    for (obj = square_object(cave, grid); obj; obj = obj->next)
      if (obj->known && !ignore_item_ok(p, obj)) return true;
    inv = true;
    if (square_isknown(cave, grid)) {
      bool notice = square_isinteresting(p->cave, grid);
      if (notice) return true;
      inv = false;
    }
    if (inv || square_ispassable(cave, grid)) {
      if (run_open_area) {
      } else if (!option) {
        option = new_dir;
      } else if (option2) {
        return true;
      } else if (option != cycle[chome[prev_dir] + i - 1]) {
        return true;
      } else if (new_dir & 0x01) {
        option2 = new_dir;
      } else {
        option2 = option;
        option = new_dir;
      }
    } else {
      if (run_open_area) {
        if (i < 0) {
          run_break_right = true;
        } else if (i > 0) {
          run_break_left = true;
        }
      }
    }
  }
  for (i = -max; i <= max; i++) {
    new_dir = cycle[chome[prev_dir] + i];
    grid = loc_sum(p->grid, loc_sum(ddgrid[prev_dir], ddgrid[new_dir]));
    if (!square_in_bounds(cave, grid)) continue;
    if (square(cave, grid)->mon > 0) {
      struct monster* mon = square_monster(cave, grid);
      if (monster_is_visible(mon)) return true;
    }
  }
  if (run_open_area) {
    for (i = -max; i < 0; i++) {
      new_dir = cycle[chome[prev_dir] + i];
      grid = loc_sum(p->grid, ddgrid[new_dir]);
      if (!square_isknown(cave, grid) || square_ispassable(cave, grid)) {
        if (run_break_right) {
          return true;
        }
      } else {
        if (run_break_left) {
          return true;
        }
      }
    }
    for (i = max; i > 0; i--) {
      new_dir = cycle[chome[prev_dir] + i];
      grid = loc_sum(p->grid, ddgrid[new_dir]);
      if (!square_isknown(cave, grid) || square_ispassable(cave, grid)) {
        if (run_break_left) {
          return true;
        }
      } else {
        if (run_break_right) {
          return true;
        }
      }
    }
  } else {
    if (!option) {
      return true;
    } else if (!option2) {
      run_cur_dir = option;
      run_old_dir = option;
    } else {
      run_cur_dir = option;
      run_old_dir = option2;
    }
  }
  if (see_wall(run_cur_dir, p->grid)) return true;
  return false;
}
STATIC_OVL void
run_step(int dir)
{
  bool disarm = true;
  if (dir) {
    run_init(dir);
    if (player->upkeep->running == 0) player->upkeep->running = 9999;
    player->upkeep->update |= (PU_TORCH);
  } else {
    if (!player->upkeep->running_withpathfind) {
      if (run_test(player)) {
        disturb(player, false);
        return;
      }
    } else if (path_step_idx < 0) {
      disturb(player, false);
      player->upkeep->running_withpathfind = false;
      return;
    } else {
      struct loc grid =
          loc_sum(player->grid, ddgrid[path_step_dir[path_step_idx]]);
      if (path_step_idx == 0) {
        if (square_isknown(cave, grid) && !square_ispassable(cave, grid)) {
          disturb(player, false);
          player->upkeep->running_withpathfind = false;
          return;
        }
      } else if (path_step_idx > 0) {
        struct object* obj;
        grid = loc_sum(player->grid, ddgrid[path_step_dir[path_step_idx]]);
        if (square_isknown(cave, grid) &&
            !square_ispassable(player->cave, grid)) {
          disturb(player, false);
          player->upkeep->running_withpathfind = false;
          return;
        }
        if (square(cave, grid)->mon > 0) {
          struct monster* mon = square_monster(cave, grid);
          if (monster_is_visible(mon)) {
            disturb(player, false);
            player->upkeep->running_withpathfind = false;
            return;
          }
        }
        for (obj = square_object(player->cave, grid); obj; obj = obj->next) {
          if (obj->known && !ignore_item_ok(player, obj)) {
            disturb(player, false);
            player->upkeep->running_withpathfind = false;
            return;
          }
        }
        grid = loc_sum(grid, ddgrid[path_step_dir[path_step_idx - 1]]);
        if (square_isknown(cave, grid) && !square_ispassable(cave, grid)) {
          player->upkeep->running_withpathfind = false;
          run_init(path_step_dir[path_step_idx]);
        }
      }
      run_cur_dir = path_step_dir[path_step_idx--];
    }
  }
  player->upkeep->energy_use = z_info->move_energy;
  move_player(run_cur_dir, dir && disarm ? true : false);
  if (!square_in_bounds_fully(cave, player->grid)) {
    do_cmd_escape();
    return;
  }
  if (player->upkeep->running) {
    player->upkeep->running--;
  } else if (!player->upkeep->running_withpathfind)
    return;
  if (player->upkeep->running) {
    cmdq_push(CMD_RUN);
    if (player->upkeep->running_withpathfind) {
      cmdq_peek()->is_background_command = true;
    }
    cmd_set_arg_direction(cmdq_peek(), "direction", 0);
  }
}
STATIC_OVL void
drop_iron_crown(struct monster* mon, const char* message)
{
  int i;
  struct loc grid;
  struct monster_race* race = mon->race;
  const struct artifact* crown = lookup_artifact_name("of Morgoth");
  bool note;
  if (!is_artifact_created(crown)) {
    struct object* obj;
    struct object_kind* kind;
    msg(message);
    find_nearby_grid(cave, &grid, mon->grid, 1, 1);
    for (i = 0; i < 1000; i++) {
      find_nearby_grid(cave, &grid, mon->grid, 1, 1);
      if (!loc_eq(grid, mon->grid) && square_isfloor(cave, grid)) break;
    }
    obj = mem_zalloc(sizeof(*obj));
    kind = lookup_kind(crown->tval, crown->sval);
    object_prep(obj, kind, z_info->dun_depth, RANDOMISE);
    obj->artifact = crown;
    copy_artifact_data(obj, obj->artifact);
    mark_artifact_created(crown, true);
    obj->origin = ORIGIN_DROP;
    obj->origin_depth = convert_depth_to_origin(cave->depth);
    obj->origin_race = race;
    obj->number = 1;
    floor_carry(cave, grid, obj, &note);
    race->pd -= 1;
    race->light = 0;
    race->wil += 5;
    race->per += 5;
  }
}
STATIC_OVL void
shatter_weapon(struct player* p, int silnum)
{
  int i;
  struct object* weapon = equipped_item_by_slot_name(p, "weapon");
  struct object* destroyed;
  char w_name[80];
  bool dummy = false;
  p->crown_shatter = true;
  object_desc(w_name, sizeof(w_name), weapon, false, 0);
  if (silnum == 2) {
    msg("You strive to free a second Silmaril, but it is not fated to be.");
  } else {
    msg("You strive to free a third Silmaril, but it is not fated to be.");
  }
  msg("As you strike the crown, your %s shatters into innumerable pieces.",
      w_name);
  p->stealth_score -= 5;
  destroyed = gear_object_for_use(player, weapon, 1, false, &dummy);
  object_delete(p->cave, NULL, &destroyed->known);
  object_delete(cave, p->cave, &destroyed);
  for (i = 1; i < cave_monster_max(cave); i++) {
    struct monster* mon = cave_monster(cave, i);
    if (rf_has(mon->race->flags, RF_QUESTOR)) {
      if ((mon->cdis <= 5) && los(cave, p->grid, mon->grid)) {
        msg("A shard strikes Morgoth upon his cheek.");
        set_alertness(mon, ALERTNESS_VERY_ALERT);
      }
    }
  }
}
STATIC_OVL void
break_truce(struct player* p, bool obvious)
{
  int i;
  struct monster* mon = NULL;
  char m_name[80];
  if (p->truce) {
    for (i = cave_monster_max(cave) - 1; i >= 1; i--) {
      mon = cave_monster(cave, i);
      if (!mon->race) continue;
      if (!los(cave, mon->grid, p->grid)) continue;
      if (mon->alertness < ALERTNESS_ALERT) continue;
      monster_desc(m_name, sizeof(m_name), mon, MDESC_STANDARD);
      p->truce = false;
    }
    if (obvious) p->truce = false;
    if (!p->truce) {
      if (!obvious) {
        msg("%s lets out a cry! The tension is broken.", m_name);
        cave->monster_noise.centre = mon->grid;
        update_flow(cave, &cave->monster_noise, NULL);
        monsters_hear(false, false, -10);
      } else {
        msg("The tension is broken.");
      }
      for (i = cave_monster_max(cave) - 1; i >= 1; i--) {
        mon = cave_monster(cave, i);
        if (!mon->race) continue;
        mon->min_range = 0;
      }
    }
  }
}
STATIC_OVL void
check_truce(struct player* p)
{
  int d;
  for (d = 0; d < 8; d++) {
    struct loc grid = loc_sum(p->grid, ddgrid_ddd[d]);
    struct monster* mon = square_monster(cave, grid);
    if (mon && (mon->race == lookup_monster("Morgoth, Lord of Darkness")) &&
        (mon->alertness >= ALERTNESS_ALERT)) {
      msg("With a voice as of rolling thunder, Morgoth, Lord of Darkness, "
          "speaks:");
      msg("'You dare challenge me in mine own hall? Now is your death upon "
          "you!'");
      break_truce(p, true);
      return;
    }
  }
}
STATIC_OVL void
wake_all_monsters(struct player* p)
{
  int i;
  for (i = 1; i < cave_monster_max(cave); i++) {
    struct monster* mon = cave_monster(cave, i);
    if (!mon->race) continue;
    set_alertness(mon, MAX(mon->alertness, ALERTNESS_VERY_ALERT));
    if (p->upkeep->health_who == mon) p->upkeep->redraw |= (PR_HEALTH);
  }
}
STATIC_OVL void
prise_silmaril(struct player* p)
{
  struct object *obj, *weapon;
  const char* freed_msg = NULL;
  bool freed = false;
  int net_dam = 0;
  int hit_result = 0;
  int pd = 0;
  int noise = 0;
  int mds = p->state.mds;
  int attack_mod = p->state.skill_use[SKILL_MELEE];
  struct monster_race* race = lookup_monster("Morgoth, Lord of Darkness");
  obj = square_object(cave, p->grid);
  switch (obj->pval) {
    case 3: {
      pd = 15;
      noise = 5;
      freed_msg = "You have freed a Silmaril!";
      break;
    }
    case 2: {
      pd = 25;
      noise = 10;
      if (p->crown_shatter) {
        freed_msg = "The fates be damned! You free a second Silmaril.";
      } else {
        freed_msg = "You free a second Silmaril.";
      }
      break;
    }
    case 1: {
      pd = 30;
      noise = 15;
      freed_msg =
          "You free the final Silmaril. You have a very bad feeling about "
          "this.";
      msg("Looking into the hallowed light of the final Silmaril, you are "
          "filled with a strange dread.");
      if (!get_check("Are you sure you wish to proceed? ")) return;
      break;
    }
  }
  weapon = equipped_item_by_slot_name(p, "weapon");
  if (player_active_ability(p, "Rapid Attack")) {
    mds = total_mds(p, &p->state, weapon, 0);
    attack_mod += 3;
  }
  hit_result = hit_roll(attack_mod, 0, source_player(), source_none(), true);
  p->stealth_score -= noise;
  if (hit_result > 0) {
    int dummy;
    int crit_bonus_dice =
        crit_bonus(p, hit_result, weapon->weight, race, SKILL_MELEE, false);
    int dam = damroll(p->state.mdd + crit_bonus_dice, mds);
    int prt = damroll(pd, 4);
    int prt_percent = prt_after_sharpness(p, weapon, &dummy);
    prt = (prt * prt_percent) / 100;
    net_dam = MAX(dam - prt, 0);
    event_signal_combat_damage(EVENT_COMBAT_DAMAGE,
                               p->state.mdd + crit_bonus_dice, mds, dam, pd, 4,
                               prt, prt_percent, PROJ_HURT, true);
  }
  if (net_dam > 0) {
    freed = true;
    switch (obj->pval) {
      case 3: {
        break;
      }
      case 2: {
        if (!p->crown_shatter && one_in_(2)) {
          shatter_weapon(p, 2);
          freed = false;
        }
        break;
      }
      case 1: {
        if (!p->crown_shatter) {
          shatter_weapon(p, 3);
          freed = false;
        } else {
          p->cursed = true;
        }
        break;
      }
    }
    if (freed) {
      struct object* sil = object_new();
      struct object_kind* kind =
          lookup_kind(TV_LIGHT, lookup_sval(TV_LIGHT, "Silmaril"));
      obj->pval--;
      msg(freed_msg);
      object_prep(sil, kind, z_info->dun_depth, RANDOMISE);
      inven_carry(p, sil, true, true);
      break_truce(p, true);
      history_add(p, "Cut a Silmaril from Morgoth's crown.", HIST_SILMARIL);
    }
  } else {
    msg("Try though you might, you were unable to free a Silmaril.");
    msg("Perhaps you should try again or use a different weapon.");
    if (pd == 15) {
      msg("(The combat rolls window shows what is happening.)");
    }
    break_truce(p, false);
  }
  if ((pd == 30) && freed) {
    msg("Until you escape you must now roll twice for every skill check, "
        "taking the worse result each time.");
    msg("You hear a cry of veangance echo through the iron hells.");
    wake_all_monsters(p);
  }
}
STATIC_OVL int
silmarils_possessed(struct player* p)
{
  int silmarils = 0;
  struct object* obj;
  for (obj = p->gear; obj; obj = obj->next) {
    if (tval_is_light(obj) && of_has(obj->flags, OF_NO_FUEL) &&
        (obj->pval == 7)) {
      silmarils += obj->number;
    }
    if (obj->artifact && streq(obj->kind->name, "Massive Iron Crown")) {
      silmarils += obj->pval;
    }
  }
  return silmarils;
}
STATIC_OVL int
skill_cost(int base, int points)
{
  int total_cost = (points + base) * (points + base + 1) / 2;
  int prev_cost = (base) * (base + 1) / 2;
  return ((total_cost - prev_cost) * 100);
}
STATIC_OVL void
recalculate_skills(void)
{
  int i;
  for (i = 0; i < SKILL_MAX; i++) {
    player->skill_base[i] = skills[i];
  }
  player->new_exp = exp_left;
  player->upkeep->update |= (PU_BONUS);
  update_stuff(player);
  event_signal(EVENT_SKILLS);
  event_signal(EVENT_EXP_CHANGE);
}
STATIC_OVL void
init_skills(bool start, bool reset)
{
  int i;
  old_exp_left = exp_left = player->new_exp;
  for (i = 0; i < SKILL_MAX; i++) {
    old_skills[i] = start ? 0
                          : (reset ? player->skill_base[i]
                                   : skills[i] - player->skill_base[i]);
    skills[i] = start ? 0 : player->skill_base[i];
    exp_spent[i] =
        reset ? 0 : skill_cost(old_skills[i], skills[i] - old_skills[i]);
    exp_inc[i] = skill_cost(skills[i], 1);
  }
  if (!start || reset) {
    recalculate_skills();
    event_signal_skillpoints(exp_spent, exp_inc, exp_left);
  }
}
STATIC_OVL void
finalise_skills(void)
{
  int i;
  for (i = 0; i < SKILL_MAX; i++) {
    old_skills[i] = skills[i];
  }
  old_exp_left = exp_left;
}
STATIC_OVL void
reset_skills(void)
{
  int i;
  exp_left = old_exp_left;
  for (i = 0; i < SKILL_MAX; i++) {
    skills[i] = old_skills[i];
    exp_spent[i] = 0;
    exp_inc[i] = skill_cost(skills[i], 1);
  }
  recalculate_skills();
  event_signal_skillpoints(exp_spent, exp_inc, exp_left);
}
STATIC_OVL bool
buy_skill(int choice)
{
  if (!(choice >= SKILL_MAX || choice < 0)) {
    int cost = skill_cost(skills[choice], 1);
    assert(cost == exp_inc[choice]);
    if (cost <= exp_left) {
      skills[choice]++;
      exp_spent[choice] += cost;
      exp_inc[choice] = skill_cost(skills[choice], 1);
      exp_left -= cost;
      event_signal_skillpoints(exp_spent, exp_inc, exp_left);
      recalculate_skills();
      return true;
    }
  }
  return false;
}
STATIC_OVL bool
sell_skill(int choice)
{
  if (!(choice >= SKILL_MAX || choice < 0) && (exp_spent[choice] > 0)) {
    int cost = skill_cost(skills[choice] - 1, 1);
    skills[choice]--;
    exp_spent[choice] -= cost;
    exp_inc[choice] = skill_cost(skills[choice], 1);
    exp_left += cost;
    event_signal_skillpoints(exp_spent, exp_inc, exp_left);
    recalculate_skills();
    return true;
  }
  return false;
}
STATIC_OVL void
do_cmd_buy_skill(struct command* cmd)
{
  int choice;
  cmd_get_arg_choice(cmd, "choice", &choice);
  buy_skill(choice);
}
STATIC_OVL void
do_cmd_sell_skill(struct command* cmd)
{
  int choice;
  cmd_get_arg_choice(cmd, "choice", &choice);
  sell_skill(choice);
}
STATIC_OVL void
do_cmd_reset_skills(struct command* cmd)
{
  reset_skills();
}
STATIC_OVL void
do_cmd_refresh_skills(struct command* cmd)
{
  event_signal_skillpoints(exp_spent, exp_inc, exp_left);
}
STATIC_OVL int
timed_name_to_idx(const char* name)
{
  for (size_t i = 0; i < N_ELEMENTS(timed_effects); i++) {
    if (my_stricmp(name, timed_effects[i].name) == 0) {
      return i;
    }
  }
  return -1;
}
STATIC_OVL enum parser_error
parse_player_timed_name(struct parser* p)
{
  const char* name = parser_getstr(p, "name");
  int index;
  if (grab_name("timed effect", name, list_timed_effect_names,
                N_ELEMENTS(list_timed_effect_names), &index)) {
    return PARSE_ERROR_INVALID_SPELL_NAME;
  }
  struct timed_effect_data* t = &timed_effects[index];
  t->index = index;
  t->fail = -1;
  parser_setpriv(p, t);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_player_timed_desc(struct parser* p)
{
  struct timed_effect_data* t = parser_priv(p);
  if (!t) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  t->desc = string_append(t->desc, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_player_timed_end_message(struct parser* p)
{
  struct timed_effect_data* t = parser_priv(p);
  if (!t) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  t->on_end = string_append(t->on_end, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_player_timed_increase_message(struct parser* p)
{
  struct timed_effect_data* t = parser_priv(p);
  if (!t) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  t->on_increase = string_append(t->on_increase, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_player_timed_decrease_message(struct parser* p)
{
  struct timed_effect_data* t = parser_priv(p);
  if (!t) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  t->on_decrease = string_append(t->on_decrease, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_player_timed_change_increase(struct parser* p)
{
  struct timed_effect_data* t = parser_priv(p);
  struct timed_change* current;
  if (!t) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  current = t->increase;
  if (!current) {
    t->increase = mem_zalloc(sizeof(struct timed_change));
    current = t->increase;
  } else {
    while (current->next) {
      current = current->next;
    }
    current->next = mem_zalloc(sizeof(struct timed_change));
    current = current->next;
  }
  current->max = parser_getint(p, "max");
  current->msg = string_append(current->msg, parser_getsym(p, "msg"));
  if (parser_hasval(p, "inc_msg")) {
    current->inc_msg =
        string_append(current->inc_msg, parser_getsym(p, "inc_msg"));
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_player_timed_change_decrease(struct parser* p)
{
  struct timed_effect_data* t = parser_priv(p);
  if (!t) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  t->decrease.max = parser_getint(p, "max");
  string_free(t->decrease.msg);
  t->decrease.msg = string_make(parser_getsym(p, "msg"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_player_timed_message_type(struct parser* p)
{
  struct timed_effect_data* t = parser_priv(p);
  if (!t) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  t->msgt = message_lookup_by_name(parser_getsym(p, "type"));
  return t->msgt < 0 ? PARSE_ERROR_INVALID_MESSAGE : PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_player_timed_fail(struct parser* p)
{
  struct timed_effect_data* t = parser_priv(p);
  const char* name = parser_getstr(p, "flag");
  int flag = lookup_flag(obj_flags, name);
  if (!t) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  if (flag == FLAG_END) {
    return PARSE_ERROR_INVALID_FLAG;
  }
  t->fail = flag;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_player_timed_grade(struct parser* p)
{
  struct timed_effect_data* t = parser_priv(p);
  const char* color = parser_getsym(p, "color");
  struct timed_grade *current, *l;
  int attr = 0;
  if (!t) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  current = t->grade;
  if (!current) {
    t->grade = mem_zalloc(sizeof(struct timed_grade));
    current = t->grade;
  }
  while (current->next) {
    current = current->next;
  }
  l = mem_zalloc(sizeof(*l));
  current->next = l;
  l->grade = current->grade + 1;
  if (strlen(color) > 1) {
    attr = color_text_to_attr(color);
  } else {
    attr = color_char_to_attr(color[0]);
  }
  if (attr < 0) return PARSE_ERROR_INVALID_COLOR;
  l->color = attr;
  l->max = parser_getint(p, "max");
  l->name = string_make(parser_getsym(p, "name"));
  if (strlen(l->name) == 1) {
    string_free(l->name);
    l->name = NULL;
  }
  l->up_msg = string_make(parser_getsym(p, "up_msg"));
  if (strlen(l->up_msg) == 1) {
    string_free(l->up_msg);
    l->up_msg = NULL;
  }
  if (parser_hasval(p, "down_msg")) {
    l->down_msg = string_make(parser_getsym(p, "down_msg"));
  }
  if (streq(t->name, "FOOD")) {
    if (l->name) {
      if (streq(l->name, "Starving")) {
        PY_FOOD_STARVE = l->max;
      } else if (streq(l->name, "Weak")) {
        PY_FOOD_WEAK = l->max;
      } else if (streq(l->name, "Hungry")) {
        PY_FOOD_ALERT = l->max;
      } else if (streq(l->name, "Fed")) {
        PY_FOOD_FULL = l->max;
      } else if (streq(l->name, "Full")) {
        PY_FOOD_MAX = l->max;
      }
    }
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_player_timed_change_grade(struct parser* p)
{
  struct timed_effect_data* t = parser_priv(p);
  const char* color = parser_getsym(p, "color");
  int grade_max = parser_getint(p, "max");
  struct timed_change_grade *current, *l;
  int attr;
  if (!t) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  if (grade_max <= 0 || grade_max > 32767) {
    return PARSE_ERROR_INVALID_VALUE;
  }
  current = t->c_grade;
  if (!current) {
    t->c_grade = mem_zalloc(sizeof(struct timed_change_grade));
    current = t->c_grade;
  }
  while (current->next) {
    current = current->next;
  }
  l = mem_zalloc(sizeof(*l));
  current->next = l;
  l->c_grade = current->c_grade + 1;
  if (strlen(color) > 1) {
    attr = color_text_to_attr(color);
  } else {
    attr = color_char_to_attr(color[0]);
  }
  if (attr < 0) {
    return PARSE_ERROR_INVALID_COLOR;
  }
  l->color = attr;
  l->max = grade_max;
  l->digits = parser_getint(p, "digits");
  l->name = string_make(parser_getsym(p, "name"));
  if (strlen(l->name) == 1) {
    string_free(l->name);
    l->name = NULL;
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_player_timed_resist(struct parser* p)
{
  struct timed_effect_data* t = parser_priv(p);
  const char* name = parser_getsym(p, "elem");
  int idx = (name) ? proj_name_to_idx(name) : -1;
  if (!t) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  if (idx < 0 || idx >= ELEM_MAX) return PARSE_ERROR_INVALID_VALUE;
  t->temp_resist = idx;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_player_timed_este(struct parser* p)
{
  struct timed_effect_data* t = parser_priv(p);
  if (!t) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  t->este = parser_getuint(p, "value") ? true : false;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_player_timed_save(struct parser* p)
{
  struct timed_effect_data* t = parser_priv(p);
  if (!t) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  t->save = parser_getuint(p, "value") ? true : false;
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_parse_player_timed(void)
{
  struct parser* p = parser_new();
  parser_setpriv(p, NULL);
  parser_reg(p, "name str name", parse_player_timed_name);
  parser_reg(p, "desc str text", parse_player_timed_desc);
  parser_reg(p, "on-end str text", parse_player_timed_end_message);
  parser_reg(p, "on-increase str text", parse_player_timed_increase_message);
  parser_reg(p, "on-decrease str text", parse_player_timed_decrease_message);
  parser_reg(p, "change-inc int max sym msg ?sym inc_msg",
             parse_player_timed_change_increase);
  parser_reg(p, "change-dec int max sym msg",
             parse_player_timed_change_decrease);
  parser_reg(p, "msgt sym type", parse_player_timed_message_type);
  parser_reg(p, "fail str flag", parse_player_timed_fail);
  parser_reg(p, "grade sym color int max sym name sym up_msg ?sym down_msg",
             parse_player_timed_grade);
  parser_reg(p, "change-grade sym color int max int digits sym name",
             parse_player_timed_change_grade);
  parser_reg(p, "resist sym elem", parse_player_timed_resist);
  parser_reg(p, "este uint value", parse_player_timed_este);
  parser_reg(p, "save uint value", parse_player_timed_save);
  return p;
}
STATIC_OVL errr
run_parse_player_timed(struct parser* p)
{
  return parse_file_quit_not_found(p, "player_timed");
}
STATIC_OVL errr
finish_parse_player_timed(struct parser* p)
{
  parser_destroy(p);
  return 0;
}
STATIC_OVL void
cleanup_player_timed(void)
{
  for (size_t i = 0; i < TMD_MAX; i++) {
    struct timed_effect_data* effect = &timed_effects[i];
    struct timed_grade* grade = effect->grade;
    struct timed_change_grade* c_grade = effect->c_grade;
    struct timed_change* increase = effect->increase;
    while (grade) {
      struct timed_grade* next = grade->next;
      string_free(grade->name);
      if (grade->up_msg) string_free(grade->up_msg);
      if (grade->down_msg) string_free(grade->down_msg);
      mem_free(grade);
      grade = next;
    }
    effect->grade = NULL;
    while (c_grade) {
      struct timed_change_grade* next = c_grade->next;
      string_free(c_grade->name);
      mem_free(c_grade);
      c_grade = next;
    }
    effect->c_grade = NULL;
    while (increase) {
      struct timed_change* next = increase->next;
      string_free(increase->msg);
      if (increase->inc_msg) string_free(increase->inc_msg);
      mem_free(increase);
      increase = next;
    }
    effect->increase = NULL;
    string_free(effect->decrease.msg);
    effect->decrease.msg = NULL;
    string_free(effect->desc);
    if (effect->on_end) string_free(effect->on_end);
    if (effect->on_increase) string_free(effect->on_increase);
    if (effect->on_decrease) string_free(effect->on_decrease);
    effect->desc = NULL;
    effect->on_end = NULL;
    effect->on_increase = NULL;
    effect->on_decrease = NULL;
  }
}
STATIC_OVL int
player_timed_decrement_amount(struct player* p, int idx)
{
  struct song* este = lookup_song("Este");
  struct song* freedom = lookup_song("Freedom");
  int bonus_este = song_bonus(p, p->state.skill_use[SKILL_SONG], este);
  int bonus_freedom = song_bonus(p, p->state.skill_use[SKILL_SONG], freedom);
  int amount = 1;
  if (timed_effects[idx].este && player_is_singing(p, este)) {
    amount = bonus_este;
  }
  if ((idx == TMD_SLOW) && player_is_singing(p, freedom)) {
    amount = bonus_freedom;
  }
  if ((idx == TMD_CUT) || (idx == TMD_POISONED)) {
    amount *= ((p->timed[idx] + 4) / 5);
    p->upkeep->redraw |= (PR_STATUS);
  }
  return amount;
}
STATIC_OVL void
player_timed_end_effect(int idx)
{
  switch (idx) {
    case TMD_ENTRANCED: {
      player->upkeep->was_entranced = true;
      break;
    }
    case TMD_RAGE: {
      player->upkeep->redraw |= PR_MAP;
      break;
    }
    default:
      break;
  }
}
STATIC_OVL const char*
player_get_timed_grade(const struct player* p, int idx)
{
  const struct timed_grade* grade;
  if (!p->timed[idx]) {
    return NULL;
  }
  grade = timed_effects[idx].grade;
  while (p->timed[idx] > grade->max) {
    grade = grade->next;
  }
  return grade->name;
}
STATIC_OVL bool
player_timed_grade_eq(const struct player* p, int idx, const char* match)
{
  if (p->timed[idx]) {
    const struct timed_grade* grade = timed_effects[idx].grade;
    while (p->timed[idx] > grade->max) {
      grade = grade->next;
    }
    if (grade->name && streq(grade->name, match)) return true;
  }
  return false;
}
STATIC_OVL bool
player_timed_grade_gt(const struct player* p, int idx, const char* match)
{
  if (p->timed[idx]) {
    const struct timed_grade* grade = timed_effects[idx].grade;
    while (1) {
      if (!grade) {
        break;
      }
      if (grade->name && streq(grade->name, match)) {
        return p->timed[idx] > grade->max;
      }
      grade = grade->next;
    }
  }
  return false;
}
STATIC_OVL bool
player_timed_grade_lt(const struct player* p, int idx, const char* match)
{
  if (p->timed[idx]) {
    const struct timed_grade* grade = timed_effects[idx].grade;
    const struct timed_grade* prev_grade = NULL;
    while (1) {
      if (!grade) {
        return false;
      }
      if (grade->name && streq(grade->name, match)) {
        return prev_grade && p->timed[idx] <= prev_grade->max;
      }
      prev_grade = grade;
      grade = grade->next;
    }
  }
  return true;
}
STATIC_OVL bool
player_set_timed(struct player* p, int idx, int v, bool notify,
                 bool can_disturb)
{
  assert(idx >= 0);
  assert(idx < TMD_MAX);
  struct timed_effect_data* effect = &timed_effects[idx];
  struct timed_grade* new_grade = effect->grade;
  struct timed_grade* current_grade = effect->grade;
  struct object* weapon = equipped_item_by_slot_name(p, "weapon");
  struct timed_grade* blackout_grade =
      (idx == TMD_STUN) ? timed_effects[TMD_STUN].grade : NULL;
  v = MAX(v, (idx == TMD_FOOD) ? 1 : 0);
  if (p->timed[idx] == v) {
    return false;
  }
  if (blackout_grade) {
    while (!blackout_grade->name ||
           !streq(blackout_grade->name, "Heavy Stun")) {
      blackout_grade = blackout_grade->next;
      assert(blackout_grade);
    }
    if (p->timed[idx] > blackout_grade->max && v > p->timed[idx]) {
      return false;
    }
  }
  if (new_grade) {
    while (v > new_grade->max) {
      new_grade = new_grade->next;
      if (!new_grade->next) break;
    }
    while (p->timed[idx] > current_grade->max) {
      current_grade = current_grade->next;
      if (!current_grade->next) break;
    }
    if (v > new_grade->max) {
      if (p->timed[idx] == new_grade->max) {
        return false;
      }
      v = new_grade->max;
    }
    if (blackout_grade && v > blackout_grade->max) {
      p->timed[TMD_BLIND] = MAX(p->timed[TMD_BLIND], 2);
    }
    if (new_grade->grade > current_grade->grade) {
      if ((timed_effects[idx].temp_resist != -1) &&
          player_resists(p, timed_effects[idx].temp_resist)) {
        print_custom_message(weapon, effect->on_increase, effect->msgt, p);
      } else {
        print_custom_message(weapon, new_grade->up_msg, effect->msgt, p);
      }
      notify = true;
    } else if ((new_grade->grade < current_grade->grade) &&
               (new_grade->down_msg)) {
      print_custom_message(weapon, new_grade->down_msg, effect->msgt, p);
      if (blackout_grade && v < blackout_grade->max) {
        msg("You wake up.");
        p->timed[TMD_BLIND] = MAX(p->timed[TMD_BLIND] - 1, 0);
      }
      notify = true;
    } else if (notify) {
      if (v == 0) {
        print_custom_message(weapon, effect->on_end, MSG_RECOVER, p);
        player_timed_end_effect(idx);
      } else if (p->timed[idx] > v && effect->on_decrease) {
        print_custom_message(weapon, effect->on_decrease, effect->msgt, p);
      }
    }
  } else {
    const struct timed_change_grade* last_grade = effect->c_grade;
    int change;
    assert(last_grade);
    while (last_grade->next) last_grade = last_grade->next;
    if (v > last_grade->max) {
      if (p->timed[idx] == last_grade->max) {
        return false;
      }
      v = last_grade->max;
    }
    change = v - p->timed[idx];
    if (change > 0) {
      struct timed_change* inc = effect->increase;
      while (change >= inc->max && inc->next) {
        inc = inc->next;
      }
      if (p->timed[idx] && inc->inc_msg) {
        msgt(effect->msgt, inc->inc_msg);
        notify = true;
      } else {
        msgt(effect->msgt, inc->msg);
        notify = true;
      }
    } else {
      if (v == 0) {
        msgt(effect->msgt, effect->on_end);
        notify = true;
      } else {
        int div = effect->decrease.max;
        if (-change > (p->timed[idx] + div - 1) / div) {
          msgt(effect->msgt, effect->decrease.msg);
          notify = true;
        }
      }
    }
  }
  p->timed[idx] = v;
  if (notify) {
    if (can_disturb) {
      disturb(p, false);
    }
    p->upkeep->update |= effect->flag_update;
    p->upkeep->redraw |= (PR_STATUS | effect->flag_redraw);
    handle_stuff(p);
  }
  return notify;
}
STATIC_OVL bool
player_saving_throw(struct player* p, struct monster* mon, int resistance)
{
  int player_skill = p->state.skill_use[SKILL_WILL];
  int difficulty = mon ? monster_skill(mon, SKILL_WILL) : 10;
  difficulty -= 10 * resistance;
  if (mon) {
    return skill_check(source_monster(mon->midx), difficulty, player_skill,
                       source_player()) <= 0;
  }
  return skill_check(source_none(), difficulty, player_skill,
                     source_player()) <= 0;
}
STATIC_OVL bool
player_inc_check(struct player* p, int idx, bool lore)
{
  struct timed_effect_data* effect = &timed_effects[idx];
  struct monster* mon =
      cave->mon_current > 0 ? cave_monster(cave, cave->mon_current) : NULL;
  int resistance;
  if ((idx == TMD_AFRAID) && p->timed[TMD_RAGE]) return false;
  if (lore) {
    return (effect->fail != -1) ? (p->known_state.flags[effect->fail] == 0)
                                : true;
  }
  resistance = (effect->fail != -1) ? p->state.flags[effect->fail] : 0;
  if (resistance) {
    equip_learn_flag(p, effect->fail);
  }
  if (effect->save && player_saving_throw(p, mon, resistance)) {
    return false;
  }
  return true;
}
STATIC_OVL bool
player_inc_timed(struct player* p, int idx, int v, bool notify,
                 bool can_disturb, bool check)
{
  assert(idx >= 0);
  assert(idx < TMD_MAX);
  if (check == false || player_inc_check(p, idx, false) == true) {
    if (idx == TMD_ENTRANCED && p->timed[TMD_ENTRANCED] > 0) {
      return false;
    } else {
      return player_set_timed(p, idx, p->timed[idx] + v, notify, can_disturb);
    }
  }
  return false;
}
STATIC_OVL bool
player_dec_timed(struct player* p, int idx, int v, bool notify,
                 bool can_disturb)
{
  int new_value;
  assert(idx >= 0);
  assert(idx < TMD_MAX);
  new_value = p->timed[idx] - v;
  if (new_value > 0) {
    return player_set_timed(p, idx, new_value, notify, can_disturb);
  }
  return player_set_timed(p, idx, new_value, true, can_disturb);
}
STATIC_OVL bool
player_clear_timed(struct player* p, int idx, bool notify, bool can_disturb)
{
  assert(idx >= 0);
  assert(idx < TMD_MAX);
  return player_set_timed(p, idx, 0, notify, can_disturb);
}
STATIC_OVL bool
player_timed_inc_happened(struct player* p, int old[], int len)
{
  int idx;
  assert(len == TMD_MAX);
  for (idx = 0; idx < len; idx++) {
    if (player->timed[idx] > old[idx]) return true;
  }
  return false;
}
STATIC_OVL int
player_min_depth(struct player* p)
{
  int turns = 0;
  int depth = 0;
  while (turns < p->turn) {
    depth += 1;
    turns += 1000 + 50 * depth;
  }
  depth = MIN(MAX(depth, 1), z_info->dun_depth);
  if (p->depth == z_info->dun_depth) {
    depth = z_info->dun_depth;
  }
  if (p->on_the_run) {
    depth = 0;
  }
  return depth;
}
STATIC_OVL int
dungeon_get_next_level(struct player* p, int dlev, int added)
{
  int target_level;
  target_level = dlev + added;
  if (target_level > z_info->dun_depth) target_level = z_info->dun_depth;
  if (target_level < 0) target_level = 0;
  return target_level;
}
STATIC_OVL void
dungeon_change_level(struct player* p, int dlev)
{
  p->depth = dlev;
  p->upkeep->generate_level = true;
  p->upkeep->autosave = true;
}
STATIC_OVL int
int_exp(int base, int power)
{
  int i;
  int result = 1;
  for (i = 0; i < power; i++) {
    result *= base;
  }
  return result;
}
STATIC_OVL void
take_hit(struct player* p, int dam, const char* kb_str)
{
  int old_chp = p->chp;
  int warning = (p->mhp * p->opts.hitpoint_warn / 10);
  time_t ct = time((time_t*)0);
  char long_day[40];
  char buf[120];
  if (p->is_dead) return;
  if (dam <= 0) return;
  disturb(p, true);
  p->chp -= dam;
  p->upkeep->redraw |= (PR_HP);
  if (p->chp <= 0) {
    if (p->timed[TMD_IMAGE]) {
      strnfmt(p->died_from, sizeof(p->died_from), "%s (while halluciinating)",
              kb_str);
    } else {
      my_strcpy(p->died_from, kb_str, sizeof(p->died_from));
    }
    if ((p->wizard || OPT(p, cheat_live)) && !get_check("Die? ")) {
      event_signal(EVENT_CHEAT_DEATH);
    } else {
      msgt(MSG_DEATH, "You die.");
      event_signal(EVENT_MESSAGE_FLUSH);
      event_signal(EVENT_DEATH);
      p->is_dead = true;
      strnfmt(buf, sizeof(buf), "Slain by %s.", p->died_from);
      history_add(p, buf, HIST_PLAYER_DEATH);
      (void)strftime(long_day, 40, "%d %B %Y", localtime(&ct));
      strnfmt(buf, sizeof(buf), "Died on %s.", long_day);
      history_add(p, buf, HIST_PLAYER_DEATH);
      return;
    }
  }
  if (p->chp < warning) {
    if (old_chp > warning) bell();
    msgt(MSG_HITPOINT_WARN, "*** LOW HITPOINT WARNING! ***");
    event_signal(EVENT_MESSAGE_FLUSH);
  }
  player_set_timed(p, TMD_ENTRANCED, 0, false, true);
}
STATIC_OVL void
death_knowledge(struct player* p)
{
  struct object* obj;
  time_t death_time = (time_t)0;
  player_learn_all_runes(p);
  for (obj = p->gear; obj; obj = obj->next) {
    object_flavor_aware(p, obj);
  }
  history_unmask_unknown(p);
  (void)time(&death_time);
  enter_score(p, &death_time);
  p->upkeep->update |= (PU_BONUS);
  handle_stuff(p);
}
STATIC_OVL void
player_regen_hp(struct player* p)
{
  int old_chp = p->chp;
  int regen_multiplier = p->state.flags[OF_REGEN] + 1;
  int regen_period = z_info->player_regen_period;
  struct song* este = lookup_song("Este");
  if (p->timed[TMD_FOOD] < PY_FOOD_STARVE) return;
  if (p->timed[TMD_POISONED]) return;
  if (p->timed[TMD_CUT]) return;
  if (player_is_singing(p, este)) {
    regen_multiplier *= song_bonus(p, p->state.skill_use[SKILL_SONG], este);
  }
  if (regen_multiplier > 0) {
    regen_period /= regen_multiplier;
  } else {
    return;
  }
  p->chp += regen_amount(p->turn, p->mhp, regen_period);
  p->chp = MIN(p->chp, p->mhp);
  if (old_chp != p->chp) {
    equip_learn_flag(p, OF_REGEN);
    p->upkeep->redraw |= (PR_HP);
  }
}
STATIC_OVL void
player_regen_mana(struct player* p)
{
  int old_csp = p->csp;
  int regen_multiplier = p->state.flags[OF_REGEN] + 1;
  int regen_period = z_info->player_regen_period;
  if (p->song[SONG_MAIN]) return;
  if (regen_multiplier > 0) {
    regen_period /= regen_multiplier;
  } else {
    return;
  }
  p->csp += regen_amount(p->turn, p->msp, regen_period);
  p->csp = MIN(p->csp, p->msp);
  if (old_csp != p->csp) {
    equip_learn_flag(p, OF_REGEN);
    p->upkeep->redraw |= (PR_MANA);
  }
}
STATIC_OVL void
player_digest(struct player* p)
{
  int i = 1;
  if (p->state.hunger < 0) {
    if (!one_in_(int_exp(3, -(p->state.hunger)))) {
      i = 0;
    }
  } else if (p->state.hunger > 0) {
    i *= int_exp(3, p->state.hunger);
  }
  if (p->timed[TMD_FOOD] >= PY_FOOD_MAX) i *= 9;
  (void)player_dec_timed(p, TMD_FOOD, i, false, true);
  if (p->timed[TMD_FOOD] < PY_FOOD_STARVE) {
    take_hit(p, 1, "starvation");
  }
}
STATIC_OVL void
player_update_light(struct player* p)
{
  struct object* obj = equipped_item_by_slot_name(p, "light");
  if (obj && tval_is_light(obj)) {
    bool burn_fuel = true;
    if (of_has(obj->flags, OF_NO_FUEL)) burn_fuel = false;
    if (burn_fuel && obj->timeout > 0) {
      obj->timeout--;
      if ((obj->timeout < 100) || (!(obj->timeout % 100)))
        p->upkeep->redraw |= (PR_EQUIP);
      if (p->timed[TMD_BLIND]) {
        if (obj->timeout == 0) obj->timeout++;
      } else if (obj->timeout == 0) {
        disturb(p, false);
        msg("Your light has gone out!");
      } else if ((obj->timeout <= 100) && (!(obj->timeout % 20))) {
        if (obj->timeout == 100) {
          disturb(p, false);
        }
        msg("Your light is growing faint.");
      }
    }
  }
  p->upkeep->update |= (PU_TORCH);
}
STATIC_OVL bool
player_radiates(struct player* p)
{
  struct object* boots = equipped_item_by_slot_name(p, "feet");
  if (boots && of_has(boots->flags, OF_RADIANCE) &&
      !square_isglow(cave, p->grid)) {
    if (!of_has(boots->known->flags, OF_RADIANCE) && one_in_(10)) {
      char short_name[80];
      char full_name[80];
      object_desc(short_name, sizeof(short_name), boots, ODESC_BASE, p);
      player_learn_flag(p, OF_RADIANCE);
      object_desc(full_name, sizeof(full_name), boots, ODESC_FULL, p);
      msg("Your footsteps leave a trail of light!");
      msg("You recognize your %s to be %s", short_name, full_name);
    }
    return true;
  }
  return false;
}
STATIC_OVL void
player_fall_in_pit(struct player* p, bool spiked)
{
  int dam = damroll(2, 4);
  const char* prefix = square_apparent_look_prefix(cave, p->grid);
  char name[50];
  square_apparent_name(cave, p->grid, name, sizeof(name));
  msg("You fall into %s%s!", prefix, name);
  event_signal_combat_attack(EVENT_COMBAT_ATTACK, source_grid(p->grid),
                             source_player(), true, -1, -1, -1, -1, false);
  event_signal_combat_damage(EVENT_COMBAT_DAMAGE, 2, 4, dam, -1, -1, 0, 0,
                             PROJ_HURT, false);
  take_hit(p, dam, name);
  p->stealth_score -= 5;
  if (spiked) {
    int prt, net_dam;
    dam = damroll(4, 5);
    prt = protection_roll(p, PROJ_HURT, true, RANDOMISE);
    net_dam = (dam - prt > 0) ? (dam - prt) : 0;
    event_signal_combat_attack(EVENT_COMBAT_ATTACK, source_grid(p->grid),
                               source_player(), true, -1, -1, -1, -1, false);
    event_signal_combat_damage(EVENT_COMBAT_DAMAGE, 4, 5, dam, -1, -1, prt, 100,
                               PROJ_HURT, true);
    if (net_dam > 0) {
      msg("You are impaled!");
      take_hit(p, net_dam, name);
      (void)player_inc_timed(p, TMD_CUT, p->timed[TMD_CUT] + (net_dam + 1) / 2,
                             true, true, false);
    } else {
      msg("Your armour protects you.");
    }
    p->stealth_score -= 5;
  }
}
STATIC_OVL void
player_falling_damage(struct player* p, bool stun)
{
  int dice = 3, dam;
  const char* message;
  if (square_ischasm(cave, p->grid)) {
    if (p->depth != z_info->dun_depth - 2) {
      dice = 6;
    }
    message = "falling down a chasm";
  } else if (square_isstairs(cave, p->grid) || square_isshaft(cave, p->grid)) {
    message = "a collapsing stair";
  } else {
    message = "a collapsing floor";
  }
  dam = damroll(dice, 4);
  event_signal_combat_attack(EVENT_COMBAT_ATTACK, source_grid(p->grid),
                             source_player(), true, -1, -1, -1, -1, false);
  event_signal_combat_damage(EVENT_COMBAT_DAMAGE, dice, 4, dam, -1, -1, 0, 0,
                             PROJ_HURT, false);
  take_hit(p, dam, message);
  if (stun) {
    (void)player_inc_timed(p, TMD_STUN, dam * 5, true, true, true);
  }
  p->staircasiness = 0;
}
STATIC_OVL void
player_fall_in_chasm(struct player* p)
{
  if (in_tutorial()) {
    tutorial_leave_section(p);
    return;
  }
  msg("You fall into the darkness!");
  event_signal(EVENT_MESSAGE_FLUSH);
  msg("...and land somewhere deeper in the Iron Hells.");
  event_signal(EVENT_MESSAGE_FLUSH);
  history_add(p, "Fell into a chasm", HIST_FELL_IN_CHASM);
  player_falling_damage(p, false);
  dungeon_change_level(p, MIN(p->depth + 2, z_info->dun_depth - 1));
}
STATIC_OVL void
player_flanking_or_retreat(struct player* p, struct loc grid)
{
  int d, start;
  struct monster* mon = target_get_monster();
  bool flanking = player_active_ability(p, "Flanking");
  bool controlled_retreat = false;
  if (p->timed[TMD_CONFUSED] || p->timed[TMD_AFRAID] || p->truce) return;
  if (player_active_ability(p, "Controlled Retreat") &&
      ((p->previous_action[1] > 9) || (p->previous_action[1] == 5))) {
    controlled_retreat = true;
  }
  if (!(flanking || controlled_retreat)) return;
  if (mon) {
    if (monster_is_visible(mon) && (!OPT(p, forgo_attacking_unwary) ||
                                    (mon->alertness >= ALERTNESS_ALERT))) {
      if (flanking && (distance(p->grid, mon->grid) == 1) &&
          (distance(grid, mon->grid) == 1)) {
        py_attack(p, mon->grid, ATT_FLANKING);
        return;
      }
      if (controlled_retreat && (distance(p->grid, mon->grid) == 1) &&
          (distance(grid, mon->grid) > 1)) {
        py_attack(p, mon->grid, ATT_CONTROLLED_RETREAT);
        return;
      }
    }
  }
  start = randint0(8);
  for (d = start; d < 8 + start; d++) {
    struct loc check = loc_sum(p->grid, ddgrid_ddd[d % 8]);
    if (!square_in_bounds(cave, check)) continue;
    mon = square_monster(cave, check);
    if (mon) {
      if (monster_is_visible(mon) && (!OPT(p, forgo_attacking_unwary) ||
                                      (mon->alertness >= ALERTNESS_ALERT))) {
        if (flanking && (distance(p->grid, mon->grid) == 1) &&
            (distance(grid, mon->grid) == 1)) {
          py_attack(p, mon->grid, ATT_FLANKING);
          return;
        }
        if (controlled_retreat && (distance(p->grid, mon->grid) == 1) &&
            (distance(grid, mon->grid) > 1)) {
          py_attack(p, mon->grid, ATT_CONTROLLED_RETREAT);
          return;
        }
      }
    }
  }
}
STATIC_OVL void
player_opportunist_or_zone(struct player* p, struct loc grid1, struct loc grid2,
                           bool opp_only)
{
  bool opp = player_active_ability(p, "Opportunist");
  bool zone = player_active_ability(p, "Zone of Control") && !opp_only;
  char m_name[80];
  struct monster* mon = square_monster(cave, grid1);
  if ((opp || zone) && monster_is_visible(mon) && !mon->skip_next_turn &&
      !p->truce && !p->timed[TMD_CONFUSED] && !p->timed[TMD_AFRAID] &&
      !p->timed[TMD_ENTRANCED] && (p->timed[TMD_STUN] < 100) &&
      (distance(grid1, p->grid) == 1) &&
      (!OPT(p, forgo_attacking_unwary) ||
       (mon->alertness >= ALERTNESS_ALERT))) {
    monster_desc(m_name, sizeof(m_name), mon, MDESC_STANDARD);
    if (zone && (distance(grid2, p->grid) == 1)) {
      msg("%s moves through your zone of control.", m_name);
      py_attack_real(p, grid1, ATT_ZONE_OF_CONTROL);
    }
    if (opp && (distance(grid2, p->grid) > 1)) {
      msg("%s moves away from you.", m_name);
      py_attack_real(p, grid1, ATT_OPPORTUNIST);
    }
  }
}
STATIC_OVL void
player_polearm_passive_attack(struct player* p, struct loc grid_from,
                              struct loc grid_to)
{
  char m_name[80];
  struct monster* mon = square_monster(cave, grid_to);
  if (mon && monster_is_visible(mon)) {
    struct object* obj = equipped_item_by_slot_name(p, "weapon");
    if (!OPT(p, forgo_attacking_unwary) ||
        (mon->alertness >= ALERTNESS_ALERT)) {
      if ((distance(grid_from, p->grid) > 1) &&
          (distance(grid_to, p->grid) == 1) && !p->truce &&
          !p->timed[TMD_CONFUSED] && !p->timed[TMD_AFRAID] &&
          of_has(obj->flags, OF_POLEARM) && p->focused) {
        char o_name[80];
        object_desc(o_name, sizeof(o_name), obj, ODESC_BASE, p);
        monster_desc(m_name, sizeof(m_name), mon, MDESC_STANDARD);
        msg("%s comes into reach of your %s.", m_name, o_name);
        py_attack_real(p, grid_to, ATT_POLEARM);
      }
    }
  }
}
STATIC_OVL bool
player_can_leap(struct player* p, struct loc grid, int dir)
{
  int i, d;
  bool run_up = false;
  struct loc mid, end;
  if (p->timed[TMD_CONFUSED]) return false;
  if (!square_isleapable(cave, grid)) return false;
  if (!player_active_ability(p, "Leaping")) return false;
  for (i = -1; i <= 1; i++) {
    d = cycle[chome[dir_from_delta(grid.y - p->grid.y, grid.x - p->grid.x)] +
              i];
    if (p->previous_action[1] == d) run_up = true;
  }
  mid = loc_sum(p->grid, ddgrid[dir]);
  end = loc_sum(mid, ddgrid[dir]);
  disturb(p, false);
  event_signal(EVENT_MESSAGE_FLUSH);
  if (square_ispit(cave, p->grid)) {
    msg("You cannot leap from within a pit.");
    return false;
  } else if (square_iswebbed(cave, p->grid)) {
    msg("You cannot leap from within a web.");
    return false;
  } else if (!run_up) {
    msg("You cannot leap without a run up.");
    return false;
  } else if (square_isknown(cave, end) && !square_ispassable(cave, end)) {
    msg("You cannot leap over as there is no room to land.");
    return false;
  }
  return true;
}
STATIC_OVL bool
player_break_web(struct player* p)
{
  int difficulty = 7;
  int score = MAX(p->state.stat_use[STAT_STR] * 2, difficulty - 8);
  disturb(p, false);
  difficulty -= 10 * p->state.flags[OF_FREE_ACT];
  difficulty -= player_spider_bane_bonus(p);
  if (skill_check(source_player(), score, difficulty, source_none()) <= 0) {
    msg("You fail to break free of the web.");
    p->upkeep->energy_use = z_info->move_energy;
    p->previous_action[0] = ACTION_MISC;
    return false;
  } else {
    msg("You break free!");
    square_destroy_trap(cave, p->grid);
    return true;
  }
}
STATIC_OVL bool
player_escape_pit(struct player* p)
{
  disturb(p, false);
  if (check_hit(square_pit_difficulty(cave, p->grid), false,
                source_grid(p->grid))) {
    msg("You try to climb out of the pit, but fail.");
    p->upkeep->energy_use = z_info->move_energy;
    p->previous_action[0] = ACTION_MISC;
    return false;
  }
  msg("You climb out of the pit.");
  return true;
}
STATIC_OVL void
player_blast_ceiling(struct player* p)
{
  int will = p->state.skill_use[SKILL_WILL];
  if (player_active_ability(p, "Channeling")) {
    will += 5;
  }
  if (skill_check(source_player(), will, 10, source_none()) > 0) {
    int dam = damroll(4, 8);
    int prt = protection_roll(p, PROJ_HURT, false, RANDOMISE);
    int net_dam = MAX(0, dam - prt);
    msg("The ceiling cracks and rock rains down upon you!");
    effect_simple(EF_EARTHQUAKE, source_player(), "0", 0, 3, 0, NULL);
    event_signal_combat_attack(EVENT_COMBAT_ATTACK, source_player(),
                               source_player(), true, -1, -1, -1, -1, false);
    event_signal_combat_damage(EVENT_COMBAT_DAMAGE, 4, 8, dam, -1, -1, prt, 100,
                               PROJ_HURT, false);
    take_hit(p, net_dam, "a collapsing ceiling");
    (void)player_inc_timed(p, TMD_STUN, dam * 4, true, true, true);
  } else {
    msg("The blast hits the ceiling, but you did not blow hard enough to bring "
        "it down.");
  }
}
STATIC_OVL void
player_blast_floor(struct player* p)
{
  int will = p->state.skill_use[SKILL_WILL];
  if (player_active_ability(p, "Channeling")) {
    will += 5;
  }
  if (skill_check(source_player(), will, 10, source_none()) > 0) {
    if (p->depth < z_info->dun_depth - 1 && !in_tutorial()) {
      msg("The floor crumbles beneath you!");
      event_signal(EVENT_MESSAGE_FLUSH);
      msg("You fall through...");
      event_signal(EVENT_MESSAGE_FLUSH);
      msg("...and land somewhere deeper in the Iron Hells.");
      event_signal(EVENT_MESSAGE_FLUSH);
      history_add(p, "Fell through the floor with a horn blast.",
                  HIST_FELL_DOWN_LEVEL);
      player_falling_damage(p, true);
      event_signal(EVENT_MESSAGE_FLUSH);
      dungeon_change_level(p, p->depth + 1);
    } else {
      msg("Cracks spread across the floor, but it holds firm.");
    }
  } else {
    msg("The blast hits the floor, but you did not blow hard enough to "
        "collapse it.");
  }
}
STATIC_OVL int
lookup_skill(const char* name)
{
  int i;
  for (i = 0; i < SKILL_MAX; i++) {
    if (streq(skill_names[i], name)) {
      return i;
    }
  }
  msg("Could not find %s skill!", name);
  return -1;
}
STATIC_OVL bool
player_action_is_movement(struct player* p, int n)
{
  return ((p->previous_action[n] != ACTION_NOTHING) &&
          (p->previous_action[n] != ACTION_MISC) &&
          (p->previous_action[n] != ACTION_STAND));
}
STATIC_OVL int
player_dodging_bonus(struct player* p)
{
  if (player_active_ability(p, "Dodging") && player_action_is_movement(p, 0)) {
    return 3;
  } else {
    return 0;
  }
}
STATIC_OVL bool
player_can_riposte(struct player* p, int hit_result)
{
  struct object* weapon = equipped_item_by_slot_name(p, "weapon");
  return (weapon && player_active_ability(p, "Riposte") &&
          !p->upkeep->riposte && !p->timed[TMD_AFRAID] &&
          !p->timed[TMD_CONFUSED] && !p->timed[TMD_ENTRANCED] &&
          (p->timed[TMD_STUN] <= 100) &&
          (hit_result <= -10 - ((weapon->weight + 9) / 10)));
}
STATIC_OVL bool
player_is_sprinting(struct player* p)
{
  int i;
  int turns = 1;
  if (player_active_ability(p, "Sprinting")) {
    for (i = 1; i < 4; i++) {
      if (player_action_is_movement(p, i) &&
          player_action_is_movement(p, i + 1)) {
        if (p->previous_action[i] == p->previous_action[i + 1]) {
          turns++;
        } else if (p->previous_action[i] ==
                   cycle[chome[p->previous_action[i + 1]] - 1]) {
          turns++;
        } else if (p->previous_action[i] ==
                   cycle[chome[p->previous_action[i + 1]] + 1]) {
          turns++;
        }
      }
    }
  }
  return (turns >= 4);
}
STATIC_OVL int
player_bane_type_killed(int bane_type)
{
  int j, k;
  if (bane_type < 0 || bane_type >= (int)N_ELEMENTS(bane_flag)) {
    return 0;
  }
  for (j = 1, k = 0; j < z_info->r_max; j++) {
    struct monster_race* race = &r_info[j];
    struct monster_lore* lore = get_lore(race);
    if (rf_has(race->flags, bane_flag[bane_type])) {
      k += lore->pkills;
    }
  }
  return k;
}
STATIC_OVL int
calc_bane_bonus(struct player* p)
{
  int i = 2;
  int bonus = 0;
  int killed = player_bane_type_killed(p->bane_type);
  while (i <= killed) {
    i *= 2;
    bonus++;
  }
  return bonus;
}
STATIC_OVL int
player_bane_bonus(struct player* p, struct monster* mon)
{
  int bonus = 0;
  if (!mon) return 0;
  if (p->timed[TMD_ENTRANCED]) return 0;
  if (player_timed_grade_eq(p, TMD_STUN, "Knocked Out")) return 0;
  if (rf_has(mon->race->flags, bane_flag[p->bane_type])) {
    bonus = calc_bane_bonus(p);
  }
  return bonus;
}
STATIC_OVL int
player_spider_bane_bonus(struct player* p)
{
  return (bane_flag[p->bane_type] == RF_SPIDER) ? calc_bane_bonus(p) : 0;
}
STATIC_OVL bool
player_can_fire(struct player* p, bool show_msg)
{
  struct object* obj = equipped_item_by_slot_name(p, "shooting");
  if (!obj || !p->state.ammo_tval) {
    if (show_msg) msg("You have nothing to fire with.");
    return false;
  }
  return true;
}
STATIC_OVL bool
player_can_fire_quiver1(struct player* p, bool show_msg)
{
  const struct object* ammo;
  if (!player_can_fire(p, show_msg)) {
    return false;
  }
  ammo = equipped_item_by_slot_name(p, "first quiver");
  if (!ammo) {
    if (show_msg) {
      msg("You have nothing in the first quiver to fire.");
    }
    return false;
  }
  if (ammo->tval != p->state.ammo_tval) {
    if (show_msg) {
      msg("The ammunition in the first quiver is not compatible with your "
          "launcher.");
    }
    return false;
  }
  return true;
}
STATIC_OVL bool
player_can_fire_quiver2(struct player* p, bool show_msg)
{
  const struct object* ammo;
  if (!player_can_fire(p, show_msg)) {
    return false;
  }
  ammo = equipped_item_by_slot_name(p, "second quiver");
  if (!ammo) {
    if (show_msg) {
      msg("You have nothing in the second quiver to fire.");
    }
    return false;
  }
  if (ammo->tval != p->state.ammo_tval) {
    if (show_msg) {
      msg("The ammunition in the second quiver is not compatible with your "
          "launcher.");
    }
    return false;
  }
  return true;
}
STATIC_OVL bool
player_can_refuel(struct player* p, bool show_msg)
{
  struct object* obj = equipped_item_by_slot_name(p, "light");
  if (!obj && show_msg) {
    msg("You are not wielding a light");
  }
  if (of_has(obj->flags, OF_TAKES_FUEL) || of_has(obj->flags, OF_BURNS_OUT)) {
    return true;
  }
  if (show_msg) {
    msg("Your light cannot be refuelled.");
  }
  return false;
}
STATIC_OVL bool
player_can_fire_prereq(void)
{
  return player_can_fire(player, true);
}
STATIC_OVL bool
player_can_fire_quiver1_prereq(void)
{
  return player_can_fire_quiver1(player, true);
}
STATIC_OVL bool
player_can_fire_quiver2_prereq(void)
{
  return player_can_fire_quiver2(player, true);
}
STATIC_OVL bool
player_can_refuel_prereq(void)
{
  return player_can_refuel(player, true);
}
STATIC_OVL bool
player_can_debug_prereq(void)
{
  if (player->noscore & NOSCORE_DEBUG) {
    return true;
  }
  if (confirm_debug()) {
    player->noscore |= NOSCORE_DEBUG;
    return true;
  }
  return false;
}
STATIC_OVL bool
player_can_save_prereq(void)
{
  return !in_tutorial();
}
STATIC_OVL bool
player_confuse_dir(struct player* p, int* dp, bool too)
{
  int dir = *dp;
  if (p->timed[TMD_CONFUSED]) {
    if ((dir == 5) || (randint0(100) < 75)) {
      dir = ddd[randint0(8)];
    }
    if (too) {
      msg("You are too confused.");
      return true;
    }
    if (*dp != dir) {
      msg("You are confused.");
      *dp = dir;
      return true;
    }
  }
  return false;
}
STATIC_OVL bool
player_resting_is_special(int16_t count)
{
  switch (count) {
    case REST_COMPLETE:
    case REST_ALL_POINTS:
    case REST_SOME_POINTS:
      return true;
  }
  return false;
}
STATIC_OVL bool
player_is_resting(const struct player* p)
{
  return (p->upkeep->resting > 0 ||
          player_resting_is_special(p->upkeep->resting));
}
STATIC_OVL int16_t
player_resting_count(const struct player* p)
{
  return p->upkeep->resting;
}
STATIC_OVL void
player_resting_set_count(struct player* p, int16_t count)
{
  if (player_rest_disturb) {
    p->upkeep->resting = 0;
    player_rest_disturb = false;
    return;
  }
  if ((count < 0) && !player_resting_is_special(count)) {
    p->upkeep->resting = 0;
    return;
  }
  p->upkeep->resting = count;
  if (p->upkeep->resting > 9999) p->upkeep->resting = 9999;
}
STATIC_OVL void
player_resting_cancel(struct player* p, bool disturb)
{
  player_resting_set_count(p, 0);
  player_turns_rested = 0;
  player_rest_disturb = disturb;
}
STATIC_OVL bool
player_resting_can_regenerate(const struct player* p)
{
  return player_turns_rested >= REST_REQUIRED_FOR_REGEN ||
         player_resting_is_special(p->upkeep->resting);
}
STATIC_OVL void
player_resting_step_turn(struct player* p)
{
  if (p->upkeep->resting > 0) {
    p->upkeep->resting--;
    p->upkeep->redraw |= (PR_STATE);
  }
  p->upkeep->energy_use = z_info->move_energy;
  p->previous_action[0] = ACTION_STAND;
  p->focused = true;
  search(p);
  p->resting_turn++;
  player_turns_rested++;
}
STATIC_OVL void
player_resting_complete_special(struct player* p)
{
  if (!player_resting_is_special(p->upkeep->resting)) return;
  if (p->upkeep->resting == REST_ALL_POINTS) {
    if ((p->chp == p->mhp) && (p->csp == p->msp)) disturb(p, false);
  } else if (p->upkeep->resting == REST_COMPLETE) {
    if ((p->chp == p->mhp) &&
        (p->csp == p->msp || !player_is_singing(p, NULL)) &&
        !p->timed[TMD_BLIND] && !p->timed[TMD_CONFUSED] &&
        !p->timed[TMD_POISONED] && !p->timed[TMD_AFRAID] &&
        !p->timed[TMD_STUN] && !p->timed[TMD_CUT] && !p->timed[TMD_SLOW] &&
        !p->timed[TMD_ENTRANCED] && !p->timed[TMD_IMAGE])
      disturb(p, false);
  } else if (p->upkeep->resting == REST_SOME_POINTS) {
    if ((p->chp == p->mhp) || (p->csp == p->msp)) disturb(p, false);
  }
}
STATIC_OVL int
player_get_resting_repeat_count(struct player* p)
{
  return player_resting_repeat_count;
}
STATIC_OVL void
player_set_resting_repeat_count(struct player* p, int16_t count)
{
  player_resting_repeat_count = count;
}
STATIC_OVL bool
player_resists(const struct player* p, int element)
{
  return (p->state.el_info[element].res_level > 0);
}
STATIC_OVL void
player_place(struct chunk* c, struct player* p, struct loc grid)
{
  assert(!square_monster(c, grid));
  p->grid = grid;
  square_set_mon(c, grid, -1);
}
STATIC_OVL void
player_handle_post_move(struct player* p, bool eval_trap, bool is_involuntary)
{
  if (is_involuntary) {
    cmdq_flush();
  }
  square_know_pile(cave, p->grid);
  if (square_isstairs(cave, p->grid)) {
    square_memorize(cave, p->grid);
    square_light_spot(cave, p->grid);
  }
  if (square_isforge(cave, p->grid)) {
    struct feature* feat = square_feat(cave, p->grid);
    if ((feat->fidx == FEAT_FORGE_UNIQUE) && !p->unique_forge_seen) {
      msg("You enter the forge 'Orodruth' - the Mountain's Anger - where Grond "
          "was made in days of old.");
      msg("The fires burn still.");
      p->unique_forge_seen = true;
      history_add(p, "Entered the forge 'Orodruth'", HIST_FORGE_FOUND);
    } else {
      const char* article = square_apparent_look_prefix(cave, p->grid);
      char name[50];
      square_apparent_name(cave, p->grid, name, sizeof(name));
      msg("You enter %s%s.", article, name);
    }
    square_memorize(cave, p->grid);
    square_light_spot(cave, p->grid);
  }
  if (eval_trap && square_isplayertrap(cave, p->grid)) {
    disturb(p, false);
    square_reveal_trap(cave, p->grid, true);
    hit_trap(p->grid);
  } else if (square_ischasm(cave, p->grid)) {
    player_fall_in_chasm(p);
  }
  if (!p->upkeep->generate_level) {
    update_view(cave, p);
    cmdq_push(CMD_AUTOPICKUP);
    cmdq_peek()->is_background_command = true;
  }
}
STATIC_OVL void
disturb(struct player* p, bool stop_stealth)
{
  int repeats = cmd_get_nrepeats();
  cmd_cancel_repeat();
  if (player_is_resting(p)) {
    player_resting_cancel(p, true);
    p->upkeep->redraw |= PR_STATE;
  }
  if (p->upkeep->smithing) {
    p->upkeep->smithing = false;
    p->smithing_leftover = repeats;
    msg("Your work is interrupted!");
    p->upkeep->redraw |= (PR_STATE);
  }
  if (p->upkeep->running) {
    p->upkeep->running = 0;
    cmdq_flush();
    event_signal(EVENT_PLAYERMOVED);
    p->upkeep->update |= PU_TORCH;
    event_signal_point(EVENT_MAP, -1, -1);
  }
  if (stop_stealth && p->stealth_mode) {
    p->stealth_mode = STEALTH_MODE_STOPPING;
  }
  event_signal(EVENT_INPUT_FLUSH);
}
STATIC_OVL void
search_square(struct player* p, struct loc grid, int dist, int searching)
{
  int score = 0;
  int difficulty = 0;
  struct object* obj = chest_check(p, grid, CHEST_TRAPPED);
  int chest_level = obj && is_trapped_chest(obj) ? obj->pval : 0;
  if (searching) {
    if ((dist == 1) && !square_isknown(cave, grid)) {
      struct object* square_obj = square_object(cave, grid);
      if (!(square_isfloor(cave, grid) || square_issecrettrap(cave, grid))) {
        square_memorize(cave, grid);
      }
      if (square_obj) {
        square_know_pile(cave, grid);
      }
      square_light_spot(cave, grid);
    }
  }
  if (obj || square_issecrettrap(cave, grid) ||
      square_issecretdoor(cave, grid)) {
    if ((dist > 1) && !square_isseen(cave, grid)) return;
    score = p->state.skill_use[SKILL_PERCEPTION];
    if (searching) score += 5;
    if (player_active_ability(p, "Eye for Detail")) score += 5;
    if (obj) {
      difficulty = chest_level / 2;
    } else {
      if (p->depth > 0) {
        difficulty = p->depth / 2;
      } else {
        difficulty = 10;
      }
    }
    if (dist < 1) {
      dist = 1;
    }
    difficulty += 5 * (dist - 1);
    if (p->timed[TMD_BLIND] || no_light(p) || p->timed[TMD_IMAGE]) {
      difficulty += 5;
    }
    if (p->timed[TMD_CONFUSED]) {
      difficulty += 5;
    }
    if (square_issecrettrap(cave, grid)) {
      difficulty += 5;
    }
    if (square_issecretdoor(cave, grid)) {
      difficulty += 10;
    }
    if (obj) {
      difficulty += 15;
    }
    if (square_iswebbed(cave, grid)) {
      difficulty -= player_spider_bane_bonus(p);
    }
    if (skill_check(source_player(), score, difficulty, source_none()) > 0) {
      if (square_issecrettrap(cave, grid)) {
        square_reveal_trap(cave, grid, true);
        disturb(p, false);
      }
      if (square_issecretdoor(cave, grid)) {
        msg("You have found a secret door.");
        place_closed_door(cave, grid);
        disturb(p, false);
      }
      if (obj && obj->known && !obj->known->pval) {
        msg("You have discovered a trap on the chest!");
        obj->known->pval = obj->pval;
        disturb(p, false);
      }
    }
  }
}
STATIC_OVL void
search(struct player* p)
{
  struct loc grid;
  for (grid.y = (p->grid.y - 1); grid.y <= (p->grid.y + 1); grid.y++) {
    for (grid.x = (p->grid.x - 1); grid.x <= (p->grid.x + 1); grid.x++) {
      if (!loc_eq(grid, p->grid)) {
        search_square(p, grid, 1, true);
      }
    }
  }
  perceive(p);
}
STATIC_OVL void
perceive(struct player* p)
{
  struct loc grid;
  for (grid.y = (p->grid.y - 4); grid.y <= (p->grid.y + 4); grid.y++) {
    for (grid.x = (p->grid.x - 4); grid.x <= (p->grid.x + 4); grid.x++) {
      if (square_in_bounds(cave, grid)) {
        int dist = distance(p->grid, grid);
        if ((dist <= 1) || (p->upkeep->cur_light >= dist) ||
            square_isglow(cave, grid)) {
          if ((dist <= 4) && los(cave, p->grid, grid)) {
            search_square(p, grid, dist, false);
          }
        }
      }
    }
  }
}
STATIC_OVL struct player_race*
player_id2race(guid id)
{
  struct player_race* r;
  for (r = races; r; r = r->next)
    if (guid_eq(r->ridx, id)) break;
  return r;
}
STATIC_OVL struct player_house*
player_id2house(guid id)
{
  struct player_house* h;
  for (h = houses; h; h = h->next)
    if (guid_eq(h->hidx, id)) break;
  return h;
}
STATIC_OVL struct player_house*
player_house_from_count(int idx)
{
  unsigned int min = 100;
  struct player_house* h;
  const struct player_race* race = player->race;
  for (h = houses; h; h = h->next) {
    if ((h->race == race) && (h->hidx < min)) min = h->hidx;
  }
  for (h = houses; h; h = h->next) {
    if ((h->race == race) && (h->hidx == min + idx)) return h;
  }
  return NULL;
}
STATIC_OVL struct player_sex*
player_id2sex(guid id)
{
  struct player_sex* s;
  for (s = sexes; s; s = s->next)
    if (guid_eq(s->sidx, id)) break;
  return s;
}
STATIC_OVL int
stat_name_to_idx(const char* name)
{
  int i;
  for (i = 0; stat_name_list[i]; i++) {
    if (!my_stricmp(name, stat_name_list[i])) return i;
  }
  return -1;
}
STATIC_OVL const char*
stat_idx_to_name(int type)
{
  assert(type >= 0);
  assert(type < STAT_MAX);
  return stat_name_list[type];
}
STATIC_OVL bool
player_stat_inc(struct player* p, int stat)
{
  if (p->stat_base[stat] < BASE_STAT_MAX) {
    p->stat_base[stat]++;
    p->upkeep->update |= (PU_BONUS);
    p->upkeep->redraw |= (PR_STATS);
    return true;
  }
  return false;
}
STATIC_OVL bool
player_stat_res(struct player* p, int stat, int points)
{
  if (p->stat_drain[stat] < 0) {
    p->stat_drain[stat] += points;
    if (p->stat_drain[stat] > 0) p->stat_drain[stat] = 0;
    p->upkeep->update |= (PU_BONUS);
    p->upkeep->redraw |= (PR_STATS);
    return true;
  }
  return false;
}
STATIC_OVL void
player_stat_dec(struct player* p, int stat)
{
  p->stat_drain[stat]--;
  p->upkeep->update |= (PU_BONUS);
  p->upkeep->redraw |= (PR_STATS);
}
STATIC_OVL void
check_experience(struct player* p)
{
  p->exp = MIN(MAX(p->exp, 0), PY_MAX_EXP);
  p->new_exp = MIN(MAX(p->new_exp, 0), PY_MAX_EXP);
  p->new_exp = MIN(p->new_exp, p->exp);
  p->upkeep->redraw |= (PR_EXP);
  redraw_stuff(p);
}
STATIC_OVL void
player_exp_gain(struct player* p, int32_t amount)
{
  p->exp += amount;
  p->new_exp += amount;
  check_experience(p);
}
STATIC_OVL void
player_exp_lose(struct player* p, int32_t amount)
{
  if (amount > p->new_exp) amount = p->new_exp;
  p->exp -= amount;
  p->new_exp -= amount;
  check_experience(p);
}
STATIC_OVL void
player_flags(struct player* p, bitflag f[OF_SIZE])
{
  memcpy(f, p->race->pflags, sizeof(p->race->pflags));
}
STATIC_OVL void
player_flags_timed(struct player* p, bitflag f[OF_SIZE])
{
  if (p->timed[TMD_SINVIS]) {
    of_on(f, OF_SEE_INVIS);
  }
}
STATIC_OVL uint8_t
player_hp_attr(struct player* p)
{
  uint8_t attr;
  if (p->chp >= p->mhp)
    attr = COLOUR_L_GREEN;
  else if (p->chp > (p->mhp * p->opts.hitpoint_warn) / 10)
    attr = COLOUR_YELLOW;
  else
    attr = COLOUR_RED;
  return attr;
}
STATIC_OVL uint8_t
player_sp_attr(struct player* p)
{
  uint8_t attr;
  if (p->csp >= p->msp)
    attr = COLOUR_L_GREEN;
  else if (p->csp > (p->msp * p->opts.hitpoint_warn) / 10)
    attr = COLOUR_YELLOW;
  else
    attr = COLOUR_RED;
  return attr;
}
STATIC_OVL bool
player_restore_mana(struct player* p, int amt)
{
  int old_csp = p->csp;
  p->csp += amt;
  if (p->csp > p->msp) {
    p->csp = p->msp;
  }
  p->upkeep->redraw |= PR_MANA;
  msg("You feel some of your energies returning.");
  return p->csp != old_csp;
}
STATIC_OVL size_t
player_random_name(char* buf, size_t buflen)
{
  size_t result =
      randname_make(RANDNAME_TOLKIEN, 4, 8, buf, buflen, name_sections);
  my_strcap(buf);
  return result;
}
STATIC_OVL void
player_safe_name(char* safe, size_t safelen, const char* name,
                 bool strip_suffix)
{
  size_t i;
  size_t limit = 0;
  if (name) {
    char* suffix = find_roman_suffix_start(name);
    if (suffix) {
      limit = suffix - name - 1;
    } else {
      limit = strlen(name);
    }
  }
  limit = MIN(limit, safelen);
  for (i = 0; i < limit; i++) {
    char c = name[i];
    if (!isalpha((unsigned char)c) && !isdigit((unsigned char)c)) c = '_';
    safe[i] = c;
  }
  safe[i] = '\0';
  if (!safe[0]) my_strcpy(safe, "PLAYER", safelen);
}
STATIC_OVL void
player_cleanup_members(struct player* p)
{
  history_clear(p);
  mem_free(p->timed);
  if (p->upkeep) {
    mem_free(p->upkeep->inven);
    mem_free(p->upkeep);
    p->upkeep = NULL;
  }
  if (p->obj_k) {
    object_free(p->obj_k);
    p->obj_k = NULL;
  }
  mem_free(p->vaults);
  if (p->gear) {
    object_pile_free(NULL, NULL, p->gear);
    object_pile_free(NULL, NULL, p->gear_k);
  }
  if (p->body.slots) {
    for (int i = 0; i < p->body.count; i++) string_free(p->body.slots[i].name);
    mem_free(p->body.slots);
  }
  string_free(p->body.name);
  string_free(p->history);
  release_ability_list(p->abilities);
  release_ability_list(p->item_abilities);
  if (p->cave) {
    cave_free(p->cave);
    p->cave = NULL;
  }
}
STATIC_OVL void
init_player(void)
{
  player = mem_zalloc(sizeof *player);
  player->upkeep = mem_zalloc(sizeof(struct player_upkeep));
  player->upkeep->inven =
      mem_zalloc((z_info->pack_size + 1) * sizeof(struct object*));
  player->timed = mem_zalloc(TMD_MAX * sizeof(int16_t));
  player->obj_k = object_new();
  player->obj_k->brands = mem_zalloc(z_info->brand_max * sizeof(bool));
  player->obj_k->slays = mem_zalloc(z_info->slay_max * sizeof(bool));
  player->vaults = mem_zalloc(z_info->v_max * sizeof(int16_t));
  options_init_defaults(&player->opts);
}
STATIC_OVL void
cleanup_player(void)
{
  if (!player) return;
  player_cleanup_members(player);
  mem_free(player);
  player = NULL;
}
STATIC_OVL int
proj_name_to_idx(const char* name)
{
  int i;
  for (i = 0; proj_name_list[i]; i++) {
    if (!my_stricmp(name, proj_name_list[i])) return i;
  }
  return -1;
}
STATIC_OVL const char*
proj_idx_to_name(int type)
{
  assert(type >= 0);
  assert(type < PROJ_MAX);
  return proj_name_list[type];
}
STATIC_OVL int
projectable(struct chunk* c, struct loc grid1, struct loc grid2, int flg)
{
  struct loc grid_g[512];
  struct loc final, old_final = grid2;
  int grid_n = 0;
  int max_range = z_info->max_range;
  if (!(flg & (PROJECT_WALL | PROJECT_PASS))) {
    if (loc_eq(grid1, player->grid)) {
      if (!square_isfire(c, grid2)) return PROJECT_PATH_NO;
    } else if (loc_eq(grid2, player->grid)) {
      if (!square_isfire(c, grid1)) return PROJECT_PATH_NO;
    }
  }
  grid_n = project_path(c, grid_g, max_range, grid1, &grid2, flg);
  if (!grid_n) return PROJECT_PATH_NO;
  final = grid_g[ABS(grid_n) - 1];
  if (!loc_eq(final, old_final)) return PROJECT_PATH_NO;
  if (!square_ispassable(c, final)) return PROJECT_PATH_NO;
  if (!loc_eq(grid_g[ABS(grid_n) - 1], final)) return PROJECT_PATH_NO;
  if ((flg & (PROJECT_STOP)) || (flg & (PROJECT_CHCK))) {
    if (grid_n > 0) return PROJECT_PATH_CLEAR;
  }
  return PROJECT_PATH_NOT_CLEAR;
}
STATIC_OVL struct loc
origin_get_loc(struct source origin)
{
  switch (origin.what) {
    case SRC_MONSTER: {
      struct monster* who = cave_monster(cave, origin.which.monster);
      return who ? who->grid : loc(-1, -1);
    }
    case SRC_TRAP: {
      struct trap* trap = origin.which.trap;
      return trap->grid;
    }
    case SRC_GRID: {
      return origin.which.grid;
    }
    case SRC_PLAYER:
    case SRC_OBJECT:
    case SRC_CHEST_TRAP:
      return player->grid;
    case SRC_NONE:
      return loc(-1, -1);
  }
  return loc(-1, -1);
}
STATIC_OVL bool
project(struct source origin, int rad, struct loc finish, int dd, int ds,
        int dif, int typ, int flg, int degrees_of_arc, bool uniform,
        const struct object* obj)
{
  int i, j, k, dist_from_centre;
  uint32_t dam_temp;
  struct loc centre;
  struct loc start;
  int n1y = 0;
  int n1x = 0;
  bool notice = false;
  bool drawing = false;
  bool blind = (player->timed[TMD_BLIND] ? true : false);
  int num_path_grids = 0;
  struct loc path_grid[512];
  int num_grids = 0;
  struct loc blast_grid[256];
  int distance_to_grid[256];
  bool player_sees_grid[256];
  int* dam_at_dist = malloc((z_info->max_range + 1) * sizeof(*dam_at_dist));
  handle_stuff(player);
  if (flg & PROJECT_JUMP) {
    start = finish;
    flg &= ~(PROJECT_JUMP);
  } else {
    start = origin_get_loc(origin);
    if (start.y == -1 && start.x == -1) {
      start = finish;
    }
  }
  centre = start;
  if (!rad && (flg & (PROJECT_RANGE_DAM))) {
    if (uniform || !(flg & (PROJECT_ARC))) {
      rad = z_info->max_range;
    } else {
      rad = (dd + 1) / 2;
      if (rad < 0) {
        rad = 0;
      } else if (rad > z_info->max_range) {
        rad = z_info->max_range;
      }
    }
  }
  if ((flg & (PROJECT_ARC)) && (degrees_of_arc == 0) && (rad != 0)) {
    flg &= ~(PROJECT_ARC);
    flg |= (PROJECT_BEAM);
    flg |= (PROJECT_THRU);
  }
  if (loc_eq(start, finish)) {
    blast_grid[num_grids] = finish;
    centre = finish;
    distance_to_grid[num_grids] = 0;
    sqinfo_on(square(cave, finish)->info, SQUARE_PROJECT);
    num_grids++;
  } else {
    int y = start.y;
    int x = start.x;
    if (flg & (PROJECT_BOOM)) {
      dist_from_centre = z_info->max_range;
    } else if (rad <= 0) {
      dist_from_centre = z_info->max_range;
    } else {
      dist_from_centre = rad;
    }
    num_path_grids = ABS(
        project_path(cave, path_grid, dist_from_centre, start, &finish, flg));
    if (!(flg & (PROJECT_ARC))) {
      for (i = 0; i < num_path_grids; ++i) {
        int oy = y;
        int ox = x;
        int ny = path_grid[i].y;
        int nx = path_grid[i].x;
        if (!square_ispassable(cave, path_grid[i]) &&
            ((flg & (PROJECT_BOOM)) || (rad > 0)) && !(flg & (PROJECT_BEAM)))
          break;
        y = ny;
        x = nx;
        if (flg & (PROJECT_BEAM)) {
          blast_grid[num_grids].y = y;
          blast_grid[num_grids].x = x;
          distance_to_grid[num_grids] = 0;
          sqinfo_on(square(cave, loc(x, y))->info, SQUARE_PROJECT);
          num_grids++;
        } else if (i == num_path_grids - 1) {
          blast_grid[num_grids].y = y;
          blast_grid[num_grids].x = x;
          distance_to_grid[num_grids] = 0;
          sqinfo_on(square(cave, loc(x, y))->info, SQUARE_PROJECT);
          num_grids++;
        }
        if (!blind && !(flg & (PROJECT_HIDE))) {
          bool seen = square_isview(cave, loc(x, y));
          bool beam = flg & (PROJECT_BEAM);
          event_signal_bolt(EVENT_BOLT, typ, drawing, seen, beam, oy, ox, y, x);
        }
      }
    }
    centre.y = y;
    centre.x = x;
  }
  if (((rad > 0) || (flg & (PROJECT_BOOM))) && !(flg & (PROJECT_BEAM))) {
    int y, x;
    if ((flg & (PROJECT_ARC)) && (num_path_grids != 0)) {
      centre = start;
      if (rad > 20) rad = 20;
      if (num_path_grids < 21)
        i = num_path_grids - 1;
      else
        i = 20;
      n1y = path_grid[i].y - centre.y + 20;
      n1x = path_grid[i].x - centre.x + 20;
    }
    if (num_grids == 0) {
      blast_grid[num_grids] = centre;
      distance_to_grid[num_grids] = 0;
      sqinfo_on(square(cave, centre)->info, SQUARE_PROJECT);
      num_grids++;
    }
    for (y = centre.y - rad; y <= centre.y + rad; y++) {
      for (x = centre.x - rad; x <= centre.x + rad; x++) {
        struct loc grid = loc(x, y);
        bool on_path = false;
        if (loc_eq(grid, centre)) continue;
        if (num_grids >= 255) break;
        if (!square_in_bounds(cave, grid)) continue;
        if (!(flg & (PROJECT_PASS))) {
          if ((flg & (PROJECT_THRU)) || square_ispassable(cave, grid)) {
            if (!square_isprojectable(cave, grid)) {
              bool can_see_one = false;
              for (i = 0; i < 8; i++) {
                struct loc adj_grid = loc_sum(grid, ddgrid_ddd[i]);
                if (los(cave, centre, adj_grid)) {
                  can_see_one = true;
                  break;
                }
              }
              if (!can_see_one) continue;
            }
          } else if (!square_isprojectable(cave, grid))
            continue;
        }
        dist_from_centre = (distance(centre, grid));
        if (dist_from_centre > rad) continue;
        for (i = 0; i < num_path_grids; i++) {
          if (loc_eq(grid, path_grid[i])) {
            on_path = true;
          }
        }
        if (flg & (PROJECT_ARC)) {
          int n2y, n2x, tmp, rotate, diff;
          n2y = y - start.y + 20;
          n2x = x - start.x + 20;
          rotate = 90 - get_angle_to_grid[n1y][n1x];
          tmp = ABS(get_angle_to_grid[n2y][n2x] + rotate) % 180;
          diff = ABS(90 - tmp);
          if ((diff >= (degrees_of_arc + 6) / 4) && !on_path) continue;
        }
        if (flg & (PROJECT_PASS) || los(cave, centre, grid) || on_path) {
          blast_grid[num_grids].y = y;
          blast_grid[num_grids].x = x;
          distance_to_grid[num_grids] = dist_from_centre;
          sqinfo_on(square(cave, grid)->info, SQUARE_PROJECT);
          num_grids++;
        }
      }
    }
  }
  for (i = 0; i <= z_info->max_range; i++) {
    if (i > rad) {
      dam_temp = 0;
    } else if (uniform || !(flg & PROJECT_ARC)) {
      dam_temp = dd;
    } else {
      if (dd > 2 * (i - 1)) {
        dam_temp = dd - 2 * (i - 1);
      } else {
        dam_temp = 0;
      }
    }
    dam_at_dist[i] = dam_temp;
  }
  for (i = 0, k = 0; i <= rad; i++) {
    for (j = k; j < num_grids; j++) {
      if (distance_to_grid[j] == i) {
        struct loc tmp;
        int tmp_d = distance_to_grid[k];
        tmp = blast_grid[k];
        blast_grid[k] = blast_grid[j];
        distance_to_grid[k] = distance_to_grid[j];
        blast_grid[j] = tmp;
        distance_to_grid[j] = tmp_d;
        k++;
      }
    }
  }
  for (i = 0; i < num_grids; i++) {
    if (panel_contains(blast_grid[i].y, blast_grid[i].x) &&
        square_isview(cave, blast_grid[i]) && !blind &&
        !(flg & (PROJECT_HIDE))) {
      player_sees_grid[i] = true;
    } else {
      player_sees_grid[i] = false;
    }
  }
  event_signal_blast(EVENT_EXPLOSION, typ, num_grids, distance_to_grid, drawing,
                     player_sees_grid, blast_grid, centre);
  if (flg & (PROJECT_ITEM)) {
    for (i = 0; i < num_grids; i++) {
      if (project_o(blast_grid[i], typ, obj)) {
        notice = true;
      }
    }
  }
  if (flg & (PROJECT_KILL)) {
    bool was_obvious = false;
    bool did_hit = false;
    int num_hit = 0;
    struct loc last_hit_grid = loc(0, 0);
    for (i = 0; i < num_grids; i++) {
      struct monster* mon = NULL;
      j = (typ == PROJ_FORCE) ? num_grids - 1 - i : i;
      if (!square_isproject(cave, blast_grid[j])) continue;
      mon = square_monster(cave, blast_grid[j]);
      if (mon == NULL) continue;
      project_m(origin, distance_to_grid[j], blast_grid[j],
                dam_at_dist[distance_to_grid[j]], ds, dif, typ, flg, &did_hit,
                &was_obvious);
      if (was_obvious) {
        notice = true;
      }
      if (did_hit) {
        num_hit++;
        last_hit_grid = mon->grid;
      }
    }
    if (origin.what == SRC_PLAYER && num_hit == 1 && !(flg & PROJECT_JUMP)) {
      int x = last_hit_grid.x;
      int y = last_hit_grid.y;
      if (square(cave, loc(x, y))->mon > 0) {
        struct monster* mon = square_monster(cave, loc(x, y));
        if (monster_is_visible(mon)) {
          monster_race_track(player->upkeep, mon->race);
          health_track(player->upkeep, mon);
        }
      }
    }
  }
  if (flg & (PROJECT_PLAY)) {
    for (i = 0; i < num_grids; i++) {
      if (project_p(origin, blast_grid[i], dam_at_dist[distance_to_grid[i]], ds,
                    typ)) {
        notice = true;
        if (player->is_dead) {
          free(dam_at_dist);
          return notice;
        }
        break;
      }
    }
  }
  if (flg & (PROJECT_GRID)) {
    for (i = 0; i < num_grids; i++) {
      if (project_f(origin, blast_grid[i], dif, typ)) {
        notice = true;
      }
    }
  }
  for (i = 0; i < num_grids; i++) {
    sqinfo_off(square(cave, blast_grid[i])->info, SQUARE_PROJECT);
  }
  if (player->upkeep->update) update_stuff(player);
  free(dam_at_dist);
  return (notice);
}
STATIC_OVL void
project_feature_handler_FIRE(project_feature_handler_context_t* context)
{
}
STATIC_OVL void
project_feature_handler_COLD(project_feature_handler_context_t* context)
{
}
STATIC_OVL void
project_feature_handler_POIS(project_feature_handler_context_t* context)
{
}
STATIC_OVL void
project_feature_handler_DARK(project_feature_handler_context_t* context)
{
  const struct loc grid = context->grid;
  if ((player->depth != 0 || !is_daytime())) {
    sqinfo_off(square(cave, grid)->info, SQUARE_GLOW);
  }
  if (square_isview(cave, grid)) {
    context->obvious = true;
    player->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
  }
}
STATIC_OVL void
project_feature_handler_NOTHING(project_feature_handler_context_t* context)
{
}
STATIC_OVL void
project_feature_handler_HURT(project_feature_handler_context_t* context)
{
}
STATIC_OVL void
project_feature_handler_ARROW(project_feature_handler_context_t* context)
{
}
STATIC_OVL void
project_feature_handler_BOULDER(project_feature_handler_context_t* context)
{
}
STATIC_OVL void
project_feature_handler_ACID(project_feature_handler_context_t* context)
{
}
STATIC_OVL void
project_feature_handler_SOUND(project_feature_handler_context_t* context)
{
}
STATIC_OVL void
project_feature_handler_FORCE(project_feature_handler_context_t* context)
{
}
STATIC_OVL void
project_feature_handler_LIGHT(project_feature_handler_context_t* context)
{
  const struct loc grid = context->grid;
  sqinfo_on(square(cave, grid)->info, SQUARE_GLOW);
  if (square_isview(cave, grid)) {
    if (!player->timed[TMD_BLIND]) {
      context->obvious = true;
      player->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
    }
  }
}
STATIC_OVL void
project_feature_handler_KILL_WALL(project_feature_handler_context_t* context)
{
  const struct loc grid = context->grid;
  bool success;
  if (square_ispassable(cave, grid) && !square_seemslikewall(cave, grid))
    return;
  if (square_isperm(cave, grid)) return;
  success = skill_check(context->origin, context->dif, 10, source_none()) > 0;
  if (square_isrubble(cave, grid)) {
    if (success) {
      if (square_isseen(cave, grid)) {
        msg("The rubble is blown away!");
        context->obvious = true;
        square_forget(cave, grid);
        square_light_spot(cave, grid);
      }
      square_destroy_rubble(cave, grid);
    } else if (square_isseen(cave, grid)) {
      msg("You fail to blow hard enough to smash the rubble.");
    }
  } else if (square_iscloseddoor(cave, grid)) {
    if (success) {
      if (square_isseen(cave, grid)) {
        msg("The door is blown from its hinges!");
        context->obvious = true;
        square_forget(cave, grid);
        square_light_spot(cave, grid);
      }
      square_destroy_door(cave, grid);
    } else if (square_isseen(cave, grid)) {
      msg("You fail to blow hard enough to force the door open.");
    }
  } else if (square_isquartz(cave, grid)) {
    if (success) {
      if (square_isseen(cave, grid)) {
        msg("The vein shatters!");
        context->obvious = true;
        square_forget(cave, grid);
        square_light_spot(cave, grid);
      }
      square_set_feat(cave, grid, FEAT_RUBBLE);
    } else if (square_isseen(cave, grid)) {
      msg("You fail to blow hard enough to shatter the quartz.");
    }
  } else if (square_isgranite(cave, grid)) {
    if (success) {
      if (square_isseen(cave, grid)) {
        msg("The wall shatters!");
        context->obvious = true;
        square_forget(cave, grid);
        square_light_spot(cave, grid);
      }
      square_set_feat(cave, grid, FEAT_RUBBLE);
    } else if (square_isseen(cave, grid)) {
      msg("You fail to blow hard enough to shatter the wall.");
    }
  }
  player->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
}
STATIC_OVL void
project_feature_handler_SLEEP(project_feature_handler_context_t* context)
{
}
STATIC_OVL void
project_feature_handler_SPEED(project_feature_handler_context_t* context)
{
}
STATIC_OVL void
project_feature_handler_SLOW(project_feature_handler_context_t* context)
{
}
STATIC_OVL void
project_feature_handler_CONFUSION(project_feature_handler_context_t* context)
{
}
STATIC_OVL void
project_feature_handler_FEAR(project_feature_handler_context_t* context)
{
}
STATIC_OVL void
project_feature_handler_EARTHQUAKE(project_feature_handler_context_t* context)
{
}
STATIC_OVL void
project_feature_handler_DARK_WEAK(project_feature_handler_context_t* context)
{
  project_feature_handler_DARK(context);
}
STATIC_OVL void
project_feature_handler_KILL_DOOR(project_feature_handler_context_t* context)
{
  const struct loc grid = context->grid;
  int result = skill_check(context->origin, context->dif, 0, source_none());
  if (square_isdoor(cave, grid)) {
    if (result <= 0) {
    } else if (result <= 5) {
      if (square_islockeddoor(cave, grid)) {
        square_unlock_door(cave, grid);
        msg("You hear a 'click'.");
      }
    } else if (result <= 10) {
      if (!square_isopendoor(cave, grid) && !square_isbrokendoor(cave, grid)) {
        square_open_door(cave, grid);
        context->obvious = true;
        if (square_isseen(cave, grid)) {
          msg("The door flies open.");
        } else {
          msg("You hear a door burst open.");
        }
      }
    } else if (!square_isbrokendoor(cave, grid)) {
      square_smash_door(cave, grid);
      context->obvious = true;
      if (square_isseen(cave, grid)) {
        msg("The door is ripped from its hinges.");
      } else {
        msg("You hear a door burst open.");
      }
    }
  } else if (square_isrubble(cave, grid)) {
    if (result <= 0) {
    } else {
      square_destroy_rubble(cave, grid);
      context->obvious = true;
      if (square_isseen(cave, grid)) {
        msg("The rubble is scattered across the floor.");
      } else {
        msg("You hear a loud rumbling.");
      }
    }
  }
}
STATIC_OVL void
project_feature_handler_LOCK_DOOR(project_feature_handler_context_t* context)
{
  const struct loc grid = context->grid;
  int power = skill_check(context->origin, context->dif, 0, source_none());
  if (square_monster(cave, grid) || square_isplayer(cave, grid)) return;
  if (square_isbrokendoor(cave, grid)) power -= 10;
  if (power <= 0) return;
  if (!square_isdoor(cave, grid) || square_issecretdoor(cave, grid)) return;
  if (square_isopendoor(cave, grid) || square_isbrokendoor(cave, grid)) {
    square_close_door(cave, grid);
    context->obvious = true;
    if (square_isseen(cave, grid)) {
      msg("The door slams shut.");
    } else {
      msg("You hear a door slam shut.");
    }
  } else {
    if ((square_door_lock_power(cave, grid) < 7) && (power > 1)) {
      int lock_level = square_door_lock_power(cave, grid) + power / 2;
      square_set_door_lock(cave, grid, MIN(lock_level, 7));
      msg("You hear a 'click'.");
      context->obvious = true;
    }
  }
  player->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
}
STATIC_OVL void
project_feature_handler_KILL_TRAP(project_feature_handler_context_t* context)
{
  const struct loc grid = context->grid;
  if (square_isplayertrap(cave, grid)) {
    if (square_isview(cave, grid) && square_isvisibletrap(cave, grid)) {
      context->obvious = true;
    }
    square_destroy_trap(cave, grid);
  }
}
STATIC_OVL void
project_feature_handler_DISP_ALL(project_feature_handler_context_t* context)
{
}
STATIC_OVL bool
project_f(struct source origin, struct loc grid, int dif, int typ)
{
  bool obvious = false;
  project_feature_handler_context_t context = {
      origin, grid, dif, typ, obvious,
  };
  project_feature_handler_f feature_handler = feature_handlers[typ];
  if (feature_handler != NULL) feature_handler(&context);
  return context.obvious;
}
static void
project_monster_resist_element(project_monster_handler_context_t* context,
                               int flag)
{
  if (context->seen) rf_on(context->lore->flags, flag);
  if (rf_has(context->mon->race->flags, flag)) {
    context->hurt_msg = MON_MSG_RESIST_A_LOT;
    context->dam = 0;
  }
}
STATIC_OVL void
project_monster_hurt_immune(project_monster_handler_context_t* context,
                            int hurt_flag, int imm_flag, int hurt_factor,
                            enum mon_messages hurt_msg,
                            enum mon_messages die_msg)
{
  if (context->seen) {
    rf_on(context->lore->flags, imm_flag);
    rf_on(context->lore->flags, hurt_flag);
  }
  if (rf_has(context->mon->race->flags, imm_flag)) {
    context->hurt_msg = MON_MSG_RESIST_A_LOT;
    context->dam = 0;
  } else if (rf_has(context->mon->race->flags, hurt_flag)) {
    context->hurt_msg = hurt_msg;
    context->die_msg = die_msg;
    context->dam *= hurt_factor;
  }
}
STATIC_OVL void
project_monster_hurt_only(project_monster_handler_context_t* context, int flag,
                          enum mon_messages hurt_msg, enum mon_messages die_msg)
{
  if (context->seen) rf_on(context->lore->flags, flag);
  if (rf_has(context->mon->race->flags, flag)) {
    int resist = monster_stat(context->mon, STAT_CON) * 2;
    if (skill_check(source_player(), context->dif, resist,
                    source_monster(context->mon->midx)) > 0) {
      context->hurt_msg = hurt_msg;
      context->die_msg = die_msg;
    } else {
      context->hurt_msg = MON_MSG_RESIST_A_LOT;
      context->dam = 0;
    }
  } else {
    context->dam = 0;
  }
}
STATIC_OVL void
project_monster_breath(project_monster_handler_context_t* context, int flag)
{
  if (rsf_has(context->mon->race->spell_flags, flag)) {
    context->hurt_msg = MON_MSG_RESIST;
    context->dam = 0;
  }
}
STATIC_OVL int
project_monster_skill_check(project_monster_handler_context_t* context,
                            int flag)
{
  int resistance = monster_skill(context->mon, SKILL_WILL);
  int dif = context->dif - context->r;
  if (rf_has(context->mon->race->flags, flag)) resistance += 100;
  return skill_check(context->origin, dif, resistance,
                     source_monster(context->mon->midx));
}
STATIC_OVL void
project_monster_handler_FIRE(project_monster_handler_context_t* context)
{
  project_monster_hurt_immune(context, RF_HURT_FIRE, RF_RES_FIRE, 2,
                              MON_MSG_CATCH_FIRE, MON_MSG_DISINTEGRATES);
}
STATIC_OVL void
project_monster_handler_COLD(project_monster_handler_context_t* context)
{
  project_monster_hurt_immune(context, RF_HURT_COLD, RF_RES_COLD, 2,
                              MON_MSG_BADLY_FROZEN, MON_MSG_FREEZE_SHATTER);
}
STATIC_OVL void
project_monster_handler_POIS(project_monster_handler_context_t* context)
{
  project_monster_resist_element(context, RF_RES_POIS);
}
STATIC_OVL void
project_monster_handler_DARK(project_monster_handler_context_t* context)
{
  project_monster_breath(context, RSF_BR_DARK);
  if (rf_has(context->mon->race->flags, RF_UNDEAD) ||
      context->mon->race->light < 0) {
    context->dam = 0;
    context->hurt_msg = MON_MSG_RESIST_A_LOT;
  }
}
STATIC_OVL void
project_monster_handler_NOTHING(project_monster_handler_context_t* context)
{
}
STATIC_OVL void
project_monster_handler_HURT(project_monster_handler_context_t* context)
{
}
STATIC_OVL void
project_monster_handler_ARROW(project_monster_handler_context_t* context)
{
}
STATIC_OVL void
project_monster_handler_BOULDER(project_monster_handler_context_t* context)
{
}
STATIC_OVL void
project_monster_handler_ACID(project_monster_handler_context_t* context)
{
}
STATIC_OVL void
project_monster_handler_SOUND(project_monster_handler_context_t* context)
{
  context->mon_timed[MON_TMD_STUN] = context->dam;
  context->dam = 0;
}
STATIC_OVL void
project_monster_handler_FORCE(project_monster_handler_context_t* context)
{
  int resist = monster_stat(context->mon, STAT_CON) * 2;
  if (skill_check(source_player(), context->dif, resist,
                  source_monster(context->mon->midx)) > 0) {
    if (monster_is_visible(context->mon)) {
      context->hurt_msg = MON_MSG_PUSHED;
      context->obvious = true;
    }
    knock_back(player->grid, context->mon->grid);
  } else {
    if (monster_is_visible(context->mon)) {
      context->hurt_msg = MON_MSG_NOT_PUSHED;
      context->obvious = true;
    }
  }
}
STATIC_OVL void
project_monster_handler_LIGHT(project_monster_handler_context_t* context)
{
  if (context->seen) rf_on(context->lore->flags, RF_HURT_LIGHT);
  if (rf_has(context->mon->race->flags, RF_HURT_LIGHT)) {
    context->mon_timed[MON_TMD_STUN] = context->dam;
    context->hurt_msg = MON_MSG_CRINGE_LIGHT;
  }
  context->alert = false;
  context->dam = 0;
}
STATIC_OVL void
project_monster_handler_KILL_WALL(project_monster_handler_context_t* context)
{
  project_monster_hurt_only(context, RF_STONE, MON_MSG_LOSE_SKIN,
                            MON_MSG_DISSOLVE);
}
STATIC_OVL void
project_monster_handler_SLEEP(project_monster_handler_context_t* context)
{
  int result = project_monster_skill_check(context, RF_NO_SLEEP);
  if (result > 0) {
    if (context->seen) context->obvious = true;
    set_alertness(context->mon, context->mon->alertness - (result + 5));
  } else {
    context->hurt_msg = MON_MSG_UNAFFECTED;
    context->obvious = false;
    if (context->seen && rf_has(context->mon->race->flags, RF_NO_SLEEP)) {
      rf_on(context->lore->flags, RF_NO_SLEEP);
    }
  }
  context->alert = false;
  context->dam = 0;
}
STATIC_OVL void
project_monster_handler_SPEED(project_monster_handler_context_t* context)
{
  if (context->seen) context->obvious = true;
  context->mon_timed[MON_TMD_FAST] = context->dam;
  if (context->mon->alertness < ALERTNESS_UNWARY) context->alert = false;
  context->dam = 0;
}
STATIC_OVL void
project_monster_handler_SLOW(project_monster_handler_context_t* context)
{
  int result = project_monster_skill_check(context, RF_NO_SLOW);
  if (result > 0) {
    if (context->seen) context->obvious = true;
    context->mon_timed[MON_TMD_SLOW] = result + 10;
  } else {
    context->alert = false;
    context->hurt_msg = MON_MSG_UNAFFECTED;
    context->obvious = false;
    if (context->seen && rf_has(context->mon->race->flags, RF_NO_SLOW)) {
      rf_on(context->lore->flags, RF_NO_SLOW);
    }
  }
  if (context->mon->alertness < ALERTNESS_UNWARY) context->alert = false;
  context->dam = 0;
}
STATIC_OVL void
project_monster_handler_CONFUSION(project_monster_handler_context_t* context)
{
  int result = project_monster_skill_check(context, RF_NO_CONF);
  if (result > 0) {
    if (context->seen) context->obvious = true;
    context->mon_timed[MON_TMD_CONF] = result + 10;
  } else {
    context->hurt_msg = MON_MSG_UNAFFECTED;
    context->obvious = false;
    if (context->seen && rf_has(context->mon->race->flags, RF_NO_CONF)) {
      rf_on(context->lore->flags, RF_NO_CONF);
    }
  }
  context->alert = false;
  context->dam = 0;
}
STATIC_OVL void
project_monster_handler_FEAR(project_monster_handler_context_t* context)
{
  int result;
  context->dif += 5;
  result = project_monster_skill_check(context, RF_NO_FEAR);
  if (result > 0) {
    if (context->seen) context->obvious = true;
    context->mon->tmp_morale -= result * 20;
  } else {
    context->alert = false;
    context->hurt_msg = MON_MSG_UNAFFECTED;
    context->obvious = false;
    if (context->seen && rf_has(context->mon->race->flags, RF_NO_FEAR)) {
      rf_on(context->lore->flags, RF_NO_FEAR);
    }
  }
  context->dam = 0;
}
STATIC_OVL void
project_monster_handler_EARTHQUAKE(project_monster_handler_context_t* context)
{
  context->skipped = true;
  context->dam = 0;
}
STATIC_OVL void
project_monster_handler_DARK_WEAK(project_monster_handler_context_t* context)
{
  context->skipped = true;
  context->dam = 0;
}
STATIC_OVL void
project_monster_handler_KILL_DOOR(project_monster_handler_context_t* context)
{
  context->skipped = true;
  context->dam = 0;
}
STATIC_OVL void
project_monster_handler_LOCK_DOOR(project_monster_handler_context_t* context)
{
  context->skipped = true;
  context->dam = 0;
}
STATIC_OVL void
project_monster_handler_KILL_TRAP(project_monster_handler_context_t* context)
{
  context->skipped = true;
  context->dam = 0;
}
STATIC_OVL void
project_monster_handler_DISP_ALL(project_monster_handler_context_t* context)
{
  context->hurt_msg = MON_MSG_SHUDDER;
  context->die_msg = MON_MSG_DISSOLVE;
  context->dam = context->dif;
}
STATIC_OVL bool
project_m_monster_attack(project_monster_handler_context_t* context, int m_idx)
{
  bool mon_died = false;
  bool seen = context->seen;
  int dam = context->dam;
  enum mon_messages die_msg = context->die_msg;
  enum mon_messages hurt_msg = context->hurt_msg;
  struct monster* mon = context->mon;
  if (player->upkeep->health_who == mon) player->upkeep->redraw |= (PR_HEALTH);
  mflag_on(mon->mflag, MFLAG_ACTIVE);
  mon->hp -= dam;
  if (mon->hp <= 0) {
    if (!seen) die_msg = MON_MSG_MORIA_DEATH;
    add_monster_message(mon, die_msg, false);
    monster_death(mon, player, false, NULL, false);
    mon_died = true;
  } else {
    make_alert(mon, 0);
    if (seen) {
      if (hurt_msg != MON_MSG_NONE) {
        add_monster_message(mon, hurt_msg, false);
      }
    } else if (dam > 0) {
      message_pain(mon, dam);
    }
  }
  return mon_died;
}
STATIC_OVL bool
project_m_player_attack(project_monster_handler_context_t* context)
{
  bool mon_died = false;
  bool seen = context->seen;
  int dam = context->dam;
  enum mon_messages die_msg = context->die_msg;
  enum mon_messages hurt_msg = context->hurt_msg;
  struct monster* mon = context->mon;
  if (dam > mon->hp) {
    if (!seen) die_msg = MON_MSG_MORIA_DEATH;
    add_monster_message(mon, die_msg, false);
  }
  if (dam) {
    mon_died = mon_take_hit(mon, player, dam, "");
  }
  if (!mon_died) {
    if (seen) {
      if (hurt_msg != MON_MSG_NONE) {
        add_monster_message(mon, hurt_msg, false);
      }
    } else if (dam > 0) {
      message_pain(mon, dam);
    }
  }
  return mon_died;
}
STATIC_OVL void
project_m_apply_side_effects(project_monster_handler_context_t* context,
                             int m_idx)
{
  struct monster* mon = context->mon;
  for (int i = 0; i < MON_TMD_MAX; i++) {
    if (context->mon_timed[i] > 0) {
      mon_inc_timed(mon, i, context->mon_timed[i],
                    context->flag | MON_TMD_FLG_NOTIFY);
      context->obvious = context->seen;
    }
  }
}
STATIC_OVL void
project_m(struct source origin, int r, struct loc grid, int dam, int ds,
          int dif, int typ, int flg, bool* did_hit, bool* was_obvious)
{
  struct monster* mon;
  struct monster_lore* lore;
  bool seen = false;
  bool mon_died = false;
  bool obvious = false;
  bool id = (origin.what == SRC_PLAYER) ? !obvious : false;
  int m_idx = square(cave, grid)->mon;
  project_monster_handler_f monster_handler = monster_handlers[typ];
  project_monster_handler_context_t context = {
      origin, r,  grid,         dam,         dif,          typ,
      seen,   id, NULL,         NULL,        obvious,      false,
      true,   0,  MON_MSG_NONE, MON_MSG_DIE, {0, 0, 0, 0},
  };
  *did_hit = false;
  *was_obvious = false;
  if (!square_ispassable(cave, grid)) return;
  if (!(m_idx > 0)) return;
  if (origin.what == SRC_MONSTER && origin.which.monster == m_idx) return;
  mon = cave_monster(cave, m_idx);
  lore = get_lore(mon->race);
  context.mon = mon;
  context.lore = lore;
  if (monster_is_visible(mon)) {
    seen = true;
    context.seen = seen;
  }
  if (monster_is_nonliving(mon)) context.die_msg = MON_MSG_DESTROYED;
  if (projections[typ].obvious && context.seen) context.obvious = true;
  mflag_on(mon->mflag, MFLAG_ACTIVE);
  if (origin.what == SRC_PLAYER) mflag_on(mon->mflag, MFLAG_HIT_BY_RANGED);
  if (monster_handler != NULL) monster_handler(&context);
  if (projections[typ].wake) make_alert(mon, 0);
  if (context.skipped) return;
  if (origin.what == SRC_MONSTER) {
    mon_died = project_m_monster_attack(&context, m_idx);
  } else {
    mon_died = project_m_player_attack(&context);
  }
  if (!mon_died) project_m_apply_side_effects(&context, m_idx);
  mon = context.mon;
  obvious = context.obvious;
  if (mon != NULL) {
    if (!mon_died) update_mon(mon, cave, false);
    square_light_spot(cave, mon->grid);
    if (player->upkeep->monster_race == mon->race) {
      player->upkeep->redraw |= (PR_MONSTER);
    }
  }
  *did_hit = true;
  *was_obvious = !!obvious;
}
STATIC_OVL int
inven_damage(struct player* p, int type, int perc, int resistance)
{
  int k = 0;
  struct object* obj = p->gear;
  if (perc <= 0) return 0;
  while (obj) {
    struct object* next = obj->next;
    if (object_is_equipped(p->body, obj)) {
      obj = next;
      continue;
    }
    if (obj->artifact) {
      obj = next;
      continue;
    }
    if ((obj->el_info[type].flags & EL_INFO_HATES) &&
        !(obj->el_info[type].flags & EL_INFO_IGNORE)) {
      int j, amt;
      for (amt = j = 0; j < obj->number; ++j) {
        if (percent_chance(perc) && ((resistance < 0) || one_in_(resistance))) {
          amt++;
        }
      }
      if (amt) {
        char o_name[80];
        struct object* destroyed;
        bool none_left = false;
        object_desc(o_name, sizeof(o_name), obj, ODESC_BASE, p);
        msgt(MSG_DESTROY, "%sour %s (%c) %s destroyed!",
             ((obj->number > 1) ? ((amt == obj->number)
                                       ? "All of y"
                                       : (amt > 1 ? "Some of y" : "One of y"))
                                : "Y"),
             o_name, gear_to_label(p, obj), ((amt > 1) ? "were" : "was"));
        destroyed = gear_object_for_use(p, obj, amt, false, &none_left);
        if (destroyed->known) object_delete(NULL, NULL, &destroyed->known);
        object_delete(NULL, NULL, &destroyed);
        k += amt;
      }
    }
    obj = next;
  }
  return k;
}
static void
project_object_elemental(project_object_handler_context_t* context, int element,
                         const char* singular_verb, const char* plural_verb)
{
  if (context->obj->el_info[element].flags & EL_INFO_HATES) {
    context->do_kill = true;
    context->note_kill =
        VERB_AGREEMENT(context->obj->number, singular_verb, plural_verb);
    context->ignore =
        (context->obj->el_info[element].flags & EL_INFO_IGNORE) ? true : false;
  }
}
STATIC_OVL void
project_object_handler_FIRE(project_object_handler_context_t* context)
{
  project_object_elemental(context, ELEM_FIRE, "burns up", "burn up");
}
STATIC_OVL void
project_object_handler_COLD(project_object_handler_context_t* context)
{
  project_object_elemental(context, ELEM_COLD, "shatters", "shatter");
}
STATIC_OVL void
project_object_handler_POIS(project_object_handler_context_t* context)
{
}
STATIC_OVL void
project_object_handler_DARK(project_object_handler_context_t* context)
{
}
STATIC_OVL void
project_object_handler_NOTHING(project_object_handler_context_t* context)
{
}
STATIC_OVL void
project_object_handler_HURT(project_object_handler_context_t* context)
{
}
STATIC_OVL void
project_object_handler_ARROW(project_object_handler_context_t* context)
{
}
STATIC_OVL void
project_object_handler_BOULDER(project_object_handler_context_t* context)
{
}
STATIC_OVL void
project_object_handler_ACID(project_object_handler_context_t* context)
{
  project_object_elemental(context, ELEM_ACID, "melts", "melt");
}
STATIC_OVL void
project_object_handler_SOUND(project_object_handler_context_t* context)
{
  project_object_elemental(context, PROJ_SOUND, "shatters", "shatter");
}
STATIC_OVL void
project_object_handler_FORCE(project_object_handler_context_t* context)
{
}
STATIC_OVL void
project_object_handler_LIGHT(project_object_handler_context_t* context)
{
}
STATIC_OVL void
project_object_handler_KILL_WALL(project_object_handler_context_t* context)
{
}
STATIC_OVL void
project_object_handler_SLEEP(project_object_handler_context_t* context)
{
}
STATIC_OVL void
project_object_handler_SPEED(project_object_handler_context_t* context)
{
}
STATIC_OVL void
project_object_handler_SLOW(project_object_handler_context_t* context)
{
}
STATIC_OVL void
project_object_handler_CONFUSION(project_object_handler_context_t* context)
{
}
STATIC_OVL void
project_object_handler_FEAR(project_object_handler_context_t* context)
{
}
STATIC_OVL void
project_object_handler_EARTHQUAKE(project_object_handler_context_t* context)
{
  project_object_elemental(context, PROJ_SOUND, "shatters", "shatter");
}
STATIC_OVL void
project_object_handler_DARK_WEAK(project_object_handler_context_t* context)
{
}
STATIC_OVL void
project_object_handler_KILL_DOOR(project_object_handler_context_t* context)
{
  if (is_locked_chest(context->obj)) {
    unlock_chest((struct object* const)context->obj);
    if (context->obj->pval == context->obj->known->pval) {
      msg("Click!");
      context->obvious = true;
    }
  }
}
STATIC_OVL void
project_object_handler_LOCK_DOOR(project_object_handler_context_t* context)
{
}
STATIC_OVL void
project_object_handler_KILL_TRAP(project_object_handler_context_t* context)
{
  if (is_locked_chest(context->obj)) {
    unlock_chest((struct object* const)context->obj);
    if (context->obj->pval == context->obj->known->pval) {
      msg("Click!");
      context->obvious = true;
    }
  }
}
STATIC_OVL void
project_object_handler_DISP_ALL(project_object_handler_context_t* context)
{
}
STATIC_OVL bool
project_o(struct loc grid, int typ, const struct object* protected_obj)
{
  struct object* obj = square_object(cave, grid);
  bool obvious = false;
  while (obj) {
    bool ignore = false;
    bool do_kill = false;
    const char* note_kill = NULL;
    struct object* next = obj->next;
    project_object_handler_f object_handler = object_handlers[typ];
    project_object_handler_context_t context = {
        grid, typ, obj, obvious, do_kill, ignore, note_kill,
    };
    if (object_handler != NULL) object_handler(&context);
    obvious = context.obvious;
    do_kill = context.do_kill && (obj != protected_obj);
    ignore = context.ignore;
    note_kill = context.note_kill;
    if (do_kill) {
      char o_name[80];
      if (obj->known && !ignore_item_ok(player, obj) &&
          square_isseen(cave, grid)) {
        obvious = true;
        object_desc(o_name, sizeof(o_name), obj, ODESC_BASE, player);
      }
      if (obj->artifact || ignore) {
        if (obvious && !ignore_item_ok(player, obj)) {
          msg("The %s %s unaffected!", o_name,
              VERB_AGREEMENT(obj->number, "is", "are"));
        }
      } else {
        if (obvious && note_kill && !ignore_item_ok(player, obj)) {
          msgt(MSG_DESTROY, "The %s %s!", o_name, note_kill);
        }
        if (loc_eq(grid, player->grid)) {
          cmd_disable_repeat_floor_item();
        }
        square_delete_object(cave, grid, obj, true, true);
      }
    }
    obj = next;
  }
  return obvious;
}
STATIC_OVL int
adjust_dam(struct player* p, int dd, int ds, int type)
{
  int prt = protection_roll(p, type, false, RANDOMISE);
  int dam = damroll(dd, ds);
  int resist = 1;
  int net_dam;
  if (p && p->race) {
    resist = type < ELEM_MAX ? p->state.el_info[type].res_level : 0;
    if (!type) resist = 1;
    if (resist < 1) resist -= 2;
  }
  net_dam = dam / resist;
  net_dam = net_dam > prt ? net_dam - prt : 0;
  event_signal_combat_damage(EVENT_COMBAT_DAMAGE, dd, ds, dam, -1, -1, prt, 100,
                             type, false);
  return net_dam;
}
STATIC_OVL void
project_player_handler_FIRE(project_player_handler_context_t* context)
{
  inven_damage(player, PROJ_FIRE, MIN(context->dam / 10, 3), 1);
  equip_learn_element(player, ELEM_FIRE);
}
STATIC_OVL void
project_player_handler_COLD(project_player_handler_context_t* context)
{
  inven_damage(player, PROJ_FIRE, MIN(context->dam / 10, 3), 1);
  equip_learn_element(player, ELEM_COLD);
}
STATIC_OVL void
project_player_handler_POIS(project_player_handler_context_t* context)
{
  player_inc_timed(player, TMD_POISONED, context->dam, true, true, false);
  equip_learn_element(player, ELEM_POIS);
}
STATIC_OVL void
project_player_handler_DARK(project_player_handler_context_t* context)
{
  int resistance = MAX(1, square_light(cave, player->grid));
  if (one_in_(resistance)) {
    (void)player_inc_timed(player, TMD_BLIND, damroll(2, 4), true, true, true);
  }
}
STATIC_OVL void
project_player_handler_NOTHING(project_player_handler_context_t* context)
{
}
STATIC_OVL void
project_player_handler_HURT(project_player_handler_context_t* context)
{
}
STATIC_OVL void
project_player_handler_ARROW(project_player_handler_context_t* context)
{
}
STATIC_OVL void
project_player_handler_BOULDER(project_player_handler_context_t* context)
{
}
STATIC_OVL void
project_player_handler_ACID(project_player_handler_context_t* context)
{
  if (context->dam) {
    minus_ac(player);
    inven_damage(player, PROJ_ACID, MIN(context->dam / 10, 3), 1);
  }
}
STATIC_OVL void
project_player_handler_SOUND(project_player_handler_context_t* context)
{
  if (!player_inc_timed(player, TMD_STUN, context->dam, true, true, true)) {
    msg("You are unfazed");
  }
}
STATIC_OVL void
project_player_handler_FORCE(project_player_handler_context_t* context)
{
}
STATIC_OVL void
project_player_handler_LIGHT(project_player_handler_context_t* context)
{
}
STATIC_OVL void
project_player_handler_KILL_WALL(project_player_handler_context_t* context)
{
}
STATIC_OVL void
project_player_handler_SLEEP(project_player_handler_context_t* context)
{
}
STATIC_OVL void
project_player_handler_SPEED(project_player_handler_context_t* context)
{
}
STATIC_OVL void
project_player_handler_SLOW(project_player_handler_context_t* context)
{
}
STATIC_OVL void
project_player_handler_CONFUSION(project_player_handler_context_t* context)
{
}
STATIC_OVL void
project_player_handler_FEAR(project_player_handler_context_t* context)
{
}
STATIC_OVL void
project_player_handler_EARTHQUAKE(project_player_handler_context_t* context)
{
}
STATIC_OVL void
project_player_handler_DARK_WEAK(project_player_handler_context_t* context)
{
}
STATIC_OVL void
project_player_handler_KILL_DOOR(project_player_handler_context_t* context)
{
}
STATIC_OVL void
project_player_handler_LOCK_DOOR(project_player_handler_context_t* context)
{
}
STATIC_OVL void
project_player_handler_KILL_TRAP(project_player_handler_context_t* context)
{
}
STATIC_OVL void
project_player_handler_DISP_ALL(project_player_handler_context_t* context)
{
}
STATIC_OVL void
monster_ranged_attack(project_player_handler_context_t* context, char* killer)
{
  int total_attack_mod, total_evasion_mod, crit_bonus_dice, hit_result;
  int total_dd, total_ds;
  int prt, dam, net_dam, weight;
  struct monster* mon = context->mon;
  struct monster_race* race = mon->race;
  bool arrow = context->type == PROJ_ARROW;
  total_attack_mod = total_monster_attack(player, mon, race->spell_power);
  total_evasion_mod = total_player_evasion(player, mon, false);
  if (arrow) {
    total_evasion_mod /= 2;
    if (context->ds >= 11) {
      weight = 30;
    } else {
      weight = 20;
    }
  } else {
    weight = 100;
  }
  hit_result = hit_roll(total_attack_mod, total_evasion_mod,
                        source_monster(mon->midx), source_player(), true);
  if (hit_result > 0) {
    crit_bonus_dice = crit_bonus(player, hit_result, weight, &r_info[0],
                                 SKILL_ARCHERY, !arrow);
    total_dd = context->dd + crit_bonus_dice;
    total_ds = context->ds;
    dam = damroll(total_dd, total_ds);
    prt = protection_roll(player, PROJ_HURT, false, RANDOMISE);
    net_dam = (dam - prt > 0) ? (dam - prt) : 0;
    if (player->timed[TMD_BLIND]) {
      msg("You are hit by %s.", projections[context->type].blind_desc);
    } else {
      if (net_dam > 0) {
        if (crit_bonus_dice == 0) {
          msg("It hits you.");
        } else {
          msg("It hits!");
        }
      }
    }
    event_signal_combat_damage(EVENT_COMBAT_DAMAGE, total_dd, total_ds, dam, -1,
                               -1, prt, 100, PROJ_HURT, false);
    event_signal_hit(EVENT_HIT, net_dam, PROJ_HURT, player->is_dead,
                     player->grid);
    if (net_dam) {
      take_hit(player, net_dam, killer);
      if (arrow && rf_has(race->flags, RF_CRIPPLING) &&
          (crit_bonus_dice >= 1) && (net_dam > 0)) {
        int difficulty = player->state.skill_use[SKILL_WILL] +
                         player->state.flags[OF_FREE_ACT] * 10;
        if (skill_check(source_monster(mon->midx), crit_bonus_dice * 4,
                        difficulty, source_player()) > 0) {
          struct monster_lore* lore = get_lore(race);
          if (monster_is_visible(mon)) {
            rf_on(lore->flags, RF_CRIPPLING);
          }
          msg("The shot tears into your thigh!");
          player_inc_timed(player, TMD_SLOW, crit_bonus_dice, true, true,
                           false);
        }
      }
    }
    monsters_hear(true, false, arrow ? -5 : -10);
  }
}
STATIC_OVL bool
project_p(struct source origin, struct loc grid, int dd, int ds, int typ)
{
  bool blind = (player->timed[TMD_BLIND] ? true : false);
  bool seen = !blind;
  int dam = damroll(dd, ds);
  char killer[80];
  project_player_handler_f player_handler = player_handlers[typ];
  project_player_handler_context_t context = {origin, grid, NULL, dd,
                                              ds,     dam,  typ};
  if (!square_isplayer(cave, grid)) {
    return false;
  }
  switch (origin.what) {
    case SRC_PLAYER: {
      return false;
      break;
    }
    case SRC_MONSTER: {
      struct monster* mon = cave_monster(cave, origin.which.monster);
      context.mon = mon;
      if (!monster_is_visible(mon)) seen = false;
      monster_desc(killer, sizeof(killer), mon, MDESC_DIED_FROM);
      break;
    }
    case SRC_TRAP: {
      struct trap* trap = origin.which.trap;
      strnfmt(killer, sizeof(killer), "a %s", trap->kind->desc);
      break;
    }
    case SRC_OBJECT: {
      struct object* obj = origin.which.object;
      object_desc(killer, sizeof(killer), obj, ODESC_PREFIX | ODESC_BASE,
                  player);
      break;
    }
    case SRC_CHEST_TRAP: {
      struct chest_trap* trap = origin.which.chest_trap;
      strnfmt(killer, sizeof(killer), "%s", trap->msg_death);
      break;
    }
    default: {
      my_strcpy(killer, "a bug", sizeof(killer));
      break;
    }
  }
  if (!seen) {
    msg("You are hit by %s!", projections[typ].blind_desc);
  }
  if (typ < ELEM_MAX) {
    event_signal_combat_attack(EVENT_COMBAT_ATTACK, origin, source_player(),
                               true, -1, -1, -1, -1, false);
    context.dam = adjust_dam(player, context.dd, context.ds, context.type);
  }
  if (context.dam && projections[typ].damaging) {
    if (projections[typ].evade) {
      monster_ranged_attack(&context, killer);
    } else {
      take_hit(player, context.dam, killer);
    }
  }
  if (player_handler != NULL && player->is_dead == false) {
    player_handler(&context);
  }
  disturb(player, true);
  return true;
}
STATIC_OVL void
build_prob(name_probs probs, const char** learn)
{
  int c_prev, c_cur, c_next;
  const char* ch;
  int i;
  for (i = 0; learn[i] != NULL; i++) {
    c_prev = c_cur = 26;
    ch = learn[i];
    while (*ch != '\0') {
      c_next = A2I(tolower((unsigned char)*ch));
      probs[c_prev][c_cur][c_next]++;
      probs[c_prev][c_cur][27]++;
      c_prev = c_cur;
      c_cur = c_next;
      ch++;
    }
    probs[c_prev][c_cur][26]++;
    probs[c_prev][c_cur][27]++;
  }
}
STATIC_OVL size_t
randname_make(randname_type name_type, size_t min, size_t max, char* word_buf,
              size_t buflen, const char*** sections)
{
  size_t lnum = 0;
  bool found_word = false;
  static name_probs lprobs;
  static randname_type cached_type = RANDNAME_NUM_TYPES;
  assert(name_type > 0 && name_type < RANDNAME_NUM_TYPES);
  assert(buflen > max);
  if (cached_type != name_type) {
    const char** wordlist = NULL;
    wordlist = sections[name_type];
    (void)memset(lprobs, 0, sizeof(name_probs));
    build_prob(lprobs, wordlist);
    cached_type = name_type;
  }
  while (!found_word) {
    char* cp = word_buf;
    int c_prev = 26;
    int c_cur = 26;
    int tries = 0;
    bool contains_vowel = false;
    lnum = 0;
    while (tries < 10 && lnum <= max && !found_word) {
      int r;
      int c_next = 0;
      assert(c_prev >= 0 && c_prev <= 26);
      assert(c_cur >= 0 && c_cur <= 26);
      r = randint0(lprobs[c_prev][c_cur][27]);
      while (r >= lprobs[c_prev][c_cur][c_next]) {
        r -= lprobs[c_prev][c_cur][c_next];
        c_next++;
      }
      assert(c_next <= 26);
      assert(c_next >= 0);
      if (c_next == 26) {
        if (lnum >= min && contains_vowel) {
          *cp = '\0';
          found_word = true;
        } else {
          tries++;
        }
      } else {
        *cp = I2A(c_next);
        if (is_a_vowel(*cp)) contains_vowel = true;
        cp++;
        lnum++;
        assert(c_next <= 26);
        assert(c_next >= 0);
        c_prev = c_cur;
        c_cur = c_next;
      }
    }
  }
  return lnum;
}
STATIC_OVL int
score_points(const struct high_score* score)
{
  int points = 0;
  int silmarils;
  int maxturns = 100000;
  int silmarils_factor = maxturns;
  int depth_factor = silmarils_factor * 10;
  int morgoth_factor = depth_factor * 100;
  points = maxturns - atoi(score->turns);
  if (points < 0) {
    points = 0;
  }
  if (points >= maxturns) {
    points = maxturns - 1;
  }
  silmarils = atoi(score->silmarils);
  points += silmarils_factor * silmarils;
  if (silmarils == 0) {
    points += depth_factor * atoi(score->cur_dun);
  } else {
    points += depth_factor * (40 - atoi(score->cur_dun));
  }
  if (score->escaped[0] == 't') {
    points += depth_factor;
  }
  if (score->morgoth_slain[0] == 't') {
    points += morgoth_factor;
  }
  return points;
}
STATIC_OVL size_t
highscore_read(struct high_score scores[], size_t sz)
{
  char fname[1024];
  ang_file* scorefile;
  size_t i;
  memset(scores, 0, sz * sizeof(struct high_score));
  path_build(fname, sizeof(fname), ANGBAND_DIR_SCORES, "scores.raw");
  safe_setuid_grab();
  scorefile = file_open(fname, MODE_READ, FTYPE_TEXT);
  safe_setuid_drop();
  if (!scorefile) return 0;
  for (i = 0; i < sz; i++)
    if (file_read(scorefile, (char*)&scores[i], sizeof(struct high_score)) <= 0)
      break;
  file_close(scorefile);
  return i;
}
STATIC_OVL size_t
highscore_where(const struct high_score* entry,
                const struct high_score scores[], size_t sz)
{
  size_t i;
  for (i = 0; i < sz; i++) {
    int entry_pts = score_points(entry);
    int score_pts = score_points(&scores[i]);
    if (entry_pts >= score_pts) return i;
    if (scores[i].what[0] == '\0') return i;
  }
  return sz - 1;
}
STATIC_OVL size_t
highscore_add(const struct high_score* entry, struct high_score scores[],
              size_t sz)
{
  size_t slot = highscore_where(entry, scores, sz);
  memmove(&scores[slot + 1], &scores[slot],
          sizeof(struct high_score) * (sz - 1 - slot));
  memcpy(&scores[slot], entry, sizeof(struct high_score));
  return slot;
}
STATIC_OVL size_t
highscore_count(const struct high_score scores[], size_t sz)
{
  size_t i;
  for (i = 0; i < sz; i++)
    if (scores[i].what[0] == '\0') break;
  return i;
}
STATIC_OVL void
highscore_write(const struct high_score scores[], size_t sz)
{
  size_t n;
  ang_file* lok;
  ang_file* scorefile;
  char old_name[1024];
  char cur_name[1024];
  char new_name[1024];
  char lok_name[1024];
  bool exists;
  path_build(old_name, sizeof(old_name), ANGBAND_DIR_SCORES, "scores.old");
  path_build(cur_name, sizeof(cur_name), ANGBAND_DIR_SCORES, "scores.raw");
  path_build(new_name, sizeof(new_name), ANGBAND_DIR_SCORES, "scores.new");
  path_build(lok_name, sizeof(lok_name), ANGBAND_DIR_SCORES, "scores.lok");
  n = highscore_count(scores, sz);
  safe_setuid_grab();
  exists = file_exists(lok_name);
  safe_setuid_drop();
  if (exists) {
    msg("Lock file in place for scorefile; not writing.");
    return;
  }
  safe_setuid_grab();
  lok = file_open(lok_name, MODE_WRITE, FTYPE_RAW);
  if (!lok) {
    safe_setuid_drop();
    msg("Failed to create lock for scorefile; not writing.");
    return;
  } else {
    file_lock(lok);
    safe_setuid_drop();
  }
  safe_setuid_grab();
  scorefile = file_open(new_name, MODE_WRITE, FTYPE_RAW);
  safe_setuid_drop();
  if (!scorefile) {
    msg("Failed to open new scorefile for writing.");
    file_close(lok);
    safe_setuid_grab();
    file_delete(lok_name);
    safe_setuid_drop();
    return;
  }
  file_write(scorefile, (const char*)scores, sizeof(struct high_score) * n);
  file_close(scorefile);
  safe_setuid_grab();
  if (file_exists(old_name) && !file_delete(old_name))
    msg("Couldn't delete old scorefile");
  if (file_exists(cur_name) && !file_move(cur_name, old_name))
    msg("Couldn't move old scores.raw out of the way");
  if (!file_move(new_name, cur_name))
    msg("Couldn't rename new scorefile to scores.raw");
  file_close(lok);
  file_delete(lok_name);
  safe_setuid_drop();
}
STATIC_OVL void
build_score(struct high_score* entry, const struct player* p,
            const char* died_from, const time_t* death_time)
{
  memset(entry, 0, sizeof(struct high_score));
  strnfmt(entry->what, sizeof(entry->what), "%s", buildid);
  strnfmt(entry->turns, sizeof(entry->turns), "%9ld", (long)p->turn);
  if (death_time)
    strftime(entry->day, sizeof(entry->day), "@%Y%m%d", localtime(death_time));
  else
    my_strcpy(entry->day, "TODAY", sizeof(entry->day));
  strnfmt(entry->who, sizeof(entry->who), "%-.15s", p->full_name);
  strnfmt(entry->uid, sizeof(entry->uid), "%7u", player_uid);
  strnfmt(entry->p_s, sizeof(entry->p_s), "%2d", p->sex->sidx);
  strnfmt(entry->p_r, sizeof(entry->p_r), "%2d", p->race->ridx);
  strnfmt(entry->p_h, sizeof(entry->p_h), "%2d", p->house->hidx);
  strnfmt(entry->cur_dun, sizeof(entry->cur_dun), "%3d", p->depth);
  strnfmt(entry->max_dun, sizeof(entry->max_dun), "%3d", p->max_depth);
  my_strcpy(entry->how, died_from, sizeof(entry->how));
  strnfmt(entry->silmarils, sizeof(entry->silmarils), "%1d",
          silmarils_possessed((struct player*)p));
  if (p->morgoth_slain) {
    strnfmt(entry->morgoth_slain, sizeof(entry->morgoth_slain), "t");
  } else {
    strnfmt(entry->morgoth_slain, sizeof(entry->morgoth_slain), "f");
  }
  if (p->escaped) {
    strnfmt(entry->escaped, sizeof(entry->escaped), "t");
  } else {
    strnfmt(entry->escaped, sizeof(entry->escaped), "f");
  }
}
STATIC_OVL void
enter_score(const struct player* p, const time_t* death_time)
{
  int j;
  for (j = 0; j < OPT_MAX; ++j) {
    if (option_type(j) != OP_SCORE) continue;
    if (!p->opts.opt[j]) continue;
    msg("Score not registered for cheaters.");
    event_signal(EVENT_MESSAGE_FLUSH);
    return;
  }
  if (p->noscore & (NOSCORE_WIZARD | NOSCORE_DEBUG)) {
    msg("Score not registered for wizards.");
    event_signal(EVENT_MESSAGE_FLUSH);
  } else if (streq(p->died_from, "Interrupting")) {
    msg("Score not registered due to interruption.");
    event_signal(EVENT_MESSAGE_FLUSH);
  } else if (streq(p->died_from, "Retiring")) {
    msg("Score not registered due to retiring.");
    event_signal(EVENT_MESSAGE_FLUSH);
  } else {
    struct high_score entry;
    struct high_score scores[MAX_HISCORES];
    build_score(&entry, p, p->died_from, death_time);
    highscore_read(scores, N_ELEMENTS(scores));
    highscore_add(&entry, scores, N_ELEMENTS(scores));
    highscore_write(scores, N_ELEMENTS(scores));
  }
  return;
}
STATIC_OVL void
wr_description(void)
{
  char buf[1024];
  if (player->is_dead)
    strnfmt(buf, sizeof buf, "%s, dead (%s)", player->full_name,
            player->died_from);
  else
    strnfmt(buf, sizeof buf, "%s, Exp %ld %s %s, at DL%d", player->full_name,
            (long)player->exp, player->race->name, player->house->name,
            player->depth);
  wr_string(buf);
}
STATIC_OVL void
wr_item(const struct object* obj)
{
  size_t i;
  struct ability* ability;
  wr_u16b(0xffff);
  wr_byte(0);
  wr_u16b(obj->oidx);
  wr_byte(obj->grid.y);
  wr_byte(obj->grid.x);
  wr_string(tval_find_name(obj->tval));
  if (obj->sval) {
    char name[1024];
    struct object_kind* kind = lookup_kind(obj->tval, obj->sval);
    obj_desc_name_format(name, sizeof name, 0, kind->name, 0, false);
    wr_string(name);
  } else {
    wr_string("");
  }
  if (obj->image_kind) {
    wr_string(tval_find_name(obj->image_kind->tval));
    if (obj->image_kind->sval) {
      char name[1024];
      struct object_kind* kind =
          lookup_kind(obj->image_kind->tval, obj->image_kind->sval);
      obj_desc_name_format(name, sizeof name, 0, kind->name, 0, false);
      wr_string(name);
    } else {
      wr_string("");
    }
  } else {
    wr_string("");
  }
  wr_s16b(obj->pval);
  wr_byte(obj->number);
  wr_s16b(obj->weight);
  if (obj->artifact) {
    wr_string(obj->artifact->name);
  } else {
    wr_string("");
  }
  if (obj->ego) {
    wr_string(obj->ego->name);
  } else {
    wr_string("");
  }
  wr_s16b(obj->timeout);
  wr_byte(obj->used);
  wr_s16b(obj->att);
  wr_byte(obj->dd);
  wr_byte(obj->ds);
  wr_s16b(obj->evn);
  wr_byte(obj->pd);
  wr_byte(obj->ps);
  wr_byte(obj->origin);
  wr_byte(obj->origin_depth);
  if (obj->origin_race) {
    wr_string(obj->origin_race->name);
  } else {
    wr_string("");
  }
  wr_byte(obj->notice);
  wr_byte(obj->pseudo);
  for (i = 0; i < OF_SIZE; i++) wr_byte(obj->flags[i]);
  for (i = 0; i < OBJ_MOD_MAX; i++) {
    wr_s16b(obj->modifiers[i]);
  }
  if (obj->brands) {
    wr_byte(1);
    for (i = 0; i < z_info->brand_max; i++) {
      wr_byte(obj->brands[i] ? 1 : 0);
    }
  } else {
    wr_byte(0);
  }
  if (obj->slays) {
    wr_byte(1);
    for (i = 0; i < z_info->slay_max; i++) {
      wr_byte(obj->slays[i] ? 1 : 0);
    }
  } else {
    wr_byte(0);
  }
  for (i = 0; i < ELEM_MAX; i++) {
    wr_s16b(obj->el_info[i].res_level);
    wr_byte(obj->el_info[i].flags);
  }
  for (ability = obj->abilities; ability; ability = ability->next) {
    wr_string(ability->name);
    wr_byte(ability->skill);
  }
  wr_string("end");
  wr_s16b(obj->held_m_idx);
  if (obj->note) {
    wr_byte(1);
    wr_string(quark_str(obj->note));
  } else {
    wr_byte(0);
  }
}
STATIC_OVL void
wr_monster(const struct monster* mon)
{
  size_t j;
  struct object* obj = mon->held_obj;
  struct object* dummy = object_new();
  wr_u16b(mon->midx);
  wr_string(mon->race->name);
  if (mon->image_race) {
    wr_string(mon->image_race->name);
  } else {
    wr_string("none");
  }
  wr_byte(mon->grid.y);
  wr_byte(mon->grid.x);
  wr_s16b(mon->hp);
  wr_s16b(mon->maxhp);
  wr_byte(mon->mana);
  wr_byte(mon->song ? mon->song->index : 0);
  wr_s16b(mon->alertness);
  wr_byte(mon->mspeed);
  wr_byte(mon->energy);
  wr_byte(mon->origin);
  wr_byte(mon->stance);
  wr_s16b(mon->morale);
  wr_s16b(mon->tmp_morale);
  wr_byte(mon->noise);
  wr_byte(mon->encountered);
  wr_byte(MON_TMD_MAX);
  for (j = 0; j < MON_TMD_MAX; j++) wr_s16b(mon->m_timed[j]);
  for (j = 0; j < MFLAG_SIZE; j++) wr_byte(mon->mflag[j]);
  for (j = 0; j < OF_SIZE; j++) wr_s16b(mon->known_pstate.flags[j]);
  for (j = 0; j < ELEM_MAX; j++)
    wr_s16b(mon->known_pstate.el_info[j].res_level);
  for (j = 0; j < MAX_ACTION; j++) {
    wr_byte(mon->previous_action[j]);
  }
  while (obj) {
    wr_item(obj);
    obj = obj->next;
  }
  wr_item(dummy);
  object_delete(NULL, NULL, &dummy);
  wr_u16b(mon->group_info.index);
  wr_byte(mon->group_info.role);
  wr_byte(mon->target.grid.y);
  wr_byte(mon->target.grid.x);
  wr_byte(mon->skip_this_turn);
  wr_byte(mon->skip_next_turn);
  wr_s16b(mon->consecutive_attacks);
  wr_s16b(mon->turns_stationary);
}
STATIC_OVL void
wr_trap(struct trap* trap)
{
  size_t i;
  if (trap->t_idx) {
    wr_string(trap_info[trap->t_idx].desc);
  } else {
    wr_string("");
  }
  wr_byte(trap->grid.y);
  wr_byte(trap->grid.x);
  wr_byte(trap->power);
  for (i = 0; i < TRF_SIZE; i++) wr_byte(trap->flags[i]);
}
STATIC_OVL void
wr_randomizer(void)
{
  int i;
  wr_u32b(Rand_value);
  wr_u32b(state_i);
  wr_u32b(z0);
  wr_u32b(z1);
  wr_u32b(z2);
  for (i = 0; i < RAND_DEG; i++) wr_u32b(STATE[i]);
  for (i = 0; i < 59 - RAND_DEG; i++) wr_u32b(0);
}
STATIC_OVL void
wr_options(void)
{
  int i;
  wr_byte(player->opts.delay_factor);
  wr_byte(player->opts.hitpoint_warn);
  wr_byte(player->opts.lazymove_delay);
  wr_byte(angband_term[0] ? SIDEBAR_MODE : 0);
  for (i = 0; i < OPT_MAX; i++) {
    const char* name = option_name(i);
    if (name) {
      wr_string(name);
      wr_byte(player->opts.opt[i]);
    }
  }
  wr_byte(0);
}
STATIC_OVL void
wr_messages(void)
{
  int16_t i;
  uint16_t num;
  num = messages_num();
  if (num > 80) num = 80;
  wr_u16b(num);
  for (i = num - 1; i >= 0; i--) {
    wr_string(message_str(i));
    wr_u16b(message_type(i));
  }
}
STATIC_OVL void
wr_monster_memory(void)
{
  int r_idx;
  wr_byte(MFLAG_SIZE);
  for (r_idx = 0; r_idx < z_info->r_max; r_idx++) {
    struct monster_race* race = &r_info[r_idx];
    struct monster_lore* lore = &l_list[r_idx];
    if (!race->name || ((!lore->pkills) && (!lore->psights))) continue;
    wr_string(race->name);
    wr_u16b(lore->pkills);
    wr_u16b(lore->psights);
  }
  wr_string("No more monsters");
}
STATIC_OVL void
wr_object_memory(void)
{
  int k_idx;
  wr_u16b(z_info->k_max);
  wr_byte(OF_SIZE);
  wr_byte(OBJ_MOD_MAX);
  wr_byte(ELEM_MAX);
  wr_byte(z_info->brand_max);
  wr_byte(z_info->slay_max);
  for (k_idx = 0; k_idx < z_info->k_max; k_idx++) {
    uint8_t tmp8u = 0;
    struct object_kind* kind = &k_info[k_idx];
    if (kind->aware) tmp8u |= 0x01;
    if (kind->tried) tmp8u |= 0x02;
    if (kind_is_ignored_aware(kind)) tmp8u |= 0x04;
    if (kind->everseen) tmp8u |= 0x08;
    if (kind_is_ignored_unaware(kind)) tmp8u |= 0x10;
    wr_byte(tmp8u);
  }
}
STATIC_OVL void
wr_player(void)
{
  int i;
  struct ability* ability;
  wr_string(player->full_name);
  wr_string(player->died_from);
  wr_string(player->history);
  wr_string(player->race->name);
  wr_string(player->house->name);
  wr_string(player->sex->name);
  wr_byte(player->opts.name_suffix);
  wr_s16b(player->game_type);
  wr_s16b(player->age);
  wr_s16b(player->ht);
  wr_s16b(player->wt);
  wr_s16b(player->ht_birth);
  wr_s16b(player->wt_birth);
  wr_byte(STAT_MAX);
  for (i = 0; i < STAT_MAX; ++i) wr_s16b(player->stat_base[i]);
  for (i = 0; i < STAT_MAX; ++i) wr_s16b(player->stat_drain[i]);
  wr_byte(SKILL_MAX);
  for (i = 0; i < SKILL_MAX; ++i) wr_s16b(player->skill_base[i]);
  for (ability = player->abilities; ability; ability = ability->next) {
    wr_string(ability->name);
    wr_byte(ability->skill);
    if (ability->active) {
      wr_byte(1);
    } else {
      wr_byte(0);
    }
  }
  wr_string("end");
  for (ability = player->item_abilities; ability; ability = ability->next) {
    wr_string(ability->name);
    wr_byte(ability->skill);
    if (ability->active) {
      wr_byte(1);
    } else {
      wr_byte(0);
    }
  }
  wr_string("end");
  for (i = 0; i < MAX_ACTION; i++) {
    wr_byte(player->previous_action[i]);
  }
  wr_string(player->body.name);
  wr_u16b(player->body.count);
  for (i = 0; i < player->body.count; i++) {
    wr_u16b(player->body.slots[i].type);
    wr_string(player->body.slots[i].name);
  }
  wr_s32b(player->new_exp);
  wr_s32b(player->exp);
  wr_s32b(player->encounter_exp);
  wr_s32b(player->kill_exp);
  wr_s32b(player->descent_exp);
  wr_s32b(player->ident_exp);
  wr_s32b(player->turn);
  wr_s16b(player->mhp);
  wr_s16b(player->chp);
  wr_s16b(player->msp);
  wr_s16b(player->csp);
  wr_s16b(player->max_depth);
  wr_u16b(player->staircasiness);
  wr_s16b(player->energy);
  wr_u32b(player->total_energy);
  wr_u32b(player->resting_turn);
  wr_byte(TMD_MAX);
  for (i = 0; i < TMD_MAX; i++) wr_s16b(player->timed[i]);
  wr_u16b(z_info->v_max);
  for (i = 0; i < z_info->v_max; i++) {
    wr_byte(player->vaults[i]);
  }
  wr_byte(player->unignoring);
  wr_s16b(player->last_attack_m_idx);
  wr_s16b(player->consecutive_attacks);
  wr_s16b(player->bane_type);
  wr_byte(player->focused);
  wr_byte(player->song[SONG_MAIN] ? player->song[SONG_MAIN]->index : 0);
  wr_byte(player->song[SONG_MINOR] ? player->song[SONG_MINOR]->index : 0);
  wr_s16b(player->song_duration);
  wr_s16b(player->wrath);
  wr_u16b(player->stairs_taken);
  wr_u16b(player->forge_drought);
  wr_u16b(player->forge_count);
  wr_byte(player->stealth_mode);
  wr_byte(player->self_made_arts);
  wr_byte(player->truce);
  wr_byte(player->morgoth_hits);
  wr_byte(player->crown_hint);
  wr_byte(player->crown_shatter);
  wr_byte(player->cursed);
  wr_byte(player->on_the_run);
  wr_byte(player->morgoth_slain);
  wr_byte(player->escaped);
  wr_u16b(player->noscore);
  wr_s16b(player->smithing_leftover);
  wr_byte(player->unique_forge_made);
  wr_byte(player->unique_forge_seen);
}
STATIC_OVL void
wr_ignore(void)
{
  size_t i;
  uint16_t j, n;
  assert(ignore_size <= 255);
  wr_byte((uint8_t)ignore_size);
  for (i = 0; i < ignore_size; i++) wr_byte(ignore_level[i]);
  wr_u16b(z_info->e_max);
  wr_u16b(ITYPE_SIZE);
  for (i = 0; i < z_info->e_max; i++) {
    bitflag everseen = 0, itypes[ITYPE_SIZE];
    if (e_info[i].everseen) everseen |= 0x02;
    if (e_info[i].aware) everseen |= 0x04;
    wr_byte(everseen);
    itype_wipe(itypes);
    for (j = ITYPE_NONE; j < ITYPE_MAX; j++)
      if (ego_is_ignored(i, j)) itype_on(itypes, j);
    for (j = 0; j < ITYPE_SIZE; j++) wr_byte(itypes[j]);
  }
  n = 0;
  for (i = 0; i < z_info->k_max; i++)
    if (k_info[i].note_aware) n++;
  wr_u16b(n);
  for (i = 0; i < z_info->k_max; i++) {
    if (k_info[i].note_aware) {
      char name[1024];
      wr_string(tval_find_name(k_info[i].tval));
      obj_desc_name_format(name, sizeof name, 0, k_info[i].name, 0, false);
      wr_string(name);
      wr_string(quark_str(k_info[i].note_aware));
    }
  }
  n = 0;
  for (i = 0; i < z_info->k_max; i++)
    if (k_info[i].note_unaware) n++;
  wr_u16b(n);
  for (i = 0; i < z_info->k_max; i++) {
    if (k_info[i].note_unaware) {
      char name[1024];
      wr_string(tval_find_name(k_info[i].tval));
      obj_desc_name_format(name, sizeof name, 0, k_info[i].name, 0, false);
      wr_string(name);
      wr_string(quark_str(k_info[i].note_unaware));
    }
  }
  return;
}
STATIC_OVL void
wr_misc(void)
{
  size_t i;
  wr_u32b(seed_randart);
  wr_u32b(seed_flavor);
  wr_u16b(player->noscore);
  wr_byte(player->is_dead);
  wr_s32b(turn);
  for (i = 0; i < OF_SIZE; i++) wr_byte(player->obj_k->flags[i]);
  for (i = 0; i < OBJ_MOD_MAX; i++) {
    wr_s16b(player->obj_k->modifiers[i]);
  }
  for (i = 0; i < ELEM_MAX; i++) {
    wr_s16b(player->obj_k->el_info[i].res_level);
    wr_byte(player->obj_k->el_info[i].flags);
  }
  for (i = 0; i < z_info->brand_max; i++) {
    wr_byte(player->obj_k->brands[i] ? 1 : 0);
  }
  for (i = 0; i < z_info->slay_max; i++) {
    wr_byte(player->obj_k->slays[i] ? 1 : 0);
  }
  wr_s16b(player->obj_k->att);
  wr_s16b(player->obj_k->evn);
  wr_byte(player->obj_k->pd);
  wr_byte(player->obj_k->ps);
  wr_byte(player->obj_k->dd);
  wr_byte(player->obj_k->ds);
}
STATIC_OVL void
wr_artifacts(void)
{
  int i;
  uint16_t tmp16u;
  tmp16u = z_info->a_max;
  wr_u16b(tmp16u);
  for (i = 0; i < tmp16u; i++) {
    const struct artifact_upkeep* au = &aup_info[i];
    wr_byte(au->created ? 1 : 0);
    wr_byte(au->seen ? 1 : 0);
    wr_byte(au->everseen ? 1 : 0);
    wr_byte(0);
  }
}
STATIC_OVL void
wr_gear_aux(struct object* gear)
{
  struct object* obj;
  for (obj = gear; obj; obj = obj->next) {
    assert(obj->kind);
    wr_byte(object_slot(player->body, obj));
    wr_item(obj);
  }
  wr_byte(FINISHED_CODE);
}
STATIC_OVL void
wr_gear(void)
{
  wr_gear_aux(player->gear);
  wr_gear_aux(player->gear_k);
}
STATIC_OVL void
wr_dungeon_aux(struct chunk* c)
{
  int y, x;
  size_t i;
  uint8_t tmp8u;
  uint8_t count;
  uint8_t prev_char;
  wr_string(c->name ? c->name : "Blank");
  wr_u16b(c->height);
  wr_u16b(c->width);
  if (c->vault_name) {
    wr_byte(1);
    wr_string(c->vault_name);
  } else {
    wr_byte(0);
  }
  for (i = 0; i < SQUARE_SIZE; i++) {
    count = 0;
    prev_char = 0;
    for (y = 0; y < c->height; y++) {
      for (x = 0; x < c->width; x++) {
        tmp8u = square(c, loc(x, y))->info[i];
        if ((tmp8u != prev_char) || (count == UCHAR_MAX)) {
          wr_byte(count);
          wr_byte(prev_char);
          prev_char = tmp8u;
          count = 1;
        } else
          count++;
      }
    }
    if (count) {
      wr_byte(count);
      wr_byte(prev_char);
    }
  }
  count = 0;
  prev_char = 0;
  for (y = 0; y < c->height; y++) {
    for (x = 0; x < c->width; x++) {
      tmp8u = square(c, loc(x, y))->feat;
      if ((tmp8u != prev_char) || (count == UCHAR_MAX)) {
        wr_byte(count);
        wr_byte(prev_char);
        prev_char = tmp8u;
        count = 1;
      } else
        count++;
    }
  }
  if (count) {
    wr_byte(count);
    wr_byte(prev_char);
  }
}
STATIC_OVL void
wr_objects_aux(struct chunk* c)
{
  int y, x, i;
  struct object* dummy;
  if (player->is_dead) return;
  wr_u16b(c->obj_max);
  for (y = 0; y < c->height; y++) {
    for (x = 0; x < c->width; x++) {
      struct object* obj = square(c, loc(x, y))->obj;
      while (obj) {
        wr_item(obj);
        obj = obj->next;
      }
    }
  }
  for (i = 1; i < c->obj_max; i++) {
    struct object* obj = c->objects[i];
    if (!obj) continue;
    if (square_in_bounds_fully(c, obj->grid)) continue;
    if (obj->held_m_idx) continue;
    if (obj->known && !(obj->known->notice & OBJ_NOTICE_IMAGINED)) continue;
    assert(obj->oidx == i);
    wr_item(obj);
  }
  dummy = mem_zalloc(sizeof(*dummy));
  wr_item(dummy);
  mem_free(dummy);
}
STATIC_OVL void
wr_monsters_aux(struct chunk* c)
{
  int i;
  if (player->is_dead) return;
  wr_u16b(cave_monster_max(c));
  for (i = 1; i < cave_monster_max(c); i++) {
    const struct monster* mon = cave_monster(c, i);
    wr_monster(mon);
  }
}
STATIC_OVL void
wr_traps_aux(struct chunk* c)
{
  int x, y;
  struct trap* dummy;
  if (player->is_dead) return;
  wr_byte(TRF_SIZE);
  for (y = 0; y < c->height; y++) {
    for (x = 0; x < c->width; x++) {
      struct trap* trap = square(c, loc(x, y))->trap;
      while (trap) {
        wr_trap(trap);
        trap = trap->next;
      }
    }
  }
  dummy = mem_zalloc(sizeof(*dummy));
  wr_trap(dummy);
  mem_free(dummy);
}
STATIC_OVL void
wr_dungeon(void)
{
  wr_u16b(player->depth);
  wr_u16b(daycount);
  wr_u16b(player->grid.y);
  wr_u16b(player->grid.x);
  wr_byte(SQUARE_SIZE);
  if (player->is_dead) return;
  wr_dungeon_aux(cave);
  wr_dungeon_aux(player->cave);
  compact_monsters(cave, 0);
}
STATIC_OVL void
wr_objects(void)
{
  wr_objects_aux(cave);
  wr_objects_aux(player->cave);
}
STATIC_OVL void
wr_monsters(void)
{
  wr_monsters_aux(cave);
  wr_monsters_aux(player->cave);
}
STATIC_OVL void
wr_traps(void)
{
  wr_traps_aux(cave);
  wr_traps_aux(player->cave);
}
STATIC_OVL void
wr_history(void)
{
  size_t i, j;
  struct history_info* history_list;
  uint32_t length = history_get_list(player, &history_list);
  wr_byte(HIST_SIZE);
  wr_u32b(length);
  for (i = 0; i < length; i++) {
    for (j = 0; j < HIST_SIZE; j++) wr_byte(history_list[i].type[j]);
    wr_s32b(history_list[i].turn);
    wr_s16b(history_list[i].dlev);
    if (history_list[i].a_idx) {
      wr_string(a_info[history_list[i].a_idx].name);
    } else {
      wr_string("");
    }
    wr_string(history_list[i].event);
  }
}
STATIC_OVL void
wr_monster_groups(void)
{
  uint16_t i;
  for (i = 1; i < z_info->level_monster_max; i++) {
    if (cave->monster_groups[i]) {
      struct monster_group* group = cave->monster_groups[i];
      wr_u16b(i);
      wr_byte(group->flow.centre.x);
      wr_byte(group->flow.centre.y);
      wr_s16b(group->wandering_pause);
    }
  }
  wr_u16b(0);
}
STATIC_OVL void
note(const char* message)
{
  event_signal_message(EVENT_INITSTATUS, MSG_BIRTH, message);
}
STATIC_OVL void
sf_put(uint8_t v)
{
  assert(buffer != NULL);
  assert(buffer_size > 0);
  if (buffer_size == buffer_pos) {
    buffer_size += 1024;
    buffer = mem_realloc(buffer, buffer_size);
  }
  assert(buffer_pos < buffer_size);
  buffer[buffer_pos++] = v;
  buffer_check += v;
}
STATIC_OVL uint8_t
sf_get(void)
{
  if ((buffer == NULL) || (buffer_size <= 0) || (buffer_pos >= buffer_size))
    quit("Broken savefile - probably from a development version");
  buffer_check += buffer[buffer_pos];
  return buffer[buffer_pos++];
}
STATIC_OVL void
wr_byte(uint8_t v)
{
  sf_put(v);
}
STATIC_OVL void
wr_u16b(uint16_t v)
{
  sf_put((uint8_t)(v & 0xFF));
  sf_put((uint8_t)((v >> 8) & 0xFF));
}
STATIC_OVL void
wr_s16b(int16_t v)
{
  wr_u16b((uint16_t)v);
}
STATIC_OVL void
wr_u32b(uint32_t v)
{
  sf_put((uint8_t)(v & 0xFF));
  sf_put((uint8_t)((v >> 8) & 0xFF));
  sf_put((uint8_t)((v >> 16) & 0xFF));
  sf_put((uint8_t)((v >> 24) & 0xFF));
}
STATIC_OVL void
wr_s32b(int32_t v)
{
  wr_u32b((uint32_t)v);
}
STATIC_OVL void
wr_string(const char* str)
{
  while (*str) {
    wr_byte(*str);
    str++;
  }
  wr_byte(*str);
}
STATIC_OVL void
rd_byte(uint8_t* ip)
{
  *ip = sf_get();
}
STATIC_OVL void
rd_u16b(uint16_t* ip)
{
  (*ip) = sf_get();
  (*ip) |= ((uint16_t)(sf_get()) << 8);
}
STATIC_OVL void
rd_s16b(int16_t* ip)
{
  rd_u16b((uint16_t*)ip);
}
STATIC_OVL void
rd_u32b(uint32_t* ip)
{
  (*ip) = sf_get();
  (*ip) |= ((uint32_t)(sf_get()) << 8);
  (*ip) |= ((uint32_t)(sf_get()) << 16);
  (*ip) |= ((uint32_t)(sf_get()) << 24);
}
STATIC_OVL void
rd_s32b(int32_t* ip)
{
  rd_u32b((uint32_t*)ip);
}
STATIC_OVL void
rd_string(char* str, int max)
{
  uint8_t tmp8u;
  int i = 0;
  do {
    rd_byte(&tmp8u);
    if (i < max) str[i] = tmp8u;
    if (!tmp8u) break;
  } while (++i);
  str[max - 1] = '\0';
}
STATIC_OVL void
strip_bytes(int n)
{
  uint8_t tmp8u;
  while (n--) rd_byte(&tmp8u);
}
STATIC_OVL void
pad_bytes(int n)
{
  while (n--) wr_byte(0);
}
STATIC_OVL bool
try_save(ang_file* file)
{
  uint8_t savefile_head[28];
  size_t i, pos;
  bool success = true;
  buffer = mem_alloc(1024);
  buffer_size = 1024;
  for (i = 0; i < N_ELEMENTS(savers); i++) {
    buffer_pos = 0;
    buffer_check = 0;
    savers[i].save();
    pos = my_strcpy((char*)savefile_head, savers[i].name, sizeof savefile_head);
    while (pos < 16) savefile_head[pos++] = 0;
    savefile_head[pos++] = (savers[i].version & 0xFF);
    savefile_head[pos++] = ((savers[i].version >> 8) & 0xFF);
    savefile_head[pos++] = ((savers[i].version >> 16) & 0xFF);
    savefile_head[pos++] = ((savers[i].version >> 24) & 0xFF);
    ;
    savefile_head[pos++] = (buffer_pos & 0xFF);
    savefile_head[pos++] = ((buffer_pos >> 8) & 0xFF);
    savefile_head[pos++] = ((buffer_pos >> 16) & 0xFF);
    savefile_head[pos++] = ((buffer_pos >> 24) & 0xFF);
    ;
    savefile_head[pos++] = (buffer_check & 0xFF);
    savefile_head[pos++] = ((buffer_check >> 8) & 0xFF);
    savefile_head[pos++] = ((buffer_check >> 16) & 0xFF);
    savefile_head[pos++] = ((buffer_check >> 24) & 0xFF);
    ;
    assert(pos == 28);
    if (!file_write(file, (char*)savefile_head, 28)) {
      success = false;
    }
    if (!file_write(file, (char*)buffer, buffer_pos)) {
      success = false;
    }
    if (buffer_pos % 4) {
      if (!file_write(file, "xxx", 4 - (buffer_pos % 4))) {
        success = false;
      }
    }
  }
  mem_free(buffer);
  return success;
}
STATIC_OVL bool
savefile_save(const char* path)
{
  ang_file* file;
  int count = 0;
  char new_savefile[1024];
  char old_savefile[1024];
  (void)save_charoutput();
  safe_setuid_grab();
  strnfmt(old_savefile, sizeof(old_savefile), "%s%u.old", path,
          Rand_simple(1000000));
  while (file_exists(old_savefile) && (count++ < 100))
    strnfmt(old_savefile, sizeof(old_savefile), "%s%u%u.old", path,
            Rand_simple(1000000), count);
  count = 0;
  strnfmt(new_savefile, sizeof(new_savefile), "%s%u.new", path,
          Rand_simple(1000000));
  while (file_exists(new_savefile) && (count++ < 100))
    strnfmt(new_savefile, sizeof(new_savefile), "%s%u%u.new", path,
            Rand_simple(1000000), count);
  file = file_open(new_savefile, MODE_WRITE, FTYPE_SAVE);
  safe_setuid_drop();
  if (file) {
    if (file_write(file, (char*)&savefile_magic, 4) &&
        file_write(file, (char*)&savefile_name, 4)) {
      character_saved = try_save(file);
    } else {
      character_saved = false;
    }
    file_close(file);
  } else {
    character_saved = false;
  }
  if (character_saved) {
    bool err = false;
    safe_setuid_grab();
    if (file_exists(path) && !file_move(path, old_savefile)) err = true;
    if (!err) {
      if (!file_move(new_savefile, path)) err = true;
      if (err)
        file_move(old_savefile, path);
      else
        file_delete(old_savefile);
    }
    safe_setuid_drop();
    return err ? false : true;
  }
  if (file) {
    safe_setuid_grab();
    file_delete(new_savefile);
    safe_setuid_drop();
  }
  return false;
}
STATIC_OVL bool
check_header(ang_file* f)
{
  uint8_t head[8];
  if (file_read(f, (char*)&head, 8) == 8 &&
      memcmp(&head[0], savefile_magic, 4) == 0 &&
      memcmp(&head[4], savefile_name, 4) == 0)
    return true;
  return false;
}
STATIC_OVL errr
next_blockheader(ang_file* f, struct blockheader* b)
{
  uint8_t savefile_head[28];
  size_t len;
  len = file_read(f, (char*)savefile_head, 28);
  if (len == 0) return 1;
  if (len != 28 || savefile_head[15] != 0) {
    return -1;
  }
  my_strcpy(b->name, (char*)&savefile_head, sizeof b->name);
  b->version = ((uint32_t)savefile_head[16]) |
               ((uint32_t)savefile_head[16 + 1] << 8) |
               ((uint32_t)savefile_head[16 + 2] << 16) |
               ((uint32_t)savefile_head[16 + 3] << 24);
  ;
  b->size = ((uint32_t)savefile_head[20]) |
            ((uint32_t)savefile_head[20 + 1] << 8) |
            ((uint32_t)savefile_head[20 + 2] << 16) |
            ((uint32_t)savefile_head[20 + 3] << 24);
  ;
  if (b->size % 4) b->size += 4 - (b->size % 4);
  return 0;
}
STATIC_OVL loader_t
find_loader(struct blockheader* b, const struct blockinfo* local_loaders)
{
  size_t i = 0;
  for (i = 0; local_loaders[i].name[0]; i++) {
    if (!streq(b->name, local_loaders[i].name)) continue;
    if (b->version != local_loaders[i].version) continue;
    return local_loaders[i].loader;
  }
  return NULL;
}
STATIC_OVL bool
load_block(ang_file* f, struct blockheader* b, loader_t loader)
{
  buffer = mem_alloc(b->size);
  buffer_pos = 0;
  buffer_check = 0;
  buffer_size = file_read(f, (char*)buffer, b->size);
  if (buffer_size != b->size || loader() != 0) {
    mem_free(buffer);
    return false;
  }
  mem_free(buffer);
  return true;
}
STATIC_OVL void
skip_block(ang_file* f, struct blockheader* b)
{
  file_skip(f, b->size);
}
STATIC_OVL bool
try_load(ang_file* f, const struct blockinfo* local_loaders)
{
  struct blockheader b;
  errr err;
  if (!check_header(f)) {
    note("Savefile is corrupted -- incorrect file header.");
    return false;
  }
  while ((err = next_blockheader(f, &b)) == 0) {
    loader_t loader = find_loader(&b, local_loaders);
    if (!loader) {
      note("Savefile block can't be read.");
      note("Maybe try and load the savefile in an earlier version of Angband.");
      return false;
    }
    if (!load_block(f, &b, loader)) {
      note(format("Savefile corrupted - Couldn't load block %s", b.name));
      return false;
    }
  }
  if (err == -1) {
    note("Savefile is corrupted -- block header mangled.");
    return false;
  }
  return true;
}
STATIC_OVL int
get_desc(void)
{
  rd_string(savefile_desc, sizeof savefile_desc);
  return 0;
}
STATIC_OVL const char*
savefile_get_description(const char* path)
{
  struct blockheader b;
  ang_file* f;
  safe_setuid_grab();
  f = file_open(path, MODE_READ, FTYPE_TEXT);
  safe_setuid_drop();
  if (!f) return NULL;
  savefile_desc[0] = 0;
  if (!check_header(f)) {
    my_strcpy(savefile_desc, "Invalid savefile", sizeof savefile_desc);
  } else {
    while (!next_blockheader(f, &b)) {
      if (!streq(b.name, "description")) {
        skip_block(f, &b);
        continue;
      }
      load_block(f, &b, get_desc);
      break;
    }
  }
  file_close(f);
  return savefile_desc;
}
STATIC_OVL bool
savefile_load(const char* path, bool cheat_death)
{
  bool ok;
  ang_file* f;
  safe_setuid_grab();
  f = file_open(path, MODE_READ, FTYPE_TEXT);
  safe_setuid_drop();
  if (!f) {
    note("Couldn't open savefile.");
    return false;
  }
  ok = try_load(f, loaders);
  file_close(f);
  if (player->chp < 0) {
    player->is_dead = true;
  }
  if (player->is_dead && cheat_death) {
    player->is_dead = false;
    player->chp = player->mhp;
    player->noscore |= NOSCORE_WIZARD;
  }
  character_generated = true;
  player->upkeep->playing = true;
  return ok;
}
STATIC_OVL void
savefile_get_panic_name(char* buf, size_t len, const char* path)
{
  size_t name_offset = path_filename_index(path);
  size_t used = path_build(buf, len, ANGBAND_DIR_PANIC, path + name_offset);
  if (len > 0 && (used == 0 || !suffix(buf, path + name_offset))) {
    buf[0] = '\0';
  }
}
STATIC_OVL bool
save_charoutput(void)
{
  char path[1024];
  ang_file* fo;
  bool written = true;
  path_build(path, sizeof(path), ANGBAND_DIR_USER, "CharOutput.txt");
  fo = file_open(path, MODE_WRITE, FTYPE_TEXT);
  if (fo) {
    if (!file_put(fo, "{\n")) written = false;
    if (!file_putf(fo, "race: \"%s\",\n", player->race->name)) written = false;
    if (!file_putf(fo, "house: \"%s\",\n", player->house->name))
      written = false;
    if (!file_put(fo, "mapName: \"Angband\",\n")) written = false;
    if (!file_putf(fo, "dLvl: \"%i\",\n", player->depth)) written = false;
    if (!file_putf(fo, "isDead: \"%i\",\n", (player->is_dead) ? 1 : 0))
      written = false;
    if (!file_putf(fo, "killedBy: \"%s\"\n", player->died_from))
      written = false;
    if (!file_put(fo, "}")) written = false;
    if (!file_close(fo)) written = false;
  } else {
    written = false;
  }
  return written;
}
STATIC_OVL enum parser_error
parse_song_name(struct parser* p)
{
  const char* name = parser_getstr(p, "name");
  struct song* h = parser_priv(p);
  struct song* s = mem_zalloc(sizeof *s);
  s->next = h;
  s->name = string_make(name);
  parser_setpriv(p, s);
  s->index = song_index;
  song_index++;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_song_verb(struct parser* p)
{
  struct song* s = parser_priv(p);
  assert(s);
  s->verb = string_append(s->verb, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_song_desc(struct parser* p)
{
  struct song* s = parser_priv(p);
  assert(s);
  s->desc = string_append(s->desc, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_song_alt_desc(struct parser* p)
{
  struct song* s = parser_priv(p);
  struct alt_song_desc* alt = mem_zalloc(sizeof(*alt));
  assert(s);
  alt->next = s->alt_desc;
  s->alt_desc = alt;
  alt->desc = string_make(parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_song_msg(struct parser* p)
{
  struct song* s = parser_priv(p);
  assert(s);
  s->msg = string_append(s->msg, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_song_bonus_mult(struct parser* p)
{
  struct song* s = parser_priv(p);
  if (!s) return PARSE_ERROR_MISSING_RECORD_HEADER;
  s->bonus_mult = parser_getint(p, "mult");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_song_bonus_div(struct parser* p)
{
  struct song* s = parser_priv(p);
  if (!s) return PARSE_ERROR_MISSING_RECORD_HEADER;
  s->bonus_div = parser_getint(p, "div");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_song_bonus_min(struct parser* p)
{
  struct song* s = parser_priv(p);
  if (!s) return PARSE_ERROR_MISSING_RECORD_HEADER;
  s->bonus_min = parser_getint(p, "min");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_song_noise(struct parser* p)
{
  struct song* s = parser_priv(p);
  if (!s) return PARSE_ERROR_MISSING_RECORD_HEADER;
  s->noise = parser_getint(p, "noise");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_song_extend(struct parser* p)
{
  struct song* s = parser_priv(p);
  if (!s) return PARSE_ERROR_MISSING_RECORD_HEADER;
  s->extend = parser_getint(p, "extend") ? true : false;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_song_effect(struct parser* p)
{
  struct song* s = parser_priv(p);
  struct effect* new_effect = mem_zalloc(sizeof(*new_effect));
  if (!s) return PARSE_ERROR_MISSING_RECORD_HEADER;
  s->effect = new_effect;
  return grab_effect_data(p, new_effect);
}
STATIC_OVL struct parser*
init_parse_song(void)
{
  struct parser* p = parser_new();
  parser_setpriv(p, NULL);
  parser_reg(p, "name str name", parse_song_name);
  parser_reg(p, "verb str text", parse_song_verb);
  parser_reg(p, "desc str text", parse_song_desc);
  parser_reg(p, "alt-desc str text", parse_song_alt_desc);
  parser_reg(p, "msg str text", parse_song_msg);
  parser_reg(p, "bonus-mult int mult", parse_song_bonus_mult);
  parser_reg(p, "bonus-div int div", parse_song_bonus_div);
  parser_reg(p, "bonus-min int min", parse_song_bonus_min);
  parser_reg(p, "noise int noise", parse_song_noise);
  parser_reg(p, "extend int extend", parse_song_extend);
  parser_reg(p, "effect sym eff ?sym type ?int radius ?int other",
             parse_song_effect);
  return p;
}
STATIC_OVL errr
run_parse_song(struct parser* p)
{
  return parse_file_quit_not_found(p, "song");
}
STATIC_OVL errr
finish_parse_song(struct parser* p)
{
  songs = parser_priv(p);
  parser_destroy(p);
  return 0;
}
STATIC_OVL void
cleanup_song(void)
{
  struct song *s = songs, *next;
  while (s) {
    struct alt_song_desc* alt = s->alt_desc;
    next = s->next;
    while (alt) {
      struct alt_song_desc* alt_tgt = alt;
      alt = alt->next;
      string_free(alt_tgt->desc);
      mem_free(alt_tgt);
    }
    free_effect(s->effect);
    string_free(s->msg);
    string_free(s->desc);
    string_free(s->verb);
    string_free(s->name);
    mem_free(s);
    s = next;
  }
}
STATIC_OVL struct song*
song_by_idx(int idx)
{
  struct song* s = songs;
  while (s) {
    if (s->index == idx) return s;
    s = s->next;
  }
  return NULL;
}
STATIC_OVL struct song*
lookup_song(const char* name)
{
  struct song* s = songs;
  while (s) {
    if (streq(s->name, name)) return s;
    s = s->next;
  }
  return NULL;
}
STATIC_OVL int
song_bonus(struct player* p, int pskill, struct song* song)
{
  int skill = MAX(pskill, 0);
  int bonus;
  if (!song) return 0;
  if (p->song[SONG_MAIN] != song) {
    skill /= 2;
    if (p->song[SONG_MINOR] != song) {
      return 0;
    }
  }
  bonus = skill * song->bonus_mult;
  bonus /= song->bonus_div;
  bonus = MAX(bonus, song->bonus_min);
  if (streq(song->name, "Slaying")) {
    bonus *= p->wrath;
    bonus += 999;
    bonus /= 1000;
  }
  return bonus;
}
STATIC_OVL void
player_change_song(struct player* p, struct song* song, bool exchange)
{
  int song_to_change;
  if (player_active_ability(p, "Woven Themes") && p->song[SONG_MAIN] && song) {
    song_to_change = SONG_MINOR;
  } else {
    song_to_change = SONG_MAIN;
  }
  if (p->song[SONG_MAIN] == song) {
    if (!p->song[SONG_MINOR]) {
      song = NULL;
    } else if (song) {
      msg("You were already singing that.");
      return;
    }
  } else if ((p->song[SONG_MINOR] == song) && (song_to_change == SONG_MINOR)) {
    msg("You are already using that minor theme.");
    return;
  }
  p->upkeep->redraw |= (PR_SONG);
  p->upkeep->update |= (PU_BONUS);
  if (exchange) {
    struct song* temp = p->song[SONG_MAIN];
    p->song[SONG_MAIN] = p->song[SONG_MINOR];
    p->song[SONG_MINOR] = temp;
    msg("You change the order of your themes.");
    p->upkeep->energy_use = z_info->move_energy;
    p->previous_action[0] = ACTION_MISC;
    return;
  }
  if (song_to_change == SONG_MAIN) {
    p->song_duration = 0;
  }
  if (!song) {
    if ((song_to_change == SONG_MAIN) && p->song[SONG_MAIN]) {
      msg("You end your song.");
    } else if ((song_to_change == SONG_MINOR) && p->song[SONG_MINOR]) {
      msg("You end your minor theme.");
    }
  } else if (song_to_change == SONG_MAIN) {
    msg("You %s song %s.", song->verb, song->desc);
  } else if (p->song[SONG_MINOR]) {
    msg("You change you minor theme to one %s.", song->desc);
  } else {
    msg("You add a minor theme %s.", song->desc);
  }
  if (song && song->msg) {
    msg(song->msg);
  }
  if (song_to_change == SONG_MAIN) {
    p->song[SONG_MAIN] = song;
  } else if (song) {
    p->song[SONG_MINOR] = song;
  }
  if (song) {
    p->upkeep->energy_use = z_info->move_energy;
    p->previous_action[0] = ACTION_MISC;
  }
}
STATIC_OVL bool
player_is_singing(struct player* p, struct song* song)
{
  if (p->song[SONG_MAIN] == song) return true;
  if (song && (p->song[SONG_MINOR] == song)) return true;
  return false;
}
STATIC_OVL int
player_song_noise(struct player* p)
{
  struct song* song = p->song[SONG_MAIN];
  if (!song) return 0;
  if (!p->song[SONG_MINOR]) return song->noise;
  return (song->noise + p->song[SONG_MINOR]->noise) / 2;
}
STATIC_OVL void
player_sing(struct player* p)
{
  int i;
  int cost = 0;
  struct song* smain = p->song[SONG_MAIN];
  struct song* minor = p->song[SONG_MINOR];
  if (!p->song[SONG_MAIN]) return;
  if ((p->csp < 1) ||
      (p->song[SONG_MINOR] && !player_active_ability(p, "Woven Themes")) ||
      (!player_active_ability(p, format("Song of %s", smain->name))) ||
      (p->song[SONG_MINOR] &&
       !player_active_ability(p, format("Song of %s", minor->name)))) {
    player_change_song(p, NULL, false);
    disturb(p, false);
    return;
  } else {
    p->song_duration++;
  }
  for (i = 0; i < SONG_MAX; i++) {
    struct song* song = p->song[i];
    if (!song) continue;
    if (!song->extend || ((p->song_duration % 3) == i)) {
      cost++;
    }
    if (song->effect) {
      bool dummy = false;
      effect_do(song->effect, source_player(), NULL, &dummy, true, DIR_NONE,
                NULL);
    }
  }
  p->csp -= MIN(cost, p->csp);
  p->upkeep->redraw |= (PR_MANA);
}
STATIC_OVL int
monster_sing(struct monster* mon, struct song* song)
{
  char m_name[80];
  char* description;
  struct song* silence = lookup_song("Silence");
  int song_skill = mon->race->song;
  int dist = flow_dist(cave->player_noise, mon->grid);
  monster_desc(m_name, sizeof(m_name), mon, MDESC_SHOW);
  if ((mon->song != song) && monster_is_visible(mon)) {
    msg("%s begins a song of %s.", m_name, song->desc);
    disturb(player, true);
  } else {
    int pick = randint0(8);
    struct alt_song_desc* alt_desc = song->alt_desc;
    description = alt_desc->desc;
    while (pick) {
      alt_desc = alt_desc->next;
      if (!alt_desc) {
        description = song->desc;
        break;
      }
      description = alt_desc->desc;
      pick--;
    }
    if (monster_is_visible(mon)) {
      msg("%s sings of %s.", m_name, description);
      disturb(player, true);
    } else if (dist <= 20) {
      msg("You hear a song of %s.", description);
      disturb(player, true);
    } else if (dist <= 20) {
      msg("You hear singing in the distance.");
      disturb(player, true);
    }
  }
  mon->song = song;
  if (player_is_singing(player, silence)) {
    song_skill -=
        song_bonus(player, player->state.skill_use[SKILL_SONG], silence) / 2;
  }
  return song_skill;
}
STATIC_OVL void
load_sound(struct sound_data* sound_data)
{
  if ((hooks.load_sound_hook) && (hooks.supported_files_hook)) {
    char path[2048];
    char* filename_buf;
    size_t filename_buf_size;
    int i = 0;
    bool load_success = false;
    const struct sound_file_type* supported_sound_files =
        hooks.supported_files_hook();
    path_build(path, sizeof(path), ANGBAND_DIR_SOUNDS, sound_data->name);
    while ((0 != supported_sound_files[i].type) && (!load_success)) {
      filename_buf_size =
          strlen(path) + strlen(supported_sound_files[i].extension) + 1;
      filename_buf = mem_zalloc(filename_buf_size);
      my_strcpy(filename_buf, path, filename_buf_size);
      filename_buf =
          string_append(filename_buf, supported_sound_files[i].extension);
      if (file_exists(filename_buf)) {
        sound_data->status = SOUND_ST_ERROR;
        load_success = hooks.load_sound_hook(
            filename_buf, supported_sound_files[i].type, sound_data);
      }
      mem_free(filename_buf);
      i++;
    }
    if (!load_success) plog_fmt("Failed to load sound '%s'", sound_data->name);
  }
}
STATIC_OVL errr
register_sound_pref_parser(struct parser* p)
{
  return parser_reg(p, SOUND_PRF_FORMAT, parse_prefs_dummy);
}
STATIC_OVL void
play_sound(game_event_type type, game_event_data* data, void* user)
{
  int s, sound_id;
  if (hooks.play_sound_hook) {
    assert(data->message.type >= 0);
    if (!message_sounds[data->message.type].num_sounds) return;
    s = randint0(message_sounds[data->message.type].num_sounds);
    sound_id = message_sounds[data->message.type].sound_ids[s];
    assert((sound_id >= 0) && (sound_id < next_sound_id));
    if (sounds[sound_id].status == SOUND_ST_UNKNOWN)
      load_sound(&sounds[sound_id]);
    if (sounds[sound_id].status == SOUND_ST_LOADED)
      hooks.play_sound_hook(&sounds[sound_id]);
  }
}
STATIC_OVL bool
set_preloaded_sounds(bool new_setting)
{
  bool old_setting = preload_sounds;
  preload_sounds = new_setting;
  return old_setting;
}
STATIC_OVL errr
init_sound(const char* soundstr, int argc, char** argv)
{
  int i = 0;
  bool done = false;
  close_sound();
  while (sound_modules[i].init && !done) {
    if (!soundstr || streq(soundstr, sound_modules[i].name))
      if (0 == sound_modules[i].init(&hooks, argc, argv)) done = true;
    i++;
  }
  if (!done) return 1;
  if (!hooks.open_audio_hook) return 1;
  if (!hooks.open_audio_hook()) return 1;
  event_add_handler(EVENT_SOUND, play_sound, NULL);
  return (0);
}
STATIC_OVL void
close_sound(void)
{
  if (0 == next_sound_id) return;
  if (hooks.unload_sound_hook) {
    int i;
    for (i = 0; i < next_sound_id; i++) {
      hooks.unload_sound_hook(&sounds[i]);
      string_free(sounds[i].name);
    }
  }
  mem_free(sounds);
  sounds = NULL;
  next_sound_id = 0;
  if (hooks.close_audio_hook) {
    hooks.close_audio_hook();
  }
}
STATIC_OVL void
print_sound_help(void)
{
  int i;
  for (i = 0; i < (int)N_ELEMENTS(sound_modules); i++)
    printf("     %s   %s\n", sound_modules[i].name, sound_modules[i].help);
}
STATIC_OVL struct source
source_none(void)
{
  struct source src;
  src.what = SRC_NONE;
  return src;
}
STATIC_OVL struct source
source_trap(struct trap* trap)
{
  struct source src;
  src.what = SRC_TRAP;
  src.which.trap = trap;
  return src;
}
STATIC_OVL struct source
source_monster(int who)
{
  struct source src;
  src.what = SRC_MONSTER;
  src.which.monster = who;
  return src;
}
STATIC_OVL struct source
source_player(void)
{
  struct source src;
  src.what = SRC_PLAYER;
  return src;
}
STATIC_OVL struct source
source_object(struct object* object)
{
  struct source src;
  src.what = SRC_OBJECT;
  src.which.object = object;
  return src;
}
STATIC_OVL struct source
source_chest_trap(struct chest_trap* chest_trap)
{
  struct source src;
  src.what = SRC_CHEST_TRAP;
  src.which.chest_trap = chest_trap;
  return src;
}
STATIC_OVL struct source
source_grid(struct loc grid)
{
  struct source src;
  src.what = SRC_GRID;
  src.which.grid = grid;
  return src;
}
STATIC_OVL void
look_mon_desc(char* buf, size_t max, int m_idx)
{
  struct monster* mon = cave_monster(cave, m_idx);
  if (!mon) return;
  my_strcpy(buf, " (", max);
  if (player->wizard) {
    if (mon->alertness < ALERTNESS_UNWARY) {
      my_strcat(buf, format("asleep (%d), ", mon->alertness), max);
    } else if (mon->alertness < ALERTNESS_ALERT) {
      my_strcat(buf, format("unwary (%d), ", mon->alertness), max);
    } else {
      my_strcat(buf, format("alert (%d), ", mon->alertness), max);
    }
  }
  if (mon->m_timed[MON_TMD_CONF]) my_strcat(buf, "confused, ", max);
  if (mon->m_timed[MON_TMD_STUN]) my_strcat(buf, "stunned, ", max);
  if (mon->m_timed[MON_TMD_SLOW]) my_strcat(buf, "slowed, ", max);
  if (mon->m_timed[MON_TMD_FAST]) my_strcat(buf, "hasted, ", max);
  if (strlen(buf) == 2) {
    buf[0] = '\0';
  } else {
    buf[strlen(buf) - 2] = '\0';
    my_strcat(buf, ") ", max);
  }
}
STATIC_OVL bool
target_able(struct monster* m)
{
  bool rage_visible = player->is_dead || !player->timed[TMD_RAGE] ||
                      (m && m->race && square_isseen(cave, m->grid));
  return m && m->race && monster_is_visible(m) &&
         projectable(cave, player->grid, m->grid, PROJECT_NONE) &&
         !player->timed[TMD_IMAGE] && rage_visible;
}
STATIC_OVL bool
target_okay(int range)
{
  if (!target_set) return false;
  if (target.midx > 0) {
    struct monster* mon = cave_monster(cave, target.midx);
    if (target_able(mon)) {
      target.grid = mon->grid;
      if (range && (distance(player->grid, target.grid) > range)) {
        return false;
      }
      return true;
    }
  } else if (target.grid.x && target.grid.y) {
    if (range && (distance(player->grid, target.grid) > range)) return false;
    if (square_isfire(cave, target.grid)) return true;
    if (square_iswall(cave, target.grid)) return true;
  }
  return false;
}
STATIC_OVL bool
target_set_monster(struct monster* mon)
{
  if (mon && target_able(mon)) {
    target_set = true;
    target.midx = mon->midx;
    target.grid = mon->grid;
    return true;
  } else if (target_fixed) {
    target.midx = 0;
    return true;
  }
  target_set = false;
  target.midx = 0;
  target.grid.y = 0;
  target.grid.x = 0;
  return false;
}
STATIC_OVL void
target_set_location(struct loc grid)
{
  if (square_in_bounds_fully(cave, grid)) {
    target_set = true;
    target.midx = 0;
    target.grid = grid;
    return;
  }
  target_set = false;
  target.midx = 0;
  target.grid.y = 0;
  target.grid.x = 0;
}
STATIC_OVL bool
target_is_set(void)
{
  return target_set;
}
STATIC_OVL void
target_fix(void)
{
  old_target = target;
  target_fixed = true;
}
STATIC_OVL void
target_release(void)
{
  target_fixed = false;
  if (old_target.midx != 0) {
    struct monster* mon = cave_monster(cave, old_target.midx);
    if (!mon || !mon->race || !monster_is_in_view(mon)) {
      target.grid.y = 0;
      target.grid.x = 0;
    }
  }
}
STATIC_OVL int
cmp_distance(const void* a, const void* b)
{
  int py = player->grid.y;
  int px = player->grid.x;
  const struct loc* pa = a;
  const struct loc* pb = b;
  int da, db, kx, ky;
  kx = pa->x;
  kx -= px;
  kx = ABS(kx);
  ky = pa->y;
  ky -= py;
  ky = ABS(ky);
  da = ((kx > ky) ? (kx + kx + ky) : (ky + ky + kx));
  kx = pb->x;
  kx -= px;
  kx = ABS(kx);
  ky = pb->y;
  ky -= py;
  ky = ABS(ky);
  db = ((kx > ky) ? (kx + kx + ky) : (ky + ky + kx));
  if (da < db) return -1;
  if (da > db) return 1;
  return 0;
}
STATIC_OVL int16_t
target_pick(int y1, int x1, int dy, int dx, struct point_set* targets)
{
  int i, v;
  int x2, y2, x3, y3, x4, y4;
  int b_i = -1, b_v = 9999;
  for (i = 0; i < point_set_size(targets); i++) {
    x2 = targets->pts[i].x;
    y2 = targets->pts[i].y;
    x3 = (x2 - x1);
    y3 = (y2 - y1);
    if (dx && (x3 * dx <= 0)) continue;
    if (dy && (y3 * dy <= 0)) continue;
    x4 = ABS(x3);
    y4 = ABS(y3);
    if (dy && !dx && (x4 > y4)) continue;
    if (dx && !dy && (y4 > x4)) continue;
    v = ((x4 > y4) ? (x4 + x4 + y4) : (y4 + y4 + x4));
    if ((b_i >= 0) && (v >= b_v)) continue;
    b_i = i;
    b_v = v;
  }
  return (b_i);
}
STATIC_OVL bool
target_accept(struct loc grid)
{
  struct object* obj;
  if (square(cave, grid)->mon < 0) return true;
  if (player->timed[TMD_IMAGE]) return false;
  if (square(cave, grid)->mon > 0) {
    struct monster* mon = square_monster(cave, grid);
    if (monster_is_visible(mon)) {
      return true;
    }
  }
  if (square_isvisibletrap(player->cave, grid)) return true;
  for (obj = square_object(player->cave, grid); obj; obj = obj->next) {
    if (obj->kind == unknown_item_kind || !ignore_known_item_ok(player, obj)) {
      return true;
    }
  }
  if (square_isknown(cave, grid) && square_isinteresting(player->cave, grid)) {
    return true;
  }
  return false;
}
STATIC_OVL void
coords_desc(char* buf, int size, struct loc grid)
{
  const char* east_or_west;
  const char* north_or_south;
  if (grid.y > player->grid.y)
    north_or_south = "S";
  else
    north_or_south = "N";
  if (grid.x < player->grid.x)
    east_or_west = "W";
  else
    east_or_west = "E";
  strnfmt(buf, size, "%d %s, %d %s", ABS(grid.y - player->grid.y),
          north_or_south, ABS(grid.x - player->grid.x), east_or_west);
}
STATIC_OVL void
target_get(struct loc* grid)
{
  assert(grid);
  *grid = target.grid;
}
STATIC_OVL struct monster*
target_get_monster(void)
{
  return cave_monster(cave, target.midx);
}
STATIC_OVL bool
target_sighted(void)
{
  return target_okay(z_info->max_sight) &&
         panel_contains(target.grid.y, target.grid.x) &&
         ((!target.midx && square_isseen(cave, target.grid)) ||
          (target.midx && monster_is_visible(cave_monster(cave, target.midx))));
}
STATIC_OVL struct point_set*
target_get_monsters(int mode, monster_predicate pred, bool restrict_to_panel)
{
  struct loc grid;
  int min_y, min_x, max_y, max_x;
  struct point_set* targets = point_set_new(20);
  if (restrict_to_panel) {
    get_panel(&min_y, &min_x, &max_y, &max_x);
  } else {
    min_y = player->grid.y - z_info->max_range;
    max_y = player->grid.y + z_info->max_range + 1;
    min_x = player->grid.x - z_info->max_range;
    max_x = player->grid.x + z_info->max_range + 1;
  }
  for (grid.y = min_y; grid.y < max_y; grid.y++) {
    for (grid.x = min_x; grid.x < max_x; grid.x++) {
      if (!square_in_bounds_fully(cave, grid)) continue;
      if (!target_accept(grid)) continue;
      if (mode & (TARGET_KILL)) {
        struct monster* mon = square_monster(cave, grid);
        if (mon == NULL) continue;
        if (!target_able(mon)) continue;
        if (pred && !pred(mon)) continue;
      }
      add_to_point_set(targets, grid);
    }
  }
  sort(targets->pts, point_set_size(targets), sizeof(*(targets->pts)),
       cmp_distance);
  return targets;
}
STATIC_OVL bool
target_set_closest(int mode, monster_predicate pred)
{
  struct monster* mon;
  char m_name[80];
  struct point_set* targets;
  target_set_monster(NULL);
  targets = target_get_monsters(mode, pred, false);
  if (point_set_size(targets) < 1) {
    msg("No Available Target.");
    point_set_dispose(targets);
    return false;
  }
  mon = square_monster(cave, targets->pts[0]);
  if (!target_able(mon)) {
    msg("No Available Target.");
    point_set_dispose(targets);
    return false;
  }
  monster_desc(m_name, sizeof(m_name), mon, MDESC_CAPITAL | MDESC_COMMA);
  if (!(mode & TARGET_QUIET)) msg("%s is targeted.", m_name);
  monster_race_track(player->upkeep, mon->race);
  health_track(player->upkeep, mon);
  target_set_monster(mon);
  point_set_dispose(targets);
  return true;
}
STATIC_OVL enum parser_error
parse_trap_name(struct parser* p)
{
  const char* name = parser_getsym(p, "name");
  const char* desc = parser_getstr(p, "desc");
  struct trap_kind* h = parser_priv(p);
  struct trap_kind* t = mem_zalloc(sizeof *t);
  t->next = h;
  t->name = string_make(name);
  t->desc = string_make(desc);
  parser_setpriv(p, t);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_trap_graphics(struct parser* p)
{
  wchar_t glyph = parser_getchar(p, "glyph");
  const char* color = parser_getsym(p, "color");
  int attr = 0;
  struct trap_kind* t = parser_priv(p);
  if (!t) return PARSE_ERROR_MISSING_RECORD_HEADER;
  t->d_char = glyph;
  if (strlen(color) > 1)
    attr = color_text_to_attr(color);
  else
    attr = color_char_to_attr(color[0]);
  if (attr < 0) return PARSE_ERROR_INVALID_COLOR;
  t->d_attr = attr;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_trap_rarity(struct parser* p)
{
  struct trap_kind* t = parser_priv(p);
  if (!t) return PARSE_ERROR_MISSING_RECORD_HEADER;
  t->rarity = parser_getuint(p, "rarity");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_trap_min_depth(struct parser* p)
{
  struct trap_kind* t = parser_priv(p);
  if (!t) return PARSE_ERROR_MISSING_RECORD_HEADER;
  t->min_depth = parser_getuint(p, "mindepth");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_trap_max_depth(struct parser* p)
{
  struct trap_kind* t = parser_priv(p);
  if (!t) return PARSE_ERROR_MISSING_RECORD_HEADER;
  t->max_depth = parser_getuint(p, "maxdepth");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_trap_power(struct parser* p)
{
  struct trap_kind* t = parser_priv(p);
  int power = parser_getint(p, "power");
  if (!t) return PARSE_ERROR_MISSING_RECORD_HEADER;
  if (power < -1 || power > 254) {
    return PARSE_ERROR_INVALID_VALUE;
  }
  t->power = power;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_trap_stealth(struct parser* p)
{
  struct trap_kind* t = parser_priv(p);
  if (!t) return PARSE_ERROR_MISSING_RECORD_HEADER;
  t->stealth = parser_getint(p, "stealth");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_trap_flags(struct parser* p)
{
  char* flags;
  struct trap_kind* t = parser_priv(p);
  char* s;
  if (!t) return PARSE_ERROR_MISSING_RECORD_HEADER;
  if (!parser_hasval(p, "flags")) return PARSE_ERROR_NONE;
  flags = string_make(parser_getstr(p, "flags"));
  s = strtok(flags, " |");
  while (s) {
    if (grab_flag(t->flags, TRF_SIZE, trap_flags, s)) {
      break;
    }
    s = strtok(NULL, " |");
  }
  string_free(flags);
  return s ? PARSE_ERROR_INVALID_FLAG : PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_trap_effect(struct parser* p)
{
  struct trap_kind* t = parser_priv(p);
  struct effect *effect, *new_effect;
  if (!t) return PARSE_ERROR_MISSING_RECORD_HEADER;
  new_effect = mem_zalloc(sizeof(*new_effect));
  if (t->effect) {
    effect = t->effect;
    while (effect->next) effect = effect->next;
    effect->next = new_effect;
  } else
    t->effect = new_effect;
  return grab_effect_data(p, new_effect);
}
STATIC_OVL enum parser_error
parse_trap_dice(struct parser* p)
{
  struct trap_kind* t = parser_priv(p);
  struct effect* effect;
  dice_t* dice;
  const char* string;
  if (!t) return PARSE_ERROR_MISSING_RECORD_HEADER;
  effect = t->effect;
  if (effect == NULL) return PARSE_ERROR_NONE;
  while (effect->next) effect = effect->next;
  dice = dice_new();
  if (dice == NULL) return PARSE_ERROR_INVALID_DICE;
  string = parser_getstr(p, "dice");
  if (dice_parse_string(dice, string)) {
    dice_free(effect->dice);
    effect->dice = dice;
  } else {
    dice_free(dice);
    return PARSE_ERROR_INVALID_DICE;
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_trap_expr(struct parser* p)
{
  struct trap_kind* t = parser_priv(p);
  struct effect* effect;
  expression_t* expression;
  expression_base_value_f function;
  const char* name;
  const char* base;
  const char* expr;
  enum parser_error result;
  if (!t) return PARSE_ERROR_MISSING_RECORD_HEADER;
  effect = t->effect;
  if (effect == NULL) return PARSE_ERROR_NONE;
  while (effect->next) effect = effect->next;
  if (effect->dice == NULL) return PARSE_ERROR_NONE;
  name = parser_getsym(p, "name");
  base = parser_getsym(p, "base");
  expr = parser_getstr(p, "expr");
  expression = expression_new();
  if (expression == NULL) return PARSE_ERROR_INVALID_EXPRESSION;
  function = effect_value_base_by_name(base);
  expression_set_base_value(expression, function);
  if (expression_add_operations_string(expression, expr) < 0) {
    result = PARSE_ERROR_BAD_EXPRESSION_STRING;
  } else if (dice_bind_expression(effect->dice, name, expression) < 0) {
    result = PARSE_ERROR_UNBOUND_EXPRESSION;
  } else {
    result = PARSE_ERROR_NONE;
  }
  expression_free(expression);
  return result;
}
STATIC_OVL enum parser_error
parse_trap_effect_xtra(struct parser* p)
{
  struct trap_kind* t = parser_priv(p);
  struct effect *effect, *new_effect;
  if (!t) return PARSE_ERROR_MISSING_RECORD_HEADER;
  new_effect = mem_zalloc(sizeof(*new_effect));
  if (t->effect_xtra) {
    effect = t->effect_xtra;
    while (effect->next) effect = effect->next;
    effect->next = new_effect;
  } else
    t->effect_xtra = new_effect;
  return grab_effect_data(p, new_effect);
}
STATIC_OVL enum parser_error
parse_trap_dice_xtra(struct parser* p)
{
  struct trap_kind* t = parser_priv(p);
  struct effect* effect;
  dice_t* dice;
  const char* string;
  if (!t) return PARSE_ERROR_MISSING_RECORD_HEADER;
  effect = t->effect_xtra;
  if (effect == NULL) return PARSE_ERROR_NONE;
  while (effect->next) effect = effect->next;
  dice = dice_new();
  if (dice == NULL) return PARSE_ERROR_INVALID_DICE;
  string = parser_getstr(p, "dice");
  if (dice_parse_string(dice, string)) {
    dice_free(effect->dice);
    effect->dice = dice;
  } else {
    dice_free(dice);
    return PARSE_ERROR_INVALID_DICE;
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_trap_expr_xtra(struct parser* p)
{
  struct trap_kind* t = parser_priv(p);
  struct effect* effect;
  expression_t* expression;
  expression_base_value_f function;
  const char* name;
  const char* base;
  const char* expr;
  enum parser_error result;
  if (!t) return PARSE_ERROR_MISSING_RECORD_HEADER;
  effect = t->effect_xtra;
  if (effect == NULL) return PARSE_ERROR_NONE;
  while (effect->next) effect = effect->next;
  if (effect->dice == NULL) return PARSE_ERROR_NONE;
  name = parser_getsym(p, "name");
  base = parser_getsym(p, "base");
  expr = parser_getstr(p, "expr");
  expression = expression_new();
  if (expression == NULL) return PARSE_ERROR_INVALID_EXPRESSION;
  function = effect_value_base_by_name(base);
  expression_set_base_value(expression, function);
  if (expression_add_operations_string(expression, expr) < 0) {
    result = PARSE_ERROR_BAD_EXPRESSION_STRING;
  } else if (dice_bind_expression(effect->dice, name, expression) < 0) {
    result = PARSE_ERROR_UNBOUND_EXPRESSION;
  } else {
    result = PARSE_ERROR_NONE;
  }
  expression_free(expression);
  return result;
}
STATIC_OVL enum parser_error
parse_trap_desc(struct parser* p)
{
  struct trap_kind* t = parser_priv(p);
  if (!t) return PARSE_ERROR_MISSING_RECORD_HEADER;
  t->text = string_append(t->text, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_trap_msg(struct parser* p)
{
  struct trap_kind* t = parser_priv(p);
  if (!t) return PARSE_ERROR_MISSING_RECORD_HEADER;
  t->msg = string_append(t->msg, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_trap_msg2(struct parser* p)
{
  struct trap_kind* t = parser_priv(p);
  if (!t) return PARSE_ERROR_MISSING_RECORD_HEADER;
  t->msg2 = string_append(t->msg2, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_trap_msg3(struct parser* p)
{
  struct trap_kind* t = parser_priv(p);
  if (!t) return PARSE_ERROR_MISSING_RECORD_HEADER;
  t->msg3 = string_append(t->msg3, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_trap_msg_vis(struct parser* p)
{
  struct trap_kind* t = parser_priv(p);
  if (!t) return PARSE_ERROR_MISSING_RECORD_HEADER;
  t->msg_vis = string_append(t->msg_vis, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_trap_msg_silence(struct parser* p)
{
  struct trap_kind* t = parser_priv(p);
  if (!t) return PARSE_ERROR_MISSING_RECORD_HEADER;
  t->msg_silence = string_append(t->msg_silence, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_trap_msg_good(struct parser* p)
{
  struct trap_kind* t = parser_priv(p);
  if (!t) return PARSE_ERROR_MISSING_RECORD_HEADER;
  t->msg_good = string_append(t->msg_good, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_trap_msg_bad(struct parser* p)
{
  struct trap_kind* t = parser_priv(p);
  if (!t) return PARSE_ERROR_MISSING_RECORD_HEADER;
  t->msg_bad = string_append(t->msg_bad, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_trap_msg_xtra(struct parser* p)
{
  struct trap_kind* t = parser_priv(p);
  if (!t) return PARSE_ERROR_MISSING_RECORD_HEADER;
  t->msg_xtra = string_append(t->msg_xtra, parser_getstr(p, "text"));
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_parse_trap(void)
{
  struct parser* p = parser_new();
  parser_setpriv(p, NULL);
  parser_reg(p, "name sym name str desc", parse_trap_name);
  parser_reg(p, "graphics char glyph sym color", parse_trap_graphics);
  parser_reg(p, "rarity uint rarity", parse_trap_rarity);
  parser_reg(p, "min-depth uint mindepth", parse_trap_min_depth);
  parser_reg(p, "max-depth uint maxdepth", parse_trap_max_depth);
  parser_reg(p, "power int power", parse_trap_power);
  parser_reg(p, "stealth int stealth", parse_trap_stealth);
  parser_reg(p, "flags ?str flags", parse_trap_flags);
  parser_reg(p, "effect sym eff ?sym type ?int radius ?int other",
             parse_trap_effect);
  parser_reg(p, "dice str dice", parse_trap_dice);
  parser_reg(p, "expr sym name sym base str expr", parse_trap_expr);
  parser_reg(p, "effect-xtra sym eff ?sym type ?int radius ?int other",
             parse_trap_effect_xtra);
  parser_reg(p, "dice-xtra str dice", parse_trap_dice_xtra);
  parser_reg(p, "expr-xtra sym name sym base str expr", parse_trap_expr_xtra);
  parser_reg(p, "desc str text", parse_trap_desc);
  parser_reg(p, "msg str text", parse_trap_msg);
  parser_reg(p, "msg2 str text", parse_trap_msg2);
  parser_reg(p, "msg3 str text", parse_trap_msg3);
  parser_reg(p, "msg-vis str text", parse_trap_msg_vis);
  parser_reg(p, "msg-silence str text", parse_trap_msg_silence);
  parser_reg(p, "msg-good str text", parse_trap_msg_good);
  parser_reg(p, "msg-bad str text", parse_trap_msg_bad);
  parser_reg(p, "msg-xtra str text", parse_trap_msg_xtra);
  return p;
}
STATIC_OVL errr
run_parse_trap(struct parser* p)
{
  return parse_file_quit_not_found(p, "trap");
}
STATIC_OVL errr
finish_parse_trap(struct parser* p)
{
  struct trap_kind *t, *n;
  int tidx;
  z_info->trap_max = 0;
  t = parser_priv(p);
  while (t) {
    z_info->trap_max++;
    t = t->next;
  }
  trap_info = mem_zalloc((z_info->trap_max + 1) * sizeof(*t));
  tidx = z_info->trap_max - 1;
  for (t = parser_priv(p); t; t = t->next, tidx--) {
    assert(tidx >= 0);
    memcpy(&trap_info[tidx], t, sizeof(*t));
    trap_info[tidx].tidx = tidx;
    if (tidx < z_info->trap_max - 1)
      trap_info[tidx].next = &trap_info[tidx + 1];
    else
      trap_info[tidx].next = NULL;
  }
  t = parser_priv(p);
  while (t) {
    n = t->next;
    mem_free(t);
    t = n;
  }
  parser_destroy(p);
  return 0;
}
STATIC_OVL void
cleanup_trap(void)
{
  int i;
  for (i = 0; i < z_info->trap_max; i++) {
    string_free(trap_info[i].name);
    mem_free(trap_info[i].text);
    string_free(trap_info[i].desc);
    string_free(trap_info[i].msg);
    string_free(trap_info[i].msg2);
    string_free(trap_info[i].msg3);
    string_free(trap_info[i].msg_vis);
    string_free(trap_info[i].msg_silence);
    string_free(trap_info[i].msg_good);
    string_free(trap_info[i].msg_bad);
    string_free(trap_info[i].msg_xtra);
    free_effect(trap_info[i].effect);
    free_effect(trap_info[i].effect_xtra);
  }
  mem_free(trap_info);
}
STATIC_OVL struct trap_kind*
lookup_trap(const char* desc)
{
  int i;
  struct trap_kind* closest = NULL;
  for (i = 1; i < z_info->trap_max; i++) {
    struct trap_kind* kind = &trap_info[i];
    if (!kind->name) continue;
    if (streq(desc, kind->desc)) return kind;
    if (!closest && my_stristr(kind->desc, desc)) closest = kind;
  }
  return closest;
}
STATIC_OVL bool
square_trap_specific(struct chunk* c, struct loc grid, int t_idx)
{
  struct trap* trap = square_trap(c, grid);
  if (!square_istrap(c, grid)) return false;
  while (trap) {
    if (trap->t_idx == t_idx) return true;
    trap = trap->next;
  }
  return false;
}
STATIC_OVL bool
square_trap_flag(struct chunk* c, struct loc grid, int flag)
{
  struct trap* trap = square_trap(c, grid);
  if (!square_istrap(c, grid)) return false;
  while (trap) {
    if (trf_has(trap->flags, flag)) return true;
    trap = trap->next;
  }
  return false;
}
STATIC_OVL bool
square_verify_trap(struct chunk* c, struct loc grid, int vis)
{
  struct trap* trap = square_trap(c, grid);
  bool trap_exists = false;
  while (trap) {
    if (!vis) return true;
    if ((vis == 1) && trf_has(trap->flags, TRF_VISIBLE)) return true;
    if ((vis == -1) && !trf_has(trap->flags, TRF_VISIBLE)) return true;
    trap_exists = true;
  }
  if (!trap_exists) {
    sqinfo_off(square(c, grid)->info, SQUARE_TRAP);
    square_note_spot(c, grid);
  }
  return false;
}
STATIC_OVL void
square_free_trap(struct chunk* c, struct loc grid)
{
  struct trap *next, *trap = square_trap(c, grid);
  while (trap) {
    next = trap->next;
    mem_free(trap);
    trap = next;
  }
}
STATIC_OVL bool
square_remove_all_traps(struct chunk* c, struct loc grid)
{
  struct trap* trap = square(c, grid)->trap;
  bool were_there_traps = trap == NULL ? false : true;
  while (trap) {
    struct trap* next_trap = trap->next;
    mem_free(trap);
    trap = next_trap;
  }
  square_set_trap(c, grid, NULL);
  if (square_isseen(c, grid)) {
    square_memorize_traps(c, grid);
    square_light_spot(c, grid);
  }
  (void)square_verify_trap(c, grid, 0);
  return were_there_traps;
}
STATIC_OVL bool
square_remove_trap(struct chunk* c, struct loc grid, int t_idx_remove)
{
  bool removed = false;
  struct trap* prev_trap = NULL;
  struct trap* trap = square(c, grid)->trap;
  while (trap) {
    struct trap* next_trap = trap->next;
    if (t_idx_remove == trap->t_idx) {
      mem_free(trap);
      removed = true;
      if (prev_trap) {
        prev_trap->next = next_trap;
      } else {
        square_set_trap(c, grid, next_trap);
      }
      break;
    }
    prev_trap = trap;
    trap = next_trap;
  }
  if (square_isseen(c, grid)) {
    square_memorize_traps(c, grid);
    square_light_spot(c, grid);
  }
  (void)square_verify_trap(c, grid, 0);
  return removed;
}
STATIC_OVL bool
check_hit(int power, bool display_roll, struct source against)
{
  int skill =
      player->state.skill_use[SKILL_EVASION] + player_dodging_bonus(player);
  return hit_roll(power, skill, against, source_player(), display_roll) > 0;
}
STATIC_OVL bool
square_player_trap_allowed(struct chunk* c, struct loc grid)
{
  if (square_istrap(c, grid)) return false;
  if (square_object(c, grid)) return false;
  return (square_istrappable(c, grid));
}
STATIC_OVL int
pick_trap(struct chunk* c, int feat, int trap_level)
{
  int i, pick;
  int* trap_probs = NULL;
  int trap_prob_max = 0;
  if (!feat_is_trap_holding(feat)) return -1;
  trap_probs = mem_zalloc(z_info->trap_max * sizeof(int));
  for (i = 0; i < z_info->trap_max; i++) {
    struct trap_kind* kind = &trap_info[i];
    trap_probs[i] = trap_prob_max;
    if (!kind->name) continue;
    if (!kind->rarity) continue;
    if (!trf_has(kind->flags, TRF_TRAP)) continue;
    if (kind->min_depth > trap_level) continue;
    if (kind->max_depth < trap_level) continue;
    if (!trap_level && !trf_has(kind->flags, TRF_SURFACE)) continue;
    if (feat_is_floor(feat) && !trf_has(kind->flags, TRF_FLOOR)) continue;
    if (trf_has(kind->flags, TRF_DOWN)) {
      if (player->depth >= z_info->dun_depth) continue;
    }
    trap_probs[i] += (100 / kind->rarity);
    trap_prob_max = trap_probs[i];
  }
  if (trap_prob_max == 0) {
    mem_free(trap_probs);
    return -1;
  }
  pick = randint0(trap_prob_max);
  for (i = 0; i < z_info->trap_max; i++) {
    if (pick < trap_probs[i]) {
      break;
    }
  }
  mem_free(trap_probs);
  return i < z_info->trap_max ? i : -1;
}
STATIC_OVL void
place_trap(struct chunk* c, struct loc grid, int t_idx, int trap_level)
{
  struct trap* new_trap;
  if ((t_idx <= 0) || (t_idx >= z_info->trap_max)) {
    if (!square_player_trap_allowed(c, grid)) return;
    t_idx = pick_trap(c, square(c, grid)->feat, trap_level);
  }
  if (t_idx < 0) return;
  if (in_tutorial() && trf_has(trap_info[t_idx].flags, TRF_DOWN)) {
    return;
  }
  new_trap = mem_zalloc(sizeof(*new_trap));
  new_trap->next = square_trap(c, grid);
  square_set_trap(c, grid, new_trap);
  new_trap->t_idx = t_idx;
  new_trap->kind = &trap_info[t_idx];
  new_trap->grid = grid;
  new_trap->power = new_trap->kind->power;
  trf_copy(new_trap->flags, trap_info[t_idx].flags);
  sqinfo_on(square(c, grid)->info, SQUARE_TRAP);
  square_note_spot(c, grid);
  square_light_spot(c, grid);
}
STATIC_OVL bool
square_reveal_trap(struct chunk* c, struct loc grid, bool domsg)
{
  int found_trap = 0;
  struct trap* trap = square_trap(c, grid);
  if (!square_isplayertrap(c, grid)) return false;
  while (trap) {
    if (!trf_has(trap->flags, TRF_TRAP)) {
      trap = trap->next;
      continue;
    }
    if (!trf_has(trap->flags, TRF_VISIBLE)) {
      trf_on(trap->flags, TRF_VISIBLE);
      square_memorize_traps(c, grid);
      found_trap++;
    }
    trap = trap->next;
  }
  if (found_trap) {
    if (domsg) {
      if (found_trap == 1)
        msg("You have found a trap.");
      else
        msg("You have found %d traps.", found_trap);
    }
    square_memorize(c, grid);
    square_light_spot(c, grid);
  }
  return (found_trap != 0);
}
STATIC_OVL void
square_memorize_traps(struct chunk* c, struct loc grid)
{
  struct trap* trap = square(c, grid)->trap;
  struct trap* current = NULL;
  if (c != cave) return;
  square_remove_all_traps(player->cave, grid);
  sqinfo_off(square(player->cave, grid)->info, SQUARE_TRAP);
  while (trap) {
    if (square_isvisibletrap(c, grid)) {
      struct trap* next;
      if (current) {
        next = mem_zalloc(sizeof(*next));
        current->next = next;
        current = next;
      } else {
        current = mem_zalloc(sizeof(*current));
        player->cave->squares[grid.y][grid.x].trap = current;
      }
      memcpy(current, trap, sizeof(*trap));
      current->next = NULL;
    }
    trap = trap->next;
  }
  if (square(player->cave, grid)->trap) {
    sqinfo_on(square(player->cave, grid)->info, SQUARE_TRAP);
  }
}
STATIC_OVL void
hit_trap(struct loc grid)
{
  bool ident = false;
  struct trap* trap;
  struct effect* effect;
  for (trap = square_trap(cave, grid); trap; trap = trap->next) {
    struct song* silence = lookup_song("Silence");
    bool saved = false;
    if (!trf_has(trap->kind->flags, TRF_TRAP)) continue;
    disturb(player, false);
    if (player_is_singing(player, silence) && trap->kind->msg_silence) {
      msg("%s", trap->kind->msg_silence);
    } else if (trap->kind->msg) {
      msg("%s", trap->kind->msg);
    }
    if (trap->kind->msg2) {
      event_signal(EVENT_MESSAGE_FLUSH);
      msg("%s", trap->kind->msg2);
    }
    if (trap->kind->msg3) {
      event_signal(EVENT_MESSAGE_FLUSH);
      msg("%s", trap->kind->msg3);
    }
    if (trf_has(trap->kind->flags, TRF_SAVE_SKILL)) {
      int result = skill_check(source_player(),
                               player->state.skill_use[SKILL_PERCEPTION], 10,
                               source_trap(trap));
      if (result > 0) saved = true;
    }
    if (saved) {
      if (trap->kind->msg_good) msg("%s", trap->kind->msg_good);
    } else {
      if (trap->kind->msg_bad) msg("%s", trap->kind->msg_bad);
      if (trap->kind->msg_vis && !player->timed[TMD_BLIND])
        msg("%s", trap->kind->msg_vis);
      player->stealth_score += trap->kind->stealth;
      effect = trap->kind->effect;
      effect_do(effect, source_trap(trap), NULL, &ident, false, 0, NULL);
      if (!square_trap(cave, grid) || player->is_dead) break;
      if (trap->kind->msg_xtra && ident) {
        msg("%s", trap->kind->msg_xtra);
        if (trap->kind->effect_xtra) {
          effect = trap->kind->effect_xtra;
          effect_do(effect, source_trap(trap), NULL, &ident, false, 0, NULL);
        }
        if (!square_trap(cave, grid) || player->is_dead) break;
      }
    }
    if (trf_has(trap->kind->flags, TRF_DOWN)) {
      int next = dungeon_get_next_level(player, player->depth, 1);
      dungeon_change_level(player, next);
      history_add(player, format("Fell through a %s", trap->kind->name),
                  HIST_FELL_DOWN_LEVEL);
      return;
    }
    if (trf_has(trap->kind->flags, TRF_PIT)) {
      monster_swap(player->grid, trap->grid);
      player_handle_post_move(player, false, true);
    }
    if (trf_has(trap->kind->flags, TRF_ONETIME)) {
      square_destroy_trap(cave, grid);
      square_unmark(cave, grid);
    }
    if (!square_trap(cave, grid)) break;
    trf_on(trap->flags, TRF_VISIBLE);
  }
  square_memorize_traps(cave, grid);
  if (square_isseen(cave, grid)) {
    square_light_spot(cave, grid);
  }
}
STATIC_OVL void
square_set_door_lock(struct chunk* c, struct loc grid, int power)
{
  struct trap_kind* lock = lookup_trap("door lock");
  struct trap* trap;
  if (!square_iscloseddoor(c, grid)) return;
  if (!square_trap_specific(c, grid, lock->tidx))
    place_trap(c, grid, lock->tidx, 0);
  trap = square_trap(c, grid);
  while (trap) {
    if (trap->kind == lock) trap->power = power;
    trap = trap->next;
  }
}
STATIC_OVL int
square_door_lock_power(struct chunk* c, struct loc grid)
{
  struct trap_kind* lock = lookup_trap("door lock");
  struct trap* trap;
  if (!square_iscloseddoor(c, grid)) return 0;
  if (!square_trap_specific(c, grid, lock->tidx)) return 0;
  trap = square_trap(c, grid);
  while (trap) {
    if (trap->kind == lock) return trap->power;
    trap = trap->next;
  }
  return 0;
}
STATIC_OVL void
square_set_door_jam(struct chunk* c, struct loc grid, int power)
{
  struct trap_kind* jam = lookup_trap("door jam");
  struct trap* trap;
  if (!square_iscloseddoor(c, grid)) return;
  if (!square_trap_specific(c, grid, jam->tidx))
    place_trap(c, grid, jam->tidx, 0);
  trap = square_trap(c, grid);
  while (trap) {
    if (trap->kind == jam) trap->power = power;
    trap = trap->next;
  }
}
STATIC_OVL int
square_door_jam_power(struct chunk* c, struct loc grid)
{
  struct trap_kind* jam = lookup_trap("door jam");
  struct trap* trap;
  if (!square_iscloseddoor(c, grid)) return 0;
  if (!square_trap_specific(c, grid, jam->tidx)) return 0;
  trap = square_trap(c, grid);
  while (trap) {
    if (trap->kind == jam) return trap->power;
    trap = trap->next;
  }
  return 0;
}
STATIC_OVL void
square_set_forge(struct chunk* c, struct loc grid, int uses)
{
  struct trap_kind* forge = lookup_trap("forge use");
  struct trap* trap;
  if (!square_isforge(c, grid)) return;
  if (!square_trap_specific(c, grid, forge->tidx))
    place_trap(c, grid, forge->tidx, 0);
  trap = square_trap(c, grid);
  while (trap) {
    if (trap->kind == forge) trap->power = uses;
    trap = trap->next;
  }
}
STATIC_OVL int
square_forge_uses(struct chunk* c, struct loc grid)
{
  struct trap_kind* forge = lookup_trap("forge use");
  struct trap* trap;
  if (!square_isforge(c, grid)) return 0;
  if (!square_trap_specific(c, grid, forge->tidx)) return 0;
  trap = square_trap(c, grid);
  while (trap) {
    if (trap->kind == forge) return trap->power;
    trap = trap->next;
  }
  return 0;
}
STATIC_OVL struct object*
create_tutorial_note(char* name)
{
  struct tutorial_dict_key_type dkey;
  struct tutorial_dict_val_type* dval;
  struct object* obj;
  dkey.name = name;
  dkey.comp = TUTORIAL_NOTE;
  dval = tutorial_dict_has(tutorial_parsed_data.d, &dkey);
  if (!dval) {
    msg("Tutorial has an unknown note, %s", name);
    return NULL;
  }
  obj = object_new();
  object_prep(obj, tutorial_parsed_data.note_kind, 0, RANDOMISE);
  obj->pval = dval->v.note.pval;
  obj->number = 1;
  return obj;
}
STATIC_OVL void
tutorial_section_place_feature(struct chunk* c, struct loc grid,
                               struct tutorial_section_sym_val* val)
{
  assert(square_in_bounds_fully(c, grid));
  square_set_feat(c, grid, val->v.feat);
}
STATIC_OVL void
tutorial_section_place_trap(struct chunk* c, struct loc grid,
                            struct tutorial_section_sym_val* val)
{
  assert(val->kind == SECTION_SYM_TRAP_RANDOM);
  assert(square_in_bounds_fully(c, grid));
  square_set_feat(c, grid, FEAT_FLOOR);
  square_add_trap(c, grid);
}
STATIC_OVL void
tutorial_section_place_note(struct chunk* c, struct loc grid,
                            struct tutorial_section_sym_val* val)
{
  assert(val->kind == SECTION_SYM_NOTE || val->kind == SECTION_SYM_START);
  assert(square_in_bounds_fully(c, grid));
  square_set_feat(c, grid, FEAT_FLOOR);
  if (val->v.name) {
    struct object* obj = create_tutorial_note(val->v.name);
    if (obj) {
      bool dummy;
      obj->origin = ORIGIN_FLOOR;
      obj->origin_depth = convert_depth_to_origin(c->depth);
      if (floor_carry(c, grid, obj, &dummy)) {
        list_object(c, obj);
      } else {
        object_delete(c, NULL, &obj);
      }
    }
  }
}
STATIC_OVL void
tutorial_section_place_trigger(struct chunk* c, struct loc grid,
                               struct tutorial_section_sym_val* val)
{
  struct tutorial_dict_key_type dkey;
  struct tutorial_dict_val_type* dval;
  assert(val->kind == SECTION_SYM_TRIGGER);
  assert(square_in_bounds_fully(c, grid));
  square_set_feat(c, grid, FEAT_FLOOR);
  dkey.name = val->v.name;
  dkey.comp = TUTORIAL_TRIGGER;
  dval = tutorial_dict_has(tutorial_parsed_data.d, &dkey);
  if (dval) {
    assert(!tutorial_parsed_data.trigger_gate_map[grid.y][2 * grid.x]);
    tutorial_parsed_data.trigger_gate_map[grid.y][2 * grid.x] = dval;
  } else {
    msg("Tutorial has an unknown trigger, %s", val->v.name);
  }
}
STATIC_OVL void
tutorial_section_place_gate(struct chunk* c, struct loc grid,
                            struct tutorial_section_sym_val* val)
{
  struct tutorial_dict_key_type dkey;
  struct tutorial_dict_val_type* dval;
  assert(val->kind == SECTION_SYM_GATE);
  assert(square_in_bounds_fully(c, grid));
  dkey.name = val->v.gate.dest;
  dkey.comp = TUTORIAL_SECTION;
  dval = tutorial_dict_has(tutorial_parsed_data.d, &dkey);
  if (dval) {
    assert(!tutorial_parsed_data.trigger_gate_map[grid.y][2 * grid.x]);
    tutorial_parsed_data.trigger_gate_map[grid.y][2 * grid.x] = dval;
    square_set_feat(c, grid, val->v.gate.feat);
    if (val->v.gate.note) {
      dkey.name = val->v.gate.note;
      dkey.comp = TUTORIAL_NOTE;
      dval = tutorial_dict_has(tutorial_parsed_data.d, &dkey);
      if (dval) {
        assert(!tutorial_parsed_data.trigger_gate_map[grid.y][2 * grid.x + 1]);
        tutorial_parsed_data.trigger_gate_map[grid.y][2 * grid.x + 1] = dval;
      } else {
        msg("Tutorial has an unknown note, %s", val->v.gate.note);
      }
    }
  } else {
    square_set_feat(c, grid, FEAT_FLOOR);
    msg("Tutorial has a gate to an unknown section, %s", val->v.gate.dest);
  }
}
STATIC_OVL void
tutorial_section_place_forge(struct chunk* c, struct loc grid,
                             struct tutorial_section_sym_val* val)
{
  assert(val->kind == SECTION_SYM_FORGE);
  assert(square_in_bounds_fully(c, grid));
  square_set_feat(c, grid, val->v.forge.feat);
  square_set_forge(c, grid, val->v.forge.uses);
}
STATIC_OVL void
tutorial_section_place_object(struct chunk* c, struct loc grid,
                              struct tutorial_section_sym_val* val)
{
  struct object* obj;
  bool dummy;
  assert(val->kind == SECTION_SYM_ITEM);
  assert(square_in_bounds_fully(c, grid));
  square_set_feat(c, grid, FEAT_FLOOR);
  obj = (val->v.item.is_artifact) ? tutorial_create_artifact(val->v.item.v.art)
                                  : tutorial_create_object(&val->v.item);
  if (!obj) {
    return;
  }
  obj->origin = ORIGIN_FLOOR;
  obj->origin_depth = convert_depth_to_origin(c->depth);
  dummy = true;
  if (!floor_carry(c, grid, obj, &dummy)) {
    if (obj->artifact) {
      mark_artifact_created(obj->artifact, false);
    }
    object_delete(c, NULL, &obj);
    return;
  }
  list_object(c, obj);
}
STATIC_OVL void
tutorial_section_place_monster(struct chunk* c, struct loc grid,
                               struct tutorial_section_sym_val* val)
{
  struct monster_group_info gi = {0, 0};
  struct monster* mon;
  assert(val->kind == SECTION_SYM_MONSTER);
  assert(square_in_bounds_fully(c, grid));
  square_set_feat(c, grid, FEAT_FLOOR);
  place_new_monster(c, grid, val->v.monster.race, false, false, gi,
                    ORIGIN_DROP);
  mon = square_monster(c, grid);
  if (mon && val->v.monster.note) {
    struct object* obj = create_tutorial_note(val->v.monster.note);
    if (obj) {
      obj->origin = ORIGIN_DROP;
      obj->origin_depth = convert_depth_to_origin(c->depth);
      if (!monster_carry(c, mon, obj)) {
        object_free(obj);
      }
    }
  }
  if (mon) {
    int amount;
    if (val->v.monster.sleepiness_fixed) {
      amount = val->v.monster.sleepiness;
    } else {
      assert(val->v.monster.sleepiness > 0);
      amount = randint1(val->v.monster.sleepiness);
    }
    mon->alertness =
        MAX(ALERTNESS_MIN, MIN(ALERTNESS_MAX, ALERTNESS_ALERT - amount));
  }
}
STATIC_OVL void
tutorial_section_place_custom_trap(struct chunk* c, struct loc grid,
                                   struct tutorial_section_sym_val* val)
{
  assert(val->kind == SECTION_SYM_TRAP);
  assert(square_in_bounds_fully(c, grid));
  square_set_feat(c, grid, FEAT_FLOOR);
  place_trap(c, grid, val->v.trap.kind->tidx, c->depth);
  if (val->v.trap.vis) {
    square_reveal_trap(c, grid, false);
  }
}
STATIC_OVL void
tutorial_section_place_custom_door(struct chunk* c, struct loc grid,
                                   struct tutorial_section_sym_val* val)
{
  assert(val->kind == SECTION_SYM_DOOR);
  assert(square_in_bounds_fully(c, grid));
  square_set_feat(c, grid, val->v.door.feat);
  if (val->v.door.power > 0) {
    square_set_door_lock(c, grid, val->v.door.power);
  } else if (val->v.door.power < 0) {
    square_set_door_jam(c, grid, -val->v.door.power);
  }
}
STATIC_OVL void
append_with_case_sensitive_first(textblock* tb, const char* src, bool capital)
{
  if (isupper(src[0])) {
    if (capital) {
      textblock_append(tb, "%s", src);
    } else {
      textblock_append(tb, "%c%s", tolower(src[0]), src + 1);
    }
  } else if (capital) {
    textblock_append(tb, "%c%s", toupper(src[0]), src + 1);
  } else {
    textblock_append(tb, "%s", src);
  }
}
STATIC_OVL textblock*
tutorial_expand_message_from_string(const char* text, bool note)
{
  textblock* tb = textblock_new();
  if (!text || !text[0]) {
    if (note) {
      textblock_append(tb, "This note is blank.");
    }
    return tb;
  }
  if (note) {
    textblock_append(tb, "This note reads:\n");
  }
  while (1) {
    const char* lb;
    const char* rb;
    char* tmp;
    if (!text[0]) {
      break;
    }
    lb = text;
    while (1) {
      lb = strchr(lb, '{');
      if (!lb || !tutorial_text_escaped(lb, text)) {
        break;
      }
      ++lb;
    }
    if (lb != text) {
      size_t sz = (lb) ? (size_t)(lb - text) : strlen(text);
      size_t buf_sz = 512;
      tmp = mem_alloc(buf_sz);
      while (sz) {
        size_t read = tutorial_copy_strip_escapes(
            tmp, (sz < buf_sz) ? sz + 1 : buf_sz, text, sz);
        assert(read <= sz);
        sz -= read;
        text += read;
        textblock_append(tb, "%s", tmp);
      }
      mem_free(tmp);
      if (!lb) {
        break;
      }
    }
    text = lb + 1;
    rb = text;
    while (1) {
      rb = strchr(rb, '}');
      if (!rb || !tutorial_text_escaped(rb, text)) {
        break;
      }
      ++rb;
    }
    if (!rb) {
      break;
    }
    text = lb + 1;
    if (prefix(text, "command:") || prefix(text, "Command:") ||
        prefix(text, "commanding:") || prefix(text, "Commanding:")) {
      bool capital = (text[0] == 'C');
      bool gerund;
      text = strchr(text, ':') + 1;
      gerund = (text[-2] == 'g');
      tmp = mem_alloc((rb - text) + 1);
      (void)tutorial_copy_strip_escapes(tmp, (rb - text) + 1, text, rb - text);
      tutorial_textblock_append_command_phrase(tb, tmp, capital, gerund);
      mem_free(tmp);
    } else if (prefix(text, "direction:") || prefix(text, "Direction:") ||
               prefix(text, "directioning:") || prefix(text, "Directioning:")) {
      bool capital = (text[0] == 'D');
      bool gerund;
      int dir;
      text = strchr(text, ':') + 1;
      gerund = (text[-2] == 'g');
      if (prefix(text, "north}")) {
        assert(text + 5 == rb);
        dir = 8;
      } else if (prefix(text, "northeast}")) {
        assert(text + 9 == rb);
        dir = 9;
      } else if (prefix(text, "east}")) {
        assert(text + 4 == rb);
        dir = 6;
      } else if (prefix(text, "southeast}")) {
        assert(text + 9 == rb);
        dir = 3;
      } else if (prefix(text, "south}")) {
        assert(text + 5 == rb);
        dir = 2;
      } else if (prefix(text, "southwest}")) {
        assert(text + 9 == rb);
        dir = 1;
      } else if (prefix(text, "west}")) {
        assert(text + 4 == rb);
        dir = 4;
      } else if (prefix(text, "northwest}")) {
        assert(text + 9 == rb);
        dir = 7;
      } else if (prefix(text, "stay}")) {
        assert(text + 4 == rb);
        dir = 5;
      } else {
        dir = -1;
      }
      if (dir > 0) {
        tutorial_textblock_append_direction_phrase(tb, dir, capital, gerund);
      }
    } else if (prefix(text, "direction-rose}")) {
      assert(text + 14 == rb);
      tutorial_textblock_append_direction_rose(tb);
    } else if (prefix(text, "feature:")) {
      int feat;
      text += 8;
      tmp = mem_alloc((rb - text) + 1);
      (void)tutorial_copy_strip_escapes(tmp, (rb - text) + 1, text, rb - text);
      feat = lookup_feat(tmp);
      mem_free(tmp);
      if (feat >= 0) {
        tutorial_textblock_append_feature_symbol(tb, feat);
      }
    } else if (prefix(text, "house}") || prefix(text, "House}")) {
      assert(text + 5 == rb);
      append_with_case_sensitive_first(tb, player->house->name,
                                       (text[0] == 'H'));
    } else if (prefix(text, "monster:")) {
      struct monster_race* race;
      text += 8;
      tmp = mem_alloc((rb - text) + 1);
      (void)tutorial_copy_strip_escapes(tmp, (rb - text) + 1, text, rb - text);
      race = lookup_monster(tmp);
      mem_free(tmp);
      if (race) {
        tutorial_textblock_append_monster_symbol(tb, race);
      }
    } else if (prefix(text, "name}")) {
      assert(text + 4 == rb);
      textblock_append(tb, "%s", player->full_name);
    } else if (prefix(text, "object:")) {
      int tval = -1;
      int sval = -1;
      const char* colon;
      text += 7;
      colon = text;
      while (1) {
        colon = strchr(colon, ':');
        if (!colon || !tutorial_text_escaped(colon, text)) {
          break;
        }
        ++colon;
      }
      if (colon) {
        tmp = mem_alloc((colon - text) + 1);
        (void)tutorial_copy_strip_escapes(tmp, (colon - text) + 1, text,
                                          colon - text);
        tval = tval_find_idx(tmp);
        mem_free(tmp);
        text = colon + 1;
      }
      if (colon && tval >= 0) {
        tmp = mem_alloc((rb - text) + 1);
        (void)tutorial_copy_strip_escapes(tmp, (rb - text) + 1, text,
                                          rb - text);
        if (streq(tmp, "*")) {
          sval = 1;
        } else {
          sval = lookup_sval(tval, tmp);
        }
        mem_free(tmp);
      }
      if (tval >= 0 && sval >= 0) {
        struct object_kind* kind = lookup_kind(tval, sval);
        if (kind) {
          tutorial_textblock_append_object_symbol(tb, kind);
        }
      }
    } else if (prefix(text, "paragraphbreak}")) {
      assert(text + 14 == rb);
      textblock_append(tb, "\n\n");
    } else if (prefix(text, "race}") || prefix(text, "Race}")) {
      assert(text + 4 == rb);
      append_with_case_sensitive_first(tb, player->race->name,
                                       (text[0] == 'R'));
    }
    text = rb + 1;
  }
  return tb;
}
STATIC_OVL void
tutorial_handle_player_move(game_event_type t, game_event_data* d, void* u)
{
  struct tutorial_dict_val_type* entry;
  const struct object* obj;
  assert(t == EVENT_PLAYERMOVED || t == EVENT_NEW_LEVEL_DISPLAY);
  assert(tutorial_parsed_data.trigger_gate_map);
  assert(cave && player && player->grid.x >= 0 && player->grid.y >= 0 &&
         player->grid.x < cave->width && player->grid.y < cave->height);
  entry =
      tutorial_parsed_data.trigger_gate_map[player->grid.y][2 * player->grid.x];
  if (entry && entry->key->comp == TUTORIAL_TRIGGER &&
      entry->v.trigger.expr.n_stack > 0 &&
      (entry->v.trigger.text || entry->v.trigger.changes_death_note)) {
    bool* estack = mem_alloc(entry->v.trigger.expr.n_stack * sizeof(*estack));
    int next = 0, iop;
    bool triggered;
    for (iop = 0; iop < entry->v.trigger.expr.n_op; ++iop) {
      const struct trigger_compiled_op* op = entry->v.trigger.expr.ops + iop;
      struct ability* ability;
      switch (op->kind) {
        case TRIGGER_OP_NOT:
          assert(next > 0);
          estack[next - 1] = !estack[next - 1];
          break;
        case TRIGGER_OP_AND:
          assert(next > 1);
          estack[next - 2] = estack[next - 2] && estack[next - 1];
          --next;
          break;
        case TRIGGER_OP_OR:
          assert(next > 1);
          estack[next - 2] = estack[next - 2] || estack[next - 1];
          --next;
          break;
        case TRIGGER_OP_XOR:
          assert(next > 1);
          if (estack[next - 2]) {
            estack[next - 2] = !estack[next - 1];
          } else if (estack[next - 1]) {
            estack[next - 2] = true;
          } else {
            estack[next - 2] = false;
          }
          --next;
          break;
        case TRIGGER_OP_ABILITY:
          assert(next < entry->v.trigger.expr.n_stack);
          ability = lookup_ability(op->idx, op->name);
          estack[next] = player_has_ability(player, ability);
          ++next;
          break;
        case TRIGGER_OP_CARRIED:
          assert(next < entry->v.trigger.expr.n_stack);
          obj = player->gear;
          while (1) {
            if (!obj) {
              estack[next] = false;
              break;
            }
            if (obj->kind && obj->kind->tval == op->tval &&
                (op->sval == -1 || obj->kind->sval == op->sval)) {
              estack[next] = true;
              break;
            }
            obj = obj->next;
          }
          ++next;
          break;
        case TRIGGER_OP_DRAINED:
          assert(next < entry->v.trigger.expr.n_stack);
          if (op->idx >= 0 && op->idx < STAT_MAX) {
            estack[next] = player->stat_drain[op->idx] < 0;
          } else if (op->idx == STAT_MAX) {
            estack[next] = player->chp < player->mhp;
          } else if (op->idx == STAT_MAX + 1) {
            estack[next] = player->csp < player->msp;
          } else {
            quit("Unexpected drained criteria for tutorial trigger");
          }
          ++next;
          break;
        case TRIGGER_OP_EQUIPPED:
          assert(next < entry->v.trigger.expr.n_stack);
          obj = player->gear;
          while (1) {
            if (!obj) {
              estack[next] = false;
              break;
            }
            if (obj->kind && obj->kind->tval == op->tval &&
                (op->sval == -1 || obj->kind->sval == op->sval) &&
                object_is_equipped(player->body, obj)) {
              estack[next] = true;
              break;
            }
            obj = obj->next;
          }
          ++next;
          break;
        case TRIGGER_OP_FALSE:
          assert(next < entry->v.trigger.expr.n_stack);
          estack[next] = false;
          ++next;
          break;
        case TRIGGER_OP_TIMED:
          assert(next < entry->v.trigger.expr.n_stack);
          assert(op->idx >= 0 && op->idx < TMD_MAX);
          estack[next] = player->timed[op->idx];
          ++next;
          break;
        case TRIGGER_OP_TIMED_ABOVE:
          assert(next < entry->v.trigger.expr.n_stack);
          assert(op->idx >= 0 && op->idx < TMD_MAX);
          estack[next] = player_timed_grade_gt(player, op->idx, op->name);
          ++next;
          break;
        case TRIGGER_OP_TIMED_BELOW:
          assert(next < entry->v.trigger.expr.n_stack);
          assert(op->idx >= 0 && op->idx < TMD_MAX);
          estack[next] = player_timed_grade_lt(player, op->idx, op->name);
          ++next;
          break;
        case TRIGGER_OP_TRUE:
          assert(next < entry->v.trigger.expr.n_stack);
          estack[next] = true;
          ++next;
          break;
        default:
          quit("Unexpected trigger operation in tutorial");
          break;
      }
    }
    assert(next == 1);
    triggered = estack[0];
    mem_free(estack);
    if (triggered) {
      if (entry->v.trigger.text) {
        textblock* text =
            tutorial_expand_message_from_string(entry->v.trigger.text, false);
        tutorial_textblock_show(text, NULL);
        textblock_free(text);
      }
      if (entry->v.trigger.changes_death_note) {
        tutorial_parsed_data.curr_death_note = entry->v.trigger.death_note_name;
      }
    }
  }
  obj = square_object(cave, player->grid);
  while (obj) {
    if (obj->kind == tutorial_parsed_data.note_kind) {
      textblock* text = tutorial_expand_message(obj->pval);
      tutorial_textblock_show(text, NULL);
      textblock_free(text);
    }
    obj = obj->next;
  }
}
STATIC_OVL void
tutorial_leave_section_helper(struct tutorial_dict_val_type** dest,
                              struct tutorial_dict_val_type** note,
                              const struct player* p)
{
  if (p->grid.x < 0 || p->grid.y < 0 || !cave || p->grid.x >= cave->width ||
      p->grid.y >= cave->height) {
    quit(
        "Logic error:  player coordinates are invalid when "
        "leaving a tutorial section.");
  }
  if (!tutorial_parsed_data.trigger_gate_map) {
    quit(
        "Logic error:  there's no trigger/gate map when leaving "
        "a tutorial section.");
  }
  *dest = tutorial_parsed_data.trigger_gate_map[p->grid.y][2 * p->grid.x];
  if (!*dest || (*dest)->key->comp != TUTORIAL_SECTION) {
    quit(
        "Logic error:  the trigger/gate map entry is invalid "
        "when leaving a tutorial section.");
  }
  *note = tutorial_parsed_data.trigger_gate_map[p->grid.y][2 * p->grid.x + 1];
}
STATIC_OVL bool
in_tutorial(void)
{
  return player && player->game_type < 0;
}
STATIC_OVL void
tutorial_prepare_section(const char* name, struct player* p)
{
  struct tutorial_dict_val_type* section;
  struct loc grid;
  int i;
  if (character_dungeon) {
    if (p->cave) {
      assert(cave);
      for (grid.y = 0; grid.y < cave->height; ++grid.y) {
        for (grid.x = 0; grid.x < cave->width; ++grid.x) {
          struct object* obj;
          for (obj = square_object(cave, grid); obj; obj = obj->next) {
            if (!obj->artifact || !object_is_known_artifact(obj)) continue;
            history_lose_artifact(p, obj->artifact);
            mark_artifact_created(obj->artifact, true);
          }
        }
      }
      cave_free(p->cave);
      p->cave = NULL;
    }
    p->smithing_leftover = 0;
    p->upkeep->knocked_back = false;
    wipe_mon_list(cave, p);
    forget_fire(cave);
    cave_free(cave);
  }
  character_dungeon = false;
  if (name) {
    struct tutorial_dict_key_type key = {string_make(name), TUTORIAL_SECTION};
    section = tutorial_dict_has(tutorial_parsed_data.d, &key);
    string_free(key.name);
    if (!section) {
      quit_fmt("There's no tutorial section named, %s.", name);
    }
  } else {
    section = tutorial_parsed_data.default_section;
    if (!section) {
      quit("No default tutorial section was defined");
    }
  }
  p->depth = 1;
  assert(section->v.section.rows > 0 &&
         section->v.section.rows < z_info->dungeon_hgt - 1 &&
         section->v.section.columns > 0 &&
         section->v.section.columns < z_info->dungeon_wid - 1);
  tutorial_cleanup_trigger_gate_map(tutorial_parsed_data.trigger_gate_map);
  tutorial_parsed_data.trigger_gate_map =
      mem_alloc((section->v.section.rows + 3) *
                sizeof(*tutorial_parsed_data.trigger_gate_map));
  for (i = 0; i < section->v.section.rows + 2; ++i) {
    tutorial_parsed_data.trigger_gate_map[i] =
        mem_zalloc(2 * (size_t)(section->v.section.columns + 2) *
                   sizeof(**tutorial_parsed_data.trigger_gate_map));
  }
  tutorial_parsed_data.trigger_gate_map[section->v.section.rows + 2] = NULL;
  tutorial_parsed_data.curr_death_note = section->v.section.death_note_name;
  cave = cave_new(section->v.section.rows + 2, section->v.section.columns + 2);
  cave->depth = p->depth;
  cave->turn = turn;
  grid.y = 0;
  for (grid.x = 0; grid.x < cave->width; ++grid.x) {
    square_set_feat(cave, grid, FEAT_PERM);
  }
  for (grid.y = 1; grid.y < cave->height - 1; ++grid.y) {
    char* sym = section->v.section.lines[grid.y - 1];
    grid.x = 0;
    square_set_feat(cave, grid, FEAT_PERM);
    for (grid.x = 1; grid.x < cave->width - 1; ++grid.x) {
      char* next_sym = utf8_fskip(sym, 1, NULL);
      struct tutorial_section_sym_key key;
      struct tutorial_section_sym_val* val;
      if (next_sym) {
        assert((size_t)(next_sym - sym) < sizeof(key.symbol));
        strnfmt(key.symbol, sizeof(key.symbol), "%.*s", (int)(next_sym - sym),
                sym);
      } else {
        assert(grid.x == cave->width - 2);
        my_strcpy(key.symbol, sym, sizeof(key.symbol));
      }
      key.x = grid.x - 1;
      key.y = grid.y - 1;
      val = tutorial_section_sym_table_has(section->v.section.symt, &key);
      if (!val) {
        key.x = -1;
        key.y = -1;
        val = tutorial_section_sym_table_has(section->v.section.symt, &key);
        assert(val);
      }
      (*place_ftable[val->kind])(cave, grid, val);
      if (val->kind == SECTION_SYM_START) {
        player_place(cave, p, grid);
      }
      sym = next_sym;
    }
    grid.x = cave->width - 1;
    square_set_feat(cave, grid, FEAT_PERM);
  }
  grid.y = cave->height - 1;
  for (grid.x = 0; grid.x < cave->width; ++grid.x) {
    square_set_feat(cave, grid, FEAT_PERM);
  }
  for (i = 0; i < section->v.section.area_flag_count; ++i) {
    const struct tutorial_area_flag* flag = section->v.section.area_flags + i;
    int yst = MAX(0, flag->ul.y + 1);
    int ylim = MIN(cave->height - 1, flag->lr.y + 1);
    int xst = MAX(0, flag->ul.x + 1);
    int xlim = MIN(cave->width - 1, flag->lr.x + 1);
    if (flag->clear) {
      for (grid.y = yst; grid.y <= ylim; ++grid.y) {
        for (grid.x = xst; grid.x <= xlim; ++grid.x) {
          sqinfo_diff(square(cave, grid)->info, flag->flags);
        }
      }
    } else {
      for (grid.y = yst; grid.y <= ylim; ++grid.y) {
        for (grid.x = xst; grid.x <= xlim; ++grid.x) {
          sqinfo_union(square(cave, grid)->info, flag->flags);
        }
      }
    }
  }
  p->cave = cave_new(cave->height, cave->width);
  p->cave->depth = cave->depth;
  p->cave->objects = mem_realloc(p->cave->objects,
                                 (cave->obj_max + 1) * sizeof(struct object*));
  p->cave->obj_max = cave->obj_max;
  for (i = 0; i <= p->cave->obj_max; ++i) {
    p->cave->objects[i] = NULL;
  }
  character_dungeon = true;
}
STATIC_OVL void
tutorial_leave_section(struct player* p)
{
  struct tutorial_dict_val_type* dest = NULL;
  struct tutorial_dict_val_type* note = NULL;
  tutorial_leave_section_helper(&dest, &note, p);
  if (note) {
    textblock* text;
    assert(note->key->comp == TUTORIAL_NOTE);
    if (note->v.note.text) {
      text = tutorial_expand_message_from_string(note->v.note.text, false);
      event_signal_poem_textblock(EVENT_POEM, text, 5, 10);
      textblock_free(text);
    }
  }
  if (dest->key->name && streq(dest->key->name, "EXIT")) {
    p->upkeep->playing = false;
  }
}
STATIC_OVL const char*
tutorial_get_next_section(const struct player* p)
{
  struct tutorial_dict_val_type* dest = NULL;
  struct tutorial_dict_val_type* note = NULL;
  tutorial_leave_section_helper(&dest, &note, p);
  return dest->key->name;
}
STATIC_OVL textblock*
tutorial_expand_message(int pval)
{
  struct tutorial_dict_val_type* note;
  if (pval < 0 || pval >= tutorial_parsed_data.note_table_n) {
    quit_fmt("A tutorial note had an invalid pval, %d.", pval);
  }
  if (!tutorial_parsed_data.pval_to_note_table) {
    quit("Logic error:  missing tutorial note lookup table");
  }
  note = tutorial_parsed_data.pval_to_note_table[pval];
  if (!note) {
    quit_fmt("Logic error:  have a gap in the note lookup table");
  }
  assert(note->key->comp == TUTORIAL_NOTE && note->v.note.pval == pval);
  return tutorial_expand_message_from_string(note->v.note.text, true);
}
STATIC_OVL void
tutorial_textblock_show(textblock* tb, const char* header)
{
  if (tutorial_textblock_show_hook) {
    (*tutorial_textblock_show_hook)(tb, header);
  }
}
STATIC_OVL void
tutorial_display_death_note(const struct player* p)
{
  if (tutorial_parsed_data.curr_death_note) {
    struct tutorial_dict_key_type dkey;
    struct tutorial_dict_val_type* dval;
    dkey.name = tutorial_parsed_data.curr_death_note;
    dkey.comp = TUTORIAL_NOTE;
    dval = tutorial_dict_has(tutorial_parsed_data.d, &dkey);
    if (dval) {
      textblock* text;
      assert(dval->key->comp == TUTORIAL_NOTE);
      text = tutorial_expand_message_from_string(dval->v.note.text, false);
      event_signal_poem_textblock(EVENT_POEM, text, 5, 10);
      textblock_free(text);
    } else {
      msg("Tutorial has an unknown note, %s", dkey.name);
    }
  }
}
STATIC_OVL void
tutorial_textblock_append_command_phrase(textblock* tb,
                                         const char* command_name, bool capital,
                                         bool gerund)
{
  if (tutorial_textblock_append_command_phrase_hook) {
    (*tutorial_textblock_append_command_phrase_hook)(tb, command_name, capital,
                                                     gerund);
  }
}
STATIC_OVL void
tutorial_textblock_append_direction_phrase(textblock* tb, int dirnum,
                                           bool capital, bool gerund)
{
  if (tutorial_textblock_append_direction_phrase_hook) {
    (*tutorial_textblock_append_direction_phrase_hook)(tb, dirnum, capital,
                                                       gerund);
  }
}
STATIC_OVL void
tutorial_textblock_append_direction_rose(textblock* tb)
{
  if (tutorial_textblock_append_direction_rose_hook) {
    (*tutorial_textblock_append_direction_rose_hook)(tb);
  }
}
STATIC_OVL void
tutorial_textblock_append_feature_symbol(textblock* tb, int feat)
{
  if (tutorial_textblock_append_feature_symbol_hook) {
    (*tutorial_textblock_append_feature_symbol_hook)(tb, feat);
  }
}
STATIC_OVL void
tutorial_textblock_append_monster_symbol(textblock* tb,
                                         const struct monster_race* race)
{
  if (tutorial_textblock_append_monster_symbol_hook) {
    (*tutorial_textblock_append_monster_symbol_hook)(tb, race);
  }
}
STATIC_OVL void
tutorial_textblock_append_object_symbol(textblock* tb,
                                        const struct object_kind* kind)
{
  if (tutorial_textblock_append_object_symbol_hook) {
    (*tutorial_textblock_append_object_symbol_hook)(tb, kind);
  }
}
STATIC_OVL struct object*
tutorial_create_artifact(const struct artifact* art)
{
  struct object_kind* kind;
  struct object* obj;
  if (!art->name || is_artifact_created(art)) return NULL;
  kind = lookup_kind(art->tval, art->sval);
  if (!kind) return NULL;
  obj = object_new();
  object_prep(obj, kind, art->level, RANDOMISE);
  obj->artifact = art;
  copy_artifact_data(obj, art);
  mark_artifact_created(art, true);
  return obj;
}
STATIC_OVL struct object*
tutorial_create_object(const struct tutorial_item* item)
{
  struct object_kind* kind =
      lookup_kind(item->v.details.tval, item->v.details.sval);
  int n = randcalc(item->v.details.number, 0, RANDOMISE);
  struct object* obj;
  int j;
  assert(kind);
  n = MIN(n, kind->base->max_stack);
  if (n <= 0) {
    return NULL;
  }
  obj = object_new();
  object_prep(obj, kind, 0, RANDOMISE);
  if (item->v.details.ego) {
    obj->ego = item->v.details.ego;
    ego_apply_magic(obj, 0);
  }
  obj->number = n;
  for (j = 0; j < item->v.details.tweak_count; ++j) {
    const struct tutorial_item_tweak* tweak = item->v.details.tweaks + j;
    dice_t* dice;
    switch (tweak->kind) {
      case TWEAK_FLAG:
        of_on(obj->flags, tweak->idx);
        break;
      case TWEAK_SLAY:
        assert(tweak->idx >= 0 && tweak->idx < z_info->slay_max);
        if (!obj->slays) {
          obj->slays = mem_zalloc(z_info->slay_max * sizeof(bool));
        }
        obj->slays[tweak->idx] = true;
        break;
      case TWEAK_BRAND:
        assert(tweak->idx >= 0 && tweak->idx < z_info->brand_max);
        if (!obj->brands) {
          obj->brands = mem_zalloc(z_info->brand_max * sizeof(bool));
        }
        obj->brands[tweak->idx] = true;
        break;
      case TWEAK_ELEM_IGNORE:
        assert(tweak->idx >= 0 && tweak->idx < ELEM_MAX);
        obj->el_info[tweak->idx].flags |= EL_INFO_IGNORE;
        break;
      case TWEAK_ELEM_HATE:
        assert(tweak->idx >= 0 && tweak->idx < ELEM_MAX);
        obj->el_info[tweak->idx].flags |= EL_INFO_HATES;
        break;
      case TWEAK_MODIFIER:
        assert(tweak->idx >= 0 && tweak->idx < OBJ_MOD_MAX);
        obj->modifiers[tweak->idx] = randcalc(tweak->value, 0, RANDOMISE);
        break;
      case TWEAK_ELEM_RESIST:
        assert(tweak->idx >= 0 && tweak->idx < ELEM_MAX);
        obj->el_info[tweak->idx].res_level =
            randcalc(tweak->value, 0, RANDOMISE);
        break;
      case TWEAK_PVAL:
        dice = dice_new();
        if (dice_parse_string(dice, tweak->dice)) {
          expression_t* expr = expression_new();
          expression_set_fixed_base(expr, obj->number);
          dice_bind_expression(dice, "N", expr);
          obj->pval = dice_roll(dice, NULL);
        }
        dice_free(dice);
        break;
    }
  }
  return obj;
}
STATIC_OVL void
tutorial_handle_enter_world(game_event_type t, game_event_data* d, void* u)
{
  assert(t == EVENT_ENTER_WORLD);
  event_add_handler(EVENT_PLAYERMOVED, tutorial_handle_player_move, NULL);
  event_add_handler(EVENT_NEW_LEVEL_DISPLAY, tutorial_handle_player_move, NULL);
}
STATIC_OVL void
tutorial_handle_leave_world(game_event_type t, game_event_data* d, void* u)
{
  assert(t == EVENT_LEAVE_WORLD);
  event_remove_handler(EVENT_PLAYERMOVED, tutorial_handle_player_move, NULL);
  event_remove_handler(EVENT_NEW_LEVEL_DISPLAY, tutorial_handle_player_move,
                       NULL);
}
STATIC_OVL void
tutorial_item_tweaks_free(struct tutorial_item_tweak* tweaks, int count)
{
  int i;
  for (i = 0; i < count; ++i) {
    string_free(tweaks[i].dice);
  }
  mem_free(tweaks);
}
STATIC_OVL uint32_t
tutorial_section_sym_key_hash(const void* key)
{
  const struct tutorial_section_sym_key* sk =
      (const struct tutorial_section_sym_key*)key;
  char buf[32];
  (void)strnfmt(buf, sizeof(buf), "%d,%d,%s", sk->x, sk->y, sk->symbol);
  return djb2_hash(buf);
}
STATIC_OVL int
tutorial_section_sym_key_compare(const void* a, const void* b)
{
  const struct tutorial_section_sym_key* ska =
      (const struct tutorial_section_sym_key*)a;
  const struct tutorial_section_sym_key* skb =
      (const struct tutorial_section_sym_key*)b;
  return (streq(ska->symbol, skb->symbol) && ska->x == skb->x &&
          ska->y == skb->y)
             ? 0
             : 1;
}
STATIC_OVL void
tutorial_section_sym_value_free(void* value)
{
  struct tutorial_section_sym_val* tv = (struct tutorial_section_sym_val*)value;
  switch (tv->kind) {
    case SECTION_SYM_GATE:
      string_free(tv->v.gate.dest);
      string_free(tv->v.gate.note);
      break;
    case SECTION_SYM_ITEM:
      if (!tv->v.item.is_artifact) {
        tutorial_item_tweaks_free(tv->v.item.v.details.tweaks,
                                  tv->v.item.v.details.tweak_count);
      }
      break;
    case SECTION_SYM_MONSTER:
      string_free(tv->v.monster.note);
      break;
    case SECTION_SYM_NOTE:
    case SECTION_SYM_START:
    case SECTION_SYM_TRIGGER:
      string_free(tv->v.name);
      break;
    default:
      break;
  }
  mem_free(tv);
}
STATIC_OVL struct tutorial_section_sym_table
tutorial_section_sym_table_create(void)
{
  struct tutorial_section_sym_table result;
  struct {
    enum tutorial_section_sym_kind kind;
    const char* sym;
    int feat_idx;
  } symbol_kinds[] = {
      {SECTION_SYM_DUMMY, NULL, FEAT_NONE},
      {SECTION_SYM_START, "0", FEAT_NONE},
      {SECTION_SYM_FLOOR, ".", FEAT_FLOOR},
      {SECTION_SYM_GRANITE0, "#", FEAT_GRANITE},
      {SECTION_SYM_GRANITE1, " ", FEAT_GRANITE},
      {SECTION_SYM_PERMROCK, "@", FEAT_PERM},
      {SECTION_SYM_IMPASS_RUBBLE, ":", FEAT_RUBBLE},
      {SECTION_SYM_CLOSED_DOOR, "+", FEAT_CLOSED},
      {SECTION_SYM_OPEN_DOOR, ",", FEAT_OPEN},
      {SECTION_SYM_SECRET_DOOR, "s", FEAT_SECRET},
      {SECTION_SYM_TRAP_RANDOM, "^", FEAT_NONE},
      {SECTION_SYM_NOTE, NULL, FEAT_NONE},
      {SECTION_SYM_TRIGGER, NULL, FEAT_NONE},
      {SECTION_SYM_GATE, NULL, FEAT_NONE},
      {SECTION_SYM_FORGE, NULL, FEAT_NONE},
      {SECTION_SYM_ITEM, NULL, FEAT_NONE},
      {SECTION_SYM_MONSTER, NULL, FEAT_NONE},
      {SECTION_SYM_TRAP, NULL, FEAT_NONE},
      {SECTION_SYM_DOOR, NULL, FEAT_NONE},
  };
  size_t i;
  result.d = dict_create(tutorial_section_sym_key_hash,
                         tutorial_section_sym_key_compare, mem_free,
                         tutorial_section_sym_value_free);
  for (i = 0; i < N_ELEMENTS(symbol_kinds); ++i) {
    struct tutorial_section_sym_key* key;
    struct tutorial_section_sym_val* value;
    if (!symbol_kinds[i].sym) continue;
    key = mem_alloc(sizeof(*key));
    my_strcpy(key->symbol, symbol_kinds[i].sym, sizeof(key->symbol));
    key->x = -1;
    key->y = -1;
    value = mem_zalloc(sizeof(*value));
    if (symbol_kinds[i].feat_idx != FEAT_NONE) {
      value->v.feat = symbol_kinds[i].feat_idx;
    }
    value->is_predefined = true;
    value->kind = symbol_kinds[i].kind;
    if (!tutorial_section_sym_table_insert(result, key, value)) {
      quit("logic error:  duplicate symbols in list-tutorial-sym.h");
    }
  }
  return result;
}
STATIC_OVL void
tutorial_section_sym_table_destroy(struct tutorial_section_sym_table t)
{
  dict_destroy(t.d);
}
STATIC_OVL bool
tutorial_section_sym_table_insert(struct tutorial_section_sym_table t,
                                  struct tutorial_section_sym_key* key,
                                  struct tutorial_section_sym_val* value)
{
  return dict_insert(t.d, key, value);
}
STATIC_OVL enum parser_error
tutorial_section_parse_symbol(const char* symbol,
                              struct tutorial_parser_priv* priv,
                              struct tutorial_section_sym_table t,
                              struct tutorial_section_sym_key** key)
{
  const char* lp = strchr(symbol + 1, '(');
  size_t sz = utf8_strlen(symbol);
  enum parser_error result = PARSE_ERROR_NONE;
  if (lp == NULL) {
    if (sz != 1) {
      result = PARSE_ERROR_INVALID_UTF8_CODE_POINT;
    } else {
      *key = mem_alloc(sizeof(**key));
      my_strcpy((*key)->symbol, symbol, sizeof((*key)->symbol));
      (*key)->x = -1;
      (*key)->y = -1;
    }
  } else {
    const char* rp = strchr(lp + 1, ')');
    size_t sz1 = utf8_strlen(lp);
    assert(sz1 < sz);
    if (sz - sz1 != 1) {
      result = PARSE_ERROR_INVALID_UTF8_CODE_POINT;
    } else if (rp == NULL || *(rp + 1) != '\0') {
      result = PARSE_ERROR_MALFORMED_COORDINATE;
    } else {
      char *endx, *endy;
      long lx, ly;
      lx = strtol(lp + 1, &endx, 10);
      if (endx == lp + 1 || *endx != ',') {
        result = PARSE_ERROR_NOT_NUMBER;
      } else if (lx < 0 || lx >= z_info->dungeon_wid - 1) {
        result = PARSE_ERROR_OUT_OF_BOUNDS;
      } else {
        ly = strtol(endx + 1, &endy, 10);
        if (endy == endx + 1 || endy != rp) {
          result = PARSE_ERROR_NOT_NUMBER;
        } else if (ly < 0 || ly >= z_info->dungeon_hgt - 1) {
          result = PARSE_ERROR_OUT_OF_BOUNDS;
        } else {
          struct tutorial_section_sym_val* val;
          *key = mem_alloc(sizeof(**key));
          strnfmt((*key)->symbol, sizeof((*key)->symbol), "%.*s",
                  (int)(lp - symbol), symbol);
          (*key)->x = -1;
          (*key)->y = -1;
          val = tutorial_section_sym_table_has(t, *key);
          if (val && val->is_predefined) {
            result = PARSE_ERROR_DUPLICATED_SYMBOL;
            mem_free(*key);
            *key = NULL;
          } else {
            (*key)->x = (int)lx;
            (*key)->y = (int)ly;
          }
        }
      }
    }
  }
  return result;
}
STATIC_OVL uint32_t
tutorial_key_hash(const void* key)
{
  const struct tutorial_dict_key_type* tk =
      (const struct tutorial_dict_key_type*)key;
  return djb2_hash(tk->name);
}
STATIC_OVL int
tutorial_key_compare(const void* a, const void* b)
{
  const struct tutorial_dict_key_type* tka =
      (const struct tutorial_dict_key_type*)a;
  const struct tutorial_dict_key_type* tkb =
      (const struct tutorial_dict_key_type*)b;
  return (streq(tka->name, tkb->name) && tka->comp == tkb->comp) ? 0 : 1;
}
STATIC_OVL void
tutorial_key_free(void* key)
{
  struct tutorial_dict_key_type* tk = (struct tutorial_dict_key_type*)key;
  string_free(tk->name);
  mem_free(tk);
}
STATIC_OVL void
free_trigger_compiled_ops(struct trigger_compiled_op* ops, int n)
{
  int i;
  if (!ops) {
    return;
  }
  for (i = 0; i < n; ++i) {
    mem_free(ops[i].name);
  }
  mem_free(ops);
}
STATIC_OVL void
tutorial_value_free(void* value)
{
  struct tutorial_dict_val_type* tv = (struct tutorial_dict_val_type*)value;
  int i;
  switch (tv->key->comp) {
    case TUTORIAL_ARCHETYPE:
      string_free(tv->v.archetype.race_name);
      string_free(tv->v.archetype.house_name);
      string_free(tv->v.archetype.sex_name);
      string_free(tv->v.archetype.character_name);
      string_free(tv->v.archetype.history);
      mem_free(tv->v.archetype.added_abilities);
      for (i = 0; i < tv->v.archetype.kit_count; ++i) {
        if (!tv->v.archetype.kit[i].item.is_artifact) {
          tutorial_item_tweaks_free(
              tv->v.archetype.kit[i].item.v.details.tweaks,
              tv->v.archetype.kit[i].item.v.details.tweak_count);
        }
      }
      mem_free(tv->v.archetype.kit);
      break;
    case TUTORIAL_NOTE:
      string_free(tv->v.note.text);
      break;
    case TUTORIAL_TRIGGER:
      string_free(tv->v.trigger.text);
      string_free(tv->v.trigger.death_note_name);
      free_trigger_compiled_ops(tv->v.trigger.expr.ops,
                                tv->v.trigger.expr.n_op);
      break;
    case TUTORIAL_SECTION:
      string_free(tv->v.section.start_note_name);
      string_free(tv->v.section.death_note_name);
      if (tv->v.section.lines) {
        for (i = 0; i < tv->v.section.rows; ++i) {
          string_free(tv->v.section.lines[i]);
        }
        mem_free(tv->v.section.lines);
      }
      mem_free(tv->v.section.area_flags);
      tutorial_section_sym_table_destroy(tv->v.section.symt);
      break;
  }
  mem_free(tv);
}
STATIC_OVL struct tutorial_dict_type
tutorial_dict_create(void)
{
  struct tutorial_dict_type result;
  result.d = dict_create(tutorial_key_hash, tutorial_key_compare,
                         tutorial_key_free, tutorial_value_free);
  return result;
}
STATIC_OVL void
tutorial_dict_destroy(struct tutorial_dict_type d)
{
  dict_destroy(d.d);
}
STATIC_OVL bool
tutorial_dict_insert(struct tutorial_dict_type d,
                     struct tutorial_dict_key_type* key,
                     struct tutorial_dict_val_type* value)
{
  return dict_insert(d.d, key, value);
}
STATIC_OVL void
verify_section(struct tutorial_dict_val_type* section)
{
  int count_starts = 0;
  int count_exits = 0;
  int count_unknown = 0;
  struct loc first_start = {-1, -1};
  struct loc first_unknown = {-1, -1};
  struct loc grid;
  char reasons[3][80] = {"", "", ""};
  int count_reasons;
  for (grid.y = 0; grid.y < section->v.section.rows; ++grid.y) {
    char* sym = section->v.section.lines[grid.y];
    for (grid.x = 0; grid.x < section->v.section.columns; ++grid.x) {
      char* next_sym = utf8_fskip(sym, 1, NULL);
      struct tutorial_section_sym_key key;
      struct tutorial_section_sym_val* val;
      if (next_sym) {
        assert((size_t)(next_sym - sym) < sizeof(key.symbol));
        strnfmt(key.symbol, sizeof(key.symbol), "%.*s", (int)(next_sym - sym),
                sym);
      } else {
        assert(grid.x == section->v.section.columns - 1);
        my_strcpy(key.symbol, sym, sizeof(key.symbol));
      }
      key.x = grid.x;
      key.y = grid.y;
      val = tutorial_section_sym_table_has(section->v.section.symt, &key);
      if (!val) {
        key.x = -1;
        key.y = -1;
        val = tutorial_section_sym_table_has(section->v.section.symt, &key);
      }
      if (val) {
        if (val->kind == SECTION_SYM_START) {
          if (!count_starts) {
            first_start = grid;
          }
          ++count_starts;
          assert(!val->v.name);
          val->v.name = string_make(section->v.section.start_note_name);
        } else if (val->kind == SECTION_SYM_GATE) {
          ++count_exits;
        }
      } else {
        if (!count_unknown) {
          first_unknown = grid;
        }
        ++count_unknown;
      }
      sym = next_sym;
    }
  }
  count_reasons = 0;
  if (count_starts == 0) {
    assert(count_reasons < (int)N_ELEMENTS(reasons));
    strnfmt(reasons[count_reasons], sizeof(reasons[count_reasons]),
            "  %d) no starting location", count_reasons + 1);
    ++count_reasons;
  } else if (count_starts > 1) {
    assert(count_reasons < (int)N_ELEMENTS(reasons));
    strnfmt(reasons[count_reasons], sizeof(reasons[count_reasons]),
            "  %d) %d starting locations; first at row %d and "
            "column %d",
            count_reasons + 1, count_starts, first_start.y, first_start.x);
    ++count_reasons;
  }
  if (count_exits == 0) {
    assert(count_reasons < (int)N_ELEMENTS(reasons));
    strnfmt(reasons[count_reasons], sizeof(reasons[count_reasons]),
            "  %d) no exits", count_reasons + 1);
    ++count_reasons;
  }
  if (count_unknown > 0) {
    assert(count_reasons < (int)N_ELEMENTS(reasons));
    strnfmt(reasons[count_reasons], sizeof(reasons[count_reasons]),
            "  %d) %d unknown symbols; first at row %d and "
            "column %d",
            count_reasons + 1, count_unknown, first_unknown.y, first_unknown.x);
    ++count_reasons;
  }
  if (count_reasons > 0) {
    quit_fmt("Tutorial section, %s, has these problems:%s%s%s",
             section->key->name, reasons[0], reasons[1], reasons[2]);
  }
}
STATIC_OVL enum parser_error
tutorial_add_item_tweak(struct tutorial_item_tweak** tweaks, int* count,
                        int* alloc, enum tutorial_item_tweak_kind kind,
                        const char* dice, const random_value* rv, int idx)
{
  assert(*count >= 0 && *count <= *alloc);
  if (*count == *alloc) {
    if (!*alloc) {
      *alloc = 4;
    } else if (*alloc >= 128) {
      return PARSE_ERROR_TOO_MANY_ENTRIES;
    } else {
      *alloc += *alloc;
    }
    *tweaks = mem_realloc(*tweaks, *alloc * sizeof(**tweaks));
  }
  (*tweaks)[*count].dice = string_make(dice);
  (*tweaks)[*count].value = *rv;
  (*tweaks)[*count].kind = kind;
  (*tweaks)[*count].idx = idx;
  ++*count;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
tutorial_parse_tweaks(struct tutorial_item_tweak** tweaks, int* count,
                      int* alloc, const char* props, const char* mods)
{
  random_value dummy_rv = {0, 0, 0, 0};
  char *flags, *s, *lb, *rb;
  int idx;
  enum parser_error add_error;
  *tweaks = NULL;
  *count = 0;
  *alloc = 0;
  flags = string_make(props);
  s = strtok(flags, " |");
  while (s) {
    idx = lookup_flag(obj_flags, s);
    if (idx >= 0) {
      if (idx) {
        add_error = tutorial_add_item_tweak(tweaks, count, alloc, TWEAK_FLAG,
                                            NULL, &dummy_rv, idx);
        if (add_error != PARSE_ERROR_NONE) {
          string_free(flags);
          return add_error;
        }
      }
    } else if (prefix(s, "IGNORE_")) {
      idx = lookup_flag(element_names, s + 7);
      if (idx > 0 && idx < ELEM_MAX + 1) {
        add_error = tutorial_add_item_tweak(
            tweaks, count, alloc, TWEAK_ELEM_IGNORE, NULL, &dummy_rv, idx - 1);
        if (add_error != PARSE_ERROR_NONE) {
          string_free(flags);
          return add_error;
        }
      } else {
        string_free(flags);
        return PARSE_ERROR_INVALID_PROPERTY;
      }
    } else if (prefix(s, "HATES_")) {
      idx = lookup_flag(element_names, s + 6);
      if (idx > 0 && idx < ELEM_MAX + 1) {
        add_error = tutorial_add_item_tweak(
            tweaks, count, alloc, TWEAK_ELEM_HATE, NULL, &dummy_rv, idx - 1);
        if (add_error != PARSE_ERROR_NONE) {
          string_free(flags);
          return add_error;
        }
      } else {
        string_free(flags);
        return PARSE_ERROR_INVALID_PROPERTY;
      }
    } else if ((idx = lookup_slay(s)) >= 0) {
      add_error = tutorial_add_item_tweak(tweaks, count, alloc, TWEAK_SLAY,
                                          NULL, &dummy_rv, idx);
      if (add_error != PARSE_ERROR_NONE) {
        string_free(flags);
        return add_error;
      }
    } else if ((idx = lookup_brand(s)) >= 0) {
      add_error = tutorial_add_item_tweak(tweaks, count, alloc, TWEAK_BRAND,
                                          NULL, &dummy_rv, idx);
      if (add_error != PARSE_ERROR_NONE) {
        string_free(flags);
        return add_error;
      }
    } else {
      string_free(flags);
      return PARSE_ERROR_INVALID_PROPERTY;
    }
    s = strtok(NULL, " |");
  }
  string_free(flags);
  flags = string_make(mods);
  s = strtok(flags, " |");
  while (s) {
    lb = strchr(s, '[');
    rb = strchr(s, ']');
    if (lb == NULL || rb == NULL || *(rb + 1) != '\0') {
      string_free(flags);
      return PARSE_ERROR_INVALID_DICE;
    }
    *lb = '\0';
    *rb = '\0';
    ++lb;
    if (streq(s, "PVAL")) {
      add_error = tutorial_add_item_tweak(tweaks, count, alloc, TWEAK_PVAL,
                                          lb + 1, &dummy_rv, 0);
      if (add_error != PARSE_ERROR_NONE) {
        string_free(flags);
        return add_error;
      }
    } else {
      dice_t* dice = dice_new();
      random_value rv;
      if (dice_parse_string(dice, lb)) {
        dice_random_value(dice, &rv);
        dice_free(dice);
      } else {
        dice_free(dice);
        string_free(flags);
        return PARSE_ERROR_INVALID_DICE;
      }
      idx = lookup_flag(obj_mods, s);
      if (idx >= 0) {
        if (idx > 0) {
          add_error = tutorial_add_item_tweak(
              tweaks, count, alloc, TWEAK_MODIFIER, NULL, &rv, idx - 1);
          if (add_error != PARSE_ERROR_NONE) {
            string_free(flags);
            return add_error;
          }
        }
      } else if (prefix(s, "RES_")) {
        idx = lookup_flag(element_names, s + 4);
        if (idx > 0 && idx < ELEM_MAX + 1) {
          add_error = tutorial_add_item_tweak(
              tweaks, count, alloc, TWEAK_ELEM_RESIST, NULL, &rv, idx - 1);
          if (add_error != PARSE_ERROR_NONE) {
            string_free(flags);
            return add_error;
          }
        } else {
          string_free(flags);
          return PARSE_ERROR_INVALID_PROPERTY;
        }
      } else {
        string_free(flags);
        return PARSE_ERROR_INVALID_PROPERTY;
      }
    }
    s = strtok(NULL, " |");
  }
  string_free(flags);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
tutorial_add_area_flags(struct parser* p, struct tutorial_dict_val_type* val,
                        bool clear)
{
  char* flags = string_make(parser_getstr(p, "flags"));
  char* s = strtok(flags, " |");
  bitflag bits[SQUARE_SIZE];
  struct tutorial_area_flag* this_area;
  sqinfo_wipe(bits);
  while (s) {
    int idx = lookup_flag(square_flag_names, s);
    if (idx > 0) {
      sqinfo_on(bits, idx);
    } else if (!streq(s, "NONE")) {
      string_free(flags);
      return PARSE_ERROR_INVALID_FLAG;
    }
    s = strtok(NULL, " |");
  }
  string_free(flags);
  assert(val->v.section.area_flag_count >= 0 &&
         val->v.section.area_flag_count <= val->v.section.area_flag_alloc);
  if (val->v.section.area_flag_count == val->v.section.area_flag_alloc) {
    if (!val->v.section.area_flag_alloc) {
      val->v.section.area_flag_alloc = 4;
    } else if (val->v.section.area_flag_alloc >= 1024) {
      return PARSE_ERROR_TOO_MANY_ENTRIES;
    } else {
      val->v.section.area_flag_alloc += val->v.section.area_flag_alloc;
    }
    val->v.section.area_flags = mem_realloc(
        val->v.section.area_flags,
        val->v.section.area_flag_alloc * sizeof(*val->v.section.area_flags));
  }
  this_area = val->v.section.area_flags + val->v.section.area_flag_count;
  ++val->v.section.area_flag_count;
  sqinfo_copy(this_area->flags, bits);
  this_area->ul = loc(parser_getint(p, "xul"), parser_getint(p, "yul"));
  this_area->lr = loc(parser_getint(p, "xlr"), parser_getint(p, "ylr"));
  this_area->clear = clear;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_archetype_block_start(struct parser* p)
{
  struct tutorial_parser_priv* priv =
      (struct tutorial_parser_priv*)parser_priv(p);
  struct tutorial_dict_key_type* key;
  struct tutorial_dict_val_type* value;
  if (priv->curr_value && priv->curr_value->key->comp == TUTORIAL_SECTION) {
    if (priv->section_lines_parsed < priv->curr_value->v.section.rows) {
      return PARSE_ERROR_TOO_FEW_ENTRIES;
    }
    verify_section(priv->curr_value);
  }
  key = mem_alloc(sizeof(*key));
  key->name = string_make(parser_getstr(p, "name"));
  key->comp = TUTORIAL_ARCHETYPE;
  value = mem_zalloc(sizeof(*value));
  if (!tutorial_dict_insert(priv->r->d, key, value)) {
    tutorial_value_free(value);
    tutorial_key_free(key);
    return PARSE_ERROR_DUPLICATED_NAME;
  }
  value->key = key;
  value->v.archetype.unspent_experience = -1;
  value->v.archetype.purge_kit = false;
  priv->curr_value = value;
  if (!priv->r->default_archetype) {
    priv->r->default_archetype = value;
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_note_block_start(struct parser* p)
{
  struct tutorial_parser_priv* priv =
      (struct tutorial_parser_priv*)parser_priv(p);
  struct tutorial_dict_key_type* key;
  struct tutorial_dict_val_type* value;
  if (priv->curr_value && priv->curr_value->key->comp == TUTORIAL_SECTION) {
    if (priv->section_lines_parsed < priv->curr_value->v.section.rows) {
      return PARSE_ERROR_TOO_FEW_ENTRIES;
    }
    verify_section(priv->curr_value);
  }
  key = mem_alloc(sizeof(*key));
  key->name = string_make(parser_getstr(p, "name"));
  key->comp = TUTORIAL_NOTE;
  value = mem_zalloc(sizeof(*value));
  if (!tutorial_dict_insert(priv->r->d, key, value)) {
    tutorial_value_free(value);
    tutorial_key_free(key);
    return PARSE_ERROR_DUPLICATED_NAME;
  }
  assert(priv->r->note_table_n >= 0 &&
         priv->r->note_table_n <= priv->r->note_table_a);
  if (priv->r->note_table_n == priv->r->note_table_a) {
    int new_a = (priv->r->note_table_a)
                    ? priv->r->note_table_a + priv->r->note_table_a
                    : 8;
    if (new_a > MAX_PVAL + 1) {
      return PARSE_ERROR_TOO_MANY_ENTRIES;
    }
    priv->r->note_table_a = new_a;
    priv->r->pval_to_note_table =
        mem_realloc(priv->r->pval_to_note_table,
                    new_a * sizeof(*priv->r->pval_to_note_table));
  }
  value->key = key;
  value->v.note.pval = priv->r->note_table_n;
  priv->curr_value = value;
  priv->r->pval_to_note_table[priv->r->note_table_n] = value;
  ++priv->r->note_table_n;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_trigger_block_start(struct parser* p)
{
  struct tutorial_parser_priv* priv =
      (struct tutorial_parser_priv*)parser_priv(p);
  struct tutorial_dict_key_type* key;
  struct tutorial_dict_val_type* value;
  if (priv->curr_value && priv->curr_value->key->comp == TUTORIAL_SECTION) {
    if (priv->section_lines_parsed < priv->curr_value->v.section.rows) {
      return PARSE_ERROR_TOO_FEW_ENTRIES;
    }
    verify_section(priv->curr_value);
  }
  key = mem_alloc(sizeof(*key));
  key->name = string_make(parser_getstr(p, "name"));
  key->comp = TUTORIAL_TRIGGER;
  value = mem_zalloc(sizeof(*value));
  if (!tutorial_dict_insert(priv->r->d, key, value)) {
    tutorial_value_free(value);
    tutorial_key_free(key);
    return PARSE_ERROR_DUPLICATED_NAME;
  }
  value->key = key;
  priv->curr_value = value;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_section_block_start(struct parser* p)
{
  struct tutorial_parser_priv* priv =
      (struct tutorial_parser_priv*)parser_priv(p);
  const char* name = parser_getstr(p, "name");
  struct tutorial_dict_key_type* key;
  struct tutorial_dict_val_type* value;
  if (priv->curr_value && priv->curr_value->key->comp == TUTORIAL_SECTION) {
    if (priv->section_lines_parsed < priv->curr_value->v.section.rows) {
      return PARSE_ERROR_TOO_FEW_ENTRIES;
    }
    verify_section(priv->curr_value);
  }
  key = mem_alloc(sizeof(*key));
  key->name = string_make(name);
  key->comp = TUTORIAL_SECTION;
  value = mem_zalloc(sizeof(*value));
  if (!tutorial_dict_insert(priv->r->d, key, value)) {
    tutorial_value_free(value);
    tutorial_key_free(key);
    return PARSE_ERROR_DUPLICATED_NAME;
  }
  value->key = key;
  value->v.section.symt = tutorial_section_sym_table_create();
  priv->curr_value = value;
  priv->section_lines_parsed = 0;
  if (!priv->r->default_section) {
    priv->r->default_section = value;
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_archetype_race(struct parser* p)
{
  struct tutorial_parser_priv* priv =
      (struct tutorial_parser_priv*)parser_priv(p);
  enum parser_error result = PARSE_ERROR_NONE;
  if (priv->curr_value->key->comp == TUTORIAL_ARCHETYPE) {
    const char* name = parser_getstr(p, "name");
    if (priv->curr_value->v.archetype.race_name) {
      string_free(priv->curr_value->v.archetype.race_name);
    }
    priv->curr_value->v.archetype.race_name = string_make(name);
  } else {
    result = PARSE_ERROR_UNDEFINED_DIRECTIVE;
  }
  return result;
}
STATIC_OVL enum parser_error
parse_archetype_house(struct parser* p)
{
  struct tutorial_parser_priv* priv =
      (struct tutorial_parser_priv*)parser_priv(p);
  enum parser_error result = PARSE_ERROR_NONE;
  if (priv->curr_value->key->comp == TUTORIAL_ARCHETYPE) {
    const char* name = parser_getstr(p, "name");
    if (priv->curr_value->v.archetype.house_name) {
      string_free(priv->curr_value->v.archetype.house_name);
    }
    priv->curr_value->v.archetype.house_name = string_make(name);
  } else {
    result = PARSE_ERROR_UNDEFINED_DIRECTIVE;
  }
  return result;
}
STATIC_OVL enum parser_error
parse_archetype_sex(struct parser* p)
{
  struct tutorial_parser_priv* priv =
      (struct tutorial_parser_priv*)parser_priv(p);
  enum parser_error result = PARSE_ERROR_NONE;
  if (priv->curr_value->key->comp == TUTORIAL_ARCHETYPE) {
    const char* name = parser_getstr(p, "name");
    if (priv->curr_value->v.archetype.sex_name) {
      string_free(priv->curr_value->v.archetype.sex_name);
    }
    priv->curr_value->v.archetype.sex_name = string_make(name);
  } else {
    result = PARSE_ERROR_UNDEFINED_DIRECTIVE;
  }
  return result;
}
STATIC_OVL enum parser_error
parse_archetype_character_name(struct parser* p)
{
  struct tutorial_parser_priv* priv =
      (struct tutorial_parser_priv*)parser_priv(p);
  enum parser_error result = PARSE_ERROR_NONE;
  if (priv->curr_value->key->comp == TUTORIAL_ARCHETYPE) {
    const char* name = parser_getstr(p, "name");
    if (priv->curr_value->v.archetype.character_name) {
      string_free(priv->curr_value->v.archetype.character_name);
    }
    priv->curr_value->v.archetype.character_name = string_make(name);
  } else {
    result = PARSE_ERROR_UNDEFINED_DIRECTIVE;
  }
  return result;
}
STATIC_OVL enum parser_error
parse_archetype_history(struct parser* p)
{
  struct tutorial_parser_priv* priv =
      (struct tutorial_parser_priv*)parser_priv(p);
  enum parser_error result = PARSE_ERROR_NONE;
  if (priv->curr_value->key->comp == TUTORIAL_ARCHETYPE) {
    const char* text = parser_getstr(p, "history");
    priv->curr_value->v.archetype.history =
        string_append(priv->curr_value->v.archetype.history, text);
  } else {
    result = PARSE_ERROR_UNDEFINED_DIRECTIVE;
  }
  return result;
}
STATIC_OVL enum parser_error
parse_archetype_experience(struct parser* p)
{
  struct tutorial_parser_priv* priv =
      (struct tutorial_parser_priv*)parser_priv(p);
  enum parser_error result = PARSE_ERROR_NONE;
  if (priv->curr_value->key->comp == TUTORIAL_ARCHETYPE) {
    const char* text = parser_getstr(p, "value");
    char* endptr;
    long lval = strtol(text, &endptr, 10);
    if (text[0] == '\0' || (*endptr != '\0' && !contains_only_spaces(endptr))) {
      result = PARSE_ERROR_INVALID_VALUE;
    } else {
      priv->curr_value->v.archetype.unspent_experience =
          (int32_t)MAX(0L, MIN(lval, 0x7FFFFFFFL));
    }
  } else {
    result = PARSE_ERROR_UNDEFINED_DIRECTIVE;
  }
  return result;
}
STATIC_OVL enum parser_error
parse_archetype_stats(struct parser* p)
{
  struct tutorial_parser_priv* priv =
      (struct tutorial_parser_priv*)parser_priv(p);
  enum parser_error result = PARSE_ERROR_NONE;
  if (priv->curr_value->key->comp == TUTORIAL_ARCHETYPE) {
    char* s = string_make(parser_getstr(p, "values"));
    char* t = strtok(s, " |");
    while (t) {
      int value = 0;
      int idx = 0;
      if (grab_index_and_int(&value, &idx, obj_mods, "", t) || idx < 1 ||
          idx > STAT_MAX) {
        result = PARSE_ERROR_INVALID_VALUE;
        break;
      }
      --idx;
      if (value >= 0 &&
          priv->curr_value->v.archetype.stat_adj[idx] > INT_MAX - value) {
        result = PARSE_ERROR_INVALID_VALUE;
        break;
      }
      if (value < 0 &&
          priv->curr_value->v.archetype.stat_adj[idx] < INT_MIN - value) {
        result = PARSE_ERROR_INVALID_VALUE;
        break;
      }
      priv->curr_value->v.archetype.stat_adj[idx] += value;
      t = strtok(NULL, " |");
    }
    string_free(s);
  } else {
    result = PARSE_ERROR_UNDEFINED_DIRECTIVE;
  }
  return result;
}
STATIC_OVL enum parser_error
parse_archetype_skills(struct parser* p)
{
  struct tutorial_parser_priv* priv =
      (struct tutorial_parser_priv*)parser_priv(p);
  enum parser_error result = PARSE_ERROR_NONE;
  if (priv->curr_value->key->comp == TUTORIAL_ARCHETYPE) {
    char* s = string_make(parser_getstr(p, "values"));
    char* t = strtok(s, " |");
    while (t) {
      int value = 0;
      int idx = 0;
      if (grab_index_and_int(&value, &idx, obj_mods, "", t) ||
          idx < STAT_MAX + 1 || idx > STAT_MAX + SKILL_MAX) {
        result = PARSE_ERROR_INVALID_VALUE;
        break;
      }
      idx -= STAT_MAX + 1;
      if (value >= 0 &&
          priv->curr_value->v.archetype.skill_adj[idx] > INT_MAX - value) {
        result = PARSE_ERROR_INVALID_VALUE;
        break;
      }
      if (value < 0 &&
          priv->curr_value->v.archetype.skill_adj[idx] < INT_MIN - value) {
        result = PARSE_ERROR_INVALID_VALUE;
        break;
      }
      priv->curr_value->v.archetype.skill_adj[idx] += value;
      t = strtok(NULL, " |");
    }
    string_free(s);
  } else {
    result = PARSE_ERROR_UNDEFINED_DIRECTIVE;
  }
  return result;
}
STATIC_OVL enum parser_error
parse_archetype_abilities(struct parser* p)
{
  struct tutorial_parser_priv* priv =
      (struct tutorial_parser_priv*)parser_priv(p);
  enum parser_error result = PARSE_ERROR_NONE;
  if (priv->curr_value->key->comp == TUTORIAL_ARCHETYPE) {
    char* s = string_make(parser_getstr(p, "values"));
    char* t = s;
    while (1) {
      char* tnext;
      bool done;
      int idx;
      char* rb;
      struct ability* ab;
      tnext = t + strcspn(t, " |");
      if (tnext == t) {
        if (*tnext) {
          t = tnext + 1;
          continue;
        }
        break;
      }
      while (*tnext == ' ' && *(tnext - 1) != ']') {
        tnext += 1 + strcspn(tnext + 1, " |");
      }
      if (*tnext) {
        *tnext = '\0';
        ++tnext;
        done = false;
      } else {
        done = true;
      }
      idx = STAT_MAX + 1;
      while (1) {
        if (idx > STAT_MAX + SKILL_MAX) {
          result = PARSE_ERROR_INVALID_SKILL;
          break;
        }
        if (prefix(t, obj_mods[idx]) && t[strlen(obj_mods[idx])] == '[') {
          break;
        }
        ++idx;
      }
      if (result != PARSE_ERROR_NONE) {
        break;
      }
      t += strlen(obj_mods[idx]) + 1;
      rb = strchr(t, ']');
      if (!rb || rb[1]) {
        result = PARSE_ERROR_INVALID_ABILITY;
        break;
      }
      *rb = '\0';
      ab = lookup_ability(idx - STAT_MAX - 1, t);
      if (!ab) {
        result = PARSE_ERROR_INVALID_ABILITY;
        break;
      }
      assert(priv->curr_value->v.archetype.ability_count >= 0 &&
             priv->curr_value->v.archetype.ability_count <=
                 priv->curr_value->v.archetype.ability_alloc);
      if (priv->curr_value->v.archetype.ability_count ==
          priv->curr_value->v.archetype.ability_alloc) {
        if (!priv->curr_value->v.archetype.ability_alloc) {
          priv->curr_value->v.archetype.ability_alloc = 4;
        } else if (priv->curr_value->v.archetype.ability_alloc >= 1024) {
          result = PARSE_ERROR_TOO_MANY_ENTRIES;
          break;
        } else {
          priv->curr_value->v.archetype.ability_alloc +=
              priv->curr_value->v.archetype.ability_alloc;
        }
        priv->curr_value->v.archetype.added_abilities = mem_realloc(
            priv->curr_value->v.archetype.added_abilities,
            priv->curr_value->v.archetype.ability_alloc *
                sizeof(*priv->curr_value->v.archetype.added_abilities));
      }
      priv->curr_value->v.archetype
          .added_abilities[priv->curr_value->v.archetype.ability_count] = ab;
      ++priv->curr_value->v.archetype.ability_count;
      if (done) {
        break;
      }
      t = tnext;
    }
    string_free(s);
  } else {
    result = PARSE_ERROR_UNDEFINED_DIRECTIVE;
  }
  return result;
}
STATIC_OVL enum parser_error
parse_archetype_object(struct parser* p)
{
  struct tutorial_parser_priv* priv =
      (struct tutorial_parser_priv*)parser_priv(p);
  const char* numstr = parser_getsym(p, "number");
  const char* eqstr = parser_getsym(p, "equipped");
  int tval, sval;
  dice_t* numdice;
  struct tutorial_kit_item* this_kit;
  if (priv->curr_value->key->comp != TUTORIAL_ARCHETYPE) {
    return PARSE_ERROR_UNDEFINED_DIRECTIVE;
  }
  tval = tval_find_idx(parser_getsym(p, "tval"));
  if (tval < 0) {
    return PARSE_ERROR_UNRECOGNISED_TVAL;
  }
  sval = lookup_sval(tval, parser_getsym(p, "sval"));
  if (sval < 0) {
    return PARSE_ERROR_UNRECOGNISED_SVAL;
  }
  assert(priv->curr_value->v.archetype.kit_count >= 0 &&
         priv->curr_value->v.archetype.kit_count <=
             priv->curr_value->v.archetype.kit_alloc);
  if (priv->curr_value->v.archetype.kit_count ==
      priv->curr_value->v.archetype.kit_alloc) {
    if (!priv->curr_value->v.archetype.kit_count) {
      priv->curr_value->v.archetype.kit_alloc = 4;
    } else if (priv->curr_value->v.archetype.kit_alloc >= 128) {
      return PARSE_ERROR_TOO_MANY_ENTRIES;
    } else {
      priv->curr_value->v.archetype.kit_alloc +=
          priv->curr_value->v.archetype.kit_alloc;
    }
    priv->curr_value->v.archetype.kit =
        mem_realloc(priv->curr_value->v.archetype.kit,
                    priv->curr_value->v.archetype.kit_alloc *
                        sizeof(*priv->curr_value->v.archetype.kit));
  }
  this_kit = priv->curr_value->v.archetype.kit +
             priv->curr_value->v.archetype.kit_count;
  numdice = dice_new();
  if (dice_parse_string(numdice, numstr)) {
    dice_random_value(numdice, &this_kit->item.v.details.number);
    dice_free(numdice);
  } else {
    dice_free(numdice);
    return PARSE_ERROR_INVALID_DICE;
  }
  ++priv->curr_value->v.archetype.kit_count;
  this_kit->item.v.details.ego = NULL;
  this_kit->item.v.details.tweaks = NULL;
  this_kit->item.v.details.tval = tval;
  this_kit->item.v.details.sval = sval;
  this_kit->item.v.details.tweak_count = 0;
  this_kit->item.is_artifact = false;
  this_kit->equipped = (my_stricmp(eqstr, "yes") == 0);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_archetype_complex_object(struct parser* p)
{
  struct tutorial_parser_priv* priv =
      (struct tutorial_parser_priv*)parser_priv(p);
  const char* numstr = parser_getsym(p, "number");
  const char* eqstr = parser_getsym(p, "equipped");
  const char* ego = parser_getsym(p, "ego");
  const char* props = parser_getsym(p, "properties");
  const char* mods = parser_getstr(p, "modifiers");
  int tval, sval;
  struct tutorial_item_tweak* tweaks;
  int tweak_count, tweak_alloc;
  enum parser_error tweak_result;
  dice_t* numdice;
  struct tutorial_kit_item* this_kit;
  if (priv->curr_value->key->comp != TUTORIAL_ARCHETYPE) {
    return PARSE_ERROR_UNDEFINED_DIRECTIVE;
  }
  tval = tval_find_idx(parser_getsym(p, "tval"));
  if (tval < 0) {
    return PARSE_ERROR_UNRECOGNISED_TVAL;
  }
  sval = lookup_sval(tval, parser_getsym(p, "sval"));
  if (sval < 0) {
    return PARSE_ERROR_UNRECOGNISED_SVAL;
  }
  assert(priv->curr_value->v.archetype.kit_count >= 0 &&
         priv->curr_value->v.archetype.kit_count <=
             priv->curr_value->v.archetype.kit_alloc);
  if (priv->curr_value->v.archetype.kit_count ==
      priv->curr_value->v.archetype.kit_alloc) {
    if (!priv->curr_value->v.archetype.kit_count) {
      priv->curr_value->v.archetype.kit_alloc = 4;
    } else if (priv->curr_value->v.archetype.kit_alloc >= 128) {
      return PARSE_ERROR_TOO_MANY_ENTRIES;
    } else {
      priv->curr_value->v.archetype.kit_alloc +=
          priv->curr_value->v.archetype.kit_alloc;
    }
    priv->curr_value->v.archetype.kit =
        mem_realloc(priv->curr_value->v.archetype.kit,
                    priv->curr_value->v.archetype.kit_alloc *
                        sizeof(*priv->curr_value->v.archetype.kit));
  }
  tweak_result =
      tutorial_parse_tweaks(&tweaks, &tweak_count, &tweak_alloc, props, mods);
  if (tweak_result != PARSE_ERROR_NONE) {
    tutorial_item_tweaks_free(tweaks, tweak_count);
    return tweak_result;
  }
  this_kit = priv->curr_value->v.archetype.kit +
             priv->curr_value->v.archetype.kit_count;
  numdice = dice_new();
  if (dice_parse_string(numdice, numstr)) {
    dice_random_value(numdice, &this_kit->item.v.details.number);
    dice_free(numdice);
  } else {
    dice_free(numdice);
    tutorial_item_tweaks_free(tweaks, tweak_count);
    return PARSE_ERROR_INVALID_DICE;
  }
  ++priv->curr_value->v.archetype.kit_count;
  this_kit->item.v.details.ego =
      streq(ego, "NONE") ? NULL : lookup_ego_item(ego, tval, sval);
  this_kit->item.v.details.tweaks = tweaks;
  this_kit->item.v.details.tval = tval;
  this_kit->item.v.details.sval = sval;
  this_kit->item.v.details.tweak_count = tweak_count;
  this_kit->item.is_artifact = false;
  this_kit->equipped = (my_stricmp(eqstr, "yes") == 0);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_archetype_artifact(struct parser* p)
{
  struct tutorial_parser_priv* priv =
      (struct tutorial_parser_priv*)parser_priv(p);
  const char* eqstr = parser_getsym(p, "equipped");
  const struct artifact* art;
  struct tutorial_kit_item* this_kit;
  if (priv->curr_value->key->comp != TUTORIAL_ARCHETYPE) {
    return PARSE_ERROR_UNDEFINED_DIRECTIVE;
  }
  art = lookup_artifact_name(parser_getsym(p, "name"));
  if (!art) {
    return PARSE_ERROR_NO_ARTIFACT_NAME;
  }
  assert(priv->curr_value->v.archetype.kit_count >= 0 &&
         priv->curr_value->v.archetype.kit_count <=
             priv->curr_value->v.archetype.kit_alloc);
  if (priv->curr_value->v.archetype.kit_count ==
      priv->curr_value->v.archetype.kit_alloc) {
    if (!priv->curr_value->v.archetype.kit_count) {
      priv->curr_value->v.archetype.kit_alloc = 4;
    } else if (priv->curr_value->v.archetype.kit_alloc >= 128) {
      return PARSE_ERROR_TOO_MANY_ENTRIES;
    } else {
      priv->curr_value->v.archetype.kit_alloc +=
          priv->curr_value->v.archetype.kit_alloc;
    }
    priv->curr_value->v.archetype.kit =
        mem_realloc(priv->curr_value->v.archetype.kit,
                    priv->curr_value->v.archetype.kit_alloc *
                        sizeof(*priv->curr_value->v.archetype.kit));
  }
  this_kit = priv->curr_value->v.archetype.kit +
             priv->curr_value->v.archetype.kit_count;
  ++priv->curr_value->v.archetype.kit_count;
  this_kit->item.v.art = art;
  this_kit->item.is_artifact = true;
  this_kit->equipped = (my_stricmp(eqstr, "yes") == 0);
  return PARSE_ERROR_NONE;
}
STATIC_OVL void
add_trigger_op(struct trigger_compiled_op** c, int* n_c, int* a_c,
               enum trigger_op_kind kind, int tval, int sval, int idx,
               char* name)
{
  struct trigger_compiled_op* this_op;
  assert(*n_c >= 0 && *n_c <= *a_c);
  if (*n_c == *a_c) {
    *a_c = (*a_c) ? *a_c + (*a_c) : 4;
    *c = mem_realloc(*c, *a_c * sizeof(**c));
  }
  this_op = (*c) + (*n_c);
  ++*n_c;
  this_op->kind = kind;
  this_op->tval = tval;
  this_op->sval = sval;
  this_op->idx = idx;
  this_op->name = name;
}
STATIC_OVL int
get_drained_index(const char* name)
{
  int result = 0;
  while (1) {
    if (result < STAT_MAX) {
      if (streq(name, obj_mods[result + 1])) {
        return result;
      } else {
        ++result;
      }
    } else if (streq(name, "HEALTH")) {
      return STAT_MAX;
    } else if (streq(name, "VOICE")) {
      return STAT_MAX + 1;
    } else {
      return -1;
    }
  }
}
STATIC_OVL enum parser_error
parse_trigger_condition(struct parser* p)
{
  struct tutorial_parser_priv* priv =
      (struct tutorial_parser_priv*)parser_priv(p);
  struct trigger_nesting {
    enum trigger_op_kind pend[2];
    bool expect_binary;
  } * n;
  int n_n, a_n;
  struct trigger_compiled_op* c;
  int n_c, a_c;
  const char* s_expr;
  int i, curr_stack;
  if (priv->curr_value->key->comp != TUTORIAL_TRIGGER) {
    return PARSE_ERROR_UNDEFINED_DIRECTIVE;
  }
  if (priv->curr_value->v.trigger.expr.ops) {
    return PARSE_ERROR_TOO_MANY_ENTRIES;
  }
  a_n = 4;
  n_n = 1;
  n = mem_alloc(a_n * sizeof(*n));
  n[0].pend[0] = TRIGGER_OP_NONE;
  n[0].pend[1] = TRIGGER_OP_NONE;
  n[0].expect_binary = false;
  n_c = 0;
  a_c = 0;
  c = NULL;
  s_expr = parser_getstr(p, "expression");
  while (*s_expr) {
    const char *rb, *term, *colon;
    char *tmp, *name;
    enum trigger_op_kind kind;
    int tval, sval, idx;
    assert(n_n > 0);
    switch (*s_expr) {
      case ' ':
      case '\t':
        ++s_expr;
        break;
      case '(':
        if (n[n_n - 1].expect_binary) {
          free_trigger_compiled_ops(c, n_c);
          mem_free(n);
          return PARSE_ERROR_INVALID_EXPRESSION;
        }
        ++s_expr;
        if (n_n == a_n) {
          a_n += a_n;
          n = mem_realloc(n, a_n * sizeof(*n));
        }
        n[n_n].pend[0] = TRIGGER_OP_NONE;
        n[n_n].pend[1] = TRIGGER_OP_NONE;
        n[n_n].expect_binary = false;
        ++n_n;
        break;
      case ')':
        if (n_n == 1 || n[n_n - 1].expect_binary) {
          free_trigger_compiled_ops(c, n_c);
          mem_free(n);
          return PARSE_ERROR_INVALID_EXPRESSION;
        }
        ++s_expr;
        if (n[n_n - 1].pend[1] != TRIGGER_OP_NONE) {
          assert(n[n_n - 1].pend[1] == TRIGGER_OP_NOT);
          add_trigger_op(&c, &n_c, &a_c, n[n_n - 1].pend[1], 0, 0, 0, NULL);
        }
        if (n[n_n - 1].pend[0] != TRIGGER_OP_NONE) {
          assert(n[n_n - 1].pend[0] == TRIGGER_OP_AND ||
                 n[n_n - 1].pend[0] == TRIGGER_OP_NOT ||
                 n[n_n - 1].pend[0] == TRIGGER_OP_OR ||
                 n[n_n - 1].pend[0] == TRIGGER_OP_XOR);
          add_trigger_op(&c, &n_c, &a_c, n[n_n - 1].pend[0], 0, 0, 0, NULL);
        }
        --n_n;
        if (n[n_n - 1].pend[1] != TRIGGER_OP_NONE) {
          assert(n[n_n - 1].pend[1] == TRIGGER_OP_NOT);
          add_trigger_op(&c, &n_c, &a_c, n[n_n - 1].pend[1], 0, 0, 0, NULL);
          n[n_n - 1].pend[1] = TRIGGER_OP_NONE;
        }
        if (n[n_n - 1].pend[0] != TRIGGER_OP_NONE) {
          assert(n[n_n - 1].pend[0] == TRIGGER_OP_AND ||
                 n[n_n - 1].pend[0] == TRIGGER_OP_NOT ||
                 n[n_n - 1].pend[0] == TRIGGER_OP_OR ||
                 n[n_n - 1].pend[0] == TRIGGER_OP_XOR);
          add_trigger_op(&c, &n_c, &a_c, n[n_n - 1].pend[0], 0, 0, 0, NULL);
          n[n_n - 1].pend[0] = TRIGGER_OP_NONE;
        }
        n[n_n - 1].expect_binary = true;
        break;
      case 'a':
        if (!n[n_n - 1].expect_binary || *(s_expr + 1) != 'n' ||
            *(s_expr + 2) != 'd') {
          free_trigger_compiled_ops(c, n_c);
          mem_free(n);
          return PARSE_ERROR_INVALID_EXPRESSION;
        }
        s_expr += 3;
        assert(n[n_n - 1].pend[0] == TRIGGER_OP_NONE);
        n[n_n - 1].pend[0] = TRIGGER_OP_AND;
        n[n_n - 1].expect_binary = false;
        break;
      case 'n':
        if (n[n_n - 1].expect_binary || *(s_expr + 1) != 'o' ||
            *(s_expr + 2) != 't') {
          free_trigger_compiled_ops(c, n_c);
          mem_free(n);
          return PARSE_ERROR_INVALID_EXPRESSION;
        }
        s_expr += 3;
        if (n[n_n - 1].pend[0] == TRIGGER_OP_NONE) {
          n[n_n - 1].pend[0] = TRIGGER_OP_NOT;
        } else {
          assert(n[n_n - 1].pend[1] == TRIGGER_OP_NONE);
          n[n_n - 1].pend[1] = TRIGGER_OP_NOT;
        }
        break;
      case 'o':
        if (!n[n_n - 1].expect_binary || *(s_expr + 1) != 'r') {
          free_trigger_compiled_ops(c, n_c);
          mem_free(n);
          return PARSE_ERROR_INVALID_EXPRESSION;
        }
        s_expr += 2;
        assert(n[n_n - 1].pend[0] == TRIGGER_OP_NONE);
        n[n_n - 1].pend[0] = TRIGGER_OP_OR;
        n[n_n - 1].expect_binary = false;
        break;
      case 'x':
        if (!n[n_n - 1].expect_binary || *(s_expr + 1) != 'o' ||
            *(s_expr + 2) != 'r') {
          free_trigger_compiled_ops(c, n_c);
          mem_free(n);
          return PARSE_ERROR_INVALID_EXPRESSION;
        }
        s_expr += 3;
        assert(n[n_n - 1].pend[0] == TRIGGER_OP_NONE);
        n[n_n - 1].pend[0] = TRIGGER_OP_XOR;
        n[n_n - 1].expect_binary = false;
        break;
      case '{':
        term = s_expr + 1;
        rb = term;
        while (1) {
          rb = strchr(rb, '}');
          if (!rb || !tutorial_text_escaped(rb, term)) {
            break;
          }
          ++rb;
        }
        if (n[n_n - 1].expect_binary || !rb) {
          free_trigger_compiled_ops(c, n_c);
          mem_free(n);
          return PARSE_ERROR_INVALID_EXPRESSION;
        }
        s_expr = rb + 1;
        idx = 0;
        tval = 0;
        sval = 0;
        name = NULL;
        if (prefix(term, "ability:")) {
          enum parser_error ec = PARSE_ERROR_NONE;
          term += 8;
          kind = TRIGGER_OP_ABILITY;
          colon = term;
          while (1) {
            colon = strchr(colon, ':');
            if (!colon || !tutorial_text_escaped(colon, term)) {
              break;
            }
            ++colon;
          }
          if (colon && colon < rb) {
            tmp = mem_alloc((colon - term) + 1);
            (void)tutorial_copy_strip_escapes(tmp, (colon - term) + 1, term,
                                              colon - term);
            idx = code_index_in_array(obj_mods, tmp);
            if (idx >= STAT_MAX + 1 && idx <= STAT_MAX + SKILL_MAX) {
              idx -= STAT_MAX + 1;
            } else {
              ec = PARSE_ERROR_UNRECOGNISED_SKILL;
            }
            mem_free(tmp);
          } else {
            ec = PARSE_ERROR_UNRECOGNISED_SKILL;
          }
          if (ec != PARSE_ERROR_NONE) {
            free_trigger_compiled_ops(c, n_c);
            mem_free(n);
            return ec;
          }
          term = colon + 1;
          name = mem_alloc((rb - term) + 1);
          (void)tutorial_copy_strip_escapes(name, (rb - term) + 1, term,
                                            rb - term);
        } else if (prefix(term, "carried:")) {
          enum parser_error ec = PARSE_ERROR_NONE;
          term += 8;
          kind = TRIGGER_OP_CARRIED;
          colon = term;
          while (1) {
            colon = strchr(colon, ':');
            if (!colon || !tutorial_text_escaped(colon, term)) {
              break;
            }
            ++colon;
          }
          if (colon && colon < rb) {
            tmp = mem_alloc((colon - term) + 1);
            (void)tutorial_copy_strip_escapes(tmp, (colon - term) + 1, term,
                                              colon - term);
            tval = tval_find_idx(tmp);
            mem_free(tmp);
            term = colon + 1;
            if (tval < 0) {
              ec = PARSE_ERROR_UNRECOGNISED_TVAL;
            }
          } else {
            ec = PARSE_ERROR_INVALID_EXPRESSION;
          }
          if (tval > 0) {
            tmp = mem_alloc((rb - term) + 1);
            (void)tutorial_copy_strip_escapes(tmp, (rb - term) + 1, term,
                                              rb - term);
            if (streq(tmp, "*")) {
              sval = -1;
            } else {
              sval = lookup_sval(tval, tmp);
              if (sval < 0) {
                ec = PARSE_ERROR_UNRECOGNISED_SVAL;
              }
            }
            mem_free(tmp);
          }
          if (ec != PARSE_ERROR_NONE) {
            free_trigger_compiled_ops(c, n_c);
            mem_free(n);
            return ec;
          }
        } else if (prefix(term, "drained:")) {
          term += 8;
          kind = TRIGGER_OP_DRAINED;
          tmp = mem_alloc((rb - term) + 1);
          (void)tutorial_copy_strip_escapes(tmp, (rb - term) + 1, term,
                                            rb - term);
          idx = get_drained_index(tmp);
          mem_free(tmp);
          if (idx == -1) {
            free_trigger_compiled_ops(c, n_c);
            mem_free(n);
            return PARSE_ERROR_INVALID_EXPRESSION;
          }
        } else if (prefix(term, "equipped:")) {
          enum parser_error ec = PARSE_ERROR_NONE;
          term += 9;
          kind = TRIGGER_OP_EQUIPPED;
          colon = term;
          while (1) {
            colon = strchr(colon, ':');
            if (!colon || !tutorial_text_escaped(colon, term)) {
              break;
            }
            ++colon;
          }
          if (colon && colon < rb) {
            tmp = mem_alloc((colon - term) + 1);
            (void)tutorial_copy_strip_escapes(tmp, (colon - term) + 1, term,
                                              colon - term);
            tval = tval_find_idx(tmp);
            mem_free(tmp);
            term = colon + 1;
            if (tval < 0) {
              ec = PARSE_ERROR_UNRECOGNISED_TVAL;
            }
          } else {
            ec = PARSE_ERROR_INVALID_EXPRESSION;
          }
          if (tval > 0) {
            tmp = mem_alloc((rb - term) + 1);
            (void)tutorial_copy_strip_escapes(tmp, (rb - term) + 1, term,
                                              rb - term);
            if (streq(tmp, "*")) {
              sval = -1;
            } else {
              sval = lookup_sval(tval, tmp);
              if (sval < 0) {
                ec = PARSE_ERROR_UNRECOGNISED_SVAL;
              }
            }
            mem_free(tmp);
          }
          if (ec != PARSE_ERROR_NONE) {
            free_trigger_compiled_ops(c, n_c);
            mem_free(n);
            return ec;
          }
        } else if (prefix(term, "false}")) {
          kind = TRIGGER_OP_FALSE;
        } else if (prefix(term, "timed:")) {
          enum parser_error ec = PARSE_ERROR_NONE;
          term += 6;
          colon = term;
          while (1) {
            colon = strchr(colon, ':');
            if (!colon || !tutorial_text_escaped(colon, term)) {
              break;
            }
            ++colon;
          }
          if (colon && colon < rb) {
            tmp = mem_alloc((colon - term) + 1);
            (void)tutorial_copy_strip_escapes(tmp, (colon - term) + 1, term,
                                              colon - term);
            idx = timed_name_to_idx(tmp);
            mem_free(tmp);
            if (idx < 0) {
              ec = PARSE_ERROR_INVALID_EXPRESSION;
            }
            term = colon + 1;
            if (prefix(term, "above:")) {
              kind = TRIGGER_OP_TIMED_ABOVE;
              term += 6;
            } else if (prefix(term, "below:")) {
              kind = TRIGGER_OP_TIMED_BELOW;
              term += 6;
            } else {
              ec = PARSE_ERROR_INVALID_EXPRESSION;
            }
            if (ec != PARSE_ERROR_INVALID_EXPRESSION) {
              name = mem_alloc((rb - term) + 1);
              (void)tutorial_copy_strip_escapes(name, (rb - term) + 1, term,
                                                rb - term);
            }
          } else {
            kind = TRIGGER_OP_TIMED;
            tmp = mem_alloc((rb - term) + 1);
            (void)tutorial_copy_strip_escapes(tmp, (rb - term) + 1, term,
                                              rb - term);
            idx = timed_name_to_idx(tmp);
            mem_free(tmp);
            if (idx < 0) {
              ec = PARSE_ERROR_INVALID_EXPRESSION;
            }
          }
          if (ec != PARSE_ERROR_NONE) {
            free_trigger_compiled_ops(c, n_c);
            mem_free(n);
            return ec;
          }
        } else if (prefix(term, "true}")) {
          kind = TRIGGER_OP_TRUE;
        } else {
          free_trigger_compiled_ops(c, n_c);
          mem_free(n);
          return PARSE_ERROR_INVALID_EXPRESSION;
        }
        add_trigger_op(&c, &n_c, &a_c, kind, tval, sval, idx, name);
        if (n[n_n - 1].pend[1] != TRIGGER_OP_NONE) {
          assert(n[n_n - 1].pend[1] == TRIGGER_OP_NOT);
          add_trigger_op(&c, &n_c, &a_c, n[n_n - 1].pend[1], 0, 0, 0, NULL);
          n[n_n - 1].pend[1] = TRIGGER_OP_NONE;
        }
        if (n[n_n - 1].pend[0] != TRIGGER_OP_NONE) {
          assert(n[n_n - 1].pend[0] == TRIGGER_OP_AND ||
                 n[n_n - 1].pend[0] == TRIGGER_OP_NOT ||
                 n[n_n - 1].pend[0] == TRIGGER_OP_OR ||
                 n[n_n - 1].pend[0] == TRIGGER_OP_XOR);
          add_trigger_op(&c, &n_c, &a_c, n[n_n - 1].pend[0], 0, 0, 0, NULL);
          n[n_n - 1].pend[0] = TRIGGER_OP_NONE;
        }
        n[n_n - 1].expect_binary = true;
        break;
      default:
        free_trigger_compiled_ops(c, n_c);
        mem_free(n);
        return PARSE_ERROR_INVALID_EXPRESSION;
    }
  }
  mem_free(n);
  priv->curr_value->v.trigger.expr.ops = c;
  priv->curr_value->v.trigger.expr.n_op = n_c;
  priv->curr_value->v.trigger.expr.n_stack = 0;
  for (i = 0, curr_stack = 0; i < n_c; ++i) {
    switch (c[i].kind) {
      case TRIGGER_OP_ABILITY:
      case TRIGGER_OP_CARRIED:
      case TRIGGER_OP_DRAINED:
      case TRIGGER_OP_EQUIPPED:
      case TRIGGER_OP_FALSE:
      case TRIGGER_OP_TIMED:
      case TRIGGER_OP_TIMED_ABOVE:
      case TRIGGER_OP_TIMED_BELOW:
      case TRIGGER_OP_TRUE:
        ++curr_stack;
        if (priv->curr_value->v.trigger.expr.n_stack < curr_stack) {
          priv->curr_value->v.trigger.expr.n_stack = curr_stack;
        }
        break;
      case TRIGGER_OP_NOT:
        assert(curr_stack > 0);
        break;
      case TRIGGER_OP_AND:
      case TRIGGER_OP_OR:
      case TRIGGER_OP_XOR:
        assert(curr_stack > 1);
        --curr_stack;
        break;
      default:
        assert(0);
        break;
    }
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_section_rows(struct parser* p)
{
  struct tutorial_parser_priv* priv =
      (struct tutorial_parser_priv*)parser_priv(p);
  enum parser_error result = PARSE_ERROR_NONE;
  if (priv->curr_value->key->comp == TUTORIAL_SECTION) {
    int rows = parser_getint(p, "value");
    if (rows > 0 && rows < z_info->dungeon_hgt - 1) {
      if (!priv->curr_value->v.section.lines) {
        priv->curr_value->v.section.rows = rows;
      } else {
        result = PARSE_ERROR_NON_SEQUENTIAL_RECORDS;
      }
    } else {
      result = PARSE_ERROR_INVALID_VALUE;
    }
  } else {
    result = PARSE_ERROR_UNDEFINED_DIRECTIVE;
  }
  return result;
}
STATIC_OVL enum parser_error
parse_section_columns(struct parser* p)
{
  struct tutorial_parser_priv* priv =
      (struct tutorial_parser_priv*)parser_priv(p);
  enum parser_error result = PARSE_ERROR_NONE;
  if (priv->curr_value->key->comp == TUTORIAL_SECTION) {
    int columns = parser_getint(p, "value");
    if (columns > 0 && columns < z_info->dungeon_wid - 1) {
      if (!priv->curr_value->v.section.lines) {
        priv->curr_value->v.section.columns = columns;
      } else {
        result = PARSE_ERROR_NON_SEQUENTIAL_RECORDS;
      }
    } else {
      result = PARSE_ERROR_INVALID_VALUE;
    }
  } else {
    result = PARSE_ERROR_UNDEFINED_DIRECTIVE;
  }
  return result;
}
STATIC_OVL enum parser_error
parse_section_area_flag(struct parser* p)
{
  struct tutorial_parser_priv* priv =
      (struct tutorial_parser_priv*)parser_priv(p);
  enum parser_error result = PARSE_ERROR_NONE;
  if (priv->curr_value->key->comp == TUTORIAL_SECTION) {
    result = tutorial_add_area_flags(p, priv->curr_value, false);
  } else {
    result = PARSE_ERROR_UNDEFINED_DIRECTIVE;
  }
  return result;
}
STATIC_OVL enum parser_error
parse_section_clear_area_flag(struct parser* p)
{
  struct tutorial_parser_priv* priv =
      (struct tutorial_parser_priv*)parser_priv(p);
  enum parser_error result = PARSE_ERROR_NONE;
  if (priv->curr_value->key->comp == TUTORIAL_SECTION) {
    result = tutorial_add_area_flags(p, priv->curr_value, true);
  } else {
    result = PARSE_ERROR_UNDEFINED_DIRECTIVE;
  }
  return result;
}
STATIC_OVL enum parser_error
parse_section_start_note(struct parser* p)
{
  struct tutorial_parser_priv* priv =
      (struct tutorial_parser_priv*)parser_priv(p);
  enum parser_error result = PARSE_ERROR_NONE;
  if (priv->curr_value->key->comp == TUTORIAL_SECTION) {
    const char* name = parser_getstr(p, "name");
    if (priv->curr_value->v.section.start_note_name) {
      string_free(priv->curr_value->v.section.start_note_name);
    }
    priv->curr_value->v.section.start_note_name = string_make(name);
  } else {
    result = PARSE_ERROR_UNDEFINED_DIRECTIVE;
  }
  return result;
}
STATIC_OVL enum parser_error
parse_trigger_or_section_death_note(struct parser* p)
{
  struct tutorial_parser_priv* priv =
      (struct tutorial_parser_priv*)parser_priv(p);
  enum parser_error result = PARSE_ERROR_NONE;
  if (priv->curr_value->key->comp == TUTORIAL_TRIGGER) {
    const char* name = parser_getstr(p, "name");
    if (priv->curr_value->v.trigger.death_note_name) {
      string_free(priv->curr_value->v.trigger.death_note_name);
    }
    priv->curr_value->v.trigger.death_note_name =
        (name[0]) ? string_make(name) : NULL;
    priv->curr_value->v.trigger.changes_death_note = true;
  } else if (priv->curr_value->key->comp == TUTORIAL_SECTION) {
    const char* name = parser_getstr(p, "name");
    if (priv->curr_value->v.section.death_note_name) {
      string_free(priv->curr_value->v.section.death_note_name);
    }
    priv->curr_value->v.section.death_note_name = string_make(name);
  } else {
    result = PARSE_ERROR_UNDEFINED_DIRECTIVE;
  }
  return result;
}
STATIC_OVL enum parser_error
parse_section_note(struct parser* p)
{
  struct tutorial_parser_priv* priv =
      (struct tutorial_parser_priv*)parser_priv(p);
  struct tutorial_section_sym_key* key;
  enum parser_error result;
  if (priv->curr_value->key->comp != TUTORIAL_SECTION) {
    return PARSE_ERROR_UNDEFINED_DIRECTIVE;
  }
  result = tutorial_section_parse_symbol(
      parser_getsym(p, "symbol"), priv, priv->curr_value->v.section.symt, &key);
  if (result == PARSE_ERROR_NONE) {
    struct tutorial_section_sym_val* value = mem_alloc(sizeof(*value));
    value->v.name = string_make(parser_getstr(p, "name"));
    value->is_predefined = false;
    value->kind = SECTION_SYM_NOTE;
    if (!tutorial_section_sym_table_insert(priv->curr_value->v.section.symt,
                                           key, value)) {
      tutorial_section_sym_value_free(value);
      mem_free(key);
      result = PARSE_ERROR_DUPLICATED_SYMBOL;
    }
  }
  return result;
}
STATIC_OVL enum parser_error
parse_section_trigger(struct parser* p)
{
  struct tutorial_parser_priv* priv =
      (struct tutorial_parser_priv*)parser_priv(p);
  struct tutorial_section_sym_key* key;
  enum parser_error result;
  if (priv->curr_value->key->comp != TUTORIAL_SECTION) {
    return PARSE_ERROR_UNDEFINED_DIRECTIVE;
  }
  result = tutorial_section_parse_symbol(
      parser_getsym(p, "symbol"), priv, priv->curr_value->v.section.symt, &key);
  if (result == PARSE_ERROR_NONE) {
    struct tutorial_section_sym_val* value = mem_alloc(sizeof(*value));
    value->v.name = string_make(parser_getstr(p, "name"));
    value->is_predefined = false;
    value->kind = SECTION_SYM_TRIGGER;
    if (!tutorial_section_sym_table_insert(priv->curr_value->v.section.symt,
                                           key, value)) {
      tutorial_section_sym_value_free(value);
      mem_free(key);
      result = PARSE_ERROR_DUPLICATED_SYMBOL;
    }
  }
  return result;
}
STATIC_OVL enum parser_error
parse_section_gate(struct parser* p)
{
  struct tutorial_parser_priv* priv =
      (struct tutorial_parser_priv*)parser_priv(p);
  int feat;
  struct tutorial_section_sym_key* key;
  enum parser_error result;
  if (priv->curr_value->key->comp != TUTORIAL_SECTION) {
    return PARSE_ERROR_UNDEFINED_DIRECTIVE;
  }
  feat = lookup_feat(parser_getsym(p, "terrain"));
  if (feat < 0) {
    return PARSE_ERROR_INVALID_TERRAIN;
  }
  result = tutorial_section_parse_symbol(
      parser_getsym(p, "symbol"), priv, priv->curr_value->v.section.symt, &key);
  if (result == PARSE_ERROR_NONE) {
    struct tutorial_section_sym_val* value = mem_alloc(sizeof(*value));
    value->v.gate.dest = string_make(parser_getsym(p, "destination"));
    value->v.gate.feat = feat;
    if (parser_hasval(p, "note")) {
      value->v.gate.note = string_make(parser_getstr(p, "note"));
    } else {
      value->v.gate.note = NULL;
    }
    value->is_predefined = false;
    value->kind = SECTION_SYM_GATE;
    if (!tutorial_section_sym_table_insert(priv->curr_value->v.section.symt,
                                           key, value)) {
      tutorial_section_sym_value_free(value);
      mem_free(key);
      result = PARSE_ERROR_DUPLICATED_SYMBOL;
    }
  }
  return result;
}
STATIC_OVL enum parser_error
parse_section_forge(struct parser* p)
{
  struct tutorial_parser_priv* priv =
      (struct tutorial_parser_priv*)parser_priv(p);
  const char* tstr = parser_getstr(p, "type");
  int feat = FEAT_NONE;
  struct tutorial_section_sym_key* key;
  enum parser_error result;
  if (priv->curr_value->key->comp != TUTORIAL_SECTION) {
    return PARSE_ERROR_UNDEFINED_DIRECTIVE;
  }
  if (streq(tstr, "NORMAL")) {
    feat = FEAT_FORGE;
  } else if (streq(tstr, "ENCHANTED")) {
    feat = FEAT_FORGE_GOOD;
  } else if (streq(tstr, "UNIQUE")) {
    feat = FEAT_FORGE_UNIQUE;
  } else {
    return PARSE_ERROR_INVALID_VALUE;
  }
  result = tutorial_section_parse_symbol(
      parser_getsym(p, "symbol"), priv, priv->curr_value->v.section.symt, &key);
  if (result == PARSE_ERROR_NONE) {
    struct tutorial_section_sym_val* value = mem_alloc(sizeof(*value));
    value->v.forge.feat = feat;
    value->v.forge.uses = parser_getint(p, "uses");
    value->is_predefined = false;
    value->kind = SECTION_SYM_FORGE;
    if (!tutorial_section_sym_table_insert(priv->curr_value->v.section.symt,
                                           key, value)) {
      tutorial_section_sym_value_free(value);
      mem_free(key);
      result = PARSE_ERROR_DUPLICATED_SYMBOL;
    }
  }
  return result;
}
STATIC_OVL enum parser_error
parse_section_object(struct parser* p)
{
  struct tutorial_parser_priv* priv =
      (struct tutorial_parser_priv*)parser_priv(p);
  int tval, sval;
  const char* numstr;
  dice_t* numdice;
  random_value rv;
  struct tutorial_section_sym_key* key;
  enum parser_error result;
  if (priv->curr_value->key->comp != TUTORIAL_SECTION) {
    return PARSE_ERROR_UNDEFINED_DIRECTIVE;
  }
  tval = tval_find_idx(parser_getsym(p, "tval"));
  if (tval < 0) {
    return PARSE_ERROR_UNRECOGNISED_TVAL;
  }
  sval = lookup_sval(tval, parser_getsym(p, "sval"));
  if (sval < 0) {
    return PARSE_ERROR_UNRECOGNISED_SVAL;
  }
  numstr = parser_getstr(p, "number");
  numdice = dice_new();
  if (!dice_parse_string(numdice, numstr)) {
    dice_free(numdice);
    return PARSE_ERROR_INVALID_DICE;
  }
  dice_random_value(numdice, &rv);
  dice_free(numdice);
  result = tutorial_section_parse_symbol(
      parser_getsym(p, "symbol"), priv, priv->curr_value->v.section.symt, &key);
  if (result == PARSE_ERROR_NONE) {
    struct tutorial_section_sym_val* value = mem_alloc(sizeof(*value));
    value->v.item.v.details.ego = NULL;
    value->v.item.v.details.tweaks = NULL;
    value->v.item.v.details.number = rv;
    value->v.item.v.details.tval = tval;
    value->v.item.v.details.sval = sval;
    value->v.item.v.details.tweak_count = 0;
    value->v.item.is_artifact = false;
    value->is_predefined = false;
    value->kind = SECTION_SYM_ITEM;
    if (!tutorial_section_sym_table_insert(priv->curr_value->v.section.symt,
                                           key, value)) {
      tutorial_section_sym_value_free(value);
      mem_free(key);
      result = PARSE_ERROR_DUPLICATED_SYMBOL;
    }
  }
  return result;
}
STATIC_OVL enum parser_error
parse_section_complex_object(struct parser* p)
{
  struct tutorial_parser_priv* priv =
      (struct tutorial_parser_priv*)parser_priv(p);
  int tval, sval;
  const char* numstr;
  dice_t* numdice;
  random_value rv;
  const char* ego;
  struct tutorial_item_tweak* tweaks;
  int tweak_count, tweak_alloc;
  struct tutorial_section_sym_key* key;
  enum parser_error result;
  if (priv->curr_value->key->comp != TUTORIAL_SECTION) {
    return PARSE_ERROR_UNDEFINED_DIRECTIVE;
  }
  tval = tval_find_idx(parser_getsym(p, "tval"));
  if (tval < 0) {
    return PARSE_ERROR_UNRECOGNISED_TVAL;
  }
  sval = lookup_sval(tval, parser_getsym(p, "sval"));
  if (sval < 0) {
    return PARSE_ERROR_UNRECOGNISED_SVAL;
  }
  numstr = parser_getsym(p, "number");
  numdice = dice_new();
  if (!dice_parse_string(numdice, numstr)) {
    dice_free(numdice);
    return PARSE_ERROR_INVALID_DICE;
  }
  dice_random_value(numdice, &rv);
  dice_free(numdice);
  ego = parser_getsym(p, "ego");
  result = tutorial_parse_tweaks(&tweaks, &tweak_count, &tweak_alloc,
                                 parser_getsym(p, "properties"),
                                 parser_getstr(p, "modifiers"));
  if (result != PARSE_ERROR_NONE) {
    tutorial_item_tweaks_free(tweaks, tweak_count);
    return result;
  }
  result = tutorial_section_parse_symbol(
      parser_getsym(p, "symbol"), priv, priv->curr_value->v.section.symt, &key);
  if (result == PARSE_ERROR_NONE) {
    struct tutorial_section_sym_val* value = mem_alloc(sizeof(*value));
    value->v.item.v.details.ego =
        streq(ego, "NONE") ? NULL : lookup_ego_item(ego, tval, sval);
    value->v.item.v.details.tweaks = tweaks;
    value->v.item.v.details.number = rv;
    value->v.item.v.details.tval = tval;
    value->v.item.v.details.sval = sval;
    value->v.item.v.details.tweak_count = tweak_count;
    value->v.item.is_artifact = false;
    value->is_predefined = false;
    value->kind = SECTION_SYM_ITEM;
    if (!tutorial_section_sym_table_insert(priv->curr_value->v.section.symt,
                                           key, value)) {
      tutorial_section_sym_value_free(value);
      mem_free(key);
      result = PARSE_ERROR_DUPLICATED_SYMBOL;
    }
  } else {
    tutorial_item_tweaks_free(tweaks, tweak_count);
  }
  return result;
}
STATIC_OVL enum parser_error
parse_section_artifact(struct parser* p)
{
  struct tutorial_parser_priv* priv =
      (struct tutorial_parser_priv*)parser_priv(p);
  const struct artifact* art;
  struct tutorial_section_sym_key* key;
  enum parser_error result;
  if (priv->curr_value->key->comp != TUTORIAL_SECTION) {
    return PARSE_ERROR_UNDEFINED_DIRECTIVE;
  }
  art = lookup_artifact_name(parser_getstr(p, "name"));
  if (!art) {
    return PARSE_ERROR_NO_ARTIFACT_NAME;
  }
  result = tutorial_section_parse_symbol(
      parser_getsym(p, "symbol"), priv, priv->curr_value->v.section.symt, &key);
  if (result == PARSE_ERROR_NONE) {
    struct tutorial_section_sym_val* value = mem_alloc(sizeof(*value));
    value->v.item.v.art = art;
    value->v.item.is_artifact = true;
    value->is_predefined = false;
    value->kind = SECTION_SYM_ITEM;
    if (!tutorial_section_sym_table_insert(priv->curr_value->v.section.symt,
                                           key, value)) {
      tutorial_section_sym_value_free(value);
      mem_free(key);
      result = PARSE_ERROR_DUPLICATED_SYMBOL;
    }
  }
  return result;
}
STATIC_OVL enum parser_error
parse_section_monster(struct parser* p)
{
  struct tutorial_parser_priv* priv =
      (struct tutorial_parser_priv*)parser_priv(p);
  struct monster_race* race;
  const char* alert_str;
  int sleepiness;
  bool sleepiness_fixed;
  struct tutorial_section_sym_key* key;
  enum parser_error result;
  if (priv->curr_value->key->comp != TUTORIAL_SECTION) {
    return PARSE_ERROR_UNDEFINED_DIRECTIVE;
  }
  race = lookup_monster(parser_getsym(p, "race"));
  if (race == NULL) {
    return PARSE_ERROR_INVALID_MONSTER;
  }
  alert_str = parser_getsym(p, "alertness");
  if (streq(alert_str, "ALERT")) {
    sleepiness = 0;
    sleepiness_fixed = true;
  } else if (streq(alert_str, "ASLEEP")) {
    sleepiness = race->sleep;
    sleepiness_fixed = (race->sleep <= 0);
  } else {
    char* p_end;
    long lalert = strtol(alert_str, &p_end, 10);
    if (alert_str[0] == '\0' || *p_end != '\0') {
      return PARSE_ERROR_INVALID_VALUE;
    }
    if (lalert < ALERTNESS_MIN || lalert > ALERTNESS_MAX) {
      return PARSE_ERROR_OUT_OF_BOUNDS;
    }
    sleepiness = ALERTNESS_ALERT - (int)lalert;
    sleepiness_fixed = true;
  }
  result = tutorial_section_parse_symbol(
      parser_getsym(p, "symbol"), priv, priv->curr_value->v.section.symt, &key);
  if (result == PARSE_ERROR_NONE) {
    struct tutorial_section_sym_val* value = mem_alloc(sizeof(*value));
    value->v.monster.race = race;
    if (parser_hasval(p, "note")) {
      value->v.monster.note = string_make(parser_getstr(p, "note"));
    } else {
      value->v.monster.note = NULL;
    }
    value->v.monster.sleepiness = sleepiness;
    value->v.monster.sleepiness_fixed = sleepiness_fixed;
    value->is_predefined = false;
    value->kind = SECTION_SYM_MONSTER;
    if (!tutorial_section_sym_table_insert(priv->curr_value->v.section.symt,
                                           key, value)) {
      tutorial_section_sym_value_free(value);
      mem_free(key);
      result = PARSE_ERROR_DUPLICATED_SYMBOL;
    }
  }
  return result;
}
STATIC_OVL enum parser_error
parse_section_trap(struct parser* p)
{
  const char* trap_flags[] = {"NONE", "VISIBLE", NULL};
  struct tutorial_parser_priv* priv =
      (struct tutorial_parser_priv*)parser_priv(p);
  struct trap_kind* trap;
  bool vis;
  char *flags, *s;
  struct tutorial_section_sym_key* key;
  enum parser_error result;
  if (priv->curr_value->key->comp != TUTORIAL_SECTION) {
    return PARSE_ERROR_UNDEFINED_DIRECTIVE;
  }
  trap = lookup_trap(parser_getsym(p, "name"));
  vis = false;
  flags = string_make(parser_getstr(p, "flags"));
  s = strtok(flags, " |");
  while (s) {
    int idx = lookup_flag(trap_flags, s);
    if (idx == 1) {
      vis = true;
    } else if (idx < 0) {
      string_free(flags);
      return PARSE_ERROR_INVALID_FLAG;
    }
    s = strtok(NULL, " |");
  }
  string_free(flags);
  result = tutorial_section_parse_symbol(
      parser_getsym(p, "symbol"), priv, priv->curr_value->v.section.symt, &key);
  if (result == PARSE_ERROR_NONE) {
    struct tutorial_section_sym_val* value = mem_alloc(sizeof(*value));
    value->v.trap.kind = trap;
    value->v.trap.vis = vis;
    value->is_predefined = false;
    value->kind = SECTION_SYM_TRAP;
    if (!tutorial_section_sym_table_insert(priv->curr_value->v.section.symt,
                                           key, value)) {
      tutorial_section_sym_value_free(value);
      mem_free(key);
      result = PARSE_ERROR_DUPLICATED_SYMBOL;
    }
  }
  return result;
}
STATIC_OVL enum parser_error
parse_section_door(struct parser* p)
{
  const char* door_flags[] = {
      "NONE",    "BROKEN",  "OPEN",     "CLOSED",   "SECRET",   "LOCK_1",
      "LOCK_2",  "LOCK_5",  "LOCK_10",  "LOCK_20",  "LOCK_50",  "STUCK_1",
      "STUCK_2", "STUCK_5", "STUCK_10", "STUCK_20", "STUCK_50", NULL};
  struct tutorial_parser_priv* priv =
      (struct tutorial_parser_priv*)parser_priv(p);
  int feat;
  int power;
  char *flags, *s;
  struct tutorial_section_sym_key* key;
  enum parser_error result;
  if (priv->curr_value->key->comp != TUTORIAL_SECTION) {
    return PARSE_ERROR_UNDEFINED_DIRECTIVE;
  }
  feat = FEAT_CLOSED;
  power = 0;
  flags = string_make(parser_getstr(p, "flags"));
  s = strtok(flags, " |");
  while (s) {
    int idx = lookup_flag(door_flags, s);
    switch (idx) {
      case 0:
        break;
      case 1:
        feat = FEAT_BROKEN;
        break;
      case 2:
        feat = FEAT_OPEN;
        break;
      case 3:
        feat = FEAT_CLOSED;
        break;
      case 4:
        feat = FEAT_SECRET;
        break;
      case 5:
        ++power;
        break;
      case 6:
        power += 2;
        break;
      case 7:
        power += 5;
        break;
      case 8:
        power += 10;
        break;
      case 9:
        power += 20;
        break;
      case 10:
        power += 50;
        break;
      case 11:
        --power;
        break;
      case 12:
        power -= 2;
        break;
      case 13:
        power -= 5;
        break;
      case 14:
        power -= 10;
        break;
      case 15:
        power -= 20;
        break;
      case 16:
        power -= 50;
        break;
      default:
        string_free(flags);
        return PARSE_ERROR_INVALID_FLAG;
    }
    s = strtok(NULL, " |");
  }
  string_free(flags);
  result = tutorial_section_parse_symbol(
      parser_getsym(p, "symbol"), priv, priv->curr_value->v.section.symt, &key);
  if (result == PARSE_ERROR_NONE) {
    struct tutorial_section_sym_val* value = mem_alloc(sizeof(*value));
    value->v.door.feat = feat;
    value->v.door.power =
        (feat == FEAT_CLOSED) ? MAX(MIN(power, 255), -255) : 0;
    value->is_predefined = false;
    value->kind = SECTION_SYM_DOOR;
    if (!tutorial_section_sym_table_insert(priv->curr_value->v.section.symt,
                                           key, value)) {
      tutorial_section_sym_value_free(value);
      mem_free(key);
      result = PARSE_ERROR_DUPLICATED_SYMBOL;
    }
  }
  return result;
}
STATIC_OVL enum parser_error
parse_section_line(struct parser* p)
{
  struct tutorial_parser_priv* priv =
      (struct tutorial_parser_priv*)parser_priv(p);
  const char* line;
  if (priv->curr_value->key->comp != TUTORIAL_SECTION) {
    return PARSE_ERROR_UNDEFINED_DIRECTIVE;
  }
  if (!priv->curr_value->v.section.rows ||
      !priv->curr_value->v.section.columns) {
    return PARSE_ERROR_NON_SEQUENTIAL_RECORDS;
  }
  if (priv->section_lines_parsed == 0) {
    assert(!priv->curr_value->v.section.lines);
    priv->curr_value->v.section.lines =
        mem_zalloc(priv->curr_value->v.section.rows *
                   sizeof(*(priv->curr_value->v.section.lines)));
  } else if (priv->section_lines_parsed >= priv->curr_value->v.section.rows) {
    return PARSE_ERROR_TOO_MANY_ENTRIES;
  }
  assert(!priv->curr_value->v.section.lines[priv->section_lines_parsed]);
  line = parser_getstr(p, "line");
  if (utf8_strlen(line) != (size_t)priv->curr_value->v.section.columns) {
    return PARSE_ERROR_VAULT_DESC_WRONG_LENGTH;
  }
  priv->curr_value->v.section.lines[priv->section_lines_parsed] =
      string_make(line);
  ++priv->section_lines_parsed;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_note_or_trigger_text(struct parser* p)
{
  struct tutorial_parser_priv* priv =
      (struct tutorial_parser_priv*)parser_priv(p);
  const char* text = parser_getstr(p, "contents");
  enum parser_error result = PARSE_ERROR_NONE;
  if (priv->curr_value->key->comp == TUTORIAL_NOTE) {
    priv->curr_value->v.note.text =
        string_append(priv->curr_value->v.note.text, text);
  } else if (priv->curr_value->key->comp == TUTORIAL_TRIGGER) {
    priv->curr_value->v.trigger.text =
        string_append(priv->curr_value->v.trigger.text, text);
  } else {
    result = PARSE_ERROR_UNDEFINED_DIRECTIVE;
  }
  return result;
}
STATIC_OVL enum parser_error
parse_archetype_or_section_flags(struct parser* p)
{
  struct tutorial_parser_priv* priv =
      (struct tutorial_parser_priv*)parser_priv(p);
  enum parser_error result = PARSE_ERROR_NONE;
  if (priv->curr_value->key->comp == TUTORIAL_ARCHETYPE ||
      priv->curr_value->key->comp == TUTORIAL_SECTION) {
    char *flags = string_make(parser_getstr(p, "flags")), *s;
    s = strtok(flags, " |");
    while (s) {
      if (streq(s, "DEFAULT")) {
        if (priv->curr_value->key->comp == TUTORIAL_ARCHETYPE) {
          priv->r->default_archetype = priv->curr_value;
        } else {
          priv->r->default_section = priv->curr_value;
        }
      } else if (streq(s, "PURGE_NORMAL_KIT") &&
                 priv->curr_value->key->comp == TUTORIAL_ARCHETYPE) {
        priv->curr_value->v.archetype.purge_kit = true;
      } else {
        result = PARSE_ERROR_INVALID_FLAG;
      }
      s = strtok(NULL, " |");
    }
    string_free(flags);
  } else {
    result = PARSE_ERROR_UNDEFINED_DIRECTIVE;
  }
  return result;
}
STATIC_OVL errr
tutorial_run_parser(struct parser* p)
{
  return parse_file_quit_not_found(p, "tutorial");
}
STATIC_OVL void
tutorial_parse_data(void)
{
  run_parser(&tutorial_parser);
}
STATIC_OVL void
tutorial_cleanup_parsed_data(void)
{
  if (tutorial_parsed_data.d.d) {
    tutorial_dict_destroy(tutorial_parsed_data.d);
    tutorial_parsed_data.d.d = NULL;
  }
  tutorial_parsed_data.default_archetype = NULL;
  tutorial_parsed_data.default_section = NULL;
  mem_free(tutorial_parsed_data.pval_to_note_table);
  tutorial_parsed_data.pval_to_note_table = NULL;
  tutorial_cleanup_trigger_gate_map(tutorial_parsed_data.trigger_gate_map);
  tutorial_parsed_data.trigger_gate_map = NULL;
  tutorial_parsed_data.curr_death_note = NULL;
  tutorial_parsed_data.note_table_n = 0;
  tutorial_parsed_data.note_table_a = 0;
}
STATIC_OVL struct tutorial_section_sym_val*
tutorial_section_sym_table_has(struct tutorial_section_sym_table t,
                               const struct tutorial_section_sym_key* key)
{
  return (struct tutorial_section_sym_val*)dict_has(t.d, key);
}
STATIC_OVL struct tutorial_dict_val_type*
tutorial_dict_has(struct tutorial_dict_type d,
                  const struct tutorial_dict_key_type* key)
{
  return (struct tutorial_dict_val_type*)dict_has(d.d, key);
}
STATIC_OVL bool
tutorial_text_escaped(const char* cursor, const char* limit)
{
  int count = 0;
  while (cursor > limit && *(cursor - 1) == '\\') {
    ++count;
    --cursor;
  }
  return (count & 1) != 0;
}
STATIC_OVL size_t
tutorial_copy_strip_escapes(char* dest, size_t sz, const char* src, size_t rd)
{
  size_t out = 0;
  const char* start = src;
  if (sz == 0) return 0;
  while (out < sz - 1 && *src && (size_t)(src - start) < rd) {
    if (*src == '\\') {
      ++src;
      if (*src && (size_t)(src - start) < rd) {
        *dest = *src;
        ++src;
      } else {
        *dest = '\\';
      }
    } else {
      *dest = *src;
      ++src;
    }
    ++dest;
    ++out;
  }
  *dest = '\0';
  return src - start;
}
STATIC_OVL void
tutorial_cleanup_trigger_gate_map(struct tutorial_dict_val_type*** m)
{
  int i = 0;
  if (!m) return;
  while (m[i]) {
    assert(i < z_info->dungeon_hgt);
    mem_free(m[i]);
    ++i;
  }
  mem_free(m);
}
STATIC_OVL struct parser*
tutorial_init_parser(void)
{
  struct parser* p = parser_new();
  struct tutorial_parser_priv* priv = mem_zalloc(sizeof(*priv));
  struct tutorial_dict_key_type* tutorial_exit_key;
  struct tutorial_dict_val_type* tutorial_exit;
  priv->r = &tutorial_parsed_data;
  priv->r->d = tutorial_dict_create();
  tutorial_exit_key = mem_alloc(sizeof(*tutorial_exit_key));
  tutorial_exit_key->name = string_make("EXIT");
  tutorial_exit_key->comp = TUTORIAL_SECTION;
  tutorial_exit = mem_zalloc(sizeof(*tutorial_exit));
  if (!tutorial_dict_insert(priv->r->d, tutorial_exit_key, tutorial_exit)) {
    mem_free(tutorial_exit);
    mem_free(tutorial_exit_key);
    mem_free(priv);
    parser_destroy(p);
    return NULL;
  }
  tutorial_exit->key = tutorial_exit_key;
  priv->r->default_archetype = NULL;
  priv->r->default_section = NULL;
  priv->r->pval_to_note_table = NULL;
  priv->r->note_kind =
      lookup_kind(TV_NOTE, lookup_sval(TV_NOTE, "tutorial note"));
  if (!priv->r->note_kind) {
    mem_free(priv);
    parser_destroy(p);
    return NULL;
  }
  priv->r->note_table_n = 0;
  priv->r->note_table_a = 0;
  parser_setpriv(p, priv);
  parser_reg(p, "archetype str name", parse_archetype_block_start);
  parser_reg(p, "note str name", parse_note_block_start);
  parser_reg(p, "trigger str name", parse_trigger_block_start);
  parser_reg(p, "section str name", parse_section_block_start);
  parser_reg(p, "race str name", parse_archetype_race);
  parser_reg(p, "house str name", parse_archetype_house);
  parser_reg(p, "sex str name", parse_archetype_sex);
  parser_reg(p, "name str name", parse_archetype_character_name);
  parser_reg(p, "history str history", parse_archetype_history);
  parser_reg(p, "experience str value", parse_archetype_experience);
  parser_reg(p, "stats str values", parse_archetype_stats);
  parser_reg(p, "skills str values", parse_archetype_skills);
  parser_reg(p, "abilities str values", parse_archetype_abilities);
  parser_reg(p, "object sym tval sym sval sym number sym equipped",
             parse_archetype_object);
  parser_reg(p,
             "complex-object sym tval sym sval sym number "
             "sym equipped sym ego sym properties str modifiers",
             parse_archetype_complex_object);
  parser_reg(p, "artifact sym name sym equipped", parse_archetype_artifact);
  parser_reg(p, "condition str expression", parse_trigger_condition);
  parser_reg(p, "rows int value", parse_section_rows);
  parser_reg(p, "columns int value", parse_section_columns);
  parser_reg(p, "area-flag int xul int yul int xlr int ylr str flags",
             parse_section_area_flag);
  parser_reg(p,
             "clear-area-flag int xul int yul int xlr int ylr "
             "str flags",
             parse_section_clear_area_flag);
  parser_reg(p, "start-note str name", parse_section_start_note);
  parser_reg(p, "place-note sym symbol str name", parse_section_note);
  parser_reg(p, "place-trigger sym symbol str name", parse_section_trigger);
  parser_reg(p, "gate sym symbol sym destination sym terrain ?str note",
             parse_section_gate);
  parser_reg(p, "forge sym symbol int uses str type", parse_section_forge);
  parser_reg(p, "place-object sym symbol sym tval sym sval str number",
             parse_section_object);
  parser_reg(p,
             "place-complex-object sym symbol sym tval sym sval "
             "sym number sym ego sym properties str modifiers",
             parse_section_complex_object);
  parser_reg(p, "place-artifact sym symbol str name", parse_section_artifact);
  parser_reg(p, "monster sym symbol sym race sym alertness ?str note",
             parse_section_monster);
  parser_reg(p, "trap sym symbol sym name str flags", parse_section_trap);
  parser_reg(p, "door sym symbol str flags", parse_section_door);
  parser_reg(p, "D str line", parse_section_line);
  parser_reg(p, "text str contents", parse_note_or_trigger_text);
  parser_reg(p, "flags str flags", parse_archetype_or_section_flags);
  parser_reg(p, "death-note str name", parse_trigger_or_section_death_note);
  return p;
}
STATIC_OVL errr
tutorial_finish_parser(struct parser* p)
{
  struct tutorial_parser_priv* priv =
      (struct tutorial_parser_priv*)parser_priv(p);
  struct tutorial_dict_val_type* last_val = priv->curr_value;
  int n_lines = priv->section_lines_parsed;
  mem_free(priv);
  parser_destroy(p);
  if (last_val && last_val->key->comp == TUTORIAL_SECTION) {
    if (n_lines < last_val->v.section.rows) {
      return PARSE_ERROR_TOO_FEW_ENTRIES;
    }
    verify_section(last_val);
  }
  return 0;
}
STATIC_OVL int
get_skill_abilities(int skill)
{
  struct ability* a = abilities;
  int count = 0;
  while (a) {
    if (a->skill == skill) skill_abilities[count++] = a;
    a = a->next;
  }
  return count;
}
STATIC_OVL void
bane_display(struct menu* menu, int oid, bool cursor, int row, int col,
             int width)
{
  struct bane_type* choice = menu->menu_data;
  uint8_t name_attr =
      (oid && choice[oid].kills < 4) ? COLOUR_L_DARK : COLOUR_SLATE;
  c_put_str(name_attr, choice[oid].name, row, col);
  if (cursor) {
    textblock* tb = textblock_new();
    region area;
    area.col = col - 7;
    area.row = row + (menu->count - oid) + 1;
    area.width = -1;
    area.page_rows = -1;
    if (!oid) {
      textblock_append(tb,
                       "                                            "
                       "                  ");
    } else if (choice[oid].kills >= 4) {
      textblock_append(tb,
                       "You have slain %d of these foes.            "
                       "                  ",
                       choice[oid].kills);
    } else {
      textblock_append(tb,
                       "You have slain %d of these foes and need to "
                       "slay %d more.",
                       choice[oid].kills, 4 - choice[oid].kills);
    }
    textui_textblock_place(tb, area, NULL);
    textblock_free(tb);
  }
}
STATIC_OVL bool
bane_action(struct menu* m, const ui_event* event, int oid)
{
  if ((event->type == EVT_SELECT) && oid) {
    struct bane_type* choice = m->menu_data;
    if (choice[oid].kills < 4) {
      return true;
    }
    player->bane_type = oid;
  }
  return false;
}
STATIC_OVL bool
bane_menu(void)
{
  struct menu menu;
  menu_iter menu_f = {NULL, NULL, bane_display, bane_action, NULL};
  region area = {46, 4, -1, (int)N_ELEMENTS(bane_types) + 3};
  ui_event menu_result;
  int i;
  bane_types[0].kills = 0;
  for (i = 1; i < (int)N_ELEMENTS(bane_types); ++i) {
    bane_types[i].kills = player_bane_type_killed(i);
  }
  menu_init(&menu, MN_SKIN_SCROLL, &menu_f);
  menu.title = "Enemy types";
  menu.selections = lower_case;
  menu_setpriv(&menu, N_ELEMENTS(bane_types), bane_types);
  menu_layout(&menu, &area);
  screen_save();
  area.page_rows = -1;
  region_erase(&area);
  menu_result = menu_select(&menu, 0, false);
  screen_load();
  return menu_result.type == EVT_SELECT && player->bane_type != 0;
}
STATIC_OVL void
ability_display(struct menu* menu, int oid, bool cursor, int row, int col,
                int width)
{
  struct ability** choice = menu->menu_data;
  struct ability* innate = locate_ability(player->abilities, choice[oid]);
  struct ability* item = locate_ability(player->item_abilities, choice[oid]);
  const char* name = choice[oid]->name;
  char* name_allocated = NULL;
  uint8_t attr = COLOUR_L_DARK;
  int points = player->skill_base[choice[oid]->skill];
  int points_needed = choice[oid]->level;
  if (innate) {
    attr = innate->active ? COLOUR_WHITE : COLOUR_RED;
    if (innate->skill == SKILL_PERCEPTION && streq(innate->name, "Bane") &&
        player->bane_type > 0) {
      name_allocated =
          string_make(format("%s-Bane", bane_types[player->bane_type].name));
      name = name_allocated;
    }
  } else if (item) {
    attr = item->active ? COLOUR_L_GREEN : COLOUR_RED;
  } else if (player_has_prereq_abilities(player, choice[oid]) &&
             (points >= points_needed)) {
    attr = COLOUR_SLATE;
  }
  c_put_str(attr, name, row, col);
  string_free(name_allocated);
}
STATIC_OVL bool
ability_action(struct menu* m, const ui_event* event, int oid)
{
  struct ability** choice = m->menu_data;
  struct ability* possessed = locate_ability(player->abilities, choice[oid]);
  bool points = player->skill_base[choice[oid]->skill] >= choice[oid]->level;
  if (!possessed) {
    possessed = locate_ability(player->item_abilities, choice[oid]);
  }
  if (event->type == EVT_SELECT) {
    if (possessed) {
      if (possessed->active) {
        possessed->active = false;
        put_str("Ability now switched off.", 0, 0);
      } else {
        possessed->active = true;
        put_str("Ability now switched on.", 0, 0);
      }
    } else if (player_has_prereq_abilities(player, choice[oid]) && points) {
      if (player_can_gain_ability(player, choice[oid])) {
        if (streq(choice[oid]->name, "Bane")) {
          if (!bane_menu()) return false;
        }
        if (player_gain_ability(player, choice[oid])) {
          put_str("Ability gained.", 0, 0);
        } else if (streq(choice[oid]->name, "Bane")) {
          player->bane_type = 0;
        }
      } else {
        msg("You do not have enough experience to acquire this ability.");
      }
    } else {
      msg("Insufficient prerequisites for ability!");
    }
    return true;
  }
  return false;
}
STATIC_OVL void
ability_browser(int oid, void* data, const region* loc)
{
  struct ability** choice = data;
  struct ability* current = choice[oid];
  bool learned = player_has_ability(player, current);
  uint8_t attr = COLOUR_L_DARK;
  bool points = player->skill_base[current->skill] >= current->level;
  text_out_hook = text_out_to_screen;
  text_out_wrap = 79;
  text_out_indent = 46;
  Term_gotoxy(text_out_indent, 4);
  if (current->desc) {
    text_out_c(COLOUR_L_WHITE, "%s", current->desc);
  }
  if (!learned) {
    struct ability* prereq = current->prerequisites;
    bool ready = player_has_prereq_abilities(player, current);
    int line = 0;
    if (ready && points) {
      attr = COLOUR_SLATE;
    }
    Term_gotoxy(text_out_indent, 10);
    text_out_c(attr, "Prerequisites:");
    Term_gotoxy(text_out_indent, 12);
    if (points) {
      text_out_c(COLOUR_SLATE, "  %d skill points", current->level);
    } else {
      text_out_c(COLOUR_L_DARK, "  %d skill points (you have %d)",
                 current->level, player->skill_base[current->skill]);
    }
    Term_gotoxy(text_out_indent + 2, 13);
    while (prereq) {
      if (locate_ability(player->abilities, prereq)) {
        attr = COLOUR_SLATE;
      } else {
        attr = COLOUR_L_DARK;
      }
      text_out_c(attr, "%s", prereq->name);
      prereq = prereq->next;
      line++;
      if (prereq) {
        Term_gotoxy(text_out_indent + 2, 13 + line);
        text_out_c(COLOUR_L_DARK, "or ");
      }
    }
    if (ready) {
      int exp_cost = player_ability_cost(player, current);
      bool have_exp = player_can_gain_ability(player, current);
      attr = have_exp ? COLOUR_SLATE : COLOUR_L_DARK;
      Term_gotoxy(text_out_indent, 16);
      text_out_c(attr, "Current price:");
      Term_gotoxy(text_out_indent + 2, 18);
      if (have_exp) {
        text_out_c(attr, "%d experience", exp_cost);
      } else {
        text_out_c(attr, "%d experience (you have %d)", exp_cost,
                   player->new_exp);
      }
    }
  } else if (current->skill == SKILL_PERCEPTION &&
             streq(current->name, "Bane") && player->bane_type > 0) {
    Term_gotoxy(text_out_indent, 10);
    text_out_c(COLOUR_WHITE, "%s-Bane:", bane_types[player->bane_type].name);
    Term_gotoxy(text_out_indent + 2, 12);
    text_out_c(COLOUR_WHITE, "%d slain, giving a %+d bonus",
               bane_types[player->bane_type].kills, calc_bane_bonus(player));
  }
}
STATIC_OVL void
skill_display(struct menu* menu, int oid, bool cursor, int row, int col,
              int width)
{
  char** choice = menu->menu_data;
  uint8_t attr = (cursor ? COLOUR_L_BLUE : COLOUR_WHITE);
  c_put_str(attr, choice[oid], row, col);
}
STATIC_OVL bool
skill_action(struct menu* m, const ui_event* event, int oid)
{
  struct menu menu;
  menu_iter menu_f = {NULL, NULL, ability_display, ability_action, NULL};
  region area = {17, 2, 46 - 17 - 5, 0};
  int count;
  menu_init(&menu, MN_SKIN_SCROLL, &menu_f);
  menu.title = "Abilities";
  skill_abilities = mem_zalloc(100 * sizeof(struct ability*));
  count = get_skill_abilities(oid);
  if (count) {
    menu_setpriv(&menu, count, skill_abilities);
    menu.browse_hook = ability_browser;
    menu.selections = lower_case;
    menu.flags = MN_CASELESS_TAGS;
    menu_layout(&menu, &area);
    menu_select(&menu, 0, true);
  }
  mem_free(skill_abilities);
  return true;
}
STATIC_OVL void
do_cmd_abilities(void)
{
  struct menu menu;
  menu_iter menu_f = {NULL, NULL, skill_display, skill_action, NULL};
  const char* skill_names[] = {
      "Melee",      "Archery", "Evasion",  "Stealth",
      "Perception", "Will",    "Smithing", "Song",
  };
  ui_event evt = EVENT_EMPTY;
  screen_save();
  clear_from(0);
  menu_init(&menu, MN_SKIN_SCROLL, &menu_f);
  menu.title = "Skills";
  menu_setpriv(&menu, SKILL_MAX, skill_names);
  menu.selections = lower_case;
  menu.flags = MN_CASELESS_TAGS;
  menu_layout(&menu, &SCREEN_REGION);
  while (evt.type != EVT_ESCAPE) evt = menu_select(&menu, 0, false);
  screen_load();
}
STATIC_OVL enum birth_stage
textui_birth_quickstart(void)
{
  const char* prompt =
      "['Y': use as is; 'N': redo; 'C': change name/history; '=': set birth "
      "options]";
  enum birth_stage next = BIRTH_QUICKSTART;
  prt("New character based on previous one:", 0, 0);
  prt(prompt, Term->hgt - 1, Term->wid / 2 - strlen(prompt) / 2);
  do {
    struct keypress ke = inkey();
    if (ke.code == 'N' || ke.code == 'n') {
      cmdq_push(CMD_BIRTH_RESET);
      cmdq_push(CMD_RESET_STATS);
      next = BIRTH_RACE_CHOICE;
    } else if (ke.code == KTRL('X')) {
      quit(NULL);
    } else if (!arg_force_name && (ke.code == 'C' || ke.code == 'c')) {
      next = BIRTH_NAME_CHOICE;
    } else if (ke.code == '=') {
      do_cmd_options_birth();
    } else if (ke.code == 'Y' || ke.code == 'y') {
      cmdq_push(CMD_ACCEPT_CHARACTER);
      next = BIRTH_COMPLETE;
    }
  } while (next == BIRTH_QUICKSTART);
  clear_from(23);
  return next;
}
STATIC_OVL void
birthmenu_display(struct menu* menu, int oid, bool cursor, int row, int col,
                  int width)
{
  struct birthmenu_data* data = menu->menu_data;
  uint8_t attr = curs_attrs[CURS_KNOWN][0 != cursor];
  c_put_str(attr, data->items[oid], row, col);
}
STATIC_OVL int
stat_attr(int adj)
{
  int attr;
  if (adj < 0) {
    attr = COLOUR_RED;
  } else if (adj == 0) {
    attr = COLOUR_L_DARK;
  } else if (adj == 1) {
    attr = COLOUR_GREEN;
  } else if (adj == 2) {
    attr = COLOUR_L_GREEN;
  } else {
    attr = COLOUR_L_BLUE;
  }
  return attr;
}
STATIC_OVL void
race_help(int i, void* db, const region* l)
{
  int j;
  struct player_race* r = player_id2race(i);
  if (!r) return;
  text_out_hook = text_out_to_screen;
  clear_from(14);
  text_out_indent = 19;
  Term_gotoxy(19, 9);
  for (j = 0; j < STAT_MAX; j++) {
    const char* name = stat_names_reduced[j];
    int adj = r->stat_adj[j];
    text_out_e("%s", name);
    text_out_c(stat_attr(adj), "%+3d", adj);
    text_out("\n");
  }
  text_out_e("\n");
  for (j = 0; j < SKILL_MAX; j++) {
    int adj = r->skill_adj[j];
    if (adj > 0) {
      text_out_c(COLOUR_GREEN, "%s affinity\n", skill_names[j]);
    } else if (adj < 0) {
      text_out_c(COLOUR_RED, "%s penalty\n", skill_names[j]);
    }
  }
  for (j = 0; j < PF_MAX; j++) {
    if (pf_has(r->pflags, j)) {
      text_out_c(COLOUR_GREEN, "%s\n", list_player_flag_names[j]);
    }
  }
  Term_gotoxy(19, 18);
  text_out_c(COLOUR_L_WHITE, "%s", r->desc);
  text_out_indent = 0;
}
STATIC_OVL void
house_help(int i, void* db, const region* l)
{
  int j;
  const struct player_race* r = player->race;
  struct player_house* h = player_house_from_count(i);
  if (!h) return;
  text_out_hook = text_out_to_screen;
  clear_from(14);
  text_out_indent = 42;
  Term_gotoxy(42, 9);
  for (j = 0; j < STAT_MAX; j++) {
    const char* name = stat_names_reduced[j];
    int adj = r->stat_adj[j] + h->stat_adj[j];
    text_out_e("%s", name);
    text_out_c(stat_attr(adj), "%+3d", adj);
    text_out("\n");
  }
  text_out_e("\n");
  for (j = 0; j < SKILL_MAX; j++) {
    int adj = r->skill_adj[j] + h->skill_adj[j];
    if (adj > 1) {
      text_out_c(COLOUR_L_GREEN, "%s mastery\n", skill_names[j]);
    } else if (adj > 0) {
      text_out_c(COLOUR_GREEN, "%s affinity\n", skill_names[j]);
    } else if (adj < 0) {
      text_out_c(COLOUR_RED, "%s penalty\n", skill_names[j]);
    }
  }
  for (j = 0; j < PF_MAX; j++) {
    if (pf_has(r->pflags, j)) {
      text_out_c(COLOUR_GREEN, "%s\n", list_player_flag_names[j]);
    }
  }
  Term_gotoxy(42, 18);
  text_out_c(COLOUR_L_WHITE, "%s", h->desc);
  text_out_indent = 0;
}
STATIC_OVL void
sex_help(int i, void* db, const region* l)
{
  clear_from(14);
}
STATIC_OVL bool
use_context_menu_birth(struct menu* current_menu, const ui_event* in,
                       ui_event* out)
{
  enum {
    ACT_CTX_BIRTH_OPT,
    ACT_CTX_BIRTH_RAND,
    ACT_CTX_BIRTH_QUIT,
    ACT_CTX_BIRTH_HELP
  };
  struct birthmenu_data* menu_data = menu_priv(current_menu);
  char* labels;
  struct menu* m;
  int selected;
  assert(in->type == EVT_MOUSE);
  if (in->mouse.y != 7 && in->mouse.y != 7 + 1) {
    return false;
  }
  labels = string_make(lower_case);
  m = menu_dynamic_new();
  m->selections = labels;
  menu_dynamic_add_label(m, "Show birth options", '=', ACT_CTX_BIRTH_OPT,
                         labels);
  if (menu_data->allow_random) {
    menu_dynamic_add_label(m, "Select one at random", '*', ACT_CTX_BIRTH_RAND,
                           labels);
  }
  menu_dynamic_add_label(m, "Quit", 'q', ACT_CTX_BIRTH_QUIT, labels);
  menu_dynamic_add_label(m, "Help", '?', ACT_CTX_BIRTH_HELP, labels);
  screen_save();
  menu_dynamic_calc_location(m, in->mouse.x, in->mouse.y);
  region_erase_bordered(&m->boundary);
  selected = menu_dynamic_select(m);
  menu_dynamic_free(m);
  string_free(labels);
  screen_load();
  switch (selected) {
    case ACT_CTX_BIRTH_OPT:
      do_cmd_options_birth();
      out->type = EVT_SWITCH;
      break;
    case ACT_CTX_BIRTH_RAND:
      current_menu->cursor = randint0(current_menu->count);
      out->type = EVT_SELECT;
      break;
    case ACT_CTX_BIRTH_QUIT:
      quit(NULL);
      break;
    case ACT_CTX_BIRTH_HELP:
      do_cmd_help();
      menu_data->stage_inout = BIRTH_RESET;
      out->type = EVT_SWITCH;
    default:
      break;
  }
  return true;
}
STATIC_OVL void
init_birth_menu(struct menu* menu, int n_choices, int initial_choice,
                const region* reg, bool allow_random, browse_f aux)
{
  struct birthmenu_data* menu_data;
  menu_init(menu, MN_SKIN_SCROLL, &birth_iter);
  menu->selections = all_letters_nohjkl;
  menu->flags = MN_DBL_TAP;
  menu->cursor = initial_choice;
  menu_data = mem_alloc(sizeof *menu_data);
  menu_data->items = mem_alloc(n_choices * sizeof *menu_data->items);
  menu_data->allow_random = allow_random;
  menu_setpriv(menu, n_choices, menu_data);
  menu->browse_hook = aux;
  menu->context_hook = use_context_menu_birth;
  menu_layout(menu, reg);
}
STATIC_OVL void
setup_menus(void)
{
  int n;
  struct player_sex* s;
  struct player_race* r;
  struct birthmenu_data* mdata;
  n = 0;
  for (r = races; r; r = r->next) n++;
  init_birth_menu(&race_menu, n, player->race ? player->race->ridx : 0,
                  &race_region, true, race_help);
  mdata = race_menu.menu_data;
  for (r = races; r; r = r->next) {
    mdata->items[r->ridx] = r->name;
  }
  mdata->hint = "Race affects stats, skills, and other character traits.";
  n = 0;
  for (s = sexes; s; s = s->next) n++;
  init_birth_menu(&sex_menu, n, player->sex ? player->sex->sidx : 0,
                  &sex_region, true, sex_help);
  mdata = sex_menu.menu_data;
  for (s = sexes; s; s = s->next) {
    mdata->items[s->sidx] = s->name;
  }
  mdata->hint = "Sex has no gameplay effect.";
}
STATIC_OVL void
setup_house_menu(const struct player_race* r)
{
  int i, n;
  struct player_house* h;
  struct birthmenu_data* mdata;
  n = 0;
  for (h = houses; h; h = h->next) {
    if (h->race == r) n++;
  }
  init_birth_menu(&house_menu, n, house_start, &house_region, true, house_help);
  mdata = house_menu.menu_data;
  for (i = n - 1, h = houses; h; h = h->next) {
    if (h->race == r) {
      mdata->items[i] = h->name;
      i--;
    }
  }
  mdata->hint = "House affects stats, skills, and other character traits.";
}
STATIC_OVL void
free_birth_menu(struct menu* menu)
{
  struct birthmenu_data* data = menu->menu_data;
  if (data) {
    mem_free(data->items);
    mem_free(data);
    menu->menu_data = NULL;
  }
}
STATIC_OVL void
free_birth_menus(void)
{
  free_birth_menu(&race_menu);
  free_birth_menu(&house_menu);
  free_birth_menu(&sex_menu);
}
STATIC_OVL void
clear_question(void)
{
  int i;
  for (i = 7; i < 9; i++) Term_erase(0, i, 255);
}
STATIC_OVL void
print_menu_instructions(void)
{
  Term_clear();
  text_out_hook = text_out_to_screen;
  text_out_indent = 2;
  Term_gotoxy(2, 1);
  text_out_e(
      "{light blue}Please select your character traits from the menus "
      "below:{/}\n\n"
      "Use the {light green}movement keys{/} to scroll the menu, "
      "{light green}Enter{/} to select the current menu item, '{light "
      "green}*{/}' "
      "for a random menu item, "
      "'{light green}ESC{/}' to step back through the birth process, "
      "'{light green}={/}' for the birth options, '{light green}?{/}' "
      "for help, or '{light green}Ctrl-X{/}' to quit.");
  text_out_indent = 0;
}
STATIC_OVL enum birth_stage
menu_question(enum birth_stage current, struct menu* current_menu,
              cmd_code choice_command)
{
  struct birthmenu_data* menu_data = menu_priv(current_menu);
  ui_event cx;
  enum birth_stage next = BIRTH_RESET;
  clear_question();
  Term_putstr(2, 7, -1, COLOUR_YELLOW, menu_data->hint);
  current_menu->cmd_keys = "?=*@\x18";
  while (next == BIRTH_RESET) {
    menu_data->stage_inout = current;
    cx = menu_select(current_menu, EVT_KBRD, false);
    if (cx.type == EVT_ESCAPE) {
      next = BIRTH_BACK;
    } else if (cx.type == EVT_SELECT) {
      cmdq_push(choice_command);
      cmd_set_arg_choice(cmdq_peek(), "choice", current_menu->cursor);
      if (current == BIRTH_HOUSE_CHOICE) {
        house_start = current_menu->cursor;
      }
      next = current + 1;
    } else if (cx.type == EVT_SWITCH) {
      next = menu_data->stage_inout;
    } else if (cx.type == EVT_KBRD) {
      if (cx.key.code == '*' && menu_data->allow_random) {
        current_menu->cursor = randint0(current_menu->count);
        cmdq_push(choice_command);
        cmd_set_arg_choice(cmdq_peek(), "choice", current_menu->cursor);
        if (current == BIRTH_HOUSE_CHOICE) {
          house_start = current_menu->cursor;
        }
        menu_refresh(current_menu, false);
        next = current + 1;
      } else if (cx.key.code == '=') {
        do_cmd_options_birth();
        next = current;
      } else if (cx.key.code == KTRL('X')) {
        quit(NULL);
      } else if (cx.key.code == '?') {
        do_cmd_help();
      }
    }
  }
  return next;
}
STATIC_OVL void
point_stats(game_event_type type, game_event_data* data, void* user)
{
  display_player_stat_info();
}
STATIC_OVL void
point_misc(game_event_type type, game_event_data* data, void* user)
{
  display_player_xtra_info();
}
STATIC_OVL void
stat_points(game_event_type type, game_event_data* data, void* user)
{
  int i;
  int sum = 0;
  const int* spent = data->points.points;
  const int* inc = data->points.inc_points;
  int remaining = data->points.remaining;
  put_str("Cost", 2 - 1, (42 + 32));
  for (i = 0; i < STAT_MAX; i++) {
    buysell[i] = 0;
    if (spent[i] > 0) {
      buysell[i] |= 1;
    }
    if (inc[i] <= remaining) {
      buysell[i] |= 2;
    }
    put_str(format("%4d", spent[i]), 2 + i, (42 + 32));
    sum += spent[i];
  }
  put_str(format("Total Cost: %2d/%2d", sum, remaining + sum), 2 + STAT_MAX,
          (42 + 19));
}
STATIC_OVL void
stat_points_start(void)
{
  const char* prompt =
      "[up/down to move, left/right to modify, 'r' to reset, 'Enter' to "
      "accept]";
  int i;
  Term_clear();
  display_player_xtra_info();
  display_player_stat_info();
  display_player_skill_info();
  prt(prompt, Term->hgt - 1, Term->wid / 2 - strlen(prompt) / 2);
  for (i = 0; i < STAT_MAX; ++i) {
    buysell[i] = 0;
  }
  event_add_handler(EVENT_STATPOINTS, stat_points, NULL);
  event_add_handler(EVENT_STATS, point_stats, NULL);
  event_add_handler(EVENT_EXP_CHANGE, point_misc, NULL);
}
STATIC_OVL void
stat_points_stop(void)
{
  event_remove_handler(EVENT_STATPOINTS, stat_points, NULL);
  event_remove_handler(EVENT_STATS, point_stats, NULL);
  event_remove_handler(EVENT_EXP_CHANGE, point_misc, NULL);
}
STATIC_OVL enum birth_stage
stat_points_command(void)
{
  static int stat = 0;
  enum {
    ACT_CTX_BIRTH_PTS_NONE,
    ACT_CTX_BIRTH_PTS_BUY,
    ACT_CTX_BIRTH_PTS_SELL,
    ACT_CTX_BIRTH_PTS_ESCAPE,
    ACT_CTX_BIRTH_PTS_RESET,
    ACT_CTX_BIRTH_PTS_ACCEPT,
    ACT_CTX_BIRTH_PTS_QUIT
  };
  int action = ACT_CTX_BIRTH_PTS_NONE;
  ui_event in;
  enum birth_stage next = BIRTH_STAT_POINTS;
  Term_gotoxy((42 + 32) + 4, 2 + stat);
  while (1) {
    in = inkey_ex();
    if (in.type == EVT_KBRD || in.type == EVT_MOUSE) {
      break;
    }
    if (in.type == EVT_BUTTON) {
      in.type = EVT_KBRD;
    }
    if (in.type == EVT_ESCAPE) {
      in.type = EVT_KBRD;
      in.key.code = ESCAPE;
      in.key.mods = 0;
      break;
    }
  }
  if (in.type == EVT_KBRD) {
    if (in.key.code == KTRL('X')) {
      action = ACT_CTX_BIRTH_PTS_QUIT;
    } else if (in.key.code == ESCAPE) {
      action = ACT_CTX_BIRTH_PTS_ESCAPE;
    } else if (in.key.code == 'r' || in.key.code == 'R') {
      action = ACT_CTX_BIRTH_PTS_RESET;
    } else if (in.key.code == KC_ENTER) {
      action = ACT_CTX_BIRTH_PTS_ACCEPT;
    } else {
      int dir;
      if (in.key.code == '-') {
        dir = 4;
      } else if (in.key.code == '+') {
        dir = 6;
      } else {
        dir = target_dir(in.key);
      }
      if (dir == 8) {
        stat = (stat + STAT_MAX - 1) % STAT_MAX;
      }
      if (dir == 2) {
        stat = (stat + 1) % STAT_MAX;
      }
      if (dir == 4) {
        action = ACT_CTX_BIRTH_PTS_SELL;
      }
      if (dir == 6) {
        action = ACT_CTX_BIRTH_PTS_BUY;
      }
    }
  } else if (in.type == EVT_MOUSE) {
    assert(stat >= 0 && stat < STAT_MAX);
    if (in.mouse.button == 2) {
      action = ACT_CTX_BIRTH_PTS_ESCAPE;
    } else if (in.mouse.y >= 2 && in.mouse.y < 2 + STAT_MAX &&
               in.mouse.y != 2 + stat) {
      stat = in.mouse.y - 2;
    } else {
      char* labels = string_make(lower_case);
      struct menu* m = menu_dynamic_new();
      m->selections = labels;
      if (in.mouse.y == 2 + stat && (buysell[stat] & 1)) {
        menu_dynamic_add_label(m, "Sell", 's', ACT_CTX_BIRTH_PTS_SELL, labels);
      }
      if (in.mouse.y == 2 + stat && (buysell[stat] & 2)) {
        menu_dynamic_add_label(m, "Buy", 'b', ACT_CTX_BIRTH_PTS_BUY, labels);
      }
      menu_dynamic_add_label(m, "Accept", 'a', ACT_CTX_BIRTH_PTS_ACCEPT,
                             labels);
      menu_dynamic_add_label(m, "Reset", 'r', ACT_CTX_BIRTH_PTS_RESET, labels);
      menu_dynamic_add_label(m, "Quit", 'q', ACT_CTX_BIRTH_PTS_QUIT, labels);
      screen_save();
      menu_dynamic_calc_location(m, in.mouse.x, in.mouse.y);
      region_erase_bordered(&m->boundary);
      action = menu_dynamic_select(m);
      menu_dynamic_free(m);
      string_free(labels);
      screen_load();
    }
  }
  switch (action) {
    case ACT_CTX_BIRTH_PTS_SELL:
      assert(stat >= 0 && stat < STAT_MAX);
      cmdq_push(CMD_SELL_STAT);
      cmd_set_arg_choice(cmdq_peek(), "choice", stat);
      break;
    case ACT_CTX_BIRTH_PTS_BUY:
      assert(stat >= 0 && stat < STAT_MAX);
      cmdq_push(CMD_BUY_STAT);
      cmd_set_arg_choice(cmdq_peek(), "choice", stat);
      break;
    case ACT_CTX_BIRTH_PTS_ESCAPE:
      next = BIRTH_BACK;
      break;
    case ACT_CTX_BIRTH_PTS_RESET:
      cmdq_push(CMD_RESET_STATS);
      cmd_set_arg_choice(cmdq_peek(), "choice", false);
      break;
    case ACT_CTX_BIRTH_PTS_ACCEPT:
      next = BIRTH_SKILL_POINTS;
      break;
    case ACT_CTX_BIRTH_PTS_QUIT:
      quit(NULL);
      break;
    default:
      break;
  }
  return next;
}
STATIC_OVL enum birth_stage
get_name_command(void)
{
  enum birth_stage next;
  char name[PLAYER_NAME_LEN];
  if (arg_name[0]) {
    my_strcpy(player->full_name, arg_name, sizeof(player->full_name));
  }
  if (arg_force_name) {
    next = BIRTH_HISTORY_CHOICE;
  } else if (get_character_name(name, sizeof(name)) &&
             (savefile[0] || !savefile_name_already_used(name, true, true) ||
              get_check("A savefile for that name exists.  Overwrite it? "))) {
    cmdq_push(CMD_NAME_CHOICE);
    cmd_set_arg_string(cmdq_peek(), "name", name);
    next = BIRTH_HISTORY_CHOICE;
  } else {
    next = BIRTH_BACK;
  }
  return next;
}
STATIC_OVL void
get_screen_loc(size_t cursor, int* x, int* y, size_t n_lines,
               size_t* line_starts, size_t* line_lengths)
{
  size_t lengths_so_far = 0;
  size_t i;
  if (!line_starts || !line_lengths) return;
  for (i = 0; i < n_lines; i++) {
    if (cursor >= line_starts[i]) {
      if (cursor <= (line_starts[i] + line_lengths[i])) {
        *y = i;
        *x = cursor - lengths_so_far;
        break;
      }
    }
    lengths_so_far += line_lengths[i] + 1;
  }
}
STATIC_OVL int
edit_text(char* buffer, int buflen)
{
  int len = strlen(buffer);
  bool done = false;
  int cursor = 0;
  while (!done) {
    int x = 0, y = 0;
    struct keypress ke;
    region area = {1, 18 + 1, 71, 5};
    textblock* tb = textblock_new();
    size_t *line_starts = NULL, *line_lengths = NULL;
    size_t n_lines;
    int ulen;
    clear_from(18);
    textblock_append(tb, "%s", buffer);
    textui_textblock_place(tb, area, NULL);
    n_lines =
        textblock_calculate_lines(tb, &line_starts, &line_lengths, area.width);
    ulen = (n_lines > 0) ? line_starts[n_lines - 1] + line_lengths[n_lines - 1]
                         : 0;
    get_screen_loc(cursor, &x, &y, n_lines, line_starts, line_lengths);
    Term_gotoxy(1 + x, 19 + y);
    ke = inkey();
    switch (ke.code) {
      case ESCAPE:
        return -1;
      case KC_ENTER:
        done = true;
        break;
      case ARROW_LEFT:
        if (cursor > 0) cursor--;
        break;
      case ARROW_RIGHT:
        if (cursor < ulen) cursor++;
        break;
      case ARROW_DOWN: {
        int add = line_lengths[y] + 1;
        if (cursor + add < ulen) cursor += add;
        break;
      }
      case ARROW_UP:
        if (y > 0) {
          int up = line_lengths[y - 1] + 1;
          if (cursor - up >= 0) cursor -= up;
        }
        break;
      case KC_END:
        cursor = MAX(0, ulen);
        break;
      case KC_HOME:
        cursor = 0;
        break;
      case KC_BACKSPACE:
      case KC_DELETE: {
        char *ocurs, *oshift;
        if ((ke.code == KC_BACKSPACE && cursor == 0) ||
            (ke.code == KC_DELETE && cursor >= ulen))
          break;
        ocurs = utf8_fskip(buffer, cursor, NULL);
        assert(ocurs);
        if (ke.code == KC_BACKSPACE) {
          oshift = utf8_rskip(ocurs, 1, buffer);
          assert(oshift);
          memmove(oshift, ocurs, len - (ocurs - buffer));
          --cursor;
          len -= ocurs - oshift;
        } else {
          oshift = utf8_fskip(ocurs, 1, NULL);
          assert(oshift);
          memmove(ocurs, oshift, len - (oshift - buffer));
          len -= oshift - ocurs;
        }
        buffer[len] = '\0';
        break;
      }
      default: {
        bool atnull = (cursor == ulen);
        char encoded[5];
        int n_enc;
        char* ocurs;
        if (!keycode_isprint(ke.code)) break;
        n_enc = utf32_to_utf8(encoded, N_ELEMENTS(encoded), &ke.code, 1, NULL);
        if (n_enc == 0 || n_enc + len >= buflen) {
          break;
        }
        if (atnull) {
          ocurs = buffer + len;
        } else {
          ocurs = utf8_fskip(buffer, cursor, NULL);
          assert(ocurs);
          memmove(ocurs + n_enc, ocurs, len - (ocurs - buffer));
        }
        memcpy(ocurs, encoded, n_enc);
        ++cursor;
        len += n_enc;
        buffer[len] = '\0';
        break;
      }
    }
    mem_free(line_starts);
    mem_free(line_lengths);
    textblock_free(tb);
  }
  return 0;
}
STATIC_OVL enum birth_stage
get_ahw_command(void)
{
  enum birth_stage next = 0;
  struct keypress ke;
  prt("Accept age, height and weight? [y/n]", 0, 0);
  ke = inkey();
  if (ke.code == KTRL('X')) {
    quit(NULL);
  } else if (ke.code == ESCAPE) {
    next = BIRTH_BACK;
  } else if (ke.code == 'N' || ke.code == 'n') {
    get_ahw(player);
    next = BIRTH_AHW_CHOICE;
  } else {
    next = BIRTH_HISTORY_CHOICE;
  }
  return next;
}
STATIC_OVL enum birth_stage
get_history_command(void)
{
  enum birth_stage next = 0;
  struct keypress ke;
  char old_history[240];
  my_strcpy(old_history, player->history, sizeof(old_history));
  prt("Accept character history? [y/n]", 0, 0);
  ke = inkey();
  if (ke.code == KTRL('X')) {
    quit(NULL);
  } else if (ke.code == ESCAPE) {
    next = BIRTH_BACK;
  } else if (ke.code == 'N' || ke.code == 'n') {
    char history[240];
    my_strcpy(history, player->history, sizeof(history));
    switch (edit_text(history, sizeof(history))) {
      case -1:
        next = BIRTH_BACK;
        break;
      case 0:
        cmdq_push(CMD_HISTORY_CHOICE);
        cmd_set_arg_string(cmdq_peek(), "history", history);
        next = BIRTH_HISTORY_CHOICE;
    }
  } else {
    next = BIRTH_FINAL_CONFIRM;
  }
  return next;
}
STATIC_OVL enum birth_stage
get_confirm_command(void)
{
  const char* prompt =
      "['ESC' to step back, 'S' to start over, or any other key to continue]";
  struct keypress ke;
  enum birth_stage next = BIRTH_RESET;
  prt(prompt, Term->hgt - 1, Term->wid / 2 - strlen(prompt) / 2);
  ke = inkey();
  if (ke.code == 'S' || ke.code == 's') {
    next = BIRTH_RESET;
  } else if (ke.code == KTRL('X')) {
    quit(NULL);
  } else if (ke.code == ESCAPE) {
    next = BIRTH_BACK;
  } else {
    cmdq_push(CMD_ACCEPT_CHARACTER);
    next = BIRTH_COMPLETE;
  }
  clear_from(23);
  return next;
}
STATIC_OVL int
textui_do_birth(void)
{
  enum birth_stage current_stage = BIRTH_RESET;
  enum birth_stage prev = BIRTH_BACK;
  enum birth_stage next = current_stage;
  bool done = false;
  cmdq_push(CMD_BIRTH_INIT);
  cmdq_execute(CTX_BIRTH);
  while (!done) {
    switch (current_stage) {
      case BIRTH_RESET: {
        cmdq_push(CMD_BIRTH_RESET);
        if (quickstart_allowed)
          next = BIRTH_QUICKSTART;
        else
          next = BIRTH_RACE_CHOICE;
        break;
      }
      case BIRTH_QUICKSTART: {
        display_player(0);
        next = textui_birth_quickstart();
        if (next == BIRTH_COMPLETE) done = true;
        break;
      }
      case BIRTH_HOUSE_CHOICE:
      case BIRTH_RACE_CHOICE:
      case BIRTH_SEX_CHOICE: {
        struct menu* menu = &race_menu;
        cmd_code command = CMD_CHOOSE_RACE;
        Term_clear();
        print_menu_instructions();
        if (current_stage > BIRTH_RACE_CHOICE) {
          menu_refresh(&race_menu, false);
          free_birth_menu(&house_menu);
          setup_house_menu(player->race);
          menu = &house_menu;
          command = CMD_CHOOSE_HOUSE;
        }
        if (current_stage > BIRTH_HOUSE_CHOICE) {
          menu_refresh(&house_menu, false);
          menu = &sex_menu;
          command = CMD_CHOOSE_SEX;
        }
        next = menu_question(current_stage, menu, command);
        if (next == BIRTH_BACK) {
          next = current_stage - 1;
        }
        if (next == BIRTH_QUICKSTART) next = BIRTH_RESET;
        break;
      }
      case BIRTH_STAT_POINTS: {
        stat_points_start();
        cmdq_push(CMD_REFRESH_STATS);
        cmdq_execute(CTX_BIRTH);
        next = stat_points_command();
        if (next == BIRTH_BACK) next = BIRTH_SEX_CHOICE;
        stat_points_stop();
        break;
      }
      case BIRTH_SKILL_POINTS: {
        int skill_action = gain_skills(CTX_BIRTH, (prev == BIRTH_STAT_POINTS));
        if (skill_action > 0) {
          next = BIRTH_NAME_CHOICE;
        } else if (skill_action < 0) {
          next = BIRTH_STAT_POINTS;
        } else {
          next = BIRTH_SKILL_POINTS;
        }
        break;
      }
      case BIRTH_NAME_CHOICE: {
        if (prev < BIRTH_NAME_CHOICE) display_player(0);
        next = get_name_command();
        if (next == BIRTH_BACK) next = BIRTH_SKILL_POINTS;
        break;
      }
      case BIRTH_AHW_CHOICE: {
        if (prev < BIRTH_AHW_CHOICE) display_player(0);
        next = get_ahw_command();
        if (next == BIRTH_BACK) next = BIRTH_NAME_CHOICE;
        break;
      }
      case BIRTH_HISTORY_CHOICE: {
        if (prev < BIRTH_HISTORY_CHOICE) display_player(0);
        next = get_history_command();
        if (next == BIRTH_BACK) next = BIRTH_AHW_CHOICE;
        break;
      }
      case BIRTH_FINAL_CONFIRM: {
        if (prev < BIRTH_FINAL_CONFIRM) display_player(0);
        next = get_confirm_command();
        if (next == BIRTH_BACK) next = BIRTH_HISTORY_CHOICE;
        if (next == BIRTH_COMPLETE) done = true;
        break;
      }
      default: {
      }
    }
    prev = current_stage;
    current_stage = next;
    cmdq_execute(CTX_BIRTH);
  }
  return 0;
}
STATIC_OVL void
ui_enter_birthscreen(game_event_type type, game_event_data* data, void* user)
{
  quickstart_allowed = data->flag;
  setup_menus();
}
STATIC_OVL void
ui_leave_birthscreen(game_event_type type, game_event_data* data, void* user)
{
  if (!savefile[0]) savefile_set_name(player->full_name, true, true);
  free_birth_menus();
}
STATIC_OVL void
ui_init_birthstate_handlers(void)
{
  event_add_handler(EVENT_ENTER_BIRTH, ui_enter_birthscreen, NULL);
  event_add_handler(EVENT_LEAVE_BIRTH, ui_leave_birthscreen, NULL);
}
STATIC_OVL void
new_combat_round(game_event_type type, game_event_data* data, void* user)
{
  int i;
  if (combat_number != 0) combat_number_old = combat_number;
  combat_number = 0;
  turns_since_combat++;
  if (turns_since_combat == 1) {
    for (i = 0; i < MAX_COMBAT_ROLLS; i++) {
      memcpy(&combat_rolls[1][i], &combat_rolls[0][i],
             sizeof(struct combat_roll));
    }
  } else if (turns_since_combat == 11) {
    combat_number_old = 0;
    for (i = 0; i < MAX_COMBAT_ROLLS; i++) {
      combat_rolls[1][i].att_type = COMBAT_ROLL_NONE;
    }
  }
  for (i = 0; i < MAX_COMBAT_ROLLS; i++) {
    combat_rolls[0][i].att_type = COMBAT_ROLL_NONE;
  }
  player->upkeep->redraw |= (PR_COMBAT);
}
STATIC_OVL void
update_combat_rolls_attack(game_event_type type, game_event_data* data,
                           void* user)
{
  struct monster* mon;
  struct monster_race* race1 = NULL;
  struct monster_race* race2 = NULL;
  struct source attacker = data->combat_attack.attacker;
  struct source defender = data->combat_attack.defender;
  bool vis = data->combat_attack.vis;
  int att = data->combat_attack.att;
  int att_roll = data->combat_attack.att_roll;
  int evn = data->combat_attack.evn;
  int evn_roll = data->combat_attack.evn_roll;
  bool melee = data->combat_attack.melee;
  switch (attacker.what) {
    case SRC_PLAYER:
      race1 = &r_info[0];
      break;
    case SRC_MONSTER: {
      mon = cave_monster(cave, attacker.which.monster);
      if (player->timed[TMD_IMAGE]) {
        race1 = mon->image_race;
      } else {
        race1 = mon->race;
      }
      break;
    }
    case SRC_TRAP:
      break;
    default:
      break;
  }
  switch (defender.what) {
    case SRC_PLAYER:
      race2 = &r_info[0];
      break;
    case SRC_MONSTER: {
      mon = cave_monster(cave, defender.which.monster);
      if (player->timed[TMD_IMAGE]) {
        race2 = mon->image_race;
      } else {
        race2 = mon->race;
      }
      break;
    }
    default:
      break;
  }
  if (combat_number < MAX_COMBAT_ROLLS) {
    combat_rolls[0][combat_number].att_type =
        melee ? COMBAT_ROLL_ROLL : COMBAT_ROLL_AUTO;
    if (attacker.what == SRC_GRID) {
      combat_rolls[0][combat_number].attacker_char =
          square_feat(cave, player->grid)->d_char;
      combat_rolls[0][combat_number].attacker_attr =
          square_feat(cave, player->grid)->d_attr;
    } else if (attacker.what == SRC_TRAP) {
      combat_rolls[0][combat_number].attacker_char =
          attacker.which.trap->kind->d_char;
      combat_rolls[0][combat_number].attacker_attr =
          attacker.which.trap->kind->d_attr;
    } else if ((vis && (attacker.what == SRC_MONSTER)) ||
               (attacker.what == SRC_PLAYER)) {
      combat_rolls[0][combat_number].attacker_char = race1->d_char;
      if (player->timed[TMD_RAGE] && (attacker.what != SRC_PLAYER)) {
        combat_rolls[0][combat_number].attacker_attr = COLOUR_RED;
      } else {
        combat_rolls[0][combat_number].attacker_attr = race1->d_attr;
      }
    } else {
      combat_rolls[0][combat_number].attacker_char = L'?';
      combat_rolls[0][combat_number].attacker_attr = COLOUR_SLATE;
    }
    if ((defender.what == SRC_NONE) && melee) {
      combat_rolls[0][combat_number].defender_char = L']';
      combat_rolls[0][combat_number].defender_attr = COLOUR_L_DARK;
    } else if ((vis && (defender.what == SRC_MONSTER)) ||
               (defender.what == SRC_PLAYER)) {
      combat_rolls[0][combat_number].defender_char = race2->d_char;
      if (player->timed[TMD_RAGE] && (defender.what != SRC_PLAYER)) {
        combat_rolls[0][combat_number].defender_attr = COLOUR_RED;
      } else {
        combat_rolls[0][combat_number].defender_attr = race2->d_attr;
      }
    } else {
      combat_rolls[0][combat_number].defender_char = L'?';
      combat_rolls[0][combat_number].defender_attr = COLOUR_SLATE;
    }
    if (melee) {
      combat_rolls[0][combat_number].att = att;
      combat_rolls[0][combat_number].att_roll = att_roll;
      combat_rolls[0][combat_number].evn = evn;
      combat_rolls[0][combat_number].evn_roll = evn_roll;
    }
    combat_number++;
    turns_since_combat = 0;
  }
  player->upkeep->redraw |= (PR_COMBAT);
}
STATIC_OVL void
update_combat_rolls_damage(game_event_type type, game_event_data* data,
                           void* user)
{
  int dd = data->combat_damage.dd;
  int ds = data->combat_damage.ds;
  int dam = data->combat_damage.dam;
  int pd = data->combat_damage.pd;
  int ps = data->combat_damage.ps;
  int prot = data->combat_damage.prot;
  int prt_percent = data->combat_damage.prt_percent;
  int dam_type = data->combat_damage.dam_type;
  bool melee = data->combat_damage.melee;
  if (combat_number - 1 < MAX_COMBAT_ROLLS) {
    combat_rolls[0][combat_number - 1].dam_type = dam_type;
    combat_rolls[0][combat_number - 1].dd = dd;
    combat_rolls[0][combat_number - 1].ds = ds;
    combat_rolls[0][combat_number - 1].dam = dam;
    combat_rolls[0][combat_number - 1].pd = pd;
    combat_rolls[0][combat_number - 1].ps = ps;
    combat_rolls[0][combat_number - 1].prot = prot;
    combat_rolls[0][combat_number - 1].prt_percent = prt_percent;
    combat_rolls[0][combat_number - 1].melee = melee;
    if (pd == -1) {
      if (combat_rolls[0][combat_number - 1].att_type == COMBAT_ROLL_AUTO) {
        combat_rolls[0][combat_number - 1].pd =
            protection_roll(player, dam_type, melee, MINIMISE);
        combat_rolls[0][combat_number - 1].ps =
            protection_roll(player, dam_type, melee, MAXIMISE);
      } else {
        combat_rolls[0][combat_number - 1].pd =
            protection_roll(player, PROJ_HURT, melee, MINIMISE);
        combat_rolls[0][combat_number - 1].ps =
            protection_roll(player, PROJ_HURT, melee, MAXIMISE);
      }
    }
  }
  player->upkeep->redraw |= (PR_COMBAT);
}
STATIC_OVL void
display_combat_rolls(game_event_type type, game_event_data* data, void* user)
{
  int i;
  int line = 0;
  char buf[80];
  int net_att = 0;
  int net_dam;
  int a_att;
  int a_evn;
  int a_hit;
  int a_dam_roll;
  int a_prot_roll;
  int a_net_dam;
  int round;
  int combat_num_for_round = combat_number;
  int total_player_attacks = 0;
  int player_attacks = 0;
  int monster_attacks = 0;
  int line_jump = 0;
  int res = 1;
  for (i = 0; i < Term->hgt; i++) {
    Term_erase(0, i, 255);
  }
  for (round = 0; round < 2; round++) {
    if (round == 1) {
      combat_num_for_round = combat_number_old;
      line_jump = player_attacks + monster_attacks + 2;
      if (player_attacks > 0) line_jump++;
      if (monster_attacks > 0) line_jump++;
      if (combat_number + combat_number_old > 0) {
        Term_putstr(0, line_jump - 1, 80, COLOUR_L_DARK,
                    "__________________________________________________________"
                    "_____________________");
      }
    }
    total_player_attacks = 0;
    player_attacks = 0;
    monster_attacks = 0;
    for (i = 0; i < combat_num_for_round; i++) {
      if ((combat_rolls[round][i].attacker_char == r_info[0].d_char) &&
          (combat_rolls[round][i].attacker_attr == r_info[0].d_attr)) {
        total_player_attacks++;
      }
    }
    for (i = 0; i < combat_num_for_round; i++) {
      a_net_dam = COLOUR_L_RED;
      res = 1;
      if ((combat_rolls[round][i].defender_char == r_info[0].d_char) &&
          (combat_rolls[round][i].defender_attr == r_info[0].d_attr)) {
        int dam_type = combat_rolls[round][i].dam_type;
        if (dam_type && (dam_type < ELEM_MAX)) {
          res = player->state.el_info[dam_type].res_level;
        }
      }
      if ((combat_rolls[round][i].attacker_char == r_info[0].d_char) &&
          (combat_rolls[round][i].attacker_attr == r_info[0].d_attr)) {
        player_attacks++;
        a_att = COLOUR_L_BLUE;
        a_evn = COLOUR_WHITE;
        a_hit = COLOUR_L_RED;
        a_dam_roll = COLOUR_L_BLUE;
        if (combat_rolls[round][i].prt_percent >= 100) {
          a_prot_roll = COLOUR_WHITE;
        } else if (combat_rolls[round][i].prt_percent >= 1) {
          a_prot_roll = COLOUR_SLATE;
        } else {
          a_prot_roll = COLOUR_DARK;
        }
        line = player_attacks + line_jump;
      } else {
        monster_attacks++;
        a_att = COLOUR_WHITE;
        a_evn = COLOUR_L_BLUE;
        a_hit = COLOUR_L_RED;
        a_dam_roll = COLOUR_WHITE;
        if (combat_rolls[round][i].prt_percent >= 100)
          a_prot_roll = COLOUR_L_BLUE;
        else if (combat_rolls[round][i].prt_percent >= 1)
          a_prot_roll = COLOUR_BLUE;
        else
          a_prot_roll = COLOUR_DARK;
        line = 1 + total_player_attacks + monster_attacks + line_jump;
        if (total_player_attacks == 0) line--;
      }
      Term_putstr(0, line, 1, COLOUR_WHITE, " ");
      Term_addch(combat_rolls[round][i].attacker_attr,
                 combat_rolls[round][i].attacker_char);
      if (combat_rolls[round][i].att_type == COMBAT_ROLL_ROLL) {
        if (combat_rolls[round][i].att < 10) {
          strnfmt(buf, sizeof(buf), "  (%+d)", combat_rolls[round][i].att);
        } else {
          strnfmt(buf, sizeof(buf), " (%+d)", combat_rolls[round][i].att);
        }
        Term_addstr(-1, a_att, buf);
        strnfmt(buf, sizeof(buf), "%4d",
                combat_rolls[round][i].att + combat_rolls[round][i].att_roll);
        Term_addstr(-1, a_att, buf);
        net_att = combat_rolls[round][i].att_roll + combat_rolls[round][i].att -
                  combat_rolls[round][i].evn_roll - combat_rolls[round][i].evn;
        if (net_att > 0) {
          strnfmt(buf, sizeof(buf), "%4d", net_att);
          Term_addstr(-1, a_hit, buf);
        } else {
          Term_addstr(-1, COLOUR_SLATE, "   -");
        }
        strnfmt(buf, sizeof(buf), "%4d",
                combat_rolls[round][i].evn + combat_rolls[round][i].evn_roll);
        Term_addstr(-1, a_evn, buf);
        if (combat_rolls[round][i].evn < 10) {
          strnfmt(buf, sizeof(buf), "   [%+d]", combat_rolls[round][i].evn);
        } else {
          strnfmt(buf, sizeof(buf), "  [%+d]", combat_rolls[round][i].evn);
        }
        Term_addstr(-1, a_evn, buf);
        Term_addch(COLOUR_WHITE, ' ');
        Term_addch(combat_rolls[round][i].defender_attr,
                   combat_rolls[round][i].defender_char);
      } else if (combat_rolls[round][i].att_type == COMBAT_ROLL_AUTO) {
        Term_addstr(-1, COLOUR_L_DARK, "                         ");
        Term_addch(COLOUR_WHITE, ' ');
        Term_addch(combat_rolls[round][i].defender_attr,
                   combat_rolls[round][i].defender_char);
      }
      if ((net_att > 0) ||
          (combat_rolls[round][i].att_type == COMBAT_ROLL_AUTO)) {
        Term_addstr(-1, COLOUR_L_DARK, "  ->");
        if (combat_rolls[round][i].ds < 10) {
          strnfmt(buf, sizeof(buf), "   (%dd%d)", combat_rolls[round][i].dd,
                  combat_rolls[round][i].ds);
        } else {
          strnfmt(buf, sizeof(buf), "  (%dd%d)", combat_rolls[round][i].dd,
                  combat_rolls[round][i].ds);
        }
        Term_addstr(-1, a_dam_roll, buf);
        strnfmt(buf, sizeof(buf), "%4d", combat_rolls[round][i].dam);
        Term_addstr(-1, a_dam_roll, buf);
        if (combat_rolls[round][i].att_type == COMBAT_ROLL_ROLL) {
          net_dam = combat_rolls[round][i].dam - combat_rolls[round][i].prot;
          if (net_dam > 0) {
            strnfmt(buf, sizeof(buf), "%4d", net_dam);
            Term_addstr(-1, a_net_dam, buf);
          } else {
            Term_addstr(-1, COLOUR_SLATE, "   -");
          }
          strnfmt(buf, sizeof(buf), "%4d", combat_rolls[round][i].prot);
          Term_addstr(-1, a_prot_roll, buf);
          if ((combat_rolls[round][i].defender_char != r_info[0].d_char) ||
              (combat_rolls[round][i].defender_attr != r_info[0].d_attr)) {
            if ((combat_rolls[round][i].ps < 1) ||
                (combat_rolls[round][i].pd < 1)) {
              my_strcpy(buf, "        ", sizeof(buf));
              Term_addstr(-1, a_prot_roll, buf);
            } else if (combat_rolls[round][i].ps < 10) {
              strnfmt(buf, sizeof(buf), "   [%dd%d]", combat_rolls[round][i].pd,
                      combat_rolls[round][i].ps);
              Term_addstr(-1, a_prot_roll, buf);
            } else {
              strnfmt(buf, sizeof(buf), "  [%dd%d]", combat_rolls[round][i].pd,
                      combat_rolls[round][i].ps);
              Term_addstr(-1, a_prot_roll, buf);
            }
            if ((combat_rolls[round][i].prt_percent > 0) &&
                (combat_rolls[round][i].prt_percent < 100)) {
              strnfmt(buf, sizeof(buf), " (%d%%)",
                      combat_rolls[round][i].prt_percent);
              Term_addstr(-1, a_prot_roll, buf);
            }
          } else {
            strnfmt(buf, sizeof(buf), "  [%d-%d]",
                    (combat_rolls[round][i].pd *
                     combat_rolls[round][i].prt_percent) /
                        100,
                    (combat_rolls[round][i].ps *
                     combat_rolls[round][i].prt_percent) /
                        100);
            Term_addstr(-1, a_prot_roll, buf);
          }
        } else if (combat_rolls[round][i].att_type == COMBAT_ROLL_AUTO) {
          if (combat_rolls[round][i].melee) {
            net_dam = combat_rolls[round][i].dam - combat_rolls[round][i].prot;
          } else if (res > 0) {
            net_dam = (combat_rolls[round][i].dam / res) -
                      combat_rolls[round][i].prot;
          } else {
            net_dam = (combat_rolls[round][i].dam * (-res)) -
                      combat_rolls[round][i].prot;
          }
          if (net_dam > 0) {
            strnfmt(buf, sizeof(buf), "%4d", net_dam);
            Term_addstr(-1, a_net_dam, buf);
          } else {
            Term_addstr(-1, COLOUR_SLATE, "   -");
          }
          strnfmt(buf, sizeof(buf), "%4d", combat_rolls[round][i].prot);
          Term_addstr(-1, a_prot_roll, buf);
          if ((combat_rolls[round][i].defender_char != r_info[0].d_char) ||
              (combat_rolls[round][i].defender_attr != r_info[0].d_attr)) {
            if ((combat_rolls[round][i].ps < 1) ||
                (combat_rolls[round][i].pd < 1)) {
              my_strcpy(buf, "        ", sizeof(buf));
              Term_addstr(-1, a_prot_roll, buf);
            } else if (combat_rolls[round][i].ps < 10) {
              strnfmt(buf, sizeof(buf), "   [%dd%d]", combat_rolls[round][i].pd,
                      combat_rolls[round][i].ps);
              Term_addstr(-1, a_prot_roll, buf);
            } else {
              strnfmt(buf, sizeof(buf), "  [%dd%d]", combat_rolls[round][i].pd,
                      combat_rolls[round][i].ps);
              Term_addstr(-1, a_prot_roll, buf);
            }
            if ((combat_rolls[round][i].prt_percent > 0) &&
                (combat_rolls[round][i].prt_percent < 100)) {
              strnfmt(buf, sizeof(buf), " (%d%%)",
                      combat_rolls[round][i].prt_percent);
              Term_addstr(-1, a_prot_roll, buf);
            }
          } else {
            if (!(combat_rolls[round][i].melee)) {
              if (res > 1) {
                strnfmt(buf, sizeof(buf), "  1/%d then", res);
                Term_addstr(-1, COLOUR_L_BLUE, buf);
              } else if (res < 0) {
                strnfmt(buf, sizeof(buf), "  x%d then", -res);
                Term_addstr(-1, COLOUR_L_BLUE, buf);
              }
            }
            if (combat_rolls[round][i].ps < 10) {
              strnfmt(buf, sizeof(buf), "  [%d-%d]", combat_rolls[round][i].pd,
                      combat_rolls[round][i].ps);
              Term_addstr(-1, a_prot_roll, buf);
            } else {
              strnfmt(buf, sizeof(buf), " [%d-%d]", combat_rolls[round][i].pd,
                      combat_rolls[round][i].ps);
              Term_addstr(-1, a_prot_roll, buf);
            }
          }
        }
      }
    }
  }
}
STATIC_OVL void
do_cmd_redraw(void)
{
  Term_flush();
  event_signal(EVENT_INPUT_FLUSH);
  if (character_dungeon) verify_panel();
  Term_xtra(TERM_XTRA_REACT, 0);
  if (character_dungeon) {
    player->upkeep->notice |= (PN_COMBINE);
    player->upkeep->update |= (PU_TORCH | PU_INVEN);
    player->upkeep->update |= (PU_BONUS | PU_HP | PU_SPELLS);
    player->upkeep->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
    player->upkeep->redraw |=
        (PR_BASIC | PR_EXTRA | PR_MAP | PR_INVEN | PR_EQUIP | PR_MESSAGE |
         PR_MONSTER | PR_OBJECT | PR_MONLIST | PR_ITEMLIST);
  }
  Term_clear();
  if (character_dungeon) {
    handle_stuff(player);
    if ((0 != character_dungeon) && target_sighted()) {
      struct loc target;
      target_get(&target);
      move_cursor_relative(target.y, target.x);
    } else {
      move_cursor_relative(player->grid.y, player->grid.x);
    }
  }
  (void)Term_redraw_all();
}
STATIC_OVL void
do_cmd_xxx_options(void)
{
  do_cmd_options();
  do_cmd_redraw();
}
STATIC_OVL void
do_cmd_unknown(void)
{
  prt("Type '?' for help.", 0, 0);
}
STATIC_OVL void
do_cmd_version(void)
{
  char header_buf[120];
  textblock* tb = textblock_new();
  region local_area = {0, 0, 0, 0};
  my_strcpy(header_buf,
            format("You are playing %s.  Type '?' for more info.", buildver),
            sizeof(header_buf));
  textblock_append(tb, "\n");
  textblock_append(tb, "%s", copyright);
  textui_textblock_show(tb, local_area, header_buf);
  textblock_free(tb);
}
STATIC_OVL void
textui_cmd_retire(void)
{
  struct keypress ch;
  event_signal(EVENT_INPUT_FLUSH);
  if (!get_check("Do you really want to retire?")) return;
  prt("Please verify RETIRING THIS CHARACTER by typing the '@' sign: ", 0, 0);
  event_signal(EVENT_INPUT_FLUSH);
  ch = inkey();
  prt("", 0, 0);
  if (ch.code != '@') return;
  cmdq_push(CMD_RETIRE);
}
STATIC_OVL void
textui_cmd_rest(void)
{
  const char* p =
      "Rest (0-9999, '!' for HP or SP, '*' for HP and SP, '&' as needed): ";
  char out_val[5] = "& ";
  if (!get_string(p, out_val, sizeof(out_val))) return;
  if (out_val[0] == '&') {
    cmdq_push(CMD_REST);
    cmd_set_arg_choice(cmdq_peek(), "choice", REST_COMPLETE);
  } else if (out_val[0] == '*') {
    cmdq_push(CMD_REST);
    cmd_set_arg_choice(cmdq_peek(), "choice", REST_ALL_POINTS);
  } else if (out_val[0] == '!') {
    cmdq_push(CMD_REST);
    cmd_set_arg_choice(cmdq_peek(), "choice", REST_SOME_POINTS);
  } else {
    int turns = atoi(out_val);
    if (turns <= 0) return;
    if (turns > 9999) turns = 9999;
    cmdq_push(CMD_REST);
    cmd_set_arg_choice(cmdq_peek(), "choice", turns);
  }
}
STATIC_OVL void
textui_quit(void)
{
  if (in_tutorial() && !get_check("Really exit the tutorial? ")) {
    return;
  }
  player->upkeep->playing = false;
}
STATIC_OVL void
write_html_escape_char(ang_file* fp, char* mbbuf, wchar_t c)
{
  switch (c) {
    case L'<':
      file_putf(fp, "&lt;");
      break;
    case L'>':
      file_putf(fp, "&gt;");
      break;
    case L'&':
      file_putf(fp, "&amp;");
      break;
    default: {
      int nc = text_wctomb(mbbuf, c);
      if (nc > 0) {
        mbbuf[nc] = 0;
      } else {
        mbbuf[0] = ' ';
        mbbuf[1] = 0;
      }
      file_putf(fp, "%s", mbbuf);
      break;
    }
  }
}
STATIC_OVL void
screenshot_term_query(int wid, int hgt, int x, int y, int* a, wchar_t* c)
{
  if (y < ROW_MAP || y >= hgt - ROW_BOTTOM_MAP || x < COL_MAP) {
    (void)Term_what(x, y, a, c);
  } else {
    int srcx = (x - COL_MAP) * tile_width + COL_MAP;
    int srcy = (y - ROW_MAP) * tile_height + ROW_MAP;
    if (srcx < wid && srcy < hgt - ROW_BOTTOM_MAP) {
      (void)Term_what(srcx, srcy, a, c);
    } else {
      *a = COLOUR_WHITE;
      *c = ' ';
    }
  }
}
STATIC_OVL void
html_screenshot(const char* path, int mode, term* other_term)
{
  bool other_left = false;
  int y, x;
  int main_wid, main_hgt, other_wid, other_hgt, wid, hgt;
  int main_xst, other_xst;
  int a = COLOUR_WHITE;
  int oa = COLOUR_WHITE;
  int fg_colour = COLOUR_WHITE;
  int bg_colour = COLOUR_DARK;
  wchar_t c = L' ';
  term* main_term = Term;
  const char* new_color_fmt =
      "<font color=\"#%02X%02X%02X\" style=\"background-color: "
      "#%02X%02X%02X\">";
  const char* change_color_fmt =
      (mode == 0) ? "</font><font color=\"#%02X%02X%02X\" "
                    "style=\"background-color: #%02X%02X%02X\">"
                  : "[/COLOR][COLOR=\"#%02X%02X%02X\"]";
  const char* close_color_str = "</font>";
  char* mbbuf;
  ang_file* fp;
  mbbuf = mem_alloc(text_wcsz() + 1);
  fp = file_open(path, MODE_WRITE, FTYPE_TEXT);
  if (!fp) {
    mem_free(mbbuf);
    plog_fmt("Cannot write the '%s' file!", path);
    return;
  }
  Term_get_size(&main_wid, &main_hgt);
  if (other_term) {
    Term_activate(other_term);
    Term_get_size(&other_wid, &other_hgt);
    Term_activate(main_term);
  } else {
    other_wid = 0;
    other_hgt = 0;
  }
  if (other_left) {
    other_xst = 0;
    main_xst = (other_wid > 0) ? other_wid + 1 : 0;
  } else {
    other_xst = main_wid + 1;
    main_xst = 0;
  }
  hgt = MAX(main_hgt, other_hgt);
  wid = (other_wid > 0) ? main_wid + other_wid + 1 : main_wid;
  if (mode == 0) {
    file_putf(fp, "<!DOCTYPE html><html><head>\n");
    file_putf(fp,
              "  <meta http-equiv='Content-Type' content='text/html; "
              "charset=utf-8'>\n");
    file_putf(fp, "  <meta name='generator' content='%s'>\n", buildid);
    file_putf(fp, "  <title>%s</title>\n", path);
    file_putf(fp, "</head>\n\n");
    file_putf(
        fp, "<body style='color: #%02X%02X%02X; background: #%02X%02X%02X;'>\n",
        angband_color_table[COLOUR_WHITE][1],
        angband_color_table[COLOUR_WHITE][2],
        angband_color_table[COLOUR_WHITE][3],
        angband_color_table[COLOUR_DARK][1],
        angband_color_table[COLOUR_DARK][2],
        angband_color_table[COLOUR_DARK][3]);
    file_putf(fp, "<pre>\n");
  } else {
    file_putf(fp, "[CODE][TT][BC=\"#%02X%02X%02X\"][COLOR=\"#%02X%02X%02X\"]\n",
              angband_color_table[COLOUR_DARK][1],
              angband_color_table[COLOUR_DARK][2],
              angband_color_table[COLOUR_DARK][3],
              angband_color_table[COLOUR_WHITE][1],
              angband_color_table[COLOUR_WHITE][2],
              angband_color_table[COLOUR_WHITE][3]);
  }
  for (y = 0; y < hgt; y++) {
    for (x = 0; x < wid; x++) {
      if (x >= main_xst && x < main_xst + main_wid && y < main_hgt) {
        screenshot_term_query(wid, hgt, x - main_xst, y, &a, &c);
      } else if (x >= other_xst && x < other_xst + other_wid && y < other_hgt) {
        if (x == other_xst) {
          Term_activate(other_term);
        }
        Term_what(x - other_xst, y, &a, &c);
        if (x == other_xst + other_wid - 1) {
          Term_activate(main_term);
        }
      } else {
        a = COLOUR_WHITE;
        c = ' ';
      }
      fg_colour = a % MAX_COLORS;
      switch (a / MULT_BG) {
        case BG_BLACK:
          bg_colour = COLOUR_DARK;
          break;
        case BG_SAME:
          bg_colour = fg_colour;
          break;
        case BG_DARK:
          bg_colour = COLOUR_SHADE;
          break;
        default:
          assert((a >= 0) && (a < BG_MAX * MULT_BG));
      }
      if (oa != a && (mode == 0 || c != L' ')) {
        if (oa == COLOUR_WHITE && mode == 0) {
          file_putf(fp, new_color_fmt, angband_color_table[fg_colour][1],
                    angband_color_table[fg_colour][2],
                    angband_color_table[fg_colour][3],
                    angband_color_table[bg_colour][1],
                    angband_color_table[bg_colour][2],
                    angband_color_table[bg_colour][3]);
        } else if (fg_colour == COLOUR_WHITE && bg_colour == COLOUR_DARK &&
                   mode == 0) {
          file_putf(fp, "%s", close_color_str);
        } else {
          file_putf(fp, change_color_fmt, angband_color_table[fg_colour][1],
                    angband_color_table[fg_colour][2],
                    angband_color_table[fg_colour][3],
                    angband_color_table[bg_colour][1],
                    angband_color_table[bg_colour][2],
                    angband_color_table[bg_colour][3]);
        }
        oa = a;
      }
      if (mode == 0)
        write_html_escape_char(fp, mbbuf, c);
      else {
        int nc = text_wctomb(mbbuf, c);
        if (nc > 0) {
          mbbuf[nc] = 0;
        } else {
          mbbuf[0] = ' ';
          mbbuf[1] = 0;
        }
        file_putf(fp, "%s", mbbuf);
      }
    }
    file_putf(fp, "\n");
  }
  if (oa != COLOUR_WHITE && mode == 0) file_putf(fp, "%s", close_color_str);
  if (mode == 0) {
    file_putf(fp, "</pre>\n");
    file_putf(fp, "</body>\n");
    file_putf(fp, "</html>\n");
  } else {
    file_putf(fp, "[/COLOR][/BC][/TT][/CODE]\n");
  }
  file_close(fp);
  mem_free(mbbuf);
}
STATIC_OVL void
do_cmd_save_screen_html(int mode, term* other_term)
{
  size_t i;
  ang_file* fff;
  char file_name[1024];
  char tmp_val[256];
  typedef void (*dump_func)(ang_file*);
  dump_func dump_visuals[] = {dump_monsters, dump_features, dump_objects,
                              dump_flavors, dump_colors};
  if (!get_file(mode == 0 ? "dump.html" : "dump.txt", tmp_val, sizeof(tmp_val)))
    return;
  path_build(file_name, sizeof(file_name), ANGBAND_DIR_USER, "dump.prf");
  fff = file_open(file_name, MODE_WRITE, FTYPE_TEXT);
  if (!fff) {
    msg("Screen dump failed.");
    event_signal(EVENT_MESSAGE_FLUSH);
    return;
  }
  for (i = 0; i < N_ELEMENTS(dump_visuals); i++) dump_visuals[i](fff);
  file_close(fff);
  reset_visuals(false);
  do_cmd_redraw();
  html_screenshot(tmp_val, mode, other_term);
  reset_visuals(true);
  process_pref_file(file_name, true, false);
  file_delete(file_name);
  do_cmd_redraw();
  msg("%s screen dump saved.", mode ? "Forum text" : "HTML");
  event_signal(EVENT_MESSAGE_FLUSH);
}
STATIC_OVL void
do_cmd_save_screen(void)
{
  char ch = get_char("Dump as (H)TML or (F)orum text? ", "hf", 2, ' ');
  int mode = 0;
  term* ml_term;
  switch (ch) {
    case 'h':
      mode = 0;
      break;
    case 'f':
      mode = 1;
      break;
    default:
      return;
  }
  ml_term = find_first_subwindow(PW_MONLIST);
  if (ml_term) {
    if (!get_check("Include monster list? ")) ml_term = NULL;
  }
  do_cmd_save_screen_html(mode, ml_term);
}
STATIC_OVL int
context_menu_player_2(int mx, int my)
{
  struct menu* m;
  int selected;
  char* labels;
  bool allowed = true;
  int mode =
      OPT(player, angband_keyset) ? KEYMAP_MODE_ANGBAND : KEYMAP_MODE_ORIG;
  unsigned char cmdkey;
  if (OPT(player, hjkl_movement)) {
    mode |= KEYMAP_MODE_ROGUE;
  }
  m = menu_dynamic_new();
  if (!m) {
    return 0;
  }
  labels = string_make(lower_case);
  m->selections = labels;
  menu_dynamic_add_label(m, "Knowledge", '~', MENU_VALUE_KNOWLEDGE, labels);
  menu_dynamic_add_label(m, "Show Map", 'M', MENU_VALUE_MAP, labels);
  menu_dynamic_add_label(m, "^Show Messages", 'P', MENU_VALUE_MESSAGES, labels);
  menu_dynamic_add_label(m, "Show Monster List", '[', MENU_VALUE_MONSTERS,
                         labels);
  menu_dynamic_add_label(m, "Show Object List", ']', MENU_VALUE_OBJECTS,
                         labels);
  menu_dynamic_add_label(m, "Toggle Ignored", 'K', MENU_VALUE_TOGGLE_IGNORED,
                         labels);
  {
    cmdkey = cmd_lookup_key_unktrl((CMD_IGNORE), mode);
    menu_dynamic_add_label_valid(m, ("Ignore an item"), cmdkey, (CMD_IGNORE),
                                 labels, (MN_ROW_VALID));
  };
  cmdkey = (mode & KEYMAP_MODE_ANGBAND) ? '=' : 'O';
  menu_dynamic_add_label(m, "Options", cmdkey, MENU_VALUE_OPTIONS, labels);
  menu_dynamic_add_label(m, "Commands", '?', MENU_VALUE_HELP, labels);
  msg_flag = false;
  screen_save();
  menu_dynamic_calc_location(m, mx, my);
  region_erase_bordered(&m->boundary);
  prt("(Enter to select, ESC) Command:", 0, 0);
  selected = menu_dynamic_select(m);
  menu_dynamic_free(m);
  string_free(labels);
  screen_load();
  switch (selected) {
    case -1:
      return 3;
    case MENU_VALUE_KNOWLEDGE:
    case MENU_VALUE_MAP:
    case MENU_VALUE_MESSAGES:
    case MENU_VALUE_TOGGLE_IGNORED:
    case MENU_VALUE_HELP:
    case MENU_VALUE_MONSTERS:
    case MENU_VALUE_OBJECTS:
    case MENU_VALUE_OPTIONS:
      allowed = true;
      break;
    case CMD_IGNORE:
      cmdkey = cmd_lookup_key(selected, mode);
      allowed = key_confirm_command(cmdkey);
      break;
    default:
      bell();
      allowed = false;
      break;
  }
  if (!allowed) return 1;
  switch (selected) {
    case MENU_VALUE_KNOWLEDGE:
      Term_keypress('~', 0);
      break;
    case MENU_VALUE_MAP:
      Term_keypress('M', 0);
      break;
    case MENU_VALUE_MESSAGES:
      Term_keypress(KTRL('p'), 0);
      break;
    case CMD_IGNORE:
      cmdkey = cmd_lookup_key(selected, mode);
      Term_keypress(cmdkey, 0);
      break;
    case MENU_VALUE_TOGGLE_IGNORED:
      Term_keypress('K', 0);
      break;
    case MENU_VALUE_HELP:
      context_menu_command(mx, my);
      break;
    case MENU_VALUE_MONSTERS:
      Term_keypress('[', 0);
      break;
    case MENU_VALUE_OBJECTS:
      Term_keypress(']', 0);
      break;
    case MENU_VALUE_OPTIONS:
      Term_keypress('=', 0);
      break;
    default:
      break;
  }
  return 1;
}
STATIC_OVL void
context_menu_player_display_floor(void)
{
  int diff = weight_remaining(player);
  struct object* obj;
  player->upkeep->command_wrk = (USE_FLOOR);
  screen_save();
  prt(format("(Inventory) Burden %d.%d lb (%d.%d lb %s). Item for command: ",
             player->upkeep->total_weight / 10,
             player->upkeep->total_weight % 10, abs(diff) / 10, abs(diff) % 10,
             (diff < 0 ? "overweight" : "remaining")),
      0, 0);
  if (get_item(&obj, NULL, NULL, CMD_NULL, NULL,
               USE_EQUIP | USE_INVEN | USE_QUIVER | USE_FLOOR | SHOW_EMPTY |
                   IS_HARMLESS)) {
    track_object(player->upkeep, obj);
    context_menu_object(obj);
  }
  screen_load();
}
STATIC_OVL int
context_menu_player(int mx, int my)
{
  struct menu* m;
  int selected;
  char* labels;
  bool allowed = true;
  int mode =
      OPT(player, angband_keyset) ? KEYMAP_MODE_ANGBAND : KEYMAP_MODE_ORIG;
  unsigned char cmdkey;
  struct object* obj;
  if (OPT(player, hjkl_movement)) {
    mode |= KEYMAP_MODE_ROGUE;
  }
  m = menu_dynamic_new();
  if (!m) {
    return 0;
  }
  labels = string_make(lower_case);
  m->selections = labels;
  {
    cmdkey = cmd_lookup_key_unktrl((CMD_USE), mode);
    menu_dynamic_add_label_valid(m, ("Use"), cmdkey, (CMD_USE), labels,
                                 (MN_ROW_VALID));
  };
  if (square_isupstairs(cave, player->grid)) {
    {
      cmdkey = cmd_lookup_key_unktrl((CMD_GO_UP), mode);
      menu_dynamic_add_label_valid(m, ("Go Up"), cmdkey, (CMD_GO_UP), labels,
                                   (MN_ROW_VALID));
    };
  } else if (square_isdownstairs(cave, player->grid)) {
    {
      cmdkey = cmd_lookup_key_unktrl((CMD_GO_DOWN), mode);
      menu_dynamic_add_label_valid(m, ("Go Down"), cmdkey, (CMD_GO_DOWN),
                                   labels, (MN_ROW_VALID));
    };
  }
  menu_dynamic_add_label(m, "Look", 'l', MENU_VALUE_LOOK, labels);
  menu_dynamic_add_label(m, "Rest", 'R', MENU_VALUE_REST, labels);
  menu_dynamic_add_label(m, "Inventory", 'i', MENU_VALUE_INVENTORY, labels);
  obj = square_object(cave, player->grid);
  if (obj && !ignore_item_ok(player, obj)) {
    menu_row_validity_t valid;
    menu_dynamic_add_label(m, "Floor", 'f', MENU_VALUE_FLOOR, labels);
    valid = (inven_carry_okay(obj)) ? MN_ROW_VALID : MN_ROW_INVALID;
    {
      cmdkey = cmd_lookup_key_unktrl((CMD_PICKUP), mode);
      menu_dynamic_add_label_valid(m, ("Pick up"), cmdkey, (CMD_PICKUP), labels,
                                   (valid));
    };
  }
  menu_dynamic_add_label(m, "Character", 'C', MENU_VALUE_CHARACTER, labels);
  if (!OPT(player, center_player)) {
    menu_dynamic_add_label(m, "^Center Map", 'L', MENU_VALUE_CENTER_MAP,
                           labels);
  }
  menu_dynamic_add_label(m, "Other", ' ', MENU_VALUE_OTHER, labels);
  msg_flag = false;
  screen_save();
  menu_dynamic_calc_location(m, mx, my);
  region_erase_bordered(&m->boundary);
  prt("(Enter to select, ESC) Command:", 0, 0);
  selected = menu_dynamic_select(m);
  menu_dynamic_free(m);
  string_free(labels);
  screen_load();
  cmdkey = cmd_lookup_key(selected, mode);
  switch (selected) {
    case -1:
      return 3;
    case CMD_USE:
    case CMD_GO_UP:
    case CMD_GO_DOWN:
    case CMD_PICKUP:
      allowed = key_confirm_command(cmdkey);
      break;
    case MENU_VALUE_REST:
      allowed = key_confirm_command('R');
      break;
    case MENU_VALUE_INVENTORY:
    case MENU_VALUE_LOOK:
    case MENU_VALUE_CHARACTER:
    case MENU_VALUE_OTHER:
    case MENU_VALUE_FLOOR:
    case MENU_VALUE_CENTER_MAP:
      allowed = true;
      break;
    default:
      bell();
      allowed = false;
      break;
  }
  if (!allowed) return 1;
  switch (selected) {
    case CMD_USE:
      cmdkey = cmd_lookup_key(selected, mode);
      Term_keypress(cmdkey, 0);
      break;
    case CMD_GO_UP:
    case CMD_GO_DOWN:
    case CMD_PICKUP:
      cmdq_push(selected);
      break;
    case MENU_VALUE_REST:
      Term_keypress('R', 0);
      break;
    case MENU_VALUE_INVENTORY:
      Term_keypress('i', 0);
      break;
    case MENU_VALUE_LOOK:
      if (target_set_interactive(TARGET_LOOK, player->grid, 0))
        msg("Target Selected.");
      break;
    case MENU_VALUE_CHARACTER:
      Term_keypress('C', 0);
      break;
    case MENU_VALUE_OTHER:
      context_menu_player_2(mx, my);
      break;
    case MENU_VALUE_FLOOR:
      context_menu_player_display_floor();
      break;
    case MENU_VALUE_CENTER_MAP:
      do_cmd_center_map();
      break;
    default:
      break;
  }
  return 1;
}
STATIC_OVL int
context_menu_cave(struct chunk* c, int y, int x, int adjacent, int mx, int my)
{
  struct menu* m;
  int selected;
  char* labels;
  bool allowed = true;
  int mode =
      OPT(player, angband_keyset) ? KEYMAP_MODE_ANGBAND : KEYMAP_MODE_ORIG;
  unsigned char cmdkey;
  struct loc grid = loc(x, y);
  struct object* square_obj = square_object(c, grid);
  if (OPT(player, hjkl_movement)) {
    mode |= KEYMAP_MODE_ROGUE;
  }
  m = menu_dynamic_new();
  if (!m) return 0;
  labels = string_make(lower_case);
  m->selections = labels;
  menu_dynamic_add_label(m, "Look At", 'l', MENU_VALUE_LOOK, labels);
  {
    cmdkey = cmd_lookup_key_unktrl((CMD_USE), mode);
    menu_dynamic_add_label_valid(m, ("Use Item On"), cmdkey, (CMD_USE), labels,
                                 (MN_ROW_VALID));
  };
  if (adjacent) {
    struct object* obj = chest_check(player, grid, CHEST_ANY);
    {
      cmdkey = cmd_lookup_key_unktrl((CMD_ALTER), mode);
      menu_dynamic_add_label_valid(
          m, ((square(c, grid)->mon) ? "Attack" : "Alter"), cmdkey, (CMD_ALTER),
          labels, (MN_ROW_VALID));
    };
    if (obj && !ignore_item_ok(player, obj)) {
      if (obj->known->pval) {
        if (is_locked_chest(obj)) {
          {
            cmdkey = cmd_lookup_key_unktrl((CMD_DISARM), mode);
            menu_dynamic_add_label_valid(m, ("Disarm Chest"), cmdkey,
                                         (CMD_DISARM), labels, (MN_ROW_VALID));
          };
          {
            cmdkey = cmd_lookup_key_unktrl((CMD_OPEN), mode);
            menu_dynamic_add_label_valid(m, ("Open Chest"), cmdkey, (CMD_OPEN),
                                         labels, (MN_ROW_VALID));
          };
        } else {
          {
            cmdkey = cmd_lookup_key_unktrl((CMD_OPEN), mode);
            menu_dynamic_add_label_valid(m, ("Open Disarmed Chest"), cmdkey,
                                         (CMD_OPEN), labels, (MN_ROW_VALID));
          };
        }
      } else {
        {
          cmdkey = cmd_lookup_key_unktrl((CMD_OPEN), mode);
          menu_dynamic_add_label_valid(m, ("Open Chest"), cmdkey, (CMD_OPEN),
                                       labels, (MN_ROW_VALID));
        };
      }
    }
    if (square_isdisarmabletrap(c, grid)) {
      {
        cmdkey = cmd_lookup_key_unktrl((CMD_DISARM), mode);
        menu_dynamic_add_label_valid(m, ("Disarm"), cmdkey, (CMD_DISARM),
                                     labels, (MN_ROW_VALID));
      };
      {
        cmdkey = cmd_lookup_key_unktrl((CMD_JUMP), mode);
        menu_dynamic_add_label_valid(m, ("Jump Onto"), cmdkey, (CMD_JUMP),
                                     labels, (MN_ROW_VALID));
      };
    } else if (square_iswarded(c, grid)) {
      {
        cmdkey = cmd_lookup_key_unktrl((CMD_DISARM), mode);
        menu_dynamic_add_label_valid(m, ("Disarm"), cmdkey, (CMD_DISARM),
                                     labels, (MN_ROW_VALID));
      };
    }
    if (square_isopendoor(c, grid)) {
      {
        cmdkey = cmd_lookup_key_unktrl((CMD_CLOSE), mode);
        menu_dynamic_add_label_valid(m, ("Close"), cmdkey, (CMD_CLOSE), labels,
                                     (MN_ROW_VALID));
      };
    } else if (square_iscloseddoor(c, grid) && !square_issecretdoor(c, grid)) {
      {
        cmdkey = cmd_lookup_key_unktrl((CMD_OPEN), mode);
        menu_dynamic_add_label_valid(m, ("Open"), cmdkey, (CMD_OPEN), labels,
                                     (MN_ROW_VALID));
      };
      {
        cmdkey = cmd_lookup_key_unktrl((CMD_BASH), mode);
        menu_dynamic_add_label_valid(m, ("Bash"), cmdkey, (CMD_BASH), labels,
                                     (MN_ROW_VALID));
      };
    } else if (square_isdiggable(c, grid)) {
      {
        cmdkey = cmd_lookup_key_unktrl((CMD_TUNNEL), mode);
        menu_dynamic_add_label_valid(m, ("Tunnel"), cmdkey, (CMD_TUNNEL),
                                     labels, (MN_ROW_VALID));
      };
    }
    {
      cmdkey = cmd_lookup_key_unktrl((CMD_WALK), mode);
      menu_dynamic_add_label_valid(m, ("Walk Towards"), cmdkey, (CMD_WALK),
                                   labels, (MN_ROW_VALID));
    };
  } else {
    cmdkey = (mode == KEYMAP_MODE_ORIG) ? ',' : '.';
    menu_dynamic_add_label(m, "Pathfind To", cmdkey, CMD_PATHFIND, labels);
    {
      cmdkey = cmd_lookup_key_unktrl((CMD_WALK), mode);
      menu_dynamic_add_label_valid(m, ("Walk Towards"), cmdkey, (CMD_WALK),
                                   labels, (MN_ROW_VALID));
    };
    {
      cmdkey = cmd_lookup_key_unktrl((CMD_RUN), mode);
      menu_dynamic_add_label_valid(m, ("Run Towards"), cmdkey, (CMD_RUN),
                                   labels, (MN_ROW_VALID));
    };
  }
  if (player_can_fire(player, false)) {
    {
      cmdkey = cmd_lookup_key_unktrl((CMD_FIRE), mode);
      menu_dynamic_add_label_valid(m, ("Fire On"), cmdkey, (CMD_FIRE), labels,
                                   (MN_ROW_VALID));
    };
  }
  {
    cmdkey = cmd_lookup_key_unktrl((CMD_THROW), mode);
    menu_dynamic_add_label_valid(m, ("Throw To"), cmdkey, (CMD_THROW), labels,
                                 (MN_ROW_VALID));
  };
  msg_flag = false;
  screen_save();
  menu_dynamic_calc_location(m, mx, my);
  region_erase_bordered(&m->boundary);
  if (player->timed[TMD_IMAGE]) {
    prt("(Enter to select command, ESC to cancel) You see something strange:",
        0, 0);
  } else if (square(c, grid)->mon) {
    char m_name[80];
    struct monster* mon = square_monster(c, grid);
    monster_desc(m_name, sizeof(m_name), mon, MDESC_IND_VIS);
    prt(format("(Enter to select command, ESC to cancel) You see %s:", m_name),
        0, 0);
  } else if (square_obj && !ignore_item_ok(player, square_obj)) {
    char o_name[80];
    object_desc(o_name, sizeof(o_name), square_obj, ODESC_PREFIX | ODESC_FULL,
                player);
    prt(format("(Enter to select command, ESC to cancel) You see %s:", o_name),
        0, 0);
  } else {
    char name[50];
    const char* prefix = square_apparent_look_prefix(player->cave, grid);
    square_apparent_name(player->cave, grid, name, sizeof(name));
    prt(format("(Enter to select command, ESC to cancel) You see %s%s:", prefix,
               name),
        0, 0);
  }
  selected = menu_dynamic_select(m);
  menu_dynamic_free(m);
  string_free(labels);
  screen_load();
  cmdkey = cmd_lookup_key(selected, mode);
  switch (selected) {
    case -1:
      return 3;
    case MENU_VALUE_LOOK:
    case MENU_VALUE_RECALL:
    case CMD_PATHFIND:
      allowed = true;
      break;
    case CMD_ALTER:
    case CMD_BASH:
    case CMD_DISARM:
    case CMD_JUMP:
    case CMD_CLOSE:
    case CMD_OPEN:
    case CMD_TUNNEL:
    case CMD_WALK:
    case CMD_RUN:
    case CMD_FIRE:
    case CMD_THROW:
    case CMD_USE:
      allowed = key_confirm_command(cmdkey);
      break;
    default:
      bell();
      allowed = false;
      break;
  }
  if (!allowed) return 1;
  switch (selected) {
    case MENU_VALUE_LOOK:
      if (target_set_interactive(TARGET_LOOK, grid, 0)) {
        msg("Target Selected.");
      }
      break;
    case MENU_VALUE_RECALL: {
      struct monster* mon = square_monster(c, grid);
      if (mon) {
        struct monster_lore* lore = get_lore(mon->race);
        lore_show_interactive(mon->race, lore);
      }
    } break;
    case CMD_PATHFIND:
      cmdq_push(selected);
      cmd_set_arg_point(cmdq_peek(), "point", loc(x, y));
      break;
    case CMD_ALTER:
    case CMD_BASH:
    case CMD_DISARM:
    case CMD_JUMP:
    case CMD_CLOSE:
    case CMD_OPEN:
    case CMD_TUNNEL:
    case CMD_WALK:
    case CMD_RUN:
      cmdq_push(selected);
      cmd_set_arg_direction(cmdq_peek(), "direction",
                            motion_dir(player->grid, loc(x, y)));
      break;
    case CMD_FIRE:
    case CMD_THROW:
    case CMD_USE:
      cmdq_push(selected);
      cmd_set_arg_target(cmdq_peek(), "target", DIR_TARGET);
      break;
    default:
      break;
  }
  return 1;
}
STATIC_OVL int
context_menu_object(struct object* obj)
{
  struct menu* m;
  region r;
  int selected;
  char* labels;
  char header[120];
  textblock* tb;
  region area = {0, 0, 0, 0};
  bool allowed = true;
  int mode =
      OPT(player, angband_keyset) ? KEYMAP_MODE_ANGBAND : KEYMAP_MODE_ORIG;
  unsigned char cmdkey;
  if (OPT(player, hjkl_movement)) {
    mode |= KEYMAP_MODE_ROGUE;
  }
  m = menu_dynamic_new();
  if (!m || !obj) return 0;
  object_desc(header, sizeof(header), obj, ODESC_PREFIX | ODESC_BASE, player);
  labels = string_make(lower_case);
  m->selections = labels;
  menu_dynamic_add_label(m, "Inspect", 'I', MENU_VALUE_INSPECT, labels);
  if (obj_is_useable(obj)) {
    if (tval_is_horn(obj)) {
      menu_row_validity_t valid = (player->csp) ? MN_ROW_VALID : MN_ROW_INVALID;
      {
        cmdkey = cmd_lookup_key_unktrl((CMD_BLOW_HORN), mode);
        menu_dynamic_add_label_valid(m, ("Blow"), cmdkey, (CMD_BLOW_HORN),
                                     labels, (valid));
      };
    } else if (tval_is_staff(obj)) {
      menu_row_validity_t valid =
          (obj_has_charges(obj)) ? MN_ROW_VALID : MN_ROW_INVALID;
      {
        cmdkey = cmd_lookup_key_unktrl((CMD_USE_STAFF), mode);
        menu_dynamic_add_label_valid(m, ("Use"), cmdkey, (CMD_USE_STAFF),
                                     labels, (valid));
      };
    } else if (tval_is_potion(obj)) {
      {
        cmdkey = cmd_lookup_key_unktrl((CMD_QUAFF), mode);
        menu_dynamic_add_label_valid(m, ("Quaff"), cmdkey, (CMD_QUAFF), labels,
                                     (MN_ROW_VALID));
      };
    } else if (tval_is_edible(obj)) {
      {
        cmdkey = cmd_lookup_key_unktrl((CMD_EAT), mode);
        menu_dynamic_add_label_valid(m, ("Eat"), cmdkey, (CMD_EAT), labels,
                                     (MN_ROW_VALID));
      };
    } else if (obj_can_fire(obj) && object_is_in_quiver(player, obj)) {
      {
        cmdkey = cmd_lookup_key_unktrl((CMD_FIRE), mode);
        menu_dynamic_add_label_valid(m, ("Fire"), cmdkey, (CMD_FIRE), labels,
                                     (MN_ROW_VALID));
      };
    } else {
      {
        cmdkey = cmd_lookup_key_unktrl((CMD_USE), mode);
        menu_dynamic_add_label_valid(m, ("Use"), cmdkey, (CMD_USE), labels,
                                     (MN_ROW_VALID));
      };
    }
  }
  if (obj_can_refuel(obj)) {
    cmdkey = cmd_lookup_key_unktrl((CMD_REFUEL), mode);
    menu_dynamic_add_label_valid(m, ("Refuel"), cmdkey, (CMD_REFUEL), labels,
                                 (MN_ROW_VALID));
  };
  if (object_is_equipped(player->body, obj) && obj_can_takeoff(obj)) {
    {
      cmdkey = cmd_lookup_key_unktrl((CMD_TAKEOFF), mode);
      menu_dynamic_add_label_valid(m, ("Take off"), cmdkey, (CMD_TAKEOFF),
                                   labels, (MN_ROW_VALID));
    };
  } else if (!object_is_equipped(player->body, obj) && obj_can_wear(obj)) {
    {
      cmdkey = cmd_lookup_key_unktrl((CMD_WIELD), mode);
      menu_dynamic_add_label_valid(m, ("Equip"), cmdkey, (CMD_WIELD), labels,
                                   (MN_ROW_VALID));
    };
  }
  if (object_is_carried(player, obj)) {
    {
      cmdkey = cmd_lookup_key_unktrl((CMD_DROP), mode);
      menu_dynamic_add_label_valid(m, ("Drop"), cmdkey, (CMD_DROP), labels,
                                   (MN_ROW_VALID));
    };
  } else {
    menu_row_validity_t valid =
        (inven_carry_okay(obj)) ? MN_ROW_VALID : MN_ROW_INVALID;
    {
      cmdkey = cmd_lookup_key_unktrl((CMD_PICKUP), mode);
      menu_dynamic_add_label_valid(m, ("Pick up"), cmdkey, (CMD_PICKUP), labels,
                                   (valid));
    };
  }
  if (obj_can_throw(obj)) {
    {
      cmdkey = cmd_lookup_key_unktrl((CMD_THROW), mode);
      menu_dynamic_add_label_valid(m, ("Throw"), cmdkey, (CMD_THROW), labels,
                                   (MN_ROW_VALID));
    };
  }
  {
    cmdkey = cmd_lookup_key_unktrl((CMD_INSCRIBE), mode);
    menu_dynamic_add_label_valid(m, ("Inscribe"), cmdkey, (CMD_INSCRIBE),
                                 labels, (MN_ROW_VALID));
  };
  if (obj_has_inscrip(obj)) {
    cmdkey = cmd_lookup_key_unktrl((CMD_UNINSCRIBE), mode);
    menu_dynamic_add_label_valid(m, ("Uninscribe"), cmdkey, (CMD_UNINSCRIBE),
                                 labels, (MN_ROW_VALID));
  };
  {
    cmdkey = cmd_lookup_key_unktrl((CMD_IGNORE), mode);
    menu_dynamic_add_label_valid(
        m, ((object_is_ignored(obj) ? "Unignore" : "Ignore")), cmdkey,
        (CMD_IGNORE), labels, (MN_ROW_VALID));
  };
  r.width = (int)menu_dynamic_longest_entry(m) + 3 + 2;
  r.col = Term->wid - r.width - 1;
  r.row = 1;
  r.page_rows = m->count;
  area.width = -(r.width + 2);
  msg_flag = false;
  screen_save();
  tb = object_info(obj, OINFO_NONE);
  object_desc(header, sizeof(header), obj, ODESC_PREFIX | ODESC_FULL, player);
  textui_textblock_place(tb, area, format("%s", header));
  textblock_free(tb);
  menu_layout(m, &r);
  region_erase_bordered(&r);
  prt(format("(Enter to select, ESC) Command for %s:", header), 0, 0);
  selected = menu_dynamic_select(m);
  menu_dynamic_free(m);
  string_free(labels);
  screen_load();
  cmdkey = cmd_lookup_key(selected, mode);
  switch (selected) {
    case -1:
      return 3;
    case MENU_VALUE_INSPECT:
      tb = object_info(obj, OINFO_NONE);
      object_desc(header, sizeof(header), obj, ODESC_PREFIX | ODESC_FULL,
                  player);
      textui_textblock_show(tb, area, format("%s", header));
      textblock_free(tb);
      return 2;
    case CMD_IGNORE:
    case CMD_WIELD:
    case CMD_TAKEOFF:
    case CMD_INSCRIBE:
    case CMD_UNINSCRIBE:
    case CMD_PICKUP:
    case CMD_DROP:
    case CMD_REFUEL:
    case CMD_THROW:
    case CMD_BLOW_HORN:
    case CMD_USE_STAFF:
    case CMD_QUAFF:
    case CMD_EAT:
    case CMD_FIRE:
    case CMD_USE:
      allowed = key_confirm_command(cmdkey) &&
                get_item_allow(obj, cmdkey, selected, false);
      break;
    default:
      bell();
      allowed = false;
      break;
  }
  if (!allowed) return 1;
  if (selected == CMD_IGNORE) {
    textui_cmd_ignore_menu(obj);
  } else {
    cmdq_push(selected);
    cmd_set_arg_item(cmdq_peek(), "item", obj);
  }
  return 1;
}
STATIC_OVL int
show_command_list(struct cmd_info cmd_list[], int size, int mx, int my)
{
  struct menu* m;
  int selected;
  int i;
  char cmd_name[80];
  char key[3];
  int mode =
      OPT(player, angband_keyset) ? KEYMAP_MODE_ANGBAND : KEYMAP_MODE_ORIG;
  if (OPT(player, hjkl_movement)) {
    mode |= KEYMAP_MODE_ROGUE;
  }
  m = menu_dynamic_new();
  if (!m) {
    return 0;
  }
  m->selections = lower_case;
  key[2] = '\0';
  for (i = 0; i < size; ++i) {
    if (KTRL(cmd_list[i].key[mode]) == cmd_list[i].key[mode]) {
      key[0] = '^';
      key[1] = UN_KTRL(cmd_list[i].key[mode]);
    } else {
      key[0] = cmd_list[i].key[mode];
      key[1] = '\0';
    }
    strnfmt(cmd_name, 80, "%s (%s)", cmd_list[i].desc, key);
    menu_dynamic_add(m, cmd_name, i + 1);
  }
  menu_dynamic_calc_location(m, mx, my);
  screen_save();
  region_erase_bordered(&m->boundary);
  prt("(Enter to select, ESC) Command:", 0, 0);
  selected = menu_dynamic_select(m);
  menu_dynamic_free(m);
  screen_load();
  if ((selected > 0) && (selected < size + 1)) {
    Term_keypress(cmd_list[selected - 1].key[mode], 0);
  }
  return 1;
}
STATIC_OVL int
context_menu_command(int mx, int my)
{
  struct menu* m;
  int selected;
  m = menu_dynamic_new();
  if (!m) {
    return 0;
  }
  m->selections = lower_case;
  menu_dynamic_add(m, "Item", 1);
  menu_dynamic_add(m, "Action", 2);
  menu_dynamic_add(m, "Item Management", 3);
  menu_dynamic_add(m, "Info", 4);
  menu_dynamic_add(m, "Util", 5);
  menu_dynamic_add(m, "Misc", 6);
  menu_dynamic_calc_location(m, mx, my);
  screen_save();
  region_erase_bordered(&m->boundary);
  prt("(Enter to select, ESC) Command:", 0, 0);
  selected = menu_dynamic_select(m);
  menu_dynamic_free(m);
  screen_load();
  if (selected > 0) {
    selected--;
    show_command_list(cmds_all[selected].list, cmds_all[selected].len, mx, my);
  } else {
    return 0;
  }
  return 1;
}
STATIC_OVL void
textui_process_click(ui_event e)
{
  int x, y;
  if (!OPT(player, mouse_movement)) return;
  y = KEY_GRID_Y(e);
  x = KEY_GRID_X(e);
  if (!square_in_bounds_fully(cave, loc(x, y))) return;
  if (loc_eq(player->grid, loc(x, y))) {
    if (e.mouse.mods & KC_MOD_SHIFT) {
      if (e.mouse.button == 2) {
        Term_keypress('i', 0);
      }
    } else if (e.mouse.mods & KC_MOD_CONTROL) {
      if (e.mouse.button == 1) {
        if (square_isupstairs(cave, player->grid))
          cmdq_push(CMD_GO_UP);
        else if (square_isdownstairs(cave, player->grid))
          cmdq_push(CMD_GO_DOWN);
      } else if (e.mouse.button == 2) {
        cmdq_push(CMD_USE);
      }
    } else if (e.mouse.mods & KC_MOD_ALT) {
      if (e.mouse.button == 1) {
        Term_keypress('C', 0);
      }
    } else {
      if (e.mouse.button == 1) {
        if (square_object(cave, loc(x, y))) {
          cmdq_push(CMD_PICKUP);
        } else {
          cmdq_push(CMD_HOLD);
        }
      } else if (e.mouse.button == 2) {
        context_menu_player(e.mouse.x, e.mouse.y);
      }
    }
  } else if (e.mouse.button == 1) {
    if (player->timed[TMD_CONFUSED]) {
      cmdq_push(CMD_WALK);
    } else {
      if (e.mouse.mods & KC_MOD_SHIFT) {
        cmdq_push(CMD_RUN);
        cmd_set_arg_direction(cmdq_peek(), "direction",
                              motion_dir(player->grid, loc(x, y)));
      } else if (e.mouse.mods & KC_MOD_CONTROL) {
        cmdq_push(CMD_ALTER);
        cmd_set_arg_direction(cmdq_peek(), "direction",
                              motion_dir(player->grid, loc(x, y)));
      } else if (e.mouse.mods & KC_MOD_ALT) {
        if (target_set_interactive(TARGET_LOOK, loc(x, y), 0)) {
          msg("Target Selected.");
        }
      } else {
        if ((y - player->grid.y >= -1) && (y - player->grid.y <= 1) &&
            (x - player->grid.x >= -1) && (x - player->grid.x <= 1)) {
          cmdq_push(CMD_WALK);
          cmd_set_arg_direction(cmdq_peek(), "direction",
                                motion_dir(player->grid, loc(x, y)));
        } else {
          cmdq_push(CMD_PATHFIND);
          cmd_set_arg_point(cmdq_peek(), "point", loc(x, y));
        }
      }
    }
  } else if (e.mouse.button == 2) {
    struct monster* m = square_monster(cave, loc(x, y));
    if (m && target_able(m)) {
      monster_race_track(player->upkeep, m->race);
      health_track(player->upkeep, m);
      target_set_monster(m);
    } else {
      target_set_location(loc(x, y));
    }
    if (e.mouse.mods & KC_MOD_CONTROL) {
      cmdq_push(CMD_USE);
      cmd_set_arg_target(cmdq_peek(), "target", DIR_TARGET);
    } else if (e.mouse.mods & KC_MOD_ALT) {
      cmdq_push(CMD_THROW);
      cmd_set_arg_target(cmdq_peek(), "target", DIR_TARGET);
    } else {
      if ((y - player->grid.y >= -1) && (y - player->grid.y <= 1) &&
          (x - player->grid.x >= -1) && (x - player->grid.x <= 1)) {
        context_menu_cave(cave, y, x, 1, e.mouse.x, e.mouse.y);
      } else {
        context_menu_cave(cave, y, x, 0, e.mouse.x, e.mouse.y);
      }
    }
  }
}
STATIC_OVL void
cmd_sub_entry(struct menu* menu, int oid, bool cursor, int row, int col,
              int width)
{
  uint8_t attr = (cursor ? COLOUR_L_BLUE : COLOUR_WHITE);
  const struct cmd_info* commands = menu_priv(menu);
  int mode =
      OPT(player, angband_keyset) ? KEYMAP_MODE_ANGBAND : KEYMAP_MODE_ORIG;
  struct keypress kp = {EVT_KBRD, commands[oid].key[mode], 0};
  char buf[16];
  if (OPT(player, hjkl_movement)) {
    mode |= KEYMAP_MODE_ROGUE;
  }
  Term_putstr(col, row, -1, attr, commands[oid].desc);
  if (kp.code) {
    Term_addch(attr, L' ');
    Term_addch(attr, L'(');
    keypress_to_readable(buf, sizeof buf, kp);
    Term_addstr(-1, attr, buf);
    Term_addch(attr, L')');
  }
}
STATIC_OVL bool
cmd_menu(struct command_list* list, void* selection_p)
{
  struct menu menu;
  menu_iter commands_menu = {NULL, NULL, cmd_sub_entry, NULL, NULL};
  region area = {23, 4, 37, 13};
  ui_event evt;
  struct cmd_info** selection = selection_p;
  bool result = false;
  menu_init(&menu, MN_SKIN_SCROLL, &commands_menu);
  menu_setpriv(&menu, list->len, list->list);
  area.col += 2 * list->menu_level;
  area.row -= list->menu_level;
  assert(area.row > 1);
  menu_layout(&menu, &area);
  screen_save();
  window_make(area.col - 2, area.row - 1, area.col + 39, area.row + 13);
  while (1) {
    evt = menu_select(&menu, 0, true);
    if (evt.type == EVT_SELECT) {
      if (list->list[menu.cursor].cmd || list->list[menu.cursor].hook) {
        *selection = &list->list[menu.cursor];
        break;
      } else {
        if (list->list[menu.cursor].nested_cached_idx == -1) {
          list->list[menu.cursor].nested_cached_idx =
              cmd_list_lookup_by_name(list->list[menu.cursor].nested_name);
        }
        if (list->list[menu.cursor].nested_cached_idx >= 0) {
          if (!cmd_menu(&cmds_all[list->list[menu.cursor].nested_cached_idx],
                        selection_p)) {
            break;
          }
        } else {
          break;
        }
      }
    } else if (evt.type == EVT_ESCAPE) {
      result = true;
      break;
    }
  }
  if (result && screen_save_depth > 1 && (tile_width > 1 || tile_height > 1)) {
    screen_load_all();
  } else {
    screen_load();
  }
  return result;
}
STATIC_OVL bool
cmd_list_action(struct menu* m, const ui_event* event, int oid)
{
  if (event->type == EVT_SELECT)
    return cmd_menu(&cmds_all[oid], menu_priv(m));
  else
    return false;
}
STATIC_OVL void
cmd_list_entry(struct menu* menu, int oid, bool cursor, int row, int col,
               int width)
{
  uint8_t attr = (cursor ? COLOUR_L_BLUE : COLOUR_WHITE);
  Term_putstr(col, row, -1, attr, cmds_all[oid].name);
}
STATIC_OVL struct cmd_info*
textui_action_menu_choose(void)
{
  region area = {21, 5, 37, 6};
  int len = 0;
  struct cmd_info* chosen_command = NULL;
  if (!command_menu)
    command_menu = menu_new(MN_SKIN_SCROLL, &command_menu_iter);
  while (cmds_all[len].len && cmds_all[len].menu_level == 0) {
    len++;
  };
  menu_setpriv(command_menu, len, &chosen_command);
  menu_layout(command_menu, &area);
  screen_save();
  window_make(19, 4, 58, 11);
  menu_select(command_menu, 0, true);
  screen_load();
  return chosen_command;
}
STATIC_OVL void
display_exit_screen(struct high_score* score)
{
  if (player->escaped) {
    Term_putstr(15, 2, -1, COLOUR_L_BLUE, "You have escaped");
  } else if (streq(player->died_from, "Retiring")) {
    Term_putstr(15, 2, -1, COLOUR_L_BLUE, "You have retired");
  } else {
    Term_putstr(15, 2, -1, COLOUR_L_BLUE, "You have been slain");
  }
  display_single_score(score, 1, 0, COLOUR_WHITE);
  Term_putstr(3, 10, -1, COLOUR_L_DARK,
              "____________________________________________________");
  prt_mini_screenshot(5, 14);
}
STATIC_OVL void
death_scores(const char* title, int row)
{
  screen_save();
  show_scores();
  screen_load();
}
STATIC_OVL void
death_examine(const char* title, int row)
{
  struct object* obj;
  const char *q, *s;
  q = "Examine which item? ";
  s = "You have nothing to examine.";
  while (get_item(&obj, q, s, 0, NULL,
                  (USE_INVEN | USE_QUIVER | USE_EQUIP | IS_HARMLESS))) {
    char header[120];
    textblock* tb;
    region area = {0, 0, 0, 0};
    tb = object_info(obj, OINFO_NONE);
    object_desc(header, sizeof(header), obj,
                ODESC_PREFIX | ODESC_FULL | ODESC_CAPITAL, player);
    textui_textblock_show(tb, area, header);
    textblock_free(tb);
  }
}
STATIC_OVL void
death_dungeon(const char* title, int row)
{
  int i;
  struct object* obj;
  screen_save();
  for (i = 1; i < cave->obj_max; i++) {
    obj = cave->objects[i];
    if (!obj || !obj->kind) continue;
    object_flavor_aware(player, obj);
    object_see(player, obj);
    object_touch(player, obj);
    player_know_object(player, obj);
  }
  Term_clear();
  wiz_light(cave, player);
  effect_simple(EF_DETECT_MONSTERS, source_player(), "0", 0, 0, 0, NULL);
  player->upkeep->redraw |= 0x0FFFFFFFL;
  handle_stuff(player);
  prt_map();
  do_cmd_look();
  screen_load();
}
STATIC_OVL void
death_messages(const char* title, int row)
{
  screen_save();
  do_cmd_messages();
  screen_load();
}
STATIC_OVL void
death_info(const char* title, int row)
{
  screen_save();
  display_player(0);
  prt("Hit any key to see more information: ", 0, 0);
  (void)anykey();
  if (player->upkeep->equip_cnt) {
    Term_clear();
    show_equip(OLIST_WEIGHT | OLIST_SEMPTY | OLIST_DEATH, NULL);
    prt("You are using: -more-", 0, 0);
    (void)anykey();
  }
  if (player->upkeep->inven_cnt) {
    Term_clear();
    show_inven(OLIST_WEIGHT | OLIST_DEATH, NULL);
    prt("You are carrying: -more-", 0, 0);
    (void)anykey();
  }
  screen_load();
}
STATIC_OVL void
death_history(const char* title, int row)
{
  history_display();
}
STATIC_OVL void
death_note(const char* title, int row)
{
  do_cmd_note();
}
STATIC_OVL void
death_file(const char* title, int row)
{
  char buf[1024];
  char ftmp[80];
  player_safe_name(ftmp, sizeof(ftmp), player->full_name, false);
  my_strcat(ftmp, ".txt", sizeof(ftmp));
  if (get_file(ftmp, buf, sizeof buf)) {
    bool success;
    screen_save();
    success = dump_save(buf);
    screen_load();
    if (success)
      msg("Character dump successful.");
    else
      msg("Character dump failed!");
    event_signal(EVENT_MESSAGE_FLUSH);
  }
}
STATIC_OVL void
death_spoilers(const char* title, int row)
{
  do_cmd_spoilers();
}
STATIC_OVL void
death_new_game(const char* title, int row)
{
  play_again = get_check("Start a new game? ");
}
STATIC_OVL void
death_screen(void)
{
  struct menu* death_menu;
  bool done = false;
  const region area = {15, 12, 0, N_ELEMENTS(death_actions)};
  time_t death_time = (time_t)0;
  struct high_score score;
  (void)time(&death_time);
  build_score(&score, player, player->died_from, &death_time);
  clear_from(0);
  display_exit_screen(&score);
  event_signal(EVENT_INPUT_FLUSH);
  event_signal(EVENT_MESSAGE_FLUSH);
  death_menu = menu_new_action(death_actions, N_ELEMENTS(death_actions));
  death_menu->flags = MN_CASELESS_TAGS;
  menu_layout(death_menu, &area);
  while (!done && !play_again) {
    ui_event e = menu_select(death_menu, EVT_KBRD, false);
    if (e.type == EVT_KBRD) {
      if (e.key.code == KTRL('X')) break;
      if (e.key.code == KTRL('N')) play_again = true;
    } else if (e.type == EVT_SELECT) {
      done = true;
    }
  }
  menu_free(death_menu);
}
STATIC_OVL int
prt_one_tmd(int row, int col, int ind)
{
  int printed = 0;
  if (timed_effects[ind].grade) {
    const struct timed_grade* grade = timed_effects[ind].grade;
    while (player->timed[ind] > grade->max) {
      grade = grade->next;
      assert(grade);
    }
    if (grade->name) {
      c_put_str(grade->color, grade->name, row, col);
      printed = (int)strlen(grade->name);
    }
  } else if (timed_effects[ind].c_grade) {
    const struct timed_change_grade* cg = timed_effects[ind].c_grade;
    while (player->timed[ind] > cg->max) {
      cg = cg->next;
      assert(cg);
    }
    if (cg->name) {
      if (cg->digits > 0) {
        char* meter =
            format("%s %-*d", cg->name, cg->digits, player->timed[ind]);
        c_put_str(cg->color, meter, row, col);
        printed = (int)strlen(meter);
      } else {
        c_put_str(cg->color, cg->name, row, col);
        printed = (int)strlen(cg->name);
      }
    }
  }
  return printed;
}
STATIC_OVL void
prt_field(const char* info, int row, int col)
{
  c_put_str(COLOUR_WHITE, "             ", row, col);
  c_put_str(COLOUR_L_BLUE, info, row, col);
}
STATIC_OVL void
prt_name(int row, int col)
{
  if (strlen(player->full_name) <= 12) {
    prt_field(player->full_name, row, col);
  }
}
STATIC_OVL void
prt_stat(int stat, int row, int col)
{
  char tmp[32];
  if (player->stat_drain[stat] < 0) {
    put_str(stat_names_reduced[stat], row, col);
    strnfmt(tmp, sizeof(tmp), "    %2d", player->state.stat_use[stat]);
    c_put_str(COLOUR_YELLOW, tmp, row, col + 6);
  } else {
    put_str(stat_names[stat], row, col);
    strnfmt(tmp, sizeof(tmp), "    %2d", player->state.stat_use[stat]);
    c_put_str(COLOUR_L_GREEN, tmp, row, col + 6);
  }
  if ((stat == STAT_STR) && player->timed[TMD_STR]) put_str("*", row, col + 3);
  if ((stat == STAT_DEX) && player->timed[TMD_DEX]) put_str("*", row, col + 3);
  if ((stat == STAT_CON) && player->timed[TMD_CON]) put_str("*", row, col + 3);
  if ((stat == STAT_GRA) && player->timed[TMD_GRA]) put_str("*", row, col + 3);
}
STATIC_OVL void
prt_exp(int row, int col)
{
  char out_val[32];
  strnfmt(out_val, sizeof(out_val), "%8d", player->new_exp);
  put_str("Exp ", row, col);
  c_put_str(COLOUR_L_GREEN, out_val, row, col + 4);
}
STATIC_OVL void
prt_equippy(int row, int col)
{
  int i;
  uint8_t a;
  wchar_t c;
  struct object* obj;
  for (i = 0; i < player->body.count; i++) {
    obj = slot_object(player, i);
    if (obj && tile_width == 1 && tile_height == 1) {
      c = object_char(obj);
      a = object_attr(obj);
    } else {
      c = L' ';
      a = COLOUR_WHITE;
    }
    Term_putch(col + i, row, a, c);
  }
}
STATIC_OVL void
prt_mel(int row, int col)
{
  char buf[32];
  struct object* off = equipped_item_by_slot_name(player, "arm");
  int mod = off && tval_is_weapon(off) ? -1 : 0;
  strnfmt(buf, sizeof(buf), "(%+d,%dd%d)", player->state.skill_use[SKILL_MELEE],
          player->state.mdd, player->state.mds);
  put_str(format("%12s", buf), row + mod, col);
  if (player_active_ability(player, "Rapid Attack")) {
    put_str("2x", row + mod, col);
  }
  if (!mod) {
    put_str("            ", row - 1, col);
  } else {
    strnfmt(
        buf, sizeof(buf), "(%+d,%dd%d)",
        player->state.skill_use[SKILL_MELEE] + player->state.offhand_mel_mod,
        player->state.mdd2, player->state.mds2);
    put_str(format("%12s", buf), row, col);
  }
}
STATIC_OVL void
prt_arc(int row, int col)
{
  char buf[32];
  if (equipped_item_by_slot_name(player, "shooting")) {
    strnfmt(buf, sizeof(buf), "(%+d,%dd%d)",
            player->state.skill_use[SKILL_ARCHERY], player->state.add,
            player->state.ads);
    c_put_str(COLOUR_UMBER, format("%12s", buf), row, col);
    if (player_active_ability(player, "Rapid Fire")) {
      c_put_str(COLOUR_UMBER, "2x", row, col);
    }
  }
}
STATIC_OVL void
prt_evn(int row, int col)
{
  char buf[32];
  strnfmt(buf, sizeof(buf), "[%+d,%d-%d]",
          player->state.skill_use[SKILL_EVASION],
          protection_roll(player, PROJ_HURT, true, MINIMISE),
          protection_roll(player, PROJ_HURT, true, MAXIMISE));
  c_put_str(COLOUR_SLATE, format("%12s", buf), row, col);
}
STATIC_OVL void
prt_hp(int row, int col)
{
  char cur_hp[32], health[32];
  uint8_t color = player_hp_attr(player);
  int len;
  if (player->mhp >= 100) {
    put_str("Hth        ", row, col);
  } else {
    put_str("Health      ", row, col);
  }
  len = strnfmt(health, sizeof(health), "%d:%d", player->chp, player->mhp);
  c_put_str(COLOUR_L_GREEN, health, row, col + 12 - len);
  if (player->chp >= player->mhp) return;
  strnfmt(cur_hp, sizeof(cur_hp), "%d", player->chp);
  c_put_str(color, cur_hp, row, col + 12 - len);
}
STATIC_OVL void
prt_sp(int row, int col)
{
  char cur_sp[32], voice[32];
  uint8_t color = player_sp_attr(player);
  int len;
  if (player->msp >= 100) {
    put_str("Vce        ", row, col);
  } else {
    put_str("Voice      ", row, col);
  }
  len = strnfmt(voice, sizeof(voice), "%d:%d", player->csp, player->msp);
  c_put_str(COLOUR_L_GREEN, voice, row, col + 12 - len);
  if (player->csp >= player->msp) return;
  strnfmt(cur_sp, sizeof(cur_sp), "%d", player->csp);
  c_put_str(color, cur_sp, row, col + 12 - len);
}
STATIC_OVL void
prt_song(int row, int col)
{
  char buf[80];
  struct song* song1 = player->song[SONG_MAIN];
  struct song* song2 = player->song[SONG_MINOR];
  struct song* slaying = lookup_song("Slaying");
  int slaying_bonus =
      song_bonus(player, player->state.skill_use[SKILL_SONG], slaying);
  put_str("             ", row, col);
  put_str("             ", row + 1, col);
  if (player->song[SONG_MAIN]) {
    c_put_str(COLOUR_L_BLUE, song1->name, row, col);
  }
  if (player->song[SONG_MINOR]) {
    c_put_str(COLOUR_BLUE, song2->name, row + 1, col);
  }
  if (slaying_bonus > 0) {
    strnfmt(buf, sizeof(buf), "+%d", slaying_bonus);
    if (song1 == slaying) {
      c_put_str(COLOUR_L_BLUE, buf, row, col + 8);
    } else if (song2 == slaying) {
      c_put_str(COLOUR_BLUE, buf, row + 1, col + 8);
    }
  }
}
STATIC_OVL uint8_t
health_attr(int current, int max)
{
  uint8_t attr;
  switch (health_level(current, max)) {
    case HEALTH_UNHURT:
      attr = COLOUR_WHITE;
      break;
    case HEALTH_SOMEWHAT_WOUNDED:
      attr = COLOUR_YELLOW;
      break;
    case HEALTH_WOUNDED:
      attr = COLOUR_ORANGE;
      break;
    case HEALTH_BADLY_WOUNDED:
      attr = COLOUR_L_RED;
      break;
    case HEALTH_ALMOST_DEAD:
      attr = COLOUR_RED;
      break;
    default:
      attr = COLOUR_RED;
      break;
  }
  return attr;
}
STATIC_OVL int
prt_health_aux(int row, int col)
{
  struct monster* mon = player->upkeep->health_who;
  char buf[20];
  int len = 0;
  uint8_t attr = COLOUR_L_DARK;
  if (!mon) {
    Term_erase(col, row, 12);
    Term_erase(col, row + 1, 12);
    return 0;
  }
  if (!monster_is_visible(mon) || (player->timed[TMD_IMAGE]) ||
      (mon->hp <= 0)) {
    Term_putstr(col, row, 12, attr, "  --------  ");
    Term_erase(col, row + 1, 12);
    return 12;
  }
  attr = health_attr(mon->hp, mon->maxhp);
  len = (8 * mon->hp + mon->maxhp - 1) / mon->maxhp;
  Term_putstr(col, row, 12, COLOUR_WHITE, "  --------  ");
  if (mon->m_timed[MON_TMD_CONF] && mon->m_timed[MON_TMD_STUN])
    Term_putstr(col + 2, row, len, attr, "cscscscs");
  else if (mon->m_timed[MON_TMD_CONF])
    Term_putstr(col + 2, row, len, attr, "cccccccc");
  else if (mon->m_timed[MON_TMD_STUN])
    Term_putstr(col + 2, row, len, attr, "ssssssss");
  else
    Term_putstr(col + 2, row, len, attr, "********");
  Term_erase(col, row + 1, 12);
  if (mon->alertness < ALERTNESS_UNWARY) {
    my_strcpy(buf, "Sleeping", sizeof(buf));
    attr = COLOUR_BLUE;
    len = strlen(buf);
  } else if (mon->alertness < ALERTNESS_ALERT) {
    my_strcpy(buf, "Unwary", sizeof(buf));
    attr = COLOUR_L_BLUE;
    len = strlen(buf);
  } else {
    if (rf_has(mon->race->flags, RF_MINDLESS)) {
      my_strcpy(buf, "Mindless", sizeof(buf));
      attr = COLOUR_L_DARK;
      len = strlen(buf);
    } else {
      char tmp[20];
      if (mon->stance == STANCE_FLEEING) {
        my_strcpy(tmp, "Fleeing", sizeof(tmp));
        attr = COLOUR_VIOLET;
      } else if (mon->stance == STANCE_CONFIDENT) {
        my_strcpy(tmp, "Confident", sizeof(tmp));
        attr = COLOUR_L_WHITE;
      } else if (mon->stance == STANCE_AGGRESSIVE) {
        my_strcpy(tmp, "Aggress", sizeof(tmp));
        attr = COLOUR_L_WHITE;
      } else {
        return 0;
      }
      if (mon->morale >= 0) {
        len = strnfmt(buf, sizeof(buf), "%s %d", tmp, (mon->morale + 9) / 10);
      } else {
        len = strnfmt(buf, sizeof(buf), "%s %d", tmp, mon->morale / 10);
      }
    }
  }
  Term_putstr(col, row + 1, 12, COLOUR_DARK, "            ");
  Term_putstr(col + (13 - len) / 2, row + 1, MIN(len, 12), attr, buf);
  return 12;
}
STATIC_OVL void
prt_health(int row, int col)
{
  prt_health_aux(row, col);
}
STATIC_OVL void
prt_cut(int row, int col)
{
  int r = row;
  if (player->timed[TMD_POISONED]) r--;
  put_str(format("%*s", col_map[SIDEBAR_LEFT] - col, " "), r, col);
  prt_one_tmd(r, col, TMD_CUT);
}
STATIC_OVL void
prt_poisoned(int row, int col)
{
  put_str(format("%*s", col_map[SIDEBAR_LEFT] - col, " "), row, col);
  prt_one_tmd(row, col, TMD_POISONED);
}
STATIC_OVL void
prt_speed(int row, int col)
{
  int i = player->state.speed;
  const char* type = NULL;
  uint8_t attr = COLOUR_WHITE;
  char buf[32] = "";
  if (i > 2) {
    attr = COLOUR_L_GREEN;
    type = "Fast ";
  } else if (i < 2) {
    attr = COLOUR_ORANGE;
    type = "Slow ";
  }
  if (type) strnfmt(buf, sizeof(buf), "%s", type);
  c_put_str(attr, format("%-4s", buf), row, col);
}
STATIC_OVL void
prt_str(int row, int col)
{
  prt_stat(STAT_STR, row, col);
}
STATIC_OVL void
prt_dex(int row, int col)
{
  prt_stat(STAT_DEX, row, col);
}
STATIC_OVL void
prt_con(int row, int col)
{
  prt_stat(STAT_CON, row, col);
}
STATIC_OVL void
prt_gra(int row, int col)
{
  prt_stat(STAT_GRA, row, col);
}
STATIC_OVL int
prt_stat_short(int stat, int row, int col)
{
  char tmp[32];
  if (player->stat_drain[stat] < 0) {
    put_str(format("%c:", stat_names_reduced[stat][0]), row, col);
    strnfmt(tmp, sizeof(tmp), "    %2d", player->state.stat_use[stat]);
    strskip(tmp, ' ', 0);
    c_put_str(COLOUR_YELLOW, tmp, row, col + 2);
  } else {
    put_str(format("%c:", stat_names[stat][0]), row, col);
    strnfmt(tmp, sizeof(tmp), "    %2d", player->state.stat_use[stat]);
    strskip(tmp, ' ', 0);
    c_put_str(COLOUR_L_GREEN, tmp, row, col + 2);
  }
  return 3 + strlen(tmp);
}
STATIC_OVL int
prt_exp_short(int row, int col)
{
  char out_val[32];
  long xp = (long)player->exp;
  strnfmt(out_val, sizeof(out_val), "%ld", xp);
  put_str("EXP:", row, col);
  c_put_str(COLOUR_L_GREEN, out_val, row, col + 4);
  return 5 + strlen(out_val);
}
STATIC_OVL int
prt_hp_short(int row, int col)
{
  char cur_hp[32], max_hp[32];
  uint8_t color = player_hp_attr(player);
  put_str("HP:", row, col);
  col += 3;
  strnfmt(max_hp, sizeof(max_hp), "%d", player->mhp);
  strnfmt(cur_hp, sizeof(cur_hp), "%d", player->chp);
  c_put_str(color, cur_hp, row, col);
  col += strlen(cur_hp);
  c_put_str(COLOUR_WHITE, "/", row, col);
  col += 1;
  c_put_str(COLOUR_L_GREEN, max_hp, row, col);
  return 5 + strlen(cur_hp) + strlen(max_hp);
}
STATIC_OVL int
prt_sp_short(int row, int col)
{
  char cur_sp[32], max_sp[32];
  uint8_t color = player_sp_attr(player);
  put_str("Vo:", row, col);
  col += 3;
  strnfmt(max_sp, sizeof(max_sp), "%d", player->msp);
  strnfmt(cur_sp, sizeof(cur_sp), "%d", player->csp);
  c_put_str(color, cur_sp, row, col);
  col += strlen(cur_sp);
  c_put_str(COLOUR_WHITE, "/", row, col);
  col += 1;
  c_put_str(COLOUR_L_GREEN, max_sp, row, col);
  return 5 + strlen(cur_sp) + strlen(max_sp);
}
STATIC_OVL int
prt_health_short(int row, int col)
{
  int len = prt_health_aux(row, col);
  if (len > 0) {
    return len + 1;
  }
  return 0;
}
STATIC_OVL void
update_topbar(game_event_type type, game_event_data* data, void* user, int row)
{
  int col = 0;
  prt("", row, col);
  col += prt_exp_short(row, col);
  col += prt_stat_short(STAT_STR, row, col);
  col += prt_stat_short(STAT_DEX, row, col);
  col += prt_stat_short(STAT_CON, row, col);
  col += prt_stat_short(STAT_GRA, row, col);
  ++row;
  col = 0;
  prt("", row, col);
  col += prt_hp_short(row, col);
  col += prt_sp_short(row, col);
  col += prt_health_short(row, col);
}
STATIC_OVL void
update_sidebar(game_event_type type, game_event_data* data, void* user)
{
  int x, y, row;
  int max_priority;
  size_t i;
  if (Term->sidebar_mode == SIDEBAR_NONE) {
    return;
  }
  if (Term->sidebar_mode == SIDEBAR_TOP) {
    update_topbar(type, data, user, 1);
    return;
  }
  Term_get_size(&x, &y);
  max_priority = y - 2;
  for (i = 0, row = 1; i < N_ELEMENTS(side_handlers); i++) {
    const struct side_handler_t* hnd = &side_handlers[i];
    int priority = hnd->priority;
    bool from_bottom = false;
    if (priority < 0) {
      priority = -priority;
      from_bottom = true;
    }
    if (priority <= max_priority) {
      if (hnd->type == type && hnd->hook) {
        if (from_bottom)
          hnd->hook(Term->hgt - (N_ELEMENTS(side_handlers) - i), 0);
        else
          hnd->hook(row, 0);
      }
      row++;
    }
  }
}
STATIC_OVL void
hp_colour_change(game_event_type type, game_event_data* data, void* user)
{
  if (use_graphics == GRAPHICS_NONE) square_light_spot(cave, player->grid);
}
STATIC_OVL size_t
prt_state(int row, int col)
{
  uint8_t attr = COLOUR_WHITE;
  char text[16] = "";
  if (player->upkeep->smithing) {
    my_strcpy(text, "Smithing  ", sizeof(text));
  } else if (player_is_resting(player)) {
    int i;
    int n = player_resting_count(player);
    my_strcpy(text, "Rest      ", sizeof(text));
    if (n >= 1000) {
      i = n / 100;
      text[9] = '0';
      text[8] = '0';
      text[7] = I2D(i % 10);
      if (i >= 10) {
        i = i / 10;
        text[6] = I2D(i % 10);
        if (i >= 10) text[5] = I2D(i / 10);
      }
    } else if (n >= 100) {
      i = n;
      text[9] = I2D(i % 10);
      i = i / 10;
      text[8] = I2D(i % 10);
      text[7] = I2D(i / 10);
    } else if (n >= 10) {
      i = n;
      text[9] = I2D(i % 10);
      text[8] = I2D(i / 10);
    } else if (n > 0) {
      i = n;
      text[9] = I2D(i);
    } else if (n == REST_ALL_POINTS)
      text[5] = text[6] = text[7] = text[8] = text[9] = '*';
    else if (n == REST_COMPLETE)
      text[5] = text[6] = text[7] = text[8] = text[9] = '&';
    else if (n == REST_SOME_POINTS)
      text[5] = text[6] = text[7] = text[8] = text[9] = '!';
  } else if (cmd_get_nrepeats()) {
    int nrepeats = cmd_get_nrepeats();
    if (nrepeats > 999)
      strnfmt(text, sizeof(text), "Rep. %3d00", nrepeats / 100);
    else
      strnfmt(text, sizeof(text), "Repeat %3d", nrepeats);
  } else if (player->stealth_mode) {
    my_strcpy(text, "Stealth   ", sizeof(text));
  }
  c_put_str(attr, text, row, col);
  return strlen(text) + 1;
}
STATIC_OVL size_t
prt_light(int row, int col)
{
  int light = square_light(cave, player->grid);
  if (light > 0) {
    c_put_str(COLOUR_YELLOW, format("Light %d ", light), row, col);
  } else {
    c_put_str(COLOUR_PURPLE, format("Light %d ", light), row, col);
  }
  return 8 + (ABS(light) > 9 ? 1 : 0) + (light < 0 ? 1 : 0);
}
STATIC_OVL int
longest_terrain_name(void)
{
  size_t i, max = 0;
  for (i = 0; i < z_info->trap_max; i++) {
    if (strlen(trap_info[i].name) > max) {
      max = strlen(trap_info[i].name);
    }
  }
  for (i = 0; i < FEAT_MAX; i++) {
    if (strlen(f_info[i].name) > max) {
      max = strlen(f_info[i].name);
    }
  }
  return max;
}
STATIC_OVL size_t
prt_terrain(int row, int col)
{
  struct feature* feat = square_feat(cave, player->grid);
  struct trap* trap = square_trap(cave, player->grid);
  char buf[30];
  uint8_t attr;
  if (trap && !square_isinvis(cave, player->grid) &&
      !square_isforge(cave, player->grid)) {
    my_strcpy(buf, trap->kind->name, sizeof(buf));
    attr = trap->kind->d_attr;
  } else {
    my_strcpy(buf, feat->name, sizeof(buf));
    attr = feat->d_attr;
  }
  my_strcap(buf);
  c_put_str(attr, format("%s ", buf), row, col);
  return longest_terrain_name() + 1;
}
STATIC_OVL size_t
prt_tmd(int row, int col)
{
  size_t i, len = 0;
  for (i = 0; i < TMD_MAX; i++) {
    if ((i == TMD_CUT || i == TMD_POISONED) &&
        Term->sidebar_mode == SIDEBAR_LEFT) {
      continue;
    }
    len += prt_one_tmd(row, col + len, i) + 1;
  }
  return len;
}
STATIC_OVL size_t
prt_unignore(int row, int col)
{
  if (player->unignoring) {
    const char* str = "Unignoring";
    put_str(str, row, col);
    return strlen(str) + 1;
  }
  return 0;
}
STATIC_OVL size_t
prt_depth(int row, int col)
{
  char buf[32];
  if (!player->depth)
    my_strcpy(buf, "Surface", sizeof(buf));
  else
    strnfmt(buf, sizeof(buf), "%d'", player->depth * 50);
  put_str(format("%7s", buf), row, col);
  return 7;
}
STATIC_OVL void
update_statusline_aux(int row, int col)
{
  size_t i;
  prt("", row, col);
  for (i = 0; i < N_ELEMENTS(status_handlers); i++)
    col += status_handlers[i](row, col);
}
STATIC_OVL void
update_statusline(game_event_type type, game_event_data* data, void* user)
{
  int row = Term->hgt - 1;
  if (Term->sidebar_mode == SIDEBAR_TOP) {
    row = 3;
  }
  update_statusline_aux(row, COL_MAP);
}
STATIC_OVL void
update_maps(game_event_type type, game_event_data* data, void* user)
{
  term* t = user;
  if (data->point.x == -1 && data->point.y == -1)
    prt_map();
  else {
    struct grid_data g;
    int a, ta;
    wchar_t c, tc;
    int ky, kx;
    int vy, vx;
    int clipy;
    ky = data->point.y - t->offset_y;
    kx = data->point.x - t->offset_x;
    if (t == angband_term[0]) {
      if ((ky < 0) || (ky >= SCREEN_HGT)) return;
      if ((kx < 0) || (kx >= SCREEN_WID)) return;
      vy = tile_height * ky + ROW_MAP;
      vx = tile_width * kx + COL_MAP;
      clipy = ROW_MAP + SCREEN_ROWS;
    } else {
      if ((ky < 0) || (ky >= t->hgt / tile_height)) return;
      if ((kx < 0) || (kx >= t->wid / tile_width)) return;
      vy = tile_height * ky;
      vx = tile_width * kx;
      clipy = t->hgt;
    }
    map_info(data->point, &g);
    grid_data_as_text(&g, &a, &c, &ta, &tc);
    Term_queue_char(t, vx, vy, a, c, ta, tc);
    if ((tile_width > 1) || (tile_height > 1))
      Term_big_queue_char(t, vx, vy, clipy, a, c, COLOUR_WHITE, L' ');
  }
  if (player->upkeep->update & (PU_PANEL) && OPT(player, center_player)) {
    int hgt =
        (t == angband_term[0]) ? SCREEN_HGT / 2 : t->hgt / (tile_height * 2);
    int wid =
        (t == angband_term[0]) ? SCREEN_WID / 2 : t->wid / (tile_width * 2);
    if (panel_should_modify(t, player->grid.y - hgt, player->grid.x - wid))
      return;
  }
  Term_fresh();
}
STATIC_OVL void
do_animation(void)
{
  int i;
  for (i = 1; i < cave_monster_max(cave); i++) {
    uint8_t attr;
    struct monster* mon = cave_monster(cave, i);
    if (!mon || !mon->race || !monster_is_visible(mon))
      continue;
    else if (rf_has(mon->race->flags, RF_ATTR_MULTI))
      attr = randint1(BASIC_COLORS - 1);
    else if (rf_has(mon->race->flags, RF_ATTR_FLICKER)) {
      uint8_t base_attr = monster_x_attr[mon->race->ridx];
      attr = visuals_cycler_get_attr_for_race(mon->race, flicker);
      if (attr == BASIC_COLORS) {
        attr = visuals_flicker_get_attr_for_frame(base_attr, flicker);
      }
      if (attr == BASIC_COLORS) {
        attr = base_attr;
      }
    } else
      continue;
    mon->attr = attr;
    player->upkeep->redraw |= (PR_MAP | PR_MONLIST);
  }
  flicker++;
}
STATIC_OVL void
allow_animations(void)
{
  animations_allowed = true;
}
STATIC_OVL void
disallow_animations(void)
{
  animations_allowed = false;
}
STATIC_OVL void
animate(game_event_type type, game_event_data* data, void* user)
{
  do_animation();
}
STATIC_OVL void
idle_update(void)
{
  if (!animations_allowed) return;
  if (msg_flag) return;
  if (!character_dungeon) return;
  if (!OPT(player, animate_flicker) || (use_graphics != GRAPHICS_NONE)) return;
  do_animation();
  redraw_stuff(player);
  Term_fresh();
}
STATIC_OVL void
bolt_pict(int y, int x, int ny, int nx, int typ, uint8_t* a, wchar_t* c)
{
  int motion;
  if ((ny == y) && (nx == x))
    motion = BOLT_NO_MOTION;
  else if (nx == x)
    motion = BOLT_0;
  else if ((ny - y) == (x - nx))
    motion = BOLT_45;
  else if (ny == y)
    motion = BOLT_90;
  else if ((ny - y) == (nx - x))
    motion = BOLT_135;
  else
    motion = BOLT_NO_MOTION;
  if (use_graphics == GRAPHICS_NONE) {
    wchar_t chars[] = L"*|/-\\";
    *c = chars[motion];
    *a = projections[typ].color;
  } else {
    *a = proj_to_attr[typ][motion];
    *c = proj_to_char[typ][motion];
  }
}
STATIC_OVL void
display_explosion(game_event_type type, game_event_data* data, void* user)
{
  bool new_radius = false;
  bool drawn = false;
  int i, y, x;
  int msec = player->opts.delay_factor;
  int proj_type = data->explosion.proj_type;
  int num_grids = data->explosion.num_grids;
  int* distance_to_grid = data->explosion.distance_to_grid;
  bool drawing = data->explosion.drawing;
  bool* player_sees_grid = data->explosion.player_sees_grid;
  struct loc* blast_grid = data->explosion.blast_grid;
  struct loc centre = data->explosion.centre;
  for (i = 0; i < num_grids; i++) {
    y = blast_grid[i].y;
    x = blast_grid[i].x;
    if (player_sees_grid[i]) {
      uint8_t a;
      wchar_t c;
      drawn = true;
      bolt_pict(y, x, y, x, proj_type, &a, &c);
      print_rel(c, a, y, x);
    }
    move_cursor_relative(centre.y, centre.x);
    if (i == num_grids - 1)
      new_radius = true;
    else if (distance_to_grid[i + 1] > distance_to_grid[i])
      new_radius = true;
    if (new_radius) {
      Term_fresh();
      if (player->upkeep->redraw) redraw_stuff(player);
      if (drawn || drawing) {
        Term_xtra(TERM_XTRA_DELAY, msec);
      }
      new_radius = false;
    }
  }
  if (drawn) {
    for (i = 0; i < num_grids; i++) {
      y = blast_grid[i].y;
      x = blast_grid[i].x;
      if (player_sees_grid[i]) event_signal_point(EVENT_MAP, x, y);
    }
    move_cursor_relative(centre.y, centre.x);
    Term_fresh();
    if (player->upkeep->redraw) redraw_stuff(player);
  }
}
STATIC_OVL void
display_bolt(game_event_type type, game_event_data* data, void* user)
{
  int msec = player->opts.delay_factor;
  int proj_type = data->bolt.proj_type;
  bool drawing = data->bolt.drawing;
  bool seen = data->bolt.seen;
  bool beam = data->bolt.beam;
  int oy = data->bolt.oy;
  int ox = data->bolt.ox;
  int y = data->bolt.y;
  int x = data->bolt.x;
  if (seen) {
    uint8_t a;
    wchar_t c;
    bolt_pict(oy, ox, y, x, proj_type, &a, &c);
    print_rel(c, a, y, x);
    move_cursor_relative(y, x);
    Term_fresh();
    if (player->upkeep->redraw) redraw_stuff(player);
    Term_xtra(TERM_XTRA_DELAY, msec);
    event_signal_point(EVENT_MAP, x, y);
    Term_fresh();
    if (player->upkeep->redraw) redraw_stuff(player);
    if (beam) {
      bolt_pict(y, x, y, x, proj_type, &a, &c);
      print_rel(c, a, y, x);
    }
  } else if (drawing) {
    Term_xtra(TERM_XTRA_DELAY, msec);
  }
}
STATIC_OVL void
display_missile(game_event_type type, game_event_data* data, void* user)
{
  int msec = player->opts.delay_factor;
  struct object* obj = data->missile.obj;
  bool seen = data->missile.seen;
  int y = data->missile.y;
  int x = data->missile.x;
  if (seen) {
    print_rel(object_char(obj), object_attr(obj), y, x);
    move_cursor_relative(y, x);
    Term_fresh();
    if (player->upkeep->redraw) redraw_stuff(player);
    Term_xtra(TERM_XTRA_DELAY, msec);
    event_signal_point(EVENT_MAP, x, y);
    Term_fresh();
    if (player->upkeep->redraw) redraw_stuff(player);
  }
}
STATIC_OVL void
hit_pict(int dam, int typ, bool fatal, uint8_t* a)
{
  if (1) {
    if (fatal) {
      *a = COLOUR_RED;
    } else if (!dam) {
      if (typ == PROJ_SOUND) {
        *a = COLOUR_L_UMBER;
      } else {
        *a = COLOUR_L_WHITE;
      }
    } else {
      if (typ == PROJ_POIS) {
        *a = COLOUR_GREEN;
      } else if (typ == PROJ_SOUND) {
        *a = COLOUR_L_UMBER;
      } else {
        *a = COLOUR_L_RED;
      }
    }
  } else {
  }
}
STATIC_OVL void
display_hit(game_event_type type, game_event_data* data, void* user)
{
  int msec = 3 * player->opts.delay_factor;
  int dam = data->hit.dam;
  int dam_type = data->hit.dam_type;
  bool fatal = data->hit.fatal;
  int y = data->hit.grid.y;
  int x = data->hit.grid.x;
  int ones, tens;
  if (!OPT(player, display_hits)) return;
  if (dam <= 0) {
    ones = 0;
    tens = 0;
  } else if (dam < 100) {
    ones = dam % 10;
    tens = dam / 10;
  } else {
    ones = 9;
    tens = 9;
  }
  if (damage_x_attr[0] & 0x80) {
    print_rel(damage_x_char[ones], damage_x_attr[ones], y, x);
    move_cursor_relative(y, x);
    if (dam >= 10) {
      print_rel(damage_x_char[tens], damage_x_attr[tens], y, x - 1);
      move_cursor_relative(y, x - 1);
    }
  } else {
    uint8_t a;
    wchar_t c;
    hit_pict(dam, dam_type, fatal, &a);
    c = '0' + ones;
    print_rel(c, a, y, x);
    move_cursor_relative(y, x);
    if (dam >= 10) {
      c = '0' + tens;
      print_rel(c, a, y, x - 1);
      move_cursor_relative(y, x - 1);
    }
  }
  Term_fresh();
  Term_xtra(TERM_XTRA_DELAY, msec);
  event_signal_point(EVENT_MAP, x, y);
  if (dam >= 10) {
    event_signal_point(EVENT_MAP, x - 1, y);
  }
  Term_fresh();
  if (player->upkeep->redraw) redraw_stuff(player);
}
STATIC_OVL void
pause_with_text(game_event_type type, game_event_data* data, void* user)
{
  ang_file* fp = NULL;
  char buf[1024];
  int row = data->verse.row;
  int col = data->verse.col;
  int msec = 50;
  if (data->verse.filename) {
    path_build(buf, 1024, ANGBAND_DIR_GAMEDATA,
               format("%s.txt", data->verse.filename));
    fp = file_open(buf, MODE_READ, FTYPE_TEXT);
    if (!fp) {
      return;
    }
  }
  screen_save();
  Term_clear();
  if (data->verse.filename) {
    int i = 0;
    while (file_getl(fp, buf, 80)) {
      c_put_str(COLOUR_WHITE, buf, row + i, col);
      Term_xtra(TERM_XTRA_DELAY, msec);
      Term_fresh();
      i++;
    }
  } else if (data->verse.text) {
    size_t *line_starts = NULL, *line_lengths = NULL;
    const wchar_t* txt;
    size_t n_lines;
    int w, h, i, nln_lim;
    Term_get_size(&w, &h);
    if (w <= col || h <= row) {
      return;
    }
    n_lines = textblock_calculate_lines(data->verse.text, &line_starts,
                                        &line_lengths, MIN(80, w - col));
    nln_lim = (n_lines < (size_t)w - (size_t)row) ? (int)n_lines : w - row;
    txt = textblock_text(data->verse.text);
    for (i = 0; i < nln_lim; ++i) {
      int j;
      for (j = 0; j < (int)line_lengths[i]; ++j) {
        Term_putch(col + j, row + i, COLOUR_WHITE, txt[line_starts[i] + j]);
      }
      Term_xtra(TERM_XTRA_DELAY, msec);
      Term_fresh();
    }
    mem_free(line_starts);
    mem_free(line_lengths);
  }
  anykey();
  event_signal(EVENT_MESSAGE_FLUSH);
  if (data->verse.filename) {
    file_close(fp);
  }
  screen_load();
}
STATIC_OVL void
update_inven_subwindow(game_event_type type, game_event_data* data, void* user)
{
  term* old = Term;
  term* inv_term = user;
  Term_activate(inv_term);
  if (!flip_inven)
    show_inven(OLIST_WINDOW | OLIST_WEIGHT, NULL);
  else
    show_equip(OLIST_WINDOW | OLIST_WEIGHT, NULL);
  Term_fresh();
  Term_activate(old);
}
STATIC_OVL void
update_equip_subwindow(game_event_type type, game_event_data* data, void* user)
{
  term* old = Term;
  term* inv_term = user;
  Term_activate(inv_term);
  if (!flip_inven)
    show_equip(OLIST_WINDOW | OLIST_WEIGHT, NULL);
  else
    show_inven(OLIST_WINDOW | OLIST_WEIGHT, NULL);
  Term_fresh();
  Term_activate(old);
}
STATIC_OVL void
toggle_inven_equip(void)
{
  term* old = Term;
  int i;
  flip_inven = !flip_inven;
  for (i = 0; i < ANGBAND_TERM_MAX; i++) {
    if (!angband_term[i]) continue;
    Term_activate(angband_term[i]);
    if (window_flag[i] & PW_INVEN) {
      if (!flip_inven)
        show_inven(OLIST_WINDOW | OLIST_WEIGHT, NULL);
      else
        show_equip(OLIST_WINDOW | OLIST_WEIGHT, NULL);
      Term_fresh();
    } else if (window_flag[i] & PW_EQUIP) {
      if (!flip_inven)
        show_equip(OLIST_WINDOW | OLIST_WEIGHT, NULL);
      else
        show_inven(OLIST_WINDOW | OLIST_WEIGHT, NULL);
      Term_fresh();
    }
  }
  Term_activate(old);
}
STATIC_OVL void
update_itemlist_subwindow(game_event_type type, game_event_data* data,
                          void* user)
{
  term* old = Term;
  term* inv_term = user;
  Term_activate(inv_term);
  clear_from(0);
  object_list_show_subwindow(Term->hgt, Term->wid);
  Term_fresh();
  Term_activate(old);
}
STATIC_OVL void
update_monlist_subwindow(game_event_type type, game_event_data* data,
                         void* user)
{
  term* old = Term;
  term* inv_term = user;
  Term_activate(inv_term);
  clear_from(0);
  monster_list_show_subwindow(Term->hgt, Term->wid);
  Term_fresh();
  Term_activate(old);
}
STATIC_OVL void
update_monster_subwindow(game_event_type type, game_event_data* data,
                         void* user)
{
  term* old = Term;
  term* inv_term = user;
  Term_activate(inv_term);
  if (player->upkeep->monster_race)
    lore_show_subwindow(player->upkeep->monster_race,
                        get_lore(player->upkeep->monster_race));
  Term_fresh();
  Term_activate(old);
}
STATIC_OVL void
update_object_subwindow(game_event_type type, game_event_data* data, void* user)
{
  term* old = Term;
  term* inv_term = user;
  Term_activate(inv_term);
  if (player->upkeep->object != NULL)
    display_object_recall(player->upkeep->object);
  else if (player->upkeep->object_kind)
    display_object_kind_recall(player->upkeep->object_kind);
  Term_fresh();
  Term_activate(old);
}
STATIC_OVL void
update_messages_subwindow(game_event_type type, game_event_data* data,
                          void* user)
{
  term* old = Term;
  term* inv_term = user;
  int i;
  int w, h;
  int x, y;
  const char* msg;
  Term_activate(inv_term);
  Term_get_size(&w, &h);
  for (i = 0; i < h; i++) {
    uint8_t color = message_color(i);
    uint16_t count = message_count(i);
    const char* str = message_str(i);
    if (count == 1)
      msg = str;
    else if (count == 0)
      msg = " ";
    else
      msg = format("%s <%dx>", str, count);
    Term_putstr(0, (h - 1) - i, -1, color, msg);
    Term_locate(&x, &y);
    Term_erase(x, y, 255);
  }
  Term_fresh();
  Term_activate(old);
}
STATIC_OVL void
update_minimap_subwindow(game_event_type type, game_event_data* data,
                         void* user)
{
  struct minimap_flags* flags = user;
  if (player_resting_count(player) || player->upkeep->running) return;
  if (type == EVENT_END) {
    term* old = Term;
    term* t = angband_term[flags->win_idx];
    Term_activate(t);
    if (flags->needs_redraw) Term_clear();
    display_map(NULL, NULL);
    Term_fresh();
    Term_activate(old);
    flags->needs_redraw = false;
  } else if (type == EVENT_DUNGEONLEVEL) {
    term* t = angband_term[flags->win_idx];
    int map_height = t->hgt - 2;
    int map_width = t->wid - 2;
    if (cave->height <= map_height || cave->width <= map_width) {
      flags->needs_redraw = true;
    }
  }
}
STATIC_OVL void
update_player0_subwindow(game_event_type type, game_event_data* data,
                         void* user)
{
  term* old = Term;
  term* inv_term = user;
  Term_activate(inv_term);
  display_player(0);
  Term_fresh();
  Term_activate(old);
}
STATIC_OVL void
update_player1_subwindow(game_event_type type, game_event_data* data,
                         void* user)
{
  term* old = Term;
  term* inv_term = user;
  Term_activate(inv_term);
  display_player(1);
  Term_fresh();
  Term_activate(old);
}
STATIC_OVL void
update_topbar_subwindow(game_event_type type, game_event_data* data, void* user)
{
  term* old = Term;
  term* inv_term = user;
  if (!(player && player->race && player->house && cave)) return;
  Term_activate(inv_term);
  update_topbar(type, data, user, 0);
  update_statusline_aux(2, 0);
  Term_fresh();
  Term_activate(old);
}
STATIC_OVL void
update_player_compact_subwindow(game_event_type type, game_event_data* data,
                                void* user)
{
  int row = 0;
  int col = 0;
  int i;
  term* old = Term;
  term* inv_term = user;
  Term_activate(inv_term);
  prt_name(row++, col);
  prt_exp(row++, col);
  prt_equippy(row++, col);
  for (i = 0; i < STAT_MAX; i++) prt_stat(i, row++, col);
  row++;
  prt_hp(row++, col);
  prt_sp(row++, col);
  prt_health(row, col);
  Term_fresh();
  Term_activate(old);
}
STATIC_OVL void
update_combat_rolls_subwindow(game_event_type type, game_event_data* data,
                              void* user)
{
  term* old = Term;
  term* inv_term = user;
  Term_activate(inv_term);
  display_combat_rolls(type, data, user);
  Term_fresh();
  Term_activate(old);
}
STATIC_OVL void
flush_subwindow(game_event_type type, game_event_data* data, void* user)
{
  term* old = Term;
  term* t = user;
  Term_activate(t);
  Term_fresh();
  Term_activate(old);
}
STATIC_OVL void
subwindow_flag_changed(int win_idx, uint32_t flag, bool new_state)
{
  void (*register_or_deregister)(game_event_type type, game_event_handler * fn,
                                 void* user);
  void (*set_register_or_deregister)(game_event_type * type, size_t n_events,
                                     game_event_handler * fn, void* user);
  if (new_state == false) {
    register_or_deregister = event_remove_handler;
    set_register_or_deregister = event_remove_handler_set;
  } else {
    register_or_deregister = event_add_handler;
    set_register_or_deregister = event_add_handler_set;
  }
  switch (flag) {
    case PW_INVEN: {
      register_or_deregister(EVENT_INVENTORY, update_inven_subwindow,
                             angband_term[win_idx]);
      break;
    }
    case PW_EQUIP: {
      register_or_deregister(EVENT_EQUIPMENT, update_equip_subwindow,
                             angband_term[win_idx]);
      break;
    }
    case PW_PLAYER_0: {
      set_register_or_deregister(player_events, N_ELEMENTS(player_events),
                                 update_player0_subwindow,
                                 angband_term[win_idx]);
      break;
    }
    case PW_PLAYER_1: {
      set_register_or_deregister(player_events, N_ELEMENTS(player_events),
                                 update_player1_subwindow,
                                 angband_term[win_idx]);
      break;
    }
    case PW_PLAYER_2: {
      set_register_or_deregister(player_events, N_ELEMENTS(player_events),
                                 update_player_compact_subwindow,
                                 angband_term[win_idx]);
      break;
    }
    case PW_PLAYER_3: {
      set_register_or_deregister(player_events, N_ELEMENTS(player_events),
                                 update_topbar_subwindow,
                                 angband_term[win_idx]);
      set_register_or_deregister(
          statusline_events, N_ELEMENTS(statusline_events),
          update_topbar_subwindow, angband_term[win_idx]);
      break;
    }
    case PW_COMBAT_ROLLS: {
      register_or_deregister(EVENT_COMBAT_DISPLAY,
                             update_combat_rolls_subwindow,
                             angband_term[win_idx]);
      break;
    }
    case PW_MAP: {
      minimap_data[win_idx].win_idx = win_idx;
      register_or_deregister(EVENT_MAP, update_minimap_subwindow,
                             &minimap_data[win_idx]);
      register_or_deregister(EVENT_DUNGEONLEVEL, update_minimap_subwindow,
                             &minimap_data[win_idx]);
      register_or_deregister(EVENT_END, update_minimap_subwindow,
                             &minimap_data[win_idx]);
      break;
    }
    case PW_MESSAGE: {
      register_or_deregister(EVENT_MESSAGE, update_messages_subwindow,
                             angband_term[win_idx]);
      break;
    }
    case PW_OVERHEAD: {
      register_or_deregister(EVENT_MAP, update_maps, angband_term[win_idx]);
      register_or_deregister(EVENT_END, flush_subwindow, angband_term[win_idx]);
      break;
    }
    case PW_MONSTER: {
      register_or_deregister(EVENT_MONSTERTARGET, update_monster_subwindow,
                             angband_term[win_idx]);
      break;
    }
    case PW_OBJECT: {
      register_or_deregister(EVENT_OBJECTTARGET, update_object_subwindow,
                             angband_term[win_idx]);
      break;
    }
    case PW_MONLIST: {
      register_or_deregister(EVENT_MONSTERLIST, update_monlist_subwindow,
                             angband_term[win_idx]);
      break;
    }
    case PW_ITEMLIST: {
      register_or_deregister(EVENT_ITEMLIST, update_itemlist_subwindow,
                             angband_term[win_idx]);
      break;
    }
  }
}
STATIC_OVL void
subwindow_set_flags(int win_idx, uint32_t new_flags)
{
  term* old = Term;
  int i;
  for (i = 0; i < 32; i++)
    if (window_flag_desc[i]) {
      uint32_t flag = ((uint32_t)1) << i;
      if ((new_flags & flag) != (window_flag[win_idx] & flag)) {
        subwindow_flag_changed(win_idx, flag, (new_flags & flag) != 0);
      }
    }
  window_flag[win_idx] = new_flags;
  Term_activate(angband_term[win_idx]);
  Term_clear();
  Term_fresh();
  Term_activate(old);
}
STATIC_OVL void
subwindows_set_flags(uint32_t* new_flags, size_t n_subwindows)
{
  size_t j;
  for (j = 0; j < n_subwindows; j++) {
    if (!angband_term[j]) continue;
    if (window_flag[j] != new_flags[j]) subwindow_set_flags(j, new_flags[j]);
  }
}
STATIC_OVL void
init_angband_aux(const char* why)
{
  quit_fmt("%s\n\n%s", why,
           "The 'lib' directory is probably missing or broken.\n"
           "Perhaps the archive was not extracted correctly.\n"
           "See the 'readme.txt' file for more information.");
}
STATIC_OVL void
splashscreen_note(game_event_type type, game_event_data* data, void* user)
{
  if (data->message.type == MSG_BIRTH) {
    static int y = 2;
    prt(data->message.msg, y, 0);
    pause_line(Term);
    if (++y >= 24) y = 2;
  } else {
    char* s = format("[%s]", data->message.msg);
    Term_erase(0, (Term->hgt - 23) / 5 + 23, 255);
    Term_putstr((Term->wid - strlen(s)) / 2, (Term->hgt - 23) / 5 + 23, -1,
                COLOUR_WHITE, s);
  }
  Term_fresh();
}
STATIC_OVL void
show_splashscreen(game_event_type type, game_event_data* data, void* user)
{
  ang_file* fp;
  char buf[1024];
  path_build(buf, sizeof(buf), ANGBAND_DIR_SCREENS, "news.txt");
  if (!file_exists(buf)) {
    char why[1024];
    strnfmt(why, sizeof(why), "Cannot access the '%s' file!", buf);
    init_angband_aux(why);
  }
  Term_clear();
  path_build(buf, sizeof(buf), ANGBAND_DIR_SCREENS, "news.txt");
  fp = file_open(buf, MODE_READ, FTYPE_TEXT);
  text_out_hook = text_out_to_screen;
  if (fp) {
    text_out_indent = (Term->wid - 80) / 2;
    Term_gotoxy(0, (Term->hgt - 23) / 5);
    while (file_getl(fp, buf, sizeof(buf))) {
      char* version_marker = strstr(buf, "$VERSION");
      if (version_marker) {
        ptrdiff_t pos = version_marker - buf;
        strnfmt(version_marker, sizeof(buf) - pos, "%-8s", buildver);
      }
      text_out_e("%s", buf);
      text_out("\n");
    }
    text_out_indent = 0;
    file_close(fp);
  }
  Term_fresh();
}
STATIC_OVL void
ui_refresh(game_event_type type, game_event_data* data, void* user)
{
  Term_fresh();
}
STATIC_OVL void
repeated_command_display(game_event_type type, game_event_data* data,
                         void* user)
{
  msg_flag = false;
  prt("", 0, 0);
}
STATIC_OVL void
new_level_display_update(game_event_type type, game_event_data* data,
                         void* user)
{
  Term->offset_y = z_info->dungeon_hgt;
  Term->offset_x = z_info->dungeon_wid;
  verify_panel();
  Term_clear();
  player->upkeep->update |= (PU_BONUS | PU_HP | PU_SPELLS);
  player->upkeep->update |= (PU_TORCH);
  player->upkeep->update |= (PU_UPDATE_VIEW | PU_DISTANCE);
  player->upkeep->redraw |= (PR_BASIC | PR_EXTRA | PR_MAP);
  player->upkeep->redraw |=
      (PR_INVEN | PR_EQUIP | PR_MONSTER | PR_MONLIST | PR_ITEMLIST);
  monster_list_force_subwindow_update();
  if (player->upkeep->autosave) {
    save_game();
    player->upkeep->autosave = false;
  }
  handle_stuff(player);
  Term_fresh();
}
STATIC_OVL void
cheat_death(game_event_type type, game_event_data* data, void* user)
{
  msg("You invoke wizard mode and cheat death.");
  event_signal(EVENT_MESSAGE_FLUSH);
  wiz_cheat_death();
}
STATIC_OVL void
check_panel(game_event_type type, game_event_data* data, void* user)
{
  verify_panel();
}
STATIC_OVL void
see_floor_items(game_event_type type, game_event_data* data, void* user)
{
  int floor_max = z_info->floor_size;
  struct object** floor_list = mem_zalloc(floor_max * sizeof(*floor_list));
  int floor_num = 0;
  bool blind = ((player->timed[TMD_BLIND]) || (no_light(player)));
  const char* p = "see";
  bool can_pickup = false;
  int i;
  floor_num = scan_floor(floor_list, floor_max, player,
                         OFLOOR_SENSE | OFLOOR_VISIBLE, NULL);
  if (floor_num == 0) {
    mem_free(floor_list);
    return;
  }
  for (i = 0; i < floor_num; i++)
    if (inven_carry_okay(floor_list[i])) can_pickup = true;
  if (floor_num == 1) {
    struct object* obj = floor_list[0];
    char o_name[80];
    if (!can_pickup)
      p = "have no room for";
    else if (blind)
      p = "feel";
    if (blind) {
      object_desc(o_name, sizeof(o_name), obj, ODESC_PREFIX | ODESC_BASE,
                  player);
    } else {
      object_desc(o_name, sizeof(o_name), obj, ODESC_PREFIX | ODESC_FULL,
                  player);
    }
    event_signal(EVENT_MESSAGE_FLUSH);
    if ((tval_is_weapon(obj) && !tval_is_ammo(obj)) || tval_is_armor(obj)) {
      int wgt = obj->weight;
      msg("You %s %s %d.%1d lb.", p, o_name, wgt / 10, wgt % 10);
    } else {
      msg("You %s %s.", p, o_name);
    }
    if (obj->artifact && streq(obj->artifact->name, "of Morgoth") &&
        !player->crown_hint) {
      msg("To attempt to prise a Silmaril from the crown, use the 'destroy' "
          "command (which is 'k' by default).");
      player->crown_hint = true;
    }
  } else {
    ui_event e;
    if (!can_pickup)
      p = "have no room for the following objects";
    else if (blind)
      p = "feel something on the floor";
    screen_save();
    show_floor(floor_list, floor_num, OLIST_WEIGHT, NULL);
    prt(format("You %s: ", p), 0, 0);
    e = inkey_ex();
    Term_event_push(&e);
    screen_load();
  }
  mem_free(floor_list);
}
STATIC_OVL void
process_character_pref_files(void)
{
  bool found;
  char buf[1024];
  process_pref_file("window.prf", true, true);
  process_pref_file("user.prf", true, true);
  player_safe_name(buf, sizeof(buf), player->full_name, true);
  my_strcat(buf, ".prf", sizeof(buf));
  found = process_pref_file(buf, true, true);
  if (!found) {
    int filename_index = path_filename_index(savefile);
    char filename[128];
    my_strcpy(filename, &savefile[filename_index], sizeof(filename));
    strnfmt(buf, sizeof(buf), "%s.prf", filename);
    process_pref_file(buf, true, true);
  }
}
STATIC_OVL void
ui_enter_init(game_event_type type, game_event_data* data, void* user)
{
  show_splashscreen(type, data, user);
  event_add_handler(EVENT_INITSTATUS, splashscreen_note, NULL);
}
STATIC_OVL void
ui_leave_init(game_event_type type, game_event_data* data, void* user)
{
  reset_visuals(true);
  process_character_pref_files();
  Term_xtra(TERM_XTRA_REACT, 0);
  (void)Term_redraw_all();
  event_remove_handler(EVENT_INITSTATUS, splashscreen_note, NULL);
  prt("Please wait...", 0, 0);
  Term_fresh();
}
STATIC_OVL void
ui_enter_world(game_event_type type, game_event_data* data, void* user)
{
  smlcurs = false;
  player->upkeep->redraw |= (PR_INVEN | PR_EQUIP | PR_MONSTER | PR_MESSAGE);
  redraw_stuff(player);
  event_add_handler_set(player_events, N_ELEMENTS(player_events),
                        update_sidebar, NULL);
  event_add_handler_set(statusline_events, N_ELEMENTS(statusline_events),
                        update_statusline, NULL);
  event_add_handler(EVENT_HP, hp_colour_change, NULL);
  event_add_handler(EVENT_MAP, update_maps, angband_term[0]);
  event_add_handler(EVENT_PLAYERMOVED, check_panel, NULL);
  event_add_handler(EVENT_SEEFLOOR, see_floor_items, NULL);
  event_add_handler(EVENT_EXPLOSION, display_explosion, NULL);
  event_add_handler(EVENT_BOLT, display_bolt, NULL);
  event_add_handler(EVENT_MISSILE, display_missile, NULL);
  event_add_handler(EVENT_HIT, display_hit, NULL);
  event_add_handler(EVENT_COMBAT_RESET, new_combat_round, NULL);
  event_add_handler(EVENT_COMBAT_ATTACK, update_combat_rolls_attack, NULL);
  event_add_handler(EVENT_COMBAT_DAMAGE, update_combat_rolls_damage, NULL);
  event_add_handler(EVENT_CHECK_INTERRUPT, check_for_player_interrupt, NULL);
  event_add_handler(EVENT_REFRESH, ui_refresh, NULL);
  event_add_handler(EVENT_NEW_LEVEL_DISPLAY, new_level_display_update, NULL);
  event_add_handler(EVENT_COMMAND_REPEAT, repeated_command_display, NULL);
  event_add_handler(EVENT_ANIMATE, animate, NULL);
  event_add_handler(EVENT_CHEAT_DEATH, cheat_death, NULL);
  event_add_handler(EVENT_DEATH, mini_screenshot, NULL);
  screen_save_depth--;
}
STATIC_OVL void
ui_leave_world(game_event_type type, game_event_data* data, void* user)
{
  smlcurs = true;
  event_remove_handler_set(player_events, N_ELEMENTS(player_events),
                           update_sidebar, NULL);
  event_remove_handler_set(statusline_events, N_ELEMENTS(statusline_events),
                           update_statusline, NULL);
  event_remove_handler(EVENT_HP, hp_colour_change, NULL);
  event_remove_handler(EVENT_PLAYERMOVED, check_panel, NULL);
  event_remove_handler(EVENT_SEEFLOOR, see_floor_items, NULL);
  event_remove_handler(EVENT_EXPLOSION, display_explosion, NULL);
  event_remove_handler(EVENT_BOLT, display_bolt, NULL);
  event_remove_handler(EVENT_MISSILE, display_missile, NULL);
  event_remove_handler(EVENT_HIT, display_hit, NULL);
  event_remove_handler(EVENT_COMBAT_RESET, new_combat_round, NULL);
  event_remove_handler(EVENT_COMBAT_ATTACK, update_combat_rolls_attack, NULL);
  event_remove_handler(EVENT_COMBAT_DAMAGE, update_combat_rolls_damage, NULL);
  event_remove_handler(EVENT_CHECK_INTERRUPT, check_for_player_interrupt, NULL);
  event_remove_handler(EVENT_REFRESH, ui_refresh, NULL);
  event_remove_handler(EVENT_NEW_LEVEL_DISPLAY, new_level_display_update, NULL);
  event_remove_handler(EVENT_COMMAND_REPEAT, repeated_command_display, NULL);
  event_remove_handler(EVENT_ANIMATE, animate, NULL);
  event_remove_handler(EVENT_CHEAT_DEATH, cheat_death, NULL);
  event_remove_handler(EVENT_DEATH, mini_screenshot, NULL);
  screen_save_depth++;
}
STATIC_OVL void
ui_enter_game(game_event_type type, game_event_data* data, void* user)
{
  event_add_handler(EVENT_MESSAGE, display_message, NULL);
  event_add_handler(EVENT_BELL, bell_message, NULL);
  event_add_handler(EVENT_INPUT_FLUSH, flush, NULL);
  event_add_handler(EVENT_MESSAGE_FLUSH, message_flush, NULL);
  event_add_handler(EVENT_POEM, pause_with_text, NULL);
}
STATIC_OVL void
ui_leave_game(game_event_type type, game_event_data* data, void* user)
{
  event_remove_handler(EVENT_MAP, update_maps, angband_term[0]);
  event_remove_handler(EVENT_MESSAGE, display_message, NULL);
  event_remove_handler(EVENT_BELL, bell_message, NULL);
  event_remove_handler(EVENT_INPUT_FLUSH, flush, NULL);
  event_remove_handler(EVENT_MESSAGE_FLUSH, message_flush, NULL);
  event_remove_handler(EVENT_POEM, pause_with_text, NULL);
}
STATIC_OVL void
init_display(void)
{
  event_add_handler(EVENT_ENTER_INIT, ui_enter_init, NULL);
  event_add_handler(EVENT_LEAVE_INIT, ui_leave_init, NULL);
  event_add_handler(EVENT_ENTER_GAME, ui_enter_game, NULL);
  event_add_handler(EVENT_LEAVE_GAME, ui_leave_game, NULL);
  event_add_handler(EVENT_ENTER_WORLD, ui_enter_world, NULL);
  event_add_handler(EVENT_LEAVE_WORLD, ui_leave_world, NULL);
  ui_init_birthstate_handlers();
}
STATIC_OVL struct menu*
effect_menu_new(struct effect* effect, int count, bool allow_random)
{
  struct menu* m = menu_new(MN_SKIN_SCROLL, menu_find_iter(MN_ITER_STRINGS));
  int width = 0;
  region loc = {0, 1, -99, -99};
  int ms_count = 0;
  char** ms;
  char buf[80];
  m->selections = all_letters_nohjkl;
  if (count > 0) {
    if (allow_random) ++count;
    ms = mem_alloc((count + 1) * sizeof(*ms));
    if (allow_random) {
      ms[ms_count] = string_make("one of the following at random");
      width =
          MAX(width, (int)MIN(strlen(ms[ms_count]) + 3, (size_t)(Term->wid)));
      ++ms_count;
    }
  } else {
    ms = NULL;
  }
  while (ms_count < count) {
    size_t len;
    len = effect_get_menu_name(buf, sizeof(buf), effect);
    if (!len) {
      int j;
      for (j = 0; j < ms_count; ++j) {
        string_free(ms[j]);
      }
      mem_free(ms);
      mem_free(m);
      msg("Mismatched count and effect list passed to effect_menu_new().  "
          "Please report this bug.");
      return NULL;
    }
    ms[ms_count] = string_make(buf);
    width = MAX(width, (int)MIN(len + 3, (size_t)(Term->wid)));
    ++ms_count;
    effect = effect_next(effect);
  }
  ms[ms_count] = NULL;
  menu_setpriv(m, ms_count, ms);
  loc.width = width;
  loc.page_rows = MIN(ms_count, Term->hgt - 2);
  menu_layout(m, &loc);
  return m;
}
STATIC_OVL int
effect_menu_select(struct menu* m, const char* prompt, bool allow_random)
{
  ui_event out;
  int selection;
  screen_save();
  region_erase_bordered(&m->active);
  prt((prompt) ? prompt : "Which effect? ", 0, 0);
  out = menu_select(m, 0, false);
  if (out.type & EVT_SELECT) {
    selection = m->cursor;
    if (allow_random) {
      if (selection == 0) {
        selection = -2;
      } else if (selection > 0) {
        --selection;
      }
    }
  } else {
    selection = -1;
  }
  screen_load();
  return selection;
}
STATIC_OVL void
effect_menu_destroy(struct menu* m)
{
  if (m) {
    char** ms = menu_priv(m);
    int i = 0;
    while (ms[i]) {
      string_free(ms[i]);
      ++i;
    }
    mem_free(ms);
    mem_free(m);
  }
}
STATIC_OVL int
textui_get_effect_from_list(const char* prompt, struct effect* effect,
                            int count, bool allow_random)
{
  struct menu* m;
  int choice;
  if (count == -1) {
    struct effect* cursor = effect;
    count = 0;
    while (cursor) {
      ++count;
      cursor = effect_next(cursor);
    }
  }
  m = effect_menu_new(effect, count, allow_random);
  if (m) {
    choice = effect_menu_select(m, prompt, allow_random);
    effect_menu_destroy(m);
  } else {
    choice = -1;
  }
  return choice;
}
STATIC_OVL keycode_t
keycode_find_code(const char* str, size_t len)
{
  size_t i;
  for (i = 0; i < N_ELEMENTS(mappings); i++) {
    if (strncmp(str, mappings[i].desc, len) == 0) return mappings[i].code;
  }
  return 0;
}
STATIC_OVL const char*
keycode_find_desc(keycode_t kc)
{
  size_t i;
  for (i = 0; i < N_ELEMENTS(mappings); i++) {
    if (mappings[i].code == kc) return mappings[i].desc;
  }
  return NULL;
}
STATIC_OVL bool
keycode_isprint(keycode_t kc)
{
  return kc != ESCAPE && utf32_isprint(kc);
}
STATIC_OVL int
dehex(char c)
{
  if (isdigit((unsigned char)c)) return (D2I(c));
  if (isalpha((unsigned char)c)) return (A2I(tolower((unsigned char)c)) + 10);
  return (0);
}
STATIC_OVL void
keypress_from_text(struct keypress* buf, size_t len, const char* str)
{
  size_t cur = 0;
  uint8_t mods = 0;
  memset(buf, 0, len * sizeof *buf);
  while (*str && cur < len) {
    buf[cur].type = EVT_KBRD;
    if (*str == '\\') {
      str++;
      if (*str == '\0') break;
      switch (*str) {
        case 'x': {
          if (isxdigit((unsigned char)(*(str + 1))) &&
              isxdigit((unsigned char)(*(str + 2)))) {
            int v1 = dehex(*++str) * 16;
            int v2 = dehex(*++str);
            {
              int p = (cur++);
              keycode_t c = (v1 + v2);
              uint8_t m = (mods);
              if ((m & KC_MOD_CONTROL) && ENCODE_KTRL(c)) {
                m &= ~KC_MOD_CONTROL;
                c = KTRL(c);
              }
              buf[p].mods = m;
              buf[p].code = c;
            };
          } else {
            {
              int p = (cur++);
              keycode_t c = ('?');
              uint8_t m = (mods);
              if ((m & KC_MOD_CONTROL) && ENCODE_KTRL(c)) {
                m &= ~KC_MOD_CONTROL;
                c = KTRL(c);
              }
              buf[p].mods = m;
              buf[p].code = c;
            };
          }
          break;
        }
        case 'a': {
          int p = (cur++);
          keycode_t c = ('\a');
          uint8_t m = (mods);
          if ((m & KC_MOD_CONTROL) && ENCODE_KTRL(c)) {
            m &= ~KC_MOD_CONTROL;
            c = KTRL(c);
          }
          buf[p].mods = m;
          buf[p].code = c;
        }; break;
        case '\\': {
          int p = (cur++);
          keycode_t c = ('\\');
          uint8_t m = (mods);
          if ((m & KC_MOD_CONTROL) && ENCODE_KTRL(c)) {
            m &= ~KC_MOD_CONTROL;
            c = KTRL(c);
          }
          buf[p].mods = m;
          buf[p].code = c;
        }; break;
        case '^': {
          int p = (cur++);
          keycode_t c = ('^');
          uint8_t m = (mods);
          if ((m & KC_MOD_CONTROL) && ENCODE_KTRL(c)) {
            m &= ~KC_MOD_CONTROL;
            c = KTRL(c);
          }
          buf[p].mods = m;
          buf[p].code = c;
        }; break;
        case '[': {
          int p = (cur++);
          keycode_t c = ('[');
          uint8_t m = (mods);
          if ((m & KC_MOD_CONTROL) && ENCODE_KTRL(c)) {
            m &= ~KC_MOD_CONTROL;
            c = KTRL(c);
          }
          buf[p].mods = m;
          buf[p].code = c;
        }; break;
        case '{': {
          int p = (cur++);
          keycode_t c = ('{');
          uint8_t m = (mods);
          if ((m & KC_MOD_CONTROL) && ENCODE_KTRL(c)) {
            m &= ~KC_MOD_CONTROL;
            c = KTRL(c);
          }
          buf[p].mods = m;
          buf[p].code = c;
        }; break;
        default: {
          int p = (cur++);
          keycode_t c = (*str);
          uint8_t m = (mods);
          if ((m & KC_MOD_CONTROL) && ENCODE_KTRL(c)) {
            m &= ~KC_MOD_CONTROL;
            c = KTRL(c);
          }
          buf[p].mods = m;
          buf[p].code = c;
        }; break;
      }
      mods = 0;
      str++;
    } else if (*str == '[') {
      char* end;
      keycode_t kc;
      if (*str++ == 0) return;
      end = strchr(str, (unsigned char)']');
      if (!end) return;
      kc = keycode_find_code(str, (size_t)(end - str));
      if (!kc) return;
      {
        int p = (cur++);
        keycode_t c = (kc);
        uint8_t m = (mods);
        if ((m & KC_MOD_CONTROL) && ENCODE_KTRL(c)) {
          m &= ~KC_MOD_CONTROL;
          c = KTRL(c);
        }
        buf[p].mods = m;
        buf[p].code = c;
      };
      mods = 0;
      str = end + 1;
    } else if (*str == '{') {
      str++;
      if (*str == '\0' || !strchr(str, (unsigned char)'}')) return;
      while (*str != '}') {
        switch (*str) {
          case '^':
            mods |= KC_MOD_CONTROL;
            break;
          case 'S':
            mods |= KC_MOD_SHIFT;
            break;
          case 'A':
            mods |= KC_MOD_ALT;
            break;
          case 'M':
            mods |= KC_MOD_META;
            break;
          case 'K':
            mods |= KC_MOD_KEYPAD;
            break;
          default:
            return;
        }
        str++;
      }
      str++;
    } else if (*str == '^') {
      mods |= KC_MOD_CONTROL;
      str++;
    } else {
      {
        int p = (cur++);
        keycode_t c = (*str++);
        uint8_t m = (mods);
        if ((m & KC_MOD_CONTROL) && ENCODE_KTRL(c)) {
          m &= ~KC_MOD_CONTROL;
          c = KTRL(c);
        }
        buf[p].mods = m;
        buf[p].code = c;
      };
      mods = 0;
    }
  }
  cur = MIN(cur, len - 1);
  buf[cur].type = EVT_NONE;
}
STATIC_OVL void
keypress_to_text(char* buf, size_t len, const struct keypress* src,
                 bool expand_backslash)
{
  size_t cur = 0;
  size_t end = 0;
  while (src[cur].type == EVT_KBRD) {
    keycode_t i = src[cur].code;
    int mods = src[cur].mods;
    const char* desc = keycode_find_desc(i);
    if (i < 0x20 && !desc) {
      mods |= KC_MOD_CONTROL;
      i = UN_KTRL(i);
    }
    if (mods) {
      if (mods & KC_MOD_CONTROL && !(mods & ~KC_MOD_CONTROL)) {
        strnfcat(buf, len, &end, "^");
      } else {
        strnfcat(buf, len, &end, "{");
        if (mods & KC_MOD_CONTROL) strnfcat(buf, len, &end, "^");
        if (mods & KC_MOD_SHIFT) strnfcat(buf, len, &end, "S");
        if (mods & KC_MOD_ALT) strnfcat(buf, len, &end, "A");
        if (mods & KC_MOD_META) strnfcat(buf, len, &end, "M");
        if (mods & KC_MOD_KEYPAD) strnfcat(buf, len, &end, "K");
        strnfcat(buf, len, &end, "}");
      }
    }
    if (desc) {
      strnfcat(buf, len, &end, "[%s]", desc);
    } else {
      switch (i) {
        case '\a':
          strnfcat(buf, len, &end, "\a");
          break;
        case '\\': {
          if (expand_backslash)
            strnfcat(buf, len, &end, "\\\\");
          else
            strnfcat(buf, len, &end, "\\");
          break;
        }
        case '^':
          strnfcat(buf, len, &end, "\\^");
          break;
        case '[':
          strnfcat(buf, len, &end, "\\[");
          break;
        case '{':
          strnfcat(buf, len, &end, "\\{");
          break;
        default: {
          if (i < 127)
            strnfcat(buf, len, &end, "%c", (int)i);
          else
            strnfcat(buf, len, &end, "\\x%02lx", (unsigned long)i);
          break;
        }
      }
    }
    cur++;
  }
  buf[end] = '\0';
}
STATIC_OVL void
keypress_to_readable(char* buf, size_t len, struct keypress src)
{
  size_t end = 0;
  keycode_t i = src.code;
  int mods = src.mods;
  const char* desc = keycode_find_desc(i);
  if (i < 0x20 && !desc) {
    mods |= KC_MOD_CONTROL;
    i = UN_KTRL(i);
  }
  if (mods) {
    if (mods & KC_MOD_CONTROL && !(mods & ~KC_MOD_CONTROL) && i != '^') {
      strnfcat(buf, len, &end, "^");
    } else {
      if (mods & KC_MOD_CONTROL) strnfcat(buf, len, &end, "Control-");
      if (mods & KC_MOD_SHIFT) strnfcat(buf, len, &end, "Shift-");
      if (mods & KC_MOD_ALT) strnfcat(buf, len, &end, "Alt-");
      if (mods & KC_MOD_META) strnfcat(buf, len, &end, "Meta-");
      if (mods & KC_MOD_KEYPAD) strnfcat(buf, len, &end, "Keypad-");
    }
  }
  if (desc) {
    strnfcat(buf, len, &end, "%s", desc);
  } else {
    char out[5];
    if (utf32_to_utf8(out, sizeof(out), &i, 1, NULL) > 0) {
      strnfcat(buf, len, &end, "%s", out);
    } else {
      strnfcat(buf, len, &end, "Unknown");
    }
  }
  buf[end] = '\0';
}
STATIC_OVL bool
char_matches_key(wchar_t c, keycode_t key)
{
  wchar_t keychar[2];
  char k[2] = {'\0', '\0'};
  k[0] = (char)key;
  text_mbstowcs(keychar, k, 1);
  return (c == keychar[0]);
}
STATIC_OVL bool
event_is_key(ui_event e, keycode_t key)
{
  return e.type == EVT_KBRD && e.key.code == key;
}
STATIC_OVL bool
event_is_mouse(ui_event e, uint8_t button)
{
  return e.type == EVT_MOUSE && e.mouse.button == button;
}
STATIC_OVL bool
event_is_mouse_m(ui_event e, uint8_t button, uint8_t mods)
{
  return e.type == EVT_MOUSE && e.mouse.button == button &&
         (e.mouse.mods & mods);
}
STATIC_OVL void
cmd_init(void)
{
  size_t i, j;
  memset(converted_list, 0, sizeof(converted_list));
  if (nested_lists != NULL) {
    assert(n_nested >= 0);
    for (j = 0; j < (size_t)n_nested; j++) {
      mem_free(nested_lists[j]);
    }
    nested_lists = NULL;
  }
  n_nested = 0;
  for (j = 0; j < N_ELEMENTS(cmds_all) - 1; j++) {
    n_nested = MAX(n_nested, cmds_all[j].keymap);
  }
  if (n_nested > 0) {
    nested_lists = mem_zalloc(n_nested * sizeof(*nested_lists));
    for (j = 0; j < (size_t)n_nested; j++) {
      nested_lists[j] =
          mem_zalloc((UCHAR_MAX + 1) * sizeof(*(nested_lists[j])));
    }
  }
  for (j = 0; j < N_ELEMENTS(cmds_all) - 1; j++) {
    struct cmd_info* commands = cmds_all[j].list;
    if (cmds_all[j].keymap == 0) {
      for (i = 0; i < cmds_all[j].len; i++) {
        if (!commands[i].key[3]) commands[i].key[3] = commands[i].key[0];
        if (!commands[i].key[2]) commands[i].key[2] = commands[i].key[0];
        if (!commands[i].key[1]) commands[i].key[1] = commands[i].key[0];
        if (!commands[i].key[0] || !commands[i].key[1] || !commands[i].key[2] ||
            !commands[i].key[3])
          continue;
        converted_list[0][commands[i].key[0]] = &commands[i];
        converted_list[1][commands[i].key[1]] = &commands[i];
        converted_list[2][commands[i].key[2]] = &commands[i];
        converted_list[3][commands[i].key[3]] = &commands[i];
      }
    } else if (cmds_all[j].keymap > 0) {
      int kidx = cmds_all[j].keymap - 1;
      assert(kidx < n_nested);
      for (i = 0; i < cmds_all[j].len; i++) {
        commands[i].key[3] = commands[i].key[0];
        commands[i].key[2] = commands[i].key[0];
        commands[i].key[1] = commands[i].key[0];
        assert(!nested_lists[kidx][commands[i].key[0]]);
        nested_lists[kidx][commands[i].key[0]] = &commands[i];
      }
    }
  }
}
STATIC_OVL unsigned char
cmd_lookup_key(cmd_code lookup_cmd, int mode)
{
  unsigned int i;
  assert(mode >= KEYMAP_MODE_ORIG || mode < KEYMAP_MODE_MAX);
  for (i = 0; i < N_ELEMENTS(converted_list[mode]); i++) {
    struct cmd_info* cmd = converted_list[mode][i];
    if (cmd && cmd->cmd == lookup_cmd) return cmd->key[mode];
  }
  return 0;
}
STATIC_OVL unsigned char
cmd_lookup_key_unktrl(cmd_code lookup_cmd, int mode)
{
  unsigned char c = cmd_lookup_key(lookup_cmd, mode);
  if (c < 0x20) c = UN_KTRL(c);
  return c;
}
STATIC_OVL cmd_code
cmd_lookup(unsigned char key, int mode)
{
  assert(mode >= KEYMAP_MODE_ORIG || mode < KEYMAP_MODE_MAX);
  if (!converted_list[mode][key]) return CMD_NULL;
  return converted_list[mode][key]->cmd;
}
STATIC_OVL size_t
cmd_list_lookup_by_name(const char* name)
{
  size_t i = 0;
  while (1) {
    if (i >= (int)N_ELEMENTS(cmds_all)) {
      return -2;
    }
    if (streq(cmds_all[i].name, name)) {
      return i;
    }
    ++i;
  }
}
STATIC_OVL void
textui_process_command(void)
{
  int count = 0;
  bool done = true;
  ui_event e = textui_get_command(&count);
  struct cmd_info* cmd = NULL;
  unsigned char key = '\0';
  int mode =
      OPT(player, angband_keyset) ? KEYMAP_MODE_ANGBAND : KEYMAP_MODE_ORIG;
  if (OPT(player, hjkl_movement)) {
    mode |= KEYMAP_MODE_ROGUE;
  }
  switch (e.type) {
    case EVT_RESIZE:
      do_cmd_redraw();
      return;
    case EVT_MOUSE:
      textui_process_click(e);
      return;
    case EVT_BUTTON:
    case EVT_KBRD:
      done = textui_process_key(e.key, &key, count);
      break;
    default:;
  }
  if (!key && done) return;
  if (key == KC_ENTER) {
    cmd = textui_action_menu_choose();
  } else {
    cmd = converted_list[mode][key];
  }
  if (cmd && done) {
    if (cmd->cmd || cmd->hook) {
      if (!key_confirm_command(key)) cmd = NULL;
    } else {
      while (cmd && !cmd->cmd && !cmd->hook) {
        char nestkey;
        if (cmd->nested_keymap > 0 && cmd->nested_keymap <= n_nested &&
            cmd->nested_prompt) {
          if (get_com(cmd->nested_prompt, &nestkey)) {
            const char* em = cmd->nested_error;
            cmd = nested_lists[cmd->nested_keymap - 1][(unsigned char)nestkey];
            if (!cmd) {
              msg("%s", em ? em : "That is not a valid nested command.");
            }
          } else {
            cmd = NULL;
          }
        } else {
          cmd = NULL;
        }
      }
    }
    if (cmd && cmd->prereq && !cmd->prereq()) cmd = NULL;
    if (cmd && cmd->hook)
      cmd->hook();
    else if (cmd && cmd->cmd)
      cmdq_push_repeat(cmd->cmd, count);
  } else
    do_cmd_unknown();
}
STATIC_OVL errr
textui_get_cmd(cmd_context context)
{
  if (context == CTX_GAME) textui_process_command();
  return 1;
}
STATIC_OVL void
check_for_player_interrupt(game_event_type type, game_event_data* data,
                           void* user)
{
  if (player->upkeep->running || cmd_get_nrepeats() > 0 ||
      (player_is_resting(player) && !(turn & 0x7F))) {
    ui_event e;
    inkey_scan = SCAN_INSTANT;
    e = inkey_ex();
    if (e.type != EVT_NONE) {
      event_signal(EVENT_INPUT_FLUSH);
      disturb(player, false);
      msg("Cancelled.");
    }
  }
}
STATIC_OVL void
pre_turn_refresh(void)
{
  term* old = Term;
  int j;
  if (character_dungeon) {
    player->upkeep->redraw |= (PR_MAP | PR_STATE);
    player->upkeep->redraw |= (PR_MONLIST | PR_ITEMLIST);
    handle_stuff(player);
    move_cursor_relative(player->grid.y, player->grid.x);
    for (j = 0; j < ANGBAND_TERM_MAX; j++) {
      if (!angband_term[j]) continue;
      Term_activate(angband_term[j]);
      Term_fresh();
    }
  }
  Term_activate(old);
}
STATIC_OVL bool
start_game(bool new_game)
{
  const char* loadpath = savefile;
  bool exists;
  player->is_dead = true;
  savefile_get_panic_name(panicfile, sizeof(panicfile), loadpath);
  safe_setuid_grab();
  exists = loadpath[0] && file_exists(panicfile);
  safe_setuid_drop();
  if (exists) {
    bool newer;
    safe_setuid_grab();
    newer = file_newer(panicfile, loadpath);
    safe_setuid_drop();
    if (newer) {
      if (get_check("A panic save exists.  Use it? ")) {
        loadpath = panicfile;
      }
    } else {
      safe_setuid_grab();
      file_delete(panicfile);
      safe_setuid_drop();
    }
  }
  safe_setuid_grab();
  exists = file_exists(loadpath);
  safe_setuid_drop();
  if (exists && !savefile_load(loadpath, arg_wizard)) {
    return false;
  }
  if (player->is_dead || new_game) {
    character_generated = false;
    textui_do_birth();
  }
  event_signal(EVENT_LEAVE_INIT);
  event_signal(EVENT_ENTER_GAME);
  event_signal(EVENT_ENTER_WORLD);
  player->upkeep->autosave = false;
  if (!character_dungeon) {
    prepare_next_level(player);
  }
  on_new_level();
  return true;
}
STATIC_OVL void
cleanup_savefile_selection_strings(char** entries, int count)
{
  int i;
  for (i = 0; i < count; ++i) {
    string_free(entries[i]);
  }
  mem_free(entries);
}
STATIC_OVL enum game_mode_type
select_savefile(bool retry)
{
  savefile_getter g = NULL;
  int count = 2, allocated = 16;
  char** entries = mem_zalloc(allocated * sizeof(*entries));
  char** names = mem_zalloc(allocated * sizeof(*names));
  int default_entry = 0;
  struct region m_region = {0, 3, 0, 0};
  int new_game_ind = 0, tutorial_ind = 1;
  enum game_mode_type result = GAME_LOAD;
  bool failed;
  struct menu* m;
  ui_event selection;
  while (got_savefile(&g)) {
    const struct savefile_details* details = get_savefile_details(g);
    assert(details);
    if (count == allocated) {
      allocated *= 2;
      entries = mem_realloc(entries, allocated * sizeof(*entries));
      names = mem_realloc(names, allocated * sizeof(*names));
    }
    if (details->desc) {
      entries[count] = string_make(
          format("Use %s: %s", details->fnam + details->foff, details->desc));
    } else {
      entries[count] =
          string_make(format("Use %s", details->fnam + details->foff));
    }
    names[count] = string_make(details->fnam);
    if (suffix(savefile, details->fnam)) {
      if (count != 2) {
        char* hold_entry = entries[count];
        char* hold_name = names[count];
        int i;
        for (i = count; i > 2; --i) {
          entries[i] = entries[i - 1];
          names[i] = names[i - 1];
        }
        entries[2] = hold_entry;
        names[2] = hold_name;
      }
      default_entry = 2;
      if (!arg_force_name) {
        savefile[0] = '\0';
        arg_name[0] = '\0';
      }
    }
    ++count;
  }
  if (got_savefile_dir(g)) {
    assert(allocated > 1 && !entries[0] && !names[0] && !entries[1] &&
           !names[1]);
    if (default_entry && arg_force_name) {
      int i;
      for (i = 1; i < count - 1; ++i) {
        entries[i] = entries[i + 1];
        names[i] = names[i + 1];
      }
      --default_entry;
      --count;
      new_game_ind = -1;
      tutorial_ind = 0;
    } else {
      entries[new_game_ind] = string_make("New game");
    }
    entries[tutorial_ind] = string_make("Tutorial");
    failed = false;
  } else {
    failed = true;
  }
  cleanup_savefile_getter(g);
  if (failed) {
    cleanup_savefile_selection_strings(names, count);
    cleanup_savefile_selection_strings(entries, count);
    quit("Cannot open the savefile directory");
  }
  m = menu_new(MN_SKIN_SCROLL, menu_find_iter(MN_ITER_STRINGS));
  menu_setpriv(m, count, entries);
  menu_layout(m, &m_region);
  m->cursor = default_entry;
  m->flags |= MN_DBL_TAP;
  screen_save();
  prt("Select the save to use (movement keys and enter or mouse) or quit", 0,
      0);
  prt("(escape or second mouse button).", 1, 0);
  prt((retry) ? "The previously selected savefile was unusable." : "", 2, 0);
  selection = menu_select(m, 0, false);
  screen_load();
  if (selection.type == EVT_SELECT) {
    if (m->cursor == new_game_ind) {
      result = GAME_NEW;
    } else if (m->cursor == tutorial_ind) {
      result = GAME_TUTORIAL;
    } else {
      assert(m->cursor > 0 && m->cursor < count && names[m->cursor]);
      path_build(savefile, sizeof(savefile), ANGBAND_DIR_SAVE,
                 names[m->cursor]);
    }
  }
  menu_free(m);
  cleanup_savefile_selection_strings(names, count);
  cleanup_savefile_selection_strings(entries, count);
  if (selection.type == EVT_ESCAPE) {
    quit(NULL);
  }
  return result;
}
STATIC_OVL void
play_game(enum game_mode_type mode)
{
  while (1) {
    play_again = false;
    switch (mode) {
      case GAME_LOAD:
      case GAME_NEW:
        if (!start_game(mode == GAME_NEW)) {
          quit("Broken savefile");
        }
        break;
      case GAME_SELECT: {
        bool retry = false;
        while (1) {
          mode = select_savefile(retry);
          if (mode == GAME_LOAD || mode == GAME_NEW) {
            if (start_game(mode == GAME_NEW)) {
              break;
            }
            retry = true;
          } else {
            assert(mode == GAME_TUTORIAL);
            play_again = true;
            start_tutorial();
            break;
          }
        }
      } break;
      case GAME_TUTORIAL:
        play_again = true;
        start_tutorial();
        break;
      default:
        quit("Invalid game mode in play_game()");
        break;
    }
    while (!player->is_dead && player->upkeep->playing) {
      pre_turn_refresh();
      cmd_get_hook(CTX_GAME);
      run_game_loop();
    }
    close_game(true);
    if (!play_again) break;
    cleanup_angband();
    init_display();
    init_angband();
    if (reinit_hook != NULL) {
      (*reinit_hook)();
    }
    textui_init();
    mode = GAME_SELECT;
  }
}
STATIC_OVL void
savefile_set_name(const char* fname, bool make_safe, bool strip_suffix)
{
  char path[128];
  size_t pathlen = sizeof path;
  size_t off = 0;
  if (make_safe) {
    player_safe_name(path + off, pathlen, fname, strip_suffix);
  } else {
    my_strcpy(path + off, fname, pathlen);
  }
  path_build(savefile, sizeof(savefile), ANGBAND_DIR_SAVE, path);
}
STATIC_OVL bool
savefile_name_already_used(const char* fname, bool make_safe, bool strip_suffix)
{
  char* hold = string_make(savefile);
  bool result;
  savefile_set_name(fname, make_safe, strip_suffix);
  result = file_exists(savefile);
  my_strcpy(savefile, hold, sizeof(savefile));
  string_free(hold);
  return result;
}
STATIC_OVL void
save_game(void)
{
  (void)save_game_checked();
}
STATIC_OVL bool
save_game_checked(void)
{
  char path[1024];
  bool result;
  disturb(player, true);
  event_signal(EVENT_MESSAGE_FLUSH);
  handle_stuff(player);
  prt("Saving game...", 0, 0);
  Term_fresh();
  my_strcpy(player->died_from, "(saved)", sizeof(player->died_from));
  signals_ignore_tstp();
  if (savefile_save(savefile)) {
    prt("Saving game... done.", 0, 0);
    result = true;
  } else {
    prt("Saving game... failed!", 0, 0);
    result = false;
  }
  Term_fresh();
  signals_handle_tstp();
  path_build(path, sizeof(path), ANGBAND_DIR_USER, "window.prf");
  if (!prefs_save(path, option_dump, "Dump window settings"))
    prt("Failed to save subwindow preferences", 0, 0);
  Term_fresh();
  if (!lore_save("lore.txt")) {
    msg("lore save failed!");
    event_signal(EVENT_MESSAGE_FLUSH);
  }
  Term_fresh();
  my_strcpy(player->died_from, "(alive and well)", sizeof(player->died_from));
  return result;
}
STATIC_OVL void
close_game(bool prompt_failed_save)
{
  bool prompting = true;
  event_signal(EVENT_LEAVE_WORLD);
  handle_stuff(player);
  event_signal(EVENT_MESSAGE_FLUSH);
  event_signal(EVENT_INPUT_FLUSH);
  signals_ignore_tstp();
  screen_save_depth++;
  if (player->self_made_arts > 0) {
    write_self_made_artefacts();
    deactivate_randart_file();
  }
  if (!in_tutorial()) {
    if (player->is_dead) {
      death_knowledge(player);
      death_screen();
      while (prompting && !savefile_save(savefile)) {
        if (!prompt_failed_save || !get_check("Saving failed.  Try again? ")) {
          prompting = false;
          msg("death save failed!");
          event_signal(EVENT_MESSAGE_FLUSH);
        }
      }
    } else {
      while (prompting && !save_game_checked()) {
        if (!prompt_failed_save || !get_check("Saving failed.  Try again? ")) {
          prompting = false;
        }
      }
      if (Term->mapped_flag) {
        struct keypress ch;
        prt("Press Return (or Escape).", 0, 40);
        ch = inkey();
        if (ch.code != ESCAPE) predict_score(false);
      }
    }
  } else if (player->is_dead) {
    tutorial_display_death_note(player);
  }
  wipe_mon_list(cave, player);
  screen_save_depth--;
  event_signal(EVENT_LEAVE_GAME);
  signals_handle_tstp();
}
STATIC_OVL bool
got_savefile(savefile_getter* pg)
{
  char fname[256];
  if (*pg == NULL) {
    *pg = mem_zalloc(sizeof(**pg));
    safe_setuid_grab();
    (*pg)->d = my_dopen(ANGBAND_DIR_SAVE);
    safe_setuid_drop();
    if (!(*pg)->d) {
      return false;
    }
    (*pg)->have_savedir = true;
    (*pg)->details.foff = 0;
  } else {
    if (!(*pg)->d) {
      assert(!(*pg)->have_details);
      return false;
    }
  }
  while (1) {
    char path[1024];
    const char* desc;
    bool no_entry;
    safe_setuid_grab();
    no_entry = !my_dread((*pg)->d, fname, sizeof(fname));
    safe_setuid_drop();
    if (no_entry) {
      break;
    }
    path_build(path, sizeof(path), ANGBAND_DIR_SAVE, fname);
    desc = savefile_get_description(path);
    string_free((*pg)->details.fnam);
    (*pg)->details.fnam = string_make(fname);
    string_free((*pg)->details.desc);
    (*pg)->details.desc = string_make(desc);
    (*pg)->have_details = true;
    return true;
  }
  my_dclose((*pg)->d);
  (*pg)->d = NULL;
  (*pg)->have_details = false;
  return false;
}
STATIC_OVL bool
got_savefile_dir(const savefile_getter g)
{
  return g && g->have_savedir;
}
STATIC_OVL const struct savefile_details*
get_savefile_details(const savefile_getter g)
{
  return (g && g->have_details) ? &g->details : NULL;
}
STATIC_OVL void
cleanup_savefile_getter(savefile_getter g)
{
  if (g) {
    string_free(g->details.desc);
    string_free(g->details.fnam);
    if (g->d) {
      my_dclose(g->d);
    }
    mem_free(g);
  }
}
STATIC_OVL void
string_lower(char* buf)
{
  char* s;
  for (s = buf; *s != 0; s++) *s = tolower((unsigned char)*s);
}
STATIC_OVL bool
show_file(const char* name, const char* what, int line, int mode)
{
  int i, k, n;
  struct keypress ch = KEYPRESS_NULL;
  int next = 0;
  int size;
  int back = 0;
  bool menu = false;
  bool case_sensitive = false;
  ang_file* fff = NULL;
  char* find = NULL;
  const char* tag = NULL;
  char finder[80] = "";
  char shower[80] = "";
  char filename[1024];
  char caption[128] = "";
  char path[1024];
  char buf[1024];
  char lc_buf[1024];
  char hook[26][32];
  int wid, hgt;
  bool skip_lines = false;
  for (i = 0; i < 26; i++) hook[i][0] = '\0';
  Term_get_size(&wid, &hgt);
  my_strcpy(filename, name, sizeof(filename));
  n = strlen(filename);
  for (i = 0; i < n; i++) {
    if (filename[i] == '#') {
      filename[i] = '\0';
      tag = filename + i + 1;
      break;
    }
  }
  name = filename;
  if (what) {
    my_strcpy(caption, what, sizeof(caption));
    my_strcpy(path, name, sizeof(path));
    fff = file_open(path, MODE_READ, FTYPE_TEXT);
  }
  if (!fff) {
    strnfmt(caption, sizeof(caption), "Help file '%s'", name);
    path_build(path, sizeof(path), ANGBAND_DIR_HELP, name);
    fff = file_open(path, MODE_READ, FTYPE_TEXT);
  }
  if (!fff) {
    msg("Cannot open '%s'.", name);
    event_signal(EVENT_MESSAGE_FLUSH);
    return (true);
  }
  while (true) {
    if (!file_getl(fff, buf, sizeof(buf))) break;
    if (skip_lines) {
      if (contains_only_spaces(buf)) skip_lines = false;
      continue;
    }
    if (prefix(buf, ".. ")) {
      if (prefix(buf + strlen(".. "), "menu:: [") &&
          buf[strlen(".. menu:: [x")] == ']') {
        menu = true;
        k = A2I(buf[strlen(".. menu:: [")]);
        if ((k >= 0) && (k < 26))
          my_strcpy(hook[k], buf + strlen(".. menu:: [x] "), sizeof(hook[0]));
      } else if (buf[strlen(".. ")] == '_') {
        if (tag) {
          buf[strlen(buf) - 1] = '\0';
          if (streq(buf + strlen(".. _"), tag)) {
            line = next;
          }
        }
      }
      skip_lines = true;
      continue;
    }
    next++;
  }
  size = next;
  while (true) {
    Term_clear();
    if (line > (size - (hgt - 4))) line = size - (hgt - 4);
    if (line < 0) line = 0;
    skip_lines = false;
    if (next > line) {
      file_close(fff);
      fff = file_open(path, MODE_READ, FTYPE_TEXT);
      if (!fff) return (true);
      next = 0;
    }
    while (next < line) {
      if (!file_getl(fff, buf, sizeof(buf))) break;
      if (skip_lines) {
        if (contains_only_spaces(buf)) skip_lines = false;
        continue;
      }
      if (prefix(buf, ".. ")) {
        skip_lines = true;
        continue;
      }
      next++;
    }
    for (i = 0; i < hgt - 4;) {
      if (!i) line = next;
      if (!file_getl(fff, buf, sizeof(buf))) break;
      if (skip_lines) {
        if (contains_only_spaces(buf)) skip_lines = false;
        continue;
      }
      if (prefix(buf, ".. ")) {
        skip_lines = true;
        continue;
      }
      next++;
      my_strcpy(lc_buf, buf, sizeof(lc_buf));
      if (!case_sensitive) string_lower(lc_buf);
      if (find && !i && !strstr(lc_buf, find)) continue;
      find = NULL;
      Term_putstr(0, i + 2, -1, COLOUR_WHITE, buf);
      if (strlen(shower)) {
        const char* str = lc_buf;
        while ((str = strstr(str, shower)) != NULL) {
          int len = strlen(shower);
          Term_putstr(str - lc_buf, i + 2, len, COLOUR_YELLOW,
                      &buf[str - lc_buf]);
          str += len;
        }
      }
      i++;
    }
    if (find) {
      bell();
      line = back;
      find = NULL;
      continue;
    }
    prt(format("[%s, %s, Line %d-%d/%d]", buildid, caption, line,
               line + hgt - 4, size),
        0, 0);
    if (menu) {
      prt("[Press a Letter, or ESC to exit.]", hgt - 1, 0);
    } else if (size <= hgt - 4) {
      prt("[Press ESC to exit.]", hgt - 1, 0);
    } else {
      prt("[Press Space to advance, or ESC to exit.]", hgt - 1, 0);
    }
    ch = inkey();
    if (ch.code == '?') break;
    if (ch.code == '!') case_sensitive = !case_sensitive;
    if (ch.code == '&') {
      prt("Show: ", hgt - 1, 0);
      (void)askfor_aux(shower, sizeof(shower), NULL);
      if (!case_sensitive) string_lower(shower);
    }
    if (ch.code == '/') {
      prt("Find: ", hgt - 1, 0);
      if (askfor_aux(finder, sizeof(finder), NULL)) {
        find = finder;
        back = line;
        line = line + 1;
        if (!case_sensitive) string_lower(finder);
        my_strcpy(shower, finder, sizeof(shower));
      }
    }
    if (ch.code == '#') {
      char tmp[80] = "0";
      prt("Goto Line: ", hgt - 1, 0);
      if (askfor_aux(tmp, sizeof(tmp), NULL)) line = atoi(tmp);
    }
    if (ch.code == '%') {
      char ftmp[80];
      if (OPT(player, angband_keyset)) {
        my_strcpy(ftmp, "a_index.txt", sizeof(ftmp));
      } else {
        my_strcpy(ftmp, "index.txt", sizeof(ftmp));
      }
      prt("Goto File: ", hgt - 1, 0);
      if (askfor_aux(ftmp, sizeof(ftmp), NULL)) {
        if (!show_file(ftmp, NULL, 0, mode)) ch.code = ESCAPE;
      }
    }
    switch (ch.code) {
      case ARROW_UP:
      case 'k':
      case '8':
        line--;
        break;
      case KC_PGUP:
      case '9':
      case '-':
        line -= (hgt - 4);
        break;
      case KC_HOME:
      case '7':
        line = 0;
        break;
      case ARROW_DOWN:
      case '2':
      case 'j':
      case KC_ENTER:
        line++;
        break;
      case KC_PGDOWN:
      case '3':
      case ' ':
        line += hgt - 4;
        break;
      case KC_END:
      case '1':
        line = size;
        break;
    }
    if (menu && isalpha((unsigned char)ch.code)) {
      k = A2I(ch.code);
      if ((k >= 0) && (k <= 25) && hook[k][0]) {
        if (!show_file(hook[k], NULL, 0, mode)) ch.code = ESCAPE;
      }
    }
    if (ch.code == ESCAPE) break;
  }
  file_close(fff);
  return (ch.code != '?');
}
STATIC_OVL void
do_cmd_help(void)
{
  screen_save();
  (void)show_file((OPT(player, angband_keyset)) ? "a_index.txt" : "index.txt",
                  NULL, 0, 0);
  screen_load();
}
STATIC_OVL void
print_history_header(void)
{
  c_put_str(COLOUR_WHITE, "[Player history]", 0, 0);
  c_put_str(COLOUR_L_BLUE, "      Turn   Depth  Note", 1, 0);
}
STATIC_OVL void
history_display(void)
{
  struct history_info* history_list_local = NULL;
  size_t max_item = history_get_list(player, &history_list_local);
  int row, wid, hgt, page_size;
  char buf[120];
  static size_t first_item = 0;
  size_t i;
  bool active = true;
  Term_get_size(&wid, &hgt);
  page_size = hgt - 5;
  screen_save();
  while (active) {
    struct keypress ch;
    Term_clear();
    print_history_header();
    row = 0;
    for (i = first_item; row <= page_size && i < max_item; i++) {
      strnfmt(buf, sizeof(buf), "%10ld%7d\'  %s",
              (long)history_list_local[i].turn, history_list_local[i].dlev * 50,
              history_list_local[i].event);
      if (hist_has(history_list_local[i].type, HIST_ARTIFACT_LOST))
        my_strcat(buf, " (LOST)", sizeof(buf));
      prt(buf, row + 2, 0);
      row++;
    }
    prt("[Arrow keys scroll, p/PgUp for previous page, n/PgDn for next page, "
        "ESC to exit.]",
        hgt - 1, 0);
    ch = inkey();
    switch (ch.code) {
      case 'n':
      case ' ':
      case KC_PGDOWN: {
        size_t scroll_to = first_item + page_size;
        first_item = (scroll_to < max_item ? scroll_to : max_item);
        break;
      }
      case 'p':
      case KC_PGUP: {
        int scroll_to = first_item - page_size;
        first_item = (scroll_to >= 0 ? scroll_to : 0);
        break;
      }
      case 'j':
      case ARROW_DOWN: {
        size_t scroll_to = first_item + 1;
        first_item = (scroll_to < max_item ? scroll_to : max_item);
        break;
      }
      case 'k':
      case ARROW_UP: {
        int scroll_to = first_item - 1;
        first_item = (scroll_to >= 0 ? scroll_to : 0);
        break;
      }
      case ESCAPE:
        active = false;
        break;
    }
  }
  screen_load();
  return;
}
STATIC_OVL void
dump_history(ang_file* file)
{
  struct history_info* history_list_local = NULL;
  size_t max_item = history_get_list(player, &history_list_local);
  size_t i;
  char buf[120];
  file_putf(file, "[Player history]\n");
  file_putf(file, "      Turn   Depth  Note\n");
  for (i = 0; i < max_item; i++) {
    strnfmt(buf, sizeof(buf), "%10ld%7d\'  %s",
            (long)history_list_local[i].turn, history_list_local[i].dlev * 50,
            history_list_local[i].event);
    if (hist_has(history_list_local[i].type, HIST_ARTIFACT_LOST))
      my_strcat(buf, " (LOST)", sizeof(buf));
    file_putf(file, "%s", buf);
    file_put(file, "\n");
  }
  return;
}
STATIC_OVL void
textui_init(void)
{
  uint32_t default_window_flag[ANGBAND_TERM_MAX];
  event_signal_message(EVENT_INITSTATUS, 0, "Loading basic pref file...");
  (void)process_pref_file("pref.prf", false, false);
  if (!play_again) {
    cmd_init();
    textui_knowledge_init();
    textui_input_init();
    textui_prefs_init();
    screen_save_depth++;
    if (!term_screen) quit("Main window does not exist");
    Term_activate(term_screen);
    if ((Term->hgt < 24) || (Term->wid < 80))
      plog("Main window is too small - please make it bigger.");
    (void)Term_set_cursor(false);
    (void)Term_xtra(TERM_XTRA_REACT, 0);
    (void)Term_redraw_all();
  } else {
    textui_knowledge_cleanup();
    textui_knowledge_init();
  }
  memset(window_flag, 0, sizeof(uint32_t) * ANGBAND_TERM_MAX);
  memset(default_window_flag, 0, sizeof default_window_flag);
  if (ANGBAND_TERM_MAX > 1) default_window_flag[1] = (PW_INVEN);
  if (ANGBAND_TERM_MAX > 2) default_window_flag[2] = (PW_EQUIP);
  if (ANGBAND_TERM_MAX > 3) default_window_flag[3] = (PW_COMBAT_ROLLS);
  if (ANGBAND_TERM_MAX > 4) default_window_flag[4] = (PW_MONSTER);
  if (ANGBAND_TERM_MAX > 5) default_window_flag[5] = (PW_PLAYER_0);
  if (ANGBAND_TERM_MAX > 6) default_window_flag[6] = (PW_MESSAGE);
  if (ANGBAND_TERM_MAX > 7) default_window_flag[7] = (PW_MONLIST);
  subwindows_set_flags(default_window_flag, ANGBAND_TERM_MAX);
  event_signal_message(EVENT_INITSTATUS, 0, "Initialization complete");
}
STATIC_OVL void
textui_cleanup(void)
{
  cleanup_options();
  keymap_free();
  textui_prefs_free();
  textui_knowledge_cleanup();
}
STATIC_OVL void
flush(game_event_type unused, game_event_data* data, void* user)
{
  inkey_xtra = true;
}
STATIC_OVL ui_event
inkey_aux(int scan_cutoff)
{
  int w = 0;
  ui_event ke;
  if (scan_cutoff == SCAN_OFF) {
    (void)(Term_inkey(&ke, true, true));
  } else {
    w = 0;
    while (Term_inkey(&ke, false, true) != 0) {
      w++;
      if (w >= scan_cutoff) {
        ui_event empty = EVENT_EMPTY;
        return empty;
      }
      Term_xtra(TERM_XTRA_DELAY, 10);
    }
  }
  return (ke);
}
STATIC_OVL ui_event
inkey_ex(void)
{
  bool cursor_state;
  ui_event kk;
  ui_event ke = EVENT_EMPTY;
  bool done = false;
  term* old = Term;
  if (inkey_xtra) {
    Term_flush();
    inkey_next = NULL;
    inkey_xtra = false;
  }
  while (inkey_next && inkey_next->code) {
    ke.key = *inkey_next++;
    inkey_flag = false;
    inkey_scan = 0;
    if (ke.key.code == '(') {
      keymap_auto_more = true;
      if (!inkey_next || !inkey_next->code) {
        ke.type = EVT_NONE;
        break;
      }
      continue;
    } else if (ke.key.code == ')') {
      keymap_auto_more = false;
      if (!inkey_next || !inkey_next->code) {
        ke.type = EVT_NONE;
        break;
      }
      continue;
    }
    return (ke);
  }
  keymap_auto_more = false;
  inkey_next = NULL;
  (void)Term_get_cursor(&cursor_state);
  if (!inkey_scan && (!inkey_flag || screen_save_depth))
    (void)Term_set_cursor(true);
  Term_activate(term_screen);
  while (ke.type == EVT_NONE) {
    if (inkey_scan == SCAN_INSTANT && (0 != Term_inkey(&kk, false, false)))
      break;
    if (!done && (0 != Term_inkey(&kk, false, false))) {
      Term_activate(old);
      Term_fresh();
      Term_activate(term_screen);
      character_saved = false;
      signal_count = 0;
      done = true;
    }
    ke = inkey_aux(inkey_scan);
    if (inkey_scan && ke.type == EVT_NONE) break;
    if (ke.key.code == '`') ke.key.code = ESCAPE;
  }
  Term_activate(old);
  Term_set_cursor(cursor_state);
  inkey_flag = false;
  inkey_scan = 0;
  return (ke);
}
STATIC_OVL void
anykey(void)
{
  ui_event ke = EVENT_EMPTY;
  while (ke.type != EVT_MOUSE && ke.type != EVT_KBRD) ke = inkey_ex();
}
STATIC_OVL struct keypress
inkey(void)
{
  ui_event ke = EVENT_EMPTY;
  while (ke.type != EVT_ESCAPE && ke.type != EVT_KBRD && ke.type != EVT_MOUSE &&
         ke.type != EVT_BUTTON)
    ke = inkey_ex();
  if (ke.type == EVT_ESCAPE) {
    ke.type = EVT_KBRD;
    ke.key.code = ESCAPE;
    ke.key.mods = 0;
  } else if (ke.type == EVT_MOUSE) {
    if (ke.mouse.button == 1) {
      ke.type = EVT_KBRD;
      ke.key.code = '\n';
      ke.key.mods = 0;
    } else {
      ke.type = EVT_KBRD;
      ke.key.code = ESCAPE;
      ke.key.mods = 0;
    }
  } else if (ke.type == EVT_BUTTON) {
    ke.type = EVT_KBRD;
  }
  return ke.key;
}
STATIC_OVL ui_event
inkey_m(void)
{
  ui_event ke = EVENT_EMPTY;
  while (ke.type != EVT_ESCAPE && ke.type != EVT_KBRD && ke.type != EVT_MOUSE &&
         ke.type != EVT_BUTTON)
    ke = inkey_ex();
  if (ke.type == EVT_ESCAPE) {
    ke.type = EVT_KBRD;
    ke.key.code = ESCAPE;
    ke.key.mods = 0;
  } else if (ke.type == EVT_BUTTON) {
    ke.type = EVT_KBRD;
  }
  return ke;
}
STATIC_OVL void
msg_flush(int x)
{
  uint8_t a = COLOUR_L_BLUE;
  Term_putstr(x, 0, -1, a, "-more-");
  if ((!OPT(player, auto_more)) && !keymap_auto_more) anykey();
  Term_erase(0, 0, 255);
}
STATIC_OVL void
msg_flush_split_existing(int w, int* x)
{
  int split = MIN(*x, w - 8);
  int i = split;
  wchar_t* svc = NULL;
  int* sva = NULL;
  while (i > w / 2) {
    int a;
    wchar_t c;
    --i;
    Term_what(i, 0, &a, &c);
    if (c == L' ') {
      split = i;
      break;
    }
  }
  *x -= split;
  if (*x > 0) {
    svc = mem_alloc(*x * sizeof(*svc));
    sva = mem_alloc(*x * sizeof(*sva));
    for (i = 0; i < *x; ++i) {
      Term_what(i + split, 0, &sva[i], &svc[i]);
    }
  }
  Term_erase(split, 0, w);
  msg_flush(split + 1);
  if (*x > 0) {
    for (i = 0; i < *x; ++i) {
      Term_putch(i, 0, sva[i], svc[i]);
    }
    mem_free(sva);
    mem_free(svc);
  }
}
STATIC_OVL void
display_message(game_event_type unused, game_event_data* data, void* user)
{
  int n;
  char* t;
  char buf[1024];
  uint8_t color;
  int w, h;
  int type;
  const char* msg;
  if (!data) return;
  type = data->message.type;
  msg = data->message.msg;
  if (Term && type == MSG_BELL) {
    Term_xtra(TERM_XTRA_NOISE, 0);
    return;
  }
  if (!msg || !Term || !character_generated) return;
  (void)Term_get_size(&w, &h);
  if (!msg_flag) message_column = 0;
  n = (msg ? strlen(msg) : 0);
  if (message_column && (!msg || ((message_column + n) > (w - 8)))) {
    if (message_column <= w - 8) {
      msg_flush(message_column);
      message_column = 0;
    } else {
      msg_flush_split_existing(w, &message_column);
    }
    msg_flag = false;
  }
  if (!msg) return;
  if (n > 1000) return;
  my_strcpy(buf, msg, sizeof(buf));
  t = buf;
  color = message_type_color(type);
  while (message_column + n > w - 1) {
    int split = MAX(w - 8 - message_column, 0);
    int check = split;
    char oops;
    while (check > MAX(w / 2 - message_column, 0)) {
      --check;
      if (t[check] == ' ') {
        split = check;
        break;
      }
    }
    oops = t[split];
    t[split] = '\0';
    Term_putstr(message_column, 0, split, color, t);
    msg_flush(message_column + split + 1);
    t[split] = oops;
    t[--split] = ' ';
    t += split;
    n -= split;
    message_column = 0;
  }
  Term_putstr(message_column, 0, n, color, t);
  msg_flag = true;
  message_column += n + 1;
}
STATIC_OVL void
bell_message(game_event_type unused, game_event_data* data, void* user)
{
  Term_fresh();
  display_message(unused, data, user);
  player->upkeep->redraw |= PR_MESSAGE;
}
STATIC_OVL void
message_flush(game_event_type unused, game_event_data* data, void* user)
{
  if (!msg_flag) message_column = 0;
  if (message_column) {
    if (Term) {
      int w, h;
      (void)Term_get_size(&w, &h);
      while (message_column > w - 8) {
        msg_flush_split_existing(w, &message_column);
      }
      if (message_column) {
        msg_flush(message_column);
      }
    }
    msg_flag = false;
    message_column = 0;
  }
}
STATIC_OVL void
clear_from(int row)
{
  int y;
  for (y = row; y < Term->hgt; y++) Term_erase(0, y, 255);
}
STATIC_OVL bool
askfor_aux_keypress(char* buf, size_t buflen, size_t* curs, size_t* len,
                    struct keypress keypress, bool firsttime)
{
  size_t ulen = utf8_strlen(buf);
  switch (keypress.code) {
    case ESCAPE: {
      *curs = 0;
      return true;
    }
    case KC_ENTER: {
      *curs = ulen;
      return true;
    }
    case ARROW_LEFT: {
      if (firsttime) {
        *curs = 0;
      } else if (*curs > 0) {
        (*curs)--;
      }
      break;
    }
    case ARROW_RIGHT: {
      if (firsttime) {
        *curs = ulen;
      } else if (*curs < ulen) {
        (*curs)++;
      }
      break;
    }
    case KC_BACKSPACE:
    case KC_DELETE: {
      char *ocurs, *oshift;
      if (firsttime) {
        buf[0] = '\0';
        *curs = 0;
        *len = 0;
        break;
      }
      if ((keypress.code == KC_BACKSPACE && *curs == 0) ||
          (keypress.code == KC_DELETE && *curs >= ulen))
        break;
      ocurs = utf8_fskip(buf, *curs, NULL);
      assert(ocurs);
      if (keypress.code == KC_BACKSPACE) {
        oshift = utf8_rskip(ocurs, 1, buf);
        assert(oshift);
        memmove(oshift, ocurs, *len - (ocurs - buf));
        (*curs)--;
        *len -= ocurs - oshift;
      } else {
        oshift = utf8_fskip(buf + *curs, 1, NULL);
        assert(oshift);
        memmove(ocurs, oshift, *len - (oshift - buf));
        *len -= oshift - ocurs;
      }
      buf[*len] = '\0';
      break;
    }
    default: {
      bool atnull = (*curs == ulen);
      char encoded[5];
      size_t n_enc = 0;
      char* ocurs;
      if (keycode_isprint(keypress.code)) {
        n_enc = utf32_to_utf8(encoded, N_ELEMENTS(encoded), &keypress.code, 1,
                              NULL);
      }
      if (n_enc == 0) {
        bell();
        break;
      }
      if (firsttime) {
        buf[0] = '\0';
        *curs = 0;
        *len = 0;
        atnull = 1;
      }
      if (*len + n_enc >= buflen) {
        break;
      }
      if (atnull) {
        ocurs = buf + *len;
      } else {
        ocurs = utf8_fskip(buf, *curs, NULL);
        assert(ocurs);
        memmove(ocurs + n_enc, ocurs, *len - (ocurs - buf));
      }
      memcpy(ocurs, encoded, n_enc);
      (*curs)++;
      *len += n_enc;
      buf[*len] = '\0';
      break;
    }
  }
  return false;
}
STATIC_OVL int
askfor_aux_mouse(char* buf, size_t buflen, size_t* curs, size_t* len,
                 struct mouseclick mouse, bool firsttime)
{
  return (mouse.button == 2) ? 2 : 1;
}
STATIC_OVL bool
askfor_aux(char* buf, size_t len,
           bool (*keypress_h)(char*, size_t, size_t*, size_t*, struct keypress,
                              bool))
{
  int y, x;
  size_t k = 0;
  size_t nul = 0;
  struct keypress ch = KEYPRESS_NULL;
  bool done = false;
  bool firsttime = true;
  if (keypress_h == NULL) keypress_h = askfor_aux_keypress;
  Term_locate(&x, &y);
  if ((x < 0) || (x >= 80)) x = 0;
  if (x + len > 80) len = 80 - x;
  buf[len - 1] = '\0';
  nul = strlen(buf);
  Term_erase(x, y, (int)len);
  Term_putstr(x, y, -1, COLOUR_YELLOW, buf);
  while (!done) {
    Term_gotoxy(x + k, y);
    ch = inkey();
    done = keypress_h(buf, len, &k, &nul, ch, firsttime);
    Term_erase(x, y, (int)len);
    Term_putstr(x, y, -1, COLOUR_WHITE, buf);
    firsttime = false;
  }
  return (ch.code != ESCAPE);
}
STATIC_OVL bool
askfor_aux_ext(char* buf, size_t len,
               bool (*keypress_h)(char*, size_t, size_t*, size_t*,
                                  struct keypress, bool),
               int (*mouse_h)(char*, size_t, size_t*, size_t*,
                              struct mouseclick, bool))
{
  size_t k = 0;
  size_t nul = 0;
  bool firsttime = true;
  bool done = false;
  bool accepted = true;
  int y, x;
  if (keypress_h == NULL) {
    keypress_h = askfor_aux_keypress;
  }
  if (mouse_h == NULL) {
    mouse_h = askfor_aux_mouse;
  }
  Term_locate(&x, &y);
  if (x < 0 || x >= 80) x = 0;
  if (x + len > 80) len = 80 - x;
  buf[len - 1] = '\0';
  nul = strlen(buf);
  Term_erase(x, y, (int)len);
  Term_putstr(x, y, -1, COLOUR_YELLOW, buf);
  while (!done) {
    ui_event in;
    Term_gotoxy(x + k, y);
    while (1) {
      in = inkey_ex();
      if (in.type == EVT_KBRD || in.type == EVT_MOUSE) {
        break;
      }
      if (in.type == EVT_BUTTON) {
        in.type = EVT_KBRD;
        break;
      }
      if (in.type == EVT_ESCAPE) {
        in.type = EVT_KBRD;
        in.key.code = ESCAPE;
        in.key.mods = 0;
        break;
      }
    }
    if (in.type == EVT_KBRD) {
      done = keypress_h(buf, len, &k, &nul, in.key, firsttime);
      accepted = (in.key.code != ESCAPE);
    } else if (in.type == EVT_MOUSE) {
      int result = mouse_h(buf, len, &k, &nul, in.mouse, firsttime);
      if (result != 0) {
        done = true;
        accepted = (result == 1);
      }
    }
    Term_erase(x, y, (int)len);
    Term_putstr(x, y, -1, COLOUR_WHITE, buf);
    firsttime = false;
  }
  return accepted;
}
STATIC_OVL bool
get_name_keypress(char* buf, size_t buflen, size_t* curs, size_t* len,
                  struct keypress keypress, bool firsttime)
{
  bool result;
  switch (keypress.code) {
    case '*': {
      *len = player_random_name(buf, buflen);
      *curs = 0;
      result = false;
      break;
    }
    default: {
      result = askfor_aux_keypress(buf, buflen, curs, len, keypress, firsttime);
      break;
    }
  }
  return result;
}
STATIC_OVL int
handle_name_mouse(char* buf, size_t buflen, size_t* curs, size_t* len,
                  struct mouseclick mouse, bool firsttime)
{
  enum { ACT_CTX_NAME_ACCEPT, ACT_CTX_NAME_RANDOM, ACT_CTX_NAME_CLEAR };
  int result = 2;
  char* labels;
  struct menu* m;
  int action;
  if (mouse.button == 2) {
    return result;
  }
  result = 0;
  labels = string_make(lower_case);
  m = menu_dynamic_new();
  m->selections = labels;
  menu_dynamic_add_label(m, "Accept", 'a', ACT_CTX_NAME_ACCEPT, labels);
  menu_dynamic_add_label(m, "Set to random name", 'r', ACT_CTX_NAME_RANDOM,
                         labels);
  menu_dynamic_add_label(m, "Clear name", 'c', ACT_CTX_NAME_CLEAR, labels);
  screen_save();
  menu_dynamic_calc_location(m, mouse.x, mouse.y);
  region_erase_bordered(&m->boundary);
  action = menu_dynamic_select(m);
  menu_dynamic_free(m);
  string_free(labels);
  screen_load();
  switch (action) {
    case ACT_CTX_NAME_ACCEPT:
      result = 1;
      break;
    case ACT_CTX_NAME_RANDOM:
      *len = player_random_name(buf, buflen);
      *curs = 0;
      break;
    case ACT_CTX_NAME_CLEAR:
      assert(buflen > 0);
      buf[0] = '\0';
      *len = 0;
      *curs = 0;
      break;
  }
  return result;
}
STATIC_OVL bool
get_character_name(char* buf, size_t buflen)
{
  bool res;
  event_signal(EVENT_MESSAGE_FLUSH);
  prt("Enter a name for your character (* for a random name): ", 0, 0);
  my_strcpy(buf, player->full_name, buflen);
  res = askfor_aux_ext(buf, buflen, get_name_keypress, handle_name_mouse);
  prt("", 0, 0);
  if (!res) my_strcpy(buf, player->full_name, buflen);
  return res;
}
STATIC_OVL bool
textui_get_string(const char* prompt, char* buf, size_t len)
{
  bool res;
  event_signal(EVENT_MESSAGE_FLUSH);
  prt(prompt, 0, 0);
  res = askfor_aux(buf, len, NULL);
  prt("", 0, 0);
  return (res);
}
STATIC_OVL int
textui_get_quantity(const char* prompt, int max)
{
  int amt = 1;
  if (max != 1) {
    char tmp[80];
    char buf[80];
    if (!prompt) {
      strnfmt(tmp, sizeof(tmp), "Quantity (0-%d, *=all): ", max);
      prompt = tmp;
    }
    strnfmt(buf, sizeof(buf), "%d", amt);
    if (!get_string(prompt, buf, 7)) return (0);
    amt = atoi(buf);
    if ((buf[0] == '*') || isalpha((unsigned char)buf[0])) amt = max;
  }
  if (amt > max) amt = max;
  if (amt < 0) amt = 0;
  return (amt);
}
STATIC_OVL bool
textui_get_check(const char* prompt)
{
  ui_event ke;
  char buf[80];
  strnfmt(buf, 78, "%.70s[y/n] ", prompt);
  event_signal(EVENT_MESSAGE_FLUSH);
  prt(buf, 0, 0);
  ke = inkey_m();
  prt("", 0, 0);
  if (ke.type == EVT_MOUSE) {
    if ((ke.mouse.button != 1) && (ke.mouse.y != 0)) return (false);
  } else {
    if ((ke.key.code != 'Y') && (ke.key.code != 'y')) return (false);
  }
  return (true);
}
STATIC_OVL char
get_char(const char* prompt, const char* options, size_t len, char fallback)
{
  struct keypress key;
  char buf[80];
  event_signal(EVENT_MESSAGE_FLUSH);
  strnfmt(buf, 78, "%.70s[%s] ", prompt, options);
  prt(buf, 0, 0);
  key = inkey();
  if (key.code >= 'A' && key.code <= 'Z') key.code += 32;
  if (!strchr(options, (char)key.code)) key.code = fallback;
  prt("", 0, 0);
  return key.code;
}
STATIC_OVL bool
get_file_text(const char* suggested_name, char* path, size_t len)
{
  char buf[160];
  my_strcpy(buf, suggested_name, sizeof buf);
  if (!arg_force_name) {
    if (!get_string("File name: ", buf, sizeof buf)) return false;
    if (buf[0] == '\0' || buf[0] == ' ') return false;
  } else {
    int old_len;
    time_t ltime;
    struct tm* today;
    time(&ltime);
    today = localtime(&ltime);
    prt("File name: ", 0, 0);
    assert(strlen(buf) >= 4);
    old_len = strlen(buf) - 4;
    strftime(buf + old_len, sizeof(buf) - len, "-%Y-%m-%d-%H-%M.txt", today);
    if (!get_check(format("Confirm writing to %s? ", buf))) return false;
  }
  path_build(path, len, ANGBAND_DIR_USER, buf);
  if (file_exists(path) && !get_check("Replace existing file? ")) return false;
  prt(format("Saving as %s.", path), 0, 0);
  anykey();
  prt("", 0, 0);
  return true;
}
STATIC_OVL bool
textui_get_com(const char* prompt, char* command)
{
  ui_event ke;
  bool result;
  result = get_com_ex(prompt, &ke);
  *command = (char)ke.key.code;
  return result;
}
STATIC_OVL bool
get_com_ex(const char* prompt, ui_event* command)
{
  ui_event ke;
  event_signal(EVENT_MESSAGE_FLUSH);
  prt(prompt, 0, 0);
  ke = inkey_m();
  prt("", 0, 0);
  *command = ke;
  if ((ke.type == EVT_KBRD && ke.key.code != ESCAPE) || (ke.type == EVT_MOUSE))
    return true;
  else
    return false;
}
STATIC_OVL void
pause_line(struct term* tm)
{
  prt("", tm->hgt - 1, 0);
  put_str("[Press any key to continue]", tm->hgt - 1, (tm->wid - 27) / 2);
  (void)anykey();
  prt("", tm->hgt - 1, 0);
}
STATIC_OVL bool
textui_get_rep_dir(int* dp, bool allow_5)
{
  int dir = 0;
  ui_event ke;
  (*dp) = 0;
  while (!dir) {
    event_signal(EVENT_MESSAGE_FLUSH);
    inkey_scan = SCAN_INSTANT;
    ke = inkey_ex();
    inkey_scan = SCAN_OFF;
    if (ke.type == EVT_NONE ||
        (ke.type == EVT_KBRD && !target_dir_allow(ke.key, allow_5))) {
      prt("Direction or <click> (Escape to cancel)? ", 0, 0);
      ke = inkey_ex();
    }
    if (ke.type == EVT_MOUSE) {
      if (ke.mouse.button == 1) {
        int y = KEY_GRID_Y(ke);
        int x = KEY_GRID_X(ke);
        struct loc from = player->grid;
        struct loc to = loc(x, y);
        dir = pathfind_direction_to(from, to);
      } else if (ke.mouse.button == 2) {
        prt("", 0, 0);
        return (false);
      }
    } else if (ke.type == EVT_KBRD) {
      int keypresses_handled = 0;
      while (ke.type == EVT_KBRD && ke.key.code != 0) {
        int this_dir;
        if (ke.key.code == ESCAPE) {
          prt("", 0, 0);
          return (false);
        }
        this_dir = target_dir_allow(ke.key, allow_5);
        if (this_dir) dir = dir_transitions[dir][this_dir];
        if (player->opts.lazymove_delay == 0 || ++keypresses_handled > 1) break;
        inkey_scan = player->opts.lazymove_delay;
        ke = inkey_ex();
      }
      if (dir == 5 && !allow_5) {
        prt("", 0, 0);
        return (false);
      }
    }
    if (!dir) bell();
  }
  prt("", 0, 0);
  (*dp) = dir;
  return (true);
}
STATIC_OVL bool
textui_get_aim_dir(int* dp, int range)
{
  int dir = 0;
  ui_event ke;
  const char* p;
  (*dp) = 0;
  while (!dir) {
    bool need_beep = false;
    if (!target_okay(range))
      p = "Direction ('*' or <click> to target, \"'\" for closest, Escape to "
          "cancel)? ";
    else
      p = "Direction ('5' for target, '*' or <click> to re-target, Escape to "
          "cancel)? ";
    if (!get_com_ex(p, &ke)) break;
    if (ke.type == EVT_MOUSE) {
      if (ke.mouse.button == 1) {
        if (target_set_interactive(TARGET_KILL,
                                   loc(KEY_GRID_X(ke), KEY_GRID_Y(ke)), range))
          dir = DIR_TARGET;
      } else if (ke.mouse.button == 2) {
        break;
      }
    } else if (ke.type == EVT_KBRD) {
      if (ke.key.code == '*') {
        if (target_set_interactive(TARGET_KILL, loc(-1, -1), range))
          dir = DIR_TARGET;
      } else if (ke.key.code == '\'') {
        if (target_set_closest(TARGET_KILL, NULL)) {
          dir = DIR_TARGET;
        } else {
          need_beep = true;
        }
      } else if (ke.key.code == 't' || ke.key.code == '5' ||
                 ke.key.code == '0' || ke.key.code == '.') {
        if (target_okay(range)) {
          dir = DIR_TARGET;
        } else {
          need_beep = true;
        }
      } else if (ke.key.code == '>') {
        dir = DIR_DOWN;
      } else if (ke.key.code == '<') {
        dir = DIR_UP;
      } else {
        int keypresses_handled = 0;
        while (ke.key.code != 0) {
          int this_dir;
          this_dir = target_dir(ke.key);
          if (this_dir) {
            dir = dir_transitions[dir][this_dir];
          } else {
            need_beep = true;
            break;
          }
          if (player->opts.lazymove_delay == 0 || ++keypresses_handled > 1)
            break;
          inkey_scan = player->opts.lazymove_delay;
          ke = inkey_ex();
        }
      }
    }
    if (need_beep) bell();
  }
  if (!dir) return (false);
  (*dp) = dir;
  return (true);
}
STATIC_OVL void
textui_input_init(void)
{
  get_string_hook = textui_get_string;
  get_quantity_hook = textui_get_quantity;
  get_check_hook = textui_get_check;
  get_com_hook = textui_get_com;
  get_rep_dir_hook = textui_get_rep_dir;
  get_aim_dir_hook = textui_get_aim_dir;
  get_effect_from_list_hook = textui_get_effect_from_list;
  get_item_hook = textui_get_item;
  get_panel_hook = textui_get_panel;
  panel_contains_hook = textui_panel_contains;
  map_is_visible_hook = textui_map_is_visible;
  smith_object_hook = textui_smith_object;
  change_song_hook = textui_change_song;
}
STATIC_OVL int
textui_get_count(void)
{
  int count = 0;
  while (1) {
    struct keypress ke;
    prt(format("Repeat: %d", count), 0, 0);
    ke = inkey();
    if (ke.code == ESCAPE)
      return -1;
    else if (ke.code == KC_DELETE || ke.code == KC_BACKSPACE)
      count = count / 10;
    else if (isdigit((unsigned char)ke.code)) {
      count = count * 10 + D2I(ke.code);
      if (count >= 9999) {
        bell();
        count = 9999;
      }
    } else {
      if (ke.code != KC_ENTER) Term_keypress(ke.code, ke.mods);
      break;
    }
  }
  return count;
}
STATIC_OVL ui_event
textui_get_command(int* count)
{
  int mode =
      OPT(player, angband_keyset) ? KEYMAP_MODE_ANGBAND : KEYMAP_MODE_ORIG;
  struct keypress tmp[2] = {KEYPRESS_NULL, KEYPRESS_NULL};
  ui_event ke = EVENT_EMPTY;
  const struct keypress* act = NULL;
  if (OPT(player, hjkl_movement)) {
    mode |= KEYMAP_MODE_ROGUE;
  }
  while (1) {
    msg_flag = false;
    inkey_flag = true;
    if (OPT(player, highlight_player)) {
      Term_set_cursor(true);
      move_cursor_relative(player->grid.y, player->grid.x);
    }
    ke = inkey_ex();
    if (OPT(player, highlight_player)) {
      Term_set_cursor(false);
    }
    if (ke.type == EVT_KBRD) {
      bool keymap_ok = true;
      switch (ke.key.code) {
        case '0': {
          if (ke.key.mods & KC_MOD_KEYPAD) break;
          if (!(mode & KEYMAP_MODE_ANGBAND)) break;
          int c = textui_get_count();
          if (c == -1 || !get_com_ex("Command: ", &ke))
            continue;
          else
            *count = c;
          break;
        }
        case 'R': {
          if (mode & KEYMAP_MODE_ANGBAND) break;
          int c = textui_get_count();
          if (c == -1 || !get_com_ex("Command: ", &ke))
            continue;
          else
            *count = c;
          break;
        }
        case '\\': {
          (void)get_com_ex("Command: ", &ke);
          keymap_ok = false;
          break;
        }
        case '^': {
          if (!get_com_ex("Control: ", &ke) || ke.type != EVT_KBRD) {
            continue;
          }
          if (ENCODE_KTRL(ke.key.code)) {
            ke.key.code = KTRL(ke.key.code);
          } else {
            ke.key.mods |= KC_MOD_CONTROL;
          }
          break;
        }
      }
      if (keymap_ok) act = keymap_find(mode, ke.key);
    }
    prt("", 0, 0);
    if (ke.type == EVT_BUTTON) {
      act = tmp;
      tmp[0] = ke.key;
    }
    if (ke.key.code && act && !inkey_next) {
      size_t n = 0;
      while (act[n].type) n++;
      n += 1;
      memcpy(request_command_buffer, act, n * sizeof(struct keypress));
      inkey_next = request_command_buffer;
      continue;
    }
    break;
  }
  return ke;
}
STATIC_OVL bool
key_confirm_command(unsigned char c)
{
  int i;
  for (i = 0; i < player->body.count; i++) {
    char verify_inscrip[] = "^*";
    unsigned n;
    struct object* obj = slot_object(player, i);
    if (!obj) continue;
    verify_inscrip[1] = c;
    n = check_for_inscrip(obj, "^*") + check_for_inscrip(obj, verify_inscrip);
    while (n--) {
      if (!get_check("Are you sure? ")) return false;
    }
  }
  return true;
}
STATIC_OVL bool
textui_process_key(struct keypress kp, unsigned char* c, int count)
{
  keycode_t key = kp.code;
  if (key == '\0' || key == ESCAPE || key == ' ' || key == '\a') return true;
  if (key > UCHAR_MAX) return false;
  *c = key;
  return true;
}
STATIC_OVL const struct keypress*
keymap_find(int keymap, struct keypress kc)
{
  struct keymap* k;
  assert(keymap >= 0 && keymap < KEYMAP_MODE_MAX);
  for (k = keymaps[keymap]; k; k = k->next) {
    if (k->key.code == kc.code && k->key.mods == kc.mods) return k->actions;
  }
  return NULL;
}
STATIC_OVL struct keypress*
keymap_make(const struct keypress* actions)
{
  struct keypress* new;
  size_t n = 0;
  while (actions[n].type) {
    n++;
  }
  n += 1;
  new = mem_zalloc(sizeof *new* n);
  memcpy(new, actions, sizeof *new* n);
  new[n - 1].type = EVT_NONE;
  return new;
}
STATIC_OVL void
keymap_add(int keymap, struct keypress trigger, struct keypress* actions,
           bool user)
{
  struct keymap* k = mem_zalloc(sizeof *k);
  assert(keymap >= 0 && keymap < KEYMAP_MODE_MAX);
  keymap_remove(keymap, trigger);
  k->key = trigger;
  k->actions = keymap_make(actions);
  k->user = user;
  k->next = keymaps[keymap];
  keymaps[keymap] = k;
  return;
}
STATIC_OVL bool
keymap_remove(int keymap, struct keypress trigger)
{
  struct keymap* k;
  struct keymap* prev = NULL;
  assert(keymap >= 0 && keymap < KEYMAP_MODE_MAX);
  for (k = keymaps[keymap]; k; k = k->next) {
    if (k->key.code == trigger.code && k->key.mods == trigger.mods) {
      mem_free(k->actions);
      if (prev)
        prev->next = k->next;
      else
        keymaps[keymap] = k->next;
      mem_free(k);
      return true;
    }
    prev = k;
  }
  return false;
}
STATIC_OVL void
keymap_free(void)
{
  size_t i;
  struct keymap* k;
  for (i = 0; i < N_ELEMENTS(keymaps); i++) {
    k = keymaps[i];
    while (k) {
      struct keymap* next = k->next;
      mem_free(k->actions);
      mem_free(k);
      k = next;
    }
  }
}
STATIC_OVL void
keymap_dump(ang_file* fff)
{
  int mode;
  struct keymap* k;
  if (OPT(player, angband_keyset)) {
    mode = KEYMAP_MODE_ANGBAND;
  } else {
    mode = KEYMAP_MODE_ORIG;
  }
  if (OPT(player, hjkl_movement)) {
    mode |= KEYMAP_MODE_ROGUE;
  }
  for (k = keymaps[mode]; k; k = k->next) {
    char buf[1024];
    struct keypress key[2] = {KEYPRESS_NULL, KEYPRESS_NULL};
    if (!k->user) continue;
    keypress_to_text(buf, sizeof(buf), k->actions, false);
    file_putf(fff, "keymap-act:%s\n", buf);
    key[0] = k->key;
    keypress_to_text(buf, sizeof(buf), key, true);
    file_putf(fff, "keymap-input:%d:%s\n", mode, buf);
    file_putf(fff, "\n");
  }
}
STATIC_OVL int
default_item_id(int oid)
{
  return default_join[oid].oid;
}
STATIC_OVL int
default_group_id(int oid)
{
  return default_join[oid].gid;
}
STATIC_OVL int
feat_order(int feat)
{
  if (tf_has(f_info[feat].flags, TF_FLOOR)) return 0;
  if (tf_has(f_info[feat].flags, TF_STAIR)) return 2;
  if (tf_has(f_info[feat].flags, TF_SHAFT)) return 2;
  if (tf_has(f_info[feat].flags, TF_DOOR_ANY)) return 1;
  if (tf_has(f_info[feat].flags, TF_PIT)) return 6;
  if (tf_has(f_info[feat].flags, TF_CHASM)) return 4;
  if (tf_has(f_info[feat].flags, TF_FORGE)) return 5;
  if (tf_has(f_info[feat].flags, TF_QUARTZ)) return 4;
  if (tf_has(f_info[feat].flags, TF_WALL)) return 3;
  if (tf_has(f_info[feat].flags, TF_ROCK)) return 4;
  return 7;
}
STATIC_OVL int
actual_width(int width)
{
  return width * tile_width;
}
STATIC_OVL int
actual_height(int height)
{
  return height * tile_height;
}
STATIC_OVL int
logical_width(int width)
{
  return width / tile_width;
}
STATIC_OVL int
logical_height(int height)
{
  return height / tile_height;
}
STATIC_OVL void
display_tiles(int col, int row, int height, int width, uint8_t attr_top,
              wchar_t char_left)
{
  int i, j;
  for (i = 0; i < height; i++) Term_erase(col, row + i, width);
  width = logical_width(width);
  height = logical_height(height);
  for (i = 0; i < height; i++) {
    for (j = 0; j < width; j++) {
      uint8_t a;
      wchar_t c;
      int x = col + actual_width(j);
      int y = row + actual_height(i);
      int ia, ic;
      ia = attr_top + i;
      ic = char_left + j;
      a = (uint8_t)ia;
      c = (wchar_t)ic;
      big_pad(x, y, a, c);
    }
  }
}
STATIC_OVL void
place_tile_cursor(int col, int row, uint8_t a, wchar_t c, uint8_t attr_top,
                  wchar_t char_left)
{
  int i = a - attr_top;
  int j = c - char_left;
  int x = col + actual_width(j);
  int y = row + actual_height(i);
  Term_gotoxy(x, y);
}
STATIC_OVL void
remove_tiles(int col, int row, bool* picker_ptr, int width, int height)
{
  int i;
  bigcurs = false;
  *picker_ptr = false;
  for (i = 0; i < height; i++) Term_erase(col, row + i, width);
}
STATIC_OVL bool
tile_picker_command(ui_event ke, bool* tile_picker_ptr, int height, int width,
                    uint8_t* attr_top_ptr, wchar_t* char_left_ptr,
                    uint8_t* cur_attr_ptr, wchar_t* cur_char_ptr, int col,
                    int row, int* delay)
{
  static uint8_t attr_old = 0;
  static wchar_t char_old = 0;
  int frame_left = logical_width(10);
  int frame_right = logical_width(10);
  int frame_top = logical_height(4);
  int frame_bottom = logical_height(4);
  if (*tile_picker_ptr && (ke.type == EVT_MOUSE)) {
    int eff_width = actual_width(width);
    int eff_height = actual_height(height);
    uint8_t a = *cur_attr_ptr;
    wchar_t c = *cur_char_ptr;
    int my = logical_height(ke.mouse.y - row);
    int mx = logical_width(ke.mouse.x - col);
    if ((my >= 0) && (my < eff_height) && (mx >= 0) && (mx < eff_width) &&
        ((ke.mouse.button == 1) || (a != *attr_top_ptr + my) ||
         (c != *char_left_ptr + mx))) {
      *cur_attr_ptr = a = *attr_top_ptr + my;
      *cur_char_ptr = c = *char_left_ptr + mx;
      if (*char_left_ptr > MAX(0, (int)c - frame_left)) (*char_left_ptr)--;
      if (*char_left_ptr + eff_width <= MIN(255, (int)c + frame_right))
        (*char_left_ptr)++;
      if (*attr_top_ptr > MAX(0, (int)a - frame_top)) (*attr_top_ptr)--;
      if (*attr_top_ptr + eff_height <= MIN(255, (int)a + frame_bottom))
        (*attr_top_ptr)++;
      *delay = 100;
      if (ke.mouse.button)
        remove_tiles(col, row, tile_picker_ptr, width, height);
      return true;
    } else if (ke.mouse.button == 2) {
      *cur_attr_ptr = attr_old;
      *cur_char_ptr = char_old;
      remove_tiles(col, row, tile_picker_ptr, width, height);
      return true;
    } else {
      return false;
    }
  }
  if (ke.type != EVT_KBRD) return false;
  switch (ke.key.code) {
    case ESCAPE: {
      if (*tile_picker_ptr) {
        *cur_attr_ptr = attr_old;
        *cur_char_ptr = char_old;
        remove_tiles(col, row, tile_picker_ptr, width, height);
        return true;
      }
      break;
    }
    case KC_ENTER: {
      if (*tile_picker_ptr) {
        remove_tiles(col, row, tile_picker_ptr, width, height);
        return true;
      }
      break;
    }
    case 'V':
    case 'v': {
      if (current_graphics_mode != NULL)
        if (current_graphics_mode->grafID == 0) break;
      if (!*tile_picker_ptr) {
        *tile_picker_ptr = true;
        bigcurs = true;
        *attr_top_ptr = (uint8_t)MAX(0, (int)*cur_attr_ptr - frame_top);
        *char_left_ptr = (wchar_t)MAX(0, (int)*cur_char_ptr - frame_left);
        attr_old = *cur_attr_ptr;
        char_old = *cur_char_ptr;
      } else {
        *cur_attr_ptr = attr_old;
        *cur_char_ptr = char_old;
        remove_tiles(col, row, tile_picker_ptr, width, height);
      }
      return true;
    }
    case 'C':
    case 'c': {
      attr_idx = *cur_attr_ptr;
      char_idx = *cur_char_ptr;
      return true;
    }
    case 'P':
    case 'p': {
      if (attr_idx) {
        *cur_attr_ptr = attr_idx;
        *attr_top_ptr = (uint8_t)MAX(0, (int)*cur_attr_ptr - frame_top);
      }
      if (char_idx) {
        *cur_char_ptr = char_idx;
        *char_left_ptr = (wchar_t)MAX(0, (int)*cur_char_ptr - frame_left);
      }
      return true;
    }
    default: {
      int d = target_dir(ke.key);
      uint8_t a = *cur_attr_ptr;
      wchar_t c = *cur_char_ptr;
      if (!*tile_picker_ptr) break;
      bigcurs = true;
      if ((a == 0) && (ddy[d] < 0)) d = 0;
      if ((c == 0) && (ddx[d] < 0)) d = 0;
      if ((a == 255) && (ddy[d] > 0)) d = 0;
      if ((c == 255) && (ddx[d] > 0)) d = 0;
      a += ddy[d];
      c += ddx[d];
      *cur_attr_ptr = a;
      *cur_char_ptr = c;
      if (ddx[d] < 0 && *char_left_ptr > MAX(0, (int)c - frame_left))
        (*char_left_ptr)--;
      if ((ddx[d] > 0) && *char_left_ptr + (width / tile_width) <=
                              MIN(255, (int)c + frame_right))
        (*char_left_ptr)++;
      if (ddy[d] < 0 && *attr_top_ptr > MAX(0, (int)a - frame_top))
        (*attr_top_ptr)--;
      if (ddy[d] > 0 && *attr_top_ptr + (height / tile_height) <=
                            MIN(255, (int)a + frame_bottom))
        (*attr_top_ptr)++;
      return true;
    }
  }
  return false;
}
STATIC_OVL void
display_glyphs(int col, int row, int height, int width, uint8_t a, wchar_t c)
{
  int i;
  int x, y;
  for (i = 0; i < height; i++) Term_erase(col, row + i, width);
  prt("Choose colour:", row + height / 2, col);
  Term_locate(&x, &y);
  for (i = 0; i < MAX_COLORS; i++) big_pad(x + i, y, i, c);
  Term_gotoxy(x + a, y);
}
STATIC_OVL bool
glyph_command(ui_event ke, bool* glyph_picker_ptr, int height, int width,
              uint8_t* cur_attr_ptr, wchar_t* cur_char_ptr, int col, int row)
{
  static uint8_t attr_old = 0;
  static wchar_t char_old = 0;
  if (*glyph_picker_ptr && (ke.type == EVT_MOUSE)) {
    int mx = logical_width(ke.mouse.x - col);
    if (ke.mouse.y != row + height / 2) return false;
    if ((mx >= 0) && (mx < MAX_COLORS) && (ke.mouse.button == 1)) {
      *cur_attr_ptr = mx - 14;
      remove_tiles(col, row, glyph_picker_ptr, width, height);
      return true;
    } else {
      return false;
    }
  }
  if (ke.type != EVT_KBRD) return false;
  switch (ke.key.code) {
    case ESCAPE: {
      if (*glyph_picker_ptr) {
        *cur_attr_ptr = attr_old;
        *cur_char_ptr = char_old;
        remove_tiles(col, row, glyph_picker_ptr, width, height);
        return true;
      }
      break;
    }
    case KC_ENTER: {
      if (*glyph_picker_ptr) {
        remove_tiles(col, row, glyph_picker_ptr, width, height);
        return true;
      }
      break;
    }
    case 'V':
    case 'v': {
      if (!*glyph_picker_ptr) {
        *glyph_picker_ptr = true;
        attr_old = *cur_attr_ptr;
        char_old = *cur_char_ptr;
      } else {
        *cur_attr_ptr = attr_old;
        *cur_char_ptr = char_old;
        remove_tiles(col, row, glyph_picker_ptr, width, height);
      }
      return true;
    }
    case 'C':
    case 'c': {
      attr_idx = *cur_attr_ptr;
      char_idx = *cur_char_ptr;
      return true;
    }
    case 'P':
    case 'p': {
      if (attr_idx) {
        *cur_attr_ptr = attr_idx;
      }
      if (char_idx) {
        *cur_char_ptr = char_idx;
      }
      return true;
    }
    case 'i':
    case 'I': {
      if (*glyph_picker_ptr) {
        char code_point[6];
        bool res = false;
        Term_gotoxy(col, row + height / 2 + 2);
        res = get_string("(up to 5 hex digits):", code_point, 5);
        if (res) {
          unsigned long int point = strtoul(code_point, (char**)NULL, 16);
          *cur_char_ptr = (wchar_t)point;
          return true;
        }
      }
      break;
    }
    default: {
      int d = target_dir(ke.key);
      uint8_t a = *cur_attr_ptr;
      if (!*glyph_picker_ptr) break;
      if (ddy[d] != 0) break;
      if (ddx[d] != 0) {
        a += ddx[d] + BASIC_COLORS;
        a = a % BASIC_COLORS;
        *cur_attr_ptr = a;
      }
      return true;
    }
  }
  return false;
}
STATIC_OVL void
display_group_member(struct menu* menu, int oid, bool cursor, int row, int col,
                     int wid)
{
  const member_funcs* o_funcs = menu->menu_data;
  uint8_t attr = curs_attrs[CURS_KNOWN][cursor == oid];
  (void)wid;
  o_funcs->display_member(col, row, cursor, oid);
  if (o_funcs->is_visual && o_funcs->xattr) {
    wchar_t c = *o_funcs->xchar(oid);
    uint8_t a = *o_funcs->xattr(oid);
    char buf[12];
    strnfmt(buf, sizeof(buf), "%d/%d", a, c);
    c_put_str(attr, buf, row, 64 - (int)strlen(buf));
  }
}
STATIC_OVL const char*
recall_prompt(int oid)
{
  (void)oid;
  return ", 'r' to recall";
}
STATIC_OVL void
display_knowledge(const char* title, int* obj_list, int o_count,
                  group_funcs g_funcs, member_funcs o_funcs,
                  const char* otherfields)
{
  int max_group = g_funcs.maxnum < o_count ? g_funcs.maxnum : o_count;
  int *g_list, *g_offset;
  const char** g_names;
  int g_name_len = 8;
  int grp_cnt = 0;
  int g_cur = 0, grp_old = -1;
  int o_cur = 0;
  int g_o_count = 0;
  int oid;
  region title_area = {0, 0, 0, 4};
  region group_region = {0, 6, -17, -2};
  region object_region = {-17, 6, 0, -2};
  bool tiles = (current_graphics_mode != NULL);
  bool tile_picker = false;
  bool glyph_picker = false;
  uint8_t attr_top = 0;
  wchar_t char_left = 0;
  int delay = 0;
  struct menu group_menu;
  struct menu object_menu;
  menu_iter object_iter = {NULL, NULL, display_group_member, NULL, NULL};
  int *active_cursor = &g_cur, *inactive_cursor = &o_cur;
  struct menu *active_menu = &group_menu, *inactive_menu = &object_menu;
  int panel = 0;
  void* swapspace;
  bool do_swap = false;
  bool flag = false;
  bool redraw = true;
  int browser_rows;
  int wid, hgt;
  int i;
  int prev_g = -1;
  ui_event ke;
  Term_get_size(&wid, &hgt);
  browser_rows = hgt - 8;
  if (tiles) tiles = (current_graphics_mode->grafID != 0);
  if (g_funcs.gcomp) sort(obj_list, o_count, sizeof(*obj_list), g_funcs.gcomp);
  g_list = mem_zalloc((max_group + 1) * sizeof(int));
  g_offset = mem_zalloc((max_group + 1) * sizeof(int));
  for (i = 0; i < o_count; i++) {
    if (prev_g != g_funcs.group(obj_list[i])) {
      prev_g = g_funcs.group(obj_list[i]);
      g_offset[grp_cnt] = i;
      g_list[grp_cnt++] = prev_g;
    }
  }
  g_offset[grp_cnt] = o_count;
  g_list[grp_cnt] = -1;
  g_names = mem_zalloc(grp_cnt * sizeof(char*));
  for (i = 0; i < grp_cnt; i++) {
    int len;
    g_names[i] = g_funcs.name(g_list[i]);
    len = strlen(g_names[i]);
    if (len > g_name_len) g_name_len = len;
  }
  if (g_name_len >= 20) g_name_len = 20;
  object_region.col = g_name_len + 3;
  group_region.width = g_name_len;
  if (g_funcs.summary) object_region.page_rows = -3;
  menu_init(&group_menu, MN_SKIN_SCROLL, menu_find_iter(MN_ITER_STRINGS));
  menu_setpriv(&group_menu, grp_cnt, g_names);
  menu_layout(&group_menu, &group_region);
  group_menu.flags |= MN_DBL_TAP;
  menu_init(&object_menu, MN_SKIN_SCROLL, &object_iter);
  menu_setpriv(&object_menu, 0, &o_funcs);
  menu_layout(&object_menu, &object_region);
  object_menu.flags |= MN_DBL_TAP;
  o_funcs.is_visual = false;
  screen_save();
  clear_from(0);
  while ((!flag) && (grp_cnt)) {
    bool recall = false;
    if (redraw) {
      region_erase(&title_area);
      prt(format("Knowledge - %s", title), 2, 0);
      prt("Group", 4, 0);
      prt("Name", 4, g_name_len + 3);
      if (otherfields) prt(otherfields, 4, 46);
      for (i = 0; i < 79; i++) Term_putch(i, 5, COLOUR_WHITE, L'=');
      for (i = 0; i < browser_rows; i++)
        Term_putch(g_name_len + 1, 6 + i, COLOUR_WHITE, L'|');
      redraw = false;
    }
    if (g_cur != grp_old) {
      grp_old = g_cur;
      o_cur = 0;
      g_o_count = g_offset[g_cur + 1] - g_offset[g_cur];
      menu_set_filter(&object_menu, obj_list + g_offset[g_cur], g_o_count);
      group_menu.cursor = g_cur;
      object_menu.cursor = 0;
    }
    if (!(tile_picker || glyph_picker)) {
      o_funcs.is_visual = false;
      menu_set_filter(&object_menu, obj_list + g_offset[g_cur], g_o_count);
      object_menu.cursor = o_cur;
    } else {
      o_funcs.is_visual = true;
      menu_set_filter(&object_menu, obj_list + o_cur + g_offset[g_cur], 1);
      object_menu.cursor = 0;
    }
    oid = obj_list[g_offset[g_cur] + o_cur];
    {
      const char* pedit =
          (!o_funcs.xattr) ? ""
                           : (!(attr_idx | char_idx) ? ", 'c' to copy"
                                                     : ", 'c', 'p' to paste");
      const char* xtra = o_funcs.xtra_prompt ? o_funcs.xtra_prompt(oid) : "";
      const char* pvs = "";
      if (tile_picker)
        pvs = ", ENTER to accept";
      else if (glyph_picker)
        pvs = ", 'i' to insert, ENTER to accept";
      else if (o_funcs.xattr)
        pvs = ", 'v' for visuals";
      prt(format("<dir>%s%s%s, ESC", pvs, pedit, xtra), hgt - 1, 0);
    }
    if (do_swap) {
      do_swap = false;
      (swapspace = (void*)(active_menu)), ((active_menu) = (inactive_menu)),
          ((inactive_menu) = swapspace);
      (swapspace = (void*)(active_cursor)),
          ((active_cursor) = (inactive_cursor)),
          ((inactive_cursor) = swapspace);
      panel = 1 - panel;
    }
    if (g_funcs.summary && !tile_picker && !glyph_picker) {
      g_funcs.summary(g_cur, obj_list, g_o_count, g_offset[g_cur],
                      object_menu.active.row + object_menu.active.page_rows,
                      object_region.col);
    }
    menu_refresh(inactive_menu, false);
    menu_refresh(active_menu, false);
    handle_stuff(player);
    if (tile_picker) {
      bigcurs = true;
      display_tiles(g_name_len + 3, 7, browser_rows - 1, wid - (g_name_len + 3),
                    attr_top, char_left);
      place_tile_cursor(g_name_len + 3, 7, *o_funcs.xattr(oid),
                        *o_funcs.xchar(oid), attr_top, char_left);
    }
    if (glyph_picker) {
      display_glyphs(g_name_len + 3, 7, browser_rows - 1,
                     wid - (g_name_len + 3), *o_funcs.xattr(oid),
                     *o_funcs.xchar(oid));
    }
    if (delay) {
      Term_fresh();
      Term_xtra(TERM_XTRA_DELAY, delay);
      delay = 0;
    }
    ke = inkey_ex();
    if (!tile_picker && !glyph_picker) {
      ui_event ke0 = EVENT_EMPTY;
      if (ke.type == EVT_MOUSE)
        menu_handle_mouse(active_menu, &ke, &ke0);
      else if (ke.type == EVT_KBRD)
        menu_handle_keypress(active_menu, &ke, &ke0);
      if (ke0.type != EVT_NONE) ke = ke0;
    }
    if (o_funcs.xattr && o_funcs.xchar) {
      if (tiles) {
        if (tile_picker_command(ke, &tile_picker, browser_rows - 1,
                                wid - (g_name_len + 3), &attr_top, &char_left,
                                o_funcs.xattr(oid), o_funcs.xchar(oid),
                                g_name_len + 3, 7, &delay))
          continue;
      } else {
        if (glyph_command(ke, &glyph_picker, browser_rows - 1,
                          wid - (g_name_len + 3), o_funcs.xattr(oid),
                          o_funcs.xchar(oid), g_name_len + 3, 7))
          continue;
      }
    }
    switch (ke.type) {
      case EVT_KBRD: {
        if (ke.key.code == 'r' || ke.key.code == 'R')
          recall = true;
        else if (o_funcs.xtra_act)
          o_funcs.xtra_act(ke.key, oid);
        break;
      }
      case EVT_MOUSE: {
        if (region_inside(&inactive_menu->active, &ke)) {
          (swapspace = (void*)(active_menu)), ((active_menu) = (inactive_menu)),
              ((inactive_menu) = swapspace);
          (swapspace = (void*)(active_cursor)),
              ((active_cursor) = (inactive_cursor)),
              ((inactive_cursor) = swapspace);
          panel = 1 - panel;
        }
        continue;
      }
      case EVT_ESCAPE: {
        if (panel == 1)
          do_swap = true;
        else
          flag = true;
        break;
      }
      case EVT_SELECT: {
        if (panel == 0)
          do_swap = true;
        else if (panel == 1 && oid >= 0 && o_cur == active_menu->cursor)
          recall = true;
        break;
      }
      case EVT_MOVE: {
        *active_cursor = active_menu->cursor;
        break;
      }
      default: {
        break;
      }
    }
    if (recall) {
      if (oid >= 0) o_funcs.lore(oid);
      redraw = true;
    }
  }
  if (!grp_cnt) prt(format("No %s known.", title), 15, 0);
  mem_free(g_names);
  mem_free(g_offset);
  mem_free(g_list);
  screen_load();
}
STATIC_OVL void
display_monster(int col, int row, bool cursor, int oid)
{
  int r_idx = default_item_id(oid);
  struct monster_race* race = &r_info[r_idx];
  struct monster_lore* lore = &l_list[r_idx];
  uint8_t attr = curs_attrs[CURS_KNOWN][(int)cursor];
  uint8_t a = monster_x_attr[race->ridx];
  wchar_t c = monster_x_char[race->ridx];
  if ((tile_height != 1) && (a & 0x80)) {
    a = race->d_attr;
    c = race->d_char;
  }
  c_prt(attr, race->name, row, col);
  big_pad(66, row, a, c);
  if (!race->rarity) {
    put_str(format("%s", "shape"), row, 70);
  } else if (rf_has(race->flags, RF_UNIQUE)) {
    put_str(format("%s", (race->max_num == 0) ? " dead" : "alive"), row, 70);
  } else {
    put_str(format("%5d", lore->pkills), row, 70);
  }
}
STATIC_OVL int
m_cmp_race(const void* a, const void* b)
{
  const int a_val = *(const int*)a;
  const int b_val = *(const int*)b;
  const struct monster_race* r_a = &r_info[default_item_id(a_val)];
  const struct monster_race* r_b = &r_info[default_item_id(b_val)];
  int gid = default_group_id(a_val);
  int c = gid - default_group_id(b_val);
  if (c) return c;
  assert(gid >= 0 && gid < n_monster_group);
  if (monster_group[gid].n_inc_bases) {
    int base_a = monster_group[gid].n_inc_bases;
    int base_b = monster_group[gid].n_inc_bases;
    int i;
    for (i = 0; i < monster_group[gid].n_inc_bases; ++i) {
      if (r_a->base == monster_group[gid].inc_bases[i]) {
        base_a = i;
      }
      if (r_b->base == monster_group[gid].inc_bases[i]) {
        base_b = i;
      }
    }
    c = base_a - base_b;
    if (c) {
      return c;
    }
    if (base_a < monster_group[gid].n_inc_bases) {
      c = 1;
    }
  }
  if (!c) {
    if (rf_is_inter(r_a->flags, monster_group[gid].inc_flags)) {
      if (!rf_is_inter(r_b->flags, monster_group[gid].inc_flags)) {
        return -1;
      }
    } else if (rf_is_inter(r_b->flags, monster_group[gid].inc_flags)) {
      return 1;
    } else {
      int glyph_a = monster_group[gid].n_inc_glyphs;
      int glyph_b = monster_group[gid].n_inc_glyphs;
      int i;
      for (i = 0; i < monster_group[gid].n_inc_glyphs; ++i) {
        if (r_a->d_char == monster_group[gid].inc_glyphs[i]) {
          glyph_a = i;
        }
        if (r_b->d_char == monster_group[gid].inc_glyphs[i]) {
          glyph_b = i;
        }
      }
      c = glyph_a - glyph_b;
      if (c) {
        return c;
      }
    }
  }
  c = r_a->level - r_b->level;
  if (c) return c;
  return strcmp(r_a->name, r_b->name);
}
STATIC_OVL wchar_t*
m_xchar(int oid)
{
  return &monster_x_char[default_join[oid].oid];
}
STATIC_OVL uint8_t*
m_xattr(int oid)
{
  return &monster_x_attr[default_join[oid].oid];
}
STATIC_OVL const char*
race_name(int gid)
{
  return monster_group[gid].name;
}
STATIC_OVL void
mon_lore(int oid)
{
  int r_idx;
  struct monster_race* race;
  const struct monster_lore* lore;
  textblock* tb;
  r_idx = default_item_id(oid);
  assert(r_idx);
  race = &r_info[r_idx];
  lore = get_lore(race);
  monster_race_track(player->upkeep, race);
  handle_stuff(player);
  tb = textblock_new();
  lore_description(tb, race, lore, false);
  textui_textblock_show(tb, SCREEN_REGION, NULL);
  textblock_free(tb);
}
STATIC_OVL void
mon_summary(int gid, const int* item_list, int n, int top, int row, int col)
{
  int i;
  int kills = 0;
  for (i = 0; i < n; i++) {
    int oid = default_join[item_list[i + top]].oid;
    kills += l_list[oid].pkills;
  }
  if (gid == 0 &&
      rf_has((&r_info[default_join[item_list[0]].oid])->flags, RF_UNIQUE)) {
    c_prt(COLOUR_L_BLUE, format("%d known uniques, %d slain.", n, kills), row,
          col);
  } else {
    int tkills = 0;
    for (i = 0; i < z_info->r_max; i++) tkills += l_list[i].pkills;
    c_prt(COLOUR_L_BLUE,
          format("Creatures slain: %d/%d (in group/in total)", kills, tkills),
          row, col);
  }
}
STATIC_OVL int
count_known_monsters(void)
{
  int m_count = 0, i;
  for (i = 0; i < z_info->r_max; ++i) {
    struct monster_race* race = &r_info[i];
    bool classified = false;
    int j;
    if (!l_list[i].all_known && !l_list[i].tsights) {
      continue;
    }
    if (!race->name) continue;
    for (j = 0; j < n_monster_group - 1; ++j) {
      bool has_base = false;
      int k;
      if (monster_group[j].n_inc_bases) {
        for (k = 0; k < monster_group[j].n_inc_bases; ++k) {
          if (race->base == monster_group[j].inc_bases[k]) {
            ++m_count;
            has_base = true;
            classified = true;
            break;
          }
        }
      }
      if (!has_base) {
        if (rf_is_inter(race->flags, monster_group[j].inc_flags)) {
          ++m_count;
          classified = true;
        } else if (monster_group[j].n_inc_glyphs) {
          for (k = 0; k < monster_group[j].n_inc_glyphs; ++k) {
            if (race->d_char == monster_group[j].inc_glyphs[k]) {
              ++m_count;
              classified = true;
              break;
            }
          }
        }
      }
    }
    if (!classified) {
      ++m_count;
    }
  }
  return m_count;
}
STATIC_OVL void
do_cmd_knowledge_monsters(const char* name, int row)
{
  group_funcs r_funcs = {race_name,   m_cmp_race,      default_group_id,
                         mon_summary, n_monster_group, false};
  member_funcs m_funcs = {display_monster, mon_lore, m_xchar, m_xattr,
                          recall_prompt,   0,        0};
  int* monsters;
  int m_count = count_known_monsters(), i, ind;
  default_join = mem_zalloc(m_count * sizeof(join_t));
  monsters = mem_zalloc(m_count * sizeof(int));
  ind = 0;
  for (i = 0; i < z_info->r_max; ++i) {
    struct monster_race* race = &r_info[i];
    bool classified = false;
    int j;
    if (!l_list[i].all_known && !l_list[i].tsights) {
      continue;
    }
    if (!race->name) continue;
    for (j = 0; j < n_monster_group - 1; ++j) {
      bool has_base = false;
      int k;
      if (monster_group[j].n_inc_bases) {
        for (k = 0; k < monster_group[j].n_inc_bases; ++k) {
          if (race->base == monster_group[j].inc_bases[k]) {
            assert(ind < m_count);
            monsters[ind] = ind;
            default_join[ind].oid = i;
            default_join[ind].gid = j;
            ++ind;
            has_base = true;
            classified = true;
            break;
          }
        }
      }
      if (!has_base) {
        if (rf_is_inter(race->flags, monster_group[j].inc_flags)) {
          assert(ind < m_count);
          monsters[ind] = ind;
          default_join[ind].oid = i;
          default_join[ind].gid = j;
          ++ind;
          classified = true;
        } else if (monster_group[j].n_inc_glyphs) {
          for (k = 0; k < monster_group[j].n_inc_glyphs; ++k) {
            if (race->d_char == monster_group[j].inc_glyphs[k]) {
              assert(ind < m_count);
              monsters[ind] = ind;
              default_join[ind].oid = i;
              default_join[ind].gid = j;
              ++ind;
              classified = true;
              break;
            }
          }
        }
      }
    }
    if (!classified) {
      assert(ind < m_count);
      monsters[ind] = ind;
      default_join[ind].oid = i;
      default_join[ind].gid = n_monster_group - 1;
      ++ind;
    }
  }
  display_knowledge("monsters", monsters, m_count, r_funcs, m_funcs,
                    "                   Sym  Kills");
  mem_free(default_join);
  mem_free(monsters);
}
STATIC_OVL void
get_artifact_display_name(char* o_name, size_t namelen, int a_idx)
{
  struct object body = OBJECT_NULL, known_body = OBJECT_NULL;
  struct object *obj = &body, *known_obj = &known_body;
  make_fake_artifact(obj, &a_info[a_idx]);
  object_wipe(known_obj);
  object_copy(known_obj, obj);
  obj->known = known_obj;
  object_desc(o_name, namelen, obj, ODESC_PREFIX | ODESC_BASE | ODESC_SPOIL,
              NULL);
  object_wipe(known_obj);
  object_wipe(obj);
}
STATIC_OVL void
display_artifact(int col, int row, bool cursor, int oid)
{
  uint8_t attr = curs_attrs[CURS_KNOWN][(int)cursor];
  char o_name[80];
  get_artifact_display_name(o_name, sizeof o_name, oid);
  c_prt(attr, o_name, row, col);
}
STATIC_OVL struct object*
find_artifact(struct artifact* artifact)
{
  int y, x, i;
  struct object* obj;
  for (y = 1; y < cave->height; y++) {
    for (x = 1; x < cave->width; x++) {
      struct loc grid = loc(x, y);
      for (obj = square_object(cave, grid); obj; obj = obj->next) {
        if (obj->artifact == artifact) return obj;
      }
    }
  }
  for (obj = player->gear; obj; obj = obj->next) {
    if (obj->artifact == artifact) return obj;
  }
  for (i = cave_monster_max(cave) - 1; i >= 1; i--) {
    struct monster* mon = cave_monster(cave, i);
    obj = mon ? mon->held_obj : NULL;
    while (obj) {
      if (obj->artifact == artifact) return obj;
      obj = obj->next;
    }
  }
  return NULL;
}
STATIC_OVL void
desc_art_fake(int a_idx)
{
  struct object *obj, *known_obj = NULL;
  struct object object_body = OBJECT_NULL, known_object_body = OBJECT_NULL;
  bool fake = false;
  char header[120];
  textblock* tb;
  region area = {0, 0, 0, 0};
  obj = find_artifact(&a_info[a_idx]);
  if (!obj) {
    fake = true;
    obj = &object_body;
    known_obj = &known_object_body;
    make_fake_artifact(obj, &a_info[a_idx]);
    obj->known = known_obj;
    known_obj->artifact = obj->artifact;
    known_obj->kind = obj->kind;
    if (history_is_artifact_known(player, obj->artifact))
      object_copy(known_obj, obj);
  }
  handle_stuff(player);
  tb = object_info(obj, OINFO_NONE);
  object_desc(header, sizeof(header), obj,
              ODESC_PREFIX | ODESC_FULL | ODESC_CAPITAL, player);
  if (fake) {
    object_wipe(known_obj);
    object_wipe(obj);
  }
  textui_textblock_show(tb, area, header);
  textblock_free(tb);
}
STATIC_OVL int
a_cmp_tval(const void* a, const void* b)
{
  const int a_val = *(const int*)a;
  const int b_val = *(const int*)b;
  const struct artifact* a_a = &a_info[a_val];
  const struct artifact* a_b = &a_info[b_val];
  int ta = obj_group_order[a_a->tval];
  int tb = obj_group_order[a_b->tval];
  int c = ta - tb;
  if (c) return c;
  c = a_a->sval - a_b->sval;
  if (c) return c;
  return strcmp(a_a->name, a_b->name);
}
STATIC_OVL const char*
kind_name(int gid)
{
  return object_text_order[gid].name;
}
STATIC_OVL int
art2gid(int oid)
{
  return obj_group_order[a_info[oid].tval];
}
STATIC_OVL bool
artifact_is_known(int a_idx)
{
  struct object* obj;
  if (!a_info[a_idx].name) return false;
  if (player->wizard) return true;
  if (!is_artifact_created(&a_info[a_idx])) return false;
  obj = find_artifact(&a_info[a_idx]);
  if (obj && !object_is_known_artifact(obj)) return false;
  return true;
}
STATIC_OVL int
collect_known_artifacts(int* artifacts, size_t artifacts_len)
{
  int a_count = 0;
  int j;
  if (artifacts) assert(artifacts_len >= z_info->a_max);
  for (j = 0; j < z_info->a_max; j++) {
    if (!a_info[j].name) continue;
    if (OPT(player, cheat_xtra) || artifact_is_known(j)) {
      if (artifacts)
        artifacts[a_count++] = j;
      else
        a_count++;
    }
  }
  return a_count;
}
STATIC_OVL void
do_cmd_knowledge_artifacts(const char* name, int row)
{
  group_funcs obj_f = {kind_name, a_cmp_tval, art2gid, 0, TV_MAX, false};
  member_funcs art_f = {
      display_artifact, desc_art_fake, 0, 0, recall_prompt, 0, 0};
  int* artifacts;
  int a_count = 0;
  char title[40];
  artifacts = mem_zalloc(z_info->a_max * sizeof(int));
  a_count = collect_known_artifacts(artifacts, z_info->a_max);
  strnfmt(title, sizeof(title), "artifacts");
  display_knowledge(title, artifacts, a_count, obj_f, art_f, NULL);
  mem_free(artifacts);
}
STATIC_OVL const char*
ego_grp_name(int gid)
{
  return object_text_order[gid].name;
}
STATIC_OVL void
display_ego_item(int col, int row, bool cursor, int oid)
{
  struct ego_item* ego = &e_info[default_item_id(oid)];
  uint8_t attr = curs_attrs[0 != (int)ego->everseen][0 != (int)cursor];
  c_prt(attr, ego->name, row, col);
}
STATIC_OVL void
desc_ego_fake(int oid)
{
  int e_idx = default_item_id(oid);
  struct ego_item* ego = &e_info[e_idx];
  textblock* tb;
  region area = {0, 0, 0, 0};
  tb = object_info_ego(ego);
  textui_textblock_show(
      tb, area,
      format("%s %s", ego_grp_name(default_group_id(oid)), ego->name));
  textblock_free(tb);
}
STATIC_OVL int
e_cmp_tval(const void* a, const void* b)
{
  const int a_val = *(const int*)a;
  const int b_val = *(const int*)b;
  const struct ego_item* ea = &e_info[default_item_id(a_val)];
  const struct ego_item* eb = &e_info[default_item_id(b_val)];
  int c = default_group_id(a_val) - default_group_id(b_val);
  if (c) return c;
  return strcmp(ea->name, eb->name);
}
STATIC_OVL void
do_cmd_knowledge_ego_items(const char* name, int row)
{
  group_funcs obj_f = {ego_grp_name, e_cmp_tval, default_group_id, 0,
                       TV_MAX,       false};
  member_funcs ego_f = {
      display_ego_item, desc_ego_fake, 0, 0, recall_prompt, 0, 0};
  int* egoitems;
  int e_count = 0;
  int i;
  int max_pairs = z_info->e_max * N_ELEMENTS(object_text_order);
  egoitems = mem_zalloc(max_pairs * sizeof(int));
  default_join = mem_zalloc(max_pairs * sizeof(join_t));
  for (i = 0; i < z_info->e_max; i++) {
    struct ego_item* ego = &e_info[i];
    if (ego->everseen || OPT(player, cheat_xtra)) {
      size_t j;
      int* tval = mem_zalloc(N_ELEMENTS(object_text_order) * sizeof(int));
      struct poss_item* poss;
      for (poss = ego->poss_items; poss; poss = poss->next) {
        struct object_kind* kind = &k_info[poss->kidx];
        assert(obj_group_order[kind->tval] >= 0);
        tval[obj_group_order[kind->tval]]++;
      }
      for (j = 0; j < TV_MAX; j++) {
        int gid = obj_group_order[j];
        if (gid < 0) continue;
        if ((e_count > 0) && (gid == default_join[e_count - 1].gid) &&
            (i == default_join[e_count - 1].oid))
          continue;
        if (tval[gid]) {
          egoitems[e_count] = e_count;
          default_join[e_count].oid = i;
          default_join[e_count++].gid = gid;
        }
      }
      mem_free(tval);
    }
  }
  display_knowledge("ego items", egoitems, e_count, obj_f, ego_f, NULL);
  mem_free(default_join);
  mem_free(egoitems);
}
STATIC_OVL void
display_object(int col, int row, bool cursor, int oid)
{
  struct object_kind* kind = &k_info[oid];
  const char* inscrip = get_autoinscription(kind, kind->aware);
  char o_name[80];
  bool aware = (!kind->flavor || kind->aware);
  uint8_t attr = curs_attrs[(int)aware][(int)cursor];
  uint8_t a = object_kind_attr(kind);
  wchar_t c = object_kind_char(kind);
  if (!kf_has(kind->kind_flags, KF_INSTA_ART))
    object_kind_name(o_name, sizeof(o_name), kind, OPT(player, cheat_xtra));
  if (kind->tried && !aware) my_strcat(o_name, " {tried}", sizeof(o_name));
  c_prt(attr, o_name, row, col);
  if ((aware && kind_is_ignored_aware(kind)) ||
      (!aware && kind_is_ignored_unaware(kind)))
    c_put_str(attr, "Yes", row, 46);
  if (inscrip) c_put_str(COLOUR_YELLOW, inscrip, row, 55);
  if (tile_height == 1) {
    big_pad(76, row, a, c);
  }
}
STATIC_OVL void
desc_obj_fake(int k_idx)
{
  struct object_kind* kind = &k_info[k_idx];
  struct object_kind* old_kind = player->upkeep->object_kind;
  struct object* old_obj = player->upkeep->object;
  struct object *obj = object_new(), *known_obj = object_new();
  char header[120];
  textblock* tb;
  region area = {0, 0, 0, 0};
  track_object_kind(player->upkeep, kind);
  handle_stuff(player);
  object_prep(obj, kind, 0, EXTREMIFY);
  if (kind->aware || !kind->flavor) object_copy(known_obj, obj);
  obj->known = known_obj;
  handle_stuff(player);
  tb = object_info(obj, OINFO_FAKE);
  object_desc(header, sizeof(header), obj, ODESC_PREFIX | ODESC_CAPITAL,
              player);
  textui_textblock_show(tb, area, header);
  object_delete(NULL, NULL, &known_obj);
  object_delete(NULL, NULL, &obj);
  textblock_free(tb);
  if (old_kind)
    track_object_kind(player->upkeep, old_kind);
  else if (old_obj)
    track_object(player->upkeep, old_obj);
  else
    track_object_cancel(player->upkeep);
}
STATIC_OVL int
o_cmp_tval(const void* a, const void* b)
{
  const int a_val = *(const int*)a;
  const int b_val = *(const int*)b;
  const struct object_kind* k_a = &k_info[a_val];
  const struct object_kind* k_b = &k_info[b_val];
  int ta = obj_group_order[k_a->tval];
  int tb = obj_group_order[k_b->tval];
  int c = ta - tb;
  if (c) return c;
  c = k_a->aware - k_b->aware;
  if (c) return -c;
  switch (k_a->tval) {
    case TV_LIGHT:
      break;
    default:
      if (k_a->aware) return strcmp(k_a->name, k_b->name);
      c = k_a->tried - k_b->tried;
      if (c) return -c;
      return strcmp(k_a->flavor->text, k_b->flavor->text);
  }
  return k_a->sval - k_b->sval;
}
STATIC_OVL int
obj2gid(int oid)
{
  return obj_group_order[k_info[oid].tval];
}
STATIC_OVL wchar_t*
o_xchar(int oid)
{
  struct object_kind* kind = objkind_byid(oid);
  if (!kind) return 0;
  if (!kind->flavor || kind->aware)
    return &kind_x_char[kind->kidx];
  else
    return &flavor_x_char[kind->flavor->fidx];
}
STATIC_OVL uint8_t*
o_xattr(int oid)
{
  struct object_kind* kind = objkind_byid(oid);
  if (!kind) return NULL;
  if (!kind->flavor || kind->aware)
    return &kind_x_attr[kind->kidx];
  else
    return &flavor_x_attr[kind->flavor->fidx];
}
STATIC_OVL const char*
o_xtra_prompt(int oid)
{
  struct object_kind* kind = objkind_byid(oid);
  const char* no_insc = ", 's' to toggle ignore, 'r'ecall, '{'";
  const char* with_insc = ", 's' to toggle ignore, 'r'ecall, '{', '}'";
  if (!kind) return NULL;
  if (kind->aware)
    return kind->note_aware ? with_insc : no_insc;
  else
    return kind->note_unaware ? with_insc : no_insc;
}
STATIC_OVL void
o_xtra_act(struct keypress ch, int oid)
{
  struct object_kind* k = objkind_byid(oid);
  if (!k) return;
  if (ignore_tval(k->tval) && (ch.code == 's' || ch.code == 'S')) {
    if (k->aware) {
      if (kind_is_ignored_aware(k))
        kind_ignore_clear(k);
      else
        kind_ignore_when_aware(k);
    } else {
      if (kind_is_ignored_unaware(k))
        kind_ignore_clear(k);
      else
        kind_ignore_when_unaware(k);
    }
    return;
  }
  if (ch.code == '}') {
    remove_autoinscription(oid);
  } else if (ch.code == '{') {
    char text[80] = "";
    screen_save();
    prt("Inscribe with: ", 0, 0);
    if (k->note_aware || k->note_unaware)
      strnfmt(text, sizeof(text), "%s", get_autoinscription(k, k->aware));
    if (askfor_aux(text, sizeof(text), NULL)) {
      if (k->note_aware || k->note_unaware) remove_autoinscription(oid);
      add_autoinscription(oid, text, k->aware);
      cmdq_push(CMD_AUTOINSCRIBE);
      player->upkeep->redraw |= (PR_INVEN | PR_EQUIP);
    }
    screen_load();
  }
}
STATIC_OVL void
textui_browse_object_knowledge(const char* name, int row)
{
  group_funcs kind_f = {kind_name, o_cmp_tval, obj2gid, 0, TV_MAX, false};
  member_funcs obj_f = {display_object, desc_obj_fake, o_xchar, o_xattr,
                        o_xtra_prompt,  o_xtra_act,    0};
  int* objects;
  int o_count = 0;
  int i;
  struct object_kind* kind;
  objects = mem_zalloc(z_info->k_max * sizeof(int));
  for (i = 0; i < z_info->k_max; i++) {
    kind = &k_info[i];
    if ((kind->everseen || kind->flavor || OPT(player, cheat_xtra)) &&
        (!kf_has(kind->kind_flags, KF_INSTA_ART))) {
      int c = obj_group_order[k_info[i].tval];
      if (c >= 0) objects[o_count++] = i;
    }
  }
  display_knowledge("known objects", objects, o_count, kind_f, obj_f,
                    "Ignore  Inscribed          Sym");
  mem_free(objects);
}
STATIC_OVL void
display_rune(int col, int row, bool cursor, int oid)
{
  uint8_t attr = curs_attrs[CURS_KNOWN][(int)cursor];
  const char* inscrip = quark_str(rune_note(oid));
  c_prt(attr, rune_name(oid), row, col);
  if (inscrip) c_put_str(COLOUR_YELLOW, inscrip, row, 47);
}
STATIC_OVL const char*
rune_var_name(int gid)
{
  return rune_group_text[gid];
}
STATIC_OVL int
rune_var(int oid)
{
  return (int)rune_variety(oid);
}
STATIC_OVL void
rune_lore(int oid)
{
  textblock* tb = textblock_new();
  char* title = string_make(rune_name(oid));
  my_strcap(title);
  textblock_append_c(tb, COLOUR_L_BLUE, "%s", title);
  textblock_append(tb, "\n");
  textblock_append(tb, "%s", rune_desc(oid));
  textblock_append(tb, "\n");
  textui_textblock_show(tb, SCREEN_REGION, NULL);
  textblock_free(tb);
  string_free(title);
}
STATIC_OVL const char*
rune_xtra_prompt(int oid)
{
  const char* no_insc = ", 'r'ecall, '{'";
  const char* with_insc = ", 'r'ecall, '{', '}'";
  return rune_note(oid) ? with_insc : no_insc;
}
STATIC_OVL void
rune_xtra_act(struct keypress ch, int oid)
{
  if (ch.code == '}') {
    rune_set_note(oid, NULL);
  } else if (ch.code == '{') {
    char note_text[80] = "";
    screen_save();
    prt("Inscribe with: ", 0, 0);
    if (rune_note(oid))
      strnfmt(note_text, sizeof(note_text), "%s", quark_str(rune_note(oid)));
    if (askfor_aux(note_text, sizeof(note_text), NULL)) {
      if (rune_note(oid)) rune_set_note(oid, NULL);
      rune_set_note(oid, note_text);
      rune_autoinscribe(player, oid);
      player->upkeep->redraw |= (PR_INVEN | PR_EQUIP);
    }
    screen_load();
  }
}
STATIC_OVL void
do_cmd_knowledge_runes(const char* name, int row)
{
  group_funcs rune_var_f = {
      rune_var_name, NULL, rune_var, 0, N_ELEMENTS(rune_group_text), false};
  member_funcs rune_f = {display_rune,     rune_lore,     NULL, NULL,
                         rune_xtra_prompt, rune_xtra_act, 0};
  int* runes;
  int rune_max = max_runes();
  int count = 0;
  int i;
  char buf[30];
  runes = mem_zalloc(rune_max * sizeof(int));
  for (i = 0; i < rune_max; i++) {
    if (!player_knows_rune(player, i)) continue;
    runes[count++] = i;
  }
  strnfmt(buf, sizeof(buf), "runes (%d unknown)", rune_max - count);
  display_knowledge(buf, runes, count, rune_var_f, rune_f, "Inscribed");
  mem_free(runes);
}
STATIC_OVL void
display_feature(int col, int row, bool cursor, int oid)
{
  struct feature* feat = &f_info[oid];
  uint8_t attr = curs_attrs[CURS_KNOWN][(int)cursor];
  c_prt(attr, feat->name, row, col);
  if (tile_height == 1) {
    col = 65;
    col += big_pad(col, row, feat_x_attr[LIGHTING_DARK][feat->fidx],
                   feat_x_char[LIGHTING_DARK][feat->fidx]);
    col += big_pad(col, row, feat_x_attr[LIGHTING_LIT][feat->fidx],
                   feat_x_char[LIGHTING_LIT][feat->fidx]);
    col += big_pad(col, row, feat_x_attr[LIGHTING_TORCH][feat->fidx],
                   feat_x_char[LIGHTING_TORCH][feat->fidx]);
    (void)big_pad(col, row, feat_x_attr[LIGHTING_LOS][feat->fidx],
                  feat_x_char[LIGHTING_LOS][feat->fidx]);
  }
}
STATIC_OVL int
f_cmp_fkind(const void* a, const void* b)
{
  const int a_val = *(const int*)a;
  const int b_val = *(const int*)b;
  const struct feature* fa = &f_info[a_val];
  const struct feature* fb = &f_info[b_val];
  int c = feat_order(a_val) - feat_order(b_val);
  if (c) return c;
  return strcmp(fa->name, fb->name);
}
STATIC_OVL const char*
fkind_name(int gid)
{
  return feature_group_text[gid];
}
STATIC_OVL uint8_t*
f_xattr(int oid)
{
  return &feat_x_attr[f_uik_lighting][oid];
}
STATIC_OVL wchar_t*
f_xchar(int oid)
{
  return &feat_x_char[f_uik_lighting][oid];
}
STATIC_OVL void
feat_lore(int oid)
{
  struct feature* feat = &f_info[oid];
  if (feat->desc) {
    textblock* tb = textblock_new();
    char* title = string_make(feat->name);
    my_strcap(title);
    textblock_append_c(tb, COLOUR_L_BLUE, "%s", title);
    string_free(title);
    textblock_append(tb, "\n");
    textblock_append(tb, "%s", feat->desc);
    textblock_append(tb, "\n");
    textui_textblock_show(tb, SCREEN_REGION, NULL);
    textblock_free(tb);
  }
}
STATIC_OVL const char*
feat_prompt(int oid)
{
  (void)oid;
  switch (f_uik_lighting) {
    case LIGHTING_LIT:
      return ", 't/T' for lighting (lit)";
    case LIGHTING_TORCH:
      return ", 't/T' for lighting (torch)";
    case LIGHTING_LOS:
      return ", 't/T' for lighting (LOS)";
    default:
      return ", 't/T' for lighting (dark)";
  }
}
STATIC_OVL void
f_xtra_act(struct keypress ch, int oid)
{
  if (ch.code == 't') {
    switch (f_uik_lighting) {
      case LIGHTING_LIT:
        f_uik_lighting = LIGHTING_TORCH;
        break;
      case LIGHTING_TORCH:
        f_uik_lighting = LIGHTING_LOS;
        break;
      case LIGHTING_LOS:
        f_uik_lighting = LIGHTING_DARK;
        break;
      default:
        f_uik_lighting = LIGHTING_LIT;
        break;
    }
  } else if (ch.code == 'T') {
    switch (f_uik_lighting) {
      case LIGHTING_DARK:
        f_uik_lighting = LIGHTING_LOS;
        break;
      case LIGHTING_LOS:
        f_uik_lighting = LIGHTING_TORCH;
        break;
      case LIGHTING_LIT:
        f_uik_lighting = LIGHTING_DARK;
        break;
      default:
        f_uik_lighting = LIGHTING_LIT;
        break;
    }
  }
}
STATIC_OVL void
do_cmd_knowledge_features(const char* name, int row)
{
  group_funcs fkind_f = {
      fkind_name, f_cmp_fkind, feat_order, 0, N_ELEMENTS(feature_group_text),
      false};
  member_funcs feat_f = {display_feature, feat_lore,  f_xchar, f_xattr,
                         feat_prompt,     f_xtra_act, 0};
  int* features;
  int f_count = 0;
  int i;
  features = mem_zalloc(FEAT_MAX * sizeof(int));
  for (i = 0; i < FEAT_MAX; i++) {
    if (f_info[i].name == 0 || f_info[i].mimic) continue;
    features[f_count++] = i;
  }
  display_knowledge("features", features, f_count, fkind_f, feat_f,
                    "                    Sym");
  mem_free(features);
}
STATIC_OVL void
display_trap(int col, int row, bool cursor, int oid)
{
  struct trap_kind* trap = &trap_info[oid];
  uint8_t attr = curs_attrs[CURS_KNOWN][(int)cursor];
  c_prt(attr, trap->desc, row, col);
  if (tile_height == 1) {
    col = 65;
    col += big_pad(col, row, trap_x_attr[LIGHTING_DARK][trap->tidx],
                   trap_x_char[LIGHTING_DARK][trap->tidx]);
    col += big_pad(col, row, trap_x_attr[LIGHTING_LIT][trap->tidx],
                   trap_x_char[LIGHTING_LIT][trap->tidx]);
    col += big_pad(col, row, trap_x_attr[LIGHTING_TORCH][trap->tidx],
                   trap_x_char[LIGHTING_TORCH][trap->tidx]);
    (void)big_pad(col, row, trap_x_attr[LIGHTING_LOS][trap->tidx],
                  trap_x_char[LIGHTING_LOS][trap->tidx]);
  }
}
STATIC_OVL int
trap_order(int trap)
{
  const struct trap_kind* t = &trap_info[trap];
  if (trf_has(t->flags, TRF_GLYPH))
    return 0;
  else if (trf_has(t->flags, TRF_LOCK))
    return 1;
  else if (trf_has(t->flags, TRF_TRAP))
    return 2;
  else
    return 3;
}
STATIC_OVL int
t_cmp_tkind(const void* a, const void* b)
{
  const int a_val = *(const int*)a;
  const int b_val = *(const int*)b;
  const struct trap_kind* ta = &trap_info[a_val];
  const struct trap_kind* tb = &trap_info[b_val];
  int c = trap_order(a_val) - trap_order(b_val);
  if (c) return c;
  if (ta->name) {
    if (tb->name)
      return strcmp(ta->name, tb->name);
    else
      return 1;
  } else if (tb->name) {
    return -1;
  }
  return 0;
}
STATIC_OVL const char*
tkind_name(int gid)
{
  return trap_group_text[gid];
}
STATIC_OVL uint8_t*
t_xattr(int oid)
{
  return &trap_x_attr[t_uik_lighting][oid];
}
STATIC_OVL wchar_t*
t_xchar(int oid)
{
  return &trap_x_char[t_uik_lighting][oid];
}
STATIC_OVL void
trap_lore(int oid)
{
  struct trap_kind* trap = &trap_info[oid];
  if (trap->text) {
    textblock* tb = textblock_new();
    char* title = string_make(trap->desc);
    my_strcap(title);
    textblock_append_c(tb, COLOUR_L_BLUE, "%s", title);
    string_free(title);
    textblock_append(tb, "\n");
    textblock_append(tb, "%s", trap->text);
    textblock_append(tb, "\n");
    textui_textblock_show(tb, SCREEN_REGION, NULL);
    textblock_free(tb);
  }
}
STATIC_OVL const char*
trap_prompt(int oid)
{
  (void)oid;
  return ", 't' to cycle lighting";
}
STATIC_OVL void
t_xtra_act(struct keypress ch, int oid)
{
  if (ch.code == 't') {
    switch (t_uik_lighting) {
      case LIGHTING_LIT:
        t_uik_lighting = LIGHTING_TORCH;
        break;
      case LIGHTING_TORCH:
        t_uik_lighting = LIGHTING_LOS;
        break;
      case LIGHTING_LOS:
        t_uik_lighting = LIGHTING_DARK;
        break;
      default:
        t_uik_lighting = LIGHTING_LIT;
        break;
    }
  } else if (ch.code == 'T') {
    switch (t_uik_lighting) {
      case LIGHTING_DARK:
        t_uik_lighting = LIGHTING_LOS;
        break;
      case LIGHTING_LOS:
        t_uik_lighting = LIGHTING_TORCH;
        break;
      case LIGHTING_LIT:
        t_uik_lighting = LIGHTING_DARK;
        break;
      default:
        t_uik_lighting = LIGHTING_LIT;
        break;
    }
  }
}
STATIC_OVL void
do_cmd_knowledge_traps(const char* name, int row)
{
  group_funcs tkind_f = {
      tkind_name, t_cmp_tkind, trap_order, 0, N_ELEMENTS(trap_group_text),
      false};
  member_funcs trap_f = {display_trap, trap_lore,  t_xchar, t_xattr,
                         trap_prompt,  t_xtra_act, 0};
  int* traps;
  int t_count = 0;
  int i;
  traps = mem_zalloc(z_info->trap_max * sizeof(int));
  for (i = 0; i < z_info->trap_max; i++) {
    if (!trap_info[i].name) continue;
    traps[t_count++] = i;
  }
  display_knowledge("traps", traps, t_count, tkind_f, trap_f,
                    "                    Sym");
  mem_free(traps);
}
STATIC_OVL enum parser_error
parse_monster_category(struct parser* p)
{
  struct ui_knowledge_parse_state* s =
      (struct ui_knowledge_parse_state*)parser_priv(p);
  struct ui_monster_category* c;
  assert(s);
  c = mem_zalloc(sizeof(*c));
  c->next = s->categories;
  c->name = string_make(parser_getstr(p, "name"));
  s->categories = c;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_mcat_include_base(struct parser* p)
{
  struct ui_knowledge_parse_state* s =
      (struct ui_knowledge_parse_state*)parser_priv(p);
  struct monster_base* b;
  assert(s);
  if (!s->categories) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  b = lookup_monster_base(parser_getstr(p, "name"));
  if (!b) {
    return PARSE_ERROR_INVALID_MONSTER_BASE;
  }
  assert(s->categories->n_inc_bases >= 0 &&
         s->categories->n_inc_bases <= s->categories->max_inc_bases);
  if (s->categories->n_inc_bases == s->categories->max_inc_bases) {
    if (s->categories->max_inc_bases >
        INT_MAX / (2 * (int)sizeof(struct monster_base*))) {
      return PARSE_ERROR_TOO_MANY_ENTRIES;
    }
    s->categories->max_inc_bases =
        (s->categories->max_inc_bases) ? 2 * s->categories->max_inc_bases : 2;
    s->categories->inc_bases =
        mem_realloc(s->categories->inc_bases, s->categories->max_inc_bases *
                                                  sizeof(struct monster_base*));
  }
  s->categories->inc_bases[s->categories->n_inc_bases] = b;
  ++s->categories->n_inc_bases;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_mcat_include_flag(struct parser* p)
{
  struct ui_knowledge_parse_state* s =
      (struct ui_knowledge_parse_state*)parser_priv(p);
  char *flags, *next_flag;
  assert(s);
  if (!s->categories) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  if (!parser_hasval(p, "flags")) {
    return PARSE_ERROR_NONE;
  }
  flags = string_make(parser_getstr(p, "flags"));
  next_flag = strtok(flags, " |");
  while (next_flag) {
    if (grab_flag(s->categories->inc_flags, RF_SIZE, r_info_flags, next_flag)) {
      string_free(flags);
      return PARSE_ERROR_INVALID_FLAG;
    }
    next_flag = strtok(NULL, " |");
  }
  string_free(flags);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_mcat_include_glyph(struct parser* p)
{
  struct ui_knowledge_parse_state* s =
      (struct ui_knowledge_parse_state*)parser_priv(p);
  assert(s);
  if (!s->categories) {
    return PARSE_ERROR_MISSING_RECORD_HEADER;
  }
  assert(s->categories->n_inc_glyphs >= 0 &&
         s->categories->n_inc_glyphs <= s->categories->max_inc_glyphs);
  if (s->categories->n_inc_glyphs == s->categories->max_inc_glyphs) {
    if (s->categories->max_inc_glyphs > INT_MAX / (2 * (int)sizeof(wchar_t))) {
      return PARSE_ERROR_TOO_MANY_ENTRIES;
    }
    s->categories->max_inc_glyphs =
        (s->categories->max_inc_glyphs) ? 2 * s->categories->max_inc_glyphs : 4;
    s->categories->inc_glyphs =
        mem_realloc(s->categories->inc_glyphs,
                    s->categories->max_inc_glyphs * sizeof(wchar_t));
  }
  s->categories->inc_glyphs[s->categories->n_inc_glyphs] =
      parser_getchar(p, "glyph");
  ++s->categories->n_inc_glyphs;
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_ui_knowledge_parser(void)
{
  struct ui_knowledge_parse_state* s = mem_zalloc(sizeof(*s));
  struct parser* p = parser_new();
  parser_setpriv(p, s);
  parser_reg(p, "monster-category str name", parse_monster_category);
  parser_reg(p, "mcat-include-base str name", parse_mcat_include_base);
  parser_reg(p, "mcat-include-flag ?str flags", parse_mcat_include_flag);
  parser_reg(p, "mcat-include-glyph char glyph", parse_mcat_include_glyph);
  return p;
}
STATIC_OVL errr
run_ui_knowledge_parser(struct parser* p)
{
  return parse_file_quit_not_found(p, "ui_knowledge");
}
STATIC_OVL errr
finish_ui_knowledge_parser(struct parser* p)
{
  struct ui_knowledge_parse_state* s =
      (struct ui_knowledge_parse_state*)parser_priv(p);
  struct ui_monster_category* cursor;
  size_t count;
  assert(s);
  count = 0;
  for (cursor = s->categories; cursor; cursor = cursor->next) {
    ++count;
  }
  if (count > INT_MAX - 1) {
    cursor = s->categories;
    while (cursor) {
      struct ui_monster_category* tgt = cursor;
      cursor = cursor->next;
      string_free((char*)tgt->name);
      mem_free(tgt->inc_bases);
      mem_free(tgt->inc_glyphs);
      mem_free(tgt);
    }
    mem_free(s);
    parser_destroy(p);
    return PARSE_ERROR_TOO_MANY_ENTRIES;
  }
  if (monster_group) {
    cleanup_ui_knowledge_parsed_data();
  }
  monster_group = mem_alloc((count + 1) * sizeof(*monster_group));
  n_monster_group = (int)(count + 1);
  monster_group[count].next = NULL;
  monster_group[count].name = string_make("***Unclassified***");
  monster_group[count].inc_bases = NULL;
  monster_group[count].inc_glyphs = NULL;
  rf_wipe(monster_group[count].inc_flags);
  monster_group[count].n_inc_bases = 0;
  monster_group[count].max_inc_bases = 0;
  monster_group[count].n_inc_glyphs = 0;
  monster_group[count].max_inc_glyphs = 0;
  cursor = s->categories;
  while (cursor) {
    struct ui_monster_category* src = cursor;
    cursor = cursor->next;
    --count;
    monster_group[count].next = monster_group + count + 1;
    monster_group[count].name = src->name;
    monster_group[count].inc_bases = src->inc_bases;
    monster_group[count].inc_glyphs = src->inc_glyphs;
    rf_copy(monster_group[count].inc_flags, src->inc_flags);
    monster_group[count].n_inc_bases = src->n_inc_bases;
    monster_group[count].max_inc_bases = src->max_inc_bases;
    monster_group[count].n_inc_glyphs = src->n_inc_glyphs;
    monster_group[count].max_inc_glyphs = src->max_inc_glyphs;
    mem_free(src);
  }
  mem_free(s);
  parser_destroy(p);
  return 0;
}
STATIC_OVL void
cleanup_ui_knowledge_parsed_data(void)
{
  int i;
  for (i = 0; i < n_monster_group; ++i) {
    string_free((char*)monster_group[i].name);
    mem_free(monster_group[i].inc_bases);
    mem_free(monster_group[i].inc_glyphs);
  }
  mem_free(monster_group);
  monster_group = NULL;
  n_monster_group = 0;
}
STATIC_OVL void
do_cmd_knowledge_scores(const char* name, int row)
{
  show_scores();
}
STATIC_OVL void
do_cmd_knowledge_history(const char* name, int row)
{
  history_display();
}
STATIC_OVL void
textui_knowledge_init(void)
{
  struct menu* menu = &knowledge_menu;
  menu_init(menu, MN_SKIN_SCROLL, menu_find_iter(MN_ITER_ACTIONS));
  menu_setpriv(menu, N_ELEMENTS(knowledge_actions), knowledge_actions);
  menu->title = "Display current knowledge";
  menu->selections = all_letters_nohjkl;
  if (run_parser(&ui_knowledge_parser) != PARSE_ERROR_NONE) {
    quit_fmt("Encountered error parsing ui_knowledge.txt");
  }
  if (!obj_group_order) {
    int i;
    int gid = -1;
    obj_group_order = mem_zalloc((TV_MAX + 1) * sizeof(int));
    for (i = 0; i < TV_MAX; i++) obj_group_order[i] = -1;
    for (i = 0; 0 != object_text_order[i].tval; i++) {
      if (kb_info[object_text_order[i].tval].num_svals == 0) continue;
      if (object_text_order[i].name) gid = i;
      obj_group_order[object_text_order[i].tval] = gid;
    }
  }
}
STATIC_OVL void
textui_knowledge_cleanup(void)
{
  mem_free(obj_group_order);
  obj_group_order = NULL;
  cleanup_parser(&ui_knowledge_parser);
}
STATIC_OVL void
textui_browse_knowledge(void)
{
  int i;
  region knowledge_region = {0, 0, -1, 2 + (int)N_ELEMENTS(knowledge_actions)};
  if (collect_known_artifacts(NULL, 0) > 0)
    knowledge_actions[1].flags = 0;
  else
    knowledge_actions[1].flags = MN_ACT_GRAYED;
  knowledge_actions[2].flags = MN_ACT_GRAYED;
  for (i = 0; i < z_info->e_max; i++) {
    if (e_info[i].everseen || OPT(player, cheat_xtra)) {
      knowledge_actions[2].flags = 0;
      break;
    }
  }
  if (count_known_monsters() > 0)
    knowledge_actions[3].flags = 0;
  else
    knowledge_actions[3].flags = MN_ACT_GRAYED;
  screen_save();
  menu_layout(&knowledge_menu, &knowledge_region);
  clear_from(0);
  menu_select(&knowledge_menu, 0, false);
  screen_load();
}
STATIC_OVL void
do_cmd_message_one(void)
{
  c_prt(message_color(0), format("> %s", message_str(0)), 0, 0);
}
STATIC_OVL void
do_cmd_messages(void)
{
  ui_event ke;
  bool more = true;
  int i, j, n, q;
  int wid, hgt;
  char shower[80] = "";
  n = messages_num();
  i = 0;
  q = 0;
  Term_get_size(&wid, &hgt);
  screen_save();
  while (more) {
    Term_clear();
    for (j = 0; (j < hgt - 4) && (i + j < n); j++) {
      const char* msg;
      const char* str = message_str(i + j);
      uint8_t attr = message_color(i + j);
      uint16_t count = message_count(i + j);
      if (count == 1)
        msg = str;
      else
        msg = format("%s <%dx>", str, count);
      msg = ((int)strlen(msg) >= q) ? (msg + q) : "";
      Term_putstr(0, hgt - 3 - j, -1, attr, msg);
      if (strlen(shower)) {
        str = msg;
        while ((str = my_stristr(str, shower)) != NULL) {
          int len = strlen(shower);
          Term_putstr(str - msg, hgt - 3 - j, len, COLOUR_YELLOW, str);
          str += len;
        }
      }
    }
    prt(format("Message recall (%d-%d of %d), offset %d", i, i + j - 1, n, q),
        0, 0);
    if (strlen(shower))
      prt("[Movement keys to navigate, '-' for next, '=' to find]", hgt - 1, 0);
    else
      prt("[Movement keys to navigate, '=' to find, or ESCAPE to exit]",
          hgt - 1, 0);
    ke = inkey_ex();
    if (ke.type == EVT_MOUSE) {
      if (ke.mouse.button == 1) {
        if (ke.mouse.y <= hgt / 2) {
          if (i + 20 < n) i += 20;
        } else {
          i = (i >= 20) ? (i - 20) : 0;
        }
      } else if (ke.mouse.button == 2) {
        more = false;
      }
    } else if (ke.type == EVT_KBRD) {
      switch (ke.key.code) {
        case ESCAPE: {
          more = false;
          break;
        }
        case '=': {
          prt("Find: ", hgt - 1, 0);
          if (!askfor_aux(shower, sizeof shower, NULL)) continue;
          ke.key.code = '-';
          break;
        }
        case ARROW_LEFT:
        case '4':
        case 'h':
          q = (q >= wid / 2) ? (q - wid / 2) : 0;
          break;
        case ARROW_RIGHT:
        case '6':
        case 'l':
          q = q + wid / 2;
          break;
        case ARROW_UP:
        case '8':
        case 'k':
          if (i + 1 < n) i += 1;
          break;
        case ARROW_DOWN:
        case '2':
        case 'j':
        case KC_ENTER:
          i = (i >= 1) ? (i - 1) : 0;
          break;
        case KC_PGUP:
        case 'p':
        case ' ':
          if (i + 20 < n) i += 20;
          break;
        case KC_PGDOWN:
        case 'n':
          i = (i >= 20) ? (i - 20) : 0;
          break;
      }
    }
    if (ke.key.code == '-' && strlen(shower)) {
      int16_t z;
      for (z = i + 1; z < n; z++) {
        if (my_stristr(message_str(z), shower)) {
          i = z;
          break;
        }
      }
    }
  }
  screen_load();
}
STATIC_OVL void
do_cmd_inven(void)
{
  struct object* obj = NULL;
  int ret = 3;
  if (player->upkeep->inven[0] == NULL) {
    msg("You have nothing in your inventory.");
    return;
  }
  player->upkeep->command_wrk = (USE_INVEN);
  while (ret == 3) {
    screen_save();
    if (get_item(&obj, "Select Item:",
                 "Error in do_cmd_inven(), please report.", CMD_NULL, NULL,
                 (USE_EQUIP | USE_INVEN | USE_QUIVER | USE_FLOOR | SHOW_EMPTY |
                  IS_HARMLESS))) {
      screen_load();
      if (obj && obj->kind) {
        track_object(player->upkeep, obj);
        while ((ret = context_menu_object(obj)) == 2)
          ;
      }
    } else {
      screen_load();
      ret = -1;
    }
  }
}
STATIC_OVL void
do_cmd_equip(void)
{
  struct object* obj = NULL;
  int ret = 3;
  if (!player->upkeep->equip_cnt) {
    msg("You are not wielding or wearing anything.");
    return;
  }
  player->upkeep->command_wrk = (USE_EQUIP);
  while (ret == 3) {
    screen_save();
    if (get_item(&obj, "Select Item:",
                 "Error in do_cmd_equip(), please report.", CMD_NULL, NULL,
                 (USE_EQUIP | USE_INVEN | USE_QUIVER | USE_FLOOR | SHOW_EMPTY |
                  IS_HARMLESS))) {
      screen_load();
      if (obj && obj->kind) {
        track_object(player->upkeep, obj);
        while ((ret = context_menu_object(obj)) == 2)
          ;
        player->upkeep->command_wrk = (USE_EQUIP);
      }
    } else {
      screen_load();
      ret = -1;
    }
  }
}
STATIC_OVL void
do_cmd_look(void)
{
  if (target_set_interactive(TARGET_LOOK, loc(-1, -1), 0)) {
    msg("Target Selected.");
  }
}
STATIC_OVL void
do_cmd_locate(void)
{
  int panel_hgt, panel_wid;
  int y1, x1;
  if (Term == term_screen) {
    panel_hgt = SCREEN_HGT;
    panel_wid = SCREEN_WID;
  } else {
    panel_hgt = Term->hgt / tile_height;
    panel_wid = Term->wid / tile_width;
  }
  panel_hgt = MAX(panel_hgt, 1);
  panel_wid = MAX(panel_wid, 1);
  y1 = Term->offset_y;
  x1 = Term->offset_x;
  while (1) {
    char tmp_val[80];
    char out_val[160];
    int dir = 0;
    int y2 = Term->offset_y;
    int x2 = Term->offset_x;
    if ((y2 == y1) && (x2 == x1)) {
      tmp_val[0] = '\0';
    } else {
      strnfmt(tmp_val, sizeof(tmp_val), "%s%s of",
              ((y2 < y1)   ? " north"
               : (y2 > y1) ? " south"
                           : ""),
              ((x2 < x1)   ? " west"
               : (x2 > x1) ? " east"
                           : ""));
    }
    strnfmt(out_val, sizeof(out_val),
            "Map sector [%d,%d], which is%s your sector.  Direction?",
            (2 * y2) / panel_hgt, (2 * x2) / panel_wid, tmp_val);
    if (OPT(player, center_player)) {
      strnfmt(
          out_val, sizeof(out_val),
          "Map sector [%d(%02d),%d(%02d)], which is%s your sector.  Direction?",
          (2 * y2) / panel_hgt, (2 * y2) % panel_hgt, (2 * x2) / panel_wid,
          (2 * x2) % panel_wid, tmp_val);
    }
    while (!dir) {
      struct keypress command = KEYPRESS_NULL;
      if (!get_com(out_val, (char*)&command.code)) break;
      dir = target_dir(command);
      if (!dir) bell();
    }
    if (!dir) break;
    change_panel(dir);
    handle_stuff(player);
  }
  verify_panel();
}
STATIC_OVL int
cmp_level(const void* a, const void* b)
{
  uint16_t ia = *(const uint16_t*)a;
  uint16_t ib = *(const uint16_t*)b;
  if (r_info[ia].level < r_info[ib].level) return -1;
  return 1;
}
STATIC_OVL int
cmp_tkill(const void* a, const void* b)
{
  uint16_t ia = *(const uint16_t*)a;
  uint16_t ib = *(const uint16_t*)b;
  if (l_list[ia].tkills < l_list[ib].tkills) return -1;
  if (l_list[ia].tkills > l_list[ib].tkills) return 1;
  return cmp_level(a, b);
}
STATIC_OVL int
cmp_pkill(const void* a, const void* b)
{
  uint16_t ia = *(const uint16_t*)a;
  uint16_t ib = *(const uint16_t*)b;
  if (l_list[ia].pkills < l_list[ib].pkills) return -1;
  if (l_list[ia].pkills > l_list[ib].pkills) return 1;
  return cmp_tkill(a, b);
}
STATIC_OVL int
cmp_monsters(const void* a, const void* b)
{
  return cmp_level(a, b);
}
STATIC_OVL void
lookup_symbol(char sym, char* buf, size_t max)
{
  int i;
  struct monster_base* base;
  struct monster_race* race;
  for (i = 0; i < z_info->k_max; i++) {
    if (char_matches_key(k_info[i].d_char, sym)) {
      strnfmt(buf, max, "%c - %s.", sym, tval_find_name(k_info[i].tval));
      return;
    }
  }
  for (i = 1; i < FEAT_MAX; i++) {
    if (char_matches_key(f_info[i].d_char, sym)) {
      strnfmt(buf, max, "%c - %s.", sym, f_info[i].name);
      return;
    }
  }
  for (base = rb_info; base; base = base->next) {
    if (streq(base->name, "Morgoth")) continue;
    if (char_matches_key(base->d_char, sym)) {
      strnfmt(buf, max, "%c - %s.", sym, base->text);
      return;
    }
  }
  for (race = r_info; race; race = race->next) {
    if (streq(race->name, "Morgoth")) continue;
    if (char_matches_key(race->d_char, sym)) {
      strnfmt(buf, max, "%c - %s.", sym, race->name);
      return;
    }
  }
  if (isprint(sym)) {
    strnfmt(buf, max, "%c - Unknown Symbol.", sym);
  } else {
    strnfmt(buf, max, "? - Unknown Symbol.");
  }
  return;
}
STATIC_OVL void
do_cmd_query_symbol(void)
{
  int idx, num;
  char buf[128];
  char sym;
  struct keypress query;
  bool all = false;
  bool uniq = false;
  bool norm = false;
  bool recall = false;
  uint16_t* who;
  if (!get_com("Enter character to be identified, or control+[ANU]: ", &sym))
    return;
  if (sym == KTRL('A')) {
    all = true;
    my_strcpy(buf, "Full monster list.", sizeof(buf));
  } else if (sym == KTRL('U')) {
    all = uniq = true;
    my_strcpy(buf, "Unique monster list.", sizeof(buf));
  } else if (sym == KTRL('N')) {
    all = norm = true;
    my_strcpy(buf, "Non-unique monster list.", sizeof(buf));
  } else {
    lookup_symbol(sym, buf, sizeof(buf));
  }
  prt(buf, 0, 0);
  who = mem_zalloc(z_info->r_max * sizeof(uint16_t));
  for (num = 0, idx = 1; idx < z_info->r_max - 1; idx++) {
    struct monster_race* race = &r_info[idx];
    struct monster_lore* lore = &l_list[idx];
    if (!lore->all_known && !lore->psights) continue;
    if (norm && rf_has(race->flags, RF_UNIQUE)) continue;
    if (uniq && !rf_has(race->flags, RF_UNIQUE)) continue;
    if (all || char_matches_key(race->d_char, sym)) who[num++] = idx;
  }
  if (!num) {
    mem_free(who);
    return;
  }
  put_str("Recall details? (y/k/n): ", 0, 40);
  query = inkey();
  prt(buf, 0, 0);
  if (query.code == 'k') {
    sort(who, num, sizeof(*who), cmp_pkill);
  } else if (query.code == 'y' || query.code == 'p') {
    sort(who, num, sizeof(*who), cmp_level);
  } else {
    mem_free(who);
    return;
  }
  idx = num - 1;
  while (1) {
    textblock* tb;
    int r_idx = who[idx];
    struct monster_race* race = &r_info[r_idx];
    struct monster_lore* lore = &l_list[r_idx];
    monster_race_track(player->upkeep, race);
    handle_stuff(player);
    tb = textblock_new();
    lore_title(tb, race);
    textblock_append(tb, " [(r)ecall, ESC]");
    textui_textblock_place(tb, SCREEN_REGION, NULL);
    textblock_free(tb);
    while (1) {
      if (recall)
        lore_show_interactive(race, lore);
      else
        query = inkey();
      if (query.code != 'r') break;
      recall = !recall;
    }
    if (query.code == ESCAPE) break;
    if (query.code == '-') {
      idx++;
      if (idx == num) {
        idx = 0;
      }
    } else {
      idx--;
      if (idx < 0) {
        idx = num - 1;
      }
    }
  }
  prt(buf, 0, 0);
  mem_free(who);
}
STATIC_OVL void
do_cmd_center_map(void)
{
  center_panel();
}
STATIC_OVL void
do_cmd_monlist(void)
{
  screen_save();
  monster_list_show_interactive(Term->hgt, Term->wid);
  screen_load();
}
STATIC_OVL void
do_cmd_itemlist(void)
{
  screen_save();
  object_list_show_interactive(Term->hgt, Term->wid);
  screen_load();
}
STATIC_OVL void
hallucinatory_monster(int midx, int* a, wchar_t* c)
{
  struct monster_race* race = cave_monster(cave, midx)->image_race;
  if (!race->name) return;
  *a = monster_x_attr[race->ridx];
  *c = monster_x_char[race->ridx];
}
STATIC_OVL void
image_monster(int* a, wchar_t* c)
{
  while (1) {
    struct monster_race* race = &r_info[randint0(z_info->r_max)];
    if (!race->name) continue;
    *a = monster_x_attr[race->ridx];
    *c = monster_x_char[race->ridx];
    return;
  }
}
STATIC_OVL void
image_object(int* a, wchar_t* c)
{
  while (1) {
    struct object_kind* kind = &k_info[randint0(z_info->k_max - 1) + 1];
    if (!kind->name) continue;
    *a = kind_x_attr[kind->kidx];
    *c = kind_x_char[kind->kidx];
    if (*a == 0 || *c == 0) continue;
    return;
  }
}
STATIC_OVL void
get_trap_graphics(struct chunk* c, struct grid_data* g, int* a, wchar_t* w)
{
  if (trf_has(g->trap->flags, TRF_VISIBLE) ||
      trf_has(g->trap->flags, TRF_GLYPH)) {
    *a = trap_x_attr[g->lighting][g->trap->kind->tidx];
    *w = trap_x_char[g->lighting][g->trap->kind->tidx];
  }
}
STATIC_OVL void
grid_get_attr(struct grid_data* g, int* a)
{
  int a0 = *a & 0x80;
  *a = (*a & 0x7F);
  if (feat_is_torch(g->f_idx)) {
    switch (g->lighting) {
      case LIGHTING_TORCH:
        *a = get_color(*a, ATTR_LIGHT, 1);
        break;
      case LIGHTING_LIT:
        *a = get_color(*a, ATTR_DARK, 1);
        break;
      case LIGHTING_DARK:
        *a = get_color(*a, ATTR_DARK, 2);
        break;
      default:
        break;
    }
  }
  if (a0) {
    *a = a0 | *a;
  }
  if (use_graphics == GRAPHICS_NONE &&
      (feat_is_wall(g->f_idx) || feat_is_chasm(g->f_idx))) {
    if (OPT(player, hybrid_walls))
      *a = *a + (MULT_BG * BG_DARK);
    else if (OPT(player, solid_walls))
      *a = *a + (MULT_BG * BG_SAME);
  }
}
STATIC_OVL void
grid_data_as_text(struct grid_data* g, int* ap, wchar_t* cp, int* tap,
                  wchar_t* tcp)
{
  struct feature* feat = &f_info[g->f_idx];
  int a = feat_x_attr[g->lighting][feat->fidx];
  wchar_t c = feat_x_char[g->lighting][feat->fidx];
  if (use_graphics == GRAPHICS_NONE) {
    grid_get_attr(g, &a);
    if (g->rage) a = COLOUR_RED + (MULT_BG * (a / MULT_BG));
  }
  (*tap) = a;
  (*tcp) = c;
  if (g->trap && (!g->hallucinate)) {
    get_trap_graphics(cave, g, &a, &c);
  }
  if (g->first_kind) {
    if (g->hallucinate) {
      image_object(&a, &c);
    } else if (g->multiple_objects) {
      a = object_kind_attr(pile_kind);
      c = object_kind_char(pile_kind);
    } else {
      a = (g->first_art) ? g->first_art->d_attr
                         : object_kind_attr(g->first_kind);
      if (g->glow) {
        if (use_graphics == GRAPHICS_NONE || !(a & 0x80)) {
          a = COLOUR_L_BLUE;
        } else if (glow_x_attr & 0x80) {
          a |= GRAPHICS_GLOW_MASK;
        }
      }
      c = object_kind_char(g->first_kind);
    }
    if (g->rage && (use_graphics == GRAPHICS_NONE || !(a & 0x80)))
      a = COLOUR_RED;
  }
  if (g->m_idx > 0) {
    struct monster* mon = cave_monster(cave, g->m_idx);
    if (g->hallucinate) {
      if (g->m_idx < z_info->r_max) {
        hallucinatory_monster(g->m_idx, &a, &c);
      } else {
        image_monster(&a, &c);
      }
    } else if (monster_is_listened(mon)) {
      a = COLOUR_SLATE;
      c = '*';
    } else {
      uint8_t da;
      wchar_t dc;
      da = monster_x_attr[mon->race->ridx];
      dc = monster_x_char[mon->race->ridx];
      if (da & 0x80) {
        a = da;
        c = dc;
      } else if (rf_has(mon->race->flags, RF_ATTR_MULTI) ||
                 rf_has(mon->race->flags, RF_ATTR_FLICKER)) {
        a = mon->attr ? mon->attr : da;
        c = dc;
      } else if (!flags_test(mon->race->flags, RF_SIZE, RF_CHAR_CLEAR,
                             FLAG_END)) {
        a = da;
        dc = monster_x_char[mon->race->ridx];
        c = dc;
      } else if (a & 0x80) {
        a = da;
        c = dc;
      } else if (!rf_has(mon->race->flags, RF_CHAR_CLEAR)) {
        c = dc;
      }
      mon->attr = a;
      if (use_graphics == GRAPHICS_NONE && OPT(player, highlight_unwary) &&
          (mon->alertness < ALERTNESS_ALERT)) {
        a = a + (MULT_BG * BG_DARK);
      }
      if (use_graphics != GRAPHICS_NONE && (a & 0x80) &&
          mon->alertness >= ALERTNESS_ALERT && alert_x_attr & 0x80) {
        a |= GRAPHICS_ALERT_MASK;
      }
      if (g->rage && (use_graphics == GRAPHICS_NONE || !(a & 0x80)))
        a = COLOUR_RED;
    }
  } else if (g->is_player) {
    struct monster_race* race = &r_info[0];
    a = monster_x_attr[race->ridx];
    if (!(a & 0x80)) {
      a = health_attr(player->chp, player->mhp);
    }
    c = monster_x_char[race->ridx];
  }
  (*ap) = a;
  (*cp) = c;
}
STATIC_OVL void
get_minimap_dimensions(term* t, const struct chunk* c, int tw, int th, int* mw,
                       int* mh)
{
  int map_height = t->hgt - 2;
  int map_width = t->wid - 2;
  int cave_height = c->height;
  int cave_width = c->width;
  int remainder;
  if (th > 1) {
    remainder = cave_height % th;
    if (remainder > 0) {
      cave_height += th - remainder;
    }
    map_height -= map_height % th;
  }
  if (tw > 1) {
    remainder = cave_width % tw;
    if (remainder > 0) {
      cave_width += tw - remainder;
    }
    map_width -= map_width % tw;
  }
  *mh = MIN(map_height, cave_height);
  *mw = MIN(map_width, cave_width);
}
STATIC_OVL void
move_cursor_relative_map(int y, int x)
{
  int ky, kx;
  term* old;
  int j;
  for (j = 0; j < ANGBAND_TERM_MAX; j++) {
    term* t = angband_term[j];
    if (!t) continue;
    if (!(window_flag[j] & (PW_MAPS))) continue;
    if (window_flag[j] & PW_MAP) {
      int map_width, map_height;
      get_minimap_dimensions(t, cave, tile_width, tile_height, &map_width,
                             &map_height);
      ky = (y * map_height) / cave->height;
      if (tile_height > 1) {
        ky = ky - (ky % tile_height) + 1;
      } else {
        ++ky;
      }
      kx = (x * map_width) / cave->width;
      if (tile_width > 1) {
        kx = kx - (kx % tile_width) + 1;
      } else {
        ++kx;
      }
    } else {
      ky = y - t->offset_y;
      if (tile_height > 1) ky = tile_height * ky;
      kx = x - t->offset_x;
      if (tile_width > 1) kx = tile_width * kx;
    }
    if ((ky < 0) || (ky >= t->hgt)) continue;
    if ((kx < 0) || (kx >= t->wid)) continue;
    old = Term;
    Term_activate(t);
    (void)Term_gotoxy(kx, ky);
    Term_activate(old);
  }
}
STATIC_OVL void
move_cursor_relative(int y, int x)
{
  int ky, kx;
  int vy, vx;
  move_cursor_relative_map(y, x);
  ky = y - Term->offset_y;
  if ((ky < 0) || (ky >= SCREEN_HGT)) return;
  kx = x - Term->offset_x;
  if ((kx < 0) || (kx >= SCREEN_WID)) return;
  vy = ky + ROW_MAP;
  vx = kx + COL_MAP;
  if (tile_width > 1) vx += (tile_width - 1) * kx;
  if (tile_height > 1) vy += (tile_height - 1) * ky;
  (void)Term_gotoxy(vx, vy);
}
STATIC_OVL void
print_rel_map(wchar_t c, uint8_t a, int y, int x)
{
  int ky, kx;
  int j;
  for (j = 0; j < ANGBAND_TERM_MAX; j++) {
    term* t = angband_term[j];
    if (!t) continue;
    if (!(window_flag[j] & (PW_MAPS))) continue;
    if (window_flag[j] & PW_MAP) {
      int map_width, map_height;
      get_minimap_dimensions(t, cave, tile_width, tile_height, &map_width,
                             &map_height);
      kx = (x * map_width) / cave->width;
      ky = (y * map_height) / cave->height;
      if (tile_width > 1) {
        kx = kx - (kx % tile_width) + 1;
      } else {
        ++kx;
      }
      if (tile_height > 1) {
        ky = ky - (ky % tile_height) + 1;
      } else {
        ++ky;
      }
    } else {
      ky = y - t->offset_y;
      if (tile_height > 1) {
        ky = tile_height * ky;
        if (ky + 1 >= t->hgt) continue;
      }
      kx = x - t->offset_x;
      if (tile_width > 1) {
        kx = tile_width * kx;
        if (kx + 1 >= t->wid) continue;
      }
    }
    if ((ky < 0) || (ky >= t->hgt)) continue;
    if ((kx < 0) || (kx >= t->wid)) continue;
    Term_queue_char(t, kx, ky, a, c, 0, 0);
    if ((tile_width > 1) || (tile_height > 1))
      Term_big_queue_char(
          t, kx, ky,
          t->hgt - ((window_flag[j] & PW_OVERHEAD) ? 0 : ROW_BOTTOM_MAP), a, c,
          0, 0);
  }
}
STATIC_OVL void
print_rel(wchar_t c, uint8_t a, int y, int x)
{
  int ky, kx;
  int vy, vx;
  print_rel_map(c, a, y, x);
  ky = y - Term->offset_y;
  if ((ky < 0) || (ky >= SCREEN_HGT)) return;
  kx = x - Term->offset_x;
  if ((kx < 0) || (kx >= SCREEN_WID)) return;
  vx = COL_MAP + (tile_width * kx);
  vy = ROW_MAP + (tile_height * ky);
  Term_queue_char(Term, vx, vy, a, c, 0, 0);
  if ((tile_width > 1) || (tile_height > 1))
    Term_big_queue_char(Term, vx, vy, ROW_MAP + SCREEN_ROWS, a, c, 0, 0);
}
STATIC_OVL void
prt_map_aux(void)
{
  int a, ta;
  wchar_t c, tc;
  struct grid_data g;
  int y, x;
  int vy, vx;
  int ty, tx;
  int j;
  for (j = 0; j < ANGBAND_TERM_MAX; j++) {
    term* t = angband_term[j];
    int clipy;
    if (!t) continue;
    if (!(window_flag[j] & (PW_MAPS))) continue;
    if (window_flag[j] & PW_MAP) {
      term* old = Term;
      Term_activate(t);
      display_map(NULL, NULL);
      Term_activate(old);
      continue;
    }
    ty = t->offset_y + (t->hgt / tile_height);
    tx = t->offset_x + (t->wid / tile_width);
    clipy = t->hgt - ((window_flag[j] & PW_OVERHEAD) ? 0 : ROW_BOTTOM_MAP);
    for (y = t->offset_y, vy = 0; y < ty; vy += tile_height, y++) {
      for (x = t->offset_x, vx = 0; x < tx; vx += tile_width, x++) {
        if (!square_in_bounds(cave, loc(x, y))) {
          Term_queue_char(t, vx, vy, COLOUR_WHITE, ' ', 0, 0);
          if (tile_width > 1 || tile_height > 1) {
            Term_big_queue_char(t, vx, vy, clipy, COLOUR_WHITE, ' ', 0, 0);
          }
          continue;
        }
        map_info(loc(x, y), &g);
        grid_data_as_text(&g, &a, &c, &ta, &tc);
        Term_queue_char(t, vx, vy, a, c, ta, tc);
        if ((tile_width > 1) || (tile_height > 1))
          Term_big_queue_char(t, vx, vy, clipy, 255, -1, 0, 0);
      }
      for (; vx < t->wid; ++vx) {
        Term_queue_char(t, vx, vy, COLOUR_WHITE, ' ', 0, 0);
      }
    }
    for (; vy < t->hgt; ++vy) {
      for (vx = 0; vx < t->wid; ++vx) {
        Term_queue_char(t, vx, vy, COLOUR_WHITE, ' ', 0, 0);
      }
    }
  }
}
STATIC_OVL void
prt_map(void)
{
  int a, ta;
  wchar_t c, tc;
  struct grid_data g;
  int y, x;
  int vy, vx;
  int ty, tx;
  int clipy;
  prt_map_aux();
  ty = Term->offset_y + SCREEN_HGT;
  tx = Term->offset_x + SCREEN_WID;
  clipy = ROW_MAP + SCREEN_ROWS;
  for (y = Term->offset_y, vy = ROW_MAP; y < ty; vy += tile_height, y++)
    for (x = Term->offset_x, vx = COL_MAP; x < tx; vx += tile_width, x++) {
      if (!square_in_bounds(cave, loc(x, y))) continue;
      map_info(loc(x, y), &g);
      grid_data_as_text(&g, &a, &c, &ta, &tc);
      Term_queue_char(Term, vx, vy, a, c, ta, tc);
      if ((tile_width > 1) || (tile_height > 1))
        Term_big_queue_char(Term, vx, vy, clipy, a, c, COLOUR_WHITE, L' ');
    }
}
STATIC_OVL void
display_map(int* cy, int* cx)
{
  int map_hgt, map_wid;
  int row, col;
  int x, y;
  struct grid_data g;
  int a, ta;
  wchar_t c, tc;
  uint8_t tp;
  struct monster_race* race = &r_info[0];
  uint8_t** mp = mem_zalloc(cave->height * sizeof(uint8_t*));
  for (y = 0; y < cave->height; y++)
    mp[y] = mem_zalloc(cave->width * sizeof(uint8_t));
  get_minimap_dimensions(Term, cave, tile_width, tile_height, &map_wid,
                         &map_hgt);
  if ((map_wid < 1) || (map_hgt < 1)) {
    for (y = 0; y < cave->height; y++) mem_free(mp[y]);
    mem_free(mp);
    return;
  }
  a = COLOUR_WHITE;
  c = L' ';
  ta = COLOUR_WHITE;
  tc = L' ';
  window_make(0, 0, map_wid + 1, map_hgt + 1);
  if (map_wid + 1 < Term->wid - 1) {
    for (y = 0; y < map_hgt + 1; y++) {
      Term_erase(map_wid + 2, y, Term->wid - map_wid - 2);
    }
  }
  if (map_hgt + 1 < Term->hgt - 1) {
    for (y = map_hgt + 2; y < Term->hgt; y++) {
      Term_erase(0, y, Term->wid);
    }
  }
  for (y = 0; y < cave->height; y++) {
    row = (y * map_hgt) / cave->height;
    if (tile_height > 1) row = row - (row % tile_height);
    for (x = 0; x < cave->width; x++) {
      col = (x * map_wid) / cave->width;
      if (tile_width > 1) col = col - (col % tile_width);
      map_info(loc(x, y), &g);
      grid_data_as_text(&g, &a, &c, &ta, &tc);
      tp = f_info[g.f_idx].priority;
      if ((a != ta) || (c != tc)) tp = 20;
      if (mp[row][col] < tp) {
        g.lighting = LIGHTING_LIT;
        grid_data_as_text(&g, &a, &c, &ta, &tc);
        Term_queue_char(Term, col + 1, row + 1, a, c, ta, tc);
        if ((tile_width > 1) || (tile_height > 1))
          Term_big_queue_char(Term, col + 1, row + 1, Term->hgt - 1, 255, -1, 0,
                              0);
        mp[row][col] = tp;
      }
    }
  }
  row = (player->grid.y * map_hgt / cave->height);
  col = (player->grid.x * map_wid / cave->width);
  if (tile_width > 1) col = col - (col % tile_width);
  if (tile_height > 1) row = row - (row % tile_height);
  map_info(player->grid, &g);
  g.lighting = LIGHTING_LIT;
  grid_data_as_text(&g, &a, &c, &ta, &tc);
  a = monster_x_attr[race->ridx];
  c = monster_x_char[race->ridx];
  Term_queue_char(Term, col + 1, row + 1, a, c, ta, tc);
  if ((tile_width > 1) || (tile_height > 1))
    Term_big_queue_char(Term, col + 1, row + 1, Term->hgt - 1, 255, -1, 0, 0);
  if (cy != NULL) (*cy) = row + 1;
  if (cx != NULL) (*cx) = col + 1;
  for (y = 0; y < cave->height; y++) mem_free(mp[y]);
  mem_free(mp);
}
STATIC_OVL void
do_cmd_view_map(void)
{
  int cy, cx;
  uint8_t w, h;
  const char* prompt = "Hit any key to continue";
  if (Term->view_map_hook) {
    (*(Term->view_map_hook))(Term);
    return;
  }
  screen_save();
  prt("Please wait...", 0, 0);
  Term_fresh();
  Term_clear();
  w = tile_width;
  h = tile_height;
  tile_width = 1;
  tile_height = 1;
  display_map(&cy, &cx);
  put_str(prompt, Term->hgt - 1, Term->wid / 2 - strlen(prompt) / 2);
  Term_gotoxy(cx, cy);
  (void)anykey();
  tile_width = w;
  tile_height = h;
  screen_load();
}
STATIC_OVL void
mini_screenshot(game_event_type type, game_event_data* data, void* user)
{
  int x, y;
  if (!player->escaped) {
    for (y = -3; y <= 3; y++) {
      for (x = -3; x <= 3; x++) {
        struct grid_data g;
        int a, ta;
        wchar_t c, tc;
        struct loc grid = loc(player->grid.x + x, player->grid.y + y);
        if (square_in_bounds(cave, grid)) {
          map_info(grid, &g);
          grid_data_as_text(&g, &a, &c, &ta, &tc);
          mini_screenshot_char[y + 3][x + 3] = c;
          mini_screenshot_attr[y + 3][x + 3] = a;
        } else {
          mini_screenshot_char[y + 3][x + 3] = ' ';
          mini_screenshot_attr[y + 3][x + 3] = COLOUR_DARK;
        }
      }
    }
  } else {
    for (y = -3; y <= 3; y++) {
      for (x = -3; x <= 3; x++) {
        mini_screenshot_char[y + 3][x + 3] = '.';
        mini_screenshot_attr[y + 3][x + 3] = COLOUR_L_GREEN;
      }
    }
    mini_screenshot_char[0][1] = '~';
    mini_screenshot_attr[0][1] = COLOUR_BLUE;
    mini_screenshot_char[0][2] = '~';
    mini_screenshot_attr[0][2] = COLOUR_BLUE;
    mini_screenshot_char[1][2] = '~';
    mini_screenshot_attr[1][2] = COLOUR_L_BLUE;
    mini_screenshot_char[1][3] = '~';
    mini_screenshot_attr[1][3] = COLOUR_BLUE;
    mini_screenshot_char[1][4] = '~';
    mini_screenshot_attr[1][4] = COLOUR_L_BLUE;
    mini_screenshot_char[2][4] = '~';
    mini_screenshot_attr[2][4] = COLOUR_BLUE;
    mini_screenshot_char[2][5] = '~';
    mini_screenshot_attr[2][5] = COLOUR_BLUE;
    mini_screenshot_char[3][5] = '~';
    mini_screenshot_attr[3][5] = COLOUR_L_BLUE;
    mini_screenshot_char[3][6] = '~';
    mini_screenshot_attr[3][6] = COLOUR_BLUE;
    mini_screenshot_char[4][1] = '+';
    mini_screenshot_attr[4][1] = COLOUR_GREEN;
    mini_screenshot_char[6][4] = '+';
    mini_screenshot_attr[6][4] = COLOUR_GREEN;
    mini_screenshot_char[3][3] = '@';
    mini_screenshot_attr[3][3] = COLOUR_WHITE;
  }
}
STATIC_OVL void
prt_mini_screenshot(int col, int row)
{
  int x, y;
  for (y = 0; y <= 6; y++) {
    for (x = 0; x <= 6; x++) {
      Term_putch(col + x, row + y, mini_screenshot_attr[y][x],
                 mini_screenshot_char[y][x]);
    }
  }
}
STATIC_OVL void
file_mini_screenshot(ang_file* fff)
{
  int x, y;
  for (y = 0; y <= 6; y++) {
    file_putf(fff, "  ");
    for (x = 0; x <= 6; x++) {
      uint8_t c =
          (mini_screenshot_char[y][x] < 32) ? '.' : mini_screenshot_char[y][x];
      file_putf(fff, "%c", c);
    }
    file_putf(fff, "\n");
  }
}
STATIC_OVL void
display_action_aux(menu_action* act, uint8_t color, int row, int col, int wid)
{
  Term_erase(col, row, wid);
  if (act->name) Term_putstr(col, row, wid, color, act->name);
}
STATIC_OVL char
menu_action_tag(struct menu* m, int oid)
{
  menu_action* acts = menu_priv(m);
  return acts[oid].tag;
}
STATIC_OVL int
menu_action_valid(struct menu* m, int oid)
{
  menu_action* acts = menu_priv(m);
  if (acts[oid].flags & MN_ACT_HIDDEN) return MN_ROW_HIDDEN;
  if (acts[oid].flags & MN_ACT_MAYBE) return MN_ROW_MAYBE;
  return acts[oid].name ? MN_ROW_VALID : MN_ROW_INVALID;
}
STATIC_OVL void
menu_action_display(struct menu* m, int oid, bool cursor, int row, int col,
                    int width)
{
  menu_action* acts = menu_priv(m);
  uint8_t act = acts[oid].flags & MN_ACT_GRAYED
                    ? 0
                    : (acts[oid].flags & MN_ACT_MAYBE ? 2 : 1);
  uint8_t color = curs_attrs[act][0 != cursor];
  display_action_aux(&acts[oid], color, row, col, width);
}
STATIC_OVL bool
menu_action_handle(struct menu* m, const ui_event* event, int oid)
{
  menu_action* acts = menu_priv(m);
  if (event->type == EVT_SELECT) {
    if (!(acts->flags & MN_ACT_GRAYED) && acts[oid].action) {
      acts[oid].action(acts[oid].name, m->cursor);
      return true;
    }
  } else if (m->keys_hook && event->type == EVT_KBRD) {
    return m->keys_hook(m, event, oid);
  }
  return false;
}
STATIC_OVL void
display_string(struct menu* m, int oid, bool cursor, int row, int col,
               int width)
{
  const char** items = menu_priv(m);
  uint8_t color = curs_attrs[CURS_KNOWN][0 != cursor];
  Term_putstr(col, row, width, color, items[oid]);
}
STATIC_OVL bool
handle_string(struct menu* m, const ui_event* event, int oid)
{
  if (m->keys_hook && event->type == EVT_KBRD) {
    return m->keys_hook(m, event, oid);
  }
  return false;
}
STATIC_OVL int
scrolling_get_cursor(int row, int col, int n, int top, region* loc)
{
  int cursor = row - loc->row + top;
  if (cursor >= n) cursor = n - 1;
  return cursor;
}
STATIC_OVL void
display_scrolling(struct menu* menu, int cursor, int* top, region* loc)
{
  int col = loc->col;
  int row = loc->row;
  int rows_per_page = loc->page_rows;
  int n = menu->filter_list ? menu->filter_count : menu->count;
  int i;
  if ((cursor <= *top) && (*top > 0)) *top = cursor - 1;
  if (cursor >= *top + (rows_per_page - 1))
    *top = cursor - (rows_per_page - 1) + 1;
  *top = MIN(*top, n - rows_per_page);
  *top = MAX(*top, 0);
  for (i = 0; i < rows_per_page; i++) {
    Term_erase(col, row + i, loc->width);
    if (i < n) {
      bool is_curs = (i == cursor - *top);
      display_menu_row(menu, i + *top, *top, is_curs, row + i, col, loc->width);
    }
  }
  if (menu->cursor >= 0)
    Term_gotoxy(col + menu->cursor_x_offset, row + cursor - *top);
}
STATIC_OVL char
scroll_get_tag(struct menu* menu, int pos)
{
  if (menu->selections) return menu->selections[pos - menu->top];
  return 0;
}
STATIC_OVL ui_event
scroll_process_direction(struct menu* m, int dir)
{
  ui_event out = EVENT_EMPTY;
  if (ddx[dir] && ddy[dir])
    ;
  else if (ddx[dir])
    out.type = ddx[dir] < 0 ? EVT_ESCAPE : EVT_SELECT;
  else if (ddy[dir]) {
    m->cursor += ddy[dir];
    out.type = EVT_MOVE;
  }
  return out;
}
STATIC_OVL int
object_skin_get_cursor(int row, int col, int n, int top, region* loc)
{
  int cursor = row - loc->row + top;
  if (cursor >= n) cursor = n - 1;
  return cursor;
}
STATIC_OVL void
object_skin_display(struct menu* menu, int cursor, int* top, region* loc)
{
  int col = loc->col;
  int row = loc->row;
  int rows_per_page = loc->page_rows;
  int n = menu->filter_list ? menu->filter_count : menu->count;
  int i;
  if ((cursor <= *top) && (*top > 0)) *top = cursor - 1;
  if (cursor >= *top + (rows_per_page - 1))
    *top = cursor - (rows_per_page - 1) + 1;
  *top = MIN(*top, n - rows_per_page);
  *top = MAX(*top, 0);
  for (i = 0; i < rows_per_page; i++) {
    Term_erase(col, row + i, loc->width);
    if (i < n) {
      bool is_curs = (i == cursor - *top);
      display_menu_row(menu, i + *top, *top, is_curs, row + i, col, loc->width);
    }
  }
  if (menu->cursor >= 0)
    Term_gotoxy(col + menu->cursor_x_offset, row + cursor - *top);
}
STATIC_OVL char
object_skin_get_tag(struct menu* menu, int pos)
{
  if (menu->selections) return menu->selections[pos - menu->top];
  return 0;
}
STATIC_OVL ui_event
object_skin_process_direction(struct menu* m, int dir)
{
  ui_event out = EVENT_EMPTY;
  if (ddx[dir] && ddy[dir])
    ;
  else if (ddx[dir]) {
    out.type = EVT_SWITCH;
    out.key.code = ddx[dir] < 0 ? ARROW_LEFT : ARROW_RIGHT;
  } else if (ddy[dir]) {
    m->cursor += ddy[dir];
    out.type = EVT_MOVE;
  }
  return out;
}
STATIC_OVL int
columns_get_cursor(int row, int col, int n, int top, region* loc)
{
  int w, h, cursor;
  int rows_per_page = loc->page_rows;
  int cols = (n + rows_per_page - 1) / rows_per_page;
  int colw = 23;
  Term_get_size(&w, &h);
  if ((colw * cols) > (w - col)) colw = (w - col) / cols;
  cursor = (row - loc->row) + rows_per_page * ((col - loc->col) / colw);
  if (cursor < 0) cursor = 0;
  if (cursor >= n) cursor = n - 1;
  return cursor;
}
STATIC_OVL void
display_columns(struct menu* menu, int cursor, int* top, region* loc)
{
  int c, r;
  int w, h;
  int n = menu->filter_list ? menu->filter_count : menu->count;
  int col = loc->col;
  int row = loc->row;
  int rows_per_page = loc->page_rows;
  int cols = (n + rows_per_page - 1) / rows_per_page;
  int colw = 23;
  Term_get_size(&w, &h);
  if ((colw * cols) > (w - col)) colw = (w - col) / cols;
  for (c = 0; c < cols; c++) {
    for (r = 0; r < rows_per_page; r++) {
      int pos = c * rows_per_page + r;
      bool is_cursor = (pos == cursor);
      if (pos < n)
        display_menu_row(menu, pos, 0, is_cursor, row + r, col + c * colw,
                         colw);
    }
  }
  if (menu->cursor >= 0)
    Term_gotoxy(col + (cursor / rows_per_page) * colw + menu->cursor_x_offset,
                row + (cursor % rows_per_page) - *top);
}
STATIC_OVL char
column_get_tag(struct menu* menu, int pos)
{
  if (menu->selections) return menu->selections[pos];
  return 0;
}
STATIC_OVL ui_event
column_process_direction(struct menu* m, int dir)
{
  ui_event out = EVENT_EMPTY;
  int n = m->filter_list ? m->filter_count : m->count;
  region* loc = &m->active;
  int rows_per_page = loc->page_rows;
  int cols = (n + rows_per_page - 1) / rows_per_page;
  if (ddx[dir]) m->cursor += ddx[dir] * rows_per_page;
  if (ddy[dir]) m->cursor += ddy[dir];
  if (m->cursor > n)
    m->cursor = m->cursor % rows_per_page;
  else if (m->cursor < 0)
    m->cursor = (rows_per_page * cols) + m->cursor;
  out.type = EVT_MOVE;
  return out;
}
STATIC_OVL bool
is_valid_row(struct menu* menu, int cursor)
{
  int oid;
  int count = menu->filter_list ? menu->filter_count : menu->count;
  if (cursor < 0 || cursor >= count) return false;
  oid = menu->filter_list ? menu->filter_list[cursor] : cursor;
  if (menu->row_funcs->valid_row) return menu->row_funcs->valid_row(menu, oid);
  return true;
}
STATIC_OVL bool
no_valid_row(struct menu* menu, int count)
{
  int i;
  for (i = 0; i < count; i++)
    if (is_valid_row(menu, i)) return false;
  return true;
}
STATIC_OVL int
get_cursor_key(struct menu* menu, int top, struct keypress key)
{
  int i;
  int n = menu->filter_list ? menu->filter_count : menu->count;
  if (menu->flags & MN_CASELESS_TAGS)
    key.code = toupper((unsigned char)key.code);
  if ((menu->flags & MN_INSCRIP_TAGS) && isdigit((unsigned char)key.code) &&
      menu->inscriptions[D2I(key.code)])
    key.code = menu->inscriptions[D2I(key.code)];
  if (menu->flags & MN_NO_TAGS) {
    return -1;
  } else if (menu->flags & MN_REL_TAGS) {
    for (i = 0; i < n; i++) {
      char c = menu->skin->get_tag(menu, i);
      if ((menu->flags & MN_CASELESS_TAGS) && c) c = toupper((unsigned char)c);
      if (c && c == (char)key.code) return i + menu->top;
    }
  } else if (!(menu->flags & MN_PVT_TAGS) && menu->selections) {
    for (i = 0; menu->selections[i]; i++) {
      char c = menu->selections[i];
      if (menu->flags & MN_CASELESS_TAGS) c = toupper((unsigned char)c);
      if (c == (char)key.code) return i;
    }
  } else if (menu->row_funcs->get_tag) {
    for (i = 0; i < n; i++) {
      int oid = menu->filter_list ? menu->filter_list[i] : i;
      char c = menu->row_funcs->get_tag(menu, oid);
      if ((menu->flags & MN_CASELESS_TAGS) && c) c = toupper((unsigned char)c);
      if (c && c == (char)key.code) return i;
    }
  }
  return -1;
}
STATIC_OVL menu_row_style_t
menu_row_style_for_validity(menu_row_validity_t row_valid)
{
  menu_row_style_t style;
  switch (row_valid) {
    case MN_ROW_INVALID:
    case MN_ROW_HIDDEN:
      style = MN_ROW_STYLE_DISABLED;
      break;
    case MN_ROW_MAYBE:
      style = MN_ROW_STYLE_CONDITIONAL;
      break;
    case MN_ROW_VALID:
    default:
      style = MN_ROW_STYLE_ENABLED;
      break;
  }
  return style;
}
STATIC_OVL void
display_menu_row(struct menu* menu, int pos, int top, bool cursor, int row,
                 int col, int width)
{
  int flags = menu->flags;
  char sel = 0;
  int oid = pos;
  menu_row_validity_t row_valid = MN_ROW_VALID;
  if (menu->filter_list) oid = menu->filter_list[oid];
  if (menu->row_funcs->valid_row)
    row_valid = menu->row_funcs->valid_row(menu, oid);
  if (row_valid == MN_ROW_HIDDEN) return;
  if (!(flags & MN_NO_TAGS)) {
    if (flags & MN_REL_TAGS)
      sel = menu->skin->get_tag(menu, pos);
    else if (menu->selections && !(flags & MN_PVT_TAGS))
      sel = menu->selections[pos];
    else if (menu->row_funcs->get_tag)
      sel = menu->row_funcs->get_tag(menu, oid);
  }
  if (sel) {
    menu_row_style_t style = menu_row_style_for_validity(row_valid);
    uint8_t color = curs_attrs[style][0 != (cursor)];
    Term_putstr(col, row, 3, color, format("%c) ", sel));
    col += 3;
    width -= 3;
  }
  menu->row_funcs->display_row(menu, oid, cursor, row, col, width);
}
STATIC_OVL void
menu_refresh(struct menu* menu, bool reset_screen)
{
  int oid = menu->cursor;
  region* loc = &menu->active;
  if (reset_screen) {
    screen_load();
    screen_save();
  }
  if (menu->filter_list && menu->cursor >= 0) oid = menu->filter_list[oid];
  if (menu->title)
    Term_putstr(menu->boundary.col, menu->boundary.row, loc->width,
                COLOUR_WHITE, menu->title);
  if (menu->header)
    Term_putstr(loc->col, loc->row - 1, loc->width, COLOUR_WHITE, menu->header);
  if (menu->prompt)
    Term_putstr(menu->boundary.col, loc->row + loc->page_rows, loc->width,
                COLOUR_WHITE, menu->prompt);
  if (menu->browse_hook && oid >= 0)
    menu->browse_hook(oid, menu->menu_data, loc);
  menu->skin->display_list(menu, menu->cursor, &menu->top, loc);
}
STATIC_OVL bool
menu_handle_mouse(struct menu* menu, const ui_event* in, ui_event* out)
{
  int new_cursor;
  if (in->mouse.button == 2) {
    out->type = EVT_ESCAPE;
  } else if (!region_inside(&menu->active, in)) {
    if (!region_inside(&menu->active, in) && in->mouse.x < menu->active.col) {
      out->type = EVT_ESCAPE;
    } else if (menu->context_hook) {
      return (*menu->context_hook)(menu, in, out);
    }
  } else {
    int count = menu->filter_list ? menu->filter_count : menu->count;
    new_cursor = menu->skin->get_cursor(in->mouse.y, in->mouse.x, count,
                                        menu->top, &menu->active);
    if (is_valid_row(menu, new_cursor)) {
      if (new_cursor == menu->cursor || !(menu->flags & MN_DBL_TAP))
        out->type = EVT_SELECT;
      else
        out->type = EVT_MOVE;
      menu->cursor = new_cursor;
    } else if (menu->context_hook) {
      return (*menu->context_hook)(menu, in, out);
    }
  }
  return out->type != EVT_NONE;
}
STATIC_OVL bool
menu_handle_action(struct menu* m, const ui_event* in)
{
  if (m->row_funcs->row_handler) {
    int oid = m->cursor;
    if (m->filter_list) oid = m->filter_list[m->cursor];
    return m->row_funcs->row_handler(m, in, oid);
  }
  return false;
}
STATIC_OVL bool
menu_handle_keypress(struct menu* menu, const ui_event* in, ui_event* out)
{
  bool eat = false;
  int count = menu->filter_list ? menu->filter_count : menu->count;
  int new_cursor = get_cursor_key(menu, menu->top, in->key);
  if (new_cursor >= 0 && is_valid_row(menu, new_cursor)) {
    if (!(menu->flags & MN_DBL_TAP) || new_cursor == menu->cursor)
      out->type = EVT_SELECT;
    else
      out->type = EVT_MOVE;
    menu->cursor = new_cursor;
  } else if (in->key.code == ESCAPE) {
    out->type = EVT_ESCAPE;
  } else if (count <= 0) {
    eat = true;
  } else if (in->key.code == ' ') {
    int rows = menu->active.page_rows;
    int total = count;
    if (rows < total) {
      menu->cursor += menu->active.page_rows;
      if (menu->cursor >= total - 1) menu->cursor = 0;
      menu->top = menu->cursor;
      out->type = EVT_MOVE;
    } else {
      eat = true;
    }
  } else if (in->key.code == KC_ENTER) {
    out->type = EVT_SELECT;
  } else {
    int dir = target_dir(in->key);
    if (dir && !no_valid_row(menu, count)) {
      *out = menu->skin->process_dir(menu, dir);
      if (out->type == EVT_MOVE) {
        while (!is_valid_row(menu, menu->cursor)) {
          if (menu->cursor > count - 1)
            menu->cursor = 0;
          else if (menu->cursor < 0)
            menu->cursor = count - 1;
          else
            menu->cursor += ddy[dir];
        }
        assert(menu->cursor >= 0);
        assert(menu->cursor < count);
      }
    }
  }
  return eat;
}
STATIC_OVL ui_event
menu_select(struct menu* menu, int notify, bool popup)
{
  ui_event in = EVENT_EMPTY;
  bool no_act = (menu->flags & MN_NO_ACTION) ? true : false;
  assert(menu->active.width != 0 && menu->active.page_rows != 0);
  notify |= (EVT_SELECT | EVT_ESCAPE | EVT_SWITCH);
  if (popup) screen_save();
  while (!(in.type & notify)) {
    ui_event out = EVENT_EMPTY;
    int cursor = menu->cursor;
    menu_refresh(menu, popup);
    in = inkey_ex();
    if (in.type == EVT_MOUSE) {
      if (!no_act && menu_handle_action(menu, &in)) {
        continue;
      }
      menu_handle_mouse(menu, &in, &out);
    } else if (in.type == EVT_KBRD) {
      if (!no_act && menu->cmd_keys &&
          strchr(menu->cmd_keys, (char)in.key.code) &&
          menu_handle_action(menu, &in))
        continue;
      if (!no_act && menu->switch_keys &&
          strchr(menu->switch_keys, (char)in.key.code)) {
        menu_handle_action(menu, &in);
        if (popup) screen_load();
        return in;
      }
      menu_handle_keypress(menu, &in, &out);
    } else if (in.type == EVT_RESIZE) {
      menu_calc_size(menu);
      if (menu->row_funcs->resize) menu->row_funcs->resize(menu);
    }
    if (cursor != menu->cursor) {
      menu_refresh(menu, popup);
    }
    if (out.type == EVT_SELECT && !no_act && menu_handle_action(menu, &out))
      continue;
    if (notify & out.type) {
      if (popup) screen_load();
      return out;
    }
  }
  if (popup) screen_load();
  return in;
}
STATIC_OVL const menu_iter*
menu_find_iter(menu_iter_id id)
{
  switch (id) {
    case MN_ITER_ACTIONS:
      return &menu_iter_actions;
    case MN_ITER_STRINGS:
      return &menu_iter_strings;
  }
  return NULL;
}
STATIC_OVL const menu_skin*
menu_find_skin(skin_id id)
{
  switch (id) {
    case MN_SKIN_SCROLL:
      return &menu_skin_scroll;
    case MN_SKIN_OBJECT:
      return &menu_skin_object;
    case MN_SKIN_COLUMNS:
      return &menu_skin_column;
  }
  return NULL;
}
STATIC_OVL void
menu_set_filter(struct menu* menu, const int filter_list[], int n)
{
  menu->filter_list = filter_list;
  menu->filter_count = n;
  menu_ensure_cursor_valid(menu);
}
STATIC_OVL void
menu_release_filter(struct menu* menu)
{
  menu->filter_list = NULL;
  menu->filter_count = 0;
  menu_ensure_cursor_valid(menu);
}
STATIC_OVL void
menu_ensure_cursor_valid(struct menu* m)
{
  int row;
  int count = m->filter_list ? m->filter_count : m->count;
  for (row = m->cursor; row < count; row++) {
    if (is_valid_row(m, row)) {
      m->cursor = row;
      return;
    }
  }
  m->cursor = count - 1;
}
STATIC_OVL bool
menu_calc_size(struct menu* menu)
{
  menu->active = region_calculate(menu->boundary);
  if (menu->title) {
    menu->active.row += 2;
    menu->active.page_rows -= 2;
    menu->active.col += 4;
  }
  if (menu->header) {
    menu->active.row++;
    menu->active.page_rows--;
  }
  if (menu->prompt) {
    if (menu->active.page_rows > 1) {
      menu->active.page_rows--;
    } else {
      int offset = strlen(menu->prompt) + 2;
      menu->active.col += offset;
      menu->active.width -= offset;
    }
  }
  return (menu->active.width > 0 && menu->active.page_rows > 0);
}
STATIC_OVL bool
menu_layout(struct menu* m, const region* loc)
{
  m->boundary = *loc;
  return menu_calc_size(m);
}
STATIC_OVL void
menu_setpriv(struct menu* menu, int count, void* data)
{
  menu->count = count;
  menu->menu_data = data;
  menu_ensure_cursor_valid(menu);
}
STATIC_OVL void*
menu_priv(struct menu* menu)
{
  return menu->menu_data;
}
STATIC_OVL void
menu_init(struct menu* menu, skin_id id, const menu_iter* iter)
{
  const menu_skin* skin = menu_find_skin(id);
  assert(skin && "menu skin not found!");
  assert(iter && "menu iter not found!");
  memset(menu, 0, sizeof *menu);
  menu->row_funcs = iter;
  menu->skin = skin;
  menu->cursor = 0;
  menu->cursor_x_offset = 0;
}
STATIC_OVL struct menu*
menu_new(skin_id id, const menu_iter* iter)
{
  struct menu* m = mem_alloc(sizeof *m);
  menu_init(m, id, iter);
  return m;
}
STATIC_OVL struct menu*
menu_new_action(menu_action* acts, size_t n)
{
  struct menu* m = menu_new(MN_SKIN_SCROLL, menu_find_iter(MN_ITER_ACTIONS));
  menu_setpriv(m, n, acts);
  return m;
}
STATIC_OVL void
menu_free(struct menu* m)
{
  mem_free(m);
}
STATIC_OVL void
menu_set_cursor_x_offset(struct menu* m, int offset)
{
  m->cursor_x_offset = offset;
}
STATIC_OVL int
dynamic_valid(struct menu* m, int oid)
{
  struct menu_entry* entry;
  for (entry = menu_priv(m); oid; oid--) {
    entry = entry->next;
    assert(entry);
  }
  return entry->valid;
}
STATIC_OVL void
dynamic_display(struct menu* m, int oid, bool cursor, int row, int col,
                int width)
{
  struct menu_entry* entry;
  uint8_t color = curs_attrs[MN_ROW_STYLE_ENABLED][0 != cursor];
  if (m->row_funcs->valid_row) {
    menu_row_validity_t row_valid = m->row_funcs->valid_row(m, oid);
    menu_row_style_t style = menu_row_style_for_validity(row_valid);
    color = curs_attrs[style][0 != cursor];
  }
  for (entry = menu_priv(m); oid; oid--) {
    entry = entry->next;
    assert(entry);
  }
  Term_putstr(col, row, width, color, entry->text);
}
STATIC_OVL struct menu*
menu_dynamic_new(void)
{
  struct menu* m = menu_new(MN_SKIN_SCROLL, &dynamic_iter);
  menu_setpriv(m, 0, NULL);
  return m;
}
STATIC_OVL void
menu_dynamic_add_valid(struct menu* m, const char* text, int value,
                       menu_row_validity_t valid)
{
  struct menu_entry* head = menu_priv(m);
  struct menu_entry* new = mem_zalloc(sizeof *new);
  assert(m->row_funcs == &dynamic_iter);
  new->text = string_make(text);
  new->value = value;
  new->valid = valid;
  if (head) {
    struct menu_entry* tail = head;
    while (1) {
      if (tail->next)
        tail = tail->next;
      else
        break;
    }
    tail->next = new;
    menu_setpriv(m, m->count + 1, head);
  } else {
    menu_setpriv(m, m->count + 1, new);
  }
}
STATIC_OVL void
menu_dynamic_add(struct menu* m, const char* text, int value)
{
  menu_dynamic_add_valid(m, text, value, MN_ROW_VALID);
}
STATIC_OVL void
menu_dynamic_add_label_valid(struct menu* m, const char* text, const char label,
                             int value, char* label_list,
                             menu_row_validity_t valid)
{
  if (label && m->selections && (m->selections == label_list)) {
    label_list[m->count] = label;
  }
  menu_dynamic_add_valid(m, text, value, valid);
}
STATIC_OVL void
menu_dynamic_add_label(struct menu* m, const char* text, const char label,
                       int value, char* label_list)
{
  menu_dynamic_add_label_valid(m, text, label, value, label_list, MN_ROW_VALID);
}
STATIC_OVL size_t
menu_dynamic_longest_entry(struct menu* m)
{
  size_t biggest = 0;
  size_t current;
  struct menu_entry* entry;
  for (entry = menu_priv(m); entry; entry = entry->next) {
    current = strlen(entry->text);
    if (current > biggest) biggest = current;
  }
  return biggest;
}
STATIC_OVL void
menu_dynamic_calc_location(struct menu* m, int mx, int my)
{
  region r;
  r.width = menu_dynamic_longest_entry(m) + 3 + 2;
  if (mx > Term->wid - r.width - 1) {
    r.col = Term->wid - r.width - 1;
  } else {
    r.col = mx + 1;
  }
  r.page_rows = m->count;
  if (my > Term->hgt - r.page_rows - 1) {
    if (my - r.page_rows - 1 <= 0) {
      r.row = 1;
      r.col = Term->wid - r.width - 1;
    } else {
      r.row = Term->hgt - r.page_rows - 1;
    }
  } else {
    r.row = my + 1;
  }
  menu_layout(m, &r);
}
STATIC_OVL int
menu_dynamic_select(struct menu* m)
{
  ui_event e = menu_select(m, 0, true);
  struct menu_entry* entry;
  int cursor = m->cursor;
  if (e.type == EVT_ESCAPE) return -1;
  for (entry = menu_priv(m); cursor; cursor--) {
    entry = entry->next;
    assert(entry);
  }
  return entry->value;
}
STATIC_OVL void
menu_dynamic_free(struct menu* m)
{
  struct menu_entry* entry = menu_priv(m);
  while (entry) {
    struct menu_entry* next = entry->next;
    string_free(entry->text);
    mem_free(entry);
    entry = next;
  }
  mem_free(m);
}
STATIC_OVL void
monster_list_format_section(const monster_list_t* list, textblock* tb,
                            monster_list_section_t section,
                            int lines_to_display, int max_width,
                            const char* prefix, bool show_others,
                            size_t* max_width_result)
{
  int remaining_monster_total = 0;
  int line_count = 0;
  int index;
  int total;
  char line_buffer[200];
  const char* punctuation = (lines_to_display == 0) ? "." : ":";
  const char* others = (show_others) ? "other " : "";
  size_t max_line_length = 0;
  if (list == NULL || list->entries == NULL) return;
  total = list->distinct_entries;
  if (list->total_monsters[section] == 0) {
    max_line_length =
        strnfmt(line_buffer, sizeof(line_buffer), "%s no monsters.\n", prefix);
    if (tb != NULL) textblock_append(tb, "%s", line_buffer);
    if (max_width_result != NULL) *max_width_result = MAX(max_line_length, 40);
    return;
  }
  max_line_length =
      strnfmt(line_buffer, sizeof(line_buffer), "%s %d %smonster%s%s\n", prefix,
              list->total_monsters[section], others,
              PLURAL(list->total_monsters[section]), punctuation);
  if (tb != NULL) textblock_append(tb, "%s", line_buffer);
  for (index = 0; index < total && line_count < lines_to_display; index++) {
    char alert[20] = {'\0'};
    char location[20] = {'\0'};
    int line_attr;
    size_t full_width;
    size_t name_width;
    uint16_t count_in_section = 0;
    uint16_t alert_in_section = 0;
    line_buffer[0] = '\0';
    if (list->entries[index].count[section] == 0) continue;
    if (list->entries[index].count[section] == 1) {
      const char* direction1 =
          (list->entries[index].dy[section] <= 0) ? "N" : "S";
      const char* direction2 =
          (list->entries[index].dx[section] <= 0) ? "W" : "E";
      strnfmt(location, sizeof(location), " %d %s %d %s",
              abs(list->entries[index].dy[section]), direction1,
              abs(list->entries[index].dx[section]), direction2);
    }
    full_width = max_width - 2 - utf8_strlen(location) - 1;
    alert_in_section = list->entries[index].alert[section];
    count_in_section = list->entries[index].count[section];
    if (alert_in_section > 0 && count_in_section > 1)
      strnfmt(alert, sizeof(alert), " (%d alert)", alert_in_section);
    else if (alert_in_section == 1 && count_in_section == 1)
      strnfmt(alert, sizeof(alert), " (alert)");
    name_width = MIN(full_width - utf8_strlen(alert), sizeof(line_buffer));
    get_mon_name(line_buffer, sizeof(line_buffer), list->entries[index].race,
                 list->entries[index].count[section]);
    utf8_clipto(line_buffer, name_width);
    my_strcat(line_buffer, alert, sizeof(line_buffer));
    max_line_length = MAX(max_line_length, utf8_strlen(line_buffer) + 12 + 2);
    if (tb != NULL && tile_width == 1 && tile_height == 1) {
      textblock_append_pict(tb, list->entries[index].attr,
                            monster_x_char[list->entries[index].race->ridx]);
      textblock_append(tb, " ");
    }
    if (tb != NULL) {
      full_width += strlen(line_buffer) - utf8_strlen(line_buffer);
      line_attr = monster_list_entry_line_color(&list->entries[index]);
      textblock_append_c(tb, line_attr, "%-*s%s\n", (int)full_width,
                         line_buffer, location);
    }
    line_count++;
  }
  if (max_width_result != NULL) *max_width_result = max_line_length;
  if (lines_to_display <= 0 || lines_to_display >= list->total_entries[section])
    return;
  while (index < total) {
    remaining_monster_total += list->entries[index].count[section];
    index++;
  }
  if (tb != NULL)
    textblock_append(tb, "%6s...and %d others.\n", " ",
                     remaining_monster_total);
}
STATIC_OVL bool
monster_list_format_special(const monster_list_t* list, textblock* tb,
                            int max_lines, int max_width,
                            size_t* max_height_result, size_t* max_width_result)
{
  if (player->timed[TMD_IMAGE] > 0) {
    const char* message =
        "Your hallucinations are too wild to see things clearly.\n";
    if (max_height_result != NULL) *max_height_result = 1;
    if (max_width_result != NULL) *max_width_result = strlen(message);
    if (tb != NULL) textblock_append_c(tb, COLOUR_ORANGE, "%s", message);
    return true;
  }
  return false;
}
STATIC_OVL void
monster_list_format_textblock(const monster_list_t* list, textblock* tb,
                              int max_lines, int max_width,
                              size_t* max_height_result,
                              size_t* max_width_result)
{
  int header_lines = 1;
  int lines_remaining;
  int los_lines_to_display;
  int esp_lines_to_display;
  size_t max_los_line = 0;
  size_t max_esp_line = 0;
  if (list == NULL || list->entries == NULL) return;
  if (monster_list_format_special(list, tb, max_lines, max_width,
                                  max_height_result, max_width_result))
    return;
  los_lines_to_display = list->total_entries[MONSTER_LIST_SECTION_LOS];
  esp_lines_to_display = list->total_entries[MONSTER_LIST_SECTION_ESP];
  if (list->total_entries[MONSTER_LIST_SECTION_ESP] > 0) header_lines += 2;
  if (max_height_result != NULL)
    *max_height_result =
        header_lines + los_lines_to_display + esp_lines_to_display;
  lines_remaining =
      max_lines - header_lines - list->total_entries[MONSTER_LIST_SECTION_LOS];
  if (lines_remaining < list->total_entries[MONSTER_LIST_SECTION_ESP])
    esp_lines_to_display = MAX(lines_remaining - 1, 0);
  if (lines_remaining < 0)
    los_lines_to_display = list->total_entries[MONSTER_LIST_SECTION_LOS] -
                           abs(lines_remaining) - 1;
  if (header_lines >= max_lines) {
    los_lines_to_display = 0;
    esp_lines_to_display = 0;
  }
  monster_list_format_section(list, tb, MONSTER_LIST_SECTION_LOS,
                              los_lines_to_display, max_width, "You can see",
                              false, &max_los_line);
  if (list->total_entries[MONSTER_LIST_SECTION_ESP] > 0) {
    bool show_others = list->total_monsters[MONSTER_LIST_SECTION_LOS] > 0;
    if (tb != NULL) textblock_append(tb, "\n");
    monster_list_format_section(list, tb, MONSTER_LIST_SECTION_ESP,
                                esp_lines_to_display, max_width,
                                "You are aware of", show_others, &max_esp_line);
  }
  if (max_width_result != NULL)
    *max_width_result = MAX(max_los_line, max_esp_line);
}
STATIC_OVL void
monster_list_get_glyphs(monster_list_t* list)
{
  int i;
  for (i = 0; i < (int)list->entries_size; i++) {
    monster_list_entry_t* entry = &list->entries[i];
    if (entry->race == NULL) continue;
    if (!entry->attr) entry->attr = monster_x_attr[entry->race->ridx];
  }
}
STATIC_OVL void
monster_list_show_subwindow(int height, int width)
{
  textblock* tb;
  monster_list_t* list;
  int i;
  if (height < 1 || width < 1) return;
  tb = textblock_new();
  list = monster_list_shared_instance();
  for (i = 1; i < cave_monster_max(cave); i++) {
    if (mflag_has(cave_monster(cave, i)->mflag, MFLAG_MARK)) {
      list->creation_turn = -1;
      break;
    }
  }
  monster_list_reset(list);
  monster_list_collect(list);
  monster_list_get_glyphs(list);
  monster_list_sort(list, monster_list_standard_compare);
  monster_list_format_textblock(list, tb, height, width, NULL, NULL);
  textui_textblock_place(tb, SCREEN_REGION, NULL);
  textblock_free(tb);
}
STATIC_OVL void
monster_list_show_interactive(int height, int width)
{
  textblock* tb;
  monster_list_t* list;
  size_t max_width = 0, max_height = 0;
  int safe_height, safe_width;
  region r;
  int sort_exp = 0;
  struct keypress ch;
  if (height < 1 || width < 1) return;
  do {
    tb = textblock_new();
    list = monster_list_new();
    monster_list_collect(list);
    monster_list_get_glyphs(list);
    monster_list_sort(list, sort_exp ? monster_list_compare_exp
                                     : monster_list_standard_compare);
    monster_list_format_textblock(list, NULL, 1000, 1000, &max_height,
                                  &max_width);
    safe_height = MIN(height - 3, (int)max_height + 3);
    safe_width = MIN(width - 40, (int)max_width);
    r.col = -safe_width;
    r.row = 1;
    r.width = safe_width;
    r.page_rows = safe_height;
    monster_list_format_textblock(list, tb, (int)max_height, safe_width, NULL,
                                  NULL);
    region_erase_bordered(&r);
    char buf[300];
    if (sort_exp) {
      my_strcpy(buf, "Press 'x' to turn OFF 'sort by exp'", sizeof(buf));
    } else {
      my_strcpy(buf, "Press 'x' to turn ON 'sort by exp'", sizeof(buf));
    }
    ch = textui_textblock_show(tb, r, buf);
    sort_exp = !sort_exp;
    textblock_free(tb);
    monster_list_free(list);
  } while (ch.code == 'x');
}
STATIC_OVL void
monster_list_force_subwindow_update(void)
{
  monster_list_t* list = monster_list_shared_instance();
  list->creation_turn = -1;
}
STATIC_OVL void
lore_title(textblock* tb, const struct monster_race* race)
{
  uint8_t standard_attr, optional_attr;
  wchar_t standard_char, optional_char;
  assert(race);
  standard_char = race->d_char;
  optional_char = monster_x_char[race->ridx];
  standard_attr = race->d_attr;
  optional_attr = monster_x_attr[race->ridx];
  if (!rf_has(race->flags, RF_UNIQUE)) {
    textblock_append(tb, "The ");
  }
  textblock_append(tb, "%s", race->name);
  textblock_append(tb, " ('");
  textblock_append_pict(tb, standard_attr, standard_char);
  textblock_append(tb, "')");
  if (((optional_attr != standard_attr) || (optional_char != standard_char)) &&
      (tile_width == 1) && (tile_height == 1)) {
    textblock_append(tb, " ('");
    textblock_append_pict(tb, optional_attr, optional_char);
    textblock_append(tb, "')");
  }
}
STATIC_OVL void
lore_description(textblock* tb, const struct monster_race* race,
                 const struct monster_lore* original_lore, bool spoilers)
{
  struct monster_lore mutable_lore;
  struct monster_lore* lore = &mutable_lore;
  bitflag known_flags[RF_SIZE];
  assert(tb && race && original_lore);
  if (player->timed[TMD_IMAGE] > 0) {
    textblock_append(
        tb, "Your hallucinations are too wild to see things clearly.\n");
    return;
  }
  memcpy(lore, original_lore, sizeof(struct monster_lore));
  if (spoilers || player_active_ability(player, "Lore-Master"))
    cheat_monster_lore(race, lore);
  monster_flags_known(race, lore, known_flags);
  if (!spoilers) {
    lore_title(tb, race);
    textblock_append(tb, "\n");
  }
  if (!spoilers) lore_append_kills(tb, race, lore, known_flags);
  lore_append_flavor(tb, race);
  lore_append_movement(tb, race, lore, known_flags);
  lore_append_spells(tb, race, lore, known_flags);
  lore_append_abilities(tb, race, lore, known_flags);
  lore_append_attack(tb, race, lore, known_flags);
  lore_append_toughness(tb, race, lore, known_flags);
  lore_append_skills(tb, race, lore, known_flags);
  lore_append_exp(tb, race, lore, known_flags);
  lore_append_drop(tb, race, lore, known_flags);
  textblock_append(tb, "\n");
}
STATIC_OVL void
lore_show_interactive(const struct monster_race* race,
                      const struct monster_lore* lore)
{
  textblock* tb;
  assert(race && lore);
  event_signal(EVENT_MESSAGE_FLUSH);
  tb = textblock_new();
  lore_description(tb, race, lore, false);
  textui_textblock_show(tb, SCREEN_REGION, NULL);
  textblock_free(tb);
}
STATIC_OVL void
lore_show_subwindow(const struct monster_race* race,
                    const struct monster_lore* lore)
{
  int y;
  textblock* tb;
  assert(race && lore);
  for (y = 0; y < Term->hgt; y++) Term_erase(0, y, 255);
  tb = textblock_new();
  lore_description(tb, race, lore, false);
  textui_textblock_place(tb, SCREEN_REGION, NULL);
  textblock_free(tb);
}
STATIC_OVL void
object_list_format_section(const object_list_t* list, textblock* tb,
                           object_list_section_t section, int lines_to_display,
                           int max_width, const char* prefix, bool show_others,
                           size_t* max_width_result)
{
  int remaining_object_total = 0;
  int line_count = 0;
  int entry_index;
  int total;
  char line_buffer[200];
  const char* punctuation = (lines_to_display == 0) ? "." : ":";
  const char* others = (show_others) ? "other " : "";
  size_t max_line_length = 0;
  if (list == NULL || list->entries == NULL) return;
  total = list->distinct_entries;
  if (list->total_entries[section] == 0) {
    max_line_length =
        strnfmt(line_buffer, sizeof(line_buffer), "%s no objects.\n", prefix);
    if (tb != NULL) textblock_append(tb, "%s", line_buffer);
    if (max_width_result != NULL) *max_width_result = MAX(max_line_length, 40);
    return;
  }
  max_line_length =
      strnfmt(line_buffer, sizeof(line_buffer), "%s %d %sobject%s%s\n", prefix,
              list->total_entries[section], others,
              PLURAL(list->total_entries[section]), punctuation);
  if (tb != NULL) textblock_append(tb, "%s", line_buffer);
  for (entry_index = 0; entry_index < total && line_count < lines_to_display;
       entry_index++) {
    char location[20] = {'\0'};
    int line_attr;
    size_t full_width;
    const char* direction_y = (list->entries[entry_index].dy <= 0) ? "N" : "S";
    const char* direction_x = (list->entries[entry_index].dx <= 0) ? "W" : "E";
    line_buffer[0] = '\0';
    if (list->entries[entry_index].count[section] == 0) continue;
    strnfmt(location, sizeof(location), " %d %s %d %s",
            abs(list->entries[entry_index].dy), direction_y,
            abs(list->entries[entry_index].dx), direction_x);
    full_width = max_width - 2 - utf8_strlen(location) - 1;
    object_list_format_name(&list->entries[entry_index], line_buffer,
                            sizeof(line_buffer));
    utf8_clipto(line_buffer, full_width);
    max_line_length = MAX(max_line_length, utf8_strlen(line_buffer) + 12 + 2);
    if (tb != NULL && tile_width == 1 && tile_height == 1) {
      uint8_t a = COLOUR_RED;
      wchar_t c = L'*';
      if (list->entries[entry_index].object->kind != NULL) {
        a = object_attr(list->entries[entry_index].object);
        c = object_char(list->entries[entry_index].object);
      }
      textblock_append_pict(tb, a, c);
      textblock_append(tb, " ");
    }
    if (tb != NULL) {
      full_width += strlen(line_buffer) - utf8_strlen(line_buffer);
      line_attr = object_list_entry_line_attribute(&list->entries[entry_index]);
      textblock_append_c(tb, line_attr, "%-*s%s\n", (int)full_width,
                         line_buffer, location);
    }
    line_count++;
  }
  if (max_width_result != NULL) *max_width_result = max_line_length;
  if (lines_to_display <= 0 || lines_to_display >= list->total_entries[section])
    return;
  remaining_object_total = total - entry_index;
  if (tb != NULL)
    textblock_append(tb, "%6s...and %d others.\n", " ", remaining_object_total);
}
STATIC_OVL bool
object_list_format_special(const object_list_t* list, textblock* tb,
                           int max_lines, int max_width,
                           size_t* max_height_result, size_t* max_width_result)
{
  return false;
}
STATIC_OVL void
object_list_format_textblock(const object_list_t* list, textblock* tb,
                             int max_lines, int max_width,
                             size_t* max_height_result,
                             size_t* max_width_result)
{
  int header_lines = 1;
  int lines_remaining;
  int los_lines_to_display;
  int no_los_lines_to_display;
  size_t max_los_line = 0;
  size_t max_no_los_line = 0;
  if (list == NULL || list->entries == NULL) return;
  if (object_list_format_special(list, tb, max_lines, max_width,
                                 max_height_result, max_width_result))
    return;
  los_lines_to_display = list->total_entries[OBJECT_LIST_SECTION_LOS];
  no_los_lines_to_display = list->total_entries[OBJECT_LIST_SECTION_NO_LOS];
  if (list->total_entries[OBJECT_LIST_SECTION_NO_LOS] > 0) header_lines += 2;
  if (max_height_result != NULL)
    *max_height_result =
        header_lines + los_lines_to_display + no_los_lines_to_display;
  lines_remaining =
      max_lines - header_lines - list->total_entries[OBJECT_LIST_SECTION_LOS];
  if (lines_remaining < list->total_entries[OBJECT_LIST_SECTION_NO_LOS])
    no_los_lines_to_display = MAX(lines_remaining - 1, 0);
  if (lines_remaining < 0)
    los_lines_to_display =
        list->total_entries[OBJECT_LIST_SECTION_LOS] - abs(lines_remaining) - 1;
  if (header_lines >= max_lines) {
    los_lines_to_display = 0;
    no_los_lines_to_display = 0;
  }
  object_list_format_section(list, tb, OBJECT_LIST_SECTION_LOS,
                             los_lines_to_display, max_width, "You can see",
                             false, &max_los_line);
  if (list->total_entries[OBJECT_LIST_SECTION_NO_LOS] > 0) {
    bool show_others = list->total_objects[OBJECT_LIST_SECTION_LOS] > 0;
    if (tb != NULL) textblock_append(tb, "\n");
    object_list_format_section(
        list, tb, OBJECT_LIST_SECTION_NO_LOS, no_los_lines_to_display,
        max_width, "You are aware of", show_others, &max_no_los_line);
  }
  if (max_width_result != NULL)
    *max_width_result = MAX(max_los_line, max_no_los_line);
}
STATIC_OVL void
object_list_show_subwindow(int height, int width)
{
  textblock* tb;
  object_list_t* list;
  if (height < 1 || width < 1) return;
  tb = textblock_new();
  list = object_list_shared_instance();
  object_list_reset(list);
  object_list_collect(list);
  object_list_sort(list, object_list_standard_compare);
  object_list_format_textblock(list, tb, height, width, NULL, NULL);
  textui_textblock_place(tb, SCREEN_REGION, NULL);
  textblock_free(tb);
}
STATIC_OVL void
object_list_show_interactive(int height, int width)
{
  textblock* tb;
  object_list_t* list;
  size_t max_width = 0, max_height = 0;
  int safe_height, safe_width;
  region r;
  if (height < 1 || width < 1) return;
  tb = textblock_new();
  list = object_list_new();
  object_list_collect(list);
  object_list_sort(list, object_list_standard_compare);
  object_list_format_textblock(list, NULL, 1000, 1000, &max_height, &max_width);
  safe_height = MIN(height - 2, (int)max_height + 2);
  safe_width = MIN(width - 13, (int)max_width);
  r.col = -safe_width;
  r.row = 1;
  r.width = safe_width;
  r.page_rows = safe_height;
  object_list_format_textblock(list, tb, (int)max_height, safe_width, NULL,
                               NULL);
  region_erase_bordered(&r);
  textui_textblock_show(tb, r, NULL);
  textblock_free(tb);
  object_list_free(list);
}
STATIC_OVL bool
use_flavor_glyph(const struct object_kind* kind)
{
  return kind->flavor;
}
STATIC_OVL uint8_t
object_kind_attr(const struct object_kind* kind)
{
  return use_flavor_glyph(kind) ? flavor_x_attr[kind->flavor->fidx]
                                : kind_x_attr[kind->kidx];
}
STATIC_OVL wchar_t
object_kind_char(const struct object_kind* kind)
{
  return use_flavor_glyph(kind) ? flavor_x_char[kind->flavor->fidx]
                                : kind_x_char[kind->kidx];
}
STATIC_OVL uint8_t
object_attr(const struct object* obj)
{
  return obj->artifact ? obj->artifact->d_attr : object_kind_attr(obj->kind);
}
STATIC_OVL wchar_t
object_char(const struct object* obj)
{
  return object_kind_char(obj->kind);
}
STATIC_OVL void
show_obj(int obj_num, int row, int col, bool cursor, olist_detail_t mode)
{
  int attr;
  int label_attr = cursor ? COLOUR_L_BLUE : COLOUR_WHITE;
  int ex_offset_ctr;
  char buf[80];
  struct object* obj = items[obj_num].object;
  bool show_label = mode & (OLIST_WINDOW | OLIST_DEATH) ? true : false;
  int label_size = show_label ? strlen(items[obj_num].label) : 0;
  int equip_label_size = strlen(items[obj_num].equip_label);
  prt("", row + obj_num, MAX(col - 1, 0));
  if (!strlen(items[obj_num].label)) return;
  if (show_label)
    c_put_str(label_attr, items[obj_num].label, row + obj_num, col);
  c_put_str(label_attr, items[obj_num].equip_label, row + obj_num,
            col + label_size);
  if (label_size + equip_label_size + strlen(items[obj_num].o_name) >
      (size_t)ex_offset) {
    int truncate = ex_offset - label_size - equip_label_size;
    if (truncate < 0) truncate = 0;
    if ((size_t)truncate > sizeof(items[obj_num].o_name) - 1)
      truncate = sizeof(items[obj_num].o_name) - 1;
    items[obj_num].o_name[truncate] = '\0';
  }
  if (obj) {
    attr = obj->kind->base->attr;
  } else {
    attr = COLOUR_SLATE;
  }
  c_put_str(attr, items[obj_num].o_name, row + obj_num,
            col + label_size + equip_label_size);
  if (!obj) return;
  ex_offset_ctr = ex_offset;
  if (mode & OLIST_WEIGHT) {
    int weight = obj->weight * obj->number;
    strnfmt(buf, sizeof(buf), "%4d.%1d lb", weight / 10, weight % 10);
    put_str(buf, row + obj_num, col + ex_offset_ctr);
  }
}
STATIC_OVL void
wipe_obj_list(void)
{
  int i;
  num_obj = 0;
  num_head = 0;
  max_len = 0;
  ex_width = 0;
  ex_offset = 0;
  for (i = 0; i < 50; i++) {
    my_strcpy(items[i].label, "", sizeof(items[i].label));
    my_strcpy(items[i].equip_label, "", sizeof(items[i].equip_label));
    items[i].object = NULL;
    my_strcpy(items[i].o_name, "", sizeof(items[i].o_name));
    items[i].key = '\0';
  }
}
STATIC_OVL void
build_obj_list(int last, struct object** list, item_tester tester,
               olist_detail_t mode)
{
  int i;
  bool in_term = (mode & OLIST_WINDOW) ? true : false;
  bool show_empty = (mode & OLIST_SEMPTY) ? true : false;
  bool equip = list ? false : true;
  for (i = 0; i <= last; i++) {
    char buf[80];
    struct object* obj = equip ? slot_object(player, i) : list[i];
    if (object_test(tester, obj))
      strnfmt(items[num_obj].label, sizeof(items[num_obj].label), "%c) ",
              all_letters_nohjkl[i]);
    else if ((!obj && show_empty) || in_term)
      my_strcpy(items[num_obj].label, "   ", sizeof(items[num_obj].label));
    else
      continue;
    if (equip) {
      const char* mention = equip_mention(player, i);
      size_t u8len = utf8_strlen(mention);
      if (u8len < 14) {
        strnfmt(buf, sizeof(buf), "%s%*s", mention, (int)(14 - u8len), " ");
      } else {
        char* mention_copy = string_make(mention);
        if (u8len > 14) {
          utf8_clipto(mention_copy, 14);
        }
        strnfmt(buf, sizeof(buf), "%s", mention_copy);
        string_free(mention_copy);
      }
      my_strcpy(items[num_obj].equip_label, buf,
                sizeof(items[num_obj].equip_label));
    } else {
      strnfmt(items[num_obj].equip_label, sizeof(items[num_obj].equip_label),
              "%s", "");
    }
    items[num_obj].object = obj;
    items[num_obj].key = (items[num_obj].label)[0];
    num_obj++;
  }
}
STATIC_OVL void
set_obj_names(bool terse, const struct player* p)
{
  int i;
  struct object* obj;
  for (i = 0; i < num_obj; i++) {
    obj = items[i].object;
    if (!obj) {
      if (i < num_head)
        strnfmt(items[i].o_name, sizeof(items[i].o_name), "%s", "");
      else
        strnfmt(items[i].o_name, sizeof(items[i].o_name), "(nothing)");
    } else {
      if (terse) {
        object_desc(items[i].o_name, sizeof(items[i].o_name), obj,
                    ODESC_PREFIX | ODESC_FULL | ODESC_TERSE, p);
      } else {
        object_desc(items[i].o_name, sizeof(items[i].o_name), obj,
                    ODESC_PREFIX | ODESC_FULL, p);
      }
    }
    max_len =
        MAX(max_len, strlen(items[i].label) + strlen(items[i].equip_label) +
                         strlen(items[i].o_name));
  }
}
STATIC_OVL void
show_obj_list(olist_detail_t mode)
{
  int i, row = 0, col = 0;
  bool in_term = (mode & OLIST_WINDOW) ? true : false;
  bool terse = false;
  max_len = 0;
  ex_width = 0;
  ex_offset = 0;
  if (in_term) max_len = 40;
  if (in_term && Term->wid < 40) mode &= ~(OLIST_WEIGHT);
  if (Term->wid < 50) terse = true;
  set_obj_names(terse, player);
  if (mode & OLIST_WEIGHT) ex_width += 9;
  if (in_term) {
    row = 0;
    col = 0;
  } else {
    row = 1;
    col = Term->wid - 1 - max_len - ex_width;
    if (col < 3) col = 0;
  }
  ex_offset = MIN(max_len, (size_t)(Term->wid - 1 - ex_width - col));
  for (i = 0; i < num_obj; i++) show_obj(i, row, col, false, mode);
  if (in_term) {
    for (; i < Term->hgt; i++) prt("", row + i, MAX(col - 2, 0));
  } else if (i > 0 && row + i < 24) {
    prt("", row + i, MAX(col - 2, 0));
  }
}
STATIC_OVL void
show_inven(int mode, item_tester tester)
{
  int i, last_slot = -1;
  int diff = weight_remaining(player);
  bool in_term = (mode & OLIST_WINDOW) ? true : false;
  wipe_obj_list();
  if (in_term) {
    strnfmt(items[num_obj].label, sizeof(items[num_obj].label),
            "Burden %d.%d lb (%d.%d lb %s) ", player->upkeep->total_weight / 10,
            player->upkeep->total_weight % 10, abs(diff) / 10, abs(diff) % 10,
            (diff < 0 ? "overweight" : "remaining"));
    items[num_obj].object = NULL;
    num_obj++;
  }
  for (i = 0; i < z_info->pack_size; i++)
    if (player->upkeep->inven[i] != NULL) last_slot = i;
  build_obj_list(last_slot, player->upkeep->inven, tester, mode);
  num_head = in_term ? 1 : 0;
  show_obj_list(mode);
}
STATIC_OVL void
show_equip(int mode, item_tester tester)
{
  wipe_obj_list();
  build_obj_list(player->body.count - 1, NULL, tester, mode);
  num_head = 0;
  show_obj_list(mode);
}
STATIC_OVL void
show_floor(struct object** floor_list, int floor_num, int mode,
           item_tester tester)
{
  wipe_obj_list();
  if (floor_num > z_info->floor_size) floor_num = z_info->floor_size;
  build_obj_list(floor_num - 1, floor_list, tester, mode);
  num_head = 0;
  show_obj_list(mode);
}
STATIC_OVL bool
get_item_allow(const struct object* obj, unsigned char ch, cmd_code cmd,
               bool is_harmless)
{
  char verify_inscrip[] = "!*";
  unsigned n;
  if (ch < 0x20) ch = UN_KTRL(ch);
  verify_inscrip[1] = ch;
  n = check_for_inscrip(obj, verify_inscrip);
  if (!is_harmless) n += check_for_inscrip(obj, "!*");
  if (n) {
    char prompt_buf[1024];
    const char* verb = cmd_verb(cmd);
    if (!verb) verb = "do that with";
    strnfmt(prompt_buf, sizeof(prompt_buf), "Really %s", verb);
    while (n--) {
      if (!verify_object(prompt_buf, obj, player)) {
        return false;
      }
    }
  }
  return (true);
}
STATIC_OVL bool
get_tag(struct object** tagged_obj, char tag, cmd_code cmd)
{
  int i;
  int mode =
      OPT(player, angband_keyset) ? KEYMAP_MODE_ANGBAND : KEYMAP_MODE_ORIG;
  if (OPT(player, hjkl_movement)) {
    mode |= KEYMAP_MODE_ROGUE;
  }
  for (i = 0; i < num_obj; i++) {
    const char* s;
    struct object* obj = items[i].object;
    if (!obj) continue;
    if (!obj->note) continue;
    s = strchr(quark_str(obj->note), '@');
    while (s) {
      unsigned char cmdkey;
      if (s[1] == tag) {
        *tagged_obj = obj;
        return true;
      }
      cmdkey = cmd_lookup_key(cmd, mode);
      if (cmdkey < 0x20) cmdkey = UN_KTRL(cmdkey);
      if ((s[1] == cmdkey) && (s[2] == tag)) {
        *tagged_obj = obj;
        return true;
      }
      s = strchr(s + 1, '@');
    }
  }
  return false;
}
STATIC_OVL void
menu_header(void)
{
  char tmp_val[75];
  char out_val[75];
  bool use_inven = ((item_mode & USE_INVEN) ? true : false);
  bool use_equip = ((item_mode & USE_EQUIP) ? true : false);
  bool allow_floor = ((f1 <= f2) || allow_all);
  if (player->upkeep->command_wrk == USE_INVEN) {
    strnfmt(out_val, sizeof(out_val), "Inven:");
    if (i1 <= i2) {
      strnfmt(tmp_val, sizeof(tmp_val), " %c-%c,", all_letters_nohjkl[i1],
              all_letters_nohjkl[i2]);
      my_strcat(out_val, tmp_val, sizeof(out_val));
    }
    if (use_equip) my_strcat(out_val, " / for Equip,", sizeof(out_val));
    if (allow_floor) my_strcat(out_val, " - for floor,", sizeof(out_val));
  } else if (player->upkeep->command_wrk == USE_EQUIP) {
    strnfmt(out_val, sizeof(out_val), "Equip:");
    if (e1 <= e2) {
      strnfmt(tmp_val, sizeof(tmp_val), " %c-%c,", all_letters_nohjkl[e1],
              all_letters_nohjkl[e2]);
      my_strcat(out_val, tmp_val, sizeof(out_val));
    }
    if (use_inven) my_strcat(out_val, " / for Inven,", sizeof(out_val));
    if (allow_floor) my_strcat(out_val, " - for floor,", sizeof(out_val));
  } else if (player->upkeep->command_wrk == SHOW_THROWING) {
    strnfmt(out_val, sizeof(out_val), "Throwing items:");
    if (throwing_num) {
      strnfmt(tmp_val, sizeof(tmp_val), " a-%c,",
              all_letters_nohjkl[throwing_num - 1]);
      my_strcat(out_val, tmp_val, sizeof(out_val));
    }
    if (use_inven) my_strcat(out_val, " / for Inven,", sizeof(out_val));
    if (allow_floor) my_strcat(out_val, " - for floor,", sizeof(out_val));
  } else {
    strnfmt(out_val, sizeof(out_val), "Floor:");
    if (f1 <= f2) {
      strnfmt(tmp_val, sizeof(tmp_val), " %c-%c,", all_letters_nohjkl[f1],
              all_letters_nohjkl[f2]);
      my_strcat(out_val, tmp_val, sizeof(out_val));
    }
    if (use_inven)
      my_strcat(out_val, " / for Inven,", sizeof(out_val));
    else if (use_equip)
      my_strcat(out_val, " / for Equip,", sizeof(out_val));
  }
  my_strcat(out_val, " ESC", sizeof(out_val));
  strnfmt(header, sizeof(header), "(%s)", out_val);
}
STATIC_OVL char
get_item_tag(struct menu* menu, int oid)
{
  struct object_menu_data* choice = menu_priv(menu);
  return choice[oid].key;
}
STATIC_OVL int
get_item_validity(struct menu* menu, int oid)
{
  struct object_menu_data* choice = menu_priv(menu);
  return (choice[oid].object != NULL) ? 1 : 0;
}
STATIC_OVL void
get_item_display(struct menu* menu, int oid, bool cursor, int row, int col,
                 int width)
{
  show_obj(oid, row - oid, col, cursor, olist_mode);
}
STATIC_OVL bool
get_item_action(struct menu* menu, const ui_event* event, int oid)
{
  struct object_menu_data* choice = menu_priv(menu);
  char key = event->key.code;
  bool is_harmless = item_mode & IS_HARMLESS ? true : false;
  int mode =
      OPT(player, angband_keyset) ? KEYMAP_MODE_ANGBAND : KEYMAP_MODE_ORIG;
  if (OPT(player, hjkl_movement)) {
    mode |= KEYMAP_MODE_ROGUE;
  }
  if (event->type == EVT_SELECT) {
    if (choice[oid].object &&
        get_item_allow(choice[oid].object, cmd_lookup_key(item_cmd, mode),
                       item_cmd, is_harmless))
      selection = choice[oid].object;
  }
  if (event->type == EVT_KBRD) {
    if (key == '/') {
      if (((item_mode & USE_INVEN) || allow_all) &&
          (player->upkeep->command_wrk != USE_INVEN)) {
        player->upkeep->command_wrk = USE_INVEN;
        newmenu = true;
      } else if (((item_mode & USE_EQUIP) || allow_all) &&
                 (player->upkeep->command_wrk != USE_EQUIP)) {
        player->upkeep->command_wrk = USE_EQUIP;
        newmenu = true;
      } else {
        bell();
      }
    } else if (key == '-') {
      if ((f1 > f2) && !allow_all) {
        bell();
      } else {
        player->upkeep->command_wrk = (USE_FLOOR);
        newmenu = true;
      }
    }
  }
  return false;
}
STATIC_OVL struct object*
item_menu(cmd_code cmd, int prompt_size, int mode)
{
  menu_iter menu_f = {get_item_tag, get_item_validity, get_item_display,
                      get_item_action, 0};
  struct menu* m = menu_new(MN_SKIN_OBJECT, &menu_f);
  ui_event evt = {0};
  int ex_offset_ctr = 0;
  int row, inscrip;
  struct object* obj = NULL;
  menu_setpriv(m, num_obj, items);
  m->selections = all_letters_nohjkl;
  m->switch_keys = "/|-";
  m->flags = (MN_PVT_TAGS | MN_INSCRIP_TAGS);
  m->inscriptions = mem_zalloc(10 * sizeof(char));
  for (inscrip = 0; inscrip < 10; inscrip++) {
    if (get_tag(&obj, (char)inscrip + '0', item_cmd)) {
      int i;
      for (i = 0; i < num_obj; i++)
        if (items[i].object == obj) break;
      if (i < num_obj) m->inscriptions[inscrip] = get_item_tag(m, i);
    }
  }
  selection = NULL;
  set_obj_names(false, player);
  if (olist_mode & OLIST_WEIGHT) {
    ex_width += 9;
    ex_offset_ctr += 9;
  }
  area.page_rows = m->count;
  area.row = 1;
  area.col = MIN(Term->wid - 1 - (int)max_len - ex_width, prompt_size - 2);
  if (area.col <= 3) area.col = 0;
  ex_offset = MIN(max_len, (size_t)(Term->wid - 1 - ex_width - area.col));
  while (strlen(header) < max_len + ex_width + ex_offset_ctr) {
    my_strcat(header, " ", sizeof(header));
    if (strlen(header) > sizeof(header) - 2) break;
  }
  area.width = MAX(max_len, strlen(header));
  for (row = area.row; row < area.row + area.page_rows; row++)
    prt("", row, MAX(0, area.col - 1));
  menu_layout(m, &area);
  evt = menu_select(m, 0, true);
  mem_free(m->inscriptions);
  mem_free(m);
  if (evt.type == EVT_SWITCH && !newmenu) {
    bool left = evt.key.code == ARROW_LEFT;
    if (player->upkeep->command_wrk == USE_EQUIP) {
      if (left) {
        if (f1 <= f2)
          player->upkeep->command_wrk = USE_FLOOR;
        else if (i1 <= i2)
          player->upkeep->command_wrk = USE_INVEN;
      } else {
        if (i1 <= i2)
          player->upkeep->command_wrk = USE_INVEN;
        else if (f1 <= f2)
          player->upkeep->command_wrk = USE_FLOOR;
      }
    } else if (player->upkeep->command_wrk == USE_INVEN) {
      if (left) {
        if (e1 <= e2)
          player->upkeep->command_wrk = USE_EQUIP;
        else if (f1 <= f2)
          player->upkeep->command_wrk = USE_FLOOR;
      } else {
        if (f1 <= f2)
          player->upkeep->command_wrk = USE_FLOOR;
        else if (e1 <= e2)
          player->upkeep->command_wrk = USE_EQUIP;
      }
    } else if (player->upkeep->command_wrk == USE_FLOOR) {
      if (left) {
        if (i1 <= i2)
          player->upkeep->command_wrk = USE_INVEN;
        else if (e1 <= e2)
          player->upkeep->command_wrk = USE_EQUIP;
      } else {
        if (e1 <= e2)
          player->upkeep->command_wrk = USE_EQUIP;
        else if (i1 <= i2)
          player->upkeep->command_wrk = USE_INVEN;
      }
    } else if (player->upkeep->command_wrk == SHOW_THROWING) {
      if (left) {
        if (i1 <= i2)
          player->upkeep->command_wrk = USE_INVEN;
        else if (e1 <= e2)
          player->upkeep->command_wrk = USE_EQUIP;
      } else {
        if (e1 <= e2)
          player->upkeep->command_wrk = USE_EQUIP;
        else if (i1 <= i2)
          player->upkeep->command_wrk = USE_INVEN;
      }
    }
    newmenu = true;
  }
  return selection;
}
STATIC_OVL bool
textui_get_item(struct object** choice, const char* pmt, const char* str,
                cmd_code cmd, item_tester tester, int mode)
{
  bool use_inven = ((mode & USE_INVEN) ? true : false);
  bool use_equip = ((mode & USE_EQUIP) ? true : false);
  bool use_floor = ((mode & USE_FLOOR) ? true : false);
  bool show_throwing = ((mode & SHOW_THROWING) ? true : false);
  bool allow_inven = false;
  bool allow_equip = false;
  bool allow_floor = false;
  bool toggle = false;
  int floor_max = z_info->floor_size;
  int floor_num;
  int throwing_max = z_info->pack_size + z_info->floor_size;
  floor_list = mem_zalloc(floor_max * sizeof(*floor_list));
  throwing_list = mem_zalloc(throwing_max * sizeof(*throwing_list));
  olist_mode = 0;
  item_mode = mode;
  item_cmd = cmd;
  tester_m = tester;
  prompt = pmt;
  allow_all = str ? false : true;
  olist_mode |= OLIST_WEIGHT;
  if (mode & SHOW_EMPTY) olist_mode |= OLIST_SEMPTY;
  event_signal(EVENT_MESSAGE_FLUSH);
  i1 = 0;
  i2 = z_info->pack_size - 1;
  if (!use_inven) i2 = -1;
  while ((i1 <= i2) && (!object_test(tester, player->upkeep->inven[i1]))) i1++;
  while ((i1 <= i2) && (!object_test(tester, player->upkeep->inven[i2]))) i2--;
  if ((i1 <= i2) || allow_all)
    allow_inven = true;
  else if (item_mode & USE_INVEN)
    item_mode -= USE_INVEN;
  e1 = 0;
  e2 = player->body.count - 1;
  if (!use_equip) e2 = -1;
  if ((cmd != CMD_NULL) || (tester != NULL)) {
    while ((e1 <= e2) && (!object_test(tester, slot_object(player, e1)))) e1++;
    while ((e1 <= e2) && (!object_test(tester, slot_object(player, e2)))) e2--;
  }
  if ((e1 <= e2) || allow_all)
    allow_equip = true;
  else if (item_mode & USE_EQUIP)
    item_mode -= USE_EQUIP;
  floor_num = scan_floor(floor_list, floor_max, player,
                         OFLOOR_TEST | OFLOOR_SENSE | OFLOOR_VISIBLE, tester);
  f1 = 0;
  f2 = floor_num - 1;
  if (!use_floor) f2 = -1;
  while ((f1 <= f2) && (!object_test(tester, floor_list[f1]))) f1++;
  while ((f1 <= f2) && (!object_test(tester, floor_list[f2]))) f2--;
  if ((f1 <= f2) || allow_all)
    allow_floor = true;
  else if (item_mode & USE_FLOOR)
    item_mode -= USE_FLOOR;
  throwing_num = scan_items(throwing_list, throwing_max, player,
                            USE_INVEN | USE_FLOOR, obj_is_throwing);
  if (allow_inven || allow_equip || allow_floor) {
    if (show_throwing && throwing_num) {
      player->upkeep->command_wrk = SHOW_THROWING;
    } else if ((player->upkeep->command_wrk == USE_EQUIP) && allow_equip)
      player->upkeep->command_wrk = USE_EQUIP;
    else if ((player->upkeep->command_wrk == USE_INVEN) && allow_inven)
      player->upkeep->command_wrk = USE_INVEN;
    else if ((player->upkeep->command_wrk == USE_FLOOR) && allow_floor)
      player->upkeep->command_wrk = USE_FLOOR;
    else if (use_inven && allow_inven)
      player->upkeep->command_wrk = USE_INVEN;
    else if (use_equip && allow_equip)
      player->upkeep->command_wrk = USE_EQUIP;
    else if (use_floor && allow_floor)
      player->upkeep->command_wrk = USE_FLOOR;
    else
      player->upkeep->command_wrk = USE_INVEN;
    while (true) {
      int j;
      int ni = 0;
      int ne = 0;
      for (j = 0; j < ANGBAND_TERM_MAX; j++) {
        if (!angband_term[j]) continue;
        if (window_flag[j] & (PW_INVEN)) ni++;
        if (window_flag[j] & (PW_EQUIP)) ne++;
      }
      if ((ni && !ne) || (!ni && ne)) {
        if (player->upkeep->command_wrk == USE_EQUIP) {
          if ((ne && !toggle) || (ni && toggle)) {
            toggle_inven_equip();
            toggle = !toggle;
          }
        } else if (player->upkeep->command_wrk == USE_INVEN) {
          if ((ni && !toggle) || (ne && toggle)) {
            toggle_inven_equip();
            toggle = !toggle;
          }
        } else {
          if (toggle) {
            toggle_inven_equip();
            toggle = !toggle;
          }
        }
      }
      player->upkeep->redraw |= (PR_INVEN | PR_EQUIP);
      redraw_stuff(player);
      screen_save();
      wipe_obj_list();
      if (player->upkeep->command_wrk == USE_INVEN)
        build_obj_list(i2, player->upkeep->inven, tester_m, olist_mode);
      else if (player->upkeep->command_wrk == USE_EQUIP)
        build_obj_list(e2, NULL, tester_m, olist_mode);
      else if (player->upkeep->command_wrk == USE_FLOOR)
        build_obj_list(f2, floor_list, tester_m, olist_mode);
      else if (player->upkeep->command_wrk == SHOW_THROWING)
        build_obj_list(throwing_num, throwing_list, tester_m, olist_mode);
      menu_header();
      if (pmt) {
        prt(pmt, 0, 0);
        prt(header, 0, strlen(pmt) + 1);
      }
      newmenu = false;
      *choice = item_menu(cmd, MAX(pmt ? strlen(pmt) : 0, 15), mode);
      screen_load();
      player->upkeep->redraw |= (PR_INVEN | PR_EQUIP);
      redraw_stuff(player);
      prt("", 0, 0);
      if (*choice || !newmenu) {
        if (toggle) toggle_inven_equip();
        break;
      }
    }
  } else {
    if (str) msg("%s", str);
    *choice = NULL;
  }
  player->upkeep->command_wrk = 0;
  mem_free(throwing_list);
  mem_free(floor_list);
  return (*choice != NULL) ? true : false;
}
STATIC_OVL void
display_object_recall(struct object* obj)
{
  char header_buf[120];
  textblock* tb = object_info(obj, OINFO_NONE);
  object_desc(header_buf, sizeof(header_buf), obj, ODESC_PREFIX | ODESC_FULL,
              player);
  clear_from(0);
  textui_textblock_place(tb, SCREEN_REGION, header_buf);
  textblock_free(tb);
}
STATIC_OVL void
display_object_kind_recall(struct object_kind* kind)
{
  struct object object = OBJECT_NULL, known_obj = OBJECT_NULL;
  object_prep(&object, kind, 0, EXTREMIFY);
  if (kind->aware || !kind->flavor) {
    object_copy(&known_obj, &object);
  }
  object.known = &known_obj;
  display_object_recall(&object);
  object_wipe(&known_obj);
  object_wipe(&object);
}
STATIC_OVL void
display_object_recall_interactive(struct object* obj)
{
  char header_buf[120];
  textblock* tb;
  event_signal(EVENT_MESSAGE_FLUSH);
  tb = object_info(obj, OINFO_NONE);
  object_desc(header_buf, sizeof(header_buf), obj, ODESC_PREFIX | ODESC_FULL,
              player);
  textui_textblock_show(tb, SCREEN_REGION, header_buf);
  textblock_free(tb);
}
STATIC_OVL void
textui_obj_examine(void)
{
  char header_buf[120];
  textblock* tb;
  region local_area = {0, 0, 0, 0};
  struct object* obj;
  if (!get_item(&obj, "Examine which item?", "You have nothing to examine.",
                CMD_NULL, NULL,
                (USE_EQUIP | USE_INVEN | USE_FLOOR | IS_HARMLESS)))
    return;
  track_object(player->upkeep, obj);
  tb = object_info(obj, OINFO_NONE);
  object_desc(header_buf, sizeof(header_buf), obj,
              ODESC_PREFIX | ODESC_FULL | ODESC_CAPITAL, player);
  textui_textblock_show(tb, local_area, header_buf);
  textblock_free(tb);
}
STATIC_OVL void
textui_cmd_ignore_menu(struct object* obj)
{
  char out_val[160];
  struct menu* m;
  region r;
  int selected;
  uint8_t value;
  int type;
  if (!obj) return;
  m = menu_dynamic_new();
  m->selections = lower_case;
  if (!(obj->known->notice & OBJ_NOTICE_IGNORE)) {
    menu_dynamic_add(m, "This item only", IGNORE_THIS_ITEM);
  } else {
    menu_dynamic_add(m, "Unignore this item", UNIGNORE_THIS_ITEM);
  }
  if (ignore_tval(obj->tval) &&
      (!obj->artifact || !object_flavor_is_aware(obj))) {
    bool ignored =
        kind_is_ignored_aware(obj->kind) || kind_is_ignored_unaware(obj->kind);
    char tmp[70];
    object_desc(tmp, sizeof(tmp), obj, ODESC_NOEGO | ODESC_BASE | ODESC_PLURAL,
                player);
    if (!ignored) {
      strnfmt(out_val, sizeof out_val, "All %s", tmp);
      menu_dynamic_add(m, out_val, IGNORE_THIS_FLAVOR);
    } else {
      strnfmt(out_val, sizeof out_val, "Unignore all %s", tmp);
      menu_dynamic_add(m, out_val, UNIGNORE_THIS_FLAVOR);
    }
  }
  type = ignore_type_of(obj);
  if (obj->known->ego && type != ITYPE_MAX) {
    struct ego_desc choice;
    struct ego_item* ego = obj->ego;
    char tmp[80] = "";
    choice.e_idx = ego->eidx;
    choice.itype = type;
    choice.short_name = "";
    (void)ego_item_name(tmp, sizeof(tmp), &choice);
    if (!ego_is_ignored(choice.e_idx, choice.itype)) {
      strnfmt(out_val, sizeof out_val, "All %s", tmp + 4);
      menu_dynamic_add(m, out_val, IGNORE_THIS_EGO);
    } else {
      strnfmt(out_val, sizeof out_val, "Unignore all %s", tmp + 4);
      menu_dynamic_add(m, out_val, UNIGNORE_THIS_EGO);
    }
  }
  value = ignore_level_of(obj);
  if (tval_is_jewelry(obj) && ignore_level_of(obj) != IGNORE_BAD)
    value = IGNORE_MAX;
  if (value != IGNORE_MAX && type != ITYPE_MAX) {
    strnfmt(out_val, sizeof out_val, "All %s %s", quality_values[value].name,
            ignore_name_for_type(type));
    menu_dynamic_add(m, out_val, IGNORE_THIS_QUALITY);
  }
  r.width = menu_dynamic_longest_entry(m) + 3 + 2;
  r.col = 80 - r.width;
  r.row = 1;
  r.page_rows = m->count;
  screen_save();
  menu_layout(m, &r);
  region_erase_bordered(&r);
  prt("(Enter to select, ESC) Ignore:", 0, 0);
  selected = menu_dynamic_select(m);
  screen_load();
  if (selected == IGNORE_THIS_ITEM) {
    obj->known->notice |= OBJ_NOTICE_IGNORE;
  } else if (selected == UNIGNORE_THIS_ITEM) {
    obj->known->notice &= ~(OBJ_NOTICE_IGNORE);
  } else if (selected == IGNORE_THIS_FLAVOR) {
    object_ignore_flavor_of(obj);
  } else if (selected == UNIGNORE_THIS_FLAVOR) {
    kind_ignore_clear(obj->kind);
  } else if (selected == IGNORE_THIS_EGO) {
    ego_ignore(obj);
  } else if (selected == UNIGNORE_THIS_EGO) {
    ego_ignore_clear(obj);
  } else if (selected == IGNORE_THIS_QUALITY) {
    uint8_t ignore_value = ignore_level_of(obj);
    int ignore_type = ignore_type_of(obj);
    ignore_level[ignore_type] = ignore_value;
  }
  player->upkeep->notice |= PN_IGNORE;
  menu_dynamic_free(m);
}
STATIC_OVL void
textui_cmd_ignore(void)
{
  struct object* obj;
  const char* q = "Ignore which item? ";
  const char* s = "You have nothing to ignore.";
  if (!get_item(&obj, q, s, CMD_IGNORE, NULL,
                USE_INVEN | USE_EQUIP | USE_FLOOR))
    return;
  textui_cmd_ignore_menu(obj);
}
STATIC_OVL void
textui_cmd_toggle_ignore(void)
{
  player->unignoring = !player->unignoring;
  player->upkeep->notice |= PN_IGNORE;
  do_cmd_redraw();
}
STATIC_OVL bool
get_pref_path(const char* what, int row, char* buf, size_t max)
{
  char ftmp[80];
  bool ok;
  screen_save();
  if (row > 0) {
    prt("", row - 1, 0);
  }
  prt(format("%s to a pref file", what), row, 0);
  prt("", row + 1, 0);
  prt("File: ", row + 2, 0);
  prt("", row + 3, 0);
  player_safe_name(ftmp, sizeof(ftmp), player->full_name, true);
  my_strcat(ftmp, ".prf", sizeof(ftmp));
  if (!arg_force_name)
    ok = askfor_aux(ftmp, sizeof ftmp, NULL);
  else
    ok = get_check(format("Confirm writing to %s? ", ftmp));
  screen_load();
  if (ok) path_build(buf, max, ANGBAND_DIR_USER, ftmp);
  return ok;
}
STATIC_OVL void
dump_pref_file(void (*dump)(ang_file*), const char* title, int row)
{
  char buf[1024];
  if (!get_pref_path(title, row, buf, sizeof(buf))) return;
  if (prefs_save(buf, dump, title))
    msg("Saved %s.", strstr(title, " ") + 1);
  else
    msg("Failed to save %s.", strstr(title, " ") + 1);
  event_signal(EVENT_MESSAGE_FLUSH);
  return;
}
void do_cmd_pref_file_hack(long row);
STATIC_OVL void
option_toggle_display(struct menu* m, int oid, bool cursor, int row, int col,
                      int width)
{
  uint8_t attr = curs_attrs[CURS_KNOWN][cursor != 0];
  bool* options = menu_priv(m);
  const char* desc = option_desc(oid);
  size_t u8len = utf8_strlen(desc);
  if (u8len < 45) {
    c_prt(attr, format("%s%*s", desc, (int)(45 - u8len), " "), row, col);
  } else {
    char* desc_copy = string_make(desc);
    if (u8len > 45) {
      utf8_clipto(desc_copy, 45);
    }
    c_prt(attr, desc_copy, row, col);
    string_free(desc_copy);
  }
  c_prt(attr,
        format(": %s  (%s)", options[oid] ? "yes" : "no ", option_name(oid)),
        row, col + 45);
}
STATIC_OVL bool
option_toggle_handle(struct menu* m, const ui_event* event, int oid)
{
  bool next = false;
  int page = option_type(oid);
  if (event->type == EVT_SELECT) {
    if (!((page == OP_BIRTH) && (m->flags == MN_NO_TAGS))) {
      option_set(option_name(oid), !player->opts.opt[oid]);
    }
  } else if (event->type == EVT_KBRD) {
    if (event->key.code == 'y' || event->key.code == 'Y') {
      option_set(option_name(oid), true);
      next = true;
    } else if (event->key.code == 'n' || event->key.code == 'N') {
      option_set(option_name(oid), false);
      next = true;
    } else if (event->key.code == 't' || event->key.code == 'T') {
      option_set(option_name(oid), !player->opts.opt[oid]);
    } else if (event->key.code == 's' || event->key.code == 'S') {
      char dummy;
      screen_save();
      if (options_save_custom(&player->opts, page)) {
        get_com("Successfully saved.  Press any key to continue.", &dummy);
      } else {
        get_com("Save failed.  Press any key to continue.", &dummy);
      }
      screen_load();
    } else if ((event->key.code == 'r' || event->key.code == 'R') &&
               (page != OP_BIRTH || m->flags == MN_DBL_TAP)) {
      screen_save();
      if (options_restore_custom(&player->opts, page)) {
        screen_load();
        menu_refresh(m, false);
      } else {
        char dummy;
        get_com("Restore failed.  Press any key to continue.", &dummy);
        screen_load();
      }
    } else if ((event->key.code == 'x' || event->key.code == 'X') &&
               (page != OP_BIRTH || m->flags == MN_DBL_TAP)) {
      options_restore_maintainer(&player->opts, page);
      menu_refresh(m, false);
    } else {
      return false;
    }
  } else {
    return false;
  }
  if (next) {
    m->cursor++;
    m->cursor = (m->cursor + m->filter_count) % m->filter_count;
  }
  return true;
}
STATIC_OVL bool
use_option_context_menu(struct menu* m, const ui_event* in, ui_event* out)
{
  enum { ACT_CTX_OPT_SAVE, ACT_CTX_OPT_RESTORE, ACT_CTX_OPT_RESET };
  int page = option_type(m->filter_list[0]);
  char* labels = string_make(lower_case);
  struct menu* cm = menu_dynamic_new();
  bool refresh = false;
  char save_label[40];
  int selected;
  char dummy;
  cm->selections = labels;
  strnfmt(save_label, sizeof(save_label), "Save as default %s options",
          option_type_name(page));
  menu_dynamic_add_label(cm, save_label, 's', ACT_CTX_OPT_SAVE, labels);
  if (m->flags == MN_DBL_TAP) {
    menu_dynamic_add_label(cm, "Restore from saved defaults", 'r',
                           ACT_CTX_OPT_RESTORE, labels);
    menu_dynamic_add_label(cm, "Reset to factory defaults", 'x',
                           ACT_CTX_OPT_RESET, labels);
  }
  screen_save();
  assert(in->type == EVT_MOUSE);
  menu_dynamic_calc_location(cm, in->mouse.x, in->mouse.y);
  region_erase_bordered(&cm->boundary);
  selected = menu_dynamic_select(cm);
  menu_dynamic_free(cm);
  string_free(labels);
  switch (selected) {
    case ACT_CTX_OPT_SAVE:
      if (options_save_custom(&player->opts, page)) {
        get_com(
            "Successfully saved.  Press any key to "
            "continue.",
            &dummy);
      } else {
        get_com("Save failed.  Press any key to continue.", &dummy);
      }
      break;
    case ACT_CTX_OPT_RESTORE:
      if (options_restore_custom(&player->opts, page)) {
        refresh = true;
      } else {
        get_com("Restore failed.  Press any key to continue.", &dummy);
      }
      break;
    case ACT_CTX_OPT_RESET:
      options_restore_maintainer(&player->opts, page);
      refresh = true;
      break;
    default:
      break;
  }
  screen_load();
  if (refresh) {
    menu_refresh(m, false);
  }
  return true;
}
STATIC_OVL void
option_toggle_menu(const char* name, int page)
{
  static const char selections[] = "abcdefgimopquvwzABCDEFGHIJKLMOPQUVWZ";
  int i;
  struct menu* m = menu_new(MN_SKIN_SCROLL, &option_toggle_iter);
  m->prompt = "Set option (y/n/t), select with movement keys or index";
  m->cmd_keys = "YyNnTt";
  m->selections = selections;
  m->flags = MN_DBL_TAP;
  if (page == OPT_PAGE_BIRTH) {
    m->prompt = "You can only modify these options at character birth.";
    m->cmd_keys = "";
    m->flags = MN_NO_TAGS;
  } else if (page == OPT_PAGE_BIRTH + 10 || page == OP_INTERFACE) {
    m->prompt = "Set option (y/n/t), 's' to save, 'r' to restore, 'x' to reset";
    m->cmd_keys = "YyNnTtSsRrXx";
    m->context_hook = use_option_context_menu;
    if (page == OPT_PAGE_BIRTH + 10) {
      page -= 10;
    }
  }
  m->title = name;
  for (i = 0; i < OPT_PAGE_PER; i++) {
    if (option_page[page][i] == OPT_none) break;
  }
  menu_setpriv(m, OPT_MAX, &player->opts.opt);
  menu_set_filter(m, option_page[page], i);
  menu_layout(m, &SCREEN_REGION);
  screen_save();
  clear_from(0);
  menu_select(m, 0, false);
  screen_load();
  mem_free(m);
}
STATIC_OVL void
do_cmd_options_birth(void)
{
  option_toggle_menu("Birth options", OPT_PAGE_BIRTH + 10);
}
STATIC_OVL void
do_cmd_options_win(const char* name, int row)
{
  int i, j, d;
  int y = 0;
  int x = 0;
  ui_event ke;
  uint32_t new_flags[ANGBAND_TERM_MAX];
  for (j = 0; j < ANGBAND_TERM_MAX; j++) new_flags[j] = window_flag[j];
  screen_save();
  clear_from(0);
  while (1) {
    prt("Window flags (<dir> to move, 't'/Enter to toggle, or ESC)", 0, 0);
    for (j = 0; j < ANGBAND_TERM_MAX; j++) {
      uint8_t a = COLOUR_WHITE;
      const char* s = angband_term_name[j];
      if (j == x) a = COLOUR_L_BLUE;
      Term_putstr(35 + j * 5 - strlen(s) / 2, 2 + j % 2, -1, a, s);
    }
    for (i = 0; i < PW_MAX_FLAGS; i++) {
      uint8_t a = COLOUR_WHITE;
      const char* str = window_flag_desc[i];
      if (i == y) a = COLOUR_L_BLUE;
      if (!str) str = "(Unused option)";
      Term_putstr(0, i + 5, -1, a, str);
      for (j = 0; j < ANGBAND_TERM_MAX; j++) {
        wchar_t c = L'.';
        a = COLOUR_WHITE;
        if ((i == y) && (j == x)) a = COLOUR_L_BLUE;
        if (new_flags[j] & ((uint32_t)1 << i)) c = L'X';
        Term_putch(35 + j * 5, i + 5, a, c);
      }
    }
    Term_gotoxy(35 + x * 5, y + 5);
    ke = inkey_ex();
    if (ke.type == EVT_MOUSE) {
      int choicey = ke.mouse.y - 5;
      int choicex = (ke.mouse.x - 35) / 5;
      if (ke.mouse.button == 2) break;
      if ((choicey >= 0) && (choicey < PW_MAX_FLAGS) && (choicex > 0) &&
          (choicex < ANGBAND_TERM_MAX) && !(ke.mouse.x % 5)) {
        if ((choicey == y) && (choicex == x)) {
          uint32_t flag = ((uint32_t)1) << y;
          if (new_flags[x] & flag)
            new_flags[x] &= ~flag;
          else
            new_flags[x] |= flag;
        } else {
          y = choicey;
          x = (ke.mouse.x - 35) / 5;
        }
      }
    } else if (ke.type == EVT_KBRD) {
      if (ke.key.code == ESCAPE || ke.key.code == 'q')
        break;
      else if (ke.key.code == '5' || ke.key.code == 't' ||
               ke.key.code == KC_ENTER) {
        if (x == 0)
          bell();
        else if (new_flags[x] & (((uint32_t)1) << y))
          new_flags[x] &= ~(((uint32_t)1) << y);
        else
          new_flags[x] |= (((uint32_t)1) << y);
        continue;
      }
      d = target_dir(ke.key);
      if (d != 0) {
        x = (x + ddx[d] + 8) % ANGBAND_TERM_MAX;
        y = (y + ddy[d] + 16) % PW_MAX_FLAGS;
      }
    }
  }
  subwindows_set_flags(new_flags, ANGBAND_TERM_MAX);
  screen_load();
}
STATIC_OVL struct keypress
keymap_get_trigger(void)
{
  char tmp[80];
  struct keypress buf[2] = {KEYPRESS_NULL, KEYPRESS_NULL};
  event_signal(EVENT_INPUT_FLUSH);
  buf[0] = inkey();
  keypress_to_text(tmp, sizeof(tmp), buf, false);
  Term_addstr(-1, COLOUR_WHITE, tmp);
  event_signal(EVENT_INPUT_FLUSH);
  return buf[0];
}
STATIC_OVL void
ui_keymap_pref_load(const char* title, int row)
{
  do_cmd_pref_file_hack(16);
}
STATIC_OVL void
ui_keymap_pref_append(const char* title, int row)
{
  dump_pref_file(keymap_dump, "Dump keymaps", 13);
}
STATIC_OVL void
ui_keymap_query(const char* title, int row)
{
  char tmp[1024];
  int mode =
      OPT(player, angband_keyset) ? KEYMAP_MODE_ANGBAND : KEYMAP_MODE_ORIG;
  struct keypress c;
  const struct keypress* act;
  if (OPT(player, hjkl_movement)) {
    mode |= KEYMAP_MODE_ROGUE;
  }
  prt(title, 13, 0);
  prt("Key: ", 14, 0);
  c = keymap_get_trigger();
  act = keymap_find(mode, c);
  if (!act) {
    prt("No keymap with that trigger.  Press any key to continue.", 16, 0);
    inkey();
  } else {
    keypress_to_text(tmp, sizeof(tmp), act, false);
    prt("Found: ", 15, 0);
    Term_addstr(-1, COLOUR_WHITE, tmp);
    prt("Press any key to continue.", 17, 0);
    inkey();
  }
}
STATIC_OVL void
ui_keymap_create(const char* title, int row)
{
  bool done = false;
  size_t n = 0;
  struct keypress c;
  char tmp[1024];
  int mode =
      OPT(player, angband_keyset) ? KEYMAP_MODE_ANGBAND : KEYMAP_MODE_ORIG;
  if (OPT(player, hjkl_movement)) {
    mode |= KEYMAP_MODE_ROGUE;
  }
  prt(title, 13, 0);
  prt("Key: ", 14, 0);
  c = keymap_get_trigger();
  if (c.code == '=') {
    c_prt(COLOUR_L_RED, "The '=' key is reserved.", 16, 2);
    prt("Press any key to continue.", 18, 0);
    inkey();
    return;
  }
  while (!done) {
    struct keypress kp = {EVT_NONE, 0, 0};
    int color = COLOUR_WHITE;
    if (n == 0) color = COLOUR_YELLOW;
    if (n == KEYMAP_ACTION_MAX) color = COLOUR_L_RED;
    keypress_to_text(tmp, sizeof(tmp), keymap_buffer, false);
    c_prt(color, format("Action: %s", tmp), 15, 0);
    c_prt(COLOUR_L_BLUE, "  Press '=' when finished.", 17, 0);
    c_prt(COLOUR_L_BLUE, "  Use 'CTRL-u' to reset.", 18, 0);
    c_prt(COLOUR_L_BLUE,
          format("(Maximum keymap length is %d keys.)", KEYMAP_ACTION_MAX), 19,
          0);
    kp = inkey();
    if (kp.code == '=') {
      done = true;
      continue;
    }
    switch (kp.code) {
      case KC_DELETE:
      case KC_BACKSPACE: {
        if (n > 0) {
          n -= 1;
          keymap_buffer[n].type = 0;
          keymap_buffer[n].code = 0;
          keymap_buffer[n].mods = 0;
        }
        break;
      }
      case KTRL('U'): {
        memset(keymap_buffer, 0, sizeof keymap_buffer);
        n = 0;
        break;
      }
      default: {
        if (n == KEYMAP_ACTION_MAX) continue;
        if (n == 0) {
          memset(keymap_buffer, 0, sizeof keymap_buffer);
        }
        keymap_buffer[n++] = kp;
        break;
      }
    }
  }
  if (c.code && get_check("Keep this keymap? ")) {
    keymap_add(mode, c, keymap_buffer, true);
    prt("To use in other sessions, save the keymaps to a file.  Press a key to "
        "continue.",
        17, 0);
    inkey();
  }
}
STATIC_OVL void
ui_keymap_remove(const char* title, int row)
{
  struct keypress c;
  int mode =
      OPT(player, angband_keyset) ? KEYMAP_MODE_ANGBAND : KEYMAP_MODE_ORIG;
  if (OPT(player, hjkl_movement)) {
    mode |= KEYMAP_MODE_ROGUE;
  }
  prt(title, 13, 0);
  prt("Key: ", 14, 0);
  c = keymap_get_trigger();
  if (keymap_remove(mode, c))
    prt("Removed.", 16, 0);
  else
    prt("No keymap to remove!", 16, 0);
  prt("Press any key to continue.", 17, 0);
  inkey();
}
STATIC_OVL void
keymap_browse_hook(int oid, void* db, const region* loc)
{
  char tmp[1024];
  event_signal(EVENT_MESSAGE_FLUSH);
  clear_from(13);
  prt("Current action (if any) shown below:", 13, 0);
  keypress_to_text(tmp, sizeof(tmp), keymap_buffer, false);
  prt(tmp, 14, 0);
}
STATIC_OVL void
do_cmd_keymaps(const char* title, int row)
{
  region loc = {0, 0, 0, 12};
  screen_save();
  clear_from(0);
  if (!keymap_menu) {
    keymap_menu = menu_new_action(keymap_actions, N_ELEMENTS(keymap_actions));
    keymap_menu->title = title;
    keymap_menu->selections = lower_case;
    keymap_menu->browse_hook = keymap_browse_hook;
  }
  menu_layout(keymap_menu, &loc);
  menu_select(keymap_menu, 0, false);
  screen_load();
}
STATIC_OVL void
visuals_pref_load(const char* title, int row)
{
  do_cmd_pref_file_hack(15);
}
STATIC_OVL void
visuals_dump_monsters(const char* title, int row)
{
  dump_pref_file(dump_monsters, title, 15);
}
STATIC_OVL void
visuals_dump_objects(const char* title, int row)
{
  dump_pref_file(dump_objects, title, 15);
}
STATIC_OVL void
visuals_dump_features(const char* title, int row)
{
  dump_pref_file(dump_features, title, 15);
}
STATIC_OVL void
visuals_dump_flavors(const char* title, int row)
{
  dump_pref_file(dump_flavors, title, 15);
}
STATIC_OVL void
visuals_reset(const char* title, int row)
{
  reset_visuals(true);
  prt("", 0, 0);
  msg("Visual attr/char tables reset.");
  event_signal(EVENT_MESSAGE_FLUSH);
}
STATIC_OVL void
visuals_browse_hook(int oid, void* db, const region* loc)
{
  event_signal(EVENT_MESSAGE_FLUSH);
  clear_from(1);
}
STATIC_OVL void
do_cmd_visuals(const char* title, int row)
{
  screen_save();
  clear_from(0);
  if (!visual_menu) {
    visual_menu =
        menu_new_action(visual_menu_items, N_ELEMENTS(visual_menu_items));
    visual_menu->title = title;
    visual_menu->selections = lower_case;
    visual_menu->browse_hook = visuals_browse_hook;
    visual_menu->header = "To edit visuals, use the knowledge menu";
  }
  menu_layout(visual_menu, &SCREEN_REGION);
  menu_select(visual_menu, 0, false);
  screen_load();
}
STATIC_OVL void
colors_pref_load(const char* title, int row)
{
  do_cmd_pref_file_hack(8);
  Term_xtra(TERM_XTRA_REACT, 0);
  Term_redraw_all();
}
STATIC_OVL void
colors_pref_dump(const char* title, int row)
{
  dump_pref_file(dump_colors, title, 15);
}
STATIC_OVL void
colors_modify(const char* title, int row)
{
  int i;
  static uint8_t a = 0;
  prt("Command: Modify colors", 8, 0);
  while (1) {
    const char* name;
    char index;
    struct keypress cx;
    clear_from(10);
    for (i = 0; i < BASIC_COLORS; i++) {
      Term_putstr(i * 3, 20, -1, a, "##");
      Term_putstr(i * 3, 21, -1, (uint8_t)i,
                  format(" %c", color_table[i].index_char));
      Term_putstr(i * 3, 22, -1, (uint8_t)i, format("%2d", i));
    }
    name = ((a < BASIC_COLORS) ? color_table[a].name : "undefined");
    index = ((a < BASIC_COLORS) ? color_table[a].index_char : '?');
    Term_putstr(5, 10, -1, COLOUR_WHITE,
                format("Color = %d, Name = %s, Index = %c", a, name, index));
    Term_putstr(5, 12, -1, COLOUR_WHITE,
                format("K = 0x%02x / R,G,B = 0x%02x,0x%02x,0x%02x",
                       angband_color_table[a][0], angband_color_table[a][1],
                       angband_color_table[a][2], angband_color_table[a][3]));
    Term_putstr(0, 14, -1, COLOUR_WHITE, "Command (n/N/k/K/r/R/g/G/b/B): ");
    cx = inkey();
    if (cx.code == ESCAPE) break;
    if (cx.code == 'n') {
      a = (uint8_t)(a + 1);
      if (a >= MAX_COLORS) {
        a = 0;
      }
    }
    if (cx.code == 'N') {
      a = (uint8_t)(a - 1);
      if (a >= MAX_COLORS) {
        a = MAX_COLORS - 1;
      }
    }
    if (cx.code == 'k')
      angband_color_table[a][0] = (uint8_t)(angband_color_table[a][0] + 1);
    if (cx.code == 'K')
      angband_color_table[a][0] = (uint8_t)(angband_color_table[a][0] - 1);
    if (cx.code == 'r')
      angband_color_table[a][1] = (uint8_t)(angband_color_table[a][1] + 1);
    if (cx.code == 'R')
      angband_color_table[a][1] = (uint8_t)(angband_color_table[a][1] - 1);
    if (cx.code == 'g')
      angband_color_table[a][2] = (uint8_t)(angband_color_table[a][2] + 1);
    if (cx.code == 'G')
      angband_color_table[a][2] = (uint8_t)(angband_color_table[a][2] - 1);
    if (cx.code == 'b')
      angband_color_table[a][3] = (uint8_t)(angband_color_table[a][3] + 1);
    if (cx.code == 'B')
      angband_color_table[a][3] = (uint8_t)(angband_color_table[a][3] - 1);
    Term_xtra(TERM_XTRA_REACT, 0);
    Term_redraw();
  }
}
STATIC_OVL void
colors_browse_hook(int oid, void* db, const region* loc)
{
  event_signal(EVENT_MESSAGE_FLUSH);
  clear_from(1);
}
STATIC_OVL void
do_cmd_colors(const char* title, int row)
{
  screen_save();
  clear_from(0);
  if (!color_menu) {
    color_menu = menu_new_action(color_events, N_ELEMENTS(color_events));
    color_menu->title = title;
    color_menu->selections = lower_case;
    color_menu->browse_hook = colors_browse_hook;
  }
  menu_layout(color_menu, &SCREEN_REGION);
  menu_select(color_menu, 0, false);
  screen_load();
}
STATIC_OVL bool
askfor_aux_numbers(char* buf, size_t buflen, size_t* curs, size_t* len,
                   struct keypress keypress, bool firsttime)
{
  switch (keypress.code) {
    case ESCAPE:
    case KC_ENTER:
    case ARROW_LEFT:
    case ARROW_RIGHT:
    case KC_DELETE:
    case KC_BACKSPACE:
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      return askfor_aux_keypress(buf, buflen, curs, len, keypress, firsttime);
  }
  return false;
}
STATIC_OVL void
do_cmd_delay(const char* name, int unused)
{
  char tmp[4] = "";
  int msec = player->opts.delay_factor;
  strnfmt(tmp, sizeof(tmp), "%i", player->opts.delay_factor);
  screen_save();
  prt("", 19, 0);
  prt("Command: Base Delay Factor", 20, 0);
  prt("New base delay factor (0-255): ", 21, 0);
  prt(format("Current base delay factor: %d msec", msec), 22, 0);
  prt("", 23, 0);
  if (askfor_aux(tmp, sizeof(tmp), askfor_aux_numbers)) {
    uint16_t val = (uint16_t)strtoul(tmp, NULL, 0);
    player->opts.delay_factor = MIN(val, 255);
  }
  screen_load();
}
STATIC_OVL void
do_cmd_sidebar_mode(const char* name, int unused)
{
  char tmp[20] = "";
  const char* names[SIDEBAR_MAX] = {"Left", "Top", "None"};
  struct keypress cx = KEYPRESS_NULL;
  screen_save();
  while (true) {
    my_strcpy(tmp, names[SIDEBAR_MODE % SIDEBAR_MAX], sizeof(tmp));
    prt("", 19, 0);
    prt("Command: Sidebar Mode", 20, 0);
    prt(format("Current mode: %s", tmp), 21, 0);
    prt("ESC: go back, other: cycle", 22, 0);
    prt("", 23, 0);
    cx = inkey();
    if (cx.code == ESCAPE) break;
    SIDEBAR_MODE = (SIDEBAR_MODE + 1) % SIDEBAR_MAX;
  }
  screen_load();
}
STATIC_OVL void
do_cmd_hp_warn(const char* name, int unused)
{
  bool res;
  char tmp[4] = "";
  uint8_t warn;
  strnfmt(tmp, sizeof(tmp), "%i", player->opts.hitpoint_warn);
  screen_save();
  prt("", 19, 0);
  prt("Command: Hitpoint Warning", 20, 0);
  prt("New hitpoint warning (0-9): ", 21, 0);
  prt(format("Current hitpoint warning: %d (%d%%)", player->opts.hitpoint_warn,
             player->opts.hitpoint_warn * 10),
      22, 0);
  prt("", 23, 0);
  res = askfor_aux(tmp, sizeof(tmp), askfor_aux_numbers);
  if (res) {
    warn = (uint8_t)strtoul(tmp, NULL, 0);
    if (warn > 9) warn = 0;
    player->opts.hitpoint_warn = warn;
  }
  screen_load();
}
STATIC_OVL void
do_cmd_lazymove_delay(const char* name, int unused)
{
  bool res;
  char tmp[4] = "";
  strnfmt(tmp, sizeof(tmp), "%i", player->opts.lazymove_delay);
  screen_save();
  prt("", 19, 0);
  prt("Command: Movement Delay Factor", 20, 0);
  prt("New movement delay: ", 21, 0);
  prt(format("Current movement delay: %d (%d msec)",
             player->opts.lazymove_delay, player->opts.lazymove_delay * 10),
      22, 0);
  prt("", 23, 0);
  res = askfor_aux(tmp, sizeof(tmp), askfor_aux_numbers);
  if (res) {
    unsigned long delay = strtoul(tmp, NULL, 0);
    player->opts.lazymove_delay = (uint8_t)MIN(delay, 255);
  }
  screen_load();
}
STATIC_OVL void
do_cmd_pref_file_hack(long row)
{
  char ftmp[80];
  bool ok;
  screen_save();
  if (row > 0) {
    prt("", row - 1, 0);
  }
  prt("Command: Load a user pref file", row, 0);
  prt("", row + 1, 0);
  prt("File: ", row + 2, 0);
  prt("", row + 3, 0);
  player_safe_name(ftmp, sizeof(ftmp), player->full_name, true);
  my_strcat(ftmp, ".prf", sizeof(ftmp));
  if (!arg_force_name)
    ok = askfor_aux(ftmp, sizeof ftmp, NULL);
  else
    ok = get_check(format("Confirm loading %s? ", ftmp));
  if (ok) {
    if (process_pref_file(ftmp, false, true) == false) {
      prt("", 0, 0);
      msg("Failed to load '%s'!", ftmp);
    } else {
      prt("", 0, 0);
      msg("Loaded '%s'.", ftmp);
    }
  }
  screen_load();
}
STATIC_OVL void
do_dump_options(const char* title, int row)
{
  dump_pref_file(option_dump, "Dump window settings", 20);
}
STATIC_OVL void
do_dump_autoinsc(const char* title, int row)
{
  dump_pref_file(dump_autoinscriptions, "Dump autoinscriptions", 20);
}
STATIC_OVL void
options_load_pref_file(const char* n, int row)
{
  do_cmd_pref_file_hack(20);
}
STATIC_OVL const char*
strip_ego_name(const char* name)
{
  if (prefix(name, "of the ")) return name + 7;
  if (prefix(name, "of ")) return name + 3;
  return name;
}
STATIC_OVL int
ego_item_name(char* buf, size_t buf_size, struct ego_desc* desc)
{
  size_t i;
  int end;
  size_t prefix_size;
  const char* long_name;
  struct ego_item* ego = &e_info[desc->e_idx];
  for (i = 0; i < N_ELEMENTS(quality_choices); i++)
    if (desc->itype == i) break;
  if (i == N_ELEMENTS(quality_choices)) return 0;
  end = my_strcat(buf, "[ ] ", buf_size);
  end += my_strcat(buf, quality_choices[i].name, buf_size);
  end += my_strcat(buf, " ", buf_size);
  long_name = ego->name;
  prefix_size = (desc->short_name - long_name);
  if (prefix_size > 0) {
    char prefix[100];
    my_strcpy(prefix, long_name, prefix_size + 1);
    end += my_strcat(buf, prefix, buf_size);
  }
  return end;
}
STATIC_OVL int
ego_comp_func(const void* a_ptr, const void* b_ptr)
{
  const struct ego_desc* a = a_ptr;
  const struct ego_desc* b = b_ptr;
  return (strcmp(a->short_name, b->short_name));
}
STATIC_OVL void
ego_display(struct menu* menu, int oid, bool cursor, int row, int col,
            int width)
{
  char buf[80] = "";
  struct ego_desc* choice = (struct ego_desc*)menu->menu_data;
  bool ignored = ego_is_ignored(choice[oid].e_idx, choice[oid].itype);
  uint8_t attr = (cursor ? COLOUR_L_BLUE : COLOUR_WHITE);
  uint8_t sq_attr = (ignored ? COLOUR_L_RED : COLOUR_L_GREEN);
  (void)ego_item_name(buf, sizeof(buf), &choice[oid]);
  c_put_str(attr, format("%s", buf), row, col);
  if (ignored) c_put_str(COLOUR_L_RED, "*", row, col + 1);
  c_put_str(sq_attr, choice[oid].short_name, row, col + strlen(buf));
}
STATIC_OVL bool
ego_action(struct menu* menu, const ui_event* event, int oid)
{
  struct ego_desc* choice = menu->menu_data;
  if (event->type == EVT_SELECT) {
    ego_ignore_toggle(choice[oid].e_idx, choice[oid].itype);
    return true;
  }
  return false;
}
STATIC_OVL void
ego_menu(const char* unused, int also_unused)
{
  int max_num = 0;
  struct ego_item* ego;
  struct ego_desc* choice;
  struct menu menu;
  menu_iter menu_f = {0, 0, ego_display, ego_action, 0};
  region area = {1, 5, -1, -1};
  int cursor = 0;
  int i;
  choice = mem_zalloc(z_info->e_max * ITYPE_MAX * sizeof(struct ego_desc));
  for (i = 0; i < z_info->e_max; i++) {
    int itype;
    ego = &e_info[i];
    if (!ego->name || !ego->everseen) continue;
    for (itype = ITYPE_NONE + 1; itype < ITYPE_MAX; itype++)
      if (ego_has_ignore_type(ego, itype)) {
        choice[max_num].e_idx = i;
        choice[max_num].itype = itype;
        choice[max_num].short_name = strip_ego_name(ego->name);
        ++max_num;
      }
  }
  qsort(choice, max_num, sizeof(choice[0]), ego_comp_func);
  if (!max_num) {
    mem_free(choice);
    return;
  }
  screen_save();
  clear_from(0);
  prt("Ego item ignore menu", 0, 0);
  text_out_hook = text_out_to_screen;
  text_out_indent = 1;
  text_out_wrap = 79;
  Term_gotoxy(1, 1);
  text_out_e(
      "{light green}Movement keys{/} scroll the list\n{light red}ESC{/} "
      "returns to the previous menu\n{light blue}Enter{/} toggles the current "
      "setting.");
  text_out_indent = 0;
  memset(&menu, 0, sizeof(menu));
  menu_init(&menu, MN_SKIN_SCROLL, &menu_f);
  menu_setpriv(&menu, max_num, choice);
  menu_layout(&menu, &area);
  (void)menu_select(&menu, cursor, false);
  mem_free(choice);
  screen_load();
  return;
}
STATIC_OVL int
cmp_ignore(const void* a, const void* b)
{
  char bufa[80];
  char bufb[80];
  const ignore_choice* x = a;
  const ignore_choice* y = b;
  if (!x->aware && y->aware) return 1;
  if (x->aware && !y->aware) return -1;
  object_kind_name(bufa, sizeof(bufa), x->kind, x->aware);
  object_kind_name(bufb, sizeof(bufb), y->kind, y->aware);
  return strcmp(bufa, bufb);
}
STATIC_OVL int
quality_validity(struct menu* menu, int oid)
{
  return oid ? 1 : 0;
}
STATIC_OVL void
quality_display(struct menu* menu, int oid, bool cursor, int row, int col,
                int width)
{
  if (oid) {
    const char* name = quality_choices[oid].name;
    uint8_t level = ignore_level[oid];
    const char* level_name = quality_values[level].name;
    uint8_t attr = (cursor ? COLOUR_L_BLUE : COLOUR_WHITE);
    size_t u8len = utf8_strlen(name);
    if (u8len < 30) {
      c_put_str(attr, format("%s%*s", name, (int)(30 - u8len), " "), row, col);
    } else {
      char* name_copy = string_make(name);
      if (u8len > 30) {
        utf8_clipto(name_copy, 30);
      }
      c_put_str(attr, name_copy, row, col);
      string_free(name_copy);
    }
    c_put_str(attr, format(" : %s", level_name), row, col + 30);
  }
}
STATIC_OVL void
quality_subdisplay(struct menu* menu, int oid, bool cursor, int row, int col,
                   int width)
{
  const char* name = quality_values[oid].name;
  uint8_t attr = (cursor ? COLOUR_L_BLUE : COLOUR_WHITE);
  c_put_str(attr, name, row, col);
}
STATIC_OVL bool
quality_action(struct menu* m, const ui_event* event, int oid)
{
  struct menu menu;
  menu_iter menu_f = {NULL, NULL, quality_subdisplay, NULL, NULL};
  region area = {37, 2, 29, IGNORE_MAX};
  ui_event evt;
  int count;
  area.row += oid;
  screen_save();
  count = IGNORE_MAX;
  if ((oid == ITYPE_RING) || (oid == ITYPE_AMULET))
    count = area.page_rows = IGNORE_BAD + 1;
  menu_init(&menu, MN_SKIN_SCROLL, &menu_f);
  menu_setpriv(&menu, count, quality_values);
  if (area.row + menu.count > Term->hgt - 1)
    area.row += Term->hgt - 1 - area.row - menu.count;
  menu_layout(&menu, &area);
  window_make(area.col - 2, area.row - 1, area.col + area.width + 2,
              area.row + area.page_rows);
  evt = menu_select(&menu, 0, true);
  if (evt.type == EVT_SELECT) ignore_level[oid] = menu.cursor;
  screen_load();
  return true;
}
STATIC_OVL void
quality_menu(const char* unused, int also_unused)
{
  struct menu menu;
  menu_iter menu_f = {NULL, quality_validity, quality_display, quality_action,
                      NULL};
  region area = {0, 0, 0, 0};
  screen_save();
  clear_from(0);
  menu_init(&menu, MN_SKIN_SCROLL, &menu_f);
  menu.title = "Quality ignore menu";
  menu_setpriv(&menu, ITYPE_MAX, quality_values);
  menu_layout(&menu, &area);
  menu_select(&menu, 0, false);
  screen_load();
  return;
}
STATIC_OVL bool
ignore_tval(int tval)
{
  size_t i;
  for (i = 0; i < N_ELEMENTS(sval_dependent); i++) {
    if (kb_info[tval].num_svals == 0) continue;
    if (tval == sval_dependent[i].tval) return true;
  }
  return false;
}
STATIC_OVL void
ignore_sval_menu_display(struct menu* menu, int oid, bool cursor, int row,
                         int col, int width)
{
  char buf[80];
  const ignore_choice* choice = menu_priv(menu);
  struct object_kind* kind = choice[oid].kind;
  bool aware = choice[oid].aware;
  uint8_t attr = curs_attrs[(int)aware][0 != cursor];
  object_kind_name(buf, sizeof(buf), kind, aware);
  c_put_str(attr, format("[ ] %s", buf), row, col);
  if ((aware && (kind->ignore & IGNORE_IF_AWARE)) ||
      (!aware && (kind->ignore & IGNORE_IF_UNAWARE)))
    c_put_str(COLOUR_L_RED, "*", row, col + 1);
}
STATIC_OVL bool
ignore_sval_menu_action(struct menu* m, const ui_event* event, int oid)
{
  const ignore_choice* choice = menu_priv(m);
  if (event->type == EVT_SELECT ||
      (event->type == EVT_KBRD && tolower(event->key.code) == 't')) {
    struct object_kind* kind = choice[oid].kind;
    if (choice[oid].aware)
      kind->ignore ^= IGNORE_IF_AWARE;
    else
      kind->ignore ^= IGNORE_IF_UNAWARE;
    player->upkeep->notice |= PN_IGNORE;
    return true;
  }
  return false;
}
STATIC_OVL int
ignore_collect_kind(int tval, ignore_choice** ch)
{
  ignore_choice* choice;
  int num = 0;
  int i;
  choice = mem_alloc(2 * z_info->k_max * sizeof *choice);
  for (i = 1; i < z_info->k_max; i++) {
    struct object_kind* kind = &k_info[i];
    if (!kind->name || kind->tval != tval) continue;
    if (!kind->aware) {
      choice[num].kind = kind;
      choice[num++].aware = false;
    }
    if (kind->everseen && !kf_has(kind->kind_flags, KF_INSTA_ART)) {
      choice[num].kind = kind;
      choice[num++].aware = true;
    }
  }
  if (num == 0)
    mem_free(choice);
  else
    *ch = choice;
  return num;
}
STATIC_OVL bool
sval_menu(int tval, const char* desc)
{
  struct menu* menu;
  region area = {1, 2, -1, -1};
  ignore_choice* choices;
  int n_choices = ignore_collect_kind(tval, &choices);
  if (!n_choices) return false;
  switch (tval) {
    case TV_LIGHT:
      break;
    default:
      sort(choices, n_choices, sizeof(*choices), cmp_ignore);
  }
  screen_save();
  clear_from(0);
  prt(format("Ignore the following %s:", desc), 0, 0);
  menu = menu_new(MN_SKIN_COLUMNS, &ignore_sval_menu);
  menu_setpriv(menu, n_choices, choices);
  menu->cmd_keys = "Tt";
  menu_layout(menu, &area);
  menu_set_cursor_x_offset(menu, 1);
  menu_select(menu, 0, false);
  mem_free(menu);
  mem_free(choices);
  screen_load();
  return true;
}
STATIC_OVL bool
seen_tval(int tval)
{
  int i;
  for (i = 1; i < z_info->k_max; i++) {
    struct object_kind* kind = &k_info[i];
    if (!kind->name) continue;
    if (!kind->everseen) continue;
    if (kind->tval != tval) continue;
    return true;
  }
  return false;
}
STATIC_OVL char
tag_options_item(struct menu* menu, int oid)
{
  size_t line = (size_t)oid;
  if (line < N_ELEMENTS(sval_dependent)) return all_letters_nohjkl[oid];
  if (line == N_ELEMENTS(sval_dependent)) return 0;
  line = line - N_ELEMENTS(sval_dependent) - 1;
  if (line < N_ELEMENTS(extra_item_options))
    return extra_item_options[line].tag;
  return 0;
}
STATIC_OVL int
valid_options_item(struct menu* menu, int oid)
{
  size_t line = (size_t)oid;
  if (line < N_ELEMENTS(sval_dependent)) return 1;
  if (line == N_ELEMENTS(sval_dependent)) return 0;
  line = line - N_ELEMENTS(sval_dependent) - 1;
  if (line < N_ELEMENTS(extra_item_options)) return 1;
  return 0;
}
STATIC_OVL void
display_options_item(struct menu* menu, int oid, bool cursor, int row, int col,
                     int width)
{
  size_t line = (size_t)oid;
  if (line < N_ELEMENTS(sval_dependent)) {
    bool known = seen_tval(sval_dependent[line].tval);
    uint8_t attr = curs_attrs[known ? CURS_KNOWN : CURS_UNKNOWN][(int)cursor];
    c_prt(attr, sval_dependent[line].desc, row, col);
  } else {
    uint8_t attr = curs_attrs[CURS_KNOWN][(int)cursor];
    line = line - N_ELEMENTS(sval_dependent) - 1;
    if (line < N_ELEMENTS(extra_item_options))
      c_prt(attr, extra_item_options[line].name, row, col);
  }
}
STATIC_OVL bool
handle_options_item(struct menu* menu, const ui_event* event, int oid)
{
  if (event->type == EVT_SELECT) {
    if ((size_t)oid < N_ELEMENTS(sval_dependent)) {
      sval_menu(sval_dependent[oid].tval, sval_dependent[oid].desc);
    } else {
      oid = oid - (int)N_ELEMENTS(sval_dependent) - 1;
      assert((size_t)oid < N_ELEMENTS(extra_item_options));
      extra_item_options[oid].action(NULL, 0);
    }
    return true;
  }
  return false;
}
STATIC_OVL void
do_cmd_options_item(const char* title, int row)
{
  struct menu menu;
  menu_init(&menu, MN_SKIN_SCROLL, &options_item_iter);
  menu_setpriv(&menu,
               N_ELEMENTS(sval_dependent) + N_ELEMENTS(extra_item_options) + 1,
               NULL);
  menu.title = title;
  menu_layout(&menu, &SCREEN_REGION);
  screen_save();
  clear_from(0);
  menu_select(&menu, 0, false);
  screen_load();
  player->upkeep->notice |= PN_IGNORE;
  return;
}
STATIC_OVL void
do_cmd_options(void)
{
  if (!option_menu) {
    option_menu = menu_new_action(option_actions, N_ELEMENTS(option_actions));
    option_menu->title = "Options Menu";
    option_menu->flags = MN_CASELESS_TAGS;
  }
  screen_save();
  clear_from(0);
  menu_layout(option_menu, &SCREEN_REGION);
  menu_select(option_menu, 0, false);
  screen_load();
}
STATIC_OVL void
cleanup_options(void)
{
  if (keymap_menu) menu_free(keymap_menu);
  if (visual_menu) menu_free(visual_menu);
  if (color_menu) menu_free(color_menu);
  if (option_menu) menu_free(option_menu);
}
STATIC_OVL region
region_calculate(region loc)
{
  int w, h;
  Term_get_size(&w, &h);
  if (loc.col < 0) loc.col += w;
  if (loc.row < 0) loc.row += h;
  if (loc.width <= 0) loc.width += w - loc.col;
  if (loc.page_rows <= 0) loc.page_rows += h - loc.row;
  return loc;
}
STATIC_OVL void
region_erase_bordered(const region* loc)
{
  region calc = region_calculate(*loc);
  int i = 0;
  calc.col = MAX(calc.col - 1, 0);
  calc.row = MAX(calc.row - 1, 0);
  calc.width += 2;
  calc.page_rows += 2;
  for (i = 0; i < calc.page_rows; i++)
    Term_erase(calc.col, calc.row + i, calc.width);
}
STATIC_OVL void
region_erase(const region* loc)
{
  region calc = region_calculate(*loc);
  int i = 0;
  for (i = 0; i < calc.page_rows; i++)
    Term_erase(calc.col, calc.row + i, calc.width);
}
STATIC_OVL bool
region_inside(const region* loc, const ui_event* key)
{
  if ((loc->col > key->mouse.x) || (loc->col + loc->width <= key->mouse.x))
    return false;
  if ((loc->row > key->mouse.y) || (loc->row + loc->page_rows <= key->mouse.y))
    return false;
  return true;
}
STATIC_OVL void
display_area(const wchar_t* text, const int* attrs, size_t* line_starts,
             size_t* line_lengths, size_t n_lines, region area,
             size_t line_from)
{
  size_t i, j;
  n_lines = MIN(n_lines, (size_t)area.page_rows);
  for (i = 0; i < n_lines; i++) {
    Term_erase(area.col, area.row + i, area.width);
    for (j = 0; j < line_lengths[line_from + i]; j++) {
      Term_putch(area.col + j, area.row + i,
                 attrs[line_starts[line_from + i] + j],
                 text[line_starts[line_from + i] + j]);
    }
  }
}
STATIC_OVL void
textui_textblock_place(textblock* tb, region orig_area, const char* header)
{
  region area = region_calculate(orig_area);
  size_t *line_starts = NULL, *line_lengths = NULL;
  size_t n_lines;
  n_lines =
      textblock_calculate_lines(tb, &line_starts, &line_lengths, area.width);
  if (header != NULL) {
    area.page_rows--;
    Term_erase(area.col, area.row, area.width);
    c_put_str(COLOUR_L_BLUE, header, area.row, area.col);
    area.row++;
  }
  if (n_lines > (size_t)area.page_rows) n_lines = area.page_rows;
  display_area(textblock_text(tb), textblock_attrs(tb), line_starts,
               line_lengths, n_lines, area, 0);
  mem_free(line_starts);
  mem_free(line_lengths);
}
STATIC_OVL struct keypress
textui_textblock_show(textblock* tb, region orig_area, const char* header)
{
  region area = region_calculate(orig_area);
  size_t *line_starts = NULL, *line_lengths = NULL;
  size_t n_lines;
  struct keypress ch = KEYPRESS_NULL;
  n_lines =
      textblock_calculate_lines(tb, &line_starts, &line_lengths, area.width);
  screen_save();
  area.page_rows -= 2;
  if (header != NULL) {
    area.page_rows--;
    Term_erase(area.col, area.row, area.width);
    c_put_str(COLOUR_L_BLUE, header, area.row, area.col);
    area.row++;
  }
  if (n_lines > (size_t)area.page_rows) {
    int start_line = 0;
    Term_erase(area.col, area.row + area.page_rows, area.width);
    Term_erase(area.col, area.row + area.page_rows + 1, area.width);
    c_put_str(COLOUR_L_BLUE, "(Up/down or ESCAPE to exit.)",
              area.row + area.page_rows + 1, area.col);
    while (1) {
      display_area(textblock_text(tb), textblock_attrs(tb), line_starts,
                   line_lengths, n_lines, area, start_line);
      ch = inkey();
      if (ch.code == ARROW_UP)
        start_line--;
      else if (ch.code == ESCAPE || ch.code == 'q' || ch.code == 'x')
        break;
      else if (ch.code == ']' || ch.code == '[')
        break;
      else if (ch.code == ARROW_DOWN)
        start_line++;
      else if (ch.code == ' ')
        start_line += area.page_rows;
      if (start_line < 0) start_line = 0;
      if (start_line + (size_t)area.page_rows > n_lines)
        start_line = n_lines - area.page_rows;
    }
  } else {
    display_area(textblock_text(tb), textblock_attrs(tb), line_starts,
                 line_lengths, n_lines, area, 0);
    Term_erase(area.col, area.row + n_lines, area.width);
    Term_erase(area.col, area.row + n_lines + 1, area.width);
    c_put_str(COLOUR_L_BLUE, "(Press any key to continue.)",
              area.row + n_lines + 1, area.col);
    ch = inkey();
  }
  mem_free(line_starts);
  mem_free(line_lengths);
  screen_load();
  return (ch);
}
STATIC_OVL void
text_out_to_screen(int a, const char* str)
{
  int x, y;
  int wid, h;
  int wrap;
  const wchar_t* s;
  wchar_t buf[1024];
  (void)Term_get_size(&wid, &h);
  (void)Term_locate(&x, &y);
  text_mbstowcs(buf, str, 1024);
  if ((text_out_wrap > 0) && (text_out_wrap < wid))
    wrap = text_out_wrap;
  else
    wrap = wid;
  for (s = buf; *s; s++) {
    wchar_t ch;
    if (*s == L'\n') {
      x = text_out_indent;
      y++;
      Term_erase(x, y, 255);
      x += text_out_pad;
      Term_gotoxy(x, y);
      continue;
    }
    ch = (text_iswprint(*s) ? *s : L' ');
    if ((x >= wrap - 1) && (ch != L' ')) {
      int i, n = 0;
      int av[256];
      wchar_t cv[256];
      if (x < wrap) {
        for (i = wrap - 2; i >= 0; i--) {
          Term_what(i, y, &av[i], &cv[i]);
          if (cv[i] == L' ') break;
          n = i;
        }
      }
      if (n == 0) n = wrap;
      Term_erase(n, y, 255);
      x = text_out_indent;
      y++;
      Term_erase(x, y, 255);
      x += text_out_pad;
      Term_gotoxy(x, y);
      for (i = n; i < wrap - 1; i++) {
        Term_addch(av[i], cv[i]);
        if (++x > wrap) x = wrap;
      }
    }
    Term_addch(a, ch);
    if (++x > wrap) x = wrap;
  }
}
STATIC_OVL void
c_put_str(uint8_t attr, const char* str, int row, int col)
{
  Term_putstr(col, row, -1, attr, str);
}
STATIC_OVL void
put_str(const char* str, int row, int col)
{
  c_put_str(COLOUR_WHITE, str, row, col);
}
STATIC_OVL void
c_prt(uint8_t attr, const char* str, int row, int col)
{
  Term_erase(col, row, 255);
  Term_addstr(-1, attr, str);
}
STATIC_OVL void
prt(const char* str, int row, int col)
{
  c_prt(COLOUR_WHITE, str, row, col);
}
STATIC_OVL void
screen_save(void)
{
  player->upkeep->redraw |= PR_MAP;
  redraw_stuff(player);
  event_signal(EVENT_MESSAGE_FLUSH);
  Term_save();
  screen_save_depth++;
}
STATIC_OVL void
screen_load(void)
{
  event_signal(EVENT_MESSAGE_FLUSH);
  Term_load();
  screen_save_depth--;
}
STATIC_OVL void
screen_load_all(void)
{
  event_signal(EVENT_MESSAGE_FLUSH);
  Term_load_all();
  screen_save_depth--;
}
STATIC_OVL bool
textui_map_is_visible(void)
{
  if (player->is_dead) return true;
  return (cave && screen_save_depth == 0);
}
STATIC_OVL void
window_make(int origin_x, int origin_y, int end_x, int end_y)
{
  int n;
  region to_clear;
  to_clear.col = origin_x;
  to_clear.row = origin_y;
  to_clear.width = end_x - origin_x;
  to_clear.page_rows = end_y - origin_y;
  region_erase(&to_clear);
  Term_putch(origin_x, origin_y, COLOUR_WHITE, L'+');
  Term_putch(end_x, origin_y, COLOUR_WHITE, L'+');
  Term_putch(origin_x, end_y, COLOUR_WHITE, L'+');
  Term_putch(end_x, end_y, COLOUR_WHITE, L'+');
  for (n = 1; n < (end_x - origin_x); n++) {
    Term_putch(origin_x + n, origin_y, COLOUR_WHITE, L'-');
    Term_putch(origin_x + n, end_y, COLOUR_WHITE, L'-');
  }
  for (n = 1; n < (end_y - origin_y); n++) {
    Term_putch(origin_x, origin_y + n, COLOUR_WHITE, L'|');
    Term_putch(end_x, origin_y + n, COLOUR_WHITE, L'|');
  }
}
STATIC_OVL bool
panel_should_modify(term* t, int wy, int wx)
{
  int dungeon_hgt = cave->height;
  int dungeon_wid = cave->width;
  int screen_hgt = (t == angband_term[0]) ? SCREEN_HGT : t->hgt / tile_height;
  int screen_wid = (t == angband_term[0]) ? SCREEN_WID : t->wid / tile_width;
  if (wy > dungeon_hgt - screen_hgt) wy = dungeon_hgt - screen_hgt;
  if (wy < 0) wy = 0;
  if (wx > dungeon_wid - screen_wid) wx = dungeon_wid - screen_wid;
  if (wx < 0) wx = 0;
  return ((t->offset_y != wy) || (t->offset_x != wx));
}
STATIC_OVL bool
modify_panel(term* t, int wy, int wx)
{
  int dungeon_hgt = cave->height;
  int dungeon_wid = cave->width;
  int screen_hgt = (t == angband_term[0]) ? SCREEN_HGT : t->hgt / tile_height;
  int screen_wid = (t == angband_term[0]) ? SCREEN_WID : t->wid / tile_width;
  if (wy > dungeon_hgt - screen_hgt) wy = dungeon_hgt - screen_hgt;
  if (wy < 0) wy = 0;
  if (wx > dungeon_wid - screen_wid) wx = dungeon_wid - screen_wid;
  if (wx < 0) wx = 0;
  if (panel_should_modify(t, wy, wx)) {
    t->offset_y = wy;
    t->offset_x = wx;
    player->upkeep->redraw |= (PR_MAP);
    return (true);
  }
  return (false);
}
STATIC_OVL void
verify_panel_int(bool centered, bool avoid_center)
{
  int wy, wx;
  int screen_hgt, screen_wid;
  int panel_wid, panel_hgt;
  int py = player->grid.y;
  int px = player->grid.x;
  int j;
  for (j = 0; j < ANGBAND_TERM_MAX; j++) {
    term* t = angband_term[j];
    if (!t) continue;
    if ((j > 0) && !(window_flag[j] & (PW_OVERHEAD))) continue;
    wy = t->offset_y;
    wx = t->offset_x;
    screen_hgt = (j == 0) ? SCREEN_HGT : t->hgt / tile_height;
    screen_wid = (j == 0) ? SCREEN_WID : t->wid / tile_width;
    panel_wid = screen_wid / 2;
    panel_hgt = screen_hgt / 2;
    if (centered && (!player->upkeep->running || !avoid_center) &&
        (py != wy + panel_hgt))
      wy = py - panel_hgt;
    else if ((py < wy + 3) || (py >= wy + screen_hgt - 3))
      wy = py - panel_hgt;
    if (centered && (!player->upkeep->running || !avoid_center) &&
        (px != wx + panel_wid))
      wx = px - panel_wid;
    else if ((px < wx + 3) || (px >= wx + screen_wid - 3))
      wx = px - panel_wid;
    modify_panel(t, wy, wx);
  }
}
STATIC_OVL bool
change_panel(int dir)
{
  bool changed = false;
  int j;
  for (j = 0; j < ANGBAND_TERM_MAX; j++) {
    int screen_hgt, screen_wid;
    int wx, wy;
    term* t = angband_term[j];
    if (!t) continue;
    if ((j > 0) && !(window_flag[j] & PW_OVERHEAD)) continue;
    screen_hgt = (j == 0) ? SCREEN_HGT : t->hgt / tile_height;
    screen_wid = (j == 0) ? SCREEN_WID : t->wid / tile_width;
    wy = t->offset_y + ddy[dir] * screen_hgt / 2;
    wx = t->offset_x + ddx[dir] * screen_wid / 2;
    if (modify_panel(t, wy, wx)) changed = true;
  }
  return (changed);
}
STATIC_OVL void
verify_panel(void)
{
  verify_panel_int(OPT(player, center_player), OPT(player, run_avoid_center));
}
STATIC_OVL void
center_panel(void)
{
  verify_panel_int(true, OPT(player, run_avoid_center));
}
STATIC_OVL void
textui_get_panel(int* min_y, int* min_x, int* max_y, int* max_x)
{
  term* t = term_screen;
  if (!t) return;
  *min_y = t->offset_y;
  *min_x = t->offset_x;
  *max_y = t->offset_y + SCREEN_HGT;
  *max_x = t->offset_x + SCREEN_WID;
}
STATIC_OVL bool
textui_panel_contains(unsigned int y, unsigned int x)
{
  unsigned int hgt;
  unsigned int wid;
  if (!Term) return true;
  if (Term == term_screen) {
    hgt = SCREEN_HGT;
    wid = SCREEN_WID;
  } else {
    hgt = Term->hgt / tile_height;
    wid = Term->wid / tile_width;
  }
  return (y - Term->offset_y) < hgt && (x - Term->offset_x) < wid;
}
STATIC_OVL struct panel*
panel_allocate(int n)
{
  struct panel* p = mem_zalloc(sizeof *p);
  p->len = 0;
  p->max = n;
  p->lines = mem_zalloc(p->max * sizeof *p->lines);
  return p;
}
STATIC_OVL void
panel_free(struct panel* p)
{
  assert(p);
  mem_free(p->lines);
  mem_free(p);
}
STATIC_OVL void
panel_line(struct panel* p, uint8_t attr, const char* label, const char* fmt,
           ...)
{
  va_list vp;
  struct panel_line* pl;
  assert(p);
  assert(p->len != p->max);
  pl = &p->lines[p->len++];
  pl->attr = attr;
  pl->label = label;
  va_start(vp, fmt);
  vstrnfmt(pl->value, sizeof pl->value, fmt, vp);
  va_end(vp);
}
STATIC_OVL void
panel_space(struct panel* p)
{
  assert(p);
  assert(p->len != p->max);
  p->len++;
}
STATIC_OVL void
display_player_stat_info(void)
{
  int i, row = 2, col = 41;
  char buf[80];
  for (i = 0; i < STAT_MAX; i++) {
    if (player->stat_drain[i] < 0)
      put_str(stat_names_reduced[i], row + i, col);
    else
      put_str(stat_names[i], row + i, col);
    strnfmt(buf, sizeof(buf), "%2d", player->state.stat_use[i]);
    if (player->stat_drain[i] < 0)
      c_put_str(COLOUR_YELLOW, buf, row + i, col + 5);
    else
      c_put_str(COLOUR_L_GREEN, buf, row + i, col + 5);
    if (player->state.stat_equip_mod[i] != 0) {
      c_put_str(COLOUR_SLATE, "=", row + i, col + 8);
      strnfmt(buf, sizeof(buf), "%2d", player->stat_base[i]);
      c_put_str(COLOUR_GREEN, buf, row + i, col + 10);
      strnfmt(buf, sizeof(buf), "%+3d", player->state.stat_equip_mod[i]);
      c_put_str(COLOUR_SLATE, buf, row + i, col + 13);
    }
    if (player->stat_drain[i] != 0) {
      c_put_str(COLOUR_SLATE, "=", row + i, col + 8);
      strnfmt(buf, sizeof(buf), "%2d", player->stat_base[i]);
      c_put_str(COLOUR_GREEN, buf, row + i, col + 10);
      strnfmt(buf, sizeof(buf), "%+3d", player->stat_drain[i]);
      c_put_str(COLOUR_SLATE, buf, row + i, col + 17);
    }
    if (player->state.stat_misc_mod[i] != 0) {
      c_put_str(COLOUR_SLATE, "=", row + i, col + 8);
      strnfmt(buf, sizeof(buf), "%2d", player->stat_base[i]);
      c_put_str(COLOUR_GREEN, buf, row + i, col + 10);
      strnfmt(buf, sizeof(buf), "%+3d", player->state.stat_misc_mod[i]);
      c_put_str(COLOUR_SLATE, buf, row + i, col + 21);
    }
  }
}
STATIC_OVL void
display_player_skill_info(void)
{
  int skill, row, col = 41;
  for (skill = 0; skill < SKILL_MAX; skill++) {
    int stat = player->state.skill_stat_mod[skill];
    int equip = player->state.skill_equip_mod[skill];
    int misc = player->state.skill_misc_mod[skill];
    row = 7 + skill;
    put_str(skill_names[skill], row, col);
    c_put_str(COLOUR_L_GREEN, format("%3d", player->state.skill_use[skill]),
              row, col + 11);
    c_put_str(COLOUR_SLATE, "=", row, col + 15);
    c_put_str(COLOUR_GREEN, format("%2d", player->skill_base[skill]), row,
              col + 17);
    if (stat != 0) c_put_str(COLOUR_SLATE, format("%+3d", stat), row, col + 20);
    if (equip != 0)
      c_put_str(COLOUR_SLATE, format("%+3d", equip), row, col + 24);
    if (misc != 0) c_put_str(COLOUR_SLATE, format("%+3d", misc), row, col + 28);
  }
}
STATIC_OVL void
display_panel(const struct panel* p, bool left_adj, const region* bounds)
{
  size_t i;
  int col = bounds->col;
  int row = bounds->row;
  int w = bounds->width;
  int offset = 0;
  region_erase(bounds);
  if (left_adj) {
    for (i = 0; i < p->len; i++) {
      struct panel_line* pl = &p->lines[i];
      int len = pl->label ? strlen(pl->label) : 0;
      if (offset < len) offset = len;
    }
    offset += 2;
  }
  for (i = 0; i < p->len; i++, row++) {
    int len;
    struct panel_line* pl = &p->lines[i];
    if (!pl->label) continue;
    Term_putstr(col, row, strlen(pl->label), COLOUR_WHITE, pl->label);
    len = strlen(pl->value);
    len = len < w - offset ? len : w - offset - 1;
    if (left_adj)
      Term_putstr(col + offset, row, len, pl->attr, pl->value);
    else
      Term_putstr(col + w - len, row, len, pl->attr, pl->value);
  }
}
STATIC_OVL uint8_t
max_color(int val, int max)
{
  return val < max ? COLOUR_YELLOW : COLOUR_L_GREEN;
}
STATIC_OVL struct panel*
get_panel_topleft(void)
{
  struct panel* p = panel_allocate(4);
  panel_line(p, COLOUR_L_BLUE, "Name", "%s", player->full_name);
  panel_line(p, COLOUR_L_BLUE, "Sex", "%s", player->sex->name);
  panel_line(p, COLOUR_L_BLUE, "Race", "%s", player->race->name);
  panel_line(p, COLOUR_L_BLUE, "House", "%s", player->house->short_name);
  return p;
}
STATIC_OVL struct panel*
get_panel_midleft(void)
{
  struct panel* p = panel_allocate(8);
  panel_line(p, COLOUR_L_GREEN, "Game Turn", "%d", player->turn);
  panel_line(p, COLOUR_L_GREEN, "Exp Pool", "%d", player->new_exp);
  panel_line(p, COLOUR_L_GREEN, "Total Exp", "%d", player->exp);
  panel_line(
      p, max_color(weight_limit(player->state), player->upkeep->total_weight),
      "Burden", "%.1f", player->upkeep->total_weight / 10.0F);
  panel_line(p, COLOUR_L_GREEN, "Max Burden", "%.1f",
             weight_limit(player->state) / 10.0F);
  if (turn > 0) {
    panel_line(p, max_color(player->depth, player_min_depth(player)), "Depth",
               "%3d'", player->depth * 50);
    panel_line(p, COLOUR_L_GREEN, "Min Depth", "%3d'",
               player_min_depth(player) * 50);
  } else {
    panel_space(p);
    panel_space(p);
  }
  panel_line(p, COLOUR_L_GREEN, "Light Radius", "%3d",
             player->upkeep->cur_light);
  return p;
}
STATIC_OVL struct panel*
get_panel_combat(void)
{
  struct panel* p = panel_allocate(9);
  int mel, arc;
  int add_lines = 3;
  mel = player->state.skill_use[SKILL_MELEE];
  panel_line(p, COLOUR_L_BLUE, "Melee", "(%+d,%dd%d)", mel, player->state.mdd,
             player->state.mds);
  if (player_active_ability(player, "Rapid Attack")) {
    add_lines--;
    panel_line(p, COLOUR_L_BLUE, "", "(%+d,%dd%d)", mel, player->state.mdd,
               player->state.mds);
  }
  if (player->state.mds2 > 0) {
    add_lines--;
    mel += player->state.offhand_mel_mod;
    panel_line(p, COLOUR_L_BLUE, "", "(%+d,%dd%d)", mel, player->state.mdd2,
               player->state.mds2);
  }
  arc = player->state.skill_use[SKILL_ARCHERY];
  panel_line(p, COLOUR_L_BLUE, "Bows", "(%+d,%dd%d)", arc, player->state.add,
             player->state.ads);
  if (player_active_ability(player, "Rapid Fire")) {
    add_lines--;
    panel_line(p, COLOUR_L_BLUE, "", "(%+d,%dd%d)", arc, player->state.add,
               player->state.ads);
  }
  panel_line(p, COLOUR_L_BLUE, "Armor", "[%+d,%d-%d]",
             player->state.skill_use[SKILL_EVASION],
             protection_roll(player, PROJ_HURT, true, MINIMISE),
             protection_roll(player, PROJ_HURT, true, MAXIMISE));
  if (add_lines) {
    panel_space(p);
    add_lines--;
  }
  panel_line(p, COLOUR_L_BLUE, "Health", "%d:%d", player->chp, player->mhp);
  panel_line(p, COLOUR_L_BLUE, "Voice", "%d:%d", player->csp, player->msp);
  if (player->song[SONG_MAIN]) {
    panel_line(p, COLOUR_L_BLUE, "Song", "%s", player->song[SONG_MAIN]->name);
    if (player->song[SONG_MINOR]) {
      panel_line(p, COLOUR_L_BLUE, "", "%s", player->song[SONG_MINOR]->name);
    }
  }
  return p;
}
STATIC_OVL struct panel*
get_panel_misc(void)
{
  struct panel* p = panel_allocate(3);
  uint8_t attr = COLOUR_L_BLUE;
  panel_line(p, attr, "Age", "%d", player->age);
  panel_line(p, attr, "Height", "%d'%d\"", player->ht / 12, player->ht % 12);
  panel_line(p, attr, "Weight", "%d", player->wt);
  return p;
}
STATIC_OVL void
display_player_xtra_info(void)
{
  size_t i;
  for (i = 0; i < N_ELEMENTS(panels); i++) {
    struct panel* p = panels[i].panel();
    display_panel(p, panels[i].align_left, &panels[i].bounds);
    panel_free(p);
  }
  text_out_wrap = 72;
  text_out_indent = 1;
  Term_gotoxy(text_out_indent, 19);
  text_out_to_screen(COLOUR_WHITE, player->history);
  text_out_wrap = 0;
  text_out_indent = 0;
  return;
}
STATIC_OVL void
display_player(int mode)
{
  clear_from(0);
  if (Term != angband_term[0] && !player->upkeep->playing) return;
  display_player_stat_info();
  if (mode) {
    struct panel* p = panels[0].panel();
    display_panel(p, panels[0].align_left, &panels[0].bounds);
    panel_free(p);
  } else {
    display_player_xtra_info();
    display_player_skill_info();
  }
}
STATIC_OVL void
write_character_dump(ang_file* fff)
{
  int i, x, y;
  int a;
  wchar_t c;
  char o_name[80];
  int n;
  char buf[1024];
  char* p;
  file_putf(fff, "  [%s Character Dump]\n\n", buildid);
  display_player(0);
  for (y = 1; y < 23; y++) {
    p = buf;
    for (x = 0; x < 79; x++) {
      (void)(Term_what(x, y, &a, &c));
      n = text_wctomb(p, c);
      if (n > 0) {
        p += n;
      } else {
        *p++ = ' ';
      }
    }
    while ((p > buf) && (p[-1] == ' ')) --p;
    *p = '\0';
    file_putf(fff, "%s\n", buf);
  }
  file_putf(fff, "\n\n");
  if (player->is_dead) {
    i = messages_num();
    if (i > 15) i = 15;
    file_putf(fff, "  [Last Messages]\n\n");
    while (i-- > 0) {
      file_putf(fff, "> %s\n", message_str((int16_t)i));
    }
    if (streq(player->died_from, "Retiring")) {
      file_putf(fff, "\nRetired.\n\n");
    } else {
      file_putf(fff, "\nKilled by %s.\n\n", player->died_from);
    }
    file_putf(fff, "\n  [Screenshot]\n\n");
    file_mini_screenshot(fff);
    file_putf(fff, "\n");
  }
  file_putf(fff, "  [Character Equipment]\n\n");
  for (i = 0; i < player->body.count; i++) {
    struct object* obj = slot_object(player, i);
    if (!obj) continue;
    object_desc(o_name, sizeof(o_name), obj, ODESC_PREFIX | ODESC_FULL, player);
    file_putf(fff, "%c) %s\n", gear_to_label(player, obj), o_name);
    object_info_chardump(fff, obj, 5, 72);
  }
  file_putf(fff, "\n\n");
  file_putf(fff, "\n\n  [Character Inventory]\n\n");
  for (i = 0; i < z_info->pack_size; i++) {
    struct object* obj = player->upkeep->inven[i];
    if (!obj) break;
    object_desc(o_name, sizeof(o_name), obj, ODESC_PREFIX | ODESC_FULL, player);
    file_putf(fff, "%c) %s\n", gear_to_label(player, obj), o_name);
    object_info_chardump(fff, obj, 5, 72);
  }
  file_putf(fff, "\n\n");
  dump_history(fff);
  file_putf(fff, "\n\n");
  file_putf(fff, "  [Options]\n\n");
  for (i = 0; i < OP_MAX; i++) {
    int opt;
    const char* title = "";
    switch (i) {
      case OP_INTERFACE:
        title = "User interface";
        break;
      case OP_BIRTH:
        title = "Birth";
        break;
      default:
        continue;
    }
    file_putf(fff, "  [%s]\n\n", title);
    for (opt = 0; opt < OPT_MAX; opt++) {
      const char* desc;
      size_t u8len;
      if (option_type(opt) != i) continue;
      desc = option_desc(opt);
      u8len = utf8_strlen(desc);
      if (u8len < 45) {
        file_putf(fff, "%s%*s", desc, (int)(45 - u8len), " ");
      } else {
        file_putf(fff, "%s", desc);
      }
      file_putf(fff, ": %s (%s)\n", player->opts.opt[opt] ? "yes" : "no ",
                option_name(opt));
    }
    file_putf(fff, "\n");
  }
  if (player->self_made_arts) {
    file_putf(fff, "  [Artefact label]\n\n");
    file_putf(fff, "%08lx\n\n", (unsigned long)seed_randart);
  }
}
STATIC_OVL bool
dump_save(const char* path)
{
  if (text_lines_to_file(path, write_character_dump)) {
    msg("Failed to create file %s.new", path);
    return false;
  }
  return true;
}
STATIC_OVL void
do_cmd_change_name(void)
{
  ui_event ke;
  int mode = 0;
  bool more = true;
  screen_save();
  while (more) {
    display_player(mode);
    Term_putstr(1, 23, -1, COLOUR_SLATE,
                "history   change name   save to a file   abilities   increase "
                "skills   ESC");
    Term_putstr(1, 23, -1, COLOUR_L_WHITE, "h");
    Term_putstr(11, 23, -1, COLOUR_L_WHITE, "c");
    Term_putstr(25, 23, -1, COLOUR_L_WHITE, "s");
    Term_putstr(42, 23, -1, COLOUR_L_WHITE, "a");
    Term_putstr(54, 23, -1, COLOUR_L_WHITE, "i");
    Term_putstr(72, 23, -1, COLOUR_L_WHITE, "ESC");
    ke = inkey_ex();
    if ((ke.type == EVT_KBRD) || (ke.type == EVT_BUTTON)) {
      switch (ke.key.code) {
        case ESCAPE:
          more = false;
          break;
        case 'h': {
          history_display();
          break;
        }
        case 'c': {
          if (arg_force_name)
            msg("You are not allowed to change your name!");
          else {
            char namebuf[32] = "";
            if (get_character_name(namebuf, sizeof namebuf))
              my_strcpy(player->full_name, namebuf, sizeof(player->full_name));
          }
          break;
        }
        case 's': {
          char buf[1024];
          char fname[80];
          player_safe_name(fname, sizeof(fname), player->full_name, false);
          my_strcat(fname, ".txt", sizeof(fname));
          if (get_file(fname, buf, sizeof buf)) {
            if (dump_save(buf))
              msg("Character dump successful.");
            else
              msg("Character dump failed!");
          }
          break;
        }
        case 'a': {
          do_cmd_abilities();
          update_stuff(player);
          break;
        }
        case 'i': {
          (void)gain_skills(CTX_GAME, true);
          break;
        }
      }
    } else if (ke.type == EVT_MOUSE) {
      if (ke.mouse.button == 1) {
        mode = (mode + 1) % 2;
      } else if (ke.mouse.button == 2) {
        more = false;
      } else {
        mode = (mode - 1) % 2;
      }
    }
    event_signal(EVENT_MESSAGE_FLUSH);
  }
  screen_load();
}
STATIC_OVL void
remove_old_dump(const char* cur_fname, const char* mark)
{
  bool between_marks = false;
  bool changed = false;
  bool skip_one = false;
  char buf[1024];
  char start_line[1024];
  char end_line[1024];
  char new_fname[1024];
  ang_file* new_file;
  ang_file* cur_file;
  strnfmt(new_fname, sizeof(new_fname), "%s.new", cur_fname);
  strnfmt(start_line, sizeof(start_line), "%s begin %s", dump_separator, mark);
  strnfmt(end_line, sizeof(end_line), "%s end %s", dump_separator, mark);
  cur_file = file_open(cur_fname, MODE_READ, FTYPE_TEXT);
  if (!cur_file) return;
  new_file = file_open(new_fname, MODE_WRITE, FTYPE_TEXT);
  if (!new_file) {
    file_close(cur_file);
    msg("Failed to create file %s", new_fname);
    return;
  }
  while (file_getl(cur_file, buf, sizeof(buf))) {
    if (streq(buf, start_line))
      between_marks = true;
    else if (streq(buf, end_line)) {
      between_marks = false;
      skip_one = true;
      changed = true;
    }
    if (!between_marks && !skip_one) file_putf(new_file, "%s\n", buf);
    skip_one = false;
  }
  file_close(cur_file);
  file_close(new_file);
  if (changed) {
    char old_fname[1024];
    strnfmt(old_fname, sizeof(old_fname), "%s.old", cur_fname);
    if (file_move(cur_fname, old_fname)) {
      file_move(new_fname, cur_fname);
      file_delete(old_fname);
    }
  } else {
    file_delete(new_fname);
  }
}
STATIC_OVL void
pref_header(ang_file* fff, const char* mark)
{
  file_putf(fff, "%s begin %s\n", dump_separator, mark);
  file_putf(fff, "# *Warning!*  The lines below are an automatic dump.\n");
  file_putf(fff,
            "# Don't edit them; changes will be deleted and replaced "
            "automatically.\n");
}
STATIC_OVL void
pref_footer(ang_file* fff, const char* mark)
{
  file_putf(fff, "# *Warning!*  The lines above are an automatic dump.\n");
  file_putf(fff,
            "# Don't edit them; changes will be deleted and replaced "
            "automatically.\n");
  file_putf(fff, "%s end %s\n", dump_separator, mark);
}
STATIC_OVL void
dump_monsters(ang_file* fff)
{
  int i;
  for (i = 0; i < z_info->r_max; i++) {
    struct monster_race* race = &r_info[i];
    uint8_t attr = monster_x_attr[i];
    wint_t chr = monster_x_char[i];
    if (!race->name) continue;
    file_putf(fff, "monster:%s:0x%02X:0x%02X\n", race->name, attr, chr);
  }
}
STATIC_OVL void
dump_objects(ang_file* fff)
{
  int i;
  file_putf(fff, "# Objects\n");
  for (i = 0; i < z_info->k_max; i++) {
    struct object_kind* kind = &k_info[i];
    char name[120] = "";
    if (!kind->name || !kind->tval) continue;
    object_short_name(name, sizeof name, kind->name);
    file_putf(fff, "object:%s:%s:%d:%d\n", tval_find_name(kind->tval), name,
              kind_x_attr[i], kind_x_char[i]);
  }
}
STATIC_OVL void
dump_autoinscriptions(ang_file* f)
{
  int i;
  for (i = 0; i < z_info->k_max; i++) {
    struct object_kind* k = &k_info[i];
    char name[120];
    const char* note;
    if (!k->name || !k->tval) continue;
    note = get_autoinscription(k, true);
    if (note) {
      object_short_name(name, sizeof name, k->name);
      file_putf(f, "inscribe:%s:%s:%s\n", tval_find_name(k->tval), name, note);
    }
  }
}
STATIC_OVL void
dump_features(ang_file* fff)
{
  int i;
  for (i = 0; i < FEAT_MAX; i++) {
    struct feature* feat = &f_info[i];
    size_t j;
    if (!feat->name) continue;
    if (feat->mimic) continue;
    file_putf(fff, "# Terrain: %s\n", feat->name);
    for (j = 0; j < LIGHTING_MAX; j++) {
      uint8_t attr = feat_x_attr[j][i];
      wint_t chr = feat_x_char[j][i];
      const char* light = NULL;
      if (j == LIGHTING_TORCH) light = "torch";
      if (j == LIGHTING_LOS)
        light = "los";
      else if (j == LIGHTING_LIT)
        light = "lit";
      else if (j == LIGHTING_DARK)
        light = "dark";
      assert(light);
      file_putf(fff, "feat:%s:%s:%d:%d\n", get_feat_code_name(i), light, attr,
                chr);
    }
  }
}
STATIC_OVL void
dump_flavors(ang_file* fff)
{
  struct flavor* f;
  for (f = flavors; f; f = f->next) {
    uint8_t attr = flavor_x_attr[f->fidx];
    wint_t chr = flavor_x_char[f->fidx];
    file_putf(fff, "# Item flavor: %s\n", f->text);
    file_putf(fff, "flavor:%d:%d:%d\n\n", f->fidx, attr, chr);
  }
}
STATIC_OVL void
dump_colors(ang_file* fff)
{
  int i;
  for (i = 0; i < MAX_COLORS; i++) {
    int kv = angband_color_table[i][0];
    int rv = angband_color_table[i][1];
    int gv = angband_color_table[i][2];
    int bv = angband_color_table[i][3];
    const char* name = "unknown";
    if (!kv && !rv && !gv && !bv && i >= BASIC_COLORS) continue;
    if (i < BASIC_COLORS) name = color_table[i].name;
    file_putf(fff, "# Color: %s\n", name);
    file_putf(fff, "color:%d:%d:%d:%d:%d\n\n", i, kv, rv, gv, bv);
  }
}
STATIC_OVL void
option_dump(ang_file* fff)
{
  int i, j;
  file_putf(fff, "# Options\n\n");
  for (i = 1; i < ANGBAND_TERM_MAX; i++) {
    if (!angband_term[i]) continue;
    for (j = 0; j < (int)N_ELEMENTS(window_flag_desc); j++) {
      if (!window_flag_desc[j]) continue;
      if (window_flag[i] & (((uint32_t)1) << j)) {
        file_putf(fff, "# Window '%s', Flag '%s'\n", angband_term_name[i],
                  window_flag_desc[j]);
        file_putf(fff, "window:%d:%d:1\n", i, j);
        file_putf(fff, "\n");
      }
    }
  }
}
STATIC_OVL bool
prefs_save(const char* path, void (*dump)(ang_file*), const char* title)
{
  ang_file* fff;
  remove_old_dump(path, title);
  fff = file_open(path, MODE_APPEND, FTYPE_TEXT);
  if (!fff) {
    return false;
  }
  pref_header(fff, title);
  file_putf(fff, "\n");
  dump(fff);
  file_putf(fff, "\n");
  pref_footer(fff, title);
  file_close(fff);
  return true;
}
STATIC_OVL enum parser_error
parse_prefs_load(struct parser* p)
{
  struct prefs_data* d = parser_priv(p);
  const char* file;
  assert(d != NULL);
  if (d->bypass) return PARSE_ERROR_NONE;
  file = parser_getstr(p, "file");
  (void)process_pref_file(file, true, d->user);
  return PARSE_ERROR_NONE;
}
STATIC_OVL const char*
process_pref_file_expr(char** sp, char* fp)
{
  const char* v;
  char* b;
  char* s;
  char f = ' ';
  s = (*sp);
  while (isspace((unsigned char)*s)) s++;
  b = s;
  v = "?o?o?";
  if (*s == '[') {
    const char* p;
    const char* t;
    s++;
    t = process_pref_file_expr(&s, &f);
    if (!*t) {
    } else if (streq(t, "IOR")) {
      v = "0";
      while (*s && (f != ']')) {
        t = process_pref_file_expr(&s, &f);
        if (*t && !streq(t, "0")) v = "1";
      }
    } else if (streq(t, "AND")) {
      v = "1";
      while (*s && (f != ']')) {
        t = process_pref_file_expr(&s, &f);
        if (*t && streq(t, "0")) v = "0";
      }
    } else if (streq(t, "NOT")) {
      v = "1";
      while (*s && (f != ']')) {
        t = process_pref_file_expr(&s, &f);
        if (*t && !streq(t, "0")) v = "0";
      }
    } else if (streq(t, "EQU")) {
      v = "1";
      if (*s && (f != ']')) {
        t = process_pref_file_expr(&s, &f);
      }
      while (*s && (f != ']')) {
        p = t;
        t = process_pref_file_expr(&s, &f);
        if (*t && !streq(p, t)) v = "0";
      }
    } else if (streq(t, "LEQ")) {
      v = "1";
      if (*s && (f != ']')) {
        t = process_pref_file_expr(&s, &f);
      }
      while (*s && (f != ']')) {
        p = t;
        t = process_pref_file_expr(&s, &f);
        if (*t && (strcmp(p, t) >= 0)) v = "0";
      }
    } else if (streq(t, "GEQ")) {
      v = "1";
      if (*s && (f != ']')) {
        t = process_pref_file_expr(&s, &f);
      }
      while (*s && (f != ']')) {
        p = t;
        t = process_pref_file_expr(&s, &f);
        if (*t && (strcmp(p, t) <= 0)) v = "0";
      }
    } else {
      while (*s && (f != ']')) {
        (void)process_pref_file_expr(&s, &f);
      }
    }
    if (f != ']') v = "?x?x?";
    if ((f = *s) != '\0') *s++ = '\0';
  } else {
    while (isprint((unsigned char)*s) && !strchr(" []", *s)) ++s;
    if ((f = *s) != '\0') *s++ = '\0';
    if (*b == '$') {
      if (streq(b + 1, "SYS"))
        v = ANGBAND_SYS;
      else if (streq(b + 1, "RACE"))
        v = player->race->name;
      else if (streq(b + 1, "HOUSE"))
        v = player->house->name;
      else if (streq(b + 1, "SEX"))
        v = player->sex->name;
    } else {
      v = b;
    }
  }
  (*fp) = f;
  (*sp) = s;
  return v;
}
STATIC_OVL enum parser_error
parse_prefs_expr(struct parser* p)
{
  struct prefs_data* d = parser_priv(p);
  const char* v;
  char* str;
  char* expr;
  char f;
  assert(d != NULL);
  str = expr = string_make(parser_getstr(p, "expr"));
  v = process_pref_file_expr(&expr, &f);
  d->bypass = streq(v, "0");
  string_free(str);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_prefs_object(struct parser* p)
{
  int tvi, svi;
  struct object_kind* kind;
  const char *tval, *sval;
  struct prefs_data* d = parser_priv(p);
  assert(d != NULL);
  if (d->bypass) return PARSE_ERROR_NONE;
  tval = parser_getsym(p, "tval");
  sval = parser_getsym(p, "sval");
  if (streq(tval, "*")) {
    uint8_t attr = parser_getint(p, "attr");
    wchar_t chr = parser_getint(p, "char");
    size_t i;
    struct flavor* flavor;
    if (!streq(sval, "*")) return PARSE_ERROR_UNRECOGNISED_SVAL;
    for (i = 0; i < z_info->k_max; i++) {
      struct object_kind* kind_local = &k_info[i];
      kind_x_attr[kind_local->kidx] = attr;
      kind_x_char[kind_local->kidx] = chr;
    }
    for (flavor = flavors; flavor; flavor = flavor->next) {
      flavor_x_attr[flavor->fidx] = attr;
      flavor_x_char[flavor->fidx] = chr;
    }
  } else {
    tvi = tval_find_idx(tval);
    if (tvi < 0) return PARSE_ERROR_UNRECOGNISED_TVAL;
    if (streq(sval, "*")) {
      uint8_t attr = parser_getint(p, "attr");
      wchar_t chr = parser_getint(p, "char");
      size_t i;
      struct flavor* flavor;
      for (i = 0; i < z_info->k_max; i++) {
        struct object_kind* kind_local = &k_info[i];
        if (kind_local->tval != tvi) continue;
        kind_x_attr[kind_local->kidx] = attr;
        kind_x_char[kind_local->kidx] = chr;
      }
      for (flavor = flavors; flavor; flavor = flavor->next)
        if (flavor->tval == tvi) {
          flavor_x_attr[flavor->fidx] = attr;
          flavor_x_char[flavor->fidx] = chr;
        }
    } else {
      svi = lookup_sval(tvi, sval);
      if (svi < 0) return PARSE_ERROR_NONE;
      kind = lookup_kind(tvi, svi);
      if (!kind) return PARSE_ERROR_NONE;
      kind_x_attr[kind->kidx] = (uint8_t)parser_getint(p, "attr");
      kind_x_char[kind->kidx] = (wchar_t)parser_getint(p, "char");
    }
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_prefs_monster(struct parser* p)
{
  const char* name;
  struct monster_race* monster;
  struct prefs_data* d = parser_priv(p);
  assert(d != NULL);
  if (d->bypass) return PARSE_ERROR_NONE;
  name = parser_getsym(p, "name");
  monster = lookup_monster(name);
  if (!monster) return PARSE_ERROR_NO_KIND_FOUND;
  monster_x_attr[monster->ridx] = (uint8_t)parser_getint(p, "attr");
  monster_x_char[monster->ridx] = (wchar_t)parser_getint(p, "char");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_prefs_monster_base(struct parser* p)
{
  const char* name;
  struct monster_base* mb;
  size_t i;
  uint8_t a;
  wchar_t c;
  struct prefs_data* d = parser_priv(p);
  assert(d != NULL);
  if (d->bypass) return PARSE_ERROR_NONE;
  name = parser_getsym(p, "name");
  mb = lookup_monster_base(name);
  if (!mb) return PARSE_ERROR_NO_KIND_FOUND;
  a = (uint8_t)parser_getint(p, "attr");
  c = (wchar_t)parser_getint(p, "char");
  for (i = 0; i < z_info->r_max; i++) {
    struct monster_race* race = &r_info[i];
    if (race->base != mb) continue;
    monster_x_attr[race->ridx] = a;
    monster_x_char[race->ridx] = c;
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL void
set_trap_graphic(int trap_idx, int light_idx, uint8_t attr, wchar_t ch)
{
  if (light_idx < LIGHTING_MAX) {
    trap_x_attr[light_idx][trap_idx] = attr;
    trap_x_char[light_idx][trap_idx] = ch;
  } else {
    for (light_idx = 0; light_idx < LIGHTING_MAX; light_idx++) {
      trap_x_attr[light_idx][trap_idx] = attr;
      trap_x_char[light_idx][trap_idx] = ch;
    }
  }
}
STATIC_OVL enum parser_error
parse_prefs_trap(struct parser* p)
{
  const char* idx_sym;
  const char* lighting;
  int trap_idx;
  int light_idx;
  struct prefs_data* d = parser_priv(p);
  assert(d != NULL);
  if (d->bypass) return PARSE_ERROR_NONE;
  idx_sym = parser_getsym(p, "idx");
  if (streq(idx_sym, "*")) {
    trap_idx = -1;
  } else {
    struct trap_kind* trap = lookup_trap(idx_sym);
    if (!trap) {
      return PARSE_ERROR_UNRECOGNISED_TRAP;
    } else {
      trap_idx = trap->tidx;
    }
  }
  lighting = parser_getsym(p, "lighting");
  if (streq(lighting, "torch"))
    light_idx = LIGHTING_TORCH;
  else if (streq(lighting, "los"))
    light_idx = LIGHTING_LOS;
  else if (streq(lighting, "lit"))
    light_idx = LIGHTING_LIT;
  else if (streq(lighting, "dark"))
    light_idx = LIGHTING_DARK;
  else if (streq(lighting, "*"))
    light_idx = LIGHTING_MAX;
  else
    return PARSE_ERROR_INVALID_LIGHTING;
  if (trap_idx == -1) {
    size_t i;
    for (i = 0; i < z_info->trap_max; i++) {
      set_trap_graphic(i, light_idx, parser_getint(p, "attr"),
                       parser_getint(p, "char"));
    }
  } else {
    set_trap_graphic(trap_idx, light_idx, parser_getint(p, "attr"),
                     parser_getint(p, "char"));
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_prefs_feat(struct parser* p)
{
  const char* sym = parser_getsym(p, "idx");
  int idx;
  const char* lighting;
  int light_idx;
  struct prefs_data* d = parser_priv(p);
  assert(d != NULL);
  if (d->bypass) return PARSE_ERROR_NONE;
  idx = lookup_feat_code(sym);
  if (idx < 0) {
    idx = lookup_feat(sym);
  }
  if (idx < 0 || idx >= FEAT_MAX) {
    return PARSE_ERROR_OUT_OF_BOUNDS;
  }
  lighting = parser_getsym(p, "lighting");
  if (streq(lighting, "torch"))
    light_idx = LIGHTING_TORCH;
  else if (streq(lighting, "los"))
    light_idx = LIGHTING_LOS;
  else if (streq(lighting, "lit"))
    light_idx = LIGHTING_LIT;
  else if (streq(lighting, "dark"))
    light_idx = LIGHTING_DARK;
  else if (streq(lighting, "*"))
    light_idx = LIGHTING_MAX;
  else
    return PARSE_ERROR_INVALID_LIGHTING;
  if (light_idx < LIGHTING_MAX) {
    feat_x_attr[light_idx][idx] = (uint8_t)parser_getint(p, "attr");
    feat_x_char[light_idx][idx] = (wchar_t)parser_getint(p, "char");
  } else {
    for (light_idx = 0; light_idx < LIGHTING_MAX; light_idx++) {
      feat_x_attr[light_idx][idx] = (uint8_t)parser_getint(p, "attr");
      feat_x_char[light_idx][idx] = (wchar_t)parser_getint(p, "char");
    }
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_prefs_gf(struct parser* p)
{
  bool types[PROJ_MAX] = {0};
  const char* direction;
  int motion;
  char *s, *t;
  size_t i;
  struct prefs_data* d = parser_priv(p);
  assert(d != NULL);
  if (d->bypass) return PARSE_ERROR_NONE;
  s = string_make(parser_getsym(p, "type"));
  t = strtok(s, "| ");
  while (t) {
    if (streq(t, "*")) {
      memset(types, true, sizeof types);
    } else {
      int idx = proj_name_to_idx(t);
      if (idx == -1) return PARSE_ERROR_INVALID_VALUE;
      types[idx] = true;
    }
    t = strtok(NULL, "| ");
  }
  string_free(s);
  direction = parser_getsym(p, "direction");
  if (streq(direction, "static"))
    motion = BOLT_NO_MOTION;
  else if (streq(direction, "0"))
    motion = BOLT_0;
  else if (streq(direction, "45"))
    motion = BOLT_45;
  else if (streq(direction, "90"))
    motion = BOLT_90;
  else if (streq(direction, "135"))
    motion = BOLT_135;
  else
    return PARSE_ERROR_INVALID_VALUE;
  for (i = 0; i < PROJ_MAX; i++) {
    if (!types[i]) continue;
    proj_to_attr[i][motion] = (uint8_t)parser_getuint(p, "attr");
    proj_to_char[i][motion] = (wchar_t)parser_getuint(p, "char");
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_prefs_gs(struct parser* p)
{
  struct prefs_data* d = parser_priv(p);
  const char* name = parser_getsym(p, "type");
  int x_attr = parser_getint(p, "attr");
  int x_char = parser_getint(p, "char");
  assert(d != NULL);
  if (d->bypass) return PARSE_ERROR_NONE;
  if (streq(name, "ALERT")) {
    alert_x_attr = (uint8_t)x_attr;
    alert_x_char = (wchar_t)x_char;
  } else if (streq(name, "GLOW")) {
    glow_x_attr = (uint8_t)x_attr;
    glow_x_char = (wchar_t)x_char;
  } else {
    char* ep;
    long l = strtol(name, &ep, 10);
    if (l >= 0 && l <= 9 && contains_only_spaces(ep) &&
        !contains_only_spaces(name)) {
      damage_x_attr[l] = (uint8_t)x_attr;
      damage_x_char[l] = (wchar_t)x_char;
    } else {
      return PARSE_ERROR_UNRECOGNISED_PARAMETER;
    }
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_prefs_flavor(struct parser* p)
{
  unsigned int idx;
  struct flavor* flavor;
  struct prefs_data* d = parser_priv(p);
  assert(d != NULL);
  if (d->bypass) return PARSE_ERROR_NONE;
  idx = parser_getuint(p, "idx");
  for (flavor = flavors; flavor; flavor = flavor->next)
    if (flavor->fidx == idx) break;
  if (flavor) {
    flavor_x_attr[idx] = (uint8_t)parser_getint(p, "attr");
    flavor_x_char[idx] = (wchar_t)parser_getint(p, "char");
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_prefs_inscribe(struct parser* p)
{
  int tvi, svi;
  struct object_kind* kind;
  struct prefs_data* d = parser_priv(p);
  assert(d != NULL);
  if (d->bypass) return PARSE_ERROR_NONE;
  tvi = tval_find_idx(parser_getsym(p, "tval"));
  if (tvi < 0) return PARSE_ERROR_UNRECOGNISED_TVAL;
  svi = lookup_sval(tvi, parser_getsym(p, "sval"));
  if (svi < 0) return PARSE_ERROR_UNRECOGNISED_SVAL;
  kind = lookup_kind(tvi, svi);
  if (!kind) return PARSE_ERROR_UNRECOGNISED_SVAL;
  add_autoinscription(kind->kidx, parser_getstr(p, "text"), true);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_prefs_keymap_action(struct parser* p)
{
  const char* act = "";
  struct prefs_data* d = parser_priv(p);
  assert(d != NULL);
  if (d->bypass) return PARSE_ERROR_NONE;
  if (parser_hasval(p, "act")) {
    act = parser_getstr(p, "act");
  }
  keypress_from_text(d->keymap_buffer, N_ELEMENTS(d->keymap_buffer), act);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_prefs_keymap_input(struct parser* p)
{
  int mode;
  struct keypress tmp[2];
  struct prefs_data* d = parser_priv(p);
  assert(d != NULL);
  if (d->bypass) return PARSE_ERROR_NONE;
  mode = parser_getint(p, "mode");
  if (mode < 0 || mode >= KEYMAP_MODE_MAX) return PARSE_ERROR_OUT_OF_BOUNDS;
  keypress_from_text(tmp, N_ELEMENTS(tmp), parser_getstr(p, "key"));
  if (tmp[0].type != EVT_KBRD || tmp[1].type != EVT_NONE)
    return PARSE_ERROR_FIELD_TOO_LONG;
  keymap_add(mode, tmp[0], d->keymap_buffer, d->user);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_prefs_message(struct parser* p)
{
  int a, msg_index;
  const char* attr;
  const char* type;
  struct prefs_data* d = parser_priv(p);
  assert(d != NULL);
  if (d->bypass) return PARSE_ERROR_NONE;
  type = parser_getsym(p, "type");
  attr = parser_getsym(p, "attr");
  msg_index = message_lookup_by_name(type);
  if (msg_index < 0) return PARSE_ERROR_INVALID_MESSAGE;
  if (strlen(attr) > 1)
    a = color_text_to_attr(attr);
  else
    a = color_char_to_attr(attr[0]);
  if (a < 0) return PARSE_ERROR_INVALID_COLOR;
  message_color_define(msg_index, (uint8_t)a);
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_prefs_color(struct parser* p)
{
  int idx;
  struct prefs_data* d = parser_priv(p);
  assert(d != NULL);
  if (d->bypass) return PARSE_ERROR_NONE;
  idx = parser_getuint(p, "idx");
  if (idx >= MAX_COLORS) {
    return (idx < 256) ? PARSE_ERROR_NONE : PARSE_ERROR_OUT_OF_BOUNDS;
  }
  angband_color_table[idx][0] = parser_getint(p, "k");
  angband_color_table[idx][1] = parser_getint(p, "r");
  angband_color_table[idx][2] = parser_getint(p, "g");
  angband_color_table[idx][3] = parser_getint(p, "b");
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_prefs_window(struct parser* p)
{
  int window;
  size_t flag;
  struct prefs_data* d = parser_priv(p);
  assert(d != NULL);
  if (d->bypass) return PARSE_ERROR_NONE;
  window = parser_getint(p, "window");
  if (window <= 0 || window >= ANGBAND_TERM_MAX)
    return PARSE_ERROR_OUT_OF_BOUNDS;
  flag = parser_getuint(p, "flag");
  if (flag >= N_ELEMENTS(window_flag_desc)) return PARSE_ERROR_OUT_OF_BOUNDS;
  if (window_flag_desc[flag]) {
    int value = parser_getuint(p, "value");
    if (value)
      d->window_flags[window] |= (((uint32_t)1) << flag);
    else
      d->window_flags[window] &= ~(((uint32_t)1) << flag);
  }
  d->loaded_window_flag[window] = true;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
parse_prefs_dummy(struct parser* p)
{
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
init_parse_prefs(bool user)
{
  struct parser* p = parser_new();
  struct prefs_data* pd = mem_zalloc(sizeof *pd);
  int i;
  parser_setpriv(p, pd);
  pd->user = user;
  for (i = 0; i < ANGBAND_TERM_MAX; i++) {
    pd->loaded_window_flag[i] = false;
  }
  parser_reg(p, "% str file", parse_prefs_load);
  parser_reg(p, "? str expr", parse_prefs_expr);
  parser_reg(p, "object sym tval sym sval int attr int char",
             parse_prefs_object);
  parser_reg(p, "monster sym name int attr int char", parse_prefs_monster);
  parser_reg(p, "monster-base sym name int attr int char",
             parse_prefs_monster_base);
  parser_reg(p, "feat sym idx sym lighting int attr int char",
             parse_prefs_feat);
  parser_reg(p, "trap sym idx sym lighting int attr int char",
             parse_prefs_trap);
  parser_reg(p, "GF sym type sym direction uint attr uint char",
             parse_prefs_gf);
  parser_reg(p, "GS sym type int attr int char", parse_prefs_gs);
  parser_reg(p, "flavor uint idx int attr int char", parse_prefs_flavor);
  parser_reg(p, "inscribe sym tval sym sval str text", parse_prefs_inscribe);
  parser_reg(p, "keymap-act ?str act", parse_prefs_keymap_action);
  parser_reg(p, "keymap-input int mode str key", parse_prefs_keymap_input);
  parser_reg(p, "message sym type sym attr", parse_prefs_message);
  parser_reg(p, "color uint idx int k int r int g int b", parse_prefs_color);
  parser_reg(p, "window int window uint flag uint value", parse_prefs_window);
  register_sound_pref_parser(p);
  return p;
}
STATIC_OVL errr
finish_parse_prefs(struct parser* p)
{
  struct prefs_data* d = parser_priv(p);
  int i;
  for (i = 0; i < ANGBAND_TERM_MAX; i++) {
    if (!d->loaded_window_flag[i]) d->window_flags[i] = window_flag[i];
  }
  subwindows_set_flags(d->window_flags, ANGBAND_TERM_MAX);
  for (i = 0; i < 10; ++i) {
    if (!(damage_x_attr[i] & 0x80)) {
      damage_x_attr[0] = 0;
      break;
    }
  }
  return PARSE_ERROR_NONE;
}
STATIC_OVL errr
process_pref_file_command(const char* s)
{
  struct parser* p = init_parse_prefs(true);
  errr e = parser_parse(p, s);
  mem_free(parser_priv(p));
  parser_destroy(p);
  return e;
}
STATIC_OVL void
ui_print_error(const char* name, struct parser* p)
{
  struct parser_state s;
  parser_getstate(p, &s);
  msg("Parse error in %s line %d column %d: %s: %s", name, s.line, s.col, s.msg,
      parser_error_str[s.error]);
  event_signal(EVENT_MESSAGE_FLUSH);
}
STATIC_OVL bool
process_pref_file_named(const char* path, bool quiet, bool user)
{
  ang_file* f = file_open(path, MODE_READ, -1);
  errr e = 0;
  if (!f) {
    if (!quiet) msg("Cannot open '%s'.", path);
    e = PARSE_ERROR_INTERNAL;
  } else {
    char line[1024];
    struct parser* p = init_parse_prefs(user);
    while (file_getl(f, line, sizeof line)) {
      e = parser_parse(p, line);
      if (e != PARSE_ERROR_NONE) {
        ui_print_error(path, p);
        break;
      }
    }
    finish_parse_prefs(p);
    file_close(f);
    mem_free(parser_priv(p));
    parser_destroy(p);
  }
  return e == PARSE_ERROR_NONE;
}
STATIC_OVL bool
process_pref_file_layered(const char* name, bool quiet, bool user,
                          const char* base_search_path,
                          const char* fallback_search_path, bool* used_fallback)
{
  char buf[1024];
  assert(base_search_path != NULL);
  path_build(buf, sizeof(buf), base_search_path, name);
  if (used_fallback != NULL) *used_fallback = false;
  if (!file_exists(buf) && fallback_search_path != NULL) {
    path_build(buf, sizeof(buf), fallback_search_path, name);
    if (used_fallback != NULL) *used_fallback = true;
  }
  return process_pref_file_named(buf, quiet, user);
}
STATIC_OVL bool
process_pref_file(const char* name, bool quiet, bool user)
{
  bool root_success = false;
  bool user_success = false;
  bool used_fallback = false;
  root_success =
      process_pref_file_layered(name, quiet, user, ANGBAND_DIR_CUSTOMIZE,
                                ANGBAND_DIR_USER, &used_fallback);
  if (!root_success && current_graphics_mode)
    root_success = process_pref_file_layered(
        name, quiet, user, current_graphics_mode->path, NULL, NULL);
  if (!used_fallback) {
    user_success = process_pref_file_layered(name, true, true, ANGBAND_DIR_USER,
                                             NULL, &used_fallback);
  }
  return root_success || user_success;
}
STATIC_OVL void
reset_visuals(bool load_prefs)
{
  int i, j;
  struct flavor* f;
  for (i = 0; i < FEAT_MAX; i++) {
    struct feature* feat = &f_info[i];
    for (j = 0; j < LIGHTING_MAX; j++) {
      feat_x_attr[j][i] = feat->d_attr;
      feat_x_char[j][i] = feat->d_char;
    }
  }
  for (i = 0; i < z_info->k_max; i++) {
    struct object_kind* kind = &k_info[i];
    kind_x_attr[i] = kind->d_attr;
    kind_x_char[i] = kind->d_char;
  }
  for (i = 0; i < z_info->r_max; i++) {
    struct monster_race* race = &r_info[i];
    monster_x_attr[i] = race->d_attr;
    monster_x_char[i] = race->d_char;
  }
  for (i = 0; i < z_info->trap_max; i++) {
    struct trap_kind* trap = &trap_info[i];
    for (j = 0; j < LIGHTING_MAX; j++) {
      trap_x_attr[j][i] = trap->d_attr;
      trap_x_char[j][i] = trap->d_char;
    }
  }
  for (f = flavors; f; f = f->next) {
    flavor_x_attr[f->fidx] = f->d_attr;
    flavor_x_char[f->fidx] = f->d_char;
  }
  if (!load_prefs) return;
  if (use_graphics) {
    graphics_mode* mode = get_graphics_mode(use_graphics);
    char buf[2014];
    assert(mode);
    path_build(buf, sizeof buf, mode->path, mode->pref);
    process_pref_file_named(buf, false, false);
  } else {
    process_pref_file("font.prf", false, false);
  }
}
STATIC_OVL void
textui_prefs_init(void)
{
  int i;
  struct flavor* f;
  monster_x_attr = mem_zalloc(z_info->r_max * sizeof(uint8_t));
  monster_x_char = mem_zalloc(z_info->r_max * sizeof(wchar_t));
  kind_x_attr = mem_zalloc(z_info->k_max * sizeof(uint8_t));
  kind_x_char = mem_zalloc(z_info->k_max * sizeof(wchar_t));
  for (i = 0; i < LIGHTING_MAX; i++) {
    feat_x_attr[i] = mem_zalloc(FEAT_MAX * sizeof(uint8_t));
    feat_x_char[i] = mem_zalloc(FEAT_MAX * sizeof(wchar_t));
  }
  for (i = 0; i < LIGHTING_MAX; i++) {
    trap_x_attr[i] = mem_zalloc(z_info->trap_max * sizeof(uint8_t));
    trap_x_char[i] = mem_zalloc(z_info->trap_max * sizeof(wchar_t));
  }
  for (f = flavors; f; f = f->next)
    if (flavor_max < f->fidx) flavor_max = f->fidx;
  flavor_x_attr = mem_zalloc((flavor_max + 1) * sizeof(uint8_t));
  flavor_x_char = mem_zalloc((flavor_max + 1) * sizeof(wchar_t));
  alert_x_attr = 0;
  alert_x_char = 0;
  glow_x_attr = 0;
  glow_x_char = 0;
  for (i = 0; i < 10; ++i) {
    damage_x_attr[i] = 0;
    damage_x_char[i] = 0;
  }
  reset_visuals(false);
}
STATIC_OVL void
textui_prefs_free(void)
{
  int i;
  mem_free(monster_x_attr);
  mem_free(monster_x_char);
  mem_free(kind_x_attr);
  mem_free(kind_x_char);
  for (i = 0; i < LIGHTING_MAX; i++) {
    mem_free(feat_x_attr[i]);
    mem_free(feat_x_char[i]);
  }
  for (i = 0; i < LIGHTING_MAX; i++) {
    mem_free(trap_x_attr[i]);
    mem_free(trap_x_char[i]);
  }
  mem_free(flavor_x_attr);
  mem_free(flavor_x_char);
}
STATIC_OVL void
do_cmd_pref(void)
{
  char tmp[80];
  my_strcpy(tmp, "", sizeof(tmp));
  if (!get_string("Pref: ", tmp, 80)) return;
  (void)process_pref_file_command(tmp);
}
STATIC_OVL term*
find_first_subwindow(uint32_t flag)
{
  int i = 1;
  while (1) {
    if (i >= ANGBAND_TERM_MAX) {
      return NULL;
    }
    if ((window_flag[i] & flag) && angband_term[i]) {
      return angband_term[i];
    }
    ++i;
  }
}
STATIC_OVL void
comma_number(char* output, int number, int len)
{
  if (number >= 1000000) {
    strnfmt(output, len, "%d,%03d,%03d", number / 1000000,
            (number % 1000000) / 1000, number % 1000);
  } else if (number >= 1000) {
    strnfmt(output, len, "%d,%03d", number / 1000, number % 1000);
  } else {
    strnfmt(output, len, "%d", number);
  }
}
STATIC_OVL void
atomonth(int number, char* output, int len)
{
  switch (number) {
    case 1:
      strnfmt(output, len, "Jan");
      break;
    case 2:
      strnfmt(output, len, "Feb");
      break;
    case 3:
      strnfmt(output, len, "Mar");
      break;
    case 4:
      strnfmt(output, len, "Apr");
      break;
    case 5:
      strnfmt(output, len, "May");
      break;
    case 6:
      strnfmt(output, len, "Jun");
      break;
    case 7:
      strnfmt(output, len, "Jul");
      break;
    case 8:
      strnfmt(output, len, "Aug");
      break;
    case 9:
      strnfmt(output, len, "Sep");
      break;
    case 10:
      strnfmt(output, len, "Oct");
      break;
    case 11:
      strnfmt(output, len, "Nov");
      break;
    case 12:
      strnfmt(output, len, "Dec");
      break;
    default:
      break;
  }
}
STATIC_OVL void
display_single_score(const struct high_score* score, int row, int place,
                     int attr)
{
  int aged, depth;
  const char *user, *when;
  struct player_house* h;
  struct player_sex* s;
  char out_val[160];
  char tmp_val[160];
  char aged_commas[15];
  char depth_commas[15];
  bool alive = streq(score->how, "(alive and well)");
  h = player_id2house(atoi(score->p_h));
  s = player_id2sex(atoi(score->p_s));
  for (user = score->uid; isspace((unsigned char)*user); user++)
    ;
  for (when = score->day; isspace((unsigned char)*when); when++)
    ;
  aged = atoi(score->turns);
  depth = atoi(score->cur_dun) * 50;
  comma_number(aged_commas, aged, sizeof(aged_commas));
  comma_number(depth_commas, depth, sizeof(depth_commas));
  if ((*when == '@') && strlen(when) == 9) {
    char month[4];
    strnfmt(month, sizeof(month), "%.2s", when + 5);
    atomonth(atoi(month), month, sizeof(month));
    if (*(when + 7) == '0') {
      strnfmt(tmp_val, sizeof(tmp_val), "%.1s %.3s %.4s", when + 8, month,
              when + 1);
    } else {
      strnfmt(tmp_val, sizeof(tmp_val), "%.2s %.3s %.4s", when + 7, month,
              when + 1);
    }
    when = tmp_val;
  }
  if (place == 0) {
    strnfmt(out_val, sizeof(out_val), "     %5s ft  %s of %s", depth_commas,
            score->who, h->alt_name);
  } else {
    strnfmt(out_val, sizeof(out_val), "%3d. %5s ft  %s of %s", place,
            depth_commas, score->who, h->alt_name);
  }
  if (score->morgoth_slain[0] == 't') {
    my_strcat(out_val, ", who defeated Morgoth in his dark halls",
              sizeof(out_val));
  } else {
    if (score->silmarils[0] == '1') {
      my_strcat(out_val, ", who freed a Silmaril", sizeof(out_val));
    }
    if (score->silmarils[0] == '2') {
      my_strcat(out_val, ", who freed two Silmarils", sizeof(out_val));
    }
    if (score->silmarils[0] == '3') {
      my_strcat(out_val, ", who freed all three Silmarils", sizeof(out_val));
    }
    if (score->silmarils[0] > '3') {
      my_strcat(out_val, ", who freed suspiciously many Silmarils",
                sizeof(out_val));
    }
  }
  c_put_str(attr, out_val, row + 3, 0);
  if (score->escaped[0] == 't') {
    strnfmt(out_val, sizeof(out_val), "               Escaped the iron hells");
    if ((score->morgoth_slain[0] == 't') || (score->silmarils[0] > '0')) {
      my_strcat(out_val, " and brought back the light of Valinor",
                sizeof(out_val));
    } else {
      my_strcat(out_val, format(" with %s task unfulfilled", s->possessive),
                sizeof(out_val));
    }
  } else if (alive) {
    strnfmt(out_val, sizeof(out_val),
            "               Lives still, deep within Angband's vaults");
  } else {
    strnfmt(out_val, sizeof(out_val), "               Slain by %s", score->how);
    if (score->silmarils[0] > '0') {
      my_strcat(out_val, format(" during %s escape", s->possessive),
                sizeof(out_val));
    }
  }
  c_put_str(attr, out_val, row + 4, 0);
  if (alive) {
    strnfmt(out_val, sizeof(out_val), "               after %s turns.",
            aged_commas);
    c_put_str(attr, out_val, row + 5, 0);
  } else {
    strnfmt(out_val, sizeof(out_val), "               after %s turns.  (%s)",
            aged_commas, when);
    c_put_str(attr, out_val, row + 5, 0);
  }
  if (score->escaped[0] == 't') {
    c_put_str(attr, "  escaped", row + 3, 4);
  }
  if (score->silmarils[0] == '1') {
    c_put_str(attr, "         *", row + 5, 0);
  }
  if (score->silmarils[0] == '2') {
    c_put_str(attr, "        * *", row + 5, 0);
  }
  if (score->silmarils[0] > '2') {
    c_put_str(attr, "       * * *", row + 5, 0);
  }
  if (score->morgoth_slain[0] == 't') {
    c_put_str(COLOUR_L_DARK, "         V", row + 4, 0);
  }
}
STATIC_OVL void
display_score_page(const struct high_score scores[], int start, int count,
                   int highlight)
{
  int n;
  for (n = 0; start < count && n < 5; start++, n++) {
    const struct high_score* score = &scores[start];
    bool alive = streq(score->how, "(alive and well)");
    uint8_t attr = alive ? COLOUR_WHITE : COLOUR_SLATE;
    display_single_score(score, n * 4, start, attr);
  }
}
STATIC_OVL void
display_scores_aux(const struct high_score scores[], int from, int to,
                   int highlight, bool allow_scrolling)
{
  struct keypress ch;
  int k, count;
  if (from < 0) from = 0;
  if (to < 0) to = allow_scrolling ? 5 : 10;
  if (to > MAX_HISCORES) to = MAX_HISCORES;
  for (count = 0; count < MAX_HISCORES; count++)
    if (!scores[count].what[0]) break;
  if ((count > to) && !allow_scrolling) count = to;
  k = from;
  while (1) {
    Term_clear();
    if (k > 0) {
      put_str(format("Names of the Fallen (from position %d)", k + 1), 0, 21);
    } else {
      put_str("Names of the Fallen", 0, 30);
    }
    display_score_page(scores, k, count, highlight);
    if (allow_scrolling) {
      prt("[Press ESC to exit, up for prior page, any other key for next "
          "page.]",
          23, 6);
    } else {
      prt("[Press ESC to exit, any other key to page forward till done.]", 23,
          9);
    }
    ch = inkey();
    prt("", 23, 0);
    if (ch.code == ESCAPE) {
      break;
    } else if (ch.code == ARROW_UP && allow_scrolling) {
      if (k == 0) {
        k = count - 5;
        while (k % 5) k++;
      } else if (k < 5) {
        k = 0;
      } else {
        k = k - 5;
      }
    } else {
      k += 5;
      if (k >= count) {
        if (allow_scrolling) {
          k = 0;
        } else {
          break;
        }
      }
    }
  }
  return;
}
STATIC_OVL void
predict_score(bool allow_scrolling)
{
  int j;
  struct high_score the_score;
  struct high_score scores[MAX_HISCORES];
  highscore_read(scores, N_ELEMENTS(scores));
  build_score(&the_score, player, "nobody (yet!)", NULL);
  if (player->is_dead)
    j = highscore_where(&the_score, scores, N_ELEMENTS(scores));
  else
    j = highscore_add(&the_score, scores, N_ELEMENTS(scores));
  if (j < 10) {
    display_scores_aux(scores, 0, 15, j, allow_scrolling);
  } else {
    display_scores_aux(scores, j - 2, j + 7, j, allow_scrolling);
  }
}
STATIC_OVL void
show_scores(void)
{
  screen_save();
  if (character_generated) {
    predict_score(true);
  } else {
    struct high_score scores[MAX_HISCORES];
    highscore_read(scores, N_ELEMENTS(scores));
    display_scores_aux(scores, 0, MAX_HISCORES, -1, true);
  }
  screen_load();
  Term_fresh();
}
STATIC_OVL Signal_Handler_t
wrap_signal(int sig, Signal_Handler_t handler)
{
  return signal(sig, handler);
}
STATIC_OVL void
handle_signal_simple(int sig)
{
  int save_errno = errno;
  char msg[48];
  (void)(*signal_aux)(sig, SIG_IGN);
  (void)strnfmt(msg, sizeof(msg), "Exiting on signal %d!", sig);
  if (!character_generated || character_saved) quit(msg);
  signal_count++;
  if (player->is_dead) {
    my_strcpy(player->died_from, "Abortion", sizeof(player->died_from));
    close_game(false);
    quit(msg);
  } else if (signal_count >= 5) {
    quit(msg);
  } else if (signal_count >= 4) {
    int cx, cy;
    errr cbad = Term_locate(&cx, &cy);
    Term_xtra(TERM_XTRA_NOISE, 0);
    Term_erase(0, 0, 255);
    Term_putstr(0, 0, -1, COLOUR_WHITE,
                "Another interrupt (CTRL-c) will quit without saving!");
    if (!cbad) {
      Term_gotoxy(cx, cy);
    }
    Term_fresh();
  } else if (signal_count >= 2) {
    Term_xtra(TERM_XTRA_NOISE, 0);
  }
  (void)(*signal_aux)(sig, handle_signal_simple);
  errno = save_errno;
}
STATIC_OVL void
handle_signal_abort(int sig)
{
  char msg[48];
  (void)(*signal_aux)(sig, SIG_IGN);
  (void)strnfmt(msg, sizeof(msg), "Exiting on signal %d!", sig);
  if (!character_generated || character_saved) quit(msg);
  Term_erase(0, 23, 255);
  Term_putstr(0, 23, -1, COLOUR_RED,
              "A gruesome software bug LEAPS out at you!");
  Term_putstr(45, 23, -1, COLOUR_RED, "Panic save...");
  Term_fresh();
  my_strcpy(player->died_from, "(panic save)", sizeof(player->died_from));
  savefile_get_panic_name(panicfile, sizeof(panicfile), savefile);
  signals_ignore_tstp();
  if (panicfile[0] && savefile_save(panicfile))
    Term_putstr(45, 23, -1, COLOUR_RED, "Panic save succeeded!");
  else
    Term_putstr(45, 23, -1, COLOUR_RED, "Panic save failed!");
  Term_fresh();
  quit(msg);
}
STATIC_OVL void
signals_ignore_tstp(void)
{
}
STATIC_OVL void
signals_handle_tstp(void)
{
}
STATIC_OVL void
signals_init(void)
{
}
STATIC_OVL void
point_skills(game_event_type type, game_event_data* data, void* user)
{
  display_player_skill_info();
}
STATIC_OVL void
sk_point_misc(game_event_type type, game_event_data* data, void* user)
{
  display_player_xtra_info();
}
STATIC_OVL void
skill_points(game_event_type type, game_event_data* data, void* user)
{
  int i;
  int sum = 0;
  const int* spent = data->exp.exp;
  const int* inc = data->exp.inc_exp;
  int remaining = data->exp.remaining;
  put_str("Cost", 7 - 1, (42 + 32));
  for (i = 0; i < SKILL_MAX; i++) {
    skbuysell[i] = 0;
    if (spent[i] > 0) {
      skbuysell[i] |= 1;
    }
    if (inc[i] <= remaining) {
      skbuysell[i] |= 2;
    }
    put_str(format("%4d", spent[i]), 7 + i, (42 + 32));
    sum += spent[i];
  }
  put_str(format("Total Cost: %4d/%4d", sum, remaining + sum), 7 + SKILL_MAX,
          (42 + 15));
}
STATIC_OVL void
skill_points_start(cmd_context context, bool reset)
{
  const char* prompt =
      "[up/down to move, left/right to modify, 'r' to reset, 'Enter' to "
      "accept]";
  int i;
  Term_clear();
  display_player_xtra_info();
  display_player_stat_info();
  display_player_skill_info();
  prt(prompt, Term->hgt - 1, Term->wid / 2 - strlen(prompt) / 2);
  for (i = 0; i < SKILL_MAX; ++i) {
    skbuysell[i] = 0;
  }
  event_add_handler(EVENT_SKILLPOINTS, skill_points, NULL);
  event_add_handler(EVENT_SKILLS, point_skills, NULL);
  event_add_handler(EVENT_EXP_CHANGE, sk_point_misc, NULL);
  init_skills(false, reset);
}
STATIC_OVL void
skill_points_stop(void)
{
  event_remove_handler(EVENT_SKILLPOINTS, skill_points, NULL);
  event_remove_handler(EVENT_SKILLS, point_skills, NULL);
  event_remove_handler(EVENT_EXP_CHANGE, sk_point_misc, NULL);
}
STATIC_OVL int
skill_points_command(void)
{
  enum {
    ACT_CTX_SKILL_PTS_NONE,
    ACT_CTX_SKILL_PTS_BUY,
    ACT_CTX_SKILL_PTS_SELL,
    ACT_CTX_SKILL_PTS_ESCAPE,
    ACT_CTX_SKILL_PTS_RESET,
    ACT_CTX_SKILL_PTS_ACCEPT,
    ACT_CTX_SKILL_PTS_QUIT
  };
  int action = ACT_CTX_SKILL_PTS_NONE;
  ui_event in;
  int next = 0;
  Term_gotoxy((42 + 32) + 4, 7 + skill_idx);
  while (1) {
    in = inkey_ex();
    if (in.type == EVT_KBRD || in.type == EVT_MOUSE) {
      break;
    }
    if (in.type == EVT_BUTTON) {
      in.type = EVT_KBRD;
    }
    if (in.type == EVT_ESCAPE) {
      in.type = EVT_KBRD;
      in.key.code = ESCAPE;
      in.key.mods = 0;
      break;
    }
  }
  if (in.type == EVT_KBRD) {
    if (in.key.code == KTRL('X')) {
      action = ACT_CTX_SKILL_PTS_QUIT;
    } else if (in.key.code == ESCAPE) {
      action = ACT_CTX_SKILL_PTS_ESCAPE;
    } else if (in.key.code == 'r' || in.key.code == 'R') {
      action = ACT_CTX_SKILL_PTS_RESET;
    } else if (in.key.code == KC_ENTER) {
      action = ACT_CTX_SKILL_PTS_ACCEPT;
    } else {
      int dir;
      if (in.key.code == '-') {
        dir = 4;
      } else if (in.key.code == '+') {
        dir = 6;
      } else {
        dir = target_dir(in.key);
      }
      if (dir == 8) {
        skill_idx = (skill_idx + SKILL_MAX - 1) % SKILL_MAX;
      }
      if (dir == 2) {
        skill_idx = (skill_idx + 1) % SKILL_MAX;
      }
      if (dir == 4) {
        action = ACT_CTX_SKILL_PTS_SELL;
      }
      if (dir == 6) {
        action = ACT_CTX_SKILL_PTS_BUY;
      }
    }
  } else if (in.type == EVT_MOUSE) {
    assert(skill_idx >= 0 && skill_idx < SKILL_MAX);
    if (in.mouse.button == 2) {
      action = ACT_CTX_SKILL_PTS_ESCAPE;
    } else if (in.mouse.y >= 7 && in.mouse.y < 7 + SKILL_MAX &&
               in.mouse.y != 7 + skill_idx) {
      skill_idx = in.mouse.y - 7;
    } else {
      char* labels = string_make(lower_case);
      struct menu* m = menu_dynamic_new();
      m->selections = labels;
      if (in.mouse.y == 7 + skill_idx && (skbuysell[skill_idx] & 1)) {
        menu_dynamic_add_label(m, "Sell", 's', ACT_CTX_SKILL_PTS_SELL, labels);
      }
      if (in.mouse.y == 7 + skill_idx && (skbuysell[skill_idx] & 2)) {
        menu_dynamic_add_label(m, "Buy", 'b', ACT_CTX_SKILL_PTS_BUY, labels);
      }
      menu_dynamic_add_label(m, "Accept", 'a', ACT_CTX_SKILL_PTS_ACCEPT,
                             labels);
      menu_dynamic_add_label(m, "Reset", 'r', ACT_CTX_SKILL_PTS_RESET, labels);
      menu_dynamic_add_label(m, "Quit", 'q', ACT_CTX_SKILL_PTS_QUIT, labels);
      screen_save();
      menu_dynamic_calc_location(m, in.mouse.x, in.mouse.y);
      region_erase_bordered(&m->boundary);
      action = menu_dynamic_select(m);
      menu_dynamic_free(m);
      string_free(labels);
      screen_load();
    }
  }
  switch (action) {
    case ACT_CTX_SKILL_PTS_SELL:
      assert(skill_idx >= 0 && skill_idx < SKILL_MAX);
      cmdq_push(CMD_SELL_SKILL);
      cmd_set_arg_choice(cmdq_peek(), "choice", skill_idx);
      break;
    case ACT_CTX_SKILL_PTS_BUY:
      assert(skill_idx >= 0 && skill_idx < SKILL_MAX);
      cmdq_push(CMD_BUY_SKILL);
      cmd_set_arg_choice(cmdq_peek(), "choice", skill_idx);
      break;
    case ACT_CTX_SKILL_PTS_ESCAPE:
      cmdq_push(CMD_RESET_SKILLS);
      cmd_set_arg_choice(cmdq_peek(), "choice", false);
      next = -1;
      break;
    case ACT_CTX_SKILL_PTS_RESET:
      cmdq_push(CMD_RESET_SKILLS);
      cmd_set_arg_choice(cmdq_peek(), "choice", false);
      break;
    case ACT_CTX_SKILL_PTS_ACCEPT:
      next = 1;
      break;
    case ACT_CTX_SKILL_PTS_QUIT:
      if (character_dungeon) {
        next = -1;
      } else {
        quit(NULL);
      }
      break;
    default:
      break;
  }
  return next;
}
STATIC_OVL int
gain_skills(cmd_context context, bool reset)
{
  int next = 0;
  skill_points_start(context, reset);
  while (!next) {
    next = skill_points_command();
    cmdq_push(CMD_REFRESH_SKILLS);
    cmdq_execute(context);
  }
  skill_points_stop();
  if (context == CTX_GAME) {
    finalise_skills();
    player->upkeep->redraw |= (PR_EXP);
  }
  return next;
}
STATIC_OVL void
include_pval(struct object* obj)
{
  if (!pval_included) {
    object_wipe(smith_obj_backup);
    object_copy(smith_obj_backup, smith_obj);
  }
  if (pval_valid(obj)) {
    int i;
    obj->pval = pval;
    for (i = 0; i < OBJ_MOD_MAX; i++) {
      if (obj->modifiers[i]) {
        obj->modifiers[i] = (obj->modifiers[i] < 0) ? -pval : pval;
        obj->known->modifiers[i] = obj->modifiers[i];
      }
    }
  }
  pval_included = true;
}
STATIC_OVL void
exclude_pval(struct object* obj)
{
  if (pval_included) {
    object_wipe(smith_obj);
    object_copy(smith_obj, smith_obj_backup);
  }
  pval_included = false;
}
STATIC_OVL void
wipe_smithing_objects(void)
{
  object_wipe(smith_obj);
  object_wipe(smith_obj_backup);
  mem_free(smith_art->slays);
  mem_free(smith_art->brands);
  release_ability_list(smith_art->abilities);
  memset(smith_art, 0, sizeof(*smith_art));
}
STATIC_OVL void
know_smith_obj(void)
{
  object_copy(smith_obj_known, smith_obj);
  smith_obj_known->known = NULL;
  smith_obj->known = smith_obj_known;
}
STATIC_OVL void
reset_smithing_objects(struct object_kind* kind)
{
  object_wipe(smith_obj);
  object_wipe(smith_obj_backup);
  mem_free(smith_art->slays);
  mem_free(smith_art->brands);
  release_ability_list(smith_art->abilities);
  memset(smith_art, 0, sizeof(*smith_art));
  create_base_object(kind, smith_obj);
  know_smith_obj();
  object_copy(smith_obj_backup, smith_obj);
  pval = pval_valid(smith_obj) ? pval_default(smith_obj) : 0;
}
STATIC_OVL void
show_smith_obj(void)
{
  int effective_skill = player->state.skill_use[SKILL_SMITHING] +
                        square_forge_bonus(cave, player->grid);
  int dif;
  uint8_t attr;
  bool affordable = true;
  int costs = 0;
  char o_desc[80];
  int mode = ODESC_FULL | ODESC_CAPITAL | ODESC_SPOIL;
  textblock* tb;
  region bottom = {16, MAX_SMITHING_TVALS + 3, 0, 0};
  region right = {62, 2, 0, 0};
  const struct object_kind* kind = smith_obj->kind;
  if (!kind) return;
  include_pval(smith_obj);
  dif = object_difficulty(smith_obj, &current_cost);
  attr = effective_skill < dif ? COLOUR_SLATE : COLOUR_L_DARK;
  exclude_pval(smith_obj);
  text_out_hook = text_out_to_screen;
  text_out_wrap = 80;
  text_out_indent = 62;
  region_erase(&bottom);
  region_erase(&right);
  Term_gotoxy(62, 2);
  text_out_c(attr, "Difficulty:\n\n");
  if (current_cost.drain) {
    attr = COLOUR_BLUE;
  }
  text_out_c(attr, "%3d", dif);
  text_out_c(COLOUR_L_DARK, "  (max %d)", effective_skill);
  Term_gotoxy(62, 8);
  if (affordable) {
    attr = COLOUR_SLATE;
  } else {
    attr = COLOUR_L_DARK;
  }
  text_out_c(attr, "Cost:");
  Term_gotoxy(62 + 2, 10);
  if (current_cost.weaponsmith) {
    text_out_c(COLOUR_RED, "Weaponsmith\n");
    costs++;
    Term_gotoxy(62 + 2, 10 + costs);
  }
  if (current_cost.armoursmith) {
    text_out_c(COLOUR_RED, "Armoursmith\n");
    costs++;
    Term_gotoxy(62 + 2, 10 + costs);
  }
  if (current_cost.jeweller) {
    text_out_c(COLOUR_RED, "Jeweller\n");
    costs++;
    Term_gotoxy(62 + 2, 10 + costs);
  }
  if (current_cost.enchantment) {
    text_out_c(COLOUR_RED, "Enchantment\n");
    costs++;
    Term_gotoxy(62 + 2, 10 + costs);
  }
  if (current_cost.artistry) {
    text_out_c(COLOUR_RED, "Artistry\n");
    costs++;
    Term_gotoxy(62 + 2, 10 + costs);
  }
  if (current_cost.artifice) {
    text_out_c(COLOUR_RED, "Artifice\n");
    costs++;
    Term_gotoxy(62 + 2, 10 + costs);
  }
  if (current_cost.uses > 0) {
    if (square_forge_uses(cave, player->grid) >= current_cost.uses) {
      attr = COLOUR_SLATE;
    } else {
      affordable = false;
      attr = COLOUR_L_DARK;
    }
    if (current_cost.uses == 1) {
      text_out_c(attr, "1 Use");
    } else {
      text_out_c(attr, "%d Uses", current_cost.uses);
    }
    text_out_c(COLOUR_L_DARK, " (of %d)",
               square_forge_uses(cave, player->grid));
    costs++;
    Term_gotoxy(62 + 2, 10 + costs);
  }
  if (current_cost.drain > 0) {
    if (current_cost.drain <= player->skill_base[SKILL_SMITHING]) {
      attr = COLOUR_BLUE;
    } else {
      attr = COLOUR_L_DARK;
      affordable = false;
    }
    text_out_c(attr, "%d Smithing", current_cost.drain);
    costs++;
    Term_gotoxy(62 + 2, 10 + costs);
  }
  if (current_cost.mithril > 0) {
    if (current_cost.mithril <= mithril_carried(player)) {
      attr = COLOUR_SLATE;
    } else {
      attr = COLOUR_L_DARK;
      affordable = false;
    }
    text_out_c(attr, "%d.%d lb Mithril", current_cost.mithril / 10,
               current_cost.mithril % 10);
    costs++;
    Term_gotoxy(62 + 2, 10 + costs);
  }
  if (current_cost.stat[STAT_STR] > 0) {
    if (player->stat_base[STAT_STR] + player->stat_drain[STAT_STR] -
            current_cost.stat[STAT_STR] >=
        -5) {
      attr = COLOUR_SLATE;
    } else {
      attr = COLOUR_L_DARK;
      affordable = false;
    }
    text_out_c(attr, "%d Str", current_cost.stat[STAT_STR]);
    costs++;
    Term_gotoxy(62 + 2, 10 + costs);
  }
  if (current_cost.stat[STAT_DEX] > 0) {
    if (player->stat_base[STAT_DEX] + player->stat_drain[STAT_DEX] -
            current_cost.stat[STAT_DEX] >=
        -5) {
      attr = COLOUR_SLATE;
    } else {
      attr = COLOUR_L_DARK;
      affordable = false;
    }
    text_out_c(attr, "%d Dex", current_cost.stat[STAT_DEX]);
    costs++;
    Term_gotoxy(62 + 2, 10 + costs);
  }
  if (current_cost.stat[STAT_CON] > 0) {
    if (player->stat_base[STAT_CON] + player->stat_drain[STAT_CON] -
            current_cost.stat[STAT_CON] >=
        -5) {
      attr = COLOUR_SLATE;
    } else {
      attr = COLOUR_L_DARK;
      affordable = false;
    }
    text_out_c(attr, "%d Con", current_cost.stat[STAT_CON]);
    costs++;
    Term_gotoxy(62 + 2, 10 + costs);
  }
  if (current_cost.stat[STAT_GRA] > 0) {
    if (player->stat_base[STAT_GRA] + player->stat_drain[STAT_GRA] -
            current_cost.stat[STAT_GRA] >=
        -5) {
      attr = COLOUR_SLATE;
    } else {
      attr = COLOUR_L_DARK;
      affordable = false;
    }
    text_out_c(attr, "%d Gra", current_cost.stat[STAT_GRA]);
    costs++;
    Term_gotoxy(62 + 2, 10 + costs);
  }
  if (current_cost.exp > 0) {
    if (player->new_exp >= current_cost.exp) {
      attr = COLOUR_SLATE;
    } else {
      attr = COLOUR_L_DARK;
      affordable = false;
    }
    text_out_c(attr, "%d Exp", current_cost.exp);
    costs++;
    Term_gotoxy(62 + 2, 10 + costs);
  }
  attr = COLOUR_SLATE;
  text_out_c(attr, "%d Turns", MAX(10, dif * 10));
  clear_from(MAX_SMITHING_TVALS + 3);
  if (player->smithing_leftover) {
    Term_gotoxy(2, MAX_SMITHING_TVALS + 3);
    text_out_c(COLOUR_L_BLUE, "In progress:");
    Term_gotoxy(2 - 1, MAX_SMITHING_TVALS + 5);
    text_out_c(COLOUR_BLUE, "%3d turns left", player->smithing_leftover);
  }
  if (smith_obj->number > 1) {
    mode |= ODESC_PREFIX;
  }
  include_pval(smith_obj);
  know_smith_obj();
  object_desc(o_desc, sizeof(o_desc), smith_obj, mode, player);
  my_strcat(o_desc,
            format("   %d.%d lb", smith_obj->weight * smith_obj->number / 10,
                   (smith_obj->weight * smith_obj->number) % 10),
            sizeof(o_desc));
  tb = object_info(smith_obj, OINFO_SMITH);
  exclude_pval(smith_obj);
  textui_textblock_place(tb, bottom, o_desc);
  textblock_free(tb);
  text_out_indent = 0;
  text_out_wrap = 0;
}
STATIC_OVL void
smith_obj_browser(int oid, void* data, const region* loc)
{
  show_smith_obj();
}
STATIC_OVL int
get_smithing_svals(int tval)
{
  int i, count = 0;
  for (i = 0; i < z_info->k_max; i++) {
    struct object_kind* kind = &k_info[i];
    if (kind->tval != tval) continue;
    if (kf_has(kind->kind_flags, KF_INSTA_ART)) continue;
    if (of_has(kind->flags, OF_NO_SMITHING)) continue;
    smithing_svals[count++] = kind;
  }
  return count;
}
STATIC_OVL void
sval_display(struct menu* menu, int oid, bool cursor, int row, int col,
             int width)
{
  char name[40];
  struct object_kind** choice = (struct object_kind**)menu->menu_data;
  uint8_t attr = (cursor ? COLOUR_L_BLUE : COLOUR_WHITE);
  struct object object_body, object_known_body;
  struct object *obj = &object_body, *known_obj = &object_known_body;
  struct smithing_cost local_cost;
  struct smithing_cost* cost = &local_cost;
  if (cursor) {
    obj = smith_obj;
    known_obj = smith_obj_known;
    cost = &current_cost;
  }
  create_base_object(choice[oid], obj);
  object_copy(known_obj, obj);
  known_obj->known = NULL;
  obj->known = known_obj;
  if (cursor) {
    object_wipe(smith_obj_backup);
    object_copy(smith_obj_backup, smith_obj);
  }
  include_pval(obj);
  (void)object_difficulty(obj, cost);
  attr = smith_affordable(obj, cost) ? COLOUR_WHITE : COLOUR_SLATE;
  if (cursor) {
    know_smith_obj();
    show_smith_obj();
  }
  exclude_pval(obj);
  object_kind_name(name, sizeof(name), choice[oid], true);
  c_put_str(attr, name, row, col);
}
STATIC_OVL bool
sval_action(struct menu* m, const ui_event* event, int oid)
{
  return (event->type == EVT_SELECT) ? false : true;
}
STATIC_OVL void
tval_display(struct menu* menu, int oid, bool cursor, int row, int col,
             int width)
{
  const char* name = smithing_tvals[oid].desc;
  uint8_t attr = COLOUR_RED;
  if (((smithing_tvals[oid].category == SMITH_TYPE_WEAPON) &&
       player_active_ability(player, "Weaponsmith")) ||
      ((smithing_tvals[oid].category == SMITH_TYPE_JEWELRY) &&
       player_active_ability(player, "Jeweller")) ||
      ((smithing_tvals[oid].category == SMITH_TYPE_ARMOUR) &&
       player_active_ability(player, "Armoursmith"))) {
    attr = COLOUR_WHITE;
  }
  c_put_str(attr, name, row, col);
}
STATIC_OVL bool
tval_action(struct menu* m, const ui_event* event, int oid)
{
  struct menu menu;
  menu_iter menu_f = {NULL, NULL, sval_display, sval_action, NULL};
  region area = {34, 2, 62 - 34, MAX_SMITHING_TVALS};
  ui_event evt;
  int count = 0;
  bool selected = false;
  screen_save();
  count = get_smithing_svals(smithing_tvals[oid].tval);
  menu_init(&menu, MN_SKIN_SCROLL, &menu_f);
  menu.selections = lower_case;
  menu.flags = MN_CASELESS_TAGS;
  menu.browse_hook = smith_obj_browser;
  menu_setpriv(&menu, count, smithing_svals);
  menu_layout(&menu, &area);
  evt = menu_select(&menu, 0, true);
  if (evt.type == EVT_SELECT) {
    smith_obj->kind = smithing_svals[menu.cursor];
    pval = pval_valid(smith_obj) ? pval_default(smith_obj) : 0;
    selected = true;
  }
  menu_refresh(smithing_menu, false);
  screen_load();
  return !selected;
}
STATIC_OVL void
tval_menu(const char* name, int row)
{
  struct menu menu;
  menu_iter menu_f = {NULL, NULL, tval_display, tval_action, NULL};
  ui_event evt = EVENT_EMPTY;
  region area = {16, 2, 34 - 16, MAX_SMITHING_TVALS};
  region big = {16, 2, 0, 0};
  wipe_smithing_objects();
  pval = 0;
  menu_init(&menu, MN_SKIN_SCROLL, &menu_f);
  menu.selections = lower_case;
  menu.flags = MN_CASELESS_TAGS;
  menu.browse_hook = smith_obj_browser;
  menu_setpriv(&menu, MAX_SMITHING_TVALS, (void*)smithing_tvals);
  region_erase(&big);
  numbers_changed = false;
  menu_layout(&menu, &area);
  while (evt.type != EVT_ESCAPE) {
    evt = menu_select(&menu, 0, false);
    if ((evt.type == EVT_SELECT) && smith_obj->kind) break;
  }
  return;
}
STATIC_OVL int
get_smithing_specials(struct object_kind* kind)
{
  int i, count = 0, pval_old = pval;
  struct object dummy_body, dummy_body_known;
  struct smithing_cost dummy_cost;
  if (!kind) return 0;
  for (i = 0; i < z_info->e_max; i++) {
    struct ego_item* ego = &e_info[i];
    struct poss_item* poss;
    for (poss = ego->poss_items; poss; poss = poss->next) {
      if (kind->kidx == poss->kidx) break;
    }
    if (!poss) continue;
    smithing_specials[count] = ego;
    object_copy(&dummy_body, smith_obj);
    create_special(&dummy_body, ego);
    object_copy(&dummy_body_known, &dummy_body);
    dummy_body_known.known = NULL;
    dummy_body.known = &dummy_body_known;
    pval = pval_valid(&dummy_body) ? pval_default(&dummy_body) : 0;
    include_pval(&dummy_body);
    (void)object_difficulty(&dummy_body, &dummy_cost);
    affordable_specials[count] = smith_affordable(&dummy_body, &dummy_cost);
    exclude_pval(&dummy_body);
    object_wipe(&dummy_body_known);
    object_wipe(&dummy_body);
    ++count;
  }
  pval = pval_old;
  return count;
}
STATIC_OVL void
special_display(struct menu* menu, int oid, bool cursor, int row, int col,
                int width)
{
  struct ego_item** choice = (struct ego_item**)menu->menu_data;
  uint8_t attr = affordable_specials[oid] ? COLOUR_WHITE : COLOUR_SLATE;
  if (cursor) {
    create_special(smith_obj, choice[oid]);
    know_smith_obj();
    pval = pval_valid(smith_obj) ? smith_obj->pval : 0;
    include_pval(smith_obj);
    show_smith_obj();
    exclude_pval(smith_obj);
  }
  c_put_str(attr, strip_ego_name(choice[oid]->name), row, col);
}
STATIC_OVL bool
special_action(struct menu* m, const ui_event* event, int oid)
{
  return (event->type == EVT_SELECT) ? false : true;
}
STATIC_OVL void
special_menu(const char* name, int row)
{
  struct object_kind* kind = smith_obj->kind;
  struct menu menu;
  menu_iter menu_f = {NULL, NULL, special_display, special_action, NULL};
  int count;
  region area = {16, 2, 62 - 16, MAX_SMITHING_TVALS};
  ui_event evt;
  if (smith_obj->artifact) reset_smithing_objects(kind);
  menu_init(&menu, MN_SKIN_SCROLL, &menu_f);
  smithing_specials = mem_zalloc(z_info->e_max * sizeof(smithing_specials));
  affordable_specials = mem_zalloc(z_info->e_max * sizeof(affordable_specials));
  count = get_smithing_specials(smith_obj->kind);
  if (!count) {
    mem_free(affordable_specials);
    mem_free(smithing_specials);
    return;
  }
  menu.selections = lower_case;
  menu.flags = MN_CASELESS_TAGS;
  menu_setpriv(&menu, count, smithing_specials);
  menu_layout(&menu, &area);
  evt = menu_select(&menu, 0, false);
  if (evt.type == EVT_SELECT) smith_obj->ego = smithing_specials[menu.cursor];
  menu_refresh(&menu, false);
  mem_free(affordable_specials);
  mem_free(smithing_specials);
  return;
}
STATIC_OVL int
get_smith_properties(enum smithing_category cat)
{
  int i, count = 0;
  for (i = 0; i < z_info->property_max; i++) {
    struct obj_property* prop = &obj_properties[i];
    if (prop->smith_cat != (int)cat) continue;
    if (!applicable_property(prop, smith_obj)) continue;
    negative = false;
    smith_art_properties[count].prop = prop;
    smith_art_properties[count++].negative = false;
    if (cat == SMITH_CAT_STAT) {
      smith_art_properties[count].prop = prop;
      smith_art_properties[count++].negative = true;
    }
  }
  return count;
}
STATIC_OVL int
get_smith_art_abilities(int skill)
{
  struct ability* a;
  int count = 0;
  for (a = abilities; a; a = a->next) {
    struct poss_item* poss = a->poss_items;
    if (a->skill != skill) continue;
    while (poss) {
      if (poss->kidx == smith_obj->kind->kidx) break;
      poss = poss->next;
    }
    if (!poss) continue;
    smith_art_abilities[count++] = a;
  }
  return count;
}
STATIC_OVL void
rename_artefact(void)
{
  char tmp[20];
  char o_desc[30];
  bool name_selected = false;
  tmp[0] = '\0';
  my_strcpy(tmp, smith_art->name, sizeof(tmp));
  my_strcpy(smith_art_name, "", sizeof(smith_art_name));
  object_desc(o_desc, sizeof(o_desc), smith_obj, ODESC_BASE, player);
  Term_putstr(16, MAX_SMITHING_TVALS + 3, -1, COLOUR_L_WHITE, o_desc);
  Term_gotoxy(16 + strlen(o_desc), MAX_SMITHING_TVALS + 3);
  while (!name_selected) {
    if (askfor_aux(tmp, sizeof(tmp), NULL)) {
      my_strcpy(smith_art->name, tmp, 30);
      player->upkeep->redraw |= (PR_MISC);
    } else {
      strnfmt(smith_art_name, sizeof(smith_art_name), "of %s",
              player->full_name);
      return;
    }
    if (tmp[0] != '\0') {
      name_selected = true;
    } else {
      strnfmt(smith_art_name, sizeof(smith_art_name), "of %s",
              player->full_name);
    }
  }
}
STATIC_OVL void
ui_skill_display(struct menu* menu, int oid, bool cursor, int row, int col,
                 int width)
{
  struct ability** choice = menu->menu_data;
  bool chosen = !!locate_ability(smith_obj->abilities, choice[oid]);
  uint8_t attr = chosen ? COLOUR_BLUE : COLOUR_SLATE;
  struct object backup;
  if (!applicable_ability(choice[oid], smith_obj)) {
    attr = COLOUR_L_DARK;
  } else {
    include_pval(smith_obj);
    object_copy(&backup, smith_obj);
    if (!chosen) {
      add_ability(&smith_obj->abilities, choice[oid]);
      if (smith_affordable(smith_obj, &current_cost) && cursor) {
        attr = COLOUR_BLUE;
      }
    }
    if (!chosen) {
      remove_ability(&smith_obj->abilities, choice[oid]);
    }
    object_wipe(smith_obj);
    object_copy(smith_obj, &backup);
    (void)smith_affordable(smith_obj, &current_cost);
    exclude_pval(smith_obj);
  }
  c_put_str(attr, choice[oid]->name, row, col);
}
STATIC_OVL bool
ui_skill_action(struct menu* m, const ui_event* event, int oid)
{
  struct ability** choice = m->menu_data;
  if (event->type == EVT_SELECT) {
    if (!applicable_ability(choice[oid], smith_obj)) return false;
    if (!locate_ability(smith_obj->abilities, choice[oid])) {
      add_ability(&smith_obj->abilities, choice[oid]);
    } else {
      remove_ability(&smith_obj->abilities, choice[oid]);
    }
    return true;
  }
  return false;
}
STATIC_OVL void
prop_display(struct menu* menu, int oid, bool cursor, int row, int col,
             int width)
{
  struct property_info* choice = menu->menu_data;
  bool chosen = object_has_property(choice[oid].prop, smith_obj, false);
  uint8_t attr;
  char* name;
  if (choice[oid].prop->smith_cat == SMITH_CAT_STAT) {
    if (choice[oid].negative) {
      chosen = object_has_property(choice[oid].prop, smith_obj, true);
      name = format("%s penalty", choice[oid].prop->name);
    } else {
      name = format("%s bonus", choice[oid].prop->name);
    }
  } else {
    name = choice[oid].prop->name;
  }
  attr = chosen ? COLOUR_BLUE : COLOUR_SLATE;
  c_put_str(attr, name, row, col);
}
STATIC_OVL bool
prop_action(struct menu* m, const ui_event* event, int oid)
{
  struct property_info* choice = m->menu_data;
  if (event->type == EVT_SELECT) {
    if (!object_has_property(choice[oid].prop, smith_obj,
                             choice[oid].negative)) {
      add_object_property(choice[oid].prop, smith_obj, choice[oid].negative);
    } else {
      remove_object_property(choice[oid].prop, smith_obj);
    }
    return true;
  }
  return false;
}
STATIC_OVL void
artefact_display(struct menu* menu, int oid, bool cursor, int row, int col,
                 int width)
{
  char** choice = menu->menu_data;
  uint8_t attr;
  assert(oid >= 0 && oid < SMITH_CAT_MAX + SKILL_MAX + 1 &&
         smithing_art_cat_counts);
  attr = smithing_art_cat_counts[oid] > 0
             ? (cursor ? COLOUR_L_BLUE : COLOUR_WHITE)
             : COLOUR_L_DARK;
  if (cursor) {
    know_smith_obj();
    include_pval(smith_obj);
    show_smith_obj();
    exclude_pval(smith_obj);
  }
  c_put_str(attr, choice[oid], row, col);
}
STATIC_OVL bool
artefact_action(struct menu* m, const ui_event* event, int oid)
{
  struct menu menu;
  region area = {34, 2, 62 - 34, MAX_SMITHING_TVALS};
  int count;
  if (event->type == EVT_SELECT) {
    if (oid < SMITH_CAT_MAX) {
      menu_iter menu_f = {NULL, NULL, prop_display, prop_action, NULL};
      menu_init(&menu, MN_SKIN_SCROLL, &menu_f);
      smith_art_properties =
          mem_zalloc(z_info->property_max * sizeof(struct property_info));
      count = get_smith_properties(oid);
      if (!count) {
        mem_free(smith_art_properties);
        smith_art_properties = NULL;
        return true;
      }
      menu.selections = lower_case;
      menu.flags = MN_CASELESS_TAGS;
      menu_setpriv(&menu, count, smith_art_properties);
      menu_layout(&menu, &area);
      menu_select(&menu, 0, true);
      mem_free(smith_art_properties);
      smith_art_properties = NULL;
    } else if (oid < SMITH_CAT_MAX + SKILL_MAX) {
      menu_iter menu_f = {NULL, NULL, ui_skill_display, ui_skill_action, NULL};
      menu_init(&menu, MN_SKIN_SCROLL, &menu_f);
      smith_art_abilities = mem_zalloc(100 * sizeof(struct ability*));
      count = get_smith_art_abilities(oid - SMITH_CAT_MAX);
      if (!count) {
        mem_free(smith_art_abilities);
        smith_art_abilities = NULL;
        return true;
      }
      menu.flags = MN_CASELESS_TAGS;
      menu.selections = lower_case;
      menu_setpriv(&menu, count, smith_art_abilities);
      menu_layout(&menu, &area);
      menu_select(&menu, 0, true);
      mem_free(smith_art_abilities);
      smith_art_abilities = NULL;
    } else {
      rename_artefact();
    }
  }
  return true;
}
STATIC_OVL void
artefact_menu(const char* name, int row)
{
  struct object_kind* kind;
  struct menu menu;
  menu_iter menu_f = {NULL, NULL, artefact_display, artefact_action, NULL};
  region area = {16, 2, 62 - 16, MAX_SMITHING_TVALS};
  int i;
  if (!smith_obj->kind) return;
  kind = lookup_selfmade_kind(smith_obj->kind->tval);
  if (!kind) {
    kind = smith_obj->kind;
  }
  if (smith_obj->ego || kind != smith_obj->kind) {
    reset_smithing_objects(kind);
  }
  smith_obj->artifact = smith_art;
  strnfmt(smith_art_name, sizeof(smith_art_name), "of %s", player->full_name);
  smith_art->name = smith_art_name;
  smithing_art_cat_counts = mem_alloc((SMITH_CAT_MAX + SKILL_MAX + 1) *
                                      sizeof(smithing_art_cat_counts));
  for (i = 0; i < SMITH_CAT_MAX; ++i) {
    smith_art_properties =
        mem_zalloc(z_info->property_max * sizeof(*smith_art_properties));
    smithing_art_cat_counts[i] = get_smith_properties(i);
    mem_free(smith_art_properties);
    smith_art_properties = NULL;
  }
  for (i = SMITH_CAT_MAX; i < SMITH_CAT_MAX + SKILL_MAX; ++i) {
    smith_art_abilities = mem_zalloc(100 * sizeof(*smith_art_abilities));
    smithing_art_cat_counts[i] = get_smith_art_abilities(i - SMITH_CAT_MAX);
    mem_free(smith_art_abilities);
    smith_art_abilities = NULL;
  }
  smithing_art_cat_counts[SMITH_CAT_MAX + SKILL_MAX] = 1;
  menu_init(&menu, MN_SKIN_SCROLL, &menu_f);
  menu.selections = lower_case;
  menu.flags = MN_CASELESS_TAGS;
  menu.browse_hook = smith_obj_browser;
  menu_setpriv(&menu, SMITH_CAT_MAX + SKILL_MAX + 1, smithing_art_cats);
  menu_layout(&menu, &area);
  menu_select(&menu, 0, false);
  mem_free(smithing_art_cat_counts);
  smithing_art_cat_counts = NULL;
}
STATIC_OVL void
melt_display(struct menu* menu, int oid, bool cursor, int row, int col,
             int width)
{
  struct object** choice = menu->menu_data;
  char o_name[80];
  uint8_t attr = (cursor ? COLOUR_L_BLUE : COLOUR_WHITE);
  object_desc(o_name, sizeof(o_name), choice[oid], ODESC_PREFIX | ODESC_FULL,
              player);
  c_put_str(attr, o_name, row, col);
}
STATIC_OVL bool
melt_action(struct menu* m, const ui_event* event, int oid)
{
  struct object** choice = m->menu_data;
  if (event->type == EVT_SELECT) {
    melt_mithril_item(player, choice[oid]);
  }
  return false;
}
STATIC_OVL void
melt_menu(const char* name, int row)
{
  struct menu menu;
  menu_iter menu_f = {NULL, NULL, melt_display, melt_action, NULL};
  int count = 0;
  region area = {16, 2, 0, 0};
  struct object* obj;
  struct object** melt_menu_info = NULL;
  for (obj = player->gear; obj; obj = obj->next) {
    if (object_is_mithril(obj)) {
      melt_menu_info =
          mem_realloc(melt_menu_info, (count + 1) * sizeof(struct object*));
      melt_menu_info[count++] = obj;
    }
  }
  if (!count) return;
  menu_init(&menu, MN_SKIN_SCROLL, &menu_f);
  menu.selections = lower_case;
  menu.flags = MN_CASELESS_TAGS;
  menu.browse_hook = smith_obj_browser;
  menu_setpriv(&menu, count, melt_menu_info);
  menu_layout(&menu, &area);
  menu_select(&menu, 0, false);
  mem_free(melt_menu_info);
  return;
}
STATIC_OVL void
numbers_set_validity(void)
{
  struct object backup;
  int old_pval = pval;
  int i;
  numbers_valid[SMITH_NUM_INC_ATT] =
      att_valid(smith_obj) && (smith_obj->att < att_max(smith_obj, true));
  numbers_needs_artistry[SMITH_NUM_INC_ATT] =
      att_valid(smith_obj) && !(smith_obj->att < att_max(smith_obj, false));
  numbers_valid[SMITH_NUM_DEC_ATT] =
      att_valid(smith_obj) && (smith_obj->att > att_min(smith_obj));
  numbers_valid[SMITH_NUM_INC_DS] =
      ds_valid(smith_obj) && (smith_obj->ds < ds_max(smith_obj, true));
  numbers_needs_artistry[SMITH_NUM_INC_DS] =
      ds_valid(smith_obj) && !(smith_obj->ds < ds_max(smith_obj, false));
  numbers_valid[SMITH_NUM_DEC_DS] =
      ds_valid(smith_obj) && (smith_obj->ds > ds_min(smith_obj));
  numbers_valid[SMITH_NUM_INC_EVN] =
      evn_valid(smith_obj) && (smith_obj->evn < evn_max(smith_obj, true));
  numbers_needs_artistry[SMITH_NUM_INC_EVN] =
      evn_valid(smith_obj) && !(smith_obj->evn < evn_max(smith_obj, false));
  numbers_valid[SMITH_NUM_DEC_EVN] =
      evn_valid(smith_obj) && (smith_obj->evn > evn_min(smith_obj));
  numbers_valid[SMITH_NUM_INC_PS] =
      ps_valid(smith_obj) && (smith_obj->ps < ps_max(smith_obj, true));
  numbers_needs_artistry[SMITH_NUM_INC_PS] =
      ps_valid(smith_obj) && !(smith_obj->ps < ps_max(smith_obj, false));
  numbers_valid[SMITH_NUM_DEC_PS] =
      ps_valid(smith_obj) && (smith_obj->ps > ps_min(smith_obj));
  numbers_valid[SMITH_NUM_INC_PVAL] =
      pval_valid(smith_obj) && (pval < pval_max(smith_obj));
  numbers_valid[SMITH_NUM_DEC_PVAL] =
      pval_valid(smith_obj) && (pval > pval_min(smith_obj));
  numbers_valid[SMITH_NUM_INC_WGT] =
      wgt_valid(smith_obj) && (smith_obj->weight < wgt_max(smith_obj));
  numbers_valid[SMITH_NUM_DEC_WGT] =
      wgt_valid(smith_obj) && (smith_obj->weight > wgt_min(smith_obj));
  for (i = 0; i < SMITH_NUM_MAX; i++) {
    if (numbers_valid[i]) {
      object_copy(&backup, smith_obj);
      modify_numbers(smith_obj, i, &pval);
      include_pval(smith_obj);
      numbers_can_afford[i] = smith_affordable(smith_obj, &current_cost);
      pval = old_pval;
      exclude_pval(smith_obj);
      object_wipe(smith_obj);
      object_copy(smith_obj, &backup);
    }
  }
}
STATIC_OVL void
numbers_display(struct menu* menu, int oid, bool cursor, int row, int col,
                int width)
{
  struct numbers_menu_entry* choice = menu->menu_data;
  uint8_t attr = numbers_valid[oid] ? COLOUR_SLATE : COLOUR_L_DARK;
  if (numbers_valid[oid] && numbers_can_afford[oid]) attr = COLOUR_WHITE;
  if (numbers_valid[oid] && numbers_needs_artistry[oid]) attr = COLOUR_RED;
  show_smith_obj();
  c_put_str(attr, choice[oid].name, row, col);
}
STATIC_OVL bool
numbers_action(struct menu* m, const ui_event* event, int oid)
{
  if (event->type == EVT_SELECT) {
    if (numbers_valid[oid]) {
      modify_numbers(smith_obj, oid, &pval);
      numbers_changed = true;
      numbers_set_validity();
      menu_refresh(m, false);
    }
  }
  return false;
}
STATIC_OVL void
numbers_menu(const char* name, int row)
{
  struct menu menu;
  menu_iter menu_f = {NULL, NULL, numbers_display, numbers_action, NULL};
  ui_event evt = EVENT_EMPTY;
  region area = {16, 2, 34 - 16, MAX_SMITHING_TVALS};
  region old = {16, 2, 62 - 16, MAX_SMITHING_TVALS};
  if (!smith_obj->kind) return;
  numbers_set_validity();
  region_erase(&old);
  menu_init(&menu, MN_SKIN_SCROLL, &menu_f);
  menu.selections = lower_case;
  menu.flags = MN_CASELESS_TAGS;
  menu_setpriv(&menu, SMITH_NUM_MAX, numbers_menu_info);
  menu_layout(&menu, &area);
  while (evt.type != EVT_ESCAPE) {
    evt = menu_select(&menu, 0, false);
  }
  return;
}
STATIC_OVL void
accept_item(const char* name, int row)
{
  include_pval(smith_obj);
  if (!smith_affordable(smith_obj, &current_cost) ||
      !square_isforge(cave, player->grid) ||
      !square_forge_uses(cave, player->grid)) {
    exclude_pval(smith_obj);
    return;
  }
  exclude_pval(smith_obj);
  if (current_cost.drain > 0) {
    char buf[80];
    strnfmt(buf, sizeof(buf),
            "This will drain your smithing "
            "skill by %d points. Proceed? ",
            current_cost.drain);
    if (!get_check(buf)) return;
  }
  create_smithed_item = true;
  include_pval(smith_obj);
  if (smith_obj->artifact) add_artefact_details(smith_art, smith_obj);
  exclude_pval(smith_obj);
}
STATIC_OVL void
smithing_menu_browser(int oid, void* data, const region* loc)
{
  uint8_t attr = COLOUR_SLATE;
  const char* desc[] = {"Start with a new base item.               ",
                        "                                          ",
                        "Choose a special enchantment to add to the",
                        "base item. (not compatible with Artifice) ",
                        "Design your own artefact.                 ",
                        "(not compatible with Enchant)             ",
                        "Change the item's key numbers.            ",
                        "                                          ",
                        "Choose a mithril item to melt down.       ",
                        "                                          ",
                        "Create the item you have designed.        ",
                        "(to cancel it instead, just press Escape) "};
  const char* extra[] = {"(Enchantment cannot be changed after     ",
                         "using the Numbers menu)                  ",
                         "This forge has no resources, so you cannot",
                         "create items. To exit, press Escape.     ",
                         "You are not at a forge and thus cannot   ",
                         "create items. To exit, press Escape.     "};
  region area = {16, 2, 62 - 16, MAX_SMITHING_TVALS + 2};
  text_out_hook = text_out_to_screen;
  text_out_wrap = 62;
  text_out_indent = 16;
  region_erase(&area);
  Term_gotoxy(16, 2);
  if (no_forge && (oid == 5)) {
    text_out_c(attr, "%s", extra[4]);
  } else if (exhausted && (oid == 5)) {
    text_out_c(attr, "%s", extra[2]);
  } else if (numbers_changed && (oid == 1)) {
    text_out_c(attr, "%s", extra[0]);
  } else {
    text_out_c(attr, "%s", desc[oid * 2]);
  }
  Term_gotoxy(16, 2 + 1);
  if (no_forge && (oid == 5)) {
    text_out_c(attr, "%s", extra[5]);
  } else if (exhausted && (oid == 5)) {
    text_out_c(attr, "%s", extra[3]);
  } else if (numbers_changed && (oid == 1)) {
    text_out_c(attr, "%s", extra[1]);
  } else {
    text_out_c(attr, "%s", desc[oid * 2 + 1]);
  }
  if (smith_obj->kind) {
    show_smith_obj();
  }
}
STATIC_OVL void
check_smithing_menu_row_colors(void)
{
  size_t i;
  for (i = 0; i < N_ELEMENTS(smithing_actions); i++) {
    if (i == 0) {
      if (player_active_ability(player, "Weaponsmith") ||
          player_active_ability(player, "Armoursmith") ||
          player_active_ability(player, "Jeweller")) {
        smithing_actions[i].flags = 0;
      } else {
        smithing_actions[i].flags = MN_ACT_MAYBE;
      }
    }
    if (i == 1) {
      if (!smith_obj->kind || smith_obj->artifact || numbers_changed ||
          tval_is_jewelry(smith_obj) || tval_is_horn(smith_obj) ||
          strstr(smith_obj->kind->name, "Shovel")) {
        smithing_actions[i].flags = MN_ACT_GRAYED;
      } else if (player_active_ability(player, "Enchantment")) {
        smithing_actions[i].flags = 0;
      } else {
        smithing_actions[i].flags = MN_ACT_MAYBE;
      }
    }
    if (i == 2) {
      if (!smith_obj->kind || smith_obj->ego || tval_is_horn(smith_obj) ||
          (player->self_made_arts >= z_info->self_arts_max)) {
        smithing_actions[i].flags = MN_ACT_GRAYED;
      } else if (player_active_ability(player, "Artifice")) {
        smithing_actions[i].flags = 0;
      } else {
        smithing_actions[i].flags = MN_ACT_MAYBE;
      }
    }
    if (i == 3) {
      if (!smith_obj->kind) {
        smithing_actions[i].flags = MN_ACT_GRAYED;
      } else {
        smithing_actions[i].flags = 0;
      }
    }
    if (i == 4) {
      if (!mithril_items_carried(player) ||
          !square_isforge(cave, player->grid) ||
          !square_forge_uses(cave, player->grid)) {
        smithing_actions[i].flags = MN_ACT_GRAYED;
      } else {
        smithing_actions[i].flags = 0;
      }
    }
    if (i == 5) {
      include_pval(smith_obj);
      if (!smith_obj->kind || !smith_affordable(smith_obj, &current_cost) ||
          !square_isforge(cave, player->grid) ||
          !square_forge_uses(cave, player->grid)) {
        smithing_actions[i].flags = MN_ACT_GRAYED;
      } else {
        smithing_actions[i].flags = 0;
      }
      exclude_pval(smith_obj);
    }
  }
}
STATIC_OVL struct object*
textui_smith_object(struct smithing_cost* cost)
{
  region area = {2, 2, 16 - 2, 8 - 2};
  if (player->smithing_leftover > 0) {
    if (square_isforge(cave, player->grid)) {
      *cost = current_cost;
      return smith_obj;
    }
    if (!get_check(format("A forge has an unfinished %s.  Abandon it to see "
                          "smithing options? ",
                          smith_obj->artifact ? "artifact" : "item"))) {
      return NULL;
    }
    player->smithing_leftover = 0;
  }
  wipe_smithing_objects();
  screen_save();
  clear_from(0);
  create_smithed_item = false;
  smithing_menu =
      menu_new_action(smithing_actions, N_ELEMENTS(smithing_actions));
  check_smithing_menu_row_colors();
  if (!square_isforge(cave, player->grid)) {
    no_forge = true;
    exhausted = false;
    prt("Exploration mode:  Smithing requires a forge.", 0, 0);
  } else if (!square_forge_uses(cave, player->grid)) {
    no_forge = false;
    exhausted = true;
    prt("Exploration mode:  Smithing requires a forge with resources left.", 0,
        0);
  } else {
    no_forge = false;
    exhausted = false;
  }
  smithing_menu->flags = MN_CASELESS_TAGS;
  smithing_menu->browse_hook = smithing_menu_browser;
  menu_layout(smithing_menu, &area);
  while (!create_smithed_item) {
    ui_event evt = EVENT_EMPTY;
    check_smithing_menu_row_colors();
    evt = menu_select(smithing_menu, EVT_KBRD, false);
    if (evt.type == EVT_ESCAPE) {
      wipe_smithing_objects();
      create_smithed_item = false;
      break;
    }
  }
  menu_free(smithing_menu);
  screen_load();
  include_pval(smith_obj);
  *cost = current_cost;
  return create_smithed_item ? smith_obj : NULL;
}
STATIC_OVL int
get_songs(void)
{
  struct ability* a = abilities;
  int count = 0;
  while (a) {
    if ((a->skill == SKILL_SONG) && strstr(a->name, "Song of") &&
        player_active_ability(player, a->name)) {
      labels[count] = 'a' + count;
      songlist[count].swap = false;
      songlist[count++].song = lookup_song(a->name + strlen("Song of "));
    }
    a = a->next;
  }
  if (player->song[SONG_MAIN]) {
    labels[count] = 's';
    songlist[count].swap = false;
    songlist[count++].song = NULL;
  }
  if (player->song[SONG_MINOR]) {
    labels[count] = 'x';
    songlist[count].swap = true;
    songlist[count++].song = NULL;
  }
  labels[count] = '\0';
  return count;
}
STATIC_OVL char
song_tag(struct menu* menu, int oid)
{
  struct song_menu_info* choice = menu->menu_data;
  struct song* song = choice[oid].song;
  if (song) {
    return 'a' + oid;
  } else if (choice[oid].swap) {
    return 'x';
  } else {
    return 's';
  }
}
STATIC_OVL void
song_display(struct menu* menu, int oid, bool cursor, int row, int col,
             int width)
{
  struct song_menu_info* choice = menu->menu_data;
  struct song* song = choice[oid].song;
  const char* str;
  uint8_t attr = (cursor ? COLOUR_L_BLUE : COLOUR_WHITE);
  if (song) {
    str = format("Song of %s", song->name);
  } else if (choice[oid].swap) {
    str = "Exchange themes";
  } else {
    str = "Stop singing";
  }
  c_put_str(attr, str, row, col);
}
STATIC_OVL bool
song_action(struct menu* m, const ui_event* event, int oid)
{
  struct song_menu_info* choice = m->menu_data;
  struct song* song = choice[oid].song;
  if (event->type == EVT_SELECT) {
    if (song == NULL) {
      if (choice[oid].swap) {
        player_change_song(player, NULL, true);
      } else {
        player_change_song(player, NULL, false);
      }
    } else {
      player_change_song(player, song, false);
    }
    return false;
  }
  return true;
}
STATIC_OVL void
textui_change_song(void)
{
  struct menu menu;
  menu_iter menu_f = {song_tag, NULL, song_display, song_action, NULL};
  region area = {10, 2, 0, 0};
  int count;
  songlist = mem_zalloc(100 * sizeof(struct song_menu_info));
  count = get_songs();
  if (!count) {
    msg("You do not know any songs of power.");
    mem_free(songlist);
    return;
  }
  menu_init(&menu, MN_SKIN_SCROLL, &menu_f);
  menu.title = "Songs";
  menu.selections = labels;
  menu.flags = MN_CASELESS_TAGS;
  menu_setpriv(&menu, count, songlist);
  menu_layout(&menu, &area);
  menu_select(&menu, 0, true);
  mem_free(songlist);
}
STATIC_OVL void
spoiler_menu_act(const char* title, int row)
{
  if (row == 0) {
    cmdq_push(CMD_SPOIL_OBJ);
  } else if (row == 1) {
    cmdq_push(CMD_SPOIL_ARTIFACT);
  } else if (row == 2) {
    cmdq_push(CMD_SPOIL_MON_BRIEF);
  } else if (row == 3) {
    cmdq_push(CMD_SPOIL_MON);
  } else {
    assert(0);
  }
  cmdq_execute((player->is_dead) ? CTX_DEATH : CTX_GAME);
  event_signal(EVENT_MESSAGE_FLUSH);
}
STATIC_OVL void
do_cmd_spoilers(void)
{
  if (!spoil_menu) {
    spoil_menu = menu_new_action(spoil_actions, N_ELEMENTS(spoil_actions));
    spoil_menu->selections = all_letters_nohjkl;
    spoil_menu->title = "Create spoilers";
  }
  screen_save();
  clear_from(0);
  menu_layout(spoil_menu, &SCREEN_REGION);
  menu_select(spoil_menu, 0, false);
  screen_load();
}
int
target_dir(struct keypress ch)
{
  return target_dir_allow(ch, false);
}
STATIC_OVL int
target_dir_allow(struct keypress ch, bool allow_5)
{
  int d = 0;
  if (isdigit((unsigned char)ch.code)) {
    d = D2I(ch.code);
  } else if (isarrow(ch.code)) {
    switch (ch.code) {
      case ARROW_DOWN:
        d = 2;
        break;
      case ARROW_LEFT:
        d = 4;
        break;
      case ARROW_RIGHT:
        d = 6;
        break;
      case ARROW_UP:
        d = 8;
        break;
    }
  } else {
    int mode;
    const struct keypress* act;
    if (OPT(player, angband_keyset))
      mode = KEYMAP_MODE_ANGBAND;
    else
      mode = KEYMAP_MODE_ORIG;
    if (OPT(player, hjkl_movement)) {
      mode |= KEYMAP_MODE_ROGUE;
    }
    act = keymap_find(mode, ch);
    if (act) {
      const struct keypress* cur;
      for (cur = act; cur->type == EVT_KBRD; cur++) {
        if (isdigit((unsigned char)cur->code)) d = D2I(cur->code);
      }
    }
  }
  if (d == 5 && !allow_5) d = 0;
  return (d);
}
STATIC_OVL void
target_display_help(bool monster, bool object, bool free)
{
  int wid, hgt, help_loc;
  int mode =
      OPT(player, angband_keyset) ? KEYMAP_MODE_ANGBAND : KEYMAP_MODE_ORIG;
  if (OPT(player, hjkl_movement)) {
    mode |= KEYMAP_MODE_ROGUE;
  }
  Term_get_size(&wid, &hgt);
  help_loc = hgt - HELP_HEIGHT;
  clear_from(help_loc);
  text_out_hook = text_out_to_screen;
  text_out_indent = 1;
  Term_gotoxy(1, help_loc);
  text_out_c(COLOUR_L_GREEN, "<dir>");
  text_out(" and ");
  text_out_c(COLOUR_L_GREEN, "<click>");
  text_out(" look around. '");
  text_out_c(COLOUR_L_GREEN, "g");
  text_out("' moves to selection. '");
  text_out_c(COLOUR_L_GREEN, "p");
  text_out("' selects player. '");
  text_out_c(COLOUR_L_GREEN, "q");
  text_out("' exits. '");
  text_out_c(COLOUR_L_GREEN, "r");
  text_out("' displays details. '");
  if (free) {
    text_out_c(COLOUR_L_GREEN, "m");
    text_out("' restricts to interesting places.");
  } else {
    text_out_c(COLOUR_L_GREEN, "+");
    text_out("' and '");
    text_out_c(COLOUR_L_GREEN, "-");
    text_out("' cycle through places. '");
    text_out_c(COLOUR_L_GREEN, "o");
    text_out("' allows free selection.");
  }
  if (monster || free) {
    text_out(" '");
    text_out_c(COLOUR_L_GREEN, "t");
    text_out("' targets selection.");
  }
  if (object) {
    unsigned char key = cmd_lookup_key(CMD_IGNORE, mode);
    char label[3];
    if (KTRL(key) == key) {
      label[0] = '^';
      label[1] = UN_KTRL(key);
      label[2] = '\0';
    } else {
      label[0] = key;
      label[1] = '\0';
    }
    text_out(" '");
    text_out_c(COLOUR_L_GREEN, "%s", label);
    text_out("' ignores selection.");
  }
  text_out_indent = 0;
}
STATIC_OVL bool
is_running_keymap(struct keypress ch)
{
  int mode =
      (OPT(player, angband_keyset)) ? KEYMAP_MODE_ANGBAND : KEYMAP_MODE_ORIG;
  const struct keypress* act = keymap_find(mode, ch);
  if (OPT(player, hjkl_movement)) {
    mode |= KEYMAP_MODE_ROGUE;
  }
  if (act) {
    unsigned char run_key = cmd_lookup_key(CMD_RUN, mode);
    const struct keypress* cur;
    for (cur = act; cur->type == EVT_KBRD; cur++) {
      if ((unsigned char)cur->code == run_key) {
        return true;
      }
    }
  }
  return false;
}
STATIC_OVL bool
adjust_panel_help(struct loc grid, bool help)
{
  bool changed = false;
  int j;
  int screen_hgt_main = help ? (Term->hgt - ROW_MAP - ROW_BOTTOM_MAP - 2)
                             : (Term->hgt - ROW_MAP - ROW_BOTTOM_MAP);
  for (j = 0; j < ANGBAND_TERM_MAX; j++) {
    int wx, wy;
    int screen_hgt, screen_wid;
    term* t = angband_term[j];
    if (!t) continue;
    if ((j > 0) && !(window_flag[j] & PW_OVERHEAD)) continue;
    wy = t->offset_y;
    wx = t->offset_x;
    screen_hgt = (j == 0) ? screen_hgt_main : t->hgt;
    screen_wid = (j == 0) ? (Term->wid - COL_MAP - 1) : t->wid;
    screen_wid = screen_wid / tile_width;
    screen_hgt = screen_hgt / tile_height;
    while (grid.y >= wy + screen_hgt) wy += screen_hgt / 2;
    while (grid.y < wy) wy -= screen_hgt / 2;
    while (grid.x >= wx + screen_wid) wx += screen_wid / 2;
    while (grid.x < wx) wx -= screen_wid / 2;
    if (modify_panel(t, wy, wx)) changed = true;
  }
  return (changed);
}
STATIC_OVL ui_event
target_recall_loop_object(struct object* obj, int y, int x,
                          char out_val[TARGET_OUT_VAL_SIZE], const char* s1,
                          const char* s2, const char* s3, const char* coords,
                          const struct player* p)
{
  bool recall = false;
  ui_event press;
  while (1) {
    if (recall) {
      display_object_recall_interactive(cave->objects[obj->oidx]);
      press = inkey_m();
    } else {
      char o_name[80];
      object_desc(o_name, sizeof(o_name), cave->objects[obj->oidx],
                  ODESC_PREFIX | ODESC_FULL, p);
      if (p->wizard) {
        strnfmt(out_val, TARGET_OUT_VAL_SIZE,
                "%s%s%s%s, %s (%d:%d, noise=%d, scent=%d).", s1, s2, s3, o_name,
                coords, y, x, (int)cave->player_noise.grids[y][x],
                (int)cave->scent.grids[y][x]);
      } else {
        strnfmt(out_val, TARGET_OUT_VAL_SIZE, "%s%s%s%s, %s.", s1, s2, s3,
                o_name, coords);
      }
      prt(out_val, 0, 0);
      move_cursor_relative(y, x);
      press = inkey_m();
    }
    if ((press.type == EVT_MOUSE) && (press.mouse.button == 1) &&
        (KEY_GRID_X(press) == x) && (KEY_GRID_Y(press) == y))
      recall = !recall;
    else if ((press.type == EVT_KBRD) && (press.key.code == 'r'))
      recall = !recall;
    else
      break;
  }
  return press;
}
STATIC_OVL bool
aux_reinit(struct chunk* c, struct player* p, struct target_aux_state* auxst)
{
  struct monster* mon;
  auxst->press.type = EVT_KBRD;
  auxst->press.key.code = 'p';
  auxst->press.key.mods = 0;
  if (!square_in_bounds(c, auxst->grid)) return true;
  auxst->boring = true;
  if (square(c, auxst->grid)->mon < 0) {
    auxst->phrase1 = "You are ";
    auxst->phrase2 = "on ";
  } else {
    if (square_isseen(c, auxst->grid)) {
      auxst->phrase1 = "You see ";
    } else {
      mon = square_monster(c, auxst->grid);
      if (mon && monster_is_listened(mon)) {
        auxst->phrase1 = "You sense ";
      } else {
        auxst->phrase1 = "You recall ";
      }
    }
    auxst->phrase2 = "";
  }
  return false;
}
STATIC_OVL bool
aux_hallucinate(struct chunk* c, struct player* p,
                struct target_aux_state* auxst)
{
  const char* name_strange = "something strange";
  char out_val[TARGET_OUT_VAL_SIZE];
  if (!p->timed[TMD_IMAGE]) return false;
  if (p->wizard) {
    strnfmt(out_val, sizeof(out_val), "%s%s%s, %s (%d:%d, noise=%d, scent=%d).",
            auxst->phrase1, auxst->phrase2, name_strange, auxst->coord_desc,
            auxst->grid.y, auxst->grid.x,
            (int)c->player_noise.grids[auxst->grid.y][auxst->grid.x],
            (int)c->scent.grids[auxst->grid.y][auxst->grid.x]);
  } else {
    strnfmt(out_val, sizeof(out_val), "%s%s%s, %s.", auxst->phrase1,
            auxst->phrase2, name_strange, auxst->coord_desc);
  }
  prt(out_val, 0, 0);
  move_cursor_relative(auxst->grid.y, auxst->grid.x);
  auxst->press.key = inkey();
  return auxst->press.key.code != KC_ENTER;
}
STATIC_OVL bool
aux_monster(struct chunk* c, struct player* p, struct target_aux_state* auxst)
{
  struct monster* mon;
  const struct monster_lore* lore;
  char m_name[80];
  char out_val[TARGET_OUT_VAL_SIZE];
  bool recall;
  if (square(c, auxst->grid)->mon <= 0) return false;
  mon = square_monster(c, auxst->grid);
  if (!monster_is_visible(mon)) return false;
  lore = get_lore(mon->race);
  auxst->boring = false;
  if (p->timed[TMD_RAGE]) {
    my_strcpy(m_name, "an enemy", sizeof(m_name));
  } else {
    monster_desc(m_name, sizeof(m_name), mon, MDESC_IND_VIS);
  }
  monster_race_track(p->upkeep, mon->race);
  health_track(p->upkeep, mon);
  handle_stuff(p);
  recall = false;
  while (1) {
    if (recall && !p->timed[TMD_RAGE]) {
      lore_show_interactive(mon->race, lore);
      auxst->press = inkey_m();
    } else {
      char buf[80];
      look_mon_desc(buf, sizeof(buf), square(c, auxst->grid)->mon);
      if (p->wizard) {
        strnfmt(out_val, sizeof(out_val),
                "%s%s%s%s, %s (%d:%d, noise=%d, scent=%d).", auxst->phrase1,
                auxst->phrase2, m_name, buf, auxst->coord_desc, auxst->grid.y,
                auxst->grid.x,
                (int)c->player_noise.grids[auxst->grid.y][auxst->grid.x],
                (int)c->scent.grids[auxst->grid.y][auxst->grid.x]);
      } else {
        strnfmt(out_val, sizeof(out_val), "%s%s%s%s, %s.", auxst->phrase1,
                auxst->phrase2, m_name, buf, auxst->coord_desc);
      }
      prt(out_val, 0, 0);
      move_cursor_relative(auxst->grid.y, auxst->grid.x);
      auxst->press = inkey_m();
    }
    if (auxst->press.type == EVT_MOUSE && auxst->press.mouse.button == 1 &&
        KEY_GRID_X(auxst->press) == auxst->grid.x &&
        KEY_GRID_Y(auxst->press) == auxst->grid.y) {
      recall = !recall;
    } else if (auxst->press.type == EVT_KBRD && auxst->press.key.code == 'r') {
      recall = !recall;
    } else {
      break;
    }
  }
  if (auxst->press.type == EVT_MOUSE) {
    if (auxst->press.mouse.button == 2) return true;
    if (auxst->press.mouse.button && !(auxst->mode & (TARGET_LOOK)))
      return true;
  } else {
    if (auxst->press.key.code != KC_ENTER && auxst->press.key.code != ' ')
      return true;
    if (auxst->press.key.code == ' ' && !(auxst->mode & (TARGET_LOOK)))
      return true;
  }
  if (p->wizard) {
    const char* lphrase1;
    const char* lphrase2;
    struct object* obj;
    if (rf_has(mon->race->flags, RF_FEMALE)) {
      lphrase1 = "She is ";
    } else if (rf_has(mon->race->flags, RF_MALE)) {
      lphrase1 = "He is ";
    } else {
      lphrase1 = "It is ";
    }
    lphrase2 = "carrying ";
    for (obj = mon->held_obj; obj; obj = obj->next) {
      char o_name[80];
      object_desc(o_name, sizeof(o_name), obj, ODESC_PREFIX | ODESC_FULL, p);
      strnfmt(out_val, sizeof(out_val),
              "%s%s%s, %s (%d:%d, noise=%d, scent=%d).", lphrase1, lphrase2,
              o_name, auxst->coord_desc, auxst->grid.y, auxst->grid.x,
              (int)c->player_noise.grids[auxst->grid.y][auxst->grid.x],
              (int)c->scent.grids[auxst->grid.y][auxst->grid.x]);
      prt(out_val, 0, 0);
      move_cursor_relative(auxst->grid.y, auxst->grid.x);
      auxst->press = inkey_m();
      if (auxst->press.type == EVT_MOUSE) {
        if (auxst->press.mouse.button == 2) break;
        if (auxst->press.mouse.button && !(auxst->mode & (TARGET_LOOK))) break;
      } else {
        if (auxst->press.key.code != KC_ENTER && auxst->press.key.code != ' ')
          break;
        if (auxst->press.key.code == ' ' && !(auxst->mode & (TARGET_LOOK)))
          break;
      }
      lphrase2 = "also carrying ";
    }
    if (obj) return true;
  }
  return false;
}
STATIC_OVL bool
aux_trap(struct chunk* c, struct player* p, struct target_aux_state* auxst)
{
  struct trap* trap;
  char out_val[TARGET_OUT_VAL_SIZE];
  const char* lphrase3;
  if (!square_isvisibletrap(p->cave, auxst->grid)) return false;
  if (square_isforge(p->cave, auxst->grid)) return false;
  trap = square(p->cave, auxst->grid)->trap;
  auxst->boring = false;
  lphrase3 = (is_a_vowel(trap->kind->desc[0])) ? "an " : "a ";
  while (1) {
    if (p->wizard) {
      strnfmt(out_val, sizeof(out_val),
              "%s%s%s%s, %s (%d:%d, noise=%d, scent=%d).", auxst->phrase1,
              auxst->phrase2, lphrase3, trap->kind->name, auxst->coord_desc,
              auxst->grid.y, auxst->grid.x,
              (int)c->player_noise.grids[auxst->grid.y][auxst->grid.x],
              (int)c->scent.grids[auxst->grid.y][auxst->grid.x]);
    } else {
      strnfmt(out_val, sizeof(out_val), "%s%s%s%s, %s.", auxst->phrase1,
              auxst->phrase2, lphrase3, trap->kind->desc, auxst->coord_desc);
    }
    prt(out_val, 0, 0);
    move_cursor_relative(auxst->grid.y, auxst->grid.x);
    auxst->press = inkey_m();
    if (auxst->press.key.code != KC_ENTER && auxst->press.key.code != ' ')
      break;
    if (auxst->press.key.code == ' ' && !(auxst->mode & (TARGET_LOOK))) break;
  }
  return true;
}
STATIC_OVL bool
aux_object(struct chunk* c, struct player* p, struct target_aux_state* auxst)
{
  int floor_max = z_info->floor_size;
  struct object** floor_list = mem_zalloc(floor_max * sizeof(*floor_list));
  bool result = false;
  char out_val[TARGET_OUT_VAL_SIZE];
  int floor_num;
  floor_num = scan_distant_floor(floor_list, floor_max, p, auxst->grid);
  if (floor_num <= 0) {
    mem_free(floor_list);
    return result;
  }
  auxst->boring = false;
  track_object(p->upkeep, floor_list[0]);
  handle_stuff(p);
  if (floor_num > 1) {
    while (1) {
      if (p->wizard) {
        strnfmt(out_val, sizeof(out_val),
                "%s%sa pile of %d objects, %s (%d:%d, noise=%d, scent=%d).",
                auxst->phrase1, auxst->phrase2, floor_num, auxst->coord_desc,
                auxst->grid.y, auxst->grid.x,
                (int)c->player_noise.grids[auxst->grid.y][auxst->grid.x],
                (int)c->scent.grids[auxst->grid.y][auxst->grid.x]);
      } else {
        strnfmt(out_val, sizeof(out_val), "%s%sa pile of %d objects, %s.",
                auxst->phrase1, auxst->phrase2, floor_num, auxst->coord_desc);
      }
      prt(out_val, 0, 0);
      move_cursor_relative(auxst->grid.y, auxst->grid.x);
      auxst->press = inkey_m();
      if ((auxst->press.type == EVT_MOUSE && auxst->press.mouse.button == 1 &&
           KEY_GRID_X(auxst->press) == auxst->grid.x &&
           KEY_GRID_Y(auxst->press) == auxst->grid.y) ||
          (auxst->press.type == EVT_KBRD && auxst->press.key.code == 'r')) {
        int pos;
        while (1) {
          screen_save();
          show_floor(floor_list, floor_num, (OLIST_DEATH | OLIST_WEIGHT), NULL);
          prt(out_val, 0, 0);
          auxst->press = inkey_m();
          screen_load();
          if (auxst->press.type == EVT_MOUSE) {
            pos = auxst->press.mouse.y - 1;
          } else {
            pos = auxst->press.key.code - 'a';
          }
          if (0 <= pos && pos < floor_num) {
            track_object(p->upkeep, floor_list[pos]);
            handle_stuff(p);
            continue;
          }
          break;
        }
        continue;
      }
      break;
    }
  } else {
    struct object* obj_local = floor_list[0];
    auxst->press = target_recall_loop_object(
        obj_local, auxst->grid.y, auxst->grid.x, out_val, auxst->phrase1,
        auxst->phrase2, "", auxst->coord_desc, p);
    if (auxst->press.key.code != KC_ENTER && auxst->press.key.code != ' ')
      result = true;
    if (auxst->press.key.code == ' ' && !(auxst->mode & (TARGET_LOOK)))
      result = true;
  }
  mem_free(floor_list);
  return result;
}
STATIC_OVL bool
aux_terrain(struct chunk* c, struct player* p, struct target_aux_state* auxst)
{
  const char *lphrase2, *lphrase3;
  char name[50];
  char out_val[TARGET_OUT_VAL_SIZE];
  if (!auxst->boring && !square_isinteresting(p->cave, auxst->grid))
    return false;
  square_apparent_name(p->cave, auxst->grid, name, sizeof(name));
  lphrase2 = (*auxst->phrase2)
                 ? square_apparent_look_in_preposition(p->cave, auxst->grid)
                 : "";
  lphrase3 = square_apparent_look_prefix(p->cave, auxst->grid);
  if (p->wizard) {
    strnfmt(out_val, sizeof(out_val),
            "%s%s%s%s, %s (%d:%d, noise=%d, scent=%d).", auxst->phrase1,
            lphrase2, lphrase3, name, auxst->coord_desc, auxst->grid.y,
            auxst->grid.x,
            (int)c->player_noise.grids[auxst->grid.y][auxst->grid.x],
            (int)c->scent.grids[auxst->grid.y][auxst->grid.x]);
  } else {
    strnfmt(out_val, sizeof(out_val), "%s%s%s%s, %s.", auxst->phrase1, lphrase2,
            lphrase3, name, auxst->coord_desc);
  }
  prt(out_val, 0, 0);
  move_cursor_relative(auxst->grid.y, auxst->grid.x);
  auxst->press = inkey_m();
  return (auxst->press.type == EVT_MOUSE && auxst->press.mouse.button == 2) ||
         (auxst->press.type != EVT_MOUSE && auxst->press.key.code != KC_ENTER &&
          auxst->press.key.code != ' ');
}
STATIC_OVL bool
aux_wrapup(struct chunk* c, struct player* p, struct target_aux_state* auxst)
{
  if (auxst->press.type == EVT_MOUSE) {
    return auxst->press.mouse.button != 2;
  }
  return auxst->press.key.code != KC_ENTER;
}
STATIC_OVL ui_event
target_set_interactive_aux(struct loc grid, int mode)
{
  target_aux_handler handlers[] = {aux_reinit, aux_hallucinate, aux_monster,
                                   aux_trap,   aux_object,      aux_terrain,
                                   aux_wrapup};
  struct target_aux_state auxst;
  int ihandler;
  auxst.mode = mode;
  auxst.grid = grid;
  coords_desc(auxst.coord_desc, sizeof(auxst.coord_desc), grid);
  ihandler = 0;
  while (1) {
    if ((*handlers[ihandler])(cave, player, &auxst)) break;
    ++ihandler;
    if (ihandler >= (int)N_ELEMENTS(handlers)) ihandler = 0;
  }
  return auxst.press;
}
STATIC_OVL void
textui_target(void)
{
  if (target_set_interactive(TARGET_KILL, loc(-1, -1), 0))
    msg("Target Selected.");
  else
    msg("Target Aborted.");
}
STATIC_OVL void
textui_target_closest(void)
{
  if (target_set_closest(TARGET_KILL, NULL)) {
    bool visibility;
    struct loc target;
    target_get(&target);
    Term_fresh();
    Term_get_cursor(&visibility);
    (void)Term_set_cursor(true);
    move_cursor_relative(target.y, target.x);
    Term_xtra(TERM_XTRA_DELAY, 150);
    (void)Term_set_cursor(visibility);
  }
}
STATIC_OVL int
draw_path(uint16_t path_n, struct loc* path_g, wchar_t* c, int* a,
          struct loc grid1)
{
  int i;
  bool on_screen;
  bool pastknown = false;
  if (path_n < 1) return 0;
  on_screen = panel_contains(grid1.y, grid1.x);
  for (i = 0; i < path_n; i++) {
    uint8_t colour;
    struct loc grid = path_g[i];
    struct monster* mon = square_monster(cave, grid);
    struct object* obj = square_object(player->cave, grid);
    if (panel_contains(grid.y, grid.x))
      on_screen = true;
    else if (on_screen)
      break;
    else
      continue;
    move_cursor_relative(grid.y, grid.x);
    Term_what(Term->scr->cx, Term->scr->cy, a + i, c + i);
    if (pastknown) {
      colour = COLOUR_L_DARK;
    } else if (mon && monster_is_visible(mon)) {
      colour = COLOUR_L_RED;
    } else if (obj)
      colour = COLOUR_YELLOW;
    else if (!square_isprojectable(player->cave, grid) &&
             (square_isknown(cave, grid) || square_isseen(cave, grid)))
      colour = COLOUR_BLUE;
    else if (!square_isknown(cave, grid) && !square_isseen(cave, grid)) {
      pastknown = true;
      colour = COLOUR_L_DARK;
    } else
      colour = COLOUR_WHITE;
    (void)Term_addch(colour, L'*');
  }
  return i;
}
STATIC_OVL void
load_path(uint16_t path_n, struct loc* path_g, wchar_t* c, int* a)
{
  int i;
  for (i = 0; i < path_n; i++) {
    int y = path_g[i].y;
    int x = path_g[i].x;
    if (!panel_contains(y, x)) continue;
    move_cursor_relative(y, x);
    Term_addch(a[i], c[i]);
  }
  Term_fresh();
}
STATIC_OVL bool
pile_is_tracked(const struct object* obj)
{
  for (const struct object* o = obj; o != NULL; o = o->next) {
    if (player->upkeep->object == o) {
      return true;
    }
  }
  return false;
}
STATIC_OVL bool
pile_has_known(const struct object* obj)
{
  for (const struct object* o = obj; o != NULL; o = o->next) {
    struct object* base_obj = cave->objects[o->oidx];
    if (base_obj->known) {
      return true;
    }
  }
  return false;
}
STATIC_OVL bool
target_set_interactive(int mode, struct loc grid, int range)
{
  int path_n;
  struct loc path_g[256];
  int wid, hgt, help_prompt_loc;
  int adjusted_range = range ? range : z_info->max_range;
  int key_mode =
      OPT(player, angband_keyset) ? KEYMAP_MODE_ANGBAND : KEYMAP_MODE_ORIG;
  bool done = false;
  bool show_interesting = true;
  bool help = false;
  keycode_t ignore_key;
  wchar_t* path_char = mem_zalloc(adjusted_range * sizeof(wchar_t));
  int* path_attr = mem_zalloc(adjusted_range * sizeof(int));
  if (OPT(player, hjkl_movement)) {
    key_mode |= KEYMAP_MODE_ROGUE;
  }
  ignore_key = cmd_lookup_key(CMD_IGNORE, key_mode);
  if (!square_in_bounds_fully(cave, grid)) {
    grid = player->grid;
  } else {
    show_interesting = false;
  }
  target_set_monster(0);
  disallow_animations();
  Term_get_size(&wid, &hgt);
  help_prompt_loc = hgt - 1;
  prt("Press '?' for help.", help_prompt_loc, 0);
  struct point_set* targets = target_get_monsters(mode, NULL, true);
  int target_index = 0;
  while (!done) {
    bool path_drawn = false;
    bool use_interesting_mode = show_interesting && point_set_size(targets);
    bool use_free_mode = !use_interesting_mode;
    if (use_interesting_mode) {
      grid = targets->pts[target_index];
      if (adjust_panel_help(grid, help)) handle_stuff(player);
    }
    if (help) {
      bool has_target = target_able(square_monster(cave, grid));
      bool has_object =
          !(mode & TARGET_KILL) && pile_has_known(square_object(cave, grid));
      target_display_help(has_target, has_object, use_free_mode);
    }
    path_n = ABS(project_path(cave, path_g, adjusted_range, player->grid, &grid,
                              PROJECT_THRU | PROJECT_INFO | PROJECT_LEAVE));
    if (mode & (TARGET_KILL))
      path_drawn =
          draw_path(path_n, path_g, path_char, path_attr, player->grid);
    ui_event press = target_set_interactive_aux(
        grid, mode | (use_free_mode ? TARGET_LOOK : 0));
    if (path_drawn) load_path(path_n, path_g, path_char, path_attr);
    if (event_is_mouse_m(press, 2, KC_MOD_CONTROL) ||
        event_is_mouse(press, 3)) {
      grid = KEY_GRID(press);
      if (use_free_mode) {
        target_set_location(grid);
        done = true;
      } else {
        struct monster* m_local = square_monster(cave, grid);
        if (target_able(m_local)) {
          target_set_monster(m_local);
          done = true;
        } else {
          bell();
          if (!square_in_bounds(cave, grid)) {
            grid = player->grid;
          }
        }
      }
    } else if (event_is_mouse_m(press, 2, KC_MOD_ALT)) {
      grid = KEY_GRID(press);
      cmdq_push(CMD_PATHFIND);
      cmd_set_arg_point(cmdq_peek(), "point", grid);
      done = true;
    } else if (event_is_mouse(press, 2)) {
      if (use_free_mode && (mode & TARGET_KILL) &&
          loc_eq(grid, KEY_GRID(press))) {
        target_set_location(grid);
      }
      done = true;
    } else if (event_is_mouse(press, 1)) {
      grid = KEY_GRID(press);
      if (press.mouse.y <= 1) {
        grid.y--;
      } else if (press.mouse.y >= Term->hgt - 2) {
        grid.y++;
      } else if (press.mouse.x <= COL_MAP) {
        grid.x--;
      } else if (press.mouse.x >= Term->wid - 2) {
        grid.x++;
      }
      grid.x = MAX(0, MIN(grid.x, cave->width - 1));
      grid.y = MAX(0, MIN(grid.y, cave->height - 1));
      if (adjust_panel_help(grid, help)) {
        handle_stuff(player);
        point_set_dispose(targets);
        targets = target_get_monsters(mode, NULL, true);
      }
      show_interesting = false;
      for (int i = 0; i < point_set_size(targets); i++) {
        if (loc_eq(grid, targets->pts[i])) {
          target_index = i;
          show_interesting = true;
          break;
        }
      }
    } else if (event_is_key(press, ESCAPE) || event_is_key(press, 'q')) {
      done = true;
    } else if (event_is_key(press, ' ') || event_is_key(press, '*') ||
               event_is_key(press, '+')) {
      if (use_interesting_mode && ++target_index == point_set_size(targets)) {
        target_index = 0;
      }
    } else if (event_is_key(press, '-')) {
      if (use_interesting_mode && target_index-- == 0) {
        target_index = point_set_size(targets) - 1;
      }
    } else if (event_is_key(press, 'p')) {
      grid = player->grid;
      show_interesting = false;
      verify_panel();
      handle_stuff(player);
    } else if (event_is_key(press, 'o')) {
      show_interesting = false;
    } else if (event_is_key(press, 'm')) {
      if (use_free_mode && point_set_size(targets) > 0) {
        show_interesting = true;
        target_index = 0;
        int min_dist = 999;
        for (int i = 0; i < point_set_size(targets); i++) {
          int dist = distance(grid, targets->pts[i]);
          if (dist < min_dist) {
            target_index = i;
            min_dist = dist;
          }
        }
      }
    } else if (event_is_key(press, 't') || event_is_key(press, '5') ||
               event_is_key(press, '0') || event_is_key(press, '.')) {
      if (use_interesting_mode) {
        struct monster* m_local = square_monster(cave, grid);
        if (target_able(m_local)) {
          target_set_monster(m_local);
          done = true;
        } else {
          bell();
        }
      } else {
        target_set_location(grid);
        done = true;
      }
    } else if (event_is_key(press, 'g')) {
      cmdq_push(CMD_PATHFIND);
      cmd_set_arg_point(cmdq_peek(), "point", grid);
      done = true;
    } else if (event_is_key(press, ignore_key)) {
      if (!(mode & TARGET_KILL) && pile_is_tracked(square_object(cave, grid))) {
        textui_cmd_ignore_menu(player->upkeep->object);
        handle_stuff(player);
        point_set_dispose(targets);
        targets = target_get_monsters(mode, NULL, true);
      }
    } else if (event_is_key(press, '?')) {
      help = !help;
      player->upkeep->redraw |= (PR_BASIC | PR_EXTRA | PR_MAP | PR_EQUIP);
      Term_clear();
      handle_stuff(player);
      if (!help) prt("Press '?' for help.", help_prompt_loc, 0);
    } else {
      int dir = target_dir(press.key);
      if (!dir) {
        bell();
      } else if (use_interesting_mode) {
        int old_y = targets->pts[target_index].y;
        int old_x = targets->pts[target_index].x;
        int new_index;
        new_index = target_pick(old_y, old_x, ddy[dir], ddx[dir], targets);
        if (new_index < 0) {
          int old_wy = Term->offset_y;
          int old_wx = Term->offset_x;
          if (change_panel(dir)) {
            point_set_dispose(targets);
            targets = target_get_monsters(mode, NULL, true);
            new_index = target_pick(old_y, old_x, ddy[dir], ddx[dir], targets);
            if (new_index < 0 && modify_panel(Term, old_wy, old_wx)) {
              point_set_dispose(targets);
              targets = target_get_monsters(mode, NULL, true);
            }
            handle_stuff(player);
          }
        }
        if (new_index >= 0) target_index = new_index;
      } else {
        int step = (is_running_keymap(press.key)) ? 10 : 1;
        grid.x += step * ddx[dir];
        grid.y += step * ddy[dir];
        grid.x = MAX(1, MIN(grid.x, cave->width - 2));
        grid.y = MAX(1, MIN(grid.y, cave->height - 2));
        if (adjust_panel_help(grid, help)) {
          handle_stuff(player);
          point_set_dispose(targets);
          targets = target_get_monsters(mode, NULL, true);
        }
      }
    }
  }
  point_set_dispose(targets);
  if (help) {
    player->upkeep->redraw |= (PR_BASIC | PR_EXTRA | PR_MAP | PR_EQUIP);
    Term_clear();
  } else {
    prt("", 0, 0);
    prt("", help_prompt_loc, 0);
    player->upkeep->redraw |= (PR_DEPTH | PR_STATUS);
  }
  verify_panel();
  handle_stuff(player);
  mem_free(path_attr);
  mem_free(path_char);
  allow_animations();
  return target_is_set();
}
STATIC_OVL errr
term_win_nuke(term_win* s)
{
  mem_free_alt(s->a);
  mem_free_alt(s->c);
  mem_free_alt(s->va);
  mem_free_alt(s->vc);
  mem_free_alt(s->ta);
  mem_free_alt(s->tc);
  mem_free_alt(s->vta);
  mem_free_alt(s->vtc);
  return (0);
}
STATIC_OVL errr
term_win_init(term_win* s, int w, int h)
{
  int y;
  s->a = mem_zalloc_alt(h * sizeof(int*));
  s->c = mem_zalloc_alt(h * sizeof(wchar_t*));
  s->va = mem_zalloc_alt(h * w * sizeof(int));
  s->vc = mem_zalloc_alt(h * w * sizeof(wchar_t));
  s->ta = mem_zalloc_alt(h * sizeof(int*));
  s->tc = mem_zalloc_alt(h * sizeof(wchar_t*));
  s->vta = mem_zalloc_alt(h * w * sizeof(int));
  s->vtc = mem_zalloc_alt(h * w * sizeof(wchar_t));
  for (y = 0; y < h; y++) {
    s->a[y] = s->va + w * y;
    s->c[y] = s->vc + w * y;
    s->ta[y] = s->vta + w * y;
    s->tc[y] = s->vtc + w * y;
  }
  return (0);
}
STATIC_OVL errr
term_win_copy(term_win* s, term_win* f, int w, int h)
{
  int x, y;
  for (y = 0; y < h; y++) {
    int* f_aa = f->a[y];
    wchar_t* f_cc = f->c[y];
    int* s_aa = s->a[y];
    wchar_t* s_cc = s->c[y];
    int* f_taa = f->ta[y];
    wchar_t* f_tcc = f->tc[y];
    int* s_taa = s->ta[y];
    wchar_t* s_tcc = s->tc[y];
    for (x = 0; x < w; x++) {
      *s_aa++ = *f_aa++;
      *s_cc++ = *f_cc++;
      *s_taa++ = *f_taa++;
      *s_tcc++ = *f_tcc++;
    }
  }
  s->cnx = f->cnx;
  s->cny = f->cny;
  s->cx = f->cx;
  s->cy = f->cy;
  s->cu = f->cu;
  s->cv = f->cv;
  return (0);
}
STATIC_OVL extern errr
Term_redraw_all(void)
{
  term* old = Term;
  errr combined = 0;
  int j;
  for (j = 0; j < ANGBAND_TERM_MAX; j++) {
    errr one_result;
    if (!angband_term[j]) continue;
    (void)Term_activate(angband_term[j]);
    one_result = Term_redraw();
    if (!one_result) {
      combined = one_result;
    }
  }
  (void)Term_activate(old);
  return combined;
}
STATIC_OVL errr
Term_xtra(int n, int v)
{
  if (!Term->xtra_hook) return (-1);
  return ((*Term->xtra_hook)(n, v));
}
STATIC_OVL errr
Term_curs_hack(int x, int y)
{
  if (x || y) return (-2);
  return (-1);
}
STATIC_OVL errr
Term_wipe_hack(int x, int y, int n)
{
  if (x || y || n) return (-2);
  return (-1);
}
STATIC_OVL errr
Term_text_hack(int x, int y, int n, int a, const wchar_t* cp)
{
  if (x || y || n || a || cp) return (-2);
  return (-1);
}
STATIC_OVL errr
Term_pict_hack(int x, int y, int n, const int* ap, const wchar_t* cp,
               const int* tap, const wchar_t* tcp)
{
  if (x || y || n || ap || cp || tap || tcp) return (-2);
  return (-1);
}
STATIC_OVL void
Term_queue_char(term* t, int x, int y, int a, wchar_t c, int ta, wchar_t tc)
{
  int* scr_aa = t->scr->a[y];
  wchar_t* scr_cc = t->scr->c[y];
  int oa = scr_aa[x];
  wchar_t oc = scr_cc[x];
  int* scr_taa = t->scr->ta[y];
  wchar_t* scr_tcc = t->scr->tc[y];
  int ota = scr_taa[x];
  wchar_t otc = scr_tcc[x];
  if (!ta) ta = ota;
  if (!tc) tc = otc;
  if ((oa == a) && (oc == c) && (ota == ta) && (otc == tc)) return;
  scr_aa[x] = a;
  scr_cc[x] = c;
  scr_taa[x] = ta;
  scr_tcc[x] = tc;
  if (y < t->y1) t->y1 = y;
  if (y > t->y2) t->y2 = y;
  if (x < t->x1[y]) t->x1[y] = x;
  if (x > t->x2[y]) t->x2[y] = x;
  if (t->dblh_hook) {
    if (y >= tile_height) {
      int ofg_dbl = (*t->dblh_hook)(oa, oc);
      int obg_dbl = (*t->dblh_hook)(ota, otc);
      if (ofg_dbl || obg_dbl) {
        int yp = y - tile_height;
        if (yp < t->y1) t->y1 = yp;
        if (x < t->x1[yp]) t->x1[yp] = x;
        if (x > t->x2[yp]) t->x2[yp] = x;
      }
    }
    if (y < t->hgt - tile_height) {
      int yn = y + tile_height;
      int ofg_dbl_nr = (*t->dblh_hook)(t->old->a[yn][x], t->old->c[yn][x]);
      int obg_dbl_nr = (*t->dblh_hook)(t->old->ta[yn][x], t->old->tc[yn][x]);
      if (ofg_dbl_nr || obg_dbl_nr) {
        if (yn > t->y2) t->y2 = yn;
        if (x < t->x1[yn]) t->x1[yn] = x;
        if (x > t->x2[yn]) t->x2[yn] = x;
      }
    }
  }
}
STATIC_OVL void
Term_big_queue_char(term* t, int x, int y, int clipy, int a, wchar_t c, int a1,
                    wchar_t c1)
{
  int vmax;
  int hor, vert;
  (void)c;
  vmax = (y + tile_height <= clipy) ? tile_height : clipy - y;
  if (tile_width > 1) {
    for (hor = 1; hor < tile_width; hor++) {
      if (a & 0x80)
        Term_queue_char(t, x + hor, y, 255, -1, 0, 0);
      else
        Term_queue_char(t, x + hor, y, COLOUR_WHITE, L' ', a1, c1);
    }
    for (vert = 1; vert < vmax; vert++) {
      for (hor = 0; hor < tile_width; hor++) {
        if (a & 0x80)
          Term_queue_char(t, x + hor, y + vert, 255, -1, 0, 0);
        else
          Term_queue_char(t, x + hor, y + vert, COLOUR_WHITE, L' ', a1, c1);
      }
    }
  } else {
    for (vert = 1; vert < vmax; vert++) {
      if (a & 0x80)
        Term_queue_char(t, x, y + vert, 255, -1, 0, 0);
      else
        Term_queue_char(t, x, y + vert, COLOUR_WHITE, L' ', a1, c1);
    }
  }
}
STATIC_OVL void
Term_queue_chars(int x, int y, int n, int a, const wchar_t* s)
{
  int x1 = -1, x2 = -1;
  int* scr_aa = Term->scr->a[y];
  wchar_t* scr_cc = Term->scr->c[y];
  int* scr_taa = Term->scr->ta[y];
  wchar_t* scr_tcc = Term->scr->tc[y];
  for (; n; x++, s++, n--) {
    int oa = scr_aa[x];
    wchar_t oc = scr_cc[x];
    int ota = scr_taa[x];
    wchar_t otc = scr_tcc[x];
    if ((oa == a) && (oc == *s) && (ota == 0) && (otc == 0)) continue;
    scr_aa[x] = a;
    scr_cc[x] = *s;
    scr_taa[x] = 0;
    scr_tcc[x] = 0;
    if (x1 < 0) x1 = x;
    x2 = x;
  }
  if (x1 >= 0) {
    if (y < Term->y1) Term->y1 = y;
    if (y > Term->y2) Term->y2 = y;
    if (x1 < Term->x1[y]) Term->x1[y] = x1;
    if (x2 > Term->x2[y]) Term->x2[y] = x2;
  }
}
STATIC_OVL void
Term_fresh_row_pict(int y, int x1, int x2)
{
  int x;
  int* old_aa = Term->old->a[y];
  wchar_t* old_cc = Term->old->c[y];
  int* scr_aa = Term->scr->a[y];
  wchar_t* scr_cc = Term->scr->c[y];
  int* old_taa = Term->old->ta[y];
  wchar_t* old_tcc = Term->old->tc[y];
  int* scr_taa = Term->scr->ta[y];
  wchar_t* scr_tcc = Term->scr->tc[y];
  int ota;
  wchar_t otc;
  int nta;
  wchar_t ntc;
  int fn = 0;
  int fx = 0;
  int oa;
  wchar_t oc;
  int na;
  wchar_t nc;
  for (x = x1; x <= x2; x++) {
    oa = old_aa[x];
    oc = old_cc[x];
    na = scr_aa[x];
    nc = scr_cc[x];
    ota = old_taa[x];
    otc = old_tcc[x];
    nta = scr_taa[x];
    ntc = scr_tcc[x];
    if ((na == oa) && (nc == oc) && (nta == ota) && (ntc == otc)) {
      if (fn) {
        (void)((*Term->pict_hook)(fx, y, fn, &scr_aa[fx], &scr_cc[fx],
                                  &scr_taa[fx], &scr_tcc[fx]));
        fn = 0;
      }
      continue;
    }
    old_aa[x] = na;
    old_cc[x] = nc;
    old_taa[x] = nta;
    old_tcc[x] = ntc;
    if (fn++ == 0) fx = x;
  }
  if (fn) {
    (void)((*Term->pict_hook)(fx, y, fn, &scr_aa[fx], &scr_cc[fx], &scr_taa[fx],
                              &scr_tcc[fx]));
  }
}
STATIC_OVL void
Term_fresh_row_pict_dblh(int y, int x1, int x2, int* pr_drw)
{
  int x;
  int* old_aa = Term->old->a[y];
  wchar_t* old_cc = Term->old->c[y];
  const int* scr_aa = Term->scr->a[y];
  const wchar_t* scr_cc = Term->scr->c[y];
  int* old_taa = Term->old->ta[y];
  wchar_t* old_tcc = Term->old->tc[y];
  const int* scr_taa = Term->scr->ta[y];
  const wchar_t* scr_tcc = Term->scr->tc[y];
  const int* scr_aa_nr;
  const wchar_t* scr_cc_nr;
  const int* scr_taa_nr;
  const wchar_t* scr_tcc_nr;
  const int* old_aa_nr;
  const wchar_t* old_cc_nr;
  const int* old_taa_nr;
  const wchar_t* old_tcc_nr;
  int fn = 0;
  int fx = 0;
  if (y < Term->hgt - tile_height) {
    scr_aa_nr = Term->scr->a[y + tile_height];
    scr_cc_nr = Term->scr->c[y + tile_height];
    scr_taa_nr = Term->scr->ta[y + tile_height];
    scr_tcc_nr = Term->scr->tc[y + tile_height];
    old_aa_nr = Term->old->a[y + tile_height];
    old_cc_nr = Term->old->c[y + tile_height];
    old_taa_nr = Term->old->ta[y + tile_height];
    old_tcc_nr = Term->old->tc[y + tile_height];
  } else {
    scr_aa_nr = scr_aa;
    scr_cc_nr = scr_cc;
    scr_taa_nr = scr_taa;
    scr_tcc_nr = scr_tcc;
    old_aa_nr = scr_aa_nr;
    old_cc_nr = scr_cc_nr;
    old_taa_nr = scr_taa_nr;
    old_tcc_nr = scr_tcc_nr;
  }
  for (x = 0; x < x1; x++) {
    pr_drw[x] = 0;
  }
  for (x = x1; x <= x2; x++) {
    int oa = old_aa[x];
    wchar_t oc = old_cc[x];
    int ota = old_taa[x];
    wchar_t otc = old_tcc[x];
    int na = scr_aa[x];
    wchar_t nc = scr_cc[x];
    int nta = scr_taa[x];
    wchar_t ntc = scr_tcc[x];
    int draw;
    if (na == oa && nc == oc && nta == ota && ntc == otc) {
      if (pr_drw[x] &&
          ((*Term->dblh_hook)(na, nc) || (*Term->dblh_hook)(nta, ntc))) {
        draw = 1;
      } else {
        int oa_nr = old_aa_nr[x];
        wchar_t oc_nr = old_cc_nr[x];
        int ota_nr = old_taa_nr[x];
        wchar_t otc_nr = old_tcc_nr[x];
        int na_nr = scr_aa_nr[x];
        wchar_t nc_nr = scr_cc_nr[x];
        int nta_nr = scr_taa_nr[x];
        wchar_t ntc_nr = scr_tcc_nr[x];
        if (((*Term->dblh_hook)(oa_nr, oc_nr) ||
             (*Term->dblh_hook)(ota_nr, otc_nr)) &&
            (na_nr != oa_nr || nc_nr != oc_nr || nta_nr != ota_nr ||
             ntc_nr != otc_nr)) {
          draw = 1;
        } else {
          draw = 0;
        }
      }
      pr_drw[x] = draw;
    } else {
      draw = 1;
      pr_drw[x] = 1;
    }
    if (!draw) {
      if (fn) {
        (void)((*Term->pict_hook)(fx, y, fn, &scr_aa[fx], &scr_cc[fx],
                                  &scr_taa[fx], &scr_tcc[fx]));
        fn = 0;
      }
      continue;
    }
    old_aa[x] = na;
    old_cc[x] = nc;
    old_taa[x] = nta;
    old_tcc[x] = ntc;
    if (fn++ == 0) fx = x;
  }
  if (fn) {
    (void)((*Term->pict_hook)(fx, y, fn, &scr_aa[fx], &scr_cc[fx], &scr_taa[fx],
                              &scr_tcc[fx]));
  }
  for (x = x2 + 1; x < Term->wid; x++) {
    pr_drw[x] = 0;
  }
}
STATIC_OVL int
is_padding_changed(term* t, int y, int x)
{
  int xsl = MIN(x + tile_width, t->wid);
  int ysl = MIN(y + tile_height, t->hgt);
  int xs, ys;
  for (xs = x + 1; xs < xsl; ++xs) {
    if (t->scr->a[y][xs] == 255 && (t->scr->a[y][xs] != t->old->a[y][xs] ||
                                    t->scr->c[y][xs] != t->old->c[y][xs] ||
                                    t->scr->ta[y][xs] != t->old->ta[y][xs] ||
                                    t->scr->tc[y][xs] != t->old->tc[y][xs])) {
      return 1;
    }
  }
  for (ys = y + 1; ys < ysl; ++ys) {
    for (xs = x; xs < xsl; ++xs) {
      if (t->scr->a[ys][xs] == 255 &&
          (t->scr->a[ys][xs] != t->old->a[ys][xs] ||
           t->scr->c[ys][xs] != t->old->c[ys][xs] ||
           t->scr->ta[ys][xs] != t->old->ta[ys][xs] ||
           t->scr->tc[ys][xs] != t->old->tc[ys][xs])) {
        return 1;
      }
    }
  }
  return 0;
}
STATIC_OVL void
Term_fresh_row_both(int y, int x1, int x2)
{
  int x;
  int* old_aa = Term->old->a[y];
  wchar_t* old_cc = Term->old->c[y];
  int* scr_aa = Term->scr->a[y];
  wchar_t* scr_cc = Term->scr->c[y];
  int* old_taa = Term->old->ta[y];
  wchar_t* old_tcc = Term->old->tc[y];
  int* scr_taa = Term->scr->ta[y];
  wchar_t* scr_tcc = Term->scr->tc[y];
  int ota;
  wchar_t otc;
  int nta;
  wchar_t ntc;
  int always_text = Term->always_text;
  int fn = 0;
  int fx = 0;
  int fa = COLOUR_WHITE;
  int oa;
  wchar_t oc;
  int na;
  wchar_t nc;
  for (x = x1; x <= x2; x++) {
    oa = old_aa[x];
    oc = old_cc[x];
    na = scr_aa[x];
    nc = scr_cc[x];
    ota = old_taa[x];
    otc = old_tcc[x];
    nta = scr_taa[x];
    ntc = scr_tcc[x];
    if ((na == oa) && (nc == oc) && (nta == ota) && (ntc == otc)) {
      int draw;
      if ((na & 0x80) && na != 255) {
        draw = is_padding_changed(Term, y, x);
      } else {
        draw = 0;
      }
      if (fn) {
        if (fa || always_text)
          (void)((*Term->text_hook)(fx, y, fn, fa, &scr_cc[fx]));
        else
          (void)((*Term->wipe_hook)(fx, y, fn));
        fn = 0;
      }
      if (draw) {
        (void)((*Term->pict_hook)(x, y, 1, &na, &nc, &nta, &ntc));
      }
      continue;
    }
    old_aa[x] = na;
    old_cc[x] = nc;
    old_taa[x] = nta;
    old_tcc[x] = ntc;
    if ((na & 0x80)) {
      if (fn) {
        if (fa || always_text)
          (void)((*Term->text_hook)(fx, y, fn, fa, &scr_cc[fx]));
        else
          (void)((*Term->wipe_hook)(fx, y, fn));
        fn = 0;
      }
      if (na == 255) continue;
      (void)((*Term->pict_hook)(x, y, 1, &na, &nc, &nta, &ntc));
      continue;
    }
    if (fa != na) {
      if (fn) {
        if (fa || always_text)
          (void)((*Term->text_hook)(fx, y, fn, fa, &scr_cc[fx]));
        else
          (void)((*Term->wipe_hook)(fx, y, fn));
        fn = 0;
      }
      fa = na;
    }
    if (fn++ == 0) fx = x;
  }
  if (fn) {
    if (fa || always_text)
      (void)((*Term->text_hook)(fx, y, fn, fa, &scr_cc[fx]));
    else
      (void)((*Term->wipe_hook)(fx, y, fn));
  }
}
STATIC_OVL void
Term_fresh_row_both_dblh(int y, int x1, int x2, int* pr_drw)
{
  int x;
  int* old_aa = Term->old->a[y];
  wchar_t* old_cc = Term->old->c[y];
  const int* scr_aa = Term->scr->a[y];
  const wchar_t* scr_cc = Term->scr->c[y];
  int* old_taa = Term->old->ta[y];
  wchar_t* old_tcc = Term->old->tc[y];
  const int* scr_taa = Term->scr->ta[y];
  const wchar_t* scr_tcc = Term->scr->tc[y];
  const int* scr_aa_nr;
  const wchar_t* scr_cc_nr;
  const int* scr_taa_nr;
  const wchar_t* scr_tcc_nr;
  const int* old_aa_nr;
  const wchar_t* old_cc_nr;
  const int* old_taa_nr;
  const wchar_t* old_tcc_nr;
  int always_text = Term->always_text;
  int fn = 0;
  int fx = 0;
  int fa = COLOUR_WHITE;
  if (y < Term->hgt - tile_height) {
    scr_aa_nr = Term->scr->a[y + tile_height];
    scr_cc_nr = Term->scr->c[y + tile_height];
    scr_taa_nr = Term->scr->ta[y + tile_height];
    scr_tcc_nr = Term->scr->tc[y + tile_height];
    old_aa_nr = Term->old->a[y + tile_height];
    old_cc_nr = Term->old->c[y + tile_height];
    old_taa_nr = Term->old->ta[y + tile_height];
    old_tcc_nr = Term->old->tc[y + tile_height];
  } else {
    scr_aa_nr = scr_aa;
    scr_cc_nr = scr_cc;
    scr_taa_nr = scr_taa;
    scr_tcc_nr = scr_tcc;
    old_aa_nr = scr_aa_nr;
    old_cc_nr = scr_cc_nr;
    old_taa_nr = scr_taa_nr;
    old_tcc_nr = scr_tcc_nr;
  }
  for (x = 0; x < x1; x++) {
    pr_drw[x] = 0;
  }
  for (x = x1; x <= x2; x++) {
    int oa = old_aa[x];
    wchar_t oc = old_cc[x];
    int ota = old_taa[x];
    wchar_t otc = old_tcc[x];
    int na = scr_aa[x];
    wchar_t nc = scr_cc[x];
    int nta = scr_taa[x];
    wchar_t ntc = scr_tcc[x];
    int draw;
    if (na == oa && nc == oc && nta == ota && ntc == otc) {
      if (pr_drw[x] &&
          ((*Term->dblh_hook)(na, nc) || (*Term->dblh_hook)(nta, ntc))) {
        draw = 1;
      } else {
        int oa_nr = old_aa_nr[x];
        wchar_t oc_nr = old_cc_nr[x];
        int ota_nr = old_taa_nr[x];
        wchar_t otc_nr = old_tcc_nr[x];
        int na_nr = scr_aa_nr[x];
        wchar_t nc_nr = scr_cc_nr[x];
        int nta_nr = scr_taa_nr[x];
        wchar_t ntc_nr = scr_tcc_nr[x];
        if (((*Term->dblh_hook)(oa_nr, oc_nr) ||
             (*Term->dblh_hook)(ota_nr, otc_nr)) &&
            (na_nr != oa_nr || nc_nr != oc_nr || nta_nr != ota_nr ||
             ntc_nr != otc_nr)) {
          draw = 1;
        } else {
          if ((na & 0x80) && na != 255) {
            draw = is_padding_changed(Term, y, x);
          } else {
            draw = 0;
          }
        }
      }
      pr_drw[x] = draw;
    } else {
      draw = 1;
      pr_drw[x] = 1;
    }
    if (!draw) {
      if (fn) {
        if (fa || always_text) {
          (void)((*Term->text_hook)(fx, y, fn, fa, &scr_cc[fx]));
        } else {
          (void)((*Term->wipe_hook)(fx, y, fn));
        }
        fn = 0;
      }
      continue;
    }
    old_aa[x] = na;
    old_cc[x] = nc;
    old_taa[x] = nta;
    old_tcc[x] = ntc;
    if ((na & 0x80)) {
      if (fn) {
        if (fa || always_text) {
          (void)((*Term->text_hook)(fx, y, fn, fa, &scr_cc[fx]));
        } else {
          (void)((*Term->wipe_hook)(fx, y, fn));
        }
        fn = 0;
      }
      if (na == 255) continue;
      (void)((*Term->pict_hook)(x, y, 1, &na, &nc, &nta, &ntc));
      continue;
    }
    if (fa != na) {
      if (fn) {
        if (fa || always_text) {
          (void)((*Term->text_hook)(fx, y, fn, fa, &scr_cc[fx]));
        } else {
          (void)((*Term->wipe_hook)(fx, y, fn));
        }
        fn = 0;
      }
      fa = na;
    }
    if (fn++ == 0) fx = x;
  }
  if (fn) {
    if (fa || always_text) {
      (void)((*Term->text_hook)(fx, y, fn, fa, &scr_cc[fx]));
    } else {
      (void)((*Term->wipe_hook)(fx, y, fn));
    }
  }
  for (x = x2 + 1; x < Term->wid; x++) {
    pr_drw[x] = 0;
  }
}
STATIC_OVL void
Term_fresh_row_text(int y, int x1, int x2)
{
  int x;
  int* old_aa = Term->old->a[y];
  wchar_t* old_cc = Term->old->c[y];
  int* scr_aa = Term->scr->a[y];
  wchar_t* scr_cc = Term->scr->c[y];
  int always_text = Term->always_text;
  int fn = 0;
  int fx = 0;
  int fa = COLOUR_WHITE;
  int oa;
  wchar_t oc;
  int na;
  wchar_t nc;
  for (x = x1; x <= x2; x++) {
    oa = old_aa[x];
    oc = old_cc[x];
    na = scr_aa[x];
    nc = scr_cc[x];
    if ((na == oa) && (nc == oc)) {
      if (fn) {
        if (fa || always_text)
          (void)((*Term->text_hook)(fx, y, fn, fa, &scr_cc[fx]));
        else
          (void)((*Term->wipe_hook)(fx, y, fn));
        fn = 0;
      }
      continue;
    }
    old_aa[x] = na;
    old_cc[x] = nc;
    if (fa != na) {
      if (fn) {
        if (fa || always_text)
          (void)((*Term->text_hook)(fx, y, fn, fa, &scr_cc[fx]));
        else
          (void)((*Term->wipe_hook)(fx, y, fn));
        fn = 0;
      }
      fa = na;
    }
    if (fn++ == 0) fx = x;
  }
  if (fn) {
    if (fa || always_text)
      (void)((*Term->text_hook)(fx, y, fn, fa, &scr_cc[fx]));
    else
      (void)((*Term->wipe_hook)(fx, y, fn));
  }
}
STATIC_OVL errr
Term_mark(int x, int y)
{
  int* old_aa = Term->old->a[y];
  wchar_t* old_cc = Term->old->c[y];
  int* old_taa = Term->old->ta[y];
  wchar_t* old_tcc = Term->old->tc[y];
  old_aa[x] = 0x80;
  old_cc[x] = 0;
  old_taa[x] = 0x80;
  old_tcc[x] = 0;
  if (y < Term->y1) Term->y1 = y;
  if (y > Term->y2) Term->y2 = y;
  if (x < Term->x1[y]) Term->x1[y] = x;
  if (x > Term->x2[y]) Term->x2[y] = x;
  return (0);
}
STATIC_OVL errr
Term_fresh(void)
{
  int x, y;
  int w = Term->wid;
  int h = Term->hgt;
  int y1 = Term->y1;
  int y2 = Term->y2;
  term_win* old = Term->old;
  term_win* scr = Term->scr;
  if (!Term->mapped_flag) return (1);
  if ((y1 > y2) && (scr->cu == old->cu) && (scr->cv == old->cv) &&
      (scr->cx == old->cx) && (scr->cy == old->cy) && (scr->cnx == old->cnx) &&
      (scr->cny == old->cny) && !(Term->total_erase)) {
    return (1);
  }
  if (!Term->curs_hook) Term->curs_hook = Term_curs_hack;
  if (!Term->bigcurs_hook) Term->bigcurs_hook = Term->curs_hook;
  if (!Term->wipe_hook) Term->wipe_hook = Term_wipe_hack;
  if (!Term->text_hook) Term->text_hook = Term_text_hack;
  if (!Term->pict_hook) Term->pict_hook = Term_pict_hack;
  if (Term->total_erase) {
    Term_xtra(TERM_XTRA_CLEAR, 0);
    old->cv = old->cu = false;
    old->cx = old->cy = 0;
    old->cnx = old->cny = 1;
    for (y = 0; y < h; y++) {
      int* aa = old->a[y];
      wchar_t* cc = old->c[y];
      int* taa = old->ta[y];
      wchar_t* tcc = old->tc[y];
      for (x = 0; x < w; x++) {
        *aa++ = COLOUR_WHITE;
        *cc++ = ' ';
        *taa++ = COLOUR_WHITE;
        *tcc++ = ' ';
      }
    }
    Term->y1 = y1 = 0;
    Term->y2 = y2 = h - 1;
    for (y = 0; y < h; y++) {
      Term->x1[y] = 0;
      Term->x2[y] = w - 1;
    }
    Term->total_erase = false;
  }
  if (Term->soft_cursor) {
    if (!old->cu && old->cv) {
      int mty = MAX(old->cy, MIN(old->cy + old->cny - 1, h - 1));
      int mtx = MAX(old->cx, MIN(old->cx + old->cnx - 1, w - 1));
      int ty;
      for (ty = old->cy; ty <= mty; ++ty) {
        int tx;
        for (tx = old->cx; tx <= mtx; ++tx) {
          old->c[ty][tx] = ~scr->c[ty][tx];
        }
        if (Term->x1[ty] > old->cx) {
          Term->x1[ty] = old->cx;
        }
        if (Term->x2[ty] < mtx) {
          Term->x2[ty] = mtx;
        }
      }
      if (y1 > old->cy) {
        y1 = old->cy;
      }
      if (y2 < mty) {
        y2 = mty;
      }
    }
  } else {
    if (scr->cu || !scr->cv) Term_xtra(TERM_XTRA_SHAPE, 0);
  }
  if (y1 <= y2) {
    int** pr_drw;
    int ipr;
    if (Term->dblh_hook && (Term->always_pict || Term->higher_pict)) {
      pr_drw = mem_alloc(tile_height * sizeof(*pr_drw));
      for (y = 0; y < tile_height; ++y) {
        pr_drw[y] = mem_zalloc(w * sizeof(**pr_drw));
      }
    } else {
      pr_drw = NULL;
    }
    if ((Term->icky_corner) && (y2 >= h - 1) && (Term->x2[h - 1] > w - 2))
      Term->x2[h - 1] = w - 2;
    Term->y1 = h;
    Term->y2 = 0;
    ipr = 0;
    for (y = y1; y <= y2; ++y) {
      int x1 = Term->x1[y];
      int x2 = Term->x2[y];
      if (x1 <= x2) {
        Term->x1[y] = w;
        Term->x2[y] = 0;
        if (Term->always_pict) {
          if (Term->dblh_hook) {
            Term_fresh_row_pict_dblh(y, x1, x2, pr_drw[ipr]);
            ipr = (ipr + 1) % tile_height;
          } else {
            Term_fresh_row_pict(y, x1, x2);
          }
        } else if (Term->higher_pict) {
          if (Term->dblh_hook) {
            Term_fresh_row_both_dblh(y, x1, x2, pr_drw[ipr]);
            ipr = (ipr + 1) % tile_height;
          } else {
            Term_fresh_row_both(y, x1, x2);
          }
        } else {
          Term_fresh_row_text(y, x1, x2);
        }
        if (!Term->never_frosh) Term_xtra(TERM_XTRA_FROSH, y);
      } else if (pr_drw) {
        for (x = 0; x < w; ++x) {
          pr_drw[ipr][x] = 0;
        }
        ipr = (ipr + 1) % tile_height;
      }
    }
    if (pr_drw) {
      for (y = 0; y < tile_height; ++y) {
        mem_free(pr_drw[y]);
      }
      mem_free(pr_drw);
    }
  }
  if (Term->soft_cursor) {
    if (!scr->cu && scr->cv) {
      if ((((tile_width > 1) || (tile_height > 1)) && (!smlcurs) &&
           (Term->saved == 0) && (scr->cy > 0)) ||
          bigcurs) {
        (void)((*Term->bigcurs_hook)(scr->cx, scr->cy));
        scr->cnx = tile_width;
        scr->cny = tile_height;
      } else {
        (void)((*Term->curs_hook)(scr->cx, scr->cy));
        scr->cnx = 1;
        scr->cny = 1;
      }
    } else {
      scr->cnx = 1;
      scr->cny = 1;
    }
  } else {
    if (scr->cu) {
      (void)((*Term->curs_hook)(w - 1, scr->cy));
    } else if (!scr->cv) {
      (void)((*Term->curs_hook)(scr->cx, scr->cy));
    } else {
      (void)((*Term->curs_hook)(scr->cx, scr->cy));
      Term_xtra(TERM_XTRA_SHAPE, 1);
    }
    scr->cnx = 1;
    scr->cny = 1;
  }
  old->cu = scr->cu;
  old->cv = scr->cv;
  old->cx = scr->cx;
  old->cy = scr->cy;
  old->cnx = scr->cnx;
  old->cny = scr->cny;
  Term_xtra(TERM_XTRA_FRESH, 0);
  return (0);
}
STATIC_OVL errr
Term_set_cursor(bool v)
{
  if (Term->scr->cv == v) return (1);
  Term->scr->cv = v;
  return (0);
}
STATIC_OVL errr
Term_gotoxy(int x, int y)
{
  int w = Term->wid;
  int h = Term->hgt;
  if ((x < 0) || (x >= w)) return (-1);
  if ((y < 0) || (y >= h)) return (-1);
  Term->scr->cx = x;
  Term->scr->cy = y;
  Term->scr->cu = 0;
  return (0);
}
STATIC_OVL errr
Term_draw(int x, int y, int a, wchar_t c)
{
  int w = Term->wid;
  int h = Term->hgt;
  if ((x < 0) || (x >= w)) return (-1);
  if ((y < 0) || (y >= h)) return (-1);
  if (!c) return (-2);
  Term_queue_char(Term, x, y, a, c, 0, 0);
  return (0);
}
STATIC_OVL errr
Term_addch(int a, wchar_t c)
{
  int w = Term->wid;
  if (Term->scr->cu) return (-1);
  if (!c) return (-2);
  Term_queue_char(Term, Term->scr->cx, Term->scr->cy, a, c, 0, 0);
  Term->scr->cx++;
  if (Term->scr->cx < w) return (0);
  Term->scr->cu = 1;
  return (1);
}
STATIC_OVL errr
Term_addstr(int n, int a, const char* buf)
{
  int k;
  int w = Term->wid;
  errr res = 0;
  wchar_t s[1024];
  text_mbstowcs(s, buf, 1024);
  if (Term->scr->cu) return (-1);
  k = (n < 0) ? (w + 1) : n;
  for (n = 0; (n < k) && s[n]; n++)
    ;
  if (Term->scr->cx + n >= w) res = n = w - Term->scr->cx;
  Term_queue_chars(Term->scr->cx, Term->scr->cy, n, a, s);
  Term->scr->cx += n;
  if (res) Term->scr->cu = 1;
  return (res);
}
STATIC_OVL errr
Term_putch(int x, int y, int a, wchar_t c)
{
  errr res;
  if ((res = Term_gotoxy(x, y)) != 0) return (res);
  if ((res = Term_addch(a, c)) != 0) return (res);
  return (0);
}
STATIC_OVL void
Term_big_putch(int x, int y, int a, wchar_t c)
{
  int hor, vert;
  (void)c;
  if (tile_width > 1) {
    for (hor = 0; hor < tile_width; hor++) {
      if (hor != 0) {
        if (a & 0x80)
          Term_putch(x + hor, y, 255, -1);
        else
          Term_putch(x + hor, y, COLOUR_WHITE, L' ');
      }
      for (vert = 1; vert < tile_height; vert++) {
        if (a & 0x80)
          Term_putch(x + hor, y + vert, 255, -1);
        else
          Term_putch(x + hor, y + vert, COLOUR_WHITE, L' ');
      }
    }
  } else {
    for (vert = 1; vert < tile_height; vert++) {
      if (a & 0x80)
        Term_putch(x, y + vert, 255, -1);
      else
        Term_putch(x, y + vert, COLOUR_WHITE, L' ');
    }
  }
}
STATIC_OVL errr
Term_putstr(int x, int y, int n, int a, const char* s)
{
  errr res;
  if (!Term) return 0;
  if ((res = Term_gotoxy(x, y)) != 0) return (res);
  if ((res = Term_addstr(n, a, s)) != 0) return (res);
  return (0);
}
STATIC_OVL errr
Term_erase(int x, int y, int n)
{
  int i;
  int w = Term->wid;
  int x1 = -1;
  int x2 = -1;
  int* scr_aa;
  wchar_t* scr_cc;
  int* scr_taa;
  wchar_t* scr_tcc;
  if (Term_gotoxy(x, y)) return (-1);
  if (x + n > w) n = w - x;
  scr_aa = Term->scr->a[y];
  scr_cc = Term->scr->c[y];
  scr_taa = Term->scr->ta[y];
  scr_tcc = Term->scr->tc[y];
  for (i = 0; i < n; i++, x++) {
    int oa = scr_aa[x];
    wchar_t oc = scr_cc[x];
    if ((oa == COLOUR_WHITE) && (oc == ' ')) continue;
    scr_aa[x] = COLOUR_WHITE;
    scr_cc[x] = ' ';
    scr_taa[x] = 0;
    scr_tcc[x] = 0;
    if (x1 < 0) x1 = x;
    x2 = x;
  }
  if (x1 >= 0) {
    if (y < Term->y1) Term->y1 = y;
    if (y > Term->y2) Term->y2 = y;
    if (x1 < Term->x1[y]) Term->x1[y] = x1;
    if (x2 > Term->x2[y]) Term->x2[y] = x2;
  }
  return (0);
}
STATIC_OVL errr
Term_clear(void)
{
  int x, y;
  int w = Term->wid;
  int h = Term->hgt;
  Term->scr->cu = 0;
  Term->scr->cx = Term->scr->cy = 0;
  for (y = 0; y < h; y++) {
    int* scr_aa = Term->scr->a[y];
    wchar_t* scr_cc = Term->scr->c[y];
    int* scr_taa = Term->scr->ta[y];
    wchar_t* scr_tcc = Term->scr->tc[y];
    for (x = 0; x < w; x++) {
      scr_aa[x] = COLOUR_WHITE;
      scr_cc[x] = ' ';
      scr_taa[x] = 0;
      scr_tcc[x] = 0;
    }
    Term->x1[y] = 0;
    Term->x2[y] = w - 1;
  }
  Term->y1 = 0;
  Term->y2 = h - 1;
  Term->total_erase = true;
  return (0);
}
STATIC_OVL errr
Term_redraw(void)
{
  Term->total_erase = true;
  Term_fresh();
  return (0);
}
STATIC_OVL errr
Term_redraw_section(int x1, int y1, int x2, int y2)
{
  int i, j;
  wchar_t* c_ptr;
  if (y2 >= Term->hgt) y2 = Term->hgt - 1;
  if (x2 >= Term->wid) x2 = Term->wid - 1;
  if (y1 < 0) y1 = 0;
  if (x1 < 0) x1 = 0;
  Term->y1 = y1;
  Term->y2 = y2;
  for (i = Term->y1; i <= Term->y2; i++) {
    if ((x1 > 0) && (Term->old->a[i][x1] == 255)) x1--;
    Term->x1[i] = x1;
    Term->x2[i] = x2;
    c_ptr = Term->old->c[i];
    for (j = x1; j <= x2; j++) {
      c_ptr[j] = 0;
    }
  }
  Term_fresh();
  return (0);
}
STATIC_OVL errr
Term_get_cursor(bool* v)
{
  (*v) = Term->scr->cv;
  return (0);
}
STATIC_OVL errr
Term_get_size(int* w, int* h)
{
  *w = Term ? Term->wid : 80;
  *h = Term ? Term->hgt : 24;
  return 0;
}
STATIC_OVL errr
Term_locate(int* x, int* y)
{
  (*x) = Term->scr->cx;
  (*y) = Term->scr->cy;
  if (Term->scr->cu) return (1);
  return (0);
}
STATIC_OVL errr
Term_what(int x, int y, int* a, wchar_t* c)
{
  int w = Term->wid;
  int h = Term->hgt;
  if ((x < 0) || (x >= w)) return (-1);
  if ((y < 0) || (y >= h)) return (-1);
  (*a) = Term->scr->a[y][x];
  (*c) = Term->scr->c[y][x];
  return (0);
}
STATIC_OVL errr
Term_flush(void)
{
  if (!Term) return 0;
  Term_xtra(TERM_XTRA_FLUSH, 0);
  Term->key_head = Term->key_tail = 0;
  return (0);
}
STATIC_OVL void
log_keypress(ui_event e)
{
  if (e.type != EVT_KBRD) return;
  if (!e.key.code) return;
  keylog[log_i] = e.key;
  if (log_size < KEYLOG_SIZE) log_size++;
  log_i = (log_i + 1) % KEYLOG_SIZE;
}
STATIC_OVL errr
Term_keypress(keycode_t k, uint8_t mods)
{
  if (!k) return (-1);
  if (!Term->complex_input) {
    switch (k) {
      case '\r':
      case '\n':
        k = KC_ENTER;
        break;
      case 8:
        k = KC_BACKSPACE;
        break;
      case 9:
        k = KC_TAB;
        break;
      case 27:
        k = ESCAPE;
        break;
    }
  }
  Term->key_queue[Term->key_head].type = EVT_KBRD;
  Term->key_queue[Term->key_head].key.code = k;
  Term->key_queue[Term->key_head].key.mods = mods;
  Term->key_head++;
  if (Term->key_head == Term->key_size) Term->key_head = 0;
  if (Term->key_head != Term->key_tail) return (0);
  return (1);
}
STATIC_OVL errr
Term_mousepress(int x, int y, char button)
{
  Term->key_queue[Term->key_head].type = EVT_MOUSE;
  Term->key_queue[Term->key_head].mouse.x = x;
  Term->key_queue[Term->key_head].mouse.y = y;
  Term->key_queue[Term->key_head].mouse.button = (button & 0x0F);
  Term->key_queue[Term->key_head].mouse.mods = ((button & 0xF0) >> 4);
  Term->key_head++;
  if (Term->key_head == Term->key_size) Term->key_head = 0;
  if (Term->key_head != Term->key_tail) return (0);
  return (1);
}
STATIC_OVL errr
Term_key_push(int k)
{
  ui_event ke;
  if (!k) return (-1);
  ke.type = EVT_KBRD;
  ke.key.code = k;
  ke.key.mods = 0;
  return Term_event_push(&ke);
}
STATIC_OVL errr
Term_event_push(const ui_event* ke)
{
  if (!ke) return (-1);
  if (Term->key_tail == 0) Term->key_tail = Term->key_size;
  Term->key_queue[--Term->key_tail] = *ke;
  if (Term->key_head != Term->key_tail) return (0);
  return (1);
}
STATIC_OVL errr
Term_inkey(ui_event* ch, bool wait, bool take)
{
  memset(ch, 0, sizeof *ch);
  if (!Term->never_bored) Term_xtra(TERM_XTRA_BORED, 0);
  if (wait)
    while (Term->key_head == Term->key_tail) Term_xtra(TERM_XTRA_EVENT, true);
  else if (Term->key_head == Term->key_tail)
    Term_xtra(TERM_XTRA_EVENT, false);
  if (Term->key_head == Term->key_tail) return (1);
  (*ch) = Term->key_queue[Term->key_tail];
  log_keypress(*ch);
  if (take && (++Term->key_tail == Term->key_size)) Term->key_tail = 0;
  return (0);
}
STATIC_OVL errr
Term_save(void)
{
  int w = Term->wid;
  int h = Term->hgt;
  term_win* mem;
  mem = mem_zalloc(sizeof(term_win));
  term_win_init(mem, w, h);
  term_win_copy(mem, Term->scr, w, h);
  mem->next = Term->mem;
  Term->mem = mem;
  Term->saved++;
  return (0);
}
STATIC_OVL errr
Term_load(void)
{
  int y;
  int w = Term->wid;
  int h = Term->hgt;
  term_win* tmp;
  if (Term->mem) {
    tmp = Term->mem;
    Term->mem = Term->mem->next;
    term_win_copy(Term->scr, tmp, w, h);
    (void)term_win_nuke(tmp);
    mem_free(tmp);
  }
  for (y = 0; y < h; y++) {
    Term->x1[y] = 0;
    Term->x2[y] = w - 1;
  }
  Term->y1 = 0;
  Term->y2 = h - 1;
  Term->saved--;
  return (0);
}
STATIC_OVL errr
Term_load_all(void)
{
  int w = Term->wid;
  int h = Term->hgt;
  struct reversed_save {
    term_win* saved_mem;
    struct reversed_save* next;
  }* reversed_list = NULL;
  struct term_win* cursor;
  for (cursor = Term->mem; cursor; cursor = cursor->next) {
    struct reversed_save* new_head = mem_alloc(sizeof(*new_head));
    new_head->saved_mem = cursor;
    new_head->next = reversed_list;
    reversed_list = new_head;
  }
  while (reversed_list) {
    struct reversed_save* tgt = reversed_list;
    int y;
    reversed_list = reversed_list->next;
    term_win_copy(Term->scr, tgt->saved_mem, w, h);
    mem_free(tgt);
    for (y = 0; y < h; y++) {
      Term->x1[y] = 0;
      Term->x2[y] = w - 1;
    }
    Term->y1 = 0;
    Term->y2 = h - 1;
    Term_fresh();
  }
  if (Term->mem) {
    cursor = Term->mem;
    Term->mem = Term->mem->next;
    term_win_nuke(cursor);
    mem_free(cursor);
  }
  Term->saved--;
  return (0);
}
STATIC_OVL errr
Term_resize(int w, int h)
{
  int i;
  int wid, hgt;
  int* hold_x1;
  int* hold_x2;
  term_win* hold_old;
  term_win* hold_scr;
  term_win* hold_mem;
  term_win** hold_mem_dest;
  term_win* hold_tmp;
  ui_event evt = EVENT_EMPTY;
  evt.type = EVT_RESIZE;
  if (Term->fixed_shape) return (-1);
  if ((w < 1) || (h < 1)) return (-1);
  if ((Term->wid == w) && (Term->hgt == h)) return (1);
  wid = MIN(Term->wid, w);
  hgt = MIN(Term->hgt, h);
  hold_x1 = Term->x1;
  hold_x2 = Term->x2;
  hold_old = Term->old;
  hold_scr = Term->scr;
  hold_mem = Term->mem;
  hold_tmp = Term->tmp;
  Term->x1 = mem_zalloc(h * sizeof(int));
  Term->x2 = mem_zalloc(h * sizeof(int));
  Term->old = mem_zalloc(sizeof(term_win));
  term_win_init(Term->old, w, h);
  term_win_copy(Term->old, hold_old, wid, hgt);
  Term->scr = mem_zalloc(sizeof(term_win));
  term_win_init(Term->scr, w, h);
  term_win_copy(Term->scr, hold_scr, wid, hgt);
  hold_mem_dest = &Term->mem;
  while (hold_mem != 0) {
    term_win* trash;
    *hold_mem_dest = mem_zalloc(sizeof(term_win));
    term_win_init(*hold_mem_dest, w, h);
    term_win_copy(*hold_mem_dest, hold_mem, wid, hgt);
    trash = hold_mem;
    hold_mem = hold_mem->next;
    if ((*hold_mem_dest)->cx >= w) (*hold_mem_dest)->cu = 1;
    if ((*hold_mem_dest)->cy >= h) (*hold_mem_dest)->cu = 1;
    hold_mem_dest = &((*hold_mem_dest)->next);
    term_win_nuke(trash);
    mem_free(trash);
  }
  if (hold_tmp) {
    Term->tmp = mem_zalloc(sizeof(term_win));
    term_win_init(Term->tmp, w, h);
    term_win_copy(Term->tmp, hold_tmp, wid, hgt);
  }
  mem_free(hold_x1);
  mem_free(hold_x2);
  term_win_nuke(hold_old);
  mem_free(hold_old);
  if (Term->old->cx >= w) Term->old->cu = 1;
  if (Term->old->cy >= h) Term->old->cu = 1;
  term_win_nuke(hold_scr);
  mem_free(hold_scr);
  if (Term->scr->cx >= w) Term->scr->cu = 1;
  if (Term->scr->cy >= h) Term->scr->cu = 1;
  if (hold_tmp) {
    term_win_nuke(hold_tmp);
    mem_free(hold_tmp);
    if (Term->tmp->cx >= w) Term->tmp->cu = 1;
    if (Term->tmp->cy >= h) Term->tmp->cu = 1;
  }
  Term->wid = w;
  Term->hgt = h;
  Term->total_erase = true;
  for (i = 0; i < h; i++) {
    Term->x1[i] = 0;
    Term->x2[i] = w - 1;
  }
  Term->y1 = 0;
  Term->y2 = h - 1;
  Term_event_push(&evt);
  return (0);
}
STATIC_OVL errr
Term_activate(term* t)
{
  if (Term == t) return (1);
  if (Term) Term_xtra(TERM_XTRA_LEVEL, 0);
  if (t && !t->active_flag) {
    if (t->init_hook) (*t->init_hook)(t);
    t->active_flag = true;
    t->mapped_flag = true;
  }
  Term = t;
  if (Term) Term_xtra(TERM_XTRA_LEVEL, 1);
  return (0);
}
STATIC_OVL errr
term_nuke(term* t)
{
  if (t->active_flag) {
    if (t->nuke_hook) (*t->nuke_hook)(t);
    t->active_flag = false;
    t->mapped_flag = false;
  }
  term_win_nuke(t->old);
  mem_free(t->old);
  term_win_nuke(t->scr);
  mem_free(t->scr);
  if (t->mem) {
    term_win_nuke(t->mem);
    mem_free(t->mem);
  }
  if (t->tmp) {
    term_win_nuke(t->tmp);
    mem_free(t->tmp);
  }
  mem_free(t->x1);
  mem_free(t->x2);
  mem_free(t->key_queue);
  return (0);
}
STATIC_OVL errr
term_init(term* t, int w, int h, int k)
{
  int y;
  memset(t, 0, sizeof(term));
  t->key_head = t->key_tail = 0;
  t->key_size = k;
  t->key_queue = mem_zalloc(t->key_size * sizeof(ui_event));
  t->wid = w;
  t->hgt = h;
  t->x1 = mem_zalloc(h * sizeof(int));
  t->x2 = mem_zalloc(h * sizeof(int));
  t->old = mem_zalloc(sizeof(term_win));
  term_win_init(t->old, w, h);
  t->scr = mem_zalloc(sizeof(term_win));
  term_win_init(t->scr, w, h);
  for (y = 0; y < h; y++) {
    t->x1[y] = 0;
    t->x2[y] = w - 1;
  }
  t->y1 = 0;
  t->y2 = h - 1;
  t->total_erase = true;
  t->saved = 0;
  t->sidebar_mode = SIDEBAR_LEFT;
  return (0);
}
STATIC_OVL int
big_pad(int col, int row, uint8_t a, wchar_t c)
{
  Term_putch(col, row, a, c);
  if ((tile_width > 1) || (tile_height > 1)) Term_big_putch(col, row, a, c);
  return tile_width;
}
STATIC_OVL int
Term_get_first_tile_row(term* t)
{
  int result;
  if (t == angband_term[0]) {
    result = ROW_MAP;
  } else {
    int i = 1;
    while (1) {
      if (i >= ANGBAND_TERM_MAX) {
        result = 1;
        break;
      }
      if (t == angband_term[i]) {
        if (window_flag[i] & PW_OVERHEAD) {
          result = 0;
        } else {
          result = 1;
        }
        break;
      }
      ++i;
    }
  }
  return result;
}
STATIC_OVL void
textui_tutorial_textblock_show(textblock* tb, const char* header)
{
  region orig_area = {COL_MAP, ROW_MAP, 60, 18};
  (void)textui_textblock_show(tb, orig_area, header);
}
STATIC_OVL void
textui_tutorial_textblock_append_command_phrase(textblock* tb,
                                                const char* command_name,
                                                bool capital, bool gerund)
{
  int i = 0;
  while (1) {
    size_t j;
    if (!cmds_all[i].list) {
      break;
    }
    j = 0;
    while (1) {
      if (j >= cmds_all[i].len) {
        break;
      }
      if (streq(cmds_all[i].list[j].desc, command_name)) {
        int mode =
            OPT(player, hjkl_movement) ? KEYMAP_MODE_ROGUE : KEYMAP_MODE_ORIG;
        keycode_t code = cmds_all[i].list[j].key[mode];
        if (!code && mode != KEYMAP_MODE_ORIG) {
          code = cmds_all[i].list[j].key[KEYMAP_MODE_ORIG];
        }
        if (code) {
          const char* desc = keycode_find_desc(code);
          textblock_append(tb, "%s%s ", (capital) ? "Press" : "press",
                           (gerund) ? "ing" : "");
          if (desc) {
            textblock_append(tb, "'%s'", desc);
          } else if (KTRL(code) == code) {
            textblock_append(tb, "'ctrl-%c'", UN_KTRL(code));
          } else {
            textblock_append(tb, "'%c'", code);
          }
        }
        return;
      }
      ++j;
    }
    ++i;
  }
}
STATIC_OVL void
textui_tutorial_textblock_append_direction_phrase(textblock* tb, int dirnum,
                                                  bool capital, bool gerund)
{
  int mode = OPT(player, hjkl_movement) ? KEYMAP_MODE_ROGUE : KEYMAP_MODE_ORIG;
  char keys[2][9] = {{'1', '2', '3', '4', '5', '6', '7', '8', '9'},
                     {'b', 'j', 'n', 'h', '.', 'l', 'y', 'k', 'u'}};
  if (dirnum > 0 && dirnum < 10) {
    textblock_append(tb, "%s%s '%c'", (capital) ? "Press" : "press",
                     (gerund) ? "ing" : "", keys[mode][dirnum - 1]);
  }
}
STATIC_OVL void
textui_tutorial_textblock_append_direction_rose(textblock* tb)
{
  if (OPT(player, hjkl_movement)) {
    textblock_append(
        tb,
        "\nUse the keyboard to move (or stay still) as follows:\n\n"
        "y (northeast)  k (north)   u (northeast)\n"
        "             \\    |      /\n"
        "   h (west)  -    .      -   l (east)\n"
        "             /    |      \\\n"
        "b (southeast)  j (south)   n (southeast)\n"
        "\nIn most environments, the numeric keypad or "
        "pointing and clicking with the mouse may also be "
        "used.\n");
  } else {
    textblock_append(
        tb,
        "\nUse the keyboard to move (or stay still) as follows:\n\n"
        "7 (northeast)  8 (north)   9 (northeast)\n"
        "             \\    |      /\n"
        "   4 (west)  -    5      -   6 (east)\n"
        "             /    |      \\\n"
        "1 (southeast)  2 (south)   3 (southeast)\n"
        "\nIn most environments, the numeric keypad or "
        "pointing and clicking with the mouse may also be "
        "used.  If you don't have a numeric keypad, you may "
        "want to enable the rogue-like keys (press =, select "
        "a for the interface options, then turn on the first "
        "option there) for a more convenient set of movement "
        "controls.\n");
  }
}
STATIC_OVL void
textui_tutorial_textblock_append_feature_symbol(textblock* tb, int feat)
{
  int attr = feat_x_attr[LIGHTING_LIT][feat];
  if (use_graphics == GRAPHICS_NONE && feat_is_wall(feat)) {
    if (OPT(player, hybrid_walls)) {
      attr += (MULT_BG * BG_DARK);
    } else if (OPT(player, solid_walls)) {
      attr += (MULT_BG * BG_SAME);
    }
  }
  textblock_append(tb, "('");
  textblock_append_pict(tb, attr, feat_x_char[LIGHTING_LIT][feat]);
  textblock_append(tb, "')");
}
STATIC_OVL void
textui_tutorial_textblock_append_monster_symbol(textblock* tb,
                                                const struct monster_race* race)
{
  textblock_append(tb, "('");
  textblock_append_pict(tb, monster_x_attr[race->ridx],
                        monster_x_char[race->ridx]);
  textblock_append(tb, "')");
}
STATIC_OVL void
textui_tutorial_textblock_append_object_symbol(textblock* tb,
                                               const struct object_kind* kind)
{
  textblock_append(tb, "('");
  textblock_append_pict(tb, object_kind_attr(kind), object_kind_char(kind));
  textblock_append(tb, "')");
}
STATIC_OVL void
start_tutorial(void)
{
  char name[PLAYER_NAME_LEN];
  tutorial_parse_data();
  if (tutorial_parsed_data.default_archetype) {
    struct tutorial_dict_val_type* a = tutorial_parsed_data.default_archetype;
    const struct player_race* rpick = NULL;
    int i, exp;
    character_generated = false;
    cmdq_push(CMD_BIRTH_INIT);
    cmdq_push(CMD_BIRTH_RESET);
    if (!races) {
      quit_fmt("No races specified prior to loading tutorial.");
    }
    cmdq_push(CMD_CHOOSE_RACE);
    if (a->v.archetype.race_name) {
      if (streq(a->v.archetype.race_name, "*")) {
        const struct player_race* rc = races;
        int nr = 0;
        while (rc) {
          ++nr;
          if (one_in_(nr)) {
            rpick = rc;
          }
          rc = rc->next;
        }
      } else {
        rpick = races;
        while (1) {
          if (!rpick) {
            quit_fmt(
                "Unknown race, %s, "
                "specified for "
                "tutorial archetype.",
                a->v.archetype.race_name);
            break;
          }
          if (streq(rpick->name, a->v.archetype.race_name)) {
            break;
          }
          rpick = rpick->next;
        }
      }
    } else {
      rpick = races;
    }
    cmd_set_arg_choice(cmdq_peek(), "choice", rpick->ridx);
    cmdq_push(CMD_CHOOSE_HOUSE);
    if (a->v.archetype.house_name) {
      const struct player_house* hpick = NULL;
      unsigned int hmin = UINT_MAX;
      if (streq(a->v.archetype.house_name, "*")) {
        const struct player_house* hc = houses;
        int nh = 0;
        while (hc) {
          if (hc->race == rpick) {
            ++nh;
            if (hmin > hc->hidx) {
              hmin = hc->hidx;
            }
            if (one_in_(nh)) {
              hpick = hc;
            }
          }
          hc = hc->next;
        }
        if (!hpick) {
          quit_fmt(
              "No houses available for the "
              "race, %s, specified in the "
              "tutorial.",
              rpick->name);
        }
      } else {
        const struct player_house* hc = houses;
        while (hc) {
          if (hc->race == rpick && hmin > hc->hidx) {
            hmin = hc->hidx;
          }
          if (streq(hc->short_name, a->v.archetype.house_name)) {
            if (hc->race != rpick) {
              quit_fmt(
                  "House, %s, "
                  "selected for "
                  "tutorial does "
                  "not match the "
                  "selected race, "
                  "%s.",
                  a->v.archetype.house_name, rpick->name);
            }
            hpick = hc;
          }
          hc = hc->next;
        }
        if (!hpick) {
          quit_fmt(
              "Unknown house, %s, "
              "specified for the tutorial.",
              a->v.archetype.house_name);
        }
      }
      cmd_set_arg_choice(cmdq_peek(), "choice", hpick->hidx - hmin);
    } else {
      cmd_set_arg_choice(cmdq_peek(), "choice", 0);
    }
    if (!sexes) {
      quit_fmt("No sexes specified prior to loading tutorial.");
    }
    cmdq_push(CMD_CHOOSE_SEX);
    if (a->v.archetype.sex_name) {
      const struct player_sex* spick = NULL;
      if (streq(a->v.archetype.sex_name, "*")) {
        const struct player_sex* sc = sexes;
        int ns = 0;
        while (sc) {
          ++ns;
          if (one_in_(ns)) {
            spick = sc;
          }
          sc = sc->next;
        }
      } else {
        spick = sexes;
        while (1) {
          if (!spick) {
            quit_fmt(
                "Unknown sex, %s, "
                "specified for "
                "tutorial archetype.",
                a->v.archetype.sex_name);
            break;
          }
          if (streq(spick->name, a->v.archetype.sex_name)) {
            break;
          }
          spick = spick->next;
        }
      }
      cmd_set_arg_choice(cmdq_peek(), "choice", spick->sidx);
    } else {
      cmd_set_arg_choice(cmdq_peek(), "choice", sexes->sidx);
    }
    cmdq_push(CMD_NAME_CHOICE);
    if (a->v.archetype.character_name &&
        !streq(a->v.archetype.character_name, "*")) {
      my_strcpy(name, a->v.archetype.character_name, sizeof(name));
    } else {
      (void)player_random_name(name, sizeof(name));
    }
    cmd_set_arg_string(cmdq_peek(), "name", name);
    if (a->v.archetype.history && !streq(a->v.archetype.history, "*")) {
      char history[240];
      my_strcpy(history, a->v.archetype.history, sizeof(history));
      cmdq_push(CMD_HISTORY_CHOICE);
      cmd_set_arg_string(cmdq_peek(), "history", history);
    }
    cmdq_push(CMD_ACCEPT_CHARACTER);
    cmdq_execute(CTX_BIRTH);
    for (i = 0; i < STAT_MAX; ++i) {
      if (a->v.archetype.stat_adj[i] >= 0) {
        if (player->stat_base[i] <=
            BASE_STAT_MAX - a->v.archetype.stat_adj[i]) {
          player->stat_base[i] += a->v.archetype.stat_adj[i];
        } else {
          player->stat_base[i] = BASE_STAT_MAX;
        }
      } else {
        if (player->stat_base[i] >=
            BASE_STAT_MIN - a->v.archetype.stat_adj[i]) {
          player->stat_base[i] += a->v.archetype.stat_adj[i];
        } else {
          player->stat_base[i] = BASE_STAT_MIN;
        }
      }
    }
    exp = 0;
    for (i = 0; i < SKILL_MAX; ++i) {
      int max_exp, cskill, inc_lo, inc_hi;
      if (a->v.archetype.skill_adj[i] == 0) {
        continue;
      }
      assert(a->v.archetype.skill_adj[i] > 0);
      max_exp = PY_MAX_EXP - player->exp;
      assert(max_exp >= 0);
      cskill = player->skill_base[i];
      inc_lo = 0;
      if (cskill > max_exp / 100 - 1) {
        inc_hi = 1;
      } else {
        inc_hi = max_exp / ((cskill > 0) ? 100 * cskill : 50);
      }
      while (1) {
        int inc_try, exp_try;
        if (inc_lo == inc_hi - 1 || inc_lo >= a->v.archetype.skill_adj[i]) {
          break;
        }
        inc_try = (inc_lo + inc_hi) / 2;
        if (inc_try > max_exp / 50) {
          inc_hi = inc_try;
        } else if (inc_try + cskill + cskill >= max_exp / (50 * inc_try)) {
          inc_hi = inc_try;
        } else {
          exp_try = 50 * inc_try * (inc_try + cskill + cskill + 1);
          if (exp_try <= max_exp) {
            inc_lo = inc_try;
          } else {
            inc_hi = inc_try;
          }
        }
      }
      if (a->v.archetype.skill_adj[i] > inc_lo) {
        a->v.archetype.skill_adj[i] = inc_lo;
      }
      exp += 50 * a->v.archetype.skill_adj[i] *
             (a->v.archetype.skill_adj[i] + cskill + cskill + 1);
      if (player->new_exp < exp) {
        player_exp_gain(player, exp - player->new_exp);
      }
    }
    init_skills(false, false);
    for (i = 0; i < SKILL_MAX; ++i) {
      int inc = a->v.archetype.skill_adj[i];
      if (inc == 0) {
        continue;
      }
      assert(a->v.archetype.skill_adj[i] > 0);
      while (inc) {
        cmdq_push(CMD_BUY_SKILL);
        cmd_set_arg_choice(cmdq_peek(), "choice", i);
        cmdq_execute(CTX_GAME);
        --inc;
      }
    }
    finalise_skills();
    for (i = 0; i < a->v.archetype.ability_count; ++i) {
      struct ability* anew;
      if (!player_has_prereq_abilities(player,
                                       a->v.archetype.added_abilities[i])) {
        msg("Missing prerequisites for ability, %s, "
            "specified for the tutorial archetype.",
            a->v.archetype.added_abilities[i]->name);
        continue;
      }
      exp = player_ability_cost(player, a->v.archetype.added_abilities[i]);
      if (player->new_exp < exp) {
        player_exp_gain(player, exp - player->new_exp);
      }
      player->new_exp -= exp;
      add_ability(&player->abilities, a->v.archetype.added_abilities[i]);
      anew =
          locate_ability(player->abilities, a->v.archetype.added_abilities[i]);
      assert(anew);
      anew->active = true;
    }
    if (a->v.archetype.unspent_experience >= 0) {
      if (player->new_exp < a->v.archetype.unspent_experience) {
        player_exp_gain(player,
                        a->v.archetype.unspent_experience - player->new_exp);
      } else if (player->new_exp > a->v.archetype.unspent_experience) {
        player->new_exp = a->v.archetype.unspent_experience;
      }
    }
    if (a->v.archetype.purge_kit) {
      struct object* curr = player->gear;
      int pass = 0;
      while (1) {
        struct object* next;
        int slot;
        bool none_left;
        if (curr == NULL) {
          if (pass == 0) {
            curr = player->gear;
            if (curr == NULL) {
              break;
            }
            ++pass;
          } else {
            break;
          }
        }
        next = curr->next;
        slot = equipped_item_slot(player->body, curr);
        if (slot != player->body.count) {
          if (pass == 0) {
            curr = next;
            continue;
          }
          player->body.slots[slot].obj = NULL;
          --player->upkeep->equip_cnt;
        }
        none_left = false;
        curr =
            gear_object_for_use(player, curr, curr->number, false, &none_left);
        assert(none_left);
        object_free(curr->known);
        object_free(curr);
        curr = next;
      }
    }
    if (a->v.archetype.kit_count > 0) {
      assert(a->v.archetype.kit);
      for (i = 0; i < a->v.archetype.kit_count; ++i) {
        const struct tutorial_kit_item* kit = a->v.archetype.kit + i;
        struct object* obj;
        if (!kit->equipped && pack_is_full()) {
          continue;
        }
        obj = (kit->item.is_artifact)
                  ? tutorial_create_artifact(kit->item.v.art)
                  : tutorial_create_object(&kit->item);
        if (!obj) {
          continue;
        }
        obj->origin = ORIGIN_BIRTH;
        obj->known = object_new();
        object_set_base_known(player, obj);
        object_flavor_aware(player, obj);
        if (kit->equipped) {
          int slot = wield_slot(obj);
          struct object* eobj = (slot == -1) ? NULL : slot_object(player, slot);
          if (slot != -1 && eobj == NULL) {
            if (obj->number > 1) {
              eobj = object_split(obj, 1);
            } else {
              eobj = obj;
            }
            player->body.slots[slot].obj = eobj;
            object_learn_on_wield(player, eobj);
            player->upkeep->total_weight += eobj->weight;
            ++player->upkeep->equip_cnt;
            if (obj == eobj) {
              continue;
            }
          }
          if (pack_is_full()) {
            if (obj->artifact) {
              mark_artifact_created(obj->artifact, false);
            }
            object_free(obj->known);
            object_free(obj);
            continue;
          }
        }
        inven_carry(player, obj, true, false);
      }
      update_player_object_knowledge(player);
    }
  } else {
    bool result;
    (void)player_random_name(name, sizeof(name));
    result = player_make_simple(NULL, NULL, NULL, name);
    if (!result) {
      assert(false);
    }
  }
  player->game_type = -1;
  player->upkeep->autosave = false;
  event_add_handler(EVENT_ENTER_WORLD, tutorial_handle_enter_world, NULL);
  event_add_handler(EVENT_LEAVE_WORLD, tutorial_handle_leave_world, NULL);
  tutorial_textblock_show_hook = textui_tutorial_textblock_show;
  tutorial_textblock_append_command_phrase_hook =
      textui_tutorial_textblock_append_command_phrase;
  tutorial_textblock_append_direction_phrase_hook =
      textui_tutorial_textblock_append_direction_phrase;
  tutorial_textblock_append_direction_rose_hook =
      textui_tutorial_textblock_append_direction_rose;
  tutorial_textblock_append_feature_symbol_hook =
      textui_tutorial_textblock_append_feature_symbol;
  tutorial_textblock_append_monster_symbol_hook =
      textui_tutorial_textblock_append_monster_symbol;
  tutorial_textblock_append_object_symbol_hook =
      textui_tutorial_textblock_append_object_symbol;
  event_signal(EVENT_LEAVE_INIT);
  event_signal(EVENT_ENTER_GAME);
  event_signal(EVENT_ENTER_WORLD);
  tutorial_prepare_section(NULL, player);
  on_new_level();
}
STATIC_OVL struct visuals_color_cycle*
visuals_color_cycle_new(const char* name, size_t const step_count,
                        uint8_t const invalid_color)
{
  struct visuals_color_cycle* ccycle = NULL;
  if (step_count == 0) {
    return NULL;
  }
  ccycle = mem_zalloc(sizeof(*ccycle));
  if (ccycle == NULL) {
    return NULL;
  }
  ccycle->steps = mem_zalloc(step_count * sizeof(*(ccycle->steps)));
  if (ccycle->steps == NULL) {
    mem_free(ccycle);
    return NULL;
  }
  memset(ccycle->steps, invalid_color, step_count);
  ccycle->invalid_color = invalid_color;
  ccycle->max_steps = step_count;
  ccycle->cycle_name = string_make(name);
  return ccycle;
}
STATIC_OVL void
visuals_color_cycle_free(struct visuals_color_cycle* ccycle)
{
  if (ccycle == NULL) {
    return;
  }
  if (ccycle->steps != NULL) {
    mem_free(ccycle->steps);
    ccycle->steps = NULL;
  }
  if (ccycle->cycle_name != NULL) {
    string_free(ccycle->cycle_name);
    ccycle->cycle_name = NULL;
  }
  mem_free(ccycle);
  ccycle = NULL;
}
STATIC_OVL struct visuals_color_cycle*
visuals_color_cycle_copy(struct visuals_color_cycle const* original)
{
  struct visuals_color_cycle* copy = NULL;
  size_t step = 0;
  size_t valid_colors = 0;
  size_t copy_step = 0;
  if (original == NULL) {
    return NULL;
  }
  for (step = 0; step < original->max_steps; step++) {
    if (original->steps[step] != original->invalid_color) {
      valid_colors++;
    }
  }
  copy = visuals_color_cycle_new(original->cycle_name, valid_colors,
                                 original->invalid_color);
  if (copy == NULL) {
    return NULL;
  }
  for (step = 0; step < original->max_steps && copy_step < valid_colors;
       step++) {
    if (original->steps[step] != original->invalid_color) {
      copy->steps[copy_step] = original->steps[step];
      copy_step++;
    }
  }
  return copy;
}
STATIC_OVL uint8_t
visuals_color_cycle_attr_for_frame(struct visuals_color_cycle const* ccycle,
                                   size_t const frame)
{
  size_t step = 0;
  if (ccycle == NULL) {
    return BASIC_COLORS;
  }
  step = frame % ccycle->max_steps;
  return ccycle->steps[step];
}
STATIC_OVL struct visuals_cycle_group*
visuals_cycle_group_new(const char* name, size_t const cycle_count)
{
  struct visuals_cycle_group* group = NULL;
  if (cycle_count == 0) {
    return NULL;
  }
  group = mem_zalloc(sizeof(*group));
  if (group == NULL) {
    return NULL;
  }
  group->cycles = mem_zalloc(cycle_count * sizeof(*(group->cycles)));
  if (group->cycles == NULL) {
    mem_free(group);
    return NULL;
  }
  group->max_cycles = cycle_count;
  group->group_name = string_make(name);
  return group;
}
STATIC_OVL void
visuals_cycle_group_free(struct visuals_cycle_group* group)
{
  size_t i = 0;
  if (group == NULL) {
    return;
  }
  if (group->cycles != NULL) {
    for (i = 0; i < group->max_cycles; i++) {
      visuals_color_cycle_free(group->cycles[i]);
    }
    mem_free(group->cycles);
    group->cycles = NULL;
  }
  if (group->group_name != NULL) {
    string_free(group->group_name);
    group->group_name = NULL;
  }
  mem_free(group);
  group = NULL;
}
STATIC_OVL struct visuals_cycler*
visuals_cycler_new(size_t const group_count)
{
  struct visuals_cycler* cycler = NULL;
  if (group_count == 0) {
    return NULL;
  }
  cycler = mem_zalloc(sizeof(*cycler));
  if (cycler == NULL) {
    return NULL;
  }
  cycler->groups = mem_zalloc(group_count * sizeof(*(cycler->groups)));
  if (cycler->groups == NULL) {
    mem_free(cycler);
    return NULL;
  }
  cycler->max_groups = group_count;
  return cycler;
}
STATIC_OVL void
visuals_cycler_free(struct visuals_cycler* cycler)
{
  size_t i = 0;
  if (cycler == NULL) {
    return;
  }
  if (cycler->groups != NULL) {
    for (i = 0; i < cycler->max_groups; i++) {
      visuals_cycle_group_free(cycler->groups[i]);
    }
    mem_free(cycler->groups);
    cycler->groups = NULL;
  }
  mem_free(cycler);
  cycler = NULL;
}
STATIC_OVL struct visuals_color_cycle*
visuals_cycler_cycle_by_name(struct visuals_cycler const* cycler,
                             const char* group_name, const char* cycle_name)
{
  struct visuals_cycle_group* group = NULL;
  struct visuals_color_cycle* ccycle = NULL;
  size_t i = 0;
  if (group_name == NULL || strlen(group_name) == 0) {
    return NULL;
  }
  if (cycle_name == NULL || strlen(cycle_name) == 0) {
    return NULL;
  }
  for (i = 0; i < cycler->max_groups; i++) {
    if (streq(cycler->groups[i]->group_name, group_name)) {
      group = cycler->groups[i];
      break;
    }
  }
  if (group == NULL) {
    return NULL;
  }
  for (i = 0; i < group->max_cycles; i++) {
    if (streq(group->cycles[i]->cycle_name, cycle_name)) {
      ccycle = group->cycles[i];
      break;
    }
  }
  return ccycle;
}
STATIC_OVL uint8_t
visuals_cycler_get_attr_for_frame(const char* group_name,
                                  const char* cycle_name, size_t const frame)
{
  struct visuals_cycler* table = visuals_cycler_table;
  struct visuals_color_cycle* ccycle = NULL;
  ccycle = visuals_cycler_cycle_by_name(table, group_name, cycle_name);
  if (ccycle == NULL) {
    return BASIC_COLORS;
  }
  return visuals_color_cycle_attr_for_frame(ccycle, frame);
}
STATIC_OVL void
visuals_cycler_set_cycle_for_race(struct monster_race const* race,
                                  const char* group_name,
                                  const char* cycle_name)
{
  struct visuals_cycler* table = visuals_cycler_table;
  struct visuals_color_cycle* ccycle = NULL;
  if (race == NULL || group_name == NULL || cycle_name == NULL) {
    return;
  }
  if (visuals_color_cycles_by_race == NULL) {
    return;
  }
  while (race->ridx >= visuals_color_cycles_by_race->max_entries) {
    size_t old_count = visuals_color_cycles_by_race->max_entries;
    size_t new_count = old_count + visuals_color_cycles_by_race->alloc_size;
    size_t new_size = new_count * sizeof(*(visuals_color_cycles_by_race->race));
    visuals_color_cycles_by_race->race =
        mem_realloc(visuals_color_cycles_by_race->race, new_size);
    visuals_color_cycles_by_race->max_entries = new_count;
    if (new_count >= 10000) {
      quit("Allocated too many color cycle/race refs. Check monster info?");
    }
  }
  ccycle = visuals_cycler_cycle_by_name(table, group_name, cycle_name);
  if (ccycle == NULL) {
    return;
  }
  visuals_color_cycles_by_race->race[race->ridx] = ccycle;
}
STATIC_OVL uint8_t
visuals_cycler_get_attr_for_race(struct monster_race const* race,
                                 size_t const frame)
{
  struct visuals_color_cycle* ccycle = NULL;
  if (race == NULL) {
    return BASIC_COLORS;
  }
  if (visuals_color_cycles_by_race == NULL ||
      race->ridx >= visuals_color_cycles_by_race->max_entries) {
    return BASIC_COLORS;
  }
  ccycle = visuals_color_cycles_by_race->race[race->ridx];
  if (ccycle == NULL) {
    return BASIC_COLORS;
  }
  return visuals_color_cycle_attr_for_frame(ccycle, frame);
}
STATIC_OVL struct visuals_flicker*
visuals_flicker_new(size_t const max_cycles, size_t const colors_per_cycle)
{
  struct visuals_flicker* table = NULL;
  size_t cycles_size = 0;
  if (max_cycles < BASIC_COLORS || colors_per_cycle == 0) {
    return NULL;
  }
  table = mem_zalloc(sizeof(*table));
  if (table == NULL) {
    return NULL;
  }
  cycles_size = max_cycles * colors_per_cycle * sizeof(*(table->cycles));
  table->cycles = mem_zalloc(cycles_size);
  if (table->cycles == NULL) {
    mem_free(table);
    return NULL;
  }
  table->max_cycles = max_cycles;
  table->colors_per_cycle = colors_per_cycle;
  return table;
}
STATIC_OVL void
visuals_flicker_free(struct visuals_flicker* table)
{
  if (table == NULL) {
    return;
  }
  if (table->cycles != NULL) {
    mem_free(table->cycles);
    table->cycles = NULL;
  }
  mem_free(table);
  table = NULL;
}
STATIC_OVL void
visuals_flicker_set_color(struct visuals_flicker* table,
                          size_t const cycle_index, size_t const color_index,
                          uint8_t const attr)
{
  if (table == NULL) {
    return;
  }
  if (cycle_index >= table->max_cycles) {
    return;
  }
  if (color_index >= table->colors_per_cycle) {
    return;
  }
  table->cycles[(cycle_index * table->colors_per_cycle) + color_index] = attr;
}
STATIC_OVL uint8_t
visuals_flicker_get_color(struct visuals_flicker* table,
                          size_t const cycle_index, size_t const color_index)
{
  if (table == NULL) {
    return 0;
  }
  if (cycle_index >= table->max_cycles) {
    return 0;
  }
  if (color_index >= table->colors_per_cycle) {
    return 0;
  }
  return table->cycles[(cycle_index * table->colors_per_cycle) + color_index];
}
STATIC_OVL uint8_t
visuals_flicker_get_attr_for_frame(uint8_t const selection_attr,
                                   size_t const frame)
{
  size_t color_index = 0;
  if (visuals_flicker_table == NULL) {
    return BASIC_COLORS;
  }
  if (selection_attr >= visuals_flicker_table->max_cycles) {
    return BASIC_COLORS;
  }
  color_index = frame % visuals_flicker_table->colors_per_cycle;
  return visuals_flicker_get_color(visuals_flicker_table, selection_attr,
                                   color_index);
}
STATIC_OVL struct visuals_parse_context*
visuals_parse_context_new(void)
{
  struct visuals_parse_context* context = mem_zalloc(sizeof(*context));
  if (context == NULL) {
    return NULL;
  }
  context->max_cycles = VISUALS_GROUPS_MAX * VISUALS_CYCLES_MAX + 1;
  context->cycles =
      mem_zalloc(context->max_cycles * sizeof(*(context->cycles)));
  if (context->cycles == NULL) {
    mem_free(context);
    return NULL;
  }
  context->max_groups = VISUALS_GROUPS_MAX;
  context->group_names =
      mem_zalloc(context->max_groups * sizeof(*(context->group_names)));
  if (context->group_names == NULL) {
    mem_free(context->cycles);
    mem_free(context);
    return NULL;
  }
  context->max_group_cycles = context->max_groups * VISUALS_CYCLES_MAX;
  context->group_cycles =
      mem_zalloc(context->max_group_cycles * sizeof(*(context->group_cycles)));
  if (context->group_cycles == NULL) {
    mem_free(context->group_names);
    mem_free(context->cycles);
    mem_free(context);
    return NULL;
  }
  context->cycles_index = 0;
  context->cycle_step_index = 0;
  context->flicker_color_index = 0;
  context->flicker_cycle_index = 0;
  return context;
}
STATIC_OVL void
visuals_parse_context_free(struct visuals_parse_context* context)
{
  size_t i = 0;
  if (context == NULL) {
    return;
  }
  if (context->cycles != NULL) {
    for (i = 0; i < context->max_cycles; i++) {
      visuals_color_cycle_free(context->cycles[i]);
    }
    mem_free(context->cycles);
    context->cycles = NULL;
  }
  if (context->group_names != NULL) {
    for (i = 0; i < context->max_groups; i++) {
      string_free(context->group_names[i]);
    }
    mem_free(context->group_names);
    context->group_names = NULL;
  }
  if (context->group_cycles != NULL) {
    mem_free(context->group_cycles);
    context->group_cycles = NULL;
  }
  mem_free(context);
  context = NULL;
}
STATIC_OVL struct visuals_cycler*
visuals_parse_context_convert(struct visuals_parse_context const* context)
{
  size_t group_count = 0;
  size_t group = 0;
  struct visuals_cycler* cycler = NULL;
  if (context == NULL) {
    return NULL;
  }
  while (context->group_names[group_count] != NULL) {
    group_count++;
  }
  cycler = visuals_cycler_new(group_count);
  if (cycler == NULL) {
    return NULL;
  }
  for (group = 0; group < group_count; group++) {
    size_t cycle_count = 0;
    size_t const cycle_offset = group * VISUALS_CYCLES_MAX;
    struct visuals_cycle_group* cycle_group = NULL;
    size_t ccycle = 0;
    while (context->group_cycles[cycle_offset + cycle_count] != NULL) {
      cycle_count++;
    }
    cycle_group =
        visuals_cycle_group_new(context->group_names[group], cycle_count);
    if (cycle_group == NULL) {
      return NULL;
    }
    for (ccycle = 0; ccycle < cycle_count; ccycle++) {
      struct visuals_color_cycle* old_cycle =
          context->group_cycles[cycle_offset + ccycle];
      cycle_group->cycles[ccycle] = visuals_color_cycle_copy(old_cycle);
      if (cycle_group->cycles[ccycle] == NULL) {
        return NULL;
      }
    }
    cycler->groups[group] = cycle_group;
  }
  return cycler;
}
STATIC_OVL enum parser_error
visuals_parse_flicker(struct parser* parser)
{
  struct visuals_parse_context* context = parser_priv(parser);
  const char* color_code = NULL;
  int attr = 0;
  if (context == NULL) {
    return PARSE_ERROR_INTERNAL;
  }
  color_code = parser_getsym(parser, "color");
  if (color_code == NULL || strlen(color_code) == 0) {
    return PARSE_ERROR_INVALID_COLOR;
  }
  attr = color_char_to_attr(color_code[0]);
  if (attr < 0) {
    return PARSE_ERROR_INVALID_COLOR;
  }
  context->flicker_cycle_index = (uint8_t)attr;
  context->flicker_color_index = 0;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
visuals_parse_flicker_color(struct parser* parser)
{
  struct visuals_parse_context* context = parser_priv(parser);
  const char* color_code = NULL;
  int attr = 0;
  if (context == NULL) {
    return PARSE_ERROR_INTERNAL;
  }
  color_code = parser_getsym(parser, "color");
  if (color_code == NULL || strlen(color_code) == 0) {
    return PARSE_ERROR_INVALID_COLOR;
  }
  attr = color_char_to_attr(color_code[0]);
  if (attr < 0) {
    return PARSE_ERROR_INVALID_COLOR;
  }
  visuals_flicker_set_color(visuals_flicker_table, context->flicker_cycle_index,
                            context->flicker_color_index, (uint8_t)attr);
  context->flicker_color_index++;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
visuals_parse_cycle(struct parser* parser)
{
  struct visuals_parse_context* context = parser_priv(parser);
  const char* parsed_group = NULL;
  const char* parsed_name = NULL;
  size_t i = 0;
  size_t current_group_index = 0;
  if (context == NULL) {
    return PARSE_ERROR_INTERNAL;
  }
  context->cycles_index++;
  if (context->cycles_index >= context->max_cycles) {
    return PARSE_ERROR_TOO_MANY_ENTRIES;
  }
  parsed_group = parser_getsym(parser, "group");
  if (parsed_group == NULL || strlen(parsed_group) == 0) {
    return PARSE_ERROR_INVALID_VALUE;
  }
  parsed_name = parser_getsym(parser, "name");
  if (parsed_name == NULL || strlen(parsed_name) == 0) {
    return PARSE_ERROR_INVALID_VALUE;
  }
  if (context->cycles[context->cycles_index] == NULL) {
    context->cycles[context->cycles_index] = visuals_color_cycle_new(
        parsed_name, VISUALS_STEPS_MAX, VISUALS_INVALID_COLOR);
    if (context->cycles[context->cycles_index] == NULL) {
      return PARSE_ERROR_INTERNAL;
    }
  }
  current_group_index = context->max_groups;
  for (i = 0; i < context->max_groups; i++) {
    if (context->group_names[i] == NULL) {
      context->group_names[i] = string_make(parsed_group);
      current_group_index = i;
      break;
    } else {
      const char* existing_group = context->group_names[i];
      if (existing_group != NULL && streq(parsed_group, existing_group)) {
        current_group_index = i;
        break;
      }
    }
  }
  for (i = 0; i < VISUALS_CYCLES_MAX; i++) {
    size_t offset = current_group_index * VISUALS_CYCLES_MAX + i;
    if (offset >= context->max_group_cycles) {
      continue;
    }
    if (context->group_cycles[offset] == NULL) {
      context->group_cycles[offset] = context->cycles[context->cycles_index];
      break;
    } else {
      const char* existing_name = context->group_cycles[offset]->cycle_name;
      if (existing_name != NULL && streq(parsed_name, existing_name)) {
        context->group_cycles[offset] = context->cycles[context->cycles_index];
        break;
      }
    }
  }
  context->cycle_step_index = 0;
  return PARSE_ERROR_NONE;
}
STATIC_OVL enum parser_error
visuals_parse_cycle_color(struct parser* parser)
{
  struct visuals_parse_context* context = parser_priv(parser);
  const char* color_code = NULL;
  int attr = 0;
  if (context == NULL) {
    return PARSE_ERROR_INTERNAL;
  }
  if (context->cycle_step_index >=
      context->cycles[context->cycles_index]->max_steps) {
    return PARSE_ERROR_TOO_MANY_ENTRIES;
  }
  color_code = parser_getsym(parser, "color");
  if (color_code == NULL || strlen(color_code) == 0) {
    return PARSE_ERROR_INVALID_COLOR;
  }
  attr = color_char_to_attr(color_code[0]);
  if (attr < 0) {
    return PARSE_ERROR_INVALID_COLOR;
  }
  context->cycles[context->cycles_index]->steps[context->cycle_step_index] =
      attr;
  context->cycle_step_index++;
  return PARSE_ERROR_NONE;
}
STATIC_OVL struct parser*
visuals_file_parser_init(void)
{
  struct visuals_parse_context* context = visuals_parse_context_new();
  struct parser* parser = parser_new();
  if (context == NULL || parser == NULL) {
    return NULL;
  }
  parser_setpriv(parser, context);
  parser_reg(parser, "flicker sym color str name", visuals_parse_flicker);
  parser_reg(parser, "flicker-color sym color", visuals_parse_flicker_color);
  parser_reg(parser, "cycle sym group sym name", visuals_parse_cycle);
  parser_reg(parser, "cycle-color sym color", visuals_parse_cycle_color);
  return parser;
}
STATIC_OVL errr
visuals_file_parser_run(struct parser* parser)
{
  return parse_file_quit_not_found(parser, "visuals");
}
STATIC_OVL errr
visuals_file_parser_finish(struct parser* parser)
{
  struct visuals_parse_context* context = parser_priv(parser);
  visuals_cycler_table = visuals_parse_context_convert(context);
  visuals_parse_context_free(context);
  parser_destroy(parser);
  return (visuals_cycler_table == NULL) ? PARSE_ERROR_INTERNAL
                                        : PARSE_ERROR_NONE;
}
STATIC_OVL void
visuals_file_parser_cleanup(void)
{
}
STATIC_OVL void
ui_visuals_module_init(void)
{
  event_signal_message(EVENT_INITSTATUS, 0, "Initializing visuals");
  visuals_flicker_table = visuals_flicker_new(MAX_COLORS, 3);
  if (visuals_flicker_table == NULL) {
    quit("Unable to allocate flicker table");
  }
  visuals_color_cycles_by_race =
      mem_zalloc(sizeof(*visuals_color_cycles_by_race));
  if (visuals_color_cycles_by_race == NULL) {
    quit("Unable to allocate race/color cycle table");
  }
  visuals_color_cycles_by_race->max_entries = 0;
  visuals_color_cycles_by_race->alloc_size = 100;
  if (run_parser(&visuals_file_parser)) {
    quit("Cannot initialize visuals");
  }
  if (visuals_file_parser.cleanup) {
    visuals_file_parser.cleanup();
  }
}
STATIC_OVL void
ui_visuals_module_cleanup(void)
{
  visuals_flicker_free(visuals_flicker_table);
  visuals_cycler_free(visuals_cycler_table);
  if (visuals_color_cycles_by_race != NULL) {
    if (visuals_color_cycles_by_race->race != NULL) {
      mem_free(visuals_color_cycles_by_race->race);
      visuals_color_cycles_by_race->race = NULL;
    }
    mem_free(visuals_color_cycles_by_race);
    visuals_color_cycles_by_race = NULL;
  }
}
STATIC_OVL void
proj_display(struct menu* m, int type, bool cursor, int row, int col, int wid)
{
  size_t i;
  uint8_t attr = curs_attrs[CURS_KNOWN][(int)cursor];
  const char* proj_name = proj_idx_to_name(type);
  if (type % 2) c_prt(attr, ".........................", row, col);
  c_put_str(attr, proj_name, row, col);
  col += 25;
  if (tile_height == 1) {
    for (i = 0; i < BOLT_MAX; i++) {
      if (use_graphics == GRAPHICS_NONE) {
        wchar_t chars[] = L"*|/-\\";
        col += big_pad(col, row, projections[type].color, chars[i]);
      } else {
        col += big_pad(col, row, proj_to_attr[type][i], proj_to_char[type][i]);
      }
    }
  } else {
    prt("Change tile_height to 1 to see graphics.", row, col);
  }
}
STATIC_OVL void
wiz_proj_demo(void)
{
  struct menu* m = menu_new(MN_SKIN_SCROLL, &proj_iter);
  region loc = {0, 0, 0, 0};
  menu_setpriv(m, PROJ_MAX, NULL);
  m->title = "PROJ_ types display";
  menu_layout(m, &loc);
  screen_save();
  clear_from(0);
  menu_select(m, 0, false);
  screen_load();
  mem_free(m);
}
STATIC_OVL void
get_art_name(char* buf, int max, int a_idx)
{
  struct object *obj, *known_obj;
  struct object_kind* kind;
  const struct artifact* art = &a_info[a_idx];
  obj = object_new();
  kind = lookup_kind(art->tval, art->sval);
  if (!kind) return;
  object_prep(obj, kind, 0, RANDOMISE);
  obj->artifact = art;
  known_obj = object_new();
  obj->known = known_obj;
  object_copy(known_obj, obj);
  known_obj->notice |= OBJ_NOTICE_IMAGINED;
  object_desc(buf, max, obj, ODESC_SINGULAR | ODESC_SPOIL, NULL);
  object_delete(NULL, NULL, &known_obj);
  obj->known = NULL;
  object_delete(NULL, NULL, &obj);
}
STATIC_OVL void
wiz_create_item_subdisplay(struct menu* m, int oid, bool cursor, int row,
                           int col, int width)
{
  int* choices = menu_priv(m);
  int selected = choices[oid];
  char buf[70];
  if (selected == -9999) {
    int current_tval = choices[oid + 1];
    char name[70];
    object_base_name(name, sizeof(name), current_tval, true);
    if (choose_artifact) {
      strnfmt(buf, sizeof(buf), "All artifact %s", name);
    } else {
      strnfmt(buf, sizeof(buf), "All %s", name);
    }
  } else {
    if (choose_artifact) {
      get_art_name(buf, sizeof(buf), selected);
    } else {
      object_kind_name(buf, sizeof(buf), &k_info[selected], true);
    }
  }
  c_prt(curs_attrs[CURS_KNOWN][0 != cursor], buf, row, col);
}
STATIC_OVL bool
wiz_create_item_subaction(struct menu* m, const ui_event* e, int oid)
{
  int* choices = menu_priv(m);
  int selected = choices[oid];
  if (e->type != EVT_SELECT) return true;
  if (selected == -9999 && !choose_artifact) {
    cmdq_push(CMD_WIZ_CREATE_ALL_OBJ_FROM_TVAL);
    cmd_set_arg_number(cmdq_peek(), "tval", choices[oid + 1]);
    cmd_set_arg_choice(cmdq_peek(), "choice", 0);
  } else if (selected == -9999 && choose_artifact) {
    cmdq_push(CMD_WIZ_CREATE_ALL_ARTIFACT_FROM_TVAL);
    cmd_set_arg_number(cmdq_peek(), "tval", choices[oid + 1]);
  } else if (selected != -9999 && !choose_artifact) {
    cmdq_push(CMD_WIZ_CREATE_OBJ);
    cmd_set_arg_number(cmdq_peek(), "index", choices[oid]);
  } else if (selected != -9999 && choose_artifact) {
    cmdq_push(CMD_WIZ_CREATE_ARTIFACT);
    cmd_set_arg_number(cmdq_peek(), "index", choices[oid]);
  }
  return false;
}
STATIC_OVL void
wiz_create_item_display(struct menu* m, int oid, bool cursor, int row, int col,
                        int width)
{
  char buf[80];
  if (oid == -9999) {
    if (choose_artifact) {
      my_strcpy(buf, "All artifacts", sizeof(buf));
    } else {
      my_strcpy(buf, "All objects", sizeof(buf));
    }
  } else {
    object_base_name(buf, sizeof(buf), oid, true);
  }
  c_prt(curs_attrs[CURS_KNOWN][0 != cursor], buf, row, col);
}
STATIC_OVL bool
wiz_create_item_action(struct menu* m, const ui_event* e, int oid)
{
  ui_event ret;
  struct menu* menu;
  char buf[80];
  char title[80];
  int choice[70];
  int num;
  int i;
  if (e->type != EVT_SELECT) return true;
  if (oid == -9999) {
    cmdq_push((choose_artifact) ? CMD_WIZ_CREATE_ALL_ARTIFACT
                                : CMD_WIZ_CREATE_ALL_OBJ);
    return false;
  }
  if (choose_artifact) {
    for (num = 0, i = 1; (num < 60) && (i < z_info->a_max); i++) {
      const struct artifact* art = &a_info[i];
      if (art->tval != oid) continue;
      choice[num++] = i;
    }
  } else {
    for (num = 0, i = 1; (num < 60) && (i < z_info->k_max); i++) {
      struct object_kind* kind = &k_info[i];
      if (kind->tval != oid || kf_has(kind->kind_flags, KF_INSTA_ART)) continue;
      choice[num++] = i;
    }
  }
  choice[num++] = -9999;
  choice[num] = oid;
  screen_save();
  clear_from(0);
  menu = menu_new(MN_SKIN_COLUMNS, &wiz_create_item_submenu);
  menu->selections = all_letters;
  object_base_name(buf, sizeof(buf), oid, true);
  if (choose_artifact) {
    strnfmt(title, sizeof(title), "Which artifact %s? ", buf);
  } else {
    strnfmt(title, sizeof(title), "What kind of %s?", buf);
  }
  menu->title = title;
  menu_setpriv(menu, num, choice);
  menu_layout(menu, &wiz_create_item_area);
  ret = menu_select(menu, 0, false);
  screen_load();
  mem_free(menu);
  return (ret.type == EVT_ESCAPE);
}
STATIC_OVL void
wiz_create_item(bool art)
{
  int tvals[TV_MAX];
  int i, n;
  struct menu* menu = menu_new(MN_SKIN_COLUMNS, &wiz_create_item_menu);
  choose_artifact = art;
  menu->selections = all_letters;
  menu->title = art ? "What kind of artifact?" : "What kind of object?";
  for (i = 0, n = 0; i < TV_MAX; i++) {
    if (!kb_info[i].name) continue;
    if (art) {
      int j;
      for (j = 1; j < z_info->a_max; j++) {
        const struct artifact* art_local = &a_info[j];
        if (art_local->tval == i) break;
      }
      if (j == z_info->a_max) continue;
    }
    tvals[n++] = i;
  }
  tvals[n++] = -9999;
  screen_save();
  clear_from(0);
  menu_setpriv(menu, TV_MAX, kb_info);
  menu_set_filter(menu, tvals, n);
  menu_layout(menu, &wiz_create_item_area);
  menu_select(menu, 0, false);
  screen_load();
  mem_free(menu);
  player->upkeep->redraw |= (PR_MAP | PR_ITEMLIST);
  handle_stuff(player);
}
STATIC_OVL void
wiz_confirm_quit_no_save(void)
{
  if (get_check("Really quit without saving? ")) {
    cmdq_push(CMD_WIZ_QUIT_NO_SAVE);
  }
}
STATIC_OVL void
wiz_create_artifact(void)
{
  wiz_create_item(true);
}
STATIC_OVL void
wiz_create_nonartifact(void)
{
  wiz_create_item(false);
}
STATIC_OVL void
wiz_acquire_good(void)
{
  cmdq_push(CMD_WIZ_ACQUIRE);
  cmd_set_arg_choice(cmdq_peek(), "choice", 0);
}
STATIC_OVL void
wiz_acquire_great(void)
{
  cmdq_push(CMD_WIZ_ACQUIRE);
  cmd_set_arg_choice(cmdq_peek(), "choice", 1);
}
STATIC_OVL void
wiz_create_all_for_tval(void)
{
  cmdq_push(CMD_WIZ_CREATE_ALL_OBJ_FROM_TVAL);
  cmd_set_arg_choice(cmdq_peek(), "choice", 1);
}
STATIC_OVL void
wiz_learn_all_object_kinds(void)
{
  cmdq_push(CMD_WIZ_LEARN_OBJECT_KINDS);
  cmd_set_arg_number(cmdq_peek(), "level", 100);
}
STATIC_OVL void
wiz_cheat_death(void)
{
  player->age = 1;
  player->noscore |= NOSCORE_WIZARD;
  player->is_dead = false;
  player->chp = player->mhp;
  player->csp = player->msp;
  (void)player_clear_timed(player, TMD_BLIND, true, false);
  (void)player_clear_timed(player, TMD_CONFUSED, true, false);
  (void)player_clear_timed(player, TMD_POISONED, true, false);
  (void)player_clear_timed(player, TMD_AFRAID, true, false);
  (void)player_clear_timed(player, TMD_ENTRANCED, true, false);
  (void)player_clear_timed(player, TMD_IMAGE, true, false);
  (void)player_clear_timed(player, TMD_STUN, true, false);
  (void)player_clear_timed(player, TMD_CUT, true, false);
  player_set_timed(player, TMD_FOOD, PY_FOOD_FULL - 1, false, false);
  my_strcpy(player->died_from, "Cheating death", sizeof(player->died_from));
  dungeon_change_level(player, 1);
}
STATIC_OVL void
spoiler_out_n_chars(int n, char c)
{
  while (--n >= 0) file_writec(fh, c);
}
STATIC_OVL void
spoiler_blanklines(int n)
{
  spoiler_out_n_chars(n, '\n');
}
STATIC_OVL void
spoiler_underline(const char* str, char c)
{
  text_out("%s", str);
  text_out("\n");
  spoiler_out_n_chars(strlen(str), c);
  text_out("\n");
}
STATIC_OVL void
kind_info(char* buf, size_t buf_len, char* dam, size_t dam_len, char* wgt,
          size_t wgt_len, int* lev, int32_t* val, int k)
{
  struct object_kind* kind = &k_info[k];
  struct object *obj = object_new(), *known_obj = object_new();
  int i;
  object_prep(obj, kind, 0, MAXIMISE);
  for (i = 0; i < OBJ_MOD_MAX; i++) obj->modifiers[i] = 0;
  obj->att = 0;
  obj->evn = 0;
  (*lev) = kind->level;
  object_copy(known_obj, obj);
  obj->known = known_obj;
  (*val) = object_value(obj);
  if (buf) {
    object_desc(buf, buf_len, obj, ODESC_BASE | ODESC_SPOIL, NULL);
  }
  if (wgt) strnfmt(wgt, wgt_len, "%3d.%d", obj->weight / 10, obj->weight % 10);
  if (!dam) {
    object_delete(NULL, NULL, &known_obj);
    object_delete(NULL, NULL, &obj);
    return;
  }
  dam[0] = '\0';
  if (tval_is_ammo(obj) || tval_is_melee_weapon(obj))
    strnfmt(dam, dam_len, "%dd%d", obj->dd, obj->ds);
  else if (tval_is_armor(obj))
    strnfmt(dam, dam_len, "%dd%d", obj->pd, obj->ps);
  object_delete(NULL, NULL, &known_obj);
  object_delete(NULL, NULL, &obj);
}
STATIC_OVL void
spoil_obj_desc(const char* fname)
{
  int i, k, s, t, n = 0;
  uint16_t* who;
  char buf[1024];
  char wgt[80];
  char dam[80];
  const char* format = "%-51s  %7s%6s%4s%9s\n";
  path_build(buf, sizeof(buf), ANGBAND_DIR_USER, fname);
  fh = file_open(buf, MODE_WRITE, FTYPE_TEXT);
  if (!fh) {
    msg("Cannot create spoiler file.");
    return;
  }
  who = mem_zalloc(z_info->r_max * sizeof(uint16_t));
  file_putf(fh, "Spoiler File -- Basic Items (%s)\n\n\n", buildid);
  file_putf(fh, format, "Description", "Dam/AC", "Wgt", "Lev", "Cost");
  file_putf(fh, format, "----------------------------------------", "------",
            "---", "---", "----");
  for (i = 0; true; i++) {
    if (group_item[i].name) {
      for (s = 0; s < n - 1; s++) {
        for (t = 0; t < n - 1; t++) {
          int i1 = t;
          int i2 = t + 1;
          int e1;
          int e2;
          int32_t t1;
          int32_t t2;
          kind_info(NULL, 0, NULL, 0, NULL, 0, &e1, &t1, who[i1]);
          kind_info(NULL, 0, NULL, 0, NULL, 0, &e2, &t2, who[i2]);
          if ((t1 > t2) || ((t1 == t2) && (e1 > e2))) {
            int tmp = who[i1];
            who[i1] = who[i2];
            who[i2] = tmp;
          }
        }
      }
      for (s = 0; s < n; s++) {
        int e;
        int32_t v;
        size_t u8len;
        kind_info(buf, sizeof(buf), dam, sizeof(dam), wgt, sizeof(wgt), &e, &v,
                  who[s]);
        u8len = utf8_strlen(buf);
        if (u8len < 51) {
          file_putf(fh, "  %s%*s", buf, (int)(51 - u8len), " ");
        } else {
          if (u8len > 51) {
            utf8_clipto(buf, 51);
          }
          file_putf(fh, "  %s", buf);
        }
        file_putf(fh, "%7s%6s%4d%9ld\n", dam, wgt, e, (long)(v));
      }
      n = 0;
      if (!group_item[i].tval) break;
      file_putf(fh, "\n\n%s\n\n", group_item[i].name);
    }
    for (k = 1; k < z_info->k_max; k++) {
      struct object_kind* kind = &k_info[k];
      if (kind->tval != group_item[i].tval) continue;
      if (kf_has(kind->kind_flags, KF_INSTA_ART)) continue;
      who[n++] = k;
    }
  }
  mem_free(who);
  if (!file_close(fh)) {
    msg("Cannot close spoiler file.");
    return;
  }
  msg("Successfully created a spoiler file.");
}
STATIC_OVL void
spoil_artifact(const char* fname)
{
  int i, j;
  char buf[1024];
  path_build(buf, sizeof(buf), ANGBAND_DIR_USER, fname);
  fh = file_open(buf, MODE_WRITE, FTYPE_TEXT);
  if (!fh) {
    msg("Cannot create spoiler file.");
    return;
  }
  text_out_hook = text_out_to_file;
  text_out_file = fh;
  spoiler_underline(format("Artifact Spoilers for %s", buildid), '=');
  text_out("\n Randart seed is %lu\n", (unsigned long)seed_randart);
  for (i = 0; group_artifact[i].tval; i++) {
    if (group_artifact[i].name) {
      spoiler_blanklines(2);
      spoiler_underline(group_artifact[i].name, '=');
      spoiler_blanklines(1);
    }
    for (j = 1; j < z_info->a_max; ++j) {
      const struct artifact* art = &a_info[j];
      struct artifact artc;
      char buf2[80];
      struct object *obj, *known_obj;
      if (art->tval != group_artifact[i].tval) continue;
      obj = object_new();
      known_obj = object_new();
      memcpy(&artc, art, sizeof(artc));
      artc.text = NULL;
      if (!make_fake_artifact(obj, &artc)) {
        object_delete(NULL, NULL, &known_obj);
        object_delete(NULL, NULL, &obj);
        continue;
      }
      object_copy(known_obj, obj);
      obj->known = known_obj;
      object_desc(buf2, sizeof(buf2), obj,
                  ODESC_PREFIX | ODESC_COMBAT | ODESC_EXTRA | ODESC_SPOIL,
                  NULL);
      spoiler_underline(buf2, '-');
      object_info_spoil(fh, obj, 80);
      text_out("\nLevel %u, Rarity %u, %d.%d lbs\n", art->level, art->rarity,
               (art->weight / 10), (art->weight % 10));
      spoiler_blanklines(2);
      object_delete(NULL, NULL, &known_obj);
      object_delete(NULL, NULL, &obj);
    }
  }
  if (!file_close(fh)) {
    msg("Cannot close spoiler file.");
    return;
  }
  msg("Successfully created a spoiler file.");
}
STATIC_OVL void
spoil_mon_desc(const char* fname)
{
  int i, n = 0;
  char buf[1024];
  char nam[80];
  char lev[80];
  char rar[80];
  char health[80];
  char prot[80];
  char graphics[80];
  uint16_t* who;
  path_build(buf, sizeof(buf), ANGBAND_DIR_USER, fname);
  fh = file_open(buf, MODE_WRITE, FTYPE_TEXT);
  if (!fh) {
    msg("Cannot create spoiler file.");
    return;
  }
  file_putf(fh, "Monster Spoilers for %s\n", buildid);
  file_putf(fh, "------------------------------------------\n\n");
  file_putf(fh, "%-40.40s%4s%4s%8s%8s  %11.11s\n", "Name", "Lev", "Rar", "Hit",
            "Prot", "Visual Info");
  file_putf(fh, "%-40.40s%4s%4s%8s%8s  %11.11s\n", "----", "---", "---", "---",
            "----", "-----------");
  who = mem_zalloc(z_info->r_max * sizeof(uint16_t));
  for (i = 1; i < z_info->r_max - 1; i++) {
    struct monster_race* race = &r_info[i];
    if (race->name) who[n++] = (uint16_t)i;
  }
  sort(who, n, sizeof(*who), cmp_monsters);
  for (i = 0; i < n; i++) {
    struct monster_race* race = &r_info[who[i]];
    const char* name = race->name;
    size_t u8len;
    if (rf_has(race->flags, RF_QUESTOR))
      strnfmt(nam, sizeof(nam), "[Q] %s", name);
    else if (rf_has(race->flags, RF_UNIQUE))
      strnfmt(nam, sizeof(nam), "[U] %s", name);
    else
      strnfmt(nam, sizeof(nam), "The %s", name);
    strnfmt(lev, sizeof(lev), "%d", race->level);
    strnfmt(rar, sizeof(rar), "%d", race->rarity);
    strnfmt(health, sizeof(health), "%dd%d", race->hdice, race->hside);
    strnfmt(prot, sizeof(prot), "%d:%dd%d", race->evn, race->pd, race->ps);
    strnfmt(graphics, sizeof(graphics), "%s '%c'", attr_to_text(race->d_attr),
            race->d_char);
    u8len = utf8_strlen(nam);
    if (u8len < 40) {
      file_putf(fh, "%s%*s", nam, (int)(40 - u8len), " ");
    } else {
      if (u8len > 40) {
        utf8_clipto(nam, 40);
      }
      file_putf(fh, "%s", nam);
    }
    file_putf(fh, "%4s%4s%8s%8s  %11.11s\n", lev, rar, health, prot, graphics);
  }
  file_putf(fh, "\n");
  mem_free(who);
  if (!file_close(fh)) {
    msg("Cannot close spoiler file.");
    return;
  }
  msg("Successfully created a spoiler file.");
}
STATIC_OVL void
spoil_mon_info(const char* fname)
{
  char buf[1024];
  int i, n;
  uint16_t* who;
  int count = 0;
  textblock* tb = NULL;
  path_build(buf, sizeof(buf), ANGBAND_DIR_USER, fname);
  fh = file_open(buf, MODE_WRITE, FTYPE_TEXT);
  if (!fh) {
    msg("Cannot create spoiler file.");
    return;
  }
  tb = textblock_new();
  textblock_append(tb, "Monster Spoilers for %s\n", buildid);
  textblock_append(tb, "------------------------------------------\n\n");
  textblock_to_file(tb, fh, 0, 75);
  textblock_free(tb);
  tb = NULL;
  who = mem_zalloc(z_info->r_max * sizeof(uint16_t));
  for (i = 1; i < z_info->r_max; i++) {
    struct monster_race* race = &r_info[i];
    if (race->name) who[count++] = (uint16_t)i;
  }
  sort(who, count, sizeof(*who), cmp_monsters);
  for (n = 0; n < count; n++) {
    int r_idx = who[n];
    const struct monster_race* race = &r_info[r_idx];
    const struct monster_lore* lore = &l_list[r_idx];
    tb = textblock_new();
    if (rf_has(race->flags, RF_QUESTOR))
      textblock_append(tb, "[Q] ");
    else if (rf_has(race->flags, RF_UNIQUE))
      textblock_append(tb, "[U] ");
    else
      textblock_append(tb, "The ");
    textblock_append(tb, "%s", race->name);
    textblock_append(tb, "  (");
    textblock_append(tb, "%s", attr_to_text(race->d_attr));
    textblock_append(tb, " '%c')\n", race->d_char);
    textblock_append(tb, "=== ");
    textblock_append(tb, "Num:%d  ", r_idx);
    textblock_append(tb, "Lev:%d  ", race->level);
    textblock_append(tb, "Rar:%d  ", race->rarity);
    if (race->speed >= 110)
      textblock_append(tb, "Spd:+%d  ", (race->speed - 110));
    else
      textblock_append(tb, "Spd:-%d  ", (110 - race->speed));
    textblock_append(tb, "Hp:%dd%d  ", race->hdice, race->hside);
    textblock_append(tb, "Prot:%d:%dd%d  ", race->evn, race->pd, race->ps);
    lore_description(tb, race, lore, true);
    textblock_append(tb, "\n");
    textblock_to_file(tb, fh, 0, 75);
    textblock_free(tb);
    tb = NULL;
  }
  mem_free(who);
  if (!file_close(fh)) {
    msg("Cannot close spoiler file.");
    return;
  }
  msg("Successfully created a spoiler file.");
}
STATIC_OVL bool
stats_are_enabled(void)
{
  msg("Statistics generation not turned on in this build.");
  return false;
}
STATIC_OVL void
stats_collect(int nsim, int simtype)
{
}
STATIC_OVL void
disconnect_stats(int nsim, bool stop_on_disconnect)
{
}
STATIC_OVL void
stat_grid_counter(struct chunk* c, struct grid_counter_pred* gpreds,
                  int n_gpred, struct neighbor_counter_pred* npreds,
                  int n_npred)
{
  int i;
  struct loc grid;
  for (i = 0; i < n_gpred; ++i) {
    gpreds[i].in_vault_count = 0;
    gpreds[i].in_room_count = 0;
    gpreds[i].in_other_count = 0;
  }
  for (i = 0; i < n_npred; ++i) {
    int j;
    for (j = 0; j < 9; ++j) {
      npreds[i].vault_histogram[j] = 0;
      npreds[i].room_histogram[j] = 0;
      npreds[i].other_histogram[j] = 0;
    }
  }
  for (grid.y = 0; grid.y < c->height; ++grid.y) {
    for (grid.x = 0; grid.x < c->width; ++grid.x) {
      if (square_isvault(c, grid)) {
        for (i = 0; i < n_gpred; ++i) {
          if ((*gpreds[i].pred)(c, grid)) {
            ++gpreds[i].in_vault_count;
          }
        }
        for (i = 0; i < n_npred; ++i) {
          if ((npreds[i].pred)(c, grid)) {
            int count = count_neighbors(NULL, c, grid, npreds[i].neigh, false);
            assert(count >= 0 && count <= 8);
            ++npreds[i].vault_histogram[count];
          }
        }
      } else if (square_isroom(c, grid)) {
        for (i = 0; i < n_gpred; ++i) {
          if ((*gpreds[i].pred)(c, grid)) {
            ++gpreds[i].in_room_count;
          }
        }
        for (i = 0; i < n_npred; ++i) {
          if ((npreds[i].pred)(c, grid)) {
            int count = count_neighbors(NULL, c, grid, npreds[i].neigh, false);
            assert(count >= 0 && count <= 8);
            ++npreds[i].room_histogram[count];
          }
        }
      } else {
        for (i = 0; i < n_gpred; ++i) {
          if ((*gpreds[i].pred)(c, grid)) {
            ++gpreds[i].in_other_count;
          }
        }
        for (i = 0; i < n_npred; ++i) {
          if ((npreds[i].pred)(c, grid)) {
            int count = count_neighbors(NULL, c, grid, npreds[i].neigh, false);
            assert(count >= 0 && count <= 8);
            ++npreds[i].other_histogram[count];
          }
        }
      }
    }
  }
}
STATIC_OVL bool
is_easily_traversed(struct chunk* c, struct loc grid)
{
  return square_ispassable(c, grid) || square_isdoor(c, grid) ||
         square_isrubble(c, grid);
}
STATIC_OVL bool
is_floor_trap(struct chunk* c, struct loc grid)
{
  return square_istrap(c, grid) && !square_iscloseddoor(c, grid);
}
STATIC_OVL void
stat_grid_counter_simple(struct chunk* c, struct grid_counts counts[3])
{
  struct grid_counter_pred gpreds[] = {
      {square_isfloor, 0, 0, 0},      {square_isupstairs, 0, 0, 0},
      {square_isdownstairs, 0, 0, 0}, {is_floor_trap, 0, 0, 0},
      {square_isforge, 0, 0, 0},      {square_isrubble, 0, 0, 0},
      {square_isopendoor, 0, 0, 0},   {square_iscloseddoor, 0, 0, 0},
      {square_isbrokendoor, 0, 0, 0}, {square_issecretdoor, 0, 0, 0},
  };
  struct neighbor_counter_pred npreds[] = {
      {is_easily_traversed,
       is_easily_traversed,
       {0, 0, 0, 0, 0, 0, 0, 0, 0},
       {0, 0, 0, 0, 0, 0, 0, 0, 0},
       {0, 0, 0, 0, 0, 0, 0, 0, 0}},
  };
  int i;
  stat_grid_counter(c, gpreds, (int)N_ELEMENTS(gpreds), npreds,
                    (int)N_ELEMENTS(npreds));
  counts[0].floor = gpreds[0].in_vault_count;
  counts[0].upstair = gpreds[1].in_vault_count;
  counts[0].downstair = gpreds[2].in_vault_count;
  counts[0].trap = gpreds[3].in_vault_count;
  counts[0].forge = gpreds[4].in_vault_count;
  counts[0].rubble = gpreds[5].in_vault_count;
  counts[0].open_door = gpreds[6].in_vault_count;
  counts[0].closed_door = gpreds[7].in_vault_count;
  counts[0].broken_door = gpreds[8].in_vault_count;
  counts[0].secret_door = gpreds[9].in_vault_count;
  for (i = 0; i < 9; ++i) {
    counts[0].traversable_neighbor_histogram[i] = npreds[0].vault_histogram[i];
  }
  counts[1].floor = gpreds[0].in_room_count;
  counts[1].upstair = gpreds[1].in_room_count;
  counts[1].downstair = gpreds[2].in_room_count;
  counts[1].trap = gpreds[3].in_room_count;
  counts[1].forge = gpreds[4].in_room_count;
  counts[1].rubble = gpreds[5].in_room_count;
  counts[1].open_door = gpreds[6].in_room_count;
  counts[1].closed_door = gpreds[7].in_room_count;
  counts[1].broken_door = gpreds[8].in_room_count;
  counts[1].secret_door = gpreds[9].in_room_count;
  for (i = 0; i < 9; ++i) {
    counts[1].traversable_neighbor_histogram[i] = npreds[0].room_histogram[i];
  }
  counts[2].floor = gpreds[0].in_other_count;
  counts[2].upstair = gpreds[1].in_other_count;
  counts[2].downstair = gpreds[2].in_other_count;
  counts[2].trap = gpreds[3].in_other_count;
  counts[2].forge = gpreds[4].in_other_count;
  counts[2].rubble = gpreds[5].in_other_count;
  counts[2].open_door = gpreds[6].in_other_count;
  counts[2].closed_door = gpreds[7].in_other_count;
  counts[2].broken_door = gpreds[8].in_other_count;
  counts[2].secret_door = gpreds[9].in_other_count;
  for (i = 0; i < 9; ++i) {
    counts[2].traversable_neighbor_histogram[i] = npreds[0].other_histogram[i];
  }
}
STATIC_OVL bool
flag_has(const bitflag* flags, const size_t size, const int flag)
{
  const size_t flag_offset = FLAG_OFFSET(flag);
  const int flag_binary = FLAG_BINARY(flag);
  if (flag == FLAG_END) return false;
  assert(flag_offset < size);
  if (flags[flag_offset] & flag_binary) return true;
  return false;
}
STATIC_OVL bool
flag_has_dbg(const bitflag* flags, const size_t size, const int flag,
             const char* fi, const char* fl)
{
  const size_t flag_offset = FLAG_OFFSET(flag);
  const int flag_binary = FLAG_BINARY(flag);
  if (flag == FLAG_END) return false;
  if (flag_offset >= size) {
    quit_fmt(
        "Error in flag_has(%s, %s): FlagID[%d] Size[%u] FlagOff[%u] "
        "FlagBV[%d]\n",
        fi, fl, flag, (unsigned int)size, (unsigned int)flag_offset,
        flag_binary);
  }
  if (flags[flag_offset] & flag_binary) return true;
  return false;
}
STATIC_OVL int
flag_next(const bitflag* flags, const size_t size, const int flag)
{
  const int max_flags = FLAG_MAX(size);
  int f, flag_offset, flag_binary;
  for (f = flag; f < max_flags; f++) {
    flag_offset = FLAG_OFFSET(f);
    flag_binary = FLAG_BINARY(f);
    if (flags[flag_offset] & flag_binary) return f;
  }
  return FLAG_END;
}
STATIC_OVL int
flag_count(const bitflag* flags, const size_t size)
{
  size_t i, j;
  int count = 0;
  for (i = 0; i < size; i++) {
    for (j = 1; j <= FLAG_WIDTH; j++) {
      if (flags[i] & FLAG_BINARY(j)) {
        count++;
      }
    }
  }
  return count;
}
STATIC_OVL bool
flag_is_empty(const bitflag* flags, const size_t size)
{
  size_t i;
  for (i = 0; i < size; i++)
    if (flags[i] > 0) return false;
  return true;
}
STATIC_OVL bool
flag_is_full(const bitflag* flags, const size_t size)
{
  size_t i;
  for (i = 0; i < size; i++)
    if (flags[i] != (bitflag)-1) return false;
  return true;
}
STATIC_OVL bool
flag_is_inter(const bitflag* flags1, const bitflag* flags2, const size_t size)
{
  size_t i;
  for (i = 0; i < size; i++)
    if (flags1[i] & flags2[i]) return true;
  return false;
}
STATIC_OVL bool
flag_is_subset(const bitflag* flags1, const bitflag* flags2, const size_t size)
{
  size_t i;
  for (i = 0; i < size; i++)
    if (~flags1[i] & flags2[i]) return false;
  return true;
}
STATIC_OVL bool
flag_is_equal(const bitflag* flags1, const bitflag* flags2, const size_t size)
{
  return (!memcmp(flags1, flags2, size * sizeof(bitflag)));
}
STATIC_OVL bool
flag_on(bitflag* flags, const size_t size, const int flag)
{
  const size_t flag_offset = FLAG_OFFSET(flag);
  const int flag_binary = FLAG_BINARY(flag);
  assert(flag_offset < size);
  if (flags[flag_offset] & flag_binary) return false;
  flags[flag_offset] |= flag_binary;
  return true;
}
STATIC_OVL bool
flag_on_dbg(bitflag* flags, const size_t size, const int flag, const char* fi,
            const char* fl)
{
  const size_t flag_offset = FLAG_OFFSET(flag);
  const int flag_binary = FLAG_BINARY(flag);
  if (flag_offset >= size) {
    quit_fmt(
        "Error in flag_on(%s, %s): FlagID[%d] Size[%u] FlagOff[%u] "
        "FlagBV[%d]\n",
        fi, fl, flag, (unsigned int)size, (unsigned int)flag_offset,
        flag_binary);
  }
  assert(flag_offset < size);
  if (flags[flag_offset] & flag_binary) return false;
  flags[flag_offset] |= flag_binary;
  return true;
}
STATIC_OVL bool
flag_off(bitflag* flags, const size_t size, const int flag)
{
  const size_t flag_offset = FLAG_OFFSET(flag);
  const int flag_binary = FLAG_BINARY(flag);
  assert(flag_offset < size);
  if (!(flags[flag_offset] & flag_binary)) return false;
  flags[flag_offset] &= ~flag_binary;
  return true;
}
STATIC_OVL void
flag_wipe(bitflag* flags, const size_t size)
{
  memset(flags, 0, size * sizeof(bitflag));
}
STATIC_OVL void
flag_setall(bitflag* flags, const size_t size)
{
  memset(flags, 255, size * sizeof(bitflag));
}
STATIC_OVL void
flag_negate(bitflag* flags, const size_t size)
{
  size_t i;
  for (i = 0; i < size; i++) flags[i] = ~flags[i];
}
STATIC_OVL void
flag_copy(bitflag* flags1, const bitflag* flags2, const size_t size)
{
  memcpy(flags1, flags2, size * sizeof(bitflag));
}
STATIC_OVL bool
flag_union(bitflag* flags1, const bitflag* flags2, const size_t size)
{
  size_t i;
  bool delta = false;
  for (i = 0; i < size; i++) {
    if (~flags1[i] & flags2[i]) delta = true;
    flags1[i] |= flags2[i];
  }
  return delta;
}
STATIC_OVL bool
flag_inter(bitflag* flags1, const bitflag* flags2, const size_t size)
{
  size_t i;
  bool delta = false;
  for (i = 0; i < size; i++) {
    if (!(flags1[i] == flags2[i])) delta = true;
    flags1[i] &= flags2[i];
  }
  return delta;
}
STATIC_OVL bool
flag_diff(bitflag* flags1, const bitflag* flags2, const size_t size)
{
  size_t i;
  bool delta = false;
  for (i = 0; i < size; i++) {
    if (flags1[i] & flags2[i]) delta = true;
    flags1[i] &= ~flags2[i];
  }
  return delta;
}
STATIC_OVL bool
flags_test(const bitflag* flags, const size_t size, ...)
{
  size_t flag_offset;
  int flag_binary;
  int f;
  va_list args;
  bool delta = false;
  va_start(args, size);
  for (f = va_arg(args, int); f != FLAG_END; f = va_arg(args, int)) {
    flag_offset = FLAG_OFFSET(f);
    flag_binary = FLAG_BINARY(f);
    assert(flag_offset < size);
    if (flags[flag_offset] & flag_binary) {
      delta = true;
      break;
    }
  }
  va_end(args);
  return delta;
}
STATIC_OVL bool
flags_test_all(const bitflag* flags, const size_t size, ...)
{
  size_t flag_offset;
  int flag_binary;
  int f;
  va_list args;
  bool delta = true;
  va_start(args, size);
  for (f = va_arg(args, int); f != FLAG_END; f = va_arg(args, int)) {
    flag_offset = FLAG_OFFSET(f);
    flag_binary = FLAG_BINARY(f);
    assert(flag_offset < size);
    if (!(flags[flag_offset] & flag_binary)) {
      delta = false;
      break;
    }
  }
  va_end(args);
  return delta;
}
STATIC_OVL bool
flags_clear(bitflag* flags, const size_t size, ...)
{
  size_t flag_offset;
  int flag_binary;
  int f;
  va_list args;
  bool delta = false;
  va_start(args, size);
  for (f = va_arg(args, int); f != FLAG_END; f = va_arg(args, int)) {
    flag_offset = FLAG_OFFSET(f);
    flag_binary = FLAG_BINARY(f);
    assert(flag_offset < size);
    if (flags[flag_offset] & flag_binary) delta = true;
    flags[flag_offset] &= ~flag_binary;
  }
  va_end(args);
  return delta;
}
STATIC_OVL bool
flags_set(bitflag* flags, const size_t size, ...)
{
  size_t flag_offset;
  int flag_binary;
  int f;
  va_list args;
  bool delta = false;
  va_start(args, size);
  for (f = va_arg(args, int); f != FLAG_END; f = va_arg(args, int)) {
    flag_offset = FLAG_OFFSET(f);
    flag_binary = FLAG_BINARY(f);
    assert(flag_offset < size);
    if (!(flags[flag_offset] & flag_binary)) delta = true;
    flags[flag_offset] |= flag_binary;
  }
  va_end(args);
  return delta;
}
STATIC_OVL void
flags_init(bitflag* flags, const size_t size, ...)
{
  int f;
  va_list args;
  flag_wipe(flags, size);
  va_start(args, size);
  for (f = va_arg(args, int); f != FLAG_END; f = va_arg(args, int))
    flag_on(flags, size, f);
  va_end(args);
}
STATIC_OVL bool
flags_mask(bitflag* flags, const size_t size, ...)
{
  int f;
  va_list args;
  bool delta = false;
  bitflag* mask;
  mask = mem_zalloc(size * sizeof(bitflag));
  va_start(args, size);
  for (f = va_arg(args, int); f != FLAG_END; f = va_arg(args, int))
    flag_on(mask, size, f);
  va_end(args);
  delta = flag_inter(flags, mask, size);
  mem_free(mask);
  return delta;
}
STATIC_OVL int
color_char_to_attr(char c)
{
  int a;
  if (c < 0) return (c);
  if (c == '\0' || c == ' ') return (COLOUR_DARK);
  for (a = 0; a < BASIC_COLORS; a++) {
    if (color_table[a].index_char == c) break;
  }
  if (a == BASIC_COLORS) return (COLOUR_WHITE);
  return (a);
}
STATIC_OVL int
color_text_to_attr(const char* name)
{
  int a;
  for (a = 0; a < MAX_COLORS; a++) {
    if (my_stricmp(name, color_table[a].name) == 0) return (a);
  }
  return (COLOUR_WHITE);
}
STATIC_OVL const char*
attr_to_text(uint8_t a)
{
  if (a < BASIC_COLORS)
    return (color_table[a].name);
  else
    return ("Icky");
}
STATIC_OVL uint8_t
get_color(uint8_t a, int attr, int n)
{
  if (a & (0x80)) return (a);
  if (!attr) return (a);
  while (n > 0) {
    a = color_table[a].color_translate[attr];
    n--;
  }
  return (a);
}
STATIC_OVL void
build_gamma_table(int gamma)
{
  int i, n;
  long value, diff;
  gamma_table[0] = 0;
  gamma_table[255] = 255;
  for (i = 1; i < 255; i++) {
    n = 1;
    value = 256L * 256L;
    diff = ((long)gamma_helper[i]) * (gamma - 256);
    while (diff) {
      value += diff;
      n++;
      diff = (((diff / 256) * gamma_helper[i]) * (gamma - 256)) / (256 * n);
    }
    gamma_table[i] = (uint8_t)(((long)(value / 256) * i) / 256);
  }
}
STATIC_OVL dice_input_t
dice_input_for_char(char c)
{
  switch (c) {
    case '&':
      return DICE_INPUT_AMP;
    case '-':
      return DICE_INPUT_MINUS;
    case '+':
      return DICE_INPUT_BASE;
    case 'd':
      return DICE_INPUT_DICE;
    case 'M':
    case 'm':
      return DICE_INPUT_BONUS;
    case '$':
      return DICE_INPUT_VAR;
    case '\0':
      return DICE_INPUT_NULL;
    default:
      break;
  }
  if (isdigit(c)) return DICE_INPUT_DIGIT;
  if (isupper(c)) return DICE_INPUT_UPPER;
  return DICE_INPUT_MAX;
}
STATIC_OVL dice_state_t
dice_parse_state_transition(dice_state_t state, dice_input_t input)
{
  static unsigned char state_table[DICE_STATE_MAX][DICE_INPUT_MAX] = {
      ".B.EHKB..", "..CE..B.C", "...EHKD..", "...E..D..", ".....KF..",
      "G...H.F.G", "....H....", ".....KI..", "......I.J", ".........",
      ".......L.", "G.CEH..LM", "........."};
  if (state == DICE_STATE_MAX || input == DICE_INPUT_MAX) return DICE_STATE_MAX;
  if (state_table[state][input] == '.') return DICE_STATE_MAX;
  return state_table[state][input] - 'A';
}
STATIC_OVL void
dice_reset(dice_t* dice)
{
  int i;
  dice->b = 0;
  dice->x = 0;
  dice->y = 0;
  dice->m = 0;
  dice->ex_b = false;
  dice->ex_x = false;
  dice->ex_y = false;
  dice->ex_m = false;
  if (dice->expressions == NULL) return;
  for (i = 0; i < 4; i++) {
    if (dice->expressions[i].name != NULL) {
      string_free((char*)dice->expressions[i].name);
      dice->expressions[i].name = NULL;
    }
    if (dice->expressions[i].expression != NULL) {
      expression_free((expression_t*)dice->expressions[i].expression);
      dice->expressions[i].expression = NULL;
    }
  }
}
STATIC_OVL dice_t*
dice_new(void)
{
  dice_t* dice = mem_zalloc(sizeof(dice_t));
  if (dice == NULL) return NULL;
  dice_reset(dice);
  return dice;
}
STATIC_OVL void
dice_free(dice_t* dice)
{
  if (dice == NULL) return;
  dice_reset(dice);
  if (dice->expressions != NULL) {
    mem_free(dice->expressions);
    dice->expressions = NULL;
  }
  mem_free(dice);
}
STATIC_OVL int
dice_add_variable(dice_t* dice, const char* name)
{
  int i;
  if (dice->expressions == NULL) {
    dice->expressions = mem_zalloc(4 * sizeof(dice_expression_entry_t));
  }
  for (i = 0; i < 4; i++) {
    if (dice->expressions[i].name == NULL) {
      dice->expressions[i].name = string_make(name);
      return i;
    } else if (my_stricmp(dice->expressions[i].name, name) == 0) {
      return i;
    }
  }
  return -1;
}
STATIC_OVL int
dice_bind_expression(dice_t* dice, const char* name,
                     const expression_t* expression)
{
  int i;
  if (dice->expressions == NULL) return -1;
  for (i = 0; i < 4; i++) {
    if (dice->expressions[i].name == NULL) continue;
    if (my_stricmp(name, dice->expressions[i].name) == 0) {
      dice->expressions[i].expression = expression_copy(expression);
      if (dice->expressions[i].expression == NULL) return -1;
      return i;
    }
  }
  return -1;
}
STATIC_OVL bool
dice_parse_string(dice_t* dice, const char* string)
{
  char token[16 + 1] = {'\0'};
  size_t token_end = 0;
  size_t current = 0;
  dice_state_t state = 0;
  enum last_seen_e {
    DICE_SEEN_NONE,
    DICE_SEEN_BASE,
    DICE_SEEN_DICE,
    DICE_SEEN_SIDE,
    DICE_SEEN_BONUS,
  } last_seen = DICE_SEEN_NONE;
  if (dice == NULL || string == NULL) return false;
  dice_reset(dice);
  for (current = 0; current <= strlen(string); current++) {
    bool flush;
    dice_input_t input_type = DICE_INPUT_MAX;
    if (isspace(string[current])) continue;
    input_type = dice_input_for_char(string[current]);
    switch (input_type) {
      case DICE_INPUT_AMP:
      case DICE_INPUT_BASE:
      case DICE_INPUT_DICE:
      case DICE_INPUT_VAR:
      case DICE_INPUT_NULL:
        state = dice_parse_state_transition(state, input_type);
        break;
      case DICE_INPUT_MINUS:
      case DICE_INPUT_DIGIT:
      case DICE_INPUT_UPPER:
        if (token_end < 16) {
          token[token_end] = string[current];
          token_end++;
        }
        state = dice_parse_state_transition(state, input_type);
        break;
      default:
        break;
    }
    if (string[current] == 'M') {
      if (state == DICE_STATE_VAR || state == DICE_STATE_VAR_CHAR) {
        if (token_end < 16) {
          token[token_end] = string[current];
          token_end++;
        }
        state = dice_parse_state_transition(state, DICE_INPUT_UPPER);
      } else
        state = dice_parse_state_transition(state, DICE_INPUT_BONUS);
    } else if (string[current] == 'm') {
      state = dice_parse_state_transition(state, DICE_INPUT_BONUS);
    }
    if (state >= DICE_STATE_MAX) return false;
    flush = true;
    switch (state) {
      case DICE_STATE_FLUSH_BASE:
        last_seen = DICE_SEEN_BASE;
        break;
      case DICE_STATE_FLUSH_DICE:
        last_seen = DICE_SEEN_DICE;
        if (strlen(token) == 0) {
          token[0] = '1';
          token[1] = '\0';
        }
        break;
      case DICE_STATE_FLUSH_SIDE:
        last_seen = DICE_SEEN_SIDE;
        break;
      case DICE_STATE_FLUSH_BONUS:
        last_seen = DICE_SEEN_BONUS;
        break;
      case DICE_STATE_FLUSH_ALL:
        if (last_seen < DICE_SEEN_BONUS) last_seen++;
        break;
      case DICE_STATE_BONUS:
        if (last_seen == DICE_SEEN_DICE)
          last_seen = DICE_SEEN_SIDE;
        else
          last_seen = DICE_SEEN_BONUS;
        break;
      default:
        flush = false;
        break;
    }
    if (flush && strlen(token) > 0) {
      int value = 0;
      bool is_variable = false;
      if (isupper(token[0])) {
        value = dice_add_variable(dice, token);
        is_variable = true;
      } else {
        value = (int)strtol(token, NULL, 0);
        is_variable = false;
      }
      switch (last_seen) {
        case DICE_SEEN_BASE:
          dice->b = value;
          dice->ex_b = is_variable;
          break;
        case DICE_SEEN_DICE:
          dice->x = value;
          dice->ex_x = is_variable;
          break;
        case DICE_SEEN_SIDE:
          dice->y = value;
          dice->ex_y = is_variable;
          break;
        case DICE_SEEN_BONUS:
          dice->m = value;
          dice->ex_m = is_variable;
          break;
        default:
          break;
      }
      memset(token, 0, 16 + 1);
      token_end = 0;
    }
  }
  return true;
}
STATIC_OVL void
dice_random_value(const dice_t* dice, random_value* v)
{
  if (v == NULL) return;
  if (dice->ex_b) {
    if (dice->expressions != NULL &&
        dice->expressions[dice->b].expression != NULL)
      v->base = expression_evaluate(dice->expressions[dice->b].expression);
    else
      v->base = 0;
  } else
    v->base = dice->b;
  if (dice->ex_x) {
    if (dice->expressions != NULL &&
        dice->expressions[dice->x].expression != NULL)
      v->dice = expression_evaluate(dice->expressions[dice->x].expression);
    else
      v->dice = 0;
  } else
    v->dice = dice->x;
  if (dice->ex_y) {
    if (dice->expressions != NULL &&
        dice->expressions[dice->y].expression != NULL)
      v->sides = expression_evaluate(dice->expressions[dice->y].expression);
    else
      v->sides = 0;
  } else
    v->sides = dice->y;
  if (dice->ex_m) {
    if (dice->expressions != NULL &&
        dice->expressions[dice->m].expression != NULL)
      v->m_bonus = expression_evaluate(dice->expressions[dice->m].expression);
    else
      v->m_bonus = 0;
  } else
    v->m_bonus = dice->m;
}
STATIC_OVL int
dice_evaluate(const dice_t* dice, int level, aspect asp, random_value* v)
{
  random_value rv;
  dice_random_value(dice, &rv);
  if (v != NULL) {
    v->base = rv.base;
    v->dice = rv.dice;
    v->sides = rv.sides;
    v->m_bonus = rv.m_bonus;
  }
  return randcalc(rv, level, asp);
}
STATIC_OVL int
dice_roll(const dice_t* dice, random_value* v)
{
  random_value rv;
  dice_random_value(dice, &rv);
  if (v != NULL) {
    v->base = rv.base;
    v->dice = rv.dice;
    v->sides = rv.sides;
    v->m_bonus = rv.m_bonus;
  }
  return rv.base + damroll(rv.dice, rv.sides);
}
STATIC_OVL bool
dice_test_values(const dice_t* dice, int base, int dice_count, int sides,
                 int bonus)
{
  bool success = true;
  success &= dice->b == base;
  success &= dice->x == dice_count;
  success &= dice->y == sides;
  success &= dice->m == bonus;
  return success;
}
STATIC_OVL bool
dice_test_variables(const dice_t* dice, const char* base, const char* dice_name,
                    const char* sides, const char* bonus)
{
  bool success = true;
  if (dice->expressions == NULL) return false;
  if (base == NULL)
    success &= !dice->ex_b;
  else
    success &= (dice->ex_b && dice->b >= 0 &&
                my_stricmp(dice->expressions[dice->b].name, base) == 0);
  if (dice_name == NULL)
    success &= !dice->ex_x;
  else
    success &= (dice->ex_x && dice->x >= 0 &&
                my_stricmp(dice->expressions[dice->x].name, dice_name) == 0);
  if (sides == NULL)
    success &= !dice->ex_y;
  else
    success &= (dice->ex_y && dice->y >= 0 &&
                my_stricmp(dice->expressions[dice->y].name, sides) == 0);
  if (bonus == NULL)
    success &= !dice->ex_m;
  else
    success &= (dice->ex_m && dice->m >= 0 &&
                my_stricmp(dice->expressions[dice->m].name, bonus) == 0);
  return success;
}
STATIC_OVL void
dict_depth_first_recurse(dict_type d,
                         void (*element_visitor)(dict_type d,
                                                 struct dict_list_entry* e,
                                                 void* closure),
                         void* element_closure)
{
  int i;
  for (i = 0; i < (int)N_ELEMENTS(d->lists); ++i) {
    struct dict_list_entry* entry = d->lists[i];
    while (entry) {
      struct dict_list_entry* next_entry = entry->next;
      (*element_visitor)(d, entry, element_closure);
      entry = next_entry;
    }
  }
}
STATIC_OVL void
dict_free_element(dict_type d, struct dict_list_entry* e, void* closure)
{
  if (d->value_freer) {
    (*d->value_freer)(e->value);
  }
  if (d->key_freer) {
    (*d->key_freer)(e->key);
  }
  mem_free(e);
}
STATIC_OVL dict_type
dict_create(uint32_t (*key_hasher)(const void* key),
            int (*key_comparer)(const void* a, const void* b),
            void (*key_freer)(void* key), void (*value_freer)(void* value))
{
  dict_type d = (struct dict_impl*)mem_zalloc(sizeof(struct dict_impl));
  d->key_hasher = key_hasher;
  d->key_comparer = key_comparer;
  d->key_freer = key_freer;
  d->value_freer = value_freer;
  return d;
}
STATIC_OVL void
dict_destroy(dict_type d)
{
  if (d) {
    dict_depth_first_recurse(d, dict_free_element, NULL);
    mem_free(d);
  }
}
STATIC_OVL bool
dict_insert(dict_type d, void* key, void* value)
{
  uint32_t hash, ind;
  struct dict_list_entry* entry;
  if (!d || !value) {
    return false;
  }
  hash = (*d->key_hasher)(key);
  ind = hash % (uint32_t)N_ELEMENTS(d->lists);
  entry = d->lists[ind];
  while (entry) {
    if (!(*d->key_comparer)(key, entry->key)) {
      return false;
    }
    entry = entry->next;
  }
  entry = mem_alloc(sizeof(*entry));
  entry->key = key;
  entry->value = value;
  entry->next = d->lists[ind];
  d->lists[ind] = entry;
  return true;
}
STATIC_OVL void*
dict_has(dict_type d, const void* key)
{
  uint32_t hash, ind;
  struct dict_list_entry* entry;
  if (!d) {
    return NULL;
  }
  hash = (*d->key_hasher)(key);
  ind = hash % (uint32_t)N_ELEMENTS(d->lists);
  entry = d->lists[ind];
  while (entry) {
    if (!(*d->key_comparer)(key, entry->key)) {
      return entry->value;
    }
    entry = entry->next;
  }
  return NULL;
}
STATIC_OVL expression_operator_t
expression_operator_from_token(const char* token)
{
  expression_operator_t result;
  switch (token[0]) {
    case '+':
      result = OPERATOR_ADD;
      break;
    case '-':
      result = OPERATOR_SUB;
      break;
    case '*':
      result = OPERATOR_MUL;
      break;
    case '/':
      result = OPERATOR_DIV;
      break;
    case 'n':
    case 'N':
      result = OPERATOR_NEG;
      break;
    default:
      return OPERATOR_NONE;
  }
  return (token[1]) ? OPERATOR_NONE : result;
}
STATIC_OVL expression_input_t
expression_input_for_operator(expression_operator_t operator)
{
  switch (operator) {
    case OPERATOR_NONE:
      return EXPRESSION_INPUT_INVALID;
    case OPERATOR_ADD:
    case OPERATOR_SUB:
    case OPERATOR_MUL:
    case OPERATOR_DIV:
      return EXPRESSION_INPUT_NEEDS_OPERANDS;
    case OPERATOR_NEG:
      return EXPRESSION_INPUT_UNARY_OPERATOR;
  }
  return EXPRESSION_INPUT_INVALID;
}
STATIC_OVL expression_t*
expression_new(void)
{
  expression_t* expression = mem_alloc(sizeof(expression_t));
  if (expression == NULL) return NULL;
  expression->base_value = NULL;
  expression->operation_count = 0;
  expression->operations_size = 5;
  expression->operations =
      mem_zalloc(expression->operations_size * sizeof(expression_operation_t));
  expression->fixed_base = 0;
  if (expression->operations == NULL) {
    mem_free(expression);
    return NULL;
  }
  return expression;
}
STATIC_OVL void
expression_free(expression_t* expression)
{
  if (expression == NULL) return;
  if (expression->operations != NULL) {
    mem_free(expression->operations);
    expression->operations = NULL;
  }
  mem_free(expression);
}
STATIC_OVL expression_t*
expression_copy(const expression_t* source)
{
  size_t i;
  expression_t* copy = mem_zalloc(sizeof(expression_t));
  if (copy == NULL) return NULL;
  copy->base_value = source->base_value;
  copy->operation_count = source->operation_count;
  copy->operations_size = source->operations_size;
  copy->fixed_base = source->fixed_base;
  if (copy->operations_size == 0) {
    copy->operations = NULL;
    return copy;
  }
  copy->operations =
      mem_zalloc(copy->operations_size * sizeof(expression_operation_t));
  if (copy->operations == NULL && source->operations != NULL) {
    mem_free(copy);
    return NULL;
  }
  for (i = 0; i < copy->operation_count; i++) {
    copy->operations[i].operand = source->operations[i].operand;
    copy->operations[i].operator= source->operations[i].operator;
  }
  return copy;
}
STATIC_OVL void
expression_set_fixed_base(expression_t* expression, int32_t value)
{
  expression->fixed_base = value;
}
STATIC_OVL void
expression_set_base_value(expression_t* expression,
                          expression_base_value_f function)
{
  expression->base_value = function;
}
STATIC_OVL int32_t
expression_evaluate(expression_t const* const expression)
{
  size_t i;
  int32_t value = expression->fixed_base;
  if (expression->base_value != NULL) value = expression->base_value();
  for (i = 0; i < expression->operation_count; i++) {
    switch (expression->operations[i].operator) {
      case OPERATOR_ADD:
        value += expression->operations[i].operand;
        break;
      case OPERATOR_SUB:
        value -= expression->operations[i].operand;
        break;
      case OPERATOR_MUL:
        value *= expression->operations[i].operand;
        break;
      case OPERATOR_DIV:
        value /= expression->operations[i].operand;
        break;
      case OPERATOR_NEG:
        value = -value;
        break;
      default:
        break;
    }
  }
  return value;
}
STATIC_OVL void
expression_add_operation(expression_t* expression,
                         const expression_operation_t operation)
{
  if (expression->operation_count >= expression->operations_size) {
    expression->operations_size += 5;
    expression->operations =
        mem_realloc(expression->operations, expression->operations_size *
                                                sizeof(expression_operation_t));
  }
  expression->operations[expression->operation_count] = operation;
  expression->operation_count++;
}
STATIC_OVL int16_t
expression_add_operations_string(expression_t* expression, const char* string)
{
  char* parse_string;
  expression_operation_t operations[50];
  int16_t count = 0, i = 0, nmax = 50;
  char* token = NULL;
  expression_operator_t parsed_operator = OPERATOR_NONE;
  expression_operator_t current_operator = OPERATOR_NONE;
  expression_input_t current_input = EXPRESSION_INPUT_INVALID;
  int state = EXPRESSION_STATE_START;
  static int state_table[EXPRESSION_STATE_MAX][EXPRESSION_INPUT_MAX] = {
      {
          EXPRESSION_ERR_INVALID_OPERATOR,
          EXPRESSION_STATE_OPERATOR,
          EXPRESSION_STATE_START,
          EXPRESSION_ERR_EXPECTED_OPERATOR,
      },
      {
          EXPRESSION_ERR_INVALID_OPERATOR,
          EXPRESSION_ERR_EXPECTED_OPERAND,
          EXPRESSION_ERR_EXPECTED_OPERAND,
          EXPRESSION_STATE_OPERAND,
      },
      {
          EXPRESSION_ERR_INVALID_OPERATOR,
          EXPRESSION_STATE_OPERATOR,
          EXPRESSION_STATE_START,
          EXPRESSION_STATE_OPERAND,
      },
  };
  if (expression == NULL || string == NULL) return EXPRESSION_ERR_GENERIC;
  if (my_stricmp(string, "") == 0) return 0;
  parse_string = string_make(string);
  token = strtok(parse_string, " ");
  while (token != NULL) {
    char* end = NULL;
    long value = strtol(token, &end, 0);
    if (end == token) {
      parsed_operator = expression_operator_from_token(token);
      current_input = expression_input_for_operator(parsed_operator);
      state = state_table[state][current_input];
    } else {
      state = state_table[state][EXPRESSION_INPUT_VALUE];
    }
    if (state < EXPRESSION_STATE_START) {
      string_free(parse_string);
      return state;
    } else if (state == EXPRESSION_STATE_START) {
      operations[count].operator= parsed_operator;
      operations[count].operand = 0;
      count++;
    } else if (state == EXPRESSION_STATE_OPERATOR) {
      current_operator = parsed_operator;
    } else if (state == EXPRESSION_STATE_OPERAND) {
      if (value < -32768 || value > 32767) {
        string_free(parse_string);
        return EXPRESSION_ERR_OPERAND_OUT_OF_BOUNDS;
      }
      if (current_operator == OPERATOR_DIV && value == 0) {
        string_free(parse_string);
        return EXPRESSION_ERR_DIVIDE_BY_ZERO;
      }
      operations[count].operator= current_operator;
      operations[count].operand = (int16_t)value;
      count++;
    }
    if (count >= nmax) break;
    token = strtok(NULL, " ");
  }
  for (i = 0; i < count; i++) {
    expression_add_operation(expression, operations[i]);
  }
  string_free(parse_string);
  return count;
}
STATIC_OVL bool
expression_test_copy(const expression_t* a, const expression_t* b)
{
  size_t i;
  bool success = true;
  if (a == NULL || b == NULL) return false;
  success &= (a != b);
  success &= (a->base_value == b->base_value);
  success &= (a->operation_count == b->operation_count);
  success &= (a->operations_size == b->operations_size);
  success &= (a->operations != b->operations);
  success &= (a->fixed_base == b->fixed_base);
  if (a->operation_count != b->operation_count) return false;
  for (i = 0; i < a->operation_count; i++) {
    success &= (a->operations[i].operand == b->operations[i].operand);
    success &= (a->operations[i].operator== b->operations[i].operator);
  }
  return success;
}
STATIC_OVL void
safe_setuid_drop(void)
{
}
STATIC_OVL void
safe_setuid_grab(void)
{
}
STATIC_OVL void
path_parse(char* buf, size_t max, const char* file)
{
  my_strcpy(buf, file, max);
}
STATIC_OVL void
path_process(char* buf, size_t len, size_t* cur_len, const char* path)
{
  if (path[0] == '~') {
    const char* s;
    const char* username = path + 1;
    struct passwd* pw;
    char user[128];
    s = strstr(username, PATH_SEP);
    if (s) {
      int i;
      if (s >= username + sizeof(user)) return;
      for (i = 0; username < s; ++i) user[i] = *username++;
      user[i] = '\0';
      username = user;
    }
    pw = username[0] ? getpwnam(username) : getpwuid(getuid());
    if (!pw) return;
    strnfcat(buf, len, cur_len, "%s%s", pw->pw_dir, PATH_SEP);
    if (s) strnfcat(buf, len, cur_len, "%s", s);
  } else
    strnfcat(buf, len, cur_len, "%s", path);
}
STATIC_OVL size_t
path_build(char* buf, size_t len, const char* base, const char* leaf)
{
  size_t cur_len = 0;
  int starts_with_separator;
  buf[0] = '\0';
  if (!leaf || !leaf[0]) {
    if (base && base[0]) path_process(buf, len, &cur_len, base);
    return cur_len;
  }
  starts_with_separator = (!base || !base[0]) || prefix(leaf, PATH_SEP);
  starts_with_separator = starts_with_separator || leaf[0] == '~';
  if (starts_with_separator) {
    path_process(buf, len, &cur_len, leaf);
    return cur_len;
  }
  path_process(buf, len, &cur_len, base);
  if (!suffix(base, PATH_SEP)) {
    strnfcat(buf, len, &cur_len, "%s", PATH_SEP);
  }
  path_process(buf, len, &cur_len, leaf);
  return cur_len;
}
STATIC_OVL int
path_normalize(char* buf, size_t len, const char* path_in, bool trailing_sep,
               size_t* req_len, size_t* root_len)
{
  size_t oidx_high = 0, oidx, iidx, root_size;
  int result;
  if (path_in[0] != PATH_SEPC) {
    if (path_in[0] == '~') {
      struct passwd* pw;
      if (!path_in[1] || path_in[1] == PATH_SEPC) {
        pw = getpwuid(getuid());
        iidx = 1;
      } else {
        const char* s = strchr(path_in + 1, PATH_SEPC);
        if (s) {
          size_t nlen = s - path_in;
          char* work = mem_alloc(nlen);
          (void)memcpy(work, path_in + 1, nlen - 1);
          work[nlen - 1] = '\0';
          pw = getpwnam(work);
          mem_free(work);
          iidx = nlen;
        } else {
          pw = getpwnam(path_in + 1);
          iidx = strlen(path_in);
        }
      }
      if (!pw || !pw->pw_dir || pw->pw_dir[0] == '~') {
        goto ABNORMAL_RETURN;
      }
      result = path_normalize(buf, len, pw->pw_dir,
                              (path_in[iidx]) ? true : false, &oidx_high, NULL);
      if ((result != 0 && result != 1) || oidx_high <= 1) {
        goto ABNORMAL_RETURN;
      }
      oidx = oidx_high - 1;
      if (path_in[iidx]) {
        assert(path_in[iidx] == PATH_SEPC);
        ++iidx;
      }
    } else {
      size_t work_sz = 1024;
      char* work = mem_alloc(work_sz);
      while (1) {
        if (getcwd(work, work_sz)) {
          if (work[0] != PATH_SEPC) {
            mem_free(work);
            goto ABNORMAL_RETURN;
          }
          result = path_normalize(buf, len, work, (path_in[0]) ? true : false,
                                  &oidx_high, NULL);
          mem_free(work);
          if ((result != 0 && result != 1) || oidx_high <= 1) {
            goto ABNORMAL_RETURN;
          }
          oidx = oidx_high - 1;
          break;
        } else if (errno != ERANGE) {
          mem_free(work);
          goto ABNORMAL_RETURN;
        }
        if (work_sz < ((size_t)-1) / 2) {
          work_sz *= 2;
        } else if (work_sz < (size_t)-1) {
          work_sz = (size_t)-1;
        } else {
          mem_free(work);
          goto ABNORMAL_RETURN;
        }
        work = mem_realloc(work, work_sz);
      }
      iidx = 0;
    }
  } else {
    if (len) {
      buf[0] = PATH_SEPC;
    }
    oidx = 1;
    iidx = 1;
  }
  root_size = 1;
  while (1) {
    if (!path_in[iidx]) {
      break;
    }
    assert((oidx <= len && oidx > 0 && buf[oidx - 1] == PATH_SEPC) ||
           (oidx >= len));
    if (path_in[iidx] == PATH_SEPC) {
      ++iidx;
      continue;
    }
    if (path_in[iidx] == '.') {
      if (!path_in[iidx + 1]) {
        if (oidx > root_size) {
          oidx_high = MAX(oidx, oidx_high);
          --oidx;
          ++iidx;
        }
        break;
      }
      if (path_in[iidx + 1] == PATH_SEPC) {
        iidx += 2;
        continue;
      }
      if (path_in[iidx + 1] == '.') {
        if (!path_in[iidx + 2] || path_in[iidx + 2] == PATH_SEPC) {
          if (oidx > root_size && oidx <= len) {
            oidx_high = MAX(oidx, oidx_high);
            --oidx;
            while (1) {
              assert(oidx > 0);
              if (buf[oidx - 1] == PATH_SEPC) {
                break;
              }
              --oidx;
            }
          }
          if (!path_in[iidx + 2]) {
            if (oidx > root_size) {
              --oidx;
              iidx += 2;
            }
            break;
          }
          iidx += 3;
          continue;
        }
      }
    }
    while (1) {
      if (!path_in[iidx]) {
        break;
      }
      if (path_in[iidx] == PATH_SEPC) {
        if (oidx < len) {
          buf[oidx] = path_in[iidx];
        }
        ++oidx;
        ++iidx;
        break;
      }
      if (oidx < len) {
        buf[oidx] = path_in[iidx];
      }
      ++oidx;
      ++iidx;
    }
  }
  if (trailing_sep) {
    if (iidx == 0 || path_in[iidx - 1] != PATH_SEPC) {
      if (oidx < len) {
        buf[oidx] = PATH_SEPC;
      }
      ++oidx;
    }
  }
  if (oidx < len) {
    buf[oidx] = '\0';
    result = 0;
  } else {
    if (len > 0) {
      buf[len - 1] = '\0';
    }
    result = 1;
  }
  ++oidx;
  if (req_len) {
    *req_len = MAX(oidx, oidx_high);
  }
  if (root_len) {
    *root_len = root_size;
  }
  return result;
ABNORMAL_RETURN:
  if (len > 0) {
    buf[0] = '\0';
  }
  if (req_len) {
    *req_len = 0;
  }
  if (root_len) {
    *root_len = 0;
  }
  return 2;
}
STATIC_OVL size_t
path_filename_index(const char* path)
{
  int i;
  if (strlen(path) == 0) return 0;
  for (i = strlen(path) - 1; i >= 0; i--) {
    if (path[i] == PATH_SEPC) return i + 1;
  }
  return 0;
}
STATIC_OVL bool
file_delete(const char* fname)
{
  char buf[1024];
  path_parse(buf, sizeof(buf), fname);
  return (remove(buf) == 0);
}
STATIC_OVL bool
file_move(const char* fname, const char* newname)
{
  char buf[1024];
  char aux[1024];
  path_parse(buf, sizeof(buf), fname);
  path_parse(aux, sizeof(aux), newname);
  return (rename(buf, aux) == 0);
}
STATIC_OVL bool
file_exists(const char* fname)
{
  struct stat st;
  return (stat(fname, &st) == 0);
}
STATIC_OVL bool
file_newer(const char* first, const char* second)
{
  struct stat stat1, stat2;
  if (stat(first, &stat1) != 0) return false;
  if (stat(second, &stat2) != 0) return true;
  return stat1.st_mtime > stat2.st_mtime ? true : false;
}
void (*file_open_hook)(const char* path, file_type ftype);
ang_file*
file_open(const char* fname, file_mode mode, file_type ftype)
{
  ang_file* f = mem_zalloc(sizeof(ang_file));
  char buf[1024];
  (void)ftype;
  path_parse(buf, sizeof(buf), fname);
  switch (mode) {
    case MODE_WRITE: {
      if (ftype == FTYPE_SAVE) {
        int fd;
        fd = open(buf, O_CREAT | O_EXCL | O_WRONLY | 0, S_IREAD | S_IWRITE);
        if (fd < 0) {
          f->fh = NULL;
        } else {
          f->fh = fdopen(fd, "wb");
        }
      } else {
        f->fh = fopen(buf, "wb");
      }
      break;
    }
    case MODE_READ:
      f->fh = fopen(buf, "rb");
      break;
    case MODE_APPEND:
      f->fh = fopen(buf, "a+");
      break;
    default:
      assert(0);
  }
  if (f->fh == NULL) {
    mem_free(f);
    return NULL;
  }
  f->fname = string_make(buf);
  f->mode = mode;
  if (mode != MODE_READ && file_open_hook) file_open_hook(buf, ftype);
  return f;
}
STATIC_OVL bool
file_close(ang_file* f)
{
  if (fclose(f->fh) != 0) return false;
  mem_free(f->fname);
  mem_free(f);
  return true;
}
STATIC_OVL void
file_lock(ang_file* f)
{
  struct flock lock;
  lock.l_type = (f->mode == MODE_READ ? F_RDLCK : F_WRLCK);
  lock.l_whence = SEEK_SET;
  lock.l_start = 0;
  lock.l_len = 0;
  lock.l_pid = 0;
  fcntl(fileno(f->fh), F_SETLKW, &lock);
}
STATIC_OVL void
file_unlock(ang_file* f)
{
  struct flock lock;
  lock.l_type = F_UNLCK;
  lock.l_whence = SEEK_SET;
  lock.l_start = 0;
  lock.l_len = 0;
  lock.l_pid = 0;
  fcntl(fileno(f->fh), F_SETLK, &lock);
}
STATIC_OVL bool
file_skip(ang_file* f, int bytes)
{
  return (fseek(f->fh, bytes, SEEK_CUR) == 0);
}
STATIC_OVL bool
file_readc(ang_file* f, uint8_t* b)
{
  int i = fgetc(f->fh);
  if (i == EOF) return false;
  *b = (uint8_t)i;
  return true;
}
STATIC_OVL bool
file_writec(ang_file* f, uint8_t b)
{
  return file_write(f, (const char*)&b, 1);
}
STATIC_OVL int
file_read(ang_file* f, char* buf, size_t n)
{
  size_t read = fread(buf, 1, n, f->fh);
  if (read == 0 && ferror(f->fh))
    return -1;
  else
    return read;
}
STATIC_OVL bool
file_write(ang_file* f, const char* buf, size_t n)
{
  return fwrite(buf, 1, n, f->fh) == n;
}
STATIC_OVL bool
file_getl(ang_file* f, char* buf, size_t len)
{
  bool seen_cr = false;
  uint8_t b;
  size_t i = 0;
  size_t max_len = len - 1;
  while (i < max_len) {
    char c;
    if (!file_readc(f, &b)) {
      buf[i] = '\0';
      return (i == 0) ? false : true;
    }
    c = (char)b;
    if (c == '\r') {
      seen_cr = true;
      continue;
    }
    if (seen_cr && c != '\n') {
      fseek(f->fh, -1, SEEK_CUR);
      buf[i] = '\0';
      return true;
    }
    if (c == '\n') {
      buf[i] = '\0';
      return true;
    }
    if (c == '\t') {
      size_t tabstop = ((i + 4) / 4) * 4;
      if (tabstop >= len) break;
      while (i < tabstop) buf[i++] = ' ';
      continue;
    }
    buf[i++] = c;
  }
  buf[i] = '\0';
  return true;
}
STATIC_OVL bool
file_put(ang_file* f, const char* buf)
{
  return file_write(f, buf, strlen(buf));
}
STATIC_OVL bool
file_putf(ang_file* f, const char* fmt, ...)
{
  va_list vp;
  bool status;
  if (!f) return false;
  va_start(vp, fmt);
  status = file_vputf(f, fmt, vp);
  va_end(vp);
  return status;
}
STATIC_OVL bool
file_vputf(ang_file* f, const char* fmt, va_list vp)
{
  char buf[1024];
  if (!f) return false;
  (void)vstrnfmt(buf, sizeof(buf), fmt, vp);
  return file_put(f, buf);
}
STATIC_OVL bool
dir_exists(const char* path)
{
  struct stat buf;
  if (stat(path, &buf) != 0)
    return false;
  else if (buf.st_mode & S_IFDIR)
    return true;
  else
    return false;
}
STATIC_OVL bool
dir_create(const char* path)
{
  const char* ptr;
  char buf[512];
  if (dir_exists(path)) return true;
  for (ptr = path; *ptr; ptr++) {
    if (*ptr == PATH_SEPC) {
      size_t len = (size_t)(ptr - path);
      if (len == 0) continue;
      if (*(ptr - 1) == PATH_SEPC) continue;
      if (len - 1 > 512) return false;
      my_strcpy(buf, path, len + 1);
      if (dir_exists(buf)) continue;
      if (false != 0) return false;
    }
  }
  return false == 0 ? true : false;
}
STATIC_OVL ang_dir*
my_dopen(const char* dirname)
{
  ang_dir* dir;
  DIR* d;
  d = opendir(dirname);
  if (!d) return NULL;
  dir = mem_zalloc(sizeof(ang_dir));
  if (!dir) {
    closedir(d);
    return NULL;
  }
  dir->d = d;
  dir->dirname = string_make(dirname);
  dir->only_files = true;
  return dir;
}
STATIC_OVL bool
alter_ang_dir_only_files(ang_dir* dir, bool newval)
{
  bool oldval = dir->only_files;
  dir->only_files = newval;
  return oldval;
}
STATIC_OVL bool
my_dread(ang_dir* dir, char* fname, size_t len)
{
  struct dirent* entry;
  struct stat filedata;
  char path[1024];
  assert(dir != NULL);
  while (1) {
    entry = readdir(dir->d);
    if (!entry) return false;
    path_build(path, sizeof path, dir->dirname, entry->d_name);
    if (stat(path, &filedata) != 0) continue;
    if (dir->only_files && S_ISDIR(filedata.st_mode)) continue;
    break;
  }
  my_strcpy(fname, entry->d_name, len);
  return true;
}
STATIC_OVL void
my_dclose(ang_dir* dir)
{
  if (dir->d) closedir(dir->d);
  mem_free(dir->dirname);
  mem_free(dir);
}
STATIC_OVL size_t
vstrnfmt(char* buf, size_t max, const char* fmt, va_list vp)
{
  const char* s;
  int i = 0, len = 0;
  bool do_long;
  size_t n;
  size_t q;
  char aux[128];
  char tmp[1024];
  assert(max);
  assert(fmt);
  n = 0;
  s = fmt;
  while (true) {
    if (!*s) break;
    if (*s != '%') {
      if (n == max - 1) break;
      buf[n++] = *s++;
      continue;
    }
    s++;
    if (*s == '%') {
      if (n == max - 1) break;
      buf[n++] = '%';
      s++;
      continue;
    }
    if (*s == 'n') {
      size_t* arg;
      arg = va_arg(vp, size_t*);
      (*arg) = n;
      s++;
      continue;
    }
    q = 0;
    aux[q++] = '%';
    do_long = false;
    while (true) {
      if (!*s) {
        buf[0] = '\0';
        return (0);
      }
      if (q > 100) {
        buf[0] = '\0';
        return (0);
      }
      if (isalpha((unsigned char)*s)) {
        if (*s == 'l') {
          aux[q++] = *s++;
          do_long = true;
        } else {
          aux[q++] = *s++;
          break;
        }
      } else {
        if (*s == '*') {
          int arg;
          arg = va_arg(vp, int);
          snprintf(aux + q, sizeof(aux) - q, "%d", arg);
          while (aux[q]) q++;
          s++;
        } else {
          aux[q++] = *s++;
        }
      }
    }
    aux[q] = '\0';
    tmp[0] = '\0';
    switch (aux[q - 1]) {
      case 'c': {
        int arg;
        arg = va_arg(vp, int);
        snprintf(tmp, sizeof(tmp), aux, arg);
        break;
      }
      case 'd':
      case 'i': {
        if (do_long) {
          long arg;
          arg = va_arg(vp, long);
          snprintf(tmp, sizeof(tmp), aux, arg);
        } else {
          int arg;
          arg = va_arg(vp, int);
          snprintf(tmp, sizeof(tmp), aux, arg);
        }
        break;
      }
      case 'u':
      case 'o':
      case 'x':
      case 'X': {
        if (do_long) {
          unsigned long arg;
          arg = va_arg(vp, unsigned long);
          snprintf(tmp, sizeof(tmp), aux, arg);
        } else {
          unsigned int arg;
          arg = va_arg(vp, unsigned int);
          snprintf(tmp, sizeof(tmp), aux, arg);
        }
        break;
      }
      case 'f':
      case 'e':
      case 'E':
      case 'g':
      case 'G': {
        double arg;
        arg = va_arg(vp, double);
        snprintf(tmp, sizeof(tmp), aux, arg);
        break;
      }
      case 'p': {
        void* arg;
        arg = va_arg(vp, void*);
        snprintf(tmp, sizeof(tmp), aux, arg);
        break;
      }
      case 's': {
        if (do_long) {
          const wchar_t* arg;
          char arg2[1024];
          arg = va_arg(vp, const wchar_t*);
          if (!arg) arg = L"";
          len = wcslen(arg);
          if (len >= 768) {
            len = 767;
          }
          for (i = 0; i < len; ++i) {
            arg2[i] = (char)arg[i];
          }
          arg2[len] = '\0';
          aux[q - 2] = 's';
          aux[q - 1] = '\0';
          snprintf(tmp, sizeof(tmp), aux, arg2);
          break;
        } else {
          const char* arg;
          char arg2[1024];
          arg = va_arg(vp, const char*);
          if (!arg) arg = "";
          (void)my_strcpy(arg2, arg, sizeof(arg2));
          snprintf(tmp, sizeof(tmp), aux, arg2);
          break;
        }
      }
      default: {
        buf[0] = '\0';
        return (0);
      }
    }
    for (q = 0; tmp[q]; q++) {
      if (n == max - 1) break;
      buf[n++] = tmp[q];
    }
  }
  buf[n] = '\0';
  return (n);
}
STATIC_OVL void
strnfcat(char* str, size_t max, size_t* end, const char* fmt, ...)
{
  size_t len;
  va_list vp;
  if (*end >= max) return;
  va_start(vp, fmt);
  len = vstrnfmt(&str[*end], max - *end, fmt, vp);
  va_end(vp);
  *end += len;
}
STATIC_OVL char*
vformat(const char* fmt, va_list vp)
{
  if (!format_buf) {
    format_len = 1024;
    format_buf = mem_zalloc(format_len);
    format_buf[0] = 0;
  }
  if (!fmt) return (format_buf);
  while (1) {
    va_list args;
    size_t len;
    va_copy(args, vp);
    len = vstrnfmt(format_buf, format_len, fmt, args);
    va_end(args);
    if (len < format_len - 1) break;
    format_len = format_len * 2;
    format_buf = mem_realloc(format_buf, format_len);
  }
  return (format_buf);
}
STATIC_OVL void
vformat_kill(void)
{
  mem_free(format_buf);
}
STATIC_OVL size_t
strnfmt(char* buf, size_t max, const char* fmt, ...)
{
  size_t len;
  va_list vp;
  va_start(vp, fmt);
  len = vstrnfmt(buf, max, fmt, vp);
  va_end(vp);
  return (len);
}
STATIC_OVL char*
format(const char* fmt, ...)
{
  char* res;
  va_list vp;
  va_start(vp, fmt);
  res = vformat(fmt, vp);
  va_end(vp);
  return (res);
}
STATIC_OVL void
plog_fmt(const char* fmt, ...)
{
  char* res;
  va_list vp;
  va_start(vp, fmt);
  res = vformat(fmt, vp);
  va_end(vp);
  plog(res);
}
STATIC_OVL void
quit_fmt(const char* fmt, ...)
{
  char* res;
  va_list vp;
  va_start(vp, fmt);
  res = vformat(fmt, vp);
  va_end(vp);
  quit(res);
}
STATIC_OVL quark_t
quark_add(const char* str)
{
  quark_t q;
  for (q = 1; q < nr_quarks; q++) {
    if (streq(quarks[q], str)) return q;
  }
  if (nr_quarks == alloc_quarks) {
    alloc_quarks *= 2;
    quarks = mem_realloc(quarks, alloc_quarks * sizeof(char*));
  }
  q = nr_quarks++;
  quarks[q] = string_make(str);
  return q;
}
STATIC_OVL const char*
quark_str(quark_t q)
{
  return (q >= nr_quarks ? NULL : quarks[q]);
}
STATIC_OVL void
quarks_init(void)
{
  nr_quarks = 1;
  alloc_quarks = 16;
  quarks = mem_zalloc(alloc_quarks * sizeof(char*));
}
STATIC_OVL void
quarks_free(void)
{
  size_t i;
  for (i = 1; i < nr_quarks; i++) string_free(quarks[i]);
  mem_free(quarks);
}
STATIC_OVL struct queue*
q_new(size_t size)
{
  struct queue* q = (struct queue*)malloc(sizeof(struct queue));
  if (!q) return NULL;
  q->data = (uintptr_t*)malloc(sizeof(uintptr_t) * (size + 1));
  q->size = size + 1;
  q->head = 0;
  q->tail = 0;
  return q;
}
STATIC_OVL int
q_len(struct queue* q)
{
  int len;
  if (q->tail >= q->head) {
    len = q->tail - q->head;
  } else {
    len = q->size - q->head + q->tail;
  }
  return len;
}
STATIC_OVL void
q_push(struct queue* q, uintptr_t item)
{
  q->data[q->tail] = item;
  q->tail = (q->tail + 1) % q->size;
  if (q->tail == q->head) abort();
}
STATIC_OVL uintptr_t
q_pop(struct queue* q)
{
  uintptr_t item = q->data[q->head];
  if (q->head == q->tail) abort();
  q->head = (q->head + 1) % q->size;
  return item;
}
STATIC_OVL void
q_free(struct queue* q)
{
  free(q->data);
  free(q);
}
STATIC_OVL uint32_t
WELLRNG1024a(void)
{
  z0 = STATE[(state_i + 31) & 0x0000001fU];
  z1 = (STATE[state_i]) ^ (STATE[(state_i + 3) & 0x0000001fU] ^
                           (STATE[(state_i + 3) & 0x0000001fU] >> 8));
  z2 = (STATE[(state_i + 24) & 0x0000001fU] ^
        (STATE[(state_i + 24) & 0x0000001fU] << (-(-19)))) ^
       (STATE[(state_i + 10) & 0x0000001fU] ^
        (STATE[(state_i + 10) & 0x0000001fU] << (-(-14))));
  STATE[state_i] = z1 ^ z2;
  STATE[(state_i + 31) & 0x0000001fU] = (z0 ^ (z0 << (-(-11)))) ^
                                        (z1 ^ (z1 << (-(-7)))) ^
                                        (z2 ^ (z2 << (-(-13))));
  state_i = (state_i + 31) & 0x0000001fU;
  return STATE[state_i];
}
STATIC_OVL void
Rand_state_init(uint32_t seed)
{
  int i, j;
  STATE[0] = seed;
  for (i = 1; i < RAND_DEG; i++)
    STATE[i] = ((STATE[i - 1]) * 1103515245 + 12345);
  for (i = 0; i < RAND_DEG * 10; i++) {
    j = (state_i + 1) % RAND_DEG;
    STATE[j] += STATE[state_i];
    state_i = j;
  }
}
STATIC_OVL void
Rand_init(void)
{
  if (Rand_quick) {
    uint32_t seed;
    seed = (uint32_t)(time(NULL));
    seed = ((seed >> 3) * (getpid() << 1));
    Rand_quick = false;
    Rand_state_init(seed);
  }
}
STATIC_OVL uint32_t
Rand_div(uint32_t m)
{
  uint32_t n, r = 0;
  assert(m <= 0x10000000);
  if (m <= 1) return (0);
  if (rand_fixed) return (rand_fixval * 1000 * (m - 1)) / (100 * 1000);
  n = (0x10000000 / m);
  if (Rand_quick) {
    while (1) {
      r = (Rand_value = ((Rand_value)*1103515245 + 12345));
      r = ((r >> 4) & 0x0FFFFFFF) / n;
      if (r < m) break;
    }
  } else {
    while (1) {
      r = WELLRNG1024a();
      r = ((r >> 4) & 0x0FFFFFFF) / n;
      if (r < m) break;
    }
  }
  return (r);
}
STATIC_OVL int16_t
Rand_normal(int mean, int stand)
{
  int16_t tmp, offset;
  int16_t low = 0;
  int16_t high = 256;
  if (stand < 1) return (mean);
  tmp = (int16_t)randint0(32768);
  while (low < high) {
    int mid = (low + high) >> 1;
    if (Rand_normal_table[mid] < tmp) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  offset = (int16_t)((long)stand * (long)low / 64);
  if (one_in_(2)) return (mean - offset);
  return (mean + offset);
}
STATIC_OVL int
Rand_sample(int mean, int upper, int lower, int stand_u, int stand_l)
{
  int pick = Rand_normal(0, 1000);
  if (pick > 0) {
    pick *= (upper - mean);
    pick /= (100 * stand_u);
  } else if (pick < 0) {
    pick *= (mean - lower);
    pick /= (100 * stand_l);
  }
  return mean + pick;
}
STATIC_OVL int
damroll(int num, int sides)
{
  int i;
  int sum = 0;
  if (sides <= 0) return 0;
  for (i = 0; i < num; i++) sum += randint1(sides);
  return sum;
}
STATIC_OVL int
damcalc(int num, int sides, aspect dam_aspect)
{
  switch (dam_aspect) {
    case MAXIMISE:
    case EXTREMIFY:
      return num * sides;
    case RANDOMISE:
      return damroll(num, sides);
    case MINIMISE:
      return num;
    case AVERAGE:
      return num * (sides + 1) / 2;
  }
  assert(0 && "Should never reach here");
  return 0;
}
STATIC_OVL int
rand_range(int A, int B)
{
  if (A == B) return A;
  assert(A < B);
  return A + (int32_t)Rand_div(1 + B - A);
}
STATIC_OVL int16_t
m_bonus(int divisor, int level)
{
  if (!divisor) return 0;
  return (level + randint1(10)) / divisor;
}
STATIC_OVL int16_t
m_bonus_calc(int divisor, int level, aspect bonus_aspect)
{
  if (!divisor) return 0;
  switch (bonus_aspect) {
    case EXTREMIFY:
    case MAXIMISE:
      return (level + 10) / divisor;
    case RANDOMISE:
      return m_bonus(divisor, level);
    case MINIMISE:
      return 0;
    case AVERAGE:
      return (2 * level + 11) / (2 * divisor);
  }
  assert(0 && "Should never reach here");
  return 0;
}
STATIC_OVL int
randcalc(random_value v, int level, aspect rand_aspect)
{
  if (rand_aspect == EXTREMIFY) {
    int min = randcalc(v, level, MINIMISE);
    int max = randcalc(v, level, MAXIMISE);
    return abs(min) > abs(max) ? min : max;
  } else {
    int dmg = damcalc(v.dice, v.sides, rand_aspect);
    int bonus = m_bonus_calc(v.m_bonus, level, rand_aspect);
    return v.base + dmg + bonus;
  }
}
STATIC_OVL bool
randcalc_valid(random_value v, int test)
{
  if (test < randcalc(v, 0, MINIMISE))
    return false;
  else if (test > randcalc(v, 0, MAXIMISE))
    return false;
  else
    return true;
}
STATIC_OVL bool
randcalc_varies(random_value v)
{
  return randcalc(v, 0, MINIMISE) != randcalc(v, 0, MAXIMISE);
}
STATIC_OVL bool
random_chance_check(random_chance c)
{
  return randint0(c.denominator) >= c.denominator - c.numerator;
}
STATIC_OVL int
random_chance_scaled(random_chance c, int scale)
{
  return scale * c.numerator / c.denominator;
}
STATIC_OVL void
rand_fix(uint32_t val)
{
  rand_fixed = true;
  rand_fixval = val;
}
STATIC_OVL uint32_t
Rand_simple(uint32_t m)
{
  static time_t seed;
  time_t v = time(NULL);
  seed = ((seed % m) * 1103515245 + 12345) + ((v << 16) ^ v ^ getpid());
  return (seed % m);
}
STATIC_OVL textblock*
textblock_new(void)
{
  textblock* tb = mem_zalloc(sizeof *tb);
  tb->size = 128;
  tb->text = mem_zalloc(tb->size * sizeof(*tb->text));
  tb->attrs = mem_zalloc(tb->size * sizeof(*tb->attrs));
  return tb;
}
STATIC_OVL void
textblock_free(textblock* tb)
{
  mem_free(tb->text);
  mem_free(tb->attrs);
  mem_free(tb);
}
STATIC_OVL void
textblock_resize_if_needed(textblock* tb, size_t additional_size)
{
  size_t remaining = tb->size - tb->strlen;
  if (remaining < additional_size) {
    tb->size = ((tb->strlen + additional_size) + 128);
    tb->text = mem_realloc(tb->text, tb->size * sizeof(*tb->text));
    tb->attrs = mem_realloc(tb->attrs, tb->size * sizeof(*tb->attrs));
  }
}
STATIC_OVL void
textblock_vappend_c(textblock* tb, int attr, const char* fmt, va_list vp)
{
  size_t temp_len = 128;
  char* temp_space = mem_zalloc(temp_len);
  int new_length, i;
  while (1) {
    va_list args;
    size_t len;
    va_copy(args, vp);
    len = vstrnfmt(temp_space, temp_len, fmt, args);
    va_end(args);
    if (len < temp_len - 1) {
      break;
    }
    temp_len = ((temp_len) + 128);
    temp_space = mem_realloc(temp_space, temp_len * sizeof *temp_space);
  }
  new_length = text_mbstowcs(NULL, temp_space, 0);
  assert(new_length >= 0);
  textblock_resize_if_needed(tb, new_length + 1);
  text_mbstowcs(tb->text + tb->strlen, temp_space, tb->size - tb->strlen);
  for (i = 0; i < new_length; ++i) {
    tb->attrs[i + tb->strlen] = attr;
  }
  tb->strlen += new_length;
  mem_free(temp_space);
}
STATIC_OVL void
textblock_append_pict(textblock* tb, int attr, int c)
{
  textblock_resize_if_needed(tb, 1);
  tb->text[tb->strlen] = (wchar_t)c;
  tb->attrs[tb->strlen] = attr;
  tb->strlen += 1;
}
STATIC_OVL void
textblock_append_textblock(textblock* tb, const textblock* tba)
{
  textblock_resize_if_needed(tb, tba->strlen);
  (void)memcpy(tb->text + tb->strlen, tba->text,
               tba->strlen * sizeof(*tb->text));
  (void)memcpy(tb->attrs + tb->strlen, tba->attrs,
               tba->strlen * sizeof(*tb->attrs));
  tb->strlen += tba->strlen;
}
STATIC_OVL void
textblock_append(textblock* tb, const char* fmt, ...)
{
  va_list vp;
  va_start(vp, fmt);
  textblock_vappend_c(tb, COLOUR_WHITE, fmt, vp);
  va_end(vp);
}
STATIC_OVL void
textblock_append_c(textblock* tb, int attr, const char* fmt, ...)
{
  va_list vp;
  va_start(vp, fmt);
  textblock_vappend_c(tb, attr, fmt, vp);
  va_end(vp);
}
STATIC_OVL const wchar_t*
textblock_text(textblock* tb)
{
  return tb->text;
}
STATIC_OVL const int*
textblock_attrs(textblock* tb)
{
  return tb->attrs;
}
STATIC_OVL void
new_line(size_t** line_starts, size_t** line_lengths, size_t* n_lines,
         size_t* cur_line, size_t start, size_t len)
{
  if (*cur_line == *n_lines) {
    (*n_lines) += 24;
    *line_starts = mem_realloc(*line_starts, *n_lines * sizeof **line_starts);
    *line_lengths =
        mem_realloc(*line_lengths, *n_lines * sizeof **line_lengths);
  }
  (*line_starts)[*cur_line] = start;
  (*line_lengths)[*cur_line] = len;
  (*cur_line)++;
}
STATIC_OVL size_t
textblock_calculate_lines(textblock* tb, size_t** line_starts,
                          size_t** line_lengths, size_t width)
{
  const wchar_t* text = NULL;
  size_t text_offset = 0;
  size_t alloc_lines = 0;
  size_t total_lines = 0;
  size_t current_line_index = 0;
  size_t current_line_length = 0;
  size_t breaking_char_offset = 0;
  if (tb == NULL || line_starts == NULL || line_lengths == NULL || width == 0)
    return 0;
  text = textblock_text(tb);
  if (text == NULL || tb->strlen == 0) return 0;
  new_line(line_starts, line_lengths, &alloc_lines, &total_lines, 0, 0);
  while (text_offset < tb->strlen) {
    if (text[text_offset] == L'\n') {
      (*line_lengths)[current_line_index] = current_line_length;
      new_line(line_starts, line_lengths, &alloc_lines, &total_lines,
               text_offset + 1, 0);
      current_line_index++;
      current_line_length = 0;
    } else if (text[text_offset] == L' ') {
      breaking_char_offset = text_offset;
      current_line_length++;
    } else {
      current_line_length++;
    }
    if (current_line_length == width) {
      size_t const current_line_start = (*line_starts)[current_line_index];
      size_t next_line_start_offset = 0;
      size_t adjusted_line_length = 0;
      if (breaking_char_offset > current_line_start) {
        adjusted_line_length = breaking_char_offset - current_line_start;
        next_line_start_offset = breaking_char_offset + 1;
        text_offset = breaking_char_offset + 1;
      } else {
        adjusted_line_length = width;
        next_line_start_offset = text_offset + 1;
        text_offset++;
      }
      (*line_lengths)[current_line_index] = adjusted_line_length;
      new_line(line_starts, line_lengths, &alloc_lines, &total_lines,
               next_line_start_offset, 0);
      current_line_index++;
      current_line_length = 0;
    } else {
      (*line_lengths)[current_line_index] = current_line_length;
      text_offset++;
    }
  }
  if ((*line_lengths)[total_lines - 1] == 0) total_lines--;
  return total_lines;
}
STATIC_OVL void
textblock_to_file(textblock* tb, ang_file* f, int indent, int wrap_at)
{
  size_t* line_starts = NULL;
  size_t* line_lengths = NULL;
  size_t n_lines, i, j;
  char* mbbuf;
  int width = wrap_at - indent;
  assert(width > 0);
  n_lines = textblock_calculate_lines(tb, &line_starts, &line_lengths, width);
  mbbuf = mem_alloc(text_wcsz() + 1);
  for (i = 0; i < n_lines; i++) {
    if (indent > 0) {
      file_putf(f, "%*c", indent, ' ');
    }
    for (j = 0; j < line_lengths[i]; ++j) {
      int nc = text_wctomb(mbbuf, tb->text[line_starts[i] + j]);
      if (nc > 0) {
        mbbuf[nc] = 0;
      } else {
        mbbuf[0] = ' ';
        mbbuf[1] = 0;
      }
      file_putf(f, "%s", mbbuf);
    }
    file_putf(f, "\n");
  }
  mem_free(mbbuf);
  mem_free(line_starts);
  mem_free(line_lengths);
}
STATIC_OVL void
text_out_to_file(int a, const char* str)
{
  const char* s;
  char buf[1024];
  static int pos = 0;
  int wrap = (text_out_wrap ? text_out_wrap : 75);
  (void)a;
  my_strcpy(buf, str, 1024);
  s = buf;
  while (*s) {
    int n = 0;
    int len = wrap - pos;
    int l_space = -1;
    if (len < 0) len = 0;
    if (pos == 0) {
      int i;
      for (i = 0; i < text_out_indent; i++) {
        file_writec(text_out_file, ' ');
        pos++;
      }
    }
    while ((n < len) && !((s[n] == '\n') || (s[n] == '\0'))) {
      if (s[n] == ' ') l_space = n;
      n++;
    }
    if ((l_space == -1) && (n == len)) {
      if (pos == text_out_indent) {
        len = n;
      } else if ((s[0] == ' ') || (s[0] == ',') || (s[0] == '.')) {
        len = 1;
      } else {
        file_writec(text_out_file, '\n');
        pos = 0;
        continue;
      }
    } else {
      if ((s[n] == '\n') || (s[n] == '\0'))
        len = n;
      else
        len = l_space;
    }
    file_write(text_out_file, s, len);
    pos += len;
    s += len;
    if (*s == '\0') return;
    if (*s == '\n') s++;
    file_writec(text_out_file, '\n');
    pos = 0;
    while (*s == ' ') s++;
  }
  return;
}
STATIC_OVL void
text_out(const char* fmt, ...)
{
  char buf[1024];
  va_list vp;
  va_start(vp, fmt);
  (void)vstrnfmt(buf, sizeof(buf), fmt, vp);
  va_end(vp);
  text_out_hook(COLOUR_WHITE, buf);
}
STATIC_OVL void
text_out_c(int a, const char* fmt, ...)
{
  char buf[1024];
  va_list vp;
  va_start(vp, fmt);
  (void)vstrnfmt(buf, sizeof(buf), fmt, vp);
  va_end(vp);
  text_out_hook(a, buf);
}
STATIC_OVL bool
next_section(const char* source, size_t init, const char** text, size_t* len,
             const char** tag, size_t* taglen, const char** end)
{
  const char* next;
  *tag = NULL;
  *text = source + init;
  if (*text[0] == '\0') return false;
  next = strchr(*text, '{');
  while (next) {
    const char* s = next + 1;
    while (*s && (isalpha((unsigned char)*s) || isspace((unsigned char)*s)))
      s++;
    if (*s == '}') {
      const char* close = strstr(s, "{/}");
      if (close) {
        if (next == *text) {
          *tag = *text + 1;
          *taglen = s - *text - 1;
          *text = s + 1;
          *len = close - *text;
          *end = close + 3;
          return true;
        } else {
          *len = next - *text;
          *end = *text + *len;
          return true;
        }
      } else {
        *len = strlen(*text);
        *end = *text + *len;
        return true;
      }
    } else if (*s == '\0') {
      *len = strlen(*text);
      *end = *text + *len;
      return true;
    } else {
      next = next + 1;
    }
    next = strchr(next, '{');
  }
  *len = strlen(*text);
  *end = *text + *len;
  return true;
}
STATIC_OVL void
text_out_e(const char* fmt, ...)
{
  char buf[1024];
  char smallbuf[1024];
  va_list vp;
  const char *start, *next, *text, *tag;
  size_t textlen, taglen = 0;
  va_start(vp, fmt);
  (void)vstrnfmt(buf, sizeof(buf), fmt, vp);
  va_end(vp);
  start = buf;
  while (next_section(start, 0, &text, &textlen, &tag, &taglen, &next)) {
    int a = -1;
    memcpy(smallbuf, text, textlen);
    smallbuf[textlen] = 0;
    if (tag) {
      char tagbuffer[16];
      assert(taglen < 16);
      memcpy(tagbuffer, tag, taglen);
      tagbuffer[taglen] = '\0';
      a = color_text_to_attr(tagbuffer);
    }
    if (a == -1) a = COLOUR_WHITE;
    text_out_hook(a, smallbuf);
    start = next;
  }
}
STATIC_OVL errr
text_lines_to_file(const char* path, text_writer writer)
{
  char new_fname[1024];
  char old_fname[1024];
  ang_file* new_file;
  strnfmt(new_fname, sizeof(new_fname), "%s.new", path);
  strnfmt(old_fname, sizeof(old_fname), "%s.old", path);
  new_file = file_open(new_fname, MODE_WRITE, FTYPE_TEXT);
  if (!new_file) {
    return -1;
  }
  text_out_file = new_file;
  writer(new_file);
  text_out_file = NULL;
  file_close(new_file);
  strnfmt(old_fname, sizeof(old_fname), "%s.old", path);
  if (!file_exists(path)) {
    file_move(new_fname, path);
  } else if (file_move(path, old_fname)) {
    file_move(new_fname, path);
    file_delete(old_fname);
  } else {
    file_delete(new_fname);
  }
  return 0;
}
STATIC_OVL struct loc
loc(int x, int y)
{
  struct loc p;
  p.x = x;
  p.y = y;
  return p;
}
STATIC_OVL bool
loc_eq(struct loc grid1, struct loc grid2)
{
  return (grid1.x == grid2.x) && (grid1.y == grid2.y);
}
STATIC_OVL bool
loc_is_zero(struct loc grid)
{
  return loc_eq(grid, loc(0, 0));
}
STATIC_OVL struct loc
loc_sum(struct loc grid1, struct loc grid2)
{
  return loc(grid1.x + grid2.x, grid1.y + grid2.y);
}
STATIC_OVL struct loc
loc_diff(struct loc grid1, struct loc grid2)
{
  return loc(grid1.x - grid2.x, grid1.y - grid2.y);
}
STATIC_OVL struct loc
rand_loc(struct loc grid, int x_spread, int y_spread)
{
  return loc(rand_spread(grid.x, x_spread), rand_spread(grid.y, y_spread));
}
STATIC_OVL struct loc
loc_offset(struct loc grid, int dx, int dy)
{
  return loc(grid.x + dx, grid.y + dy);
}
STATIC_OVL struct point_set*
point_set_new(int initial_size)
{
  struct point_set* ps = mem_alloc(sizeof(struct point_set));
  ps->n = 0;
  ps->allocated = initial_size;
  ps->pts = mem_zalloc(sizeof(*(ps->pts)) * ps->allocated);
  return ps;
}
STATIC_OVL void
point_set_dispose(struct point_set* ps)
{
  mem_free(ps->pts);
  mem_free(ps);
}
STATIC_OVL void
add_to_point_set(struct point_set* ps, struct loc grid)
{
  ps->pts[ps->n] = grid;
  ps->n++;
  if (ps->n >= ps->allocated) {
    ps->allocated *= 2;
    ps->pts = mem_realloc(ps->pts, sizeof(*(ps->pts)) * ps->allocated);
  }
}
STATIC_OVL int
point_set_size(struct point_set* ps)
{
  return ps->n;
}
STATIC_OVL int
point_set_contains(struct point_set* ps, struct loc grid)
{
  int i;
  for (i = 0; i < ps->n; i++)
    if (loc_eq(ps->pts[i], grid)) return 1;
  return 0;
}
STATIC_OVL size_t
utf8_strlen(const char* s)
{
  size_t i = 0, j = 0;
  while (s[i]) {
    if ((s[i] & 0xc0) != 0x80) j++;
    i++;
  }
  return j;
}
STATIC_OVL void
utf8_clipto(char* s, size_t n)
{
  size_t i = 0, j = 0;
  bool terminate_next = false;
  if (n == 0) {
    s[i] = 0;
    return;
  }
  while (s[i]) {
    if ((s[i] & 0xc0) != 0x80) {
      j++;
      if (terminate_next) break;
      if (j == n) terminate_next = true;
    }
    i++;
  }
  s[i] = 0;
}
STATIC_OVL char*
utf8_fskip(char* s, size_t n, char* lim)
{
  while (1) {
    if (*s == 0) {
      return (n > 0) ? NULL : s;
    }
    if ((*s & 0xc0) != 0x80) {
      if (n == 0) {
        return s;
      }
      --n;
    }
    if (s == lim) {
      return NULL;
    }
    ++s;
  }
}
STATIC_OVL char*
utf8_rskip(char* s, size_t n, char* lim)
{
  while (1) {
    if ((*s & 0xc0) != 0x80) {
      if (n == 0) {
        return s;
      }
      --n;
    }
    if (s == lim) {
      return NULL;
    }
    --s;
  }
}
STATIC_OVL size_t
utf32_to_utf8(char* out, size_t n_out, const uint32_t* in, size_t n_in,
              size_t* pn_cnvt)
{
  size_t nwritten = 0;
  const uint32_t* in_orig = in;
  const uint32_t* in_lim = in + n_in;
  while (1) {
    if (in == in_lim) {
      break;
    }
    if (*in <= 0x7f) {
      if (*in == 0) {
        break;
      }
      if (n_out <= 1) {
        break;
      }
      out[nwritten++] = (char)*in;
      --n_out;
    } else if (*in <= 0x7ff) {
      if (n_out <= 2) {
        break;
      }
      out[nwritten++] = 0xc0 + ((*in & 0x7c0) >> 6);
      out[nwritten++] = 0x80 + (*in & 0x3f);
      n_out -= 2;
    } else if (*in <= 0xffff) {
      if (*in >= 0xd800 && *in <= 0xdfff) {
        break;
      }
      if (n_out <= 3) {
        break;
      }
      out[nwritten++] = 0xe0 + ((*in & 0xf000) >> 12);
      out[nwritten++] = 0x80 + ((*in & 0xfc0) >> 6);
      out[nwritten++] = 0x80 + (*in & 0x3f);
      n_out -= 3;
    } else if (*in <= 0x10ffff) {
      if (n_out <= 4) {
        break;
      }
      out[nwritten++] = 0xf0 + ((*in & 0x1c0000) >> 18);
      out[nwritten++] = 0x80 + ((*in & 0x3f000) >> 12);
      out[nwritten++] = 0x80 + ((*in & 0xfc0) >> 6);
      out[nwritten++] = 0x80 + (*in & 0x3f);
      n_out -= 4;
    } else {
      break;
    }
    ++in;
  }
  if (n_out > 0) {
    out[nwritten] = 0;
  }
  if (pn_cnvt) {
    *pn_cnvt = in - in_orig;
  }
  return nwritten;
}
STATIC_OVL bool
utf32_isprint(uint32_t v)
{
  switch ((v & 0xff0000) >> 16) {
    case 0:
      switch ((v & 0xff00) >> 8) {
        case 0:
          if (v <= 0x1f || (v >= 0x7f && v <= 0x9f)) {
            return false;
          }
          break;
        case 0xd8:
        case 0xd9:
        case 0xda:
        case 0xdb:
        case 0xdc:
        case 0xdd:
        case 0xde:
        case 0xdf:
          return false;
        case 0xfd:
          if (v >= 0xfdd0 && v <= 0xfdef) {
            return false;
          }
          break;
        case 0xfe:
          if ((v & 0xfff0) == 0xfe00 || v == 0xfeff) {
            return false;
          }
          break;
        case 0xff:
          if (v >= 0xfff9 && v <= 0xfffb) {
            return false;
          }
          break;
        default:
          break;
      }
      break;
    case 1:
    case 2:
    case 3:
      break;
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
      return false;
    case 14:
      return false;
    case 15:
    case 16:
      break;
    default:
      return false;
  }
  return ((v & 0xfffe) != 0xfffe);
}
STATIC_OVL int
my_stricmp(const char* s1, const char* s2)
{
  char ch1 = 0;
  char ch2 = 0;
  while (true) {
    if ((*s1 == 0) && (*s2 == 0)) {
      return (0);
    }
    ch1 = toupper((unsigned char)*s1);
    ch2 = toupper((unsigned char)*s2);
    if (ch1 != ch2) {
      return ((int)(ch1 - ch2));
    }
    s1++;
    s2++;
  }
}
STATIC_OVL int
my_strnicmp(const char* a, const char* b, int n)
{
  const char *s1, *s2;
  char z1, z2;
  for (s1 = a, s2 = b; n > 0; s1++, s2++, n--) {
    z1 = toupper((unsigned char)*s1);
    z2 = toupper((unsigned char)*s2);
    if (z1 < z2) return (-1);
    if (z1 > z2) return (1);
    if (!z1) return (0);
  }
  return 0;
}
STATIC_OVL char*
my_stristr(const char* string, const char* pattern)
{
  const char *pptr, *sptr;
  char* start;
  for (start = (char*)string; *start != 0; start++) {
    for (; ((*start != 0) && (toupper((unsigned char)*start) !=
                              toupper((unsigned char)*pattern)));
         start++)
      ;
    if (*start == 0) return NULL;
    pptr = (const char*)pattern;
    sptr = (const char*)start;
    while (toupper((unsigned char)*sptr) == toupper((unsigned char)*pptr)) {
      sptr++;
      pptr++;
      if (*pptr == 0) return (start);
    }
  }
  return NULL;
}
STATIC_OVL size_t
my_strcpy(char* buf, const char* src, size_t bufsize)
{
  size_t len = strlen(src);
  size_t ret = len;
  if (bufsize == 0) return ret;
  if (len >= bufsize) len = bufsize - 1;
  (void)memcpy(buf, src, len);
  buf[len] = '\0';
  return ret;
}
STATIC_OVL size_t
my_strcat(char* buf, const char* src, size_t bufsize)
{
  size_t dlen = strlen(buf);
  if (dlen + 1 < bufsize) {
    return (dlen + my_strcpy(buf + dlen, src, bufsize - dlen));
  } else {
    return (dlen + strlen(src));
  }
}
STATIC_OVL void
my_strcap(char* buf)
{
  if (buf && buf[0]) buf[0] = toupper((unsigned char)buf[0]);
}
STATIC_OVL bool
streq(const char* a, const char* b)
{
  return (!strcmp(a, b));
}
STATIC_OVL bool
suffix(const char* s, const char* t)
{
  size_t tlen = strlen(t);
  size_t slen = strlen(s);
  if (tlen > slen) return (false);
  return (!strcmp(s + slen - tlen, t));
}
STATIC_OVL bool
suffix_i(const char* s, const char* t)
{
  size_t tlen = strlen(t);
  size_t slen = strlen(s);
  if (tlen > slen) return (false);
  return !my_stricmp(s + slen - tlen, t);
}
STATIC_OVL bool
prefix(const char* s, const char* t)
{
  while (*t) {
    if (*t++ != *s++) return (false);
  }
  return (true);
}
STATIC_OVL bool
prefix_i(const char* s, const char* t)
{
  while (*t) {
    if (toupper((unsigned char)*t) != toupper((unsigned char)*s))
      return (false);
    else {
      t++;
      s++;
    }
  }
  return (true);
}
STATIC_OVL void
strskip(char* s, const char c, const char e)
{
  char* in = s;
  char* out = s;
  bool escapeseen = false;
  while (*in) {
    if ((*in != c) && ((*in != e) || escapeseen)) {
      if (escapeseen) {
        *out = e;
        out++;
      }
      *out = *in;
      out++;
      escapeseen = false;
    } else if (*in == e) {
      escapeseen = true;
    } else if (escapeseen) {
      *out = *in;
      out++;
      escapeseen = false;
    }
    in++;
  }
  *out = 0;
}
STATIC_OVL void
strescape(char* s, const char c)
{
  char* in = s;
  char* out = s;
  bool escapenext = false;
  while (*in) {
    if (*in != c || escapenext) {
      *out = *in;
      out++;
      escapenext = false;
    } else if (*in == c) {
      escapenext = true;
    }
    in++;
  }
  *out = 0;
}
STATIC_OVL int
hex_char_to_int(char c)
{
  if ((c >= '0') && (c <= '9')) return c - '0';
  if ((c >= 'A') && (c <= 'F')) return c - 'A' + 10;
  if ((c >= 'a') && (c <= 'f')) return c - 'a' + 10;
  return -1;
}
STATIC_OVL int
hex_str_to_int(const char* s)
{
  int result = 0;
  while (*s) {
    int current = hex_char_to_int(*s);
    if (current == -1) return -1;
    result *= 16;
    result += current;
    ++s;
  }
  return result;
}
STATIC_OVL void
strunescape(char* s)
{
  char* in = s;
  char* out = s;
  bool unescapenext = false;
  while (*in) {
    if (unescapenext) {
      unescapenext = false;
      switch (*in) {
        case '0':
          *out++ = '\0';
          break;
        case 'a':
          *out++ = '\a';
          break;
        case 'b':
          *out++ = '\b';
          break;
        case 't':
          *out++ = '\t';
          break;
        case 'n':
          *out++ = '\n';
          break;
        case 'v':
          *out++ = '\v';
          break;
        case 'f':
          *out++ = '\f';
          break;
        case 'r':
          *out++ = '\r';
          break;
        case '\\':
          *out++ = '\\';
          break;
        case 'e':
          *out++ = '\x1B';
          break;
        case 'x': {
          char hex[3];
          if (*++in == 0) {
            *out++ = '\\';
            *out++ = 'x';
            continue;
          }
          hex[0] = *in;
          if (*++in == 0) {
            *out++ = '\\';
            *out++ = 'x';
            *out++ = hex[0];
            continue;
          }
          hex[1] = *in;
          hex[2] = 0;
          int result = hex_str_to_int(hex);
          if (result == -1) {
            *out++ = '\\';
            *out++ = 'x';
            *out++ = hex[0];
            *out++ = hex[1];
          }
          *out++ = result;
          break;
        }
        default:
          *out++ = '\\';
          *out++ = *in;
          break;
      }
      in++;
      continue;
    }
    if (*in == '\\') {
      unescapenext = true;
      in++;
      continue;
    }
    *out++ = *in++;
  }
  *out = 0;
}
STATIC_OVL bool
contains_only_spaces(const char* s)
{
  const char spaces[] = " \t";
  size_t nsp = strspn(s, spaces);
  return s[nsp] == '\0';
}
STATIC_OVL bool
is_a_vowel(int ch)
{
  switch (tolower((unsigned char)ch)) {
    case 'a':
    case 'e':
    case 'i':
    case 'o':
    case 'u': {
      return (true);
    }
  }
  return (false);
}
STATIC_OVL size_t
text_mbstowcs(wchar_t* dest, const char* src, int n)
{
  if (text_mbcs_hook)
    return (*text_mbcs_hook)(dest, src, n);
  else
    return mbstowcs(dest, src, n);
}
STATIC_OVL int
text_wctomb(char* s, wchar_t wchar)
{
  return (text_wctomb_hook) ? (*text_wctomb_hook)(s, wchar) : wctomb(s, wchar);
}
STATIC_OVL int
text_wcsz(void)
{
  return (text_wcsz_hook) ? (*text_wcsz_hook)() : MB_LEN_MAX;
}
STATIC_OVL int
text_iswprint(wint_t wc)
{
  return (text_iswprint_hook) ? (*text_iswprint_hook)(wc) : iswprint(wc);
}
STATIC_OVL void
plog(const char* str)
{
  if (plog_aux)
    (*plog_aux)(str);
  else
    (void)(fprintf(stderr, "%s: %s\n", argv0 ? argv0 : "?", str));
}
STATIC_OVL void
quit(const char* str)
{
  if (quit_aux) (*quit_aux)(str);
  if (!str) exit(EXIT_SUCCESS);
  plog(str);
  exit(EXIT_FAILURE);
}
STATIC_OVL int
mean(const int* nums, int size)
{
  int i, total = 0;
  for (i = 0; i < size; i++) total += nums[i];
  return total / size;
}
STATIC_OVL int
variance(const int* nums, int size)
{
  int i, avg, total = 0;
  avg = mean(nums, size);
  for (i = 0; i < size; i++) {
    int delta = nums[i] - avg;
    total += delta * delta;
  }
  return total / size;
}
STATIC_OVL void
sort(void* base, size_t nmemb, size_t smemb,
     int (*comp)(const void*, const void*))
{
  qsort(base, nmemb, smemb, comp);
}
STATIC_OVL uint32_t
djb2_hash(const char* str)
{
  uint32_t hash = 5381;
  int c = *str;
  while (c) {
    hash = ((hash << 5) + hash) + c;
    c = *++str;
  }
  return hash;
}
STATIC_OVL void*
mem_alloc(size_t len)
{
  if (!len) return NULL;
  void* p = malloc(len);
  if (!p) quit("Out of memory!");
  return p;
}
STATIC_OVL void*
mem_zalloc(size_t len)
{
  void* mem = mem_alloc(len);
  if (len) memset(mem, 0, len);
  return mem;
}
STATIC_OVL void
mem_free(void* p)
{
  free(p);
}
STATIC_OVL void*
mem_realloc(void* p, size_t len)
{
  if (!len) return NULL;
  p = realloc(p, len);
  if (!p) quit("Out of Memory!");
  return p;
}
STATIC_OVL char*
string_make(const char* str)
{
  char* res;
  size_t siz;
  if (!str) return NULL;
  siz = strlen(str) + 1;
  res = mem_alloc(siz);
  my_strcpy(res, str, siz);
  return res;
}
STATIC_OVL void
string_free(char* str)
{
  mem_free(str);
}
STATIC_OVL char*
string_append(char* s1, const char* s2)
{
  size_t len;
  if (!s1 && !s2) {
    return NULL;
  } else if (s1 && !s2) {
    return s1;
  } else if (!s1 && s2) {
    return string_make(s2);
  }
  len = strlen(s1);
  s1 = mem_realloc(s1, len + strlen(s2) + 1);
  my_strcpy(s1 + len, s2, strlen(s2) + 1);
  return s1;
}
STATIC_OVL void
quit_hook(const char* s)
{
  int j;
  (void)s;
  for (j = ANGBAND_TERM_MAX - 1; j >= 0; j--) {
    if (!angband_term[j]) continue;
    term_nuke(angband_term[j]);
  }
}
STATIC_OVL void
init_stuff(void)
{
  char configpath[512];
  char libpath[512];
  char datapath[512];
  my_strcpy(configpath, DEFAULT_CONFIG_PATH, sizeof(configpath));
  my_strcpy(libpath, DEFAULT_LIB_PATH, sizeof(libpath));
  my_strcpy(datapath, DEFAULT_DATA_PATH, sizeof(datapath));
  configpath[511] = '\0';
  libpath[511] = '\0';
  datapath[511] = '\0';
  if (!suffix(configpath, PATH_SEP))
    my_strcat(configpath, PATH_SEP, sizeof(configpath));
  if (!suffix(libpath, PATH_SEP)) my_strcat(libpath, PATH_SEP, sizeof(libpath));
  if (!suffix(datapath, PATH_SEP))
    my_strcat(datapath, PATH_SEP, sizeof(datapath));
  init_file_paths(configpath, libpath, datapath);
}
STATIC_OVL void
generic_reinit(void)
{
}
STATIC_OVL void
change_path(const char* info)
{
  char* info_copy = NULL;
  char* path = NULL;
  char* dir = NULL;
  unsigned int i = 0;
  char dirpath[512];
  if (!info || !info[0]) quit_fmt("Try '-d<dir>=<path>'.");
  info_copy = string_make(info);
  path = strtok(info_copy, "=");
  dir = strtok(NULL, "=");
  for (i = 0; i < N_ELEMENTS(change_path_values); i++) {
    if (my_stricmp(path, change_path_values[i].name) == 0) {
      string_free(*change_path_values[i].path);
      *change_path_values[i].path = string_make(dir);
      path_build(dirpath, sizeof(dirpath), dir, "");
      if (!dir_create(dirpath)) quit_fmt("Cannot create '%s'", dirpath);
      string_free(info_copy);
      return;
    }
  }
  quit_fmt("Unrecognised -d parameter %s", path);
}
STATIC_OVL void
user_name(char* buf, size_t len, int id)
{
  struct passwd* pw = getpwuid(id);
  if (!pw || !pw->pw_name || !pw->pw_name[0]) {
    my_strcpy(buf, "PLAYER", len);
    return;
  }
  my_strcpy(buf, pw->pw_name, len);
  my_strcap(buf);
}
STATIC_OVL void
list_saves(void)
{
  savefile_getter g = NULL;
  if (!got_savefile(&g)) {
    bool nodir = !got_savefile_dir(g);
    cleanup_savefile_getter(g);
    if (nodir) {
      quit_fmt("Cannot open savefile directory");
    }
    printf("There are no savefiles you can use.\n");
    return;
  }
  printf("Savefiles you can use are:\n");
  do {
    const struct savefile_details* details = get_savefile_details(g);
    if (details->desc) {
      printf(" %-15s  %s\n", details->fnam + details->foff, details->desc);
    } else {
      printf(" %-15s\n", details->fnam + details->foff);
    }
  } while (got_savefile(&g));
  printf("\nUse angband -u<name> to use savefile <name>.\n");
  cleanup_savefile_getter(g);
}
STATIC_OVL int
main(int argc, char* argv[])
{
  int i;
  bool new_game = false, select_game = false;
  bool done = false;
  const char* mstr = NULL;
  bool args = true;
  argv0 = argv[0];
  (void)umask(022);
  player_uid = getuid();
  safe_setuid_drop();
  init_stuff();
  for (i = 1; args && (i < argc); i++) {
    const char* arg = argv[i];
    if (*arg++ != '-') goto usage;
    switch (*arg++) {
      case 'c':
        select_game = true;
        break;
      case 'l':
        list_saves();
        exit(0);
      case 'n':
        new_game = true;
        break;
      case 'w':
        arg_wizard = true;
        break;
      case 'g':
        arg_graphics = 2;
        if (*arg) arg_graphics = atoi(arg);
        break;
      case 'u': {
        if (!*arg) goto usage;
        my_strcpy(arg_name, arg, sizeof(arg_name));
        savefile_set_name(arg, false, false);
        continue;
      }
      case 'f':
        arg_force_name = true;
        break;
      case 'm':
        if (!*arg) goto usage;
        mstr = arg;
        continue;
      case 'd':
        change_path(arg);
        continue;
      case '-':
        argv[i] = argv[0];
        argc = argc - i;
        argv = argv + i;
        args = false;
        break;
      default:
      usage:
        puts("Usage: angband [options] [-- subopts]");
        puts("  -c             Select savefile with a menu; overrides -n");
        puts(
            "  -n             Start a new character (WARNING: overwrites "
            "default savefile without -u)");
        puts("  -l             Lists all savefiles you can play");
        puts("  -w             Resurrect dead character (marks savefile)");
        puts("  -g             Request graphics mode");
        puts("  -u<who>        Use your <who> savefile");
        puts(
            "  -d<dir>=<path> Override a specific directory with <path>. "
            "<path> can be:");
        for (i = 0; i < (int)N_ELEMENTS(change_path_values); i++) {
          printf("    %s (default is %s)\n", change_path_values[i].name,
                 *change_path_values[i].path);
        }
        puts("                 Multiple -d options are allowed.");
        puts("  -m<sys>        Use module <sys>, where <sys> can be:");
        for (i = 0; i < (int)N_ELEMENTS(mmodules); i++)
          printf("     %s   %s\n", mmodules[i].name, mmodules[i].help);
        quit(NULL);
    }
    if (*arg) goto usage;
  }
  if (args) {
    argc = 1;
    argv[1] = NULL;
  }
  quit_aux = quit_hook;
  if (mstr) ANGBAND_SYS = mstr;
  if (setlocale(LC_CTYPE, "")) {
    if (!streq(nl_langinfo(CODESET), "UTF-8"))
      quit("Angband requires UTF-8 support");
  }
  if (!arg_name[0]) {
    user_name(arg_name, sizeof(arg_name), player_uid);
    savefile_set_name(arg_name, true, false);
  }
  create_needed_dirs();
  for (i = 0; i < (int)N_ELEMENTS(mmodules); i++) {
    if (!mstr || (streq(mstr, mmodules[i].name))) {
      ANGBAND_SYS = mmodules[i].name;
      if (0 == mmodules[i].init(argc, argv)) {
        done = true;
        break;
      }
    }
  }
  if (!done) quit("Unable to prepare any 'display module'!");
  signals_init();
  cmd_get_hook = textui_get_cmd;
  reinit_hook = generic_reinit;
  generic_reinit();
  init_display();
  init_angband();
  textui_init();
  pause_line(Term);
  play_game((select_game) ? GAME_SELECT : ((new_game) ? GAME_NEW : GAME_LOAD));
  textui_cleanup();
  cleanup_angband();
  quit(NULL);
  return (0);
}

#define term System_term
#include <ncurses.h>
#include <term.h>
#undef term
typedef struct term_data {
  term t;
  rect_t r;
  WINDOW* win;
} term_data;
static term_data data[6];
static int bg_color = COLOR_BLACK;

rect_t
rect(int x, int y, int cx, int cy)
{
  rect_t r;
  r.x = x;
  r.y = y;
  r.cx = cx;
  r.cy = cy;
  return r;
}
void
keymap_norm(void)
{
  (void)tcsetattr(0, TCSAFLUSH, &norm_termios);
}
void
keymap_game(void)
{
  (void)tcsetattr(0, TCSAFLUSH, &game_termios);
}
void
keymap_norm_prepare(void)
{
  tcgetattr(0, &norm_termios);
}
void
keymap_game_prepare(void)
{
  tcgetattr(0, &game_termios);
  game_termios.c_cc[VINTR] = (char)3;
  game_termios.c_cc[VSUSP] = (char)26;
  game_termios.c_cc[VQUIT] = (char)-1;
  game_termios.c_cc[VERASE] = (char)-1;
  game_termios.c_cc[VKILL] = (char)-1;
  game_termios.c_cc[VEOF] = (char)-1;
  game_termios.c_cc[VEOL] = (char)-1;
  game_termios.c_cc[VMIN] = 1;
  game_termios.c_cc[VTIME] = 0;
  game_termios.c_iflag &= ~IXON;
}
errr
Term_xtra_gcu_alive(int v)
{
  if (!v) {
    int x, y;
    keymap_norm();
    nocbreak();
    echo();
    nl();
    Term_xtra(TERM_XTRA_SHAPE, 1);
    refresh();
    getyx(stdscr, y, x);
    mvcur(y, x, LINES - 1, 0);
    endwin();
    fflush(stdout);
  } else {
    cbreak();
    noecho();
    nonl();
    keymap_game();
  }
  return 0;
}
void
Term_init_gcu(term* t)
{
  term_data* td = (term_data*)(t->data);
  wrefresh(stdscr);
  if (active++ != 0) return;
  mousemask(ALL_MOUSE_EVENTS, NULL);
  wclear(td->win);
  wmove(td->win, 0, 0);
  wrefresh(td->win);
  keymap_game();
}
void
Term_nuke_gcu(term* t)
{
  int x, y;
  term_data* td = (term_data*)(t->data);
  delwin(td->win);
  if (--active != 0) return;
  Term_xtra(TERM_XTRA_SHAPE, 1);
  start_color();
  getyx(stdscr, y, x);
  mvcur(y, x, LINES - 1, 0);
  refresh();
  endwin();
  fflush(stdout);
  keymap_norm();
}
void
balance_dimension(int* size, int* start, int term_group_index,
                  int term_group_count, int window_size, int min_term0_size,
                  int comfy_subterm_size)
{
  int subterm_group_count = term_group_count - 1;
  if (term_group_index == 0) {
    *size = MAX(min_term0_size,
                window_size - subterm_group_count * (min_term0_size + 1));
    *start = 0;
  } else if (term_group_index == term_group_count - 1) {
    if (window_size <=
        min_term0_size + subterm_group_count * (comfy_subterm_size + 1)) {
      *size = (window_size - min_term0_size - subterm_group_count) /
              subterm_group_count;
      if (window_size >
          min_term0_size + subterm_group_count + *size * subterm_group_count)
        (*size)++;
    } else {
      *size = MIN(min_term0_size,
                  window_size - min_term0_size -
                      comfy_subterm_size * (subterm_group_count - 1) -
                      subterm_group_count);
    }
    *start = window_size - *size;
  } else {
    if (window_size <=
        subterm_group_count * (min_term0_size + 1) + comfy_subterm_size) {
      *size = MIN(comfy_subterm_size,
                  (window_size - min_term0_size - subterm_group_count) /
                      subterm_group_count);
    } else {
      *size = MIN(min_term0_size,
                  window_size - subterm_group_count * (min_term0_size + 1));
    }
    *start = 1 + MAX(min_term0_size,
                     window_size - subterm_group_count * (min_term0_size + 1));
  }
}
void
get_gcu_term_size(int i, int* rows, int* cols, int* y, int* x)
{
  bool is_wide = (10 * LINES < 3 * COLS);
  int term_rows = 1;
  int term_cols = 1;
  int term_row_index = 0;
  int term_col_index = 0;
  assert(i < term_count);
  if (is_wide) {
    while (term_rows * (term_rows + 1) < term_count) term_rows++;
    while (term_cols * term_cols < term_count) term_cols++;
    if (term_count == 3) {
      term_rows = 1;
      term_cols = 3;
    }
    term_col_index = i % term_cols;
    term_row_index = (int)(i / term_cols);
  } else {
    while (term_rows * term_rows < term_count) term_rows++;
    while (term_cols * (term_cols + 1) < term_count) term_cols++;
    if (term_count == 3) {
      term_rows = 3;
      term_cols = 1;
    }
    term_col_index = (int)(i / term_rows);
    term_row_index = i % term_rows;
  }
  if (LINES < 24 + 2 * (term_rows - 1) || COLS < 80 + 2 * (term_cols - 1)) {
    term_rows = term_cols = term_count = 1;
    if (i != 0) {
      *rows = *cols = *y = *x = 0;
    }
    term_col_index = term_row_index = 0;
  }
  balance_dimension(cols, x, term_col_index, term_cols, COLS, 80, 40);
  balance_dimension(rows, y, term_row_index, term_rows, LINES, 24, 5);
}
void
do_gcu_resize(void)
{
  int i, rows, cols, y, x;
  term* old_t = Term;
  for (i = 0; i < term_count; i++) {
    Term_activate(&data[i].t);
    get_gcu_term_size(i, &rows, &cols, &y, &x);
    if (wresize(data[i].win, rows, cols) == OK) Term_resize(cols, rows);
    Term_activate(old_t);
  }
  do_cmd_redraw();
}
errr
Term_xtra_gcu_event(int v)
{
  int i, j, k, mods = 0;
  if (v) {
    halfdelay(2);
    i = getch();
    while (i == ERR) {
      i = getch();
      idle_update();
    }
    cbreak();
  } else {
    nodelay(stdscr, true);
    i = getch();
    nodelay(stdscr, false);
    if (i == ERR) return (1);
    if (i == EOF) return (1);
  }
  if (i == KEY_RESIZE) {
    halfdelay(10);
    do {
      i = getch();
    } while (i == KEY_RESIZE);
    cbreak();
    do_gcu_resize();
    if (i == ERR) return (1);
  }
  if (i == KEY_MOUSE) {
    MEVENT m;
    if (getmouse(&m) != OK) return (0);
    int b = 0;
    if (m.bstate & BUTTON1_CLICKED)
      b = 1;
    else if (m.bstate & BUTTON2_CLICKED)
      b = 2;
    else if (m.bstate & BUTTON3_CLICKED)
      b = 3;
    else if (m.bstate & BUTTON4_CLICKED)
      b = 4;
    if (m.bstate & BUTTON_SHIFT) b |= (KC_MOD_SHIFT << 4);
    if (m.bstate & BUTTON_CTRL) b |= (KC_MOD_CONTROL << 4);
    if (m.bstate & BUTTON_ALT) b |= (KC_MOD_ALT << 4);
    if (b != 0) Term_mousepress(m.x, m.y, b);
    return (0);
  }
  if (i == 27) {
    nodelay(stdscr, true);
    j = getch();
    switch (j) {
      case 'O': {
        k = getch();
        switch (k) {
          case 'q':
            i = '1';
            break;
          case 'r':
            i = '2';
            break;
          case 's':
            i = '3';
            break;
          case 't':
            i = '4';
            break;
          case 'u':
            i = '5';
            break;
          case 'v':
            i = '6';
            break;
          case 'w':
            i = '7';
            break;
          case 'x':
            i = '8';
            break;
          case 'y':
            i = '9';
            break;
          case ERR:
            break;
          default:
            ungetch(k);
            ungetch(j);
        }
        break;
      }
      case ERR:
        break;
      default:
        ungetch(j);
    }
    nodelay(stdscr, false);
  }
  Term_keypress(i, mods);
  return (0);
}
int
scale_color(int i, int j, int scale)
{
  return (angband_color_table[i][j] * (scale - 1) + 127) / 255;
}
int
create_color(int i, int scale)
{
  int r = scale_color(i, 1, scale);
  int g = scale_color(i, 2, scale);
  int b = scale_color(i, 3, scale);
  int rgb = 16 + scale * scale * r + scale * g + b;
  if (r == g && g == b) {
    if (b == 0) rgb = 0;
    if (b == scale) rgb = 15;
  }
  return rgb;
}
void
handle_extended_color_tables(void)
{
  if (COLORS == 256 || COLORS == 88) {
    int isbold = bold_extended ? A_BOLD : A_NORMAL;
    int i;
    if (keep_terminal_colors) {
      int scale = COLORS == 256 ? 6 : 4;
      bg_color = create_color(COLOUR_DARK, scale);
      for (i = 0; i < BASIC_COLORS; i++) {
        int fg = create_color(i, scale);
        init_pair(i + 1, fg, bg_color);
        colortable[i] = COLOR_PAIR(i + 1) | isbold;
        init_pair(BASIC_COLORS + i, fg, fg);
        same_colortable[i] = COLOR_PAIR(BASIC_COLORS + i) | isbold;
      }
    } else {
      bg_color = 0;
      for (i = 0; i < BASIC_COLORS; i++) {
        init_color(i, (angband_color_table[i][1] * 1001) / 256,
                   (angband_color_table[i][2] * 1001) / 256,
                   (angband_color_table[i][3] * 1001) / 256);
        init_pair(i + 1, i, bg_color);
        colortable[i] = COLOR_PAIR(i + 1) | isbold;
        init_pair(BASIC_COLORS + i, i, i);
        same_colortable[i] = COLOR_PAIR(BASIC_COLORS + i) | isbold;
      }
    }
    for (i = 0; i < term_count; ++i) {
      if (data[i].win) {
        wbkgdset(data[i].win, ' ' | colortable[COLOUR_DARK]);
      }
    }
    if (data[0].win) {
      chtype term0_bkg = getbkgd(data[0].win);
      if (getbkgd(stdscr) != term0_bkg) {
        wbkgd(stdscr, term0_bkg);
        wrefresh(stdscr);
      }
    }
  }
}
errr
Term_xtra_gcu(int n, int v)
{
  term_data* td = (term_data*)(Term->data);
  switch (n) {
    case TERM_XTRA_CLEAR:
      touchwin(td->win);
      wclear(td->win);
      return 0;
    case TERM_XTRA_NOISE:
      write(1, "\007", 1);
      return 0;
    case TERM_XTRA_FRESH:
      wrefresh(td->win);
      return 0;
    case TERM_XTRA_SHAPE:
      curs_set(v);
      return 0;
    case TERM_XTRA_ALIVE:
      return Term_xtra_gcu_alive(v);
    case TERM_XTRA_EVENT:
      return Term_xtra_gcu_event(v);
    case TERM_XTRA_FLUSH:
      while (!Term_xtra_gcu_event(false))
        ;
      return 0;
    case TERM_XTRA_DELAY:
      if (v > 0) usleep(1000 * v);
      return 0;
    case TERM_XTRA_REACT:
      handle_extended_color_tables();
      return 0;
  }
  return 1;
}
errr
Term_curs_gcu(int x, int y)
{
  term_data* td = (term_data*)(Term->data);
  wmove(td->win, y, x);
  return 0;
}
errr
Term_wipe_gcu(int x, int y, int n)
{
  term_data* td = (term_data*)(Term->data);
  wmove(td->win, y, x);
  if (x + n >= td->t.wid) {
    wclrtoeol(td->win);
  } else {
    if (can_use_color) {
      wattrset(td->win, colortable[COLOUR_DARK] | A_NORMAL);
    }
    whline(td->win, ' ', n);
    if (can_use_color) {
      wattrset(td->win, A_NORMAL);
    }
  }
  return 0;
}
errr
Term_text_gcu(int x, int y, int n, int a, const wchar_t* s)
{
  term_data* td = (term_data*)(Term->data);
  if (can_use_color) {
    int attr = a & 127;
    bool reversed = a > 127;
    int color;
    if (a / MULT_BG == BG_SAME) {
      color = same_colortable[attr];
    } else {
      color = colortable[attr];
    }
    int mode;
    if (reversed && (color & A_BOLD))
      mode = (color & ~A_BOLD) | A_BLINK | A_REVERSE;
    else if (reversed)
      mode = color | A_REVERSE;
    else
      mode = color | A_NORMAL;
    wattrset(td->win, mode);
    mvwaddnwstr(td->win, y, x, s, n);
    wattrset(td->win, A_NORMAL);
    return 0;
  }
  mvwaddnwstr(td->win, y, x, s, n);
  return 0;
}
errr
term_data_init_gcu(term_data* td, int rows, int cols, int y, int x)
{
  term* t = &td->t;
  td->win = newwin(rows, cols, y, x);
  if (!td->win) quit("Failed to setup curses window.");
  term_init(t, cols, rows, 256);
  t->icky_corner = true;
  t->complex_input = true;
  t->init_hook = Term_init_gcu;
  t->nuke_hook = Term_nuke_gcu;
  t->text_hook = Term_text_gcu;
  t->wipe_hook = Term_wipe_gcu;
  t->curs_hook = Term_curs_gcu;
  t->xtra_hook = Term_xtra_gcu;
  t->data = td;
  Term_activate(t);
  return (0);
}
errr
term_data_init(term_data* td)
{
  return term_data_init_gcu(td, td->r.cy, td->r.cx, td->r.y, td->r.x);
}
int
_parse_size_list(const char* arg, int sizes[], int max)
{
  int i = 0;
  const char* start = arg;
  const char* stop = arg;
  for (;;) {
    if (!*stop || !isdigit(*stop)) {
      if (i >= max) break;
      if (*start == '*')
        sizes[i] = 255;
      else {
        sizes[i] = atoi(start);
      }
      i++;
      if (!*stop || *stop != ',') break;
      stop++;
      start = stop;
    } else
      stop++;
  }
  return i;
}
void
hook_quit(const char* str)
{
  int i;
  for (i = 0; i < term_count; i++) {
    if (angband_term[i]) {
      term_nuke(angband_term[i]);
    }
  }
  endwin();
}
errr
init_gcu(int argc, char** argv)
{
  int i;
  termtype = getenv("TERM");
  loaded_terminfo = termtype && tgetent(0, termtype) == 1;
  for (i = 1; i < argc; i++) {
    if (prefix(argv[i], "-B")) {
      bold_extended = true;
    } else if (prefix(argv[i], "-n")) {
      term_count = atoi(&argv[i][2]);
      if (term_count > 6)
        term_count = 6;
      else if (term_count < 1)
        term_count = 1;
    } else if (prefix(argv[i], "-D")) {
      use_default_background = true;
    } else if (streq(argv[i], "-K")) {
      keep_terminal_colors = true;
    }
  }
  keymap_norm_prepare();
  if (!getenv("ESCDELAY")) {
    static char escdelbuf[80] = "ESCDELAY=20";
    putenv(escdelbuf);
  }
  if (initscr() == NULL) return (-1);
  quit_aux = hook_quit;
  if (LINES < 24 || COLS < 80)
    quit("Angband needs at least an 80x24 'curses' screen");
  can_use_color = ((start_color() != ERR) && has_colors() && (COLORS >= 8) &&
                   (COLOR_PAIRS >= 8));
  if (!can_change_color()) keep_terminal_colors = true;
  if (use_default_background && use_default_colors() == OK) bg_color = -1;
  if (can_use_color) {
    init_pair(1, COLOR_RED, bg_color);
    init_pair(2, COLOR_GREEN, bg_color);
    init_pair(3, COLOR_YELLOW, bg_color);
    init_pair(4, COLOR_BLUE, bg_color);
    init_pair(5, COLOR_MAGENTA, bg_color);
    init_pair(6, COLOR_CYAN, bg_color);
    init_pair(7, COLOR_BLACK, bg_color);
    init_pair(8, COLOR_WHITE, COLOR_WHITE);
    init_pair(9, COLOR_RED, COLOR_RED);
    init_pair(10, COLOR_GREEN, COLOR_GREEN);
    init_pair(11, COLOR_YELLOW, COLOR_YELLOW);
    init_pair(12, COLOR_BLUE, COLOR_BLUE);
    init_pair(13, COLOR_MAGENTA, COLOR_MAGENTA);
    init_pair(14, COLOR_CYAN, COLOR_CYAN);
    init_pair(15, COLOR_BLACK, COLOR_BLACK);
    colortable[COLOUR_DARK] = (COLOR_PAIR(7));
    colortable[COLOUR_WHITE] = (COLOR_PAIR(0) | A_BOLD);
    colortable[COLOUR_SLATE] = (COLOR_PAIR(0));
    colortable[COLOUR_ORANGE] = (COLOR_PAIR(3) | A_BOLD);
    colortable[COLOUR_RED] = (COLOR_PAIR(1));
    colortable[COLOUR_GREEN] = (COLOR_PAIR(2));
    colortable[COLOUR_BLUE] = (COLOR_PAIR(4));
    colortable[COLOUR_UMBER] = (COLOR_PAIR(3));
    colortable[COLOUR_L_DARK] = (COLOR_PAIR(7) | A_BOLD);
    colortable[COLOUR_L_WHITE] = (COLOR_PAIR(0));
    colortable[COLOUR_L_PURPLE] = (COLOR_PAIR(5));
    colortable[COLOUR_YELLOW] = (COLOR_PAIR(3) | A_BOLD);
    colortable[COLOUR_L_RED] = (COLOR_PAIR(5) | A_BOLD);
    colortable[COLOUR_L_GREEN] = (COLOR_PAIR(2) | A_BOLD);
    colortable[COLOUR_L_BLUE] = (COLOR_PAIR(4) | A_BOLD);
    colortable[COLOUR_L_UMBER] = (COLOR_PAIR(3));
    colortable[COLOUR_PURPLE] = (COLOR_PAIR(5));
    colortable[COLOUR_VIOLET] = (COLOR_PAIR(5));
    colortable[COLOUR_TEAL] = (COLOR_PAIR(6));
    colortable[COLOUR_MUD] = (COLOR_PAIR(3));
    colortable[COLOUR_L_YELLOW] = (COLOR_PAIR(3 | A_BOLD));
    colortable[COLOUR_MAGENTA] = (COLOR_PAIR(5 | A_BOLD));
    colortable[COLOUR_L_TEAL] = (COLOR_PAIR(6) | A_BOLD);
    colortable[COLOUR_L_VIOLET] = (COLOR_PAIR(5) | A_BOLD);
    colortable[COLOUR_L_PINK] = (COLOR_PAIR(5) | A_BOLD);
    colortable[COLOUR_MUSTARD] = (COLOR_PAIR(3));
    colortable[COLOUR_BLUE_SLATE] = (COLOR_PAIR(4));
    colortable[COLOUR_DEEP_L_BLUE] = (COLOR_PAIR(4));
    same_colortable[COLOUR_DARK] = (COLOR_PAIR(15));
    same_colortable[COLOUR_WHITE] = (COLOR_PAIR(8) | A_BOLD);
    same_colortable[COLOUR_SLATE] = (COLOR_PAIR(8));
    same_colortable[COLOUR_ORANGE] = (COLOR_PAIR(11) | A_BOLD);
    same_colortable[COLOUR_RED] = (COLOR_PAIR(9));
    same_colortable[COLOUR_GREEN] = (COLOR_PAIR(10));
    same_colortable[COLOUR_BLUE] = (COLOR_PAIR(12));
    same_colortable[COLOUR_UMBER] = (COLOR_PAIR(11));
    same_colortable[COLOUR_L_DARK] = (COLOR_PAIR(15) | A_BOLD);
    same_colortable[COLOUR_L_WHITE] = (COLOR_PAIR(8));
    same_colortable[COLOUR_L_PURPLE] = (COLOR_PAIR(13));
    same_colortable[COLOUR_YELLOW] = (COLOR_PAIR(11) | A_BOLD);
    same_colortable[COLOUR_L_RED] = (COLOR_PAIR(13) | A_BOLD);
    same_colortable[COLOUR_L_GREEN] = (COLOR_PAIR(10) | A_BOLD);
    same_colortable[COLOUR_L_BLUE] = (COLOR_PAIR(12) | A_BOLD);
    same_colortable[COLOUR_L_UMBER] = (COLOR_PAIR(11));
    same_colortable[COLOUR_PURPLE] = (COLOR_PAIR(13));
    same_colortable[COLOUR_VIOLET] = (COLOR_PAIR(13));
    same_colortable[COLOUR_TEAL] = (COLOR_PAIR(14));
    same_colortable[COLOUR_MUD] = (COLOR_PAIR(11));
    same_colortable[COLOUR_L_YELLOW] = (COLOR_PAIR(11) | A_BOLD);
    same_colortable[COLOUR_MAGENTA] = (COLOR_PAIR(13) | A_BOLD);
    same_colortable[COLOUR_L_TEAL] = (COLOR_PAIR(14) | A_BOLD);
    same_colortable[COLOUR_L_VIOLET] = (COLOR_PAIR(13) | A_BOLD);
    same_colortable[COLOUR_L_PINK] = (COLOR_PAIR(13) | A_BOLD);
    same_colortable[COLOUR_MUSTARD] = (COLOR_PAIR(3));
    same_colortable[COLOUR_BLUE_SLATE] = (COLOR_PAIR(4));
    same_colortable[COLOUR_DEEP_L_BLUE] = (COLOR_PAIR(4));
    handle_extended_color_tables();
  }
  nodelay(stdscr, false);
  cbreak();
  noecho();
  nonl();
  raw();
  keypad(stdscr, true);
  keymap_game_prepare();
  if (term_count > 1) {
    int rows, cols, y, x;
    int next_win = 0;
    for (i = 0; i < term_count; i++) {
      get_gcu_term_size(i, &rows, &cols, &y, &x);
      if (rows <= 0 || cols <= 0) continue;
      term_data_init_gcu(&data[next_win], rows, cols, y, x);
      angband_term[next_win] = &data[next_win].t;
      next_win++;
    }
  } else {
    rect_t remaining = rect(0, 0, COLS, LINES);
    int spacer_cx = 1;
    int spacer_cy = 1;
    int next_term = 1;
    int term_ct = 1;
    for (i = 1; i < argc; i++) {
      if (streq(argv[i], "-spacer")) {
        char *pe, *ystr;
        long lv;
        i++;
        if (i >= argc) quit("Missing size specifier for -spacer");
        lv = strtol(argv[i], &pe, 10);
        if (pe == argv[i] || *pe != 'x' || lv <= INT_MIN || lv >= INT_MAX) {
          quit_fmt("Invalid specification for -spacer; got %s", argv[i]);
        }
        spacer_cx = (int)lv;
        ystr = pe + 1;
        lv = strtol(ystr, &pe, 10);
        if (pe == ystr || !contains_only_spaces(pe) || lv <= INT_MIN ||
            lv >= INT_MAX) {
          quit_fmt("Invalid specification for -spacer; got %s", argv[i]);
        }
        spacer_cy = (int)lv;
      } else if (streq(argv[i], "-right") || streq(argv[i], "-left")) {
        const char *arg, *tmp;
        bool left = streq(argv[i], "-left");
        int cx, cys[6] = {0}, ct, j, x, y;
        i++;
        if (i >= argc)
          quit(format("Missing size specifier for -%s",
                      left ? "left" : "right"));
        arg = argv[i];
        tmp = strchr(arg, 'x');
        if (!tmp)
          quit(
              format("Expected something like -%s 60x27,* for two %s hand "
                     "terminals of 60 columns, the first 27 lines and the "
                     "second whatever is left.",
                     left ? "left" : "right", left ? "left" : "right"));
        cx = atoi(arg);
        remaining.cx -= cx;
        if (left) {
          x = remaining.x;
          y = remaining.y;
          remaining.x += cx;
        } else {
          x = remaining.x + remaining.cx;
          y = remaining.y;
        }
        remaining.cx -= spacer_cx;
        if (left) remaining.x += spacer_cx;
        tmp++;
        ct = _parse_size_list(tmp, cys, 6);
        for (j = 0; j < ct; j++) {
          int cy = cys[j];
          if (y + cy > remaining.y + remaining.cy)
            cy = remaining.y + remaining.cy - y;
          if (next_term >= 6)
            quit(format("Too many terminals. Only %d are allowed.", 6));
          if (cy <= 0) {
            quit(
                format("Out of bounds in -%s: %d is too large (%d rows max for "
                       "this strip)",
                       left ? "left" : "right", cys[j], remaining.cy));
          }
          data[next_term++].r = rect(x, y, cx, cy);
          y += cy + spacer_cy;
          term_ct++;
        }
      } else if (streq(argv[i], "-top") || streq(argv[i], "-bottom")) {
        const char *arg, *tmp;
        bool top = streq(argv[i], "-top");
        int cy, cxs[6] = {0}, ct, j, x, y;
        i++;
        if (i >= argc)
          quit(
              format("Missing size specifier for -%s", top ? "top" : "bottom"));
        arg = argv[i];
        tmp = strchr(arg, 'x');
        if (!tmp)
          quit(
              format("Expected something like -%s *x7 for a single %s terminal "
                     "of 7 lines using as many columns as are available.",
                     top ? "top" : "bottom", top ? "top" : "bottom"));
        tmp++;
        cy = atoi(tmp);
        ct = _parse_size_list(arg, cxs, 6);
        remaining.cy -= cy;
        if (top) {
          x = remaining.x;
          y = remaining.y;
          remaining.y += cy;
        } else {
          x = remaining.x;
          y = remaining.y + remaining.cy;
        }
        remaining.cy -= spacer_cy;
        if (top) remaining.y += spacer_cy;
        tmp++;
        for (j = 0; j < ct; j++) {
          int cx = cxs[j];
          if (x + cx > remaining.x + remaining.cx)
            cx = remaining.x + remaining.cx - x;
          if (next_term >= 6)
            quit(format("Too many terminals. Only %d are allowed.", 6));
          if (cx <= 0) {
            quit(
                format("Out of bounds in -%s: %d is too large (%d cols max for "
                       "this strip)",
                       top ? "top" : "bottom", cxs[j], remaining.cx));
          }
          data[next_term++].r = rect(x, y, cx, cy);
          x += cx + spacer_cx;
          term_ct++;
        }
      }
    }
    if (remaining.cx < 80 || remaining.cy < 24)
      quit(format("Failed: angband needs an %dx%d map screen, not %dx%d", 80,
                  24, remaining.cx, remaining.cy));
    data[0].r = remaining;
    term_data_init(&data[0]);
    angband_term[0] = Term;
    for (next_term = 1; next_term < term_ct; next_term++) {
      term_data_init(&data[next_term]);
      angband_term[next_term] = Term;
    }
  }
  Term_activate(&data[0].t);
  term_screen = &data[0].t;
  return (0);
}
errr
init_spoil(int argc, char* argv[])
{
  int i = 1;
  int result = 0;
  while (1) {
    bool badarg = false;
    int increment = 1;
    if (i >= argc) {
      break;
    }
    if (argv[i][0] == '-') {
      int j = 0;
      while (1) {
        if (j >= (int)N_ELEMENTS(opts)) {
          badarg = true;
          break;
        }
        if (argv[i][1] == opts[j].letter && argv[i][2] == '\0') {
          if (i < argc - 1) {
            opts[j].enabled = true;
            opts[j].path = argv[i + 1];
            ++increment;
          } else {
            printf(
                "init-spoil: '%s' requires an argument, the name of the "
                "spoiler file\n",
                argv[i]);
            result = 1;
          }
          break;
        }
        ++j;
      }
    } else {
      badarg = true;
    }
    if (badarg) {
      printf("init-spoil: bad argument '%s'\n", argv[i]);
      result = 1;
    }
    i += increment;
  }
  if (result != 0) return result;
  init_angband();
  if (!player_make_simple(NULL, NULL, NULL, "Spoiler")) {
    printf("init-spoil: could not initialize player.\n");
    result = 1;
  }
  if (result == 0) {
    flavor_set_all_aware();
    for (i = 0; i < (int)N_ELEMENTS(opts); ++i) {
      if (!opts[i].enabled) continue;
      (*(opts[i].func))(opts[i].path);
    }
  }
  cleanup_angband();
  if (result == 0) {
    exit(0);
  }
  return result;
}
